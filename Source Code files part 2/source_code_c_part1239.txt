 must ensure consistency between m_OldDmaPosition, m_ulDmaComplete and
    // m_irpStreamPosition (ullMappingPosition, ullMappingOffset and ullStreamPosition).
    //
    // These are used by GetPosition to compute the PlayOffset and WriteOffset.  A lock
    // must cover access to m_OldDmaPosition and m_irpStreamPosition across the looped
    // call to IrpStream->Complete(), which alters m_irpStreamPosition.  We also always
    // take this lock before m_ksSpinLockDpc.  Specifically, the lock hierachy is:
    //
    //   pServiceGroupSpinLock > m_IrpStream->m_irpStreamPositionLock > m_ksSpinLockDpc
    //
    KSPIN_LOCK *pIrpStreamPositionLock;
    pIrpStreamPositionLock = m_IrpStream->GetIrpStreamPositionLock();
    KeAcquireSpinLockAtDpcLevel(pIrpStreamPositionLock);
    KeAcquireSpinLockAtDpcLevel(&m_ksSpinLockDpc);

#if (DBG)
    //
    // Measure inter-service times.
    //
    ULONGLONG ullTime = KeQueryPerformanceCounter(NULL).QuadPart;
    if (m_ullServiceTime)
    {
        ULONG ulDelta = ULONG(ullTime - m_ullServiceTime);
        m_ullServiceIntervalSum += ulDelta;
        if (m_ulMaxServiceInterval < ulDelta)
        {
            m_ulMaxServiceInterval = ulDelta;
        }
    }
    m_ullServiceTime = ullTime;
#endif

    //
    // Count visits to this function.
    //
    m_ullServiceCount++;

    ULONG ulDmaPosition;
    NTSTATUS ntStatus = m_Stream->GetPosition(&ulDmaPosition);

    // check to see if DMA is moving
    if( ulDmaPosition != m_OldDmaPosition )
    {
        // zero the "SecondsSinceDmaMove" timeout count
        InterlockedExchange( PLONG(&m_SecondsSinceDmaMove), 0 );
    }
    m_OldDmaPosition = ulDmaPosition;

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Keep a count of cycles for physical clock position
        //
        if (ulDmaPosition < m_ulDmaPosition)
        {
            m_ulDmaCycles++;
        }

        //
        // Cache the buffer size.
        //
        ULONG ulDmaBufferSize = m_DmaChannel->BufferSize();

        //
        // If we're past the end of the buffer, treat as 0.
        //
        if (ulDmaPosition >= ulDmaBufferSize)
        {
            ulDmaPosition = 0;
        }

        m_ulDmaPosition = ulDmaPosition;

        //
        // Make sure we are aligned on a frame boundary.
        //
        ULONG ulFrameAlignment = ulDmaPosition % m_ulSampleSize;
        if (ulFrameAlignment)
        {
            if (m_DataFlow == KSPIN_DATAFLOW_IN)
            {
                //
                // Render:  round up.
                //
                ulDmaPosition =
                    (   (   (   ulDmaPosition
                            +   m_ulSampleSize
                            )
                        -   ulFrameAlignment
                        )
                    %   ulDmaBufferSize
                    );
            }
            else
            {
                //
                // Capture:  round down.
                //
                ulDmaPosition -= ulFrameAlignment;
            }
        }

        ASSERT(ulDmaPosition % m_ulSampleSize == 0);

#ifdef DEBUG_WAVECYC_DPC
        if( DebugEnable )
        {
            PUSHORT Samples = PUSHORT(PUCHAR(m_DmaChannel->SystemAddress()) + ulDmaPosition);
            DebugRecord[DebugRecordCount].DbgPinState = m_DeviceState;
            DebugRecord[DebugRecordCount].DbgDmaPosition = ulDmaPosition;
            DebugRecord[DebugRecordCount].DbgBufferSize = ulDmaBufferSize;
            DebugRecord[DebugRecordCount].DbgSampleSize = m_ulSampleSize;
            DebugRecord[DebugRecordCount].DbgSetPosition = m_bSetPosition;
            DebugRecord[DebugRecordCount].DbgStarvation = FALSE;
            DebugRecord[DebugRecordCount].DbgFrameSize = m_FrameSize;
            if( ulDmaPosition + 4 * sizeof(USHORT) < ulDmaBufferSize )
            {
                DebugRecord[DebugRecordCount].DbgDmaSamples[0] = Samples[0];
                DebugRecord[DebugRecordCount].DbgDmaSamples[1] = Samples[1];
                DebugRecord[DebugRecordCount].DbgDmaSamples[2] = Samples[2];
                DebugRecord[DebugRecordCount].DbgDmaSamples[3] = Samples[3];
            } else
            {
                DebugRecord[DebugRecordCount].DbgDmaSamples[0] = USHORT(-1);
                DebugRecord[DebugRecordCount].DbgDmaSamples[1] = USHORT(-1);
                DebugRecord[DebugRecordCount].DbgDmaSamples[2] = USHORT(-1);
                DebugRecord[DebugRecordCount].DbgDmaSamples[3] = USHORT(-1);
            }
        }
#endif

        //
        // Handle set position.
        //
        if (m_bSetPosition)
        {
            m_bSetPosition      = FALSE;
            m_ulDmaComplete     = ulDmaPosition;
            m_ulDmaCopy         = ulDmaPosition;
            m_ulDmaWindowSize   = 0;
        }

        ULONG ulBytesToComplete;
        ULONG ulBytesToCopyFirst;

        if (m_DataFlow == KSPIN_DATAFLOW_IN)
        {
            //
            // RENDER!
            //

            //
            // Determine if we have starved.
            //
            if
            (   (   (m_ulDmaComplete < m_ulDmaCopy)
                &&  (   (ulDmaPosition < m_ulDmaComplete)
                    ||  (m_ulDmaCopy < ulDmaPosition)
                    )
                )
            ||  (   (m_ulDmaCopy < m_ulDmaComplete)
                &&  (m_ulDmaCopy < ulDmaPosition)
                &&  (ulDmaPosition < m_ulDmaComplete)
                )
            ||  (   (m_ulDmaWindowSize == 0)
                &&  (ulDmaPosition != m_ulDmaCopy)
                )
            )
            {
                if (m_SetPropertyIsPending)
                {
                    if ( !InterlockedExchange((LPLONG)&m_WorkItemIsPending, TRUE))
                    {
/*                          Queue a PASSIVE_LEVEL worker item, which will:
                              Put the pin in PAUSE state,
                              Set the data format,
                              Complete the m_pPendingSetFormatIrp,
                              Set m_pPendingSetFormatIrp to zero,
                              Put the pin in RUN state.
*/
                            ::ExQueueWorkItem(  &m_SetFormatWorkItem,
                                                DelayedWorkQueue   );
                    }   //  otherwise, the WorkItem's already been queued
                }
                //
                // Starved!  Keep records.
                //
                m_ullStarvationCount++;
                m_ullStarvationBytes +=
                    (   (   (   ulDmaPosition
                            +   ulDmaBufferSize
                            )
                        -   m_ulDmaCopy
                        )
                    %   ulDmaBufferSize
                    );

                LogDMAGlitch = PERFGLITCH_PORTCLSGLITCH;

#ifdef DEBUG_WAVECYC_DPC
                if( DebugEnable )
                {
                    DebugRecord[DebugRecordCount].DbgStarvation = TRUE;
                    DebugRecord[DebugRecordCount].DbgStarvationBytes =
                        (((ulDmaPosition+ulDmaBufferSize)-m_ulDmaCopy)%ulDmaBufferSize);
                }
#endif

                //
                // Move copy position to match dma position.
                //
                m_ulDmaCopy = ulDmaPosition;

                //
                // Move the complete position to get the right window size.
                //
                m_ulDmaComplete =
                    (   (   (   ulDmaPosition
                            +   ulDmaBufferSize
                            )
                        -   m_ulDmaWindowSize
                        )
                    %   ulDmaBufferSize
                    );
            }

            //
            // Determine how many bytes we will complete (mind the wrap!).
            //
            ulBytesToComplete =
                (   (   (   ulDmaBufferSize
                        +   ulDmaPosition
                        )
                    -   m_ulDmaComplete
                    )
                %   ulDmaBufferSize
                );

            ASSERT(ulBytesToComplete <= m_ulDmaWindowSize);

            //
            // Try to fill up to the max num frames ahead
            //
#define kMaxNumFramesToFill 4

            ULONG MaxFill = ( (kMaxNumFramesToFill*m_FrameSize) > ulDmaBufferSize )
                            ? ulDmaBufferSize
                            : kMaxNumFramesToFill*m_FrameSize;

            if( MaxFill <= (m_ulDmaWindowSize - ulBytesToComplete) )
            {
                ulBytesToCopyFirst = 0;
            } else
            {
                ulBytesToCopyFirst =
                        MaxFill - (m_ulDmaWindowSize - ulBytesToComplete);
            }

            ASSERT(ulBytesToCopyFirst <= ulDmaBufferSize);
        }
        else
        {
            //
            // CAPTURE!
            //

            //
            // Determine how many bytes we'd like to copy (mind the wrap!).
            //
            //
            ulBytesToCopyFirst =
                (   (   (   ulDmaBufferSize
                        +   ulDmaPosition
                        )
                    -   m_ulDmaComplete
                    )
                %   ulDmaBufferSize
                );

            ASSERT(ulBytesToCopyFirst <= ulDmaBufferSize);
        }

        //
        // Might have to do two copies.
        //
        ULONG ulBytesToCopySecond = 0;
        if (ulBytesToCopyFirst > (ulDmaBufferSize - m_ulDmaCopy))
        {
            ulBytesToCopySecond = ulBytesToCopyFirst - (ulDmaBufferSize - m_ulDmaCopy);
            ulBytesToCopyFirst -= ulBytesToCopySecond;
        }

        //
        // Do the copies.
        //
        ULONG ulBytesCopied = 0;
        if (ulBytesToCopyFirst)
        {
            ULONG ulBytesCopiedFirst;
            Copy
            (   m_DataFlow == KSPIN_DATAFLOW_IN,
                ulBytesToCopyFirst,
                &ulBytesCopiedFirst,
                PVOID(PUCHAR(m_DmaChannel->SystemAddress()) + m_ulDmaCopy)
            );

            //
            // Do second copy only if we completed the first.
            //
            ULONG ulBytesCopiedSecond;
            if (ulBytesToCopySecond && (ulBytesToCopyFirst == ulBytesCopiedFirst))
            {
                Copy
                (   m_DataFlow == KSPIN_DATAFLOW_IN,
                    ulBytesToCopySecond,
                    &ulBytesCopiedSecond,
                    m_DmaChannel->SystemAddress()
                );
            }
            else
            {
                ulBytesCopiedSecond = 0;
            }

            ulBytesCopied = ulBytesCopiedFirst + ulBytesCopiedSecond;

#ifdef DEBUG_WAVECYC_DPC
            if( DebugEnable )
            {
                DebugRecord[DebugRecordCount].DbgCopy1Bytes = ulBytesCopiedFirst;
                DebugRecord[DebugRecordCount].DbgCopy1From = m_ulDmaCopy;
                DebugRecord[DebugRecordCount].DbgCopy1To = m_ulDmaCopy + ulBytesCopiedFirst;
                DebugRecord[DebugRecordCount].DbgCopy2Bytes = ulBytesCopiedSecond;
                if( ulBytesCopiedSecond )
                {
                    DebugRecord[DebugRecordCount].DbgCopy2From = 0;
                    DebugRecord[DebugRecordCount].DbgCopy2To = ulBytesCopiedSecond;
                } else
                {
                    DebugRecord[DebugRecordCount].DbgCopy2From = ULONG(-1);
                    DebugRecord[DebugRecordCount].DbgCopy2To = ULONG(-1);
                }
            }
#endif
            //
            // Update the copy position and the window size.
            //
            m_ulDmaCopy = (m_ulDmaCopy + ulBytesCopied) % ulDmaBufferSize;
            m_ulDmaWindowSize += ulBytesCopied;

            //
            // Count bytes copied.
            //
            m_ullByteCount += ulBytesCopied;

            //
            // Keep track of max bytes copied.
            //
#if (DBG)
            if (m_ulMaxBytesCopied < ulBytesCopied)
            {
                m_ulMaxBytesCopied = ulBytesCopied;
            }
#endif
        }

        if (m_DataFlow == KSPIN_DATAFLOW_IN)
        {
            //
            // RENDER!  Predict whether we are going to starve.
            //
            if ( (m_ulDmaWindowSize - ulBytesToComplete)
                < m_ulMinBytesReadyToTransfer)
            {
                LogGlitch = PERFGLITCH_PORTCLSGLITCH;

#ifdef  WRITE_SILENCE
                //
                // Write some silence.
                //
                ULONG ulBytesToSilence = m_ulMinBytesReadyToTransfer * 5 / 4;
                if (m_ulDmaCopy + ulBytesToSilence > ulDmaBufferSize)
                {
                    //
                    // Wrap.
                    //
                    m_Stream->Silence( m_DmaChannel->SystemAddress(),
                                       m_ulDmaCopy + ulBytesToSilence - ulDmaBufferSize );
//                    KdPrint(("'ReqServ: silence:%x @ 0x%08x\n",m_ulDmaCopy+ulBytesToSilence-ulDmaBufferSize,(ULONG_PTR)m_DmaChannel->SystemAddress()));
                    ulBytesToSilence = ulDmaBufferSize - m_ulDmaCopy;
                }
                m_Stream->Silence( PVOID(PUCHAR(m_DmaChannel->SystemAddress()) + m_ulDmaCopy),
                                   ulBytesToSilence);
//                KdPrint(("'ReqServ: silence:%x @ 0x%08x\n",ulBytesToSilence,(ULONG_PTR)m_DmaChannel->SystemAddress()+m_ulDmaCopy));
#endif  //  WRITE_SILENCE
            }
        }
        else
        {
            //
            // CAPTURE!  We will complete everything we copied.
            //
            ulBytesToComplete = ulBytesCopied;
        }

#ifdef DEBUG_WAVECYC_DPC
        if( DebugEnable )
        {
            DebugRecord[DebugRecordCount].DbgCompletedBytes = ulBytesToComplete;
            DebugRecord[DebugRecordCount].DbgCompletedFrom = m_ulDmaComplete;
            DebugRecord[DebugRecordCount].DbgCompletedTo = (m_ulDmaComplete + ulBytesToComplete) % ulDmaBufferSize;
        }
#endif

        //
        // Do the completion.
        //
        if (ulBytesToComplete)
        {
            ULONG ulBytesCompleted;
            ULONG ulTotalCompleted;

            ulTotalCompleted=0;

            do {

                m_IrpStream->Complete( ulBytesToComplete-ulTotalCompleted,
                                       &ulBytesCompleted );

                ulTotalCompleted+=ulBytesCompleted;

            } while(ulBytesCompleted && ulTotalCompleted!=ulBytesToComplete);

            ulBytesCompleted=ulTotalCompleted;

#ifdef  TRACK_LAST_COMPLETE
            if( ulBytesCompleted )
            {
                // clear the "secondsSinceLastComplete" timeout
                InterlockedExchange( PLONG(&m_SecondsSinceLastComplete), 0 );
            }
#endif  //  TRACK_LAST_COMPLETE

            if( ulBytesCompleted != ulBytesToComplete )
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("ulBytesCompleted (0x%08x) != ulBytesToComplete (0x%08x)",
                                           ulBytesCompleted,
                                           ulBytesToComplete));

                ulBytesToComplete = ulBytesCompleted;
            }

            //
            // Update the complete position and the window size.
            //
            m_ulDmaComplete = (m_ulDmaComplete + ulBytesToComplete) % ulDmaBufferSize;
            m_ulDmaWindowSize -= ulBytesToComplete;

            //
            // Capture keeps the window closed.
            //
            // ASSERT((m_DataFlow == KSPIN_DATAFLOW_IN) || (m_ulDmaWindowSize == 0));

            // ASSERT((m_ulDmaComplete == ulDmaPosition) || (m_ulDmaWindowSize == 0));

            //
            // Keep track of max bytes completed.
            //
#if (DBG)
            if (m_ulMaxBytesCompleted < ulBytesCompleted)
            {
                m_ulMaxBytesCompleted = ulBytesCompleted;
            }
#endif
        }
    }

#ifdef DEBUG_WAVECYC_DPC
    if( DebugEnable )
    {
        DebugRecord[DebugRecordCount].DbgWindowSize = m_ulDmaWindowSize;
        if( ++DebugRecordCount >= MAX_DEBUG_RECORDS )
        {
            DebugEnable = FALSE;
        }
    }
#endif

    KeReleaseSpinLockFromDpcLevel(&m_ksSpinLockDpc);
    KeReleaseSpinLockFromDpcLevel(pIrpStreamPositionLock);

    if (LoggerHandle && TraceEnable) {
        LARGE_INTEGER TimeSample=KeQueryPerformanceCounter (NULL);

        if (m_DMAGlitchType != LogDMAGlitch) {
            m_DMAGlitchType = LogDMAGlitch;
            PerfLogDMAGlitch((ULONG_PTR) this, m_DMAGlitchType, TimeSample.QuadPart, m_LastStateChangeTimeSample);
        }

        if (m_GlitchType != LogGlitch) {
            m_GlitchType = LogGlitch;
            PerfLogInsertSilenceGlitch((ULONG_PTR) this, m_GlitchType, TimeSample.QuadPart, m_LastStateChangeTimeSample);
        }

        m_LastStateChangeTimeSample = TimeSample.QuadPart;
    }

    //
    // Must be after spinlock is released.
    //
    GeneratePositionEvents();
    GenerateClockEvents();

    return;
}


//  Get into the pin object to access private members.
void
PropertyWorkerItem(
    IN PVOID Parameter
    )
{
    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    ASSERT(Parameter);
    CPortPinWaveCyclic *that;

    if (Parameter)
    {
        that = (CPortPinWaveCyclic *)Parameter;
        (void) that->WorkerItemSetFormat();
    }
}

//
// Worker item to set the data format synchronous to the stream
// (we wait until the stream starves.  Some synchronicity, eh?)
NTSTATUS
CPortPinWaveCyclic::WorkerItemSetFormat(
    void
)
{
    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    KSSTATE     previousDeviceState;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    NTSTATUS    ntStatus2;

    // Serialize.
    KeWaitForSingleObject
    (
        &m_Port->ControlMutex,
        Executive,
        KernelMode,
        FALSE,          // Not alertable.
        NULL
    );

    if (m_SetPropertyIsPending)
    {
        //  Put the pin in PAUSE state if running,
        previousDeviceState = m_DeviceState;
        if (previousDeviceState == KSSTATE_RUN)
        {
            ntStatus = DistributeDeviceState(KSSTATE_PAUSE,KSSTATE_RUN);
        }

        //  Set the data format,
        ntStatus2 = SynchronizedSetFormat(m_pPendingDataFormat);

        if (NT_SUCCESS(ntStatus) && !(NT_SUCCESS(ntStatus2)))
            ntStatus = ntStatus2;

        //  Put the pin in RUN state.
        if (previousDeviceState == KSSTATE_RUN)
        {
            ntStatus2 = DistributeDeviceState(KSSTATE_RUN,KSSTATE_PAUSE);

            if (NT_SUCCESS(ntStatus) && !(NT_SUCCESS(ntStatus2)))
                ntStatus = ntStatus2;
        }

        //  Complete the m_pPendingSetFormatIrp,
        m_pPendingSetFormatIrp->IoStatus.Information = 0;
        m_pPendingSetFormatIrp->IoStatus.Status = ntStatus;
        //m_pPendingSetFormatIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(m_pPendingSetFormatIrp,IO_NO_INCREMENT);
        m_pPendingSetFormatIrp = 0;

        //  Remember synchronization....
        m_SetPropertyIsPending = FALSE;
    }
    else    //  Our SetFormat must have been cancelled out from under us.
    {
        ntStatus = STATUS_SUCCESS;
    }
    m_WorkItemIsPending = FALSE;    //  forget about this work item
    KeReleaseMutex(&m_Port->ControlMutex, FALSE);

    return ntStatus;
}

void
CPortPinWaveCyclic::RealignBufferPosToFrame(
    void
)
{
    KIRQL kIrqlOld;
    ULONG ulDmaBufferSize,ulFrameAlignment;

    KeAcquireSpinLock(&m_ksSpinLockDpc,&kIrqlOld);

    // Cache the buffer size.
    ulDmaBufferSize = m_DmaChannel->BufferSize();

    // Make sure we are aligned on a frame boundary.
    ulFrameAlignment = m_ulDmaCopy % m_ulSampleSize;
    ASSERT(ulFrameAlignment == (m_ulDmaComplete % m_ulSampleSize));
    if (ulFrameAlignment)
    {
        m_ulDmaCopy =   (m_ulDmaCopy + m_ulSampleSize - ulFrameAlignment)
                        % ulDmaBufferSize;

        m_ulDmaComplete =   (m_ulDmaComplete + m_ulSampleSize - ulFrameAlignment)
                            % ulDmaBufferSize;

    }
    ASSERT(m_ulDmaCopy % m_ulSampleSize == 0);
    ASSERT(m_ulDmaComplete % m_ulSampleSize == 0);

    KeReleaseSpinLock(&m_ksSpinLockDpc,kIrqlOld);
}

//
// KSPROPSETID_Stream handlers
//

#pragma code_seg("PAGE")

NTSTATUS
CPortPinWaveCyclic::PinPropertyStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      irpSp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // allocators.  The returned handle is always NULL, but we
        // signal that we support the creation of allocators by
        // returning STATUS_SUCCESS.
        //
        *AllocatorHandle = NULL;
        Status = STATUS_SUCCESS;
    } else {
        CPortPinWaveCyclic  *PinWaveCyclic;



        PinWaveCyclic =
            (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp( Irp );

        //
        // The allocator can only be specified when the device is
        // in KSSTATE_STOP.
        //

        KeWaitForSingleObject(
            &PinWaveCyclic->m_Port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );

        if (PinWaveCyclic->m_DeviceState != KSSTATE_STOP) {
            KeReleaseMutex( &PinWaveCyclic->m_Port->ControlMutex, FALSE );
            return STATUS_INVALID_DEVICE_STATE;
        }

        //
        // Release the previous allocator, if any.
        //

        if (PinWaveCyclic->m_AllocatorFileObject) {
            ObDereferenceObject( PinWaveCyclic->m_AllocatorFileObject );
            PinWaveCyclic->m_AllocatorFileObject = NULL;
        }

        //
        // Reference this handle and store the resultant pointer
        // in the filter instance.  Note that the default allocator
        // does not ObReferenceObject() for its parent
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the allocator and the pin object has a reference to the
        // allocator file object.
        //
        if (*AllocatorHandle != NULL) {
            Status =
                ObReferenceObjectByHandle(
                    *AllocatorHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    NULL,
                    ExGetPreviousMode(),
                    (PVOID *) &PinWaveCyclic->m_AllocatorFileObject,
                    NULL );
        } else {
            Status = STATUS_SUCCESS;
        }
        KeReleaseMutex( &PinWaveCyclic->m_Port->ControlMutex, FALSE );
    }

    return Status;
}

NTSTATUS
CPortPinWaveCyclic::PinPropertyStreamMasterClock(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE ClockHandle
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      irpSp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // clocks.  The returned handle is always NULL, but we
        // signal that we support the creation of clocks by
        // returning STATUS_SUCCESS.
        //
        *ClockHandle = NULL;
        Status = STATUS_SUCCESS;
    } else {
        CPortPinWaveCyclic  *PinWaveCyclic;

        _DbgPrintF( DEBUGLVL_VERBOSE,("CPortPinWaveCyclic setting master clock") );

        PinWaveCyclic =
            (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp( Irp );

        //
        // The clock can only be specified when the device is
        // in KSSTATE_STOP.
        //

        KeWaitForSingleObject(
            &PinWaveCyclic->m_Port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );

        if (PinWaveCyclic->m_DeviceState != KSSTATE_STOP) {
            KeReleaseMutex( &PinWaveCyclic->m_Port->ControlMutex, FALSE );
            return STATUS_INVALID_DEVICE_STATE;
        }

        //
        // Release the previous clock, if any.
        //

        if (PinWaveCyclic->m_ClockFileObject) {
            ObDereferenceObject( PinWaveCyclic->m_ClockFileObject );
            PinWaveCyclic->m_ClockFileObject = NULL;
        }

        //
        // Reference this handle and store the resultant pointer
        // in the filter instance.  Note that the default clock
        // does not ObReferenceObject() for its parent
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the clock and the pin object has a reference to the
        // clock file object.
        //
        if (*ClockHandle != NULL) {
            Status =
                ObReferenceObjectByHandle(
                    *ClockHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    NULL,
                    ExGetPreviousMode(),
                    (PVOID *) &PinWaveCyclic->m_ClockFileObject,
                    NULL );
        } else {
            Status = STATUS_SUCCESS;
        }
        KeReleaseMutex( &PinWaveCyclic->m_Port->ControlMutex, FALSE );
    }

    return Status;
}

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
TransferKsIrp(
    IN PIRP Irp,
    OUT PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the shell
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::TransferKsIrp"));

    ASSERT(NextTransport);

    NTSTATUS status;

    if (m_ConnectionFileObject) {
        //
        // Source pin.
        //
        if (m_Flushing || (m_State == KSSTATE_STOP)) {
            //
            // Shunt IRPs to the next component if we are reset or stopped.
            //
            *NextTransport = m_TransportSink;
        } else {
            //
            // Send the IRP to the next device.
            //
            KsAddIrpToCancelableQueue(
                &m_IrpsToSend.ListEntry,
                &m_IrpsToSend.SpinLock,
                Irp,
                KsListEntryTail,
                NULL);

            KsIncrementCountedWorker(m_Worker);
            *NextTransport = NULL;
        }

        status = STATUS_PENDING;
    } else {
        //
        // Sink pin:  complete the IRP.
        //
        PKSSTREAM_HEADER StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );

        PIO_STACK_LOCATION irpSp =  IoGetCurrentIrpStackLocation( Irp );

        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_KS_WRITE_STREAM) {
            ASSERT( StreamHeader );

            //
            // Signal end-of-stream event for the renderer.
            //
            if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {

                GenerateEndOfStreamEvents();
            }
        }

        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        status = STATUS_PENDING;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS
CPortPinWaveCyclic::
DistributeDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState
    )

/*++

Routine Description:

    This routine sets the state of the pipe, informing all components in the
    pipe of the new state.  A transition to stop state destroys the pipe.

Arguments:

    NewState -
        The new state.

Return Value:

    Status.

--*/

{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::DistributeDeviceState(%p)",this));

    KSSTATE state = OldState;
    KSSTATE targetState = NewState;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Determine if this pipe section controls the entire pipe.
    //
    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport) {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } else {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // Proceed sequentially through states.
    //
    while (state != targetState) {
        KSSTATE oldState = state;

        if (ULONG(state) < ULONG(targetState)) {
            state = KSSTATE(ULONG(state) + 1);
        } else {
            state = KSSTATE(ULONG(state) - 1);
        }

        NTSTATUS statusThisPass = STATUS_SUCCESS;

        //
        // Distribute state changes if this section is in charge.
        //
        if (distribution)
        {
            //
            // Tell everyone about the state change.
            //
            _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::DistributeDeviceState(%p) distributing transition from %d to %d",this,oldState,state));
            PIKSSHELLTRANSPORT transport = distribution;
            PIKSSHELLTRANSPORT previousTransport = NULL;
            while (transport)
            {
                PIKSSHELLTRANSPORT nextTransport;
                statusThisPass = transport->SetDeviceState(state,oldState,&nextTransport);

                ASSERT(NT_SUCCESS(statusThisPass) || !nextTransport);

                if (NT_SUCCESS(statusThisPass))
                {
                    previousTransport = transport;
                    transport = nextTransport;
                } else
                {
                    //
                    // Back out on failure.
                    //
                    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.DistributeDeviceState:  failed transition from %d to %d",this,oldState,state));
                    while (previousTransport)
                    {
                        transport = previousTransport;
                        NTSTATUS statusThisPass2 = transport->SetDeviceState( oldState,
                                                                              state,
                                                                              &previousTransport);

                        ASSERT( NT_SUCCESS(statusThisPass2) );
                    }
                    break;
                }
            }
        }

        if (NT_SUCCESS(status) && !NT_SUCCESS(statusThisPass))
        {
            //
            // First failure:  go back to original state.
            //
            state = oldState;
            targetState = OldState;
            status = statusThisPass;
        }
    }

    return status;
}


void
CPortPinWaveCyclic::
DistributeResetState(
    IN KSRESET NewState
    )

/*++

Routine Description:

    This routine informs transport components that the reset state has
    changed.

Arguments:

    NewState -
        The new reset state.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::DistributeResetState"));

    PAGED_CODE();

    //
    // If this section of the pipe owns the requestor, or there is a
    // non-shell pin up the pipe (so there's no bypass), this pipe is
    // in charge of telling all the components about state changes.
    //
    // (Always)

    //
    // Set the state change around the circuit.
    //
    PIKSSHELLTRANSPORT transport =
        m_RequestorTransport ?
         m_RequestorTransport :
         m_QueueTransport;

    while (transport) {
        transport->SetResetState(NewState,&transport);
    }

    m_ResetState = NewState;
}


STDMETHODIMP_(void)
CPortPinWaveCyclic::
Connect(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a shell transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::Connect"));

    PAGED_CODE();

    KsShellStandardConnect(
        NewTransport,
        OldTransport,
        DataFlow,
        PIKSSHELLTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(void)
CPortPinWaveCyclic::
SetResetState(
    IN KSRESET ksReset,
    OUT PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::SetResetState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
        if (m_Flushing) {
            CancelIrpsOutstanding();
            m_ulDmaCopy             = 0;
            m_ulDmaComplete         = 0;
            m_ulDmaWindowSize       = 0;
            m_ullPlayPosition       = 0;
            m_ullPosition           = 0;
        }
    } else {
        *NextTransport = NULL;
    }
}

#if DBG

STDMETHODIMP_(void)
CPortPinWaveCyclic::
DbgRollCall(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"Pin%p %d (%s) refs=%d",this,m_Id,m_ConnectionFileObject ? "src" : "snk",references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


static
void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgPrintCircuit"));

    PAGED_CODE();

    ASSERT(Transport);

#define MAX_NAME_SIZE 64

    PIKSSHELLTRANSPORT transport = Transport;
    while (transport) {
        CHAR name[MAX_NAME_SIZE + 1];
        PIKSSHELLTRANSPORT next;
        PIKSSHELLTRANSPORT prev;

        transport->DbgRollCall(MAX_NAME_SIZE,name,&next,&prev);
        _DbgPrintF(DEBUGLVL_VERBOSE,("  %s",name));

        if (prev) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            prev->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (next2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" SOURCE'S(0x%08x) SINK(0x%08x) != THIS(%08x)",prev,next2,transport));
            }
        } else {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" NO SOURCE"));
        }

        if (next) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            next->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (prev2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" SINK'S(0x%08x) SOURCE(0x%08x) != THIS(%08x)",next,prev2,transport));
            }
        } else {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" NO SINK"));
        }

        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));

        transport = next;
        if (transport == Transport) {
            break;
        }
    }
}
#endif


STDMETHODIMP_(void)
CPortPinWaveCyclic::
Work
(
    void
)

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it sends
    IRPs to the connected pin using IoCallDriver().

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::Work"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do {
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_IrpsToSend.ListEntry,
                &m_IrpsToSend.SpinLock,
                KsListEntryHead,
                KsAcquireAndRemoveOnlySingleItem);

        //
        // Irp's may have been cancelled, but the loop must still run through
        // the reference counting.
        //
        if (irp) {
            if (m_Flushing || (m_State == KSSTATE_STOP)) {
                //
                // Shunt IRPs to the next component if we are reset or stopped.
                //
                KsShellTransferKsIrp(m_TransportSink,irp);
            } else {
                //
                // Set up the next stack location for the callee.
                //
                IoCopyCurrentIrpStackLocationToNext(irp);

                PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation(irp);

                irpSp->Parameters.DeviceIoControl.IoControlCode =
                    (m_DataFlow == KSPIN_DATAFLOW_OUT) ?
                     IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM;
                irpSp->DeviceObject = m_ConnectionDeviceObject;
                irpSp->FileObject = m_ConnectionFileObject;

                //
                // Add the IRP to the list of outstanding IRPs.
                //
                PIRPLIST_ENTRY irpListEntry = IRPLIST_ENTRY_IRP_STORAGE(irp);
                irpListEntry->Irp = irp;
                ExInterlockedInsertTailList(
                    &m_IrpsOutstanding.ListEntry,
                    &irpListEntry->ListEntry,
                    &m_IrpsOutstanding.SpinLock);

                IoSetCompletionRoutine(
                    irp,
                    CPortPinWaveCyclic::IoCompletionRoutine,
                    PVOID(this),
                    TRUE,
                    TRUE,
                    TRUE);

                IoCallDriver(m_ConnectionDeviceObject,irp);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#pragma code_seg()

NTSTATUS
CPortPinWaveCyclic::
IoCompletionRoutine
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)

/*++

Routine Description:

    This routine handles the completion of an IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::IoCompletionRoutine 0x%08x",Irp));

//    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *) Context;

    //
    // Remove the IRP from the list of IRPs.  Most of the time, it will be at
    // the head of the list, so this is cheaper than it looks.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&pin->m_IrpsOutstanding.SpinLock,&oldIrql);
    for(PLIST_ENTRY listEntry = pin->m_IrpsOutstanding.ListEntry.Flink;
        listEntry != &pin->m_IrpsOutstanding.ListEntry;
        listEntry = listEntry->Flink) {
            PIRPLIST_ENTRY irpListEntry =
                CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

            if (irpListEntry->Irp == Irp) {
                RemoveEntryList(listEntry);
                break;
            }
        }
    ASSERT(listEntry != &pin->m_IrpsOutstanding.ListEntry);
    KeReleaseSpinLock(&pin->m_IrpsOutstanding.SpinLock,oldIrql);

    NTSTATUS status;
    if (pin->m_TransportSink) {
        //
        // The transport circuit is up, so we can forward the IRP.
        //
        status = KsShellTransferKsIrp(pin->m_TransportSink,Irp);
    } else {
        //
        // The transport circuit is down.  This means the IRP came from another
        // filter, and we can just complete this IRP.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.IoCompletionRoutine:  got IRP %p with no transport",pin,Irp));
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        status = STATUS_SUCCESS;
    }

    //
    // Transport objects typically return STATUS_PENDING meaning that the
    // IRP won't go back the way it came.
    //
    if (status == STATUS_PENDING)
    {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS
CPortPinWaveCyclic::
BuildTransportCircuit
(
    void
)

/*++

Routine Description:

    This routine initializes a pipe object.  This includes locating all the
    pins associated with the pipe, setting the Pipe and NextPinInPipe pointers
    in the appropriate pin structures, setting all the fields in the pipe
    structure and building the transport circuit for the pipe.  The pipe and
    the associated components are left in acquire state.

    The filter's control mutex must be acquired before this function is called.

Arguments:

    Pin -
        Contains a pointer to the pin requesting the creation of the pipe.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::BuildTransportCircuit"));

    PAGED_CODE();

    BOOLEAN masterIsSource = m_ConnectionFileObject != NULL;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Create a queue.
    //
    status = m_IrpStream->QueryInterface(__uuidof(IKsShellTransport),(PVOID *) &m_QueueTransport);

    PIKSSHELLTRANSPORT hot;
    PIKSSHELLTRANSPORT cold;
    if (NT_SUCCESS(status))
    {
        //
        // Connect the queue to the master pin.  The queue is then the dangling
        // end of the 'hot' side of the circuit.
        //
        hot = m_QueueTransport;
        ASSERT(hot);

        hot->Connect(PIKSSHELLTRANSPORT(this),NULL,m_DataFlow);

        //
        // The 'cold' side of the circuit is either the upstream connection on
        // a sink pin or a requestor connected to same on a source pin.
        //
        if (masterIsSource)
        {
            //
            // Source pin...needs a requestor.
            //
            status = KspShellCreateRequestor( &m_RequestorTransport,
                                              (KSPROBE_STREAMREAD |
                                               KSPROBE_ALLOCATEMDL |
                                               KSPROBE_PROBEANDLOCK |
                                               KSPROBE_SYSTEMADDRESS),
                                              0,   // TODO:  header size
                                              HACK_FRAME_SIZE,
                                              HACK_FRAME_COUNT,
                                              m_ConnectionDeviceObject,
                                              m_AllocatorFileObject );

            if (NT_SUCCESS(status))
            {
                PIKSSHELLTRANSPORT(this)->Connect(m_RequestorTransport,NULL,m_DataFlow);
                cold = m_RequestorTransport;
            }
        } else
        {
            //
            // Sink pin...no requestor required.
            //
            cold = PIKSSHELLTRANSPORT(this);
        }
    }

    //
    // Now we have a hot end and a cold end to hook up to other pins in the
    // pipe, if any.  There are three cases:  1, 2 and many pins.
    // TODO:  Handle headless pipes.
    //
    if (NT_SUCCESS(status))
    {
        //
        // No other pins.  This is the end of the pipe.  We connect the hot
        // and the cold ends together.  The hot end is not really carrying
        // data because the queue is not modifying the data, it is producing
        // or consuming it.
        //
        cold->Connect(hot,NULL,m_DataFlow);
    }

    //
    // Clean up after a failure.
    //
    if (! NT_SUCCESS(status))
    {
        //
        // Dereference the queue if there is one.
        //
        if (m_QueueTransport)
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_RequestorTransport)
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }
    }

#if DBG
    if (NT_SUCCESS(status))
    {
        VOID DbgPrintCircuit(IN PIKSSHELLTRANSPORT Transport);
        _DbgPrintF(DEBUGLVL_VERBOSE,("TRANSPORT CIRCUIT:\n"));
        DbgPrintCircuit(PIKSSHELLTRANSPORT(this));
    }
#endif

    return status;
}

#pragma code_seg()

void
CPortPinWaveCyclic::
CancelIrpsOutstanding
(
    void
)
/*++

Routine Description:

    Cancels all IRP's on the outstanding IRPs list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::CancelIrpsOutstanding"));

    //
    // This algorithm searches for uncancelled IRPs starting at the head of
    // the list.  Every time such an IRP is found, it is cancelled, and the
    // search starts over at the head.  This will be very efficient, generally,
    // because IRPs will be removed by the completion routine when they are
    // cancelled.
    //
    for (;;) {
        //
        // Take the spinlock and search for an uncancelled IRP.  Because the
        // completion routine acquires the same spinlock, we know IRPs on this
        // list will not be completely cancelled as long as we have the
        // spinlock.
        //
        PIRP irp = NULL;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
        for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
            listEntry != &m_IrpsOutstanding.ListEntry;
            listEntry = listEntry->Flink) {
                PIRPLIST_ENTRY irpListEntry =
                    CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

                if (! irpListEntry->Irp->Cancel) {
                    irp = irpListEntry->Irp;
                    break;
                }
            }

        //
        // If there are no uncancelled IRPs, we are done.
        //
        if (! irp) {
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
            break;
        }

        //
        // Mark the IRP cancelled whether we can call the cancel routine now
        // or not.
        //
        irp->Cancel = TRUE;

        //
        // If the cancel routine has already been removed, then this IRP
        // can only be marked as canceled, and not actually canceled, as
        // another execution thread has acquired it. The assumption is that
        // the processing will be completed, and the IRP removed from the list
        // some time in the near future.
        //
        // If the element has not been acquired, then acquire it and cancel it.
        // Otherwise, it's time to find another victim.
        //
        PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);

        //
        // Since the Irp has been acquired by removing the cancel routine, or
        // there is no cancel routine and we will not be cancelling, it is safe
        // to release the list lock.
        //
        KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

        if (driverCancel) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  cancelling IRP %p",this,irp));
            //
            // This needs to be acquired since cancel routines expect it, and
            // in order to synchronize with NTOS trying to cancel Irp's.
            //
            IoAcquireCancelSpinLock(&irp->CancelIrql);
            driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);
        } else {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  uncancelable IRP %p",this,irp));
        }
    }
}

/*****************************************************************************
 * IoTimeoutRoutine
 *****************************************************************************
 * This routine is called by portcls about once per second to be used for
 * IoTimeout purposes.
 */
VOID
WaveCyclicIoTimeout
(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PVOID           pContext
)
{
    ASSERT(pDeviceObject);
    ASSERT(pContext);

    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)pContext;

    // check for SetFormat timeout
    if( (pin->m_SetPropertyIsPending) && !(pin->m_WorkItemIsPending) )
    {
        if( InterlockedIncrement( PLONG(&(pin->m_SecondsSinceSetFormatRequest)) ) >= SETFORMAT_TIMEOUT_THRESHOLD )
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("SetFormat TIMEOUT!"));

            InterlockedExchange( PLONG(&(pin->m_SecondsSinceLastDpc)), 0 );

            pin->FailPendedSetFormat();
        }
    }

    if( pin->m_DeviceState == KSSTATE_RUN )
    {
        if( InterlockedIncrement( PLONG(&(pin->m_SecondsSinceLastDpc)) ) >= LASTDPC_TIMEOUT_THRESHOLD )
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("LastDpc TIMEOUT!"));

            if( !InterlockedExchange( PLONG(&(pin->m_RecoveryItemIsPending)), TRUE ) )
            {
                pin->AddRef();
                ExQueueWorkItem( &(pin->m_RecoveryWorkItem), DelayedWorkQueue );
            }

            InterlockedExchange( PLONG(&(pin->m_SecondsSinceLastDpc)), 0 );
        } else
#ifdef  TRACK_LAST_COMPLETE
        if( InterlockedIncrement( PLONG(&(pin->m_SecondsSinceLastComplete)) ) >= LASTCOMPLETE_TIMEOUT_THRESHOLD )
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("LastComplete TIMEOUT!"));

            if( !InterlockedExchange( PLONG(&(pin->m_RecoveryItemIsPending)), TRUE ) )
            {
                pin->AddRef();
                ExQueueWorkItem( &(pin->m_RecoveryWorkItem), DelayedWorkQueue );
            }

            InterlockedExchange( PLONG(&(pin->m_SecondsSinceLastComplete)), 0 );
        } else
#endif  //  TRACK_LAST_COMPLETE
        if( InterlockedIncrement( PLONG(&(pin->m_SecondsSinceDmaMove)) ) >= LASTDMA_MOVE_THRESHOLD)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("DmaMove TIMEOUT!"));

            if( !InterlockedExchange( PLONG(&(pin->m_RecoveryItemIsPending)), TRUE ) )
            {
                pin->AddRef();
                ExQueueWorkItem( &(pin->m_RecoveryWorkItem), DelayedWorkQueue );
            }

            InterlockedExchange( PLONG(&(pin->m_SecondsSinceDmaMove)), 0 );
        } else
        {
            InterlockedExchange( PLONG(&(pin->m_RecoveryCount)), 0 );
        }
    }
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * RecoveryWorkerItem()
 *****************************************************************************
 * A worker item to attempt timeout recovery.
 */
void
RecoveryWorkerItem
(
    IN PVOID Parameter
)
{
    PAGED_CODE();

    ASSERT(Parameter);

    CPortPinWaveCyclic *that;

    if (Parameter)
    {
        that = (CPortPinWaveCyclic *)Parameter;
        (void) that->WorkerItemAttemptRecovery();

        that->Release();
    }
}


/*****************************************************************************
 * CPortPinWaveCyclic::WorkerItemAttemptRecovery()
 *****************************************************************************
 * A worker item to attempt timeout recovery.
 */
NTSTATUS
CPortPinWaveCyclic::
WorkerItemAttemptRecovery
(   void
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

#ifdef RECOVERY_STATE_CHANGE
    // grab the control mutex
    KeWaitForSingleObject( &(m_Port->ControlMutex),
                           Executive,
                           KernelMode,
                           FALSE,          // Not alertable.
                           NULL );

    if( ( m_DeviceState == KSSTATE_RUN ) && (m_CommandedState == KSSTATE_RUN) )
    {
        if( InterlockedIncrement( PLONG(&m_RecoveryCount) ) <= RECOVERY_ATTEMPT_LIMIT )
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("Attempting RUN->STOP->RUN Recovery"));

            // transition the pin from run to stop to run
            if( m_Stream )
            {
                m_Stream->SetState( KSSTATE_PAUSE );
                m_Stream->SetState( KSSTATE_ACQUIRE );
                m_Stream->SetState( KSSTATE_STOP );
                m_Stream->SetState( KSSTATE_ACQUIRE );
                m_Stream->SetState( KSSTATE_PAUSE );
                m_Stream->SetState( KSSTATE_RUN );
    }
}
#if 0
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("Recovery Limit Exceeded -> STOP"));
            // recovery limit exceeded, force the pin to KSSTATE_STOP
            ntStatus = DistributeDeviceState( KSSTATE_STOP, m_DeviceState );
            if( NT_SUCCESS(ntStatus) )
            {
                m_DeviceState = KSSTATE_STOP;
            }
        }
#endif
    }

    KeReleaseMutex(&(m_Port->ControlMutex),FALSE);
#else
    InterlockedIncrement (PLONG(&m_RecoveryCount));
#endif
    InterlockedExchange( PLONG(&m_RecoveryItemIsPending), FALSE );

    return ntStatus;
}


/*****************************************************************************
 * CPortPinWaveCyclic::SetupIoTimeouts()
 *****************************************************************************
 * Register or Unregister IO Timeout callbacks.
 */
NTSTATUS
CPortPinWaveCyclic::
SetupIoTimeouts
(
    IN  BOOL    Register
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( Register )
    {
        // only register if not already registered
        if (!InterlockedExchange((PLONG)&m_TimeoutsRegistered,TRUE))
        {
            ntStatus = PcRegisterIoTimeout( m_Port->DeviceObject,
                                            PIO_TIMER_ROUTINE(WaveCyclicIoTimeout),
                                            this );

            if (!NT_SUCCESS(ntStatus))
            {
                m_TimeoutsRegistered = FALSE;
            }
        }
    } else
    {
        // only unregister if already registered
        if (InterlockedExchange((PLONG)&m_TimeoutsRegistered,FALSE))
        {
            ntStatus = PcUnregisterIoTimeout( m_Port->DeviceObject,
                                              PIO_TIMER_ROUTINE(WaveCyclicIoTimeout),
                                              this );
            if (!NT_SUCCESS(ntStatus))
            {
                m_TimeoutsRegistered = TRUE;
            }
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\filter.cpp ===
/*****************************************************************************
 * filter.cpp - PCI wave port filter implementation
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Constants
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * PropertyTable_Pin
 *****************************************************************************
 * List of pin properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_Pin) 
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropertyHandler_Pin)
};

/*****************************************************************************
 * PropertyTable_Topology
 *****************************************************************************
 * List of topology properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TOPOLOGYSET
(
    PropertyTable_Topology,
    PropertyHandler_Topology
);

/*****************************************************************************
 * PropertyTable_FilterWavePci
 *****************************************************************************
 * Table of properties supported by the property handler.
 */
KSPROPERTY_SET PropertyTable_FilterWavePci[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(PropertyTable_Pin),
        PropertyTable_Pin,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(PropertyTable_Topology),
        PropertyTable_Topology,
        0,
        NULL
    )
};





/*****************************************************************************
 * Factory
 */

/*****************************************************************************
 * CPortFilterWavePci()
 *****************************************************************************
 * Creates a PCI wave port driver filter.
 */
NTSTATUS
CreatePortFilterWavePci
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CPortFilterWavePci,Unknown,UnknownOuter,PoolType);
}



/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortFilterWavePci::~CPortFilterWavePci()
 *****************************************************************************
 * Destructor.
 */
CPortFilterWavePci::~CPortFilterWavePci()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CPortFilterWavePci::~CPortFilterWavePci"));

    if (Port)
    {
        Port->Release();
    }

    if (m_propertyContext.pulPinInstanceCounts)
    {
        delete [] m_propertyContext.pulPinInstanceCounts;
    }
}

/*****************************************************************************
 * CPortFilterWavePci::Init()
 *****************************************************************************
 * Initializes the object.
 */
HRESULT
CPortFilterWavePci::
Init
(
    IN  CPortWavePci *Port_
)
{
    PAGED_CODE();

    ASSERT(Port_);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterWavePci::Init"));

    Port = Port_;
    Port->AddRef();

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(Port);
    m_propertyContext.pSubdeviceDescriptor = Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = Port->Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);
    m_propertyContext.pulPinInstanceCounts = 
        new(NonPagedPool,'cIcP') ULONG[Port->m_pSubdeviceDescriptor->PinCount];

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (! m_propertyContext.pulPinInstanceCounts)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

//
// Define the dispatch table for child objects of the pin 
// (e.g. clocks, allocators)
// 

static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;
static const WCHAR ClockTypeName[] = KSSTRING_Clock;

static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM( KsoDispatchCreateWithGenericFactory,ClockTypeName,0 ),
    DEFINE_KSCREATE_ITEM( CPortFilterWavePci::AllocatorDispatchCreate, AllocatorTypeName, 0 )
};
 
/*****************************************************************************
 * CPortFilterWavePci::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a pin object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWavePci::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    ASSERT(Port);
    ASSERT(Port->m_pSubdeviceDescriptor);
    ASSERT(Port->m_pSubdeviceDescriptor->PinDescriptors);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterWavePci::NewPin"));

    PKSPIN_CONNECT pinConnect;
    NTSTATUS ntStatus =
        PcValidateConnectRequest
        (
            Irp,
            Port->m_pSubdeviceDescriptor,
            &pinConnect
        );

    if (NT_SUCCESS(ntStatus))
    {
        ULONG PinId = pinConnect->PinId;

        Port->PinCount
        ( 
            PinId,
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterNecessary),
            &(m_propertyContext.pulPinInstanceCounts[PinId]),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterPossible),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalCurrent),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalPossible) 
        );

        ntStatus = 
            PcValidatePinCount
            (
                PinId,
                Port->m_pSubdeviceDescriptor,
                m_propertyContext.pulPinInstanceCounts
            );

        if (NT_SUCCESS(ntStatus))
        {
            ObjectCreate->CreateItemsCount  = 0;
            ObjectCreate->CreateItemsList   = NULL;

            PUNKNOWN pinUnknown;
            ntStatus =
                CreatePortPinWavePci
                (
                    &pinUnknown,
                    GUID_NULL,
                    OuterUnknown,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                PPORTPINWAVEPCI pinWavePci;

                ntStatus =
                    pinUnknown->QueryInterface
                    (
                        IID_IIrpTarget,
                        (PVOID *) &pinWavePci
                    );

                if (NT_SUCCESS(ntStatus))
                {
                    // The QI for IIrpTarget actually gets IPortPinMidi.
                    ntStatus = 
                        pinWavePci->Init
                        (
                            Port,
                            this,
                            pinConnect,
                            &Port->m_pSubdeviceDescriptor->
                                PinDescriptors[pinConnect->PinId],
                            DeviceObject
                        );

                    if (NT_SUCCESS(ntStatus))
                    {
                        *ReferenceParent = TRUE;
                        *IrpTarget = pinWavePci;
                    }
                    else
                    {
                        pinWavePci->Release();
                    }
                }

                pinUnknown->Release();
            }

            if (! NT_SUCCESS(ntStatus))
            {
                PcTerminateConnection
                (   Port->m_pSubdeviceDescriptor
                ,   m_propertyContext.pulPinInstanceCounts
                ,   pinConnect->PinId
                );
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortFilterWavePci::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWavePci::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTFILTERWAVEPCI(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the GUID.
        *Object = PVOID(PPORTFILTERWAVEPCI(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortFilterWavePci::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWavePci::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterWavePci::DeviceIoControl"));

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySetCount,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySets,
				&m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(Port->m_EventList);
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

/*****************************************************************************
 * CPortFilterWavePci::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWavePci::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // free any events in the port event list associated with this
    // filter instance
    //
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( IrpStack->FileObject,
                     &( Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortFilterWavePci);
DEFINE_INVALID_WRITE(CPortFilterWavePci);
DEFINE_INVALID_FLUSH(CPortFilterWavePci);
DEFINE_INVALID_QUERYSECURITY(CPortFilterWavePci);
DEFINE_INVALID_SETSECURITY(CPortFilterWavePci);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortFilterWavePci);
DEFINE_INVALID_FASTREAD(CPortFilterWavePci);
DEFINE_INVALID_FASTWRITE(CPortFilterWavePci);

NTSTATUS 
CPortFilterWavePci::AllocatorDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Dispatches the create request for the allocator to the default
    KS function.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet for the create.

Return:
    result from KsCreateDefaultAllocator();

--*/

{
    NTSTATUS Status;
    
    Status = KsCreateDefaultAllocator( Irp );
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp,IO_NO_INCREMENT );
    return Status;
} 

/*****************************************************************************
 * PropertyHandler_Pin()
 *****************************************************************************
 * Property handler for pin description properties.
 */
static
NTSTATUS
PropertyHandler_Pin
(
    IN      PIRP        Irp,
    IN      PKSP_PIN    Pin,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);

    return
        PcPinPropertyHandler
        (   Irp
        ,   Pin
        ,   Data
        );
}

/*****************************************************************************
 * PropertyHandler_Topology()
 *****************************************************************************
 * Property handler for topology.
 */
static
NTSTATUS
PropertyHandler_Topology
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    return
        KsTopologyPropertyHandler
        (
            Irp,
            Property,
            Data,
            pSubdeviceDescriptor->Topology
        );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\port.cpp ===
/*****************************************************************************
 * port.cpp - cyclic wave port driver
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#define KSDEBUG_INIT
#include "private.h"





/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreatePortWaveCyclic()
 *****************************************************************************
 * Creates a cyclic wave port driver.
 */
NTSTATUS
CreatePortWaveCyclic
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID    Interface,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating WAVECYCLIC Port"));

    STD_CREATE_BODY_
    (
        CPortWaveCyclic,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTWAVECYCLIC
    );
}

/*****************************************************************************
 * PortDriverWaveCyclic
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverWaveCyclic =
{
    &CLSID_PortWaveCyclic,
    CreatePortWaveCyclic
};

#pragma code_seg()

/*****************************************************************************
 * Member functions
 */

/*****************************************************************************
 * CPortWaveCyclic::Notify()
 *****************************************************************************
 * Lower-edge function to notify port driver of notification interrupt.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::
Notify
(
    IN      PSERVICEGROUP   ServiceGroup
)
{
    ASSERT(ServiceGroup);

    ServiceGroup->RequestService();
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CPortWaveCyclic::~CPortWaveCyclic()
 *****************************************************************************
 * Destructor.
 */
CPortWaveCyclic::~CPortWaveCyclic()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVECYCLIC Port (0x%08x)",this));

    if (m_pSubdeviceDescriptor)
    {
        PcDeleteSubdeviceDescriptor(m_pSubdeviceDescriptor);
    }

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
    }
}

/*****************************************************************************
 * CPortWaveCyclic::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPort))
    {
        *Object = PVOID(PPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortWaveCyclic))
    {
        *Object = PVOID(PPORTWAVECYCLIC(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_ISubdevice))
    {
        *Object = PVOID(PSUBDEVICE(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IIrpTargetFactory))
    {
        *Object = PVOID(PIRPTARGETFACTORY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortEvents))
    {
        *Object = PVOID(PPORTEVENTS(this));
    }
#ifdef DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort))
    {
        *Object = PVOID(PDRMPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort2))
    {
        *Object = PVOID(PDRMPORT2(this));
    }
#endif  // DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IPortClsVersion))
    {
        *Object = PVOID(PPORTCLSVERSION(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}



static
const
GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

static
const
KSPIN_INTERFACE PinInterfacesStream[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING,
      0
   },
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_LOOPED_STREAMING,
      0
   }
};


/*****************************************************************************
 * CPortWaveCyclic::Init()
 *****************************************************************************
 * Initializes the port.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
Init
(
    IN      PDEVICE_OBJECT  DeviceObjectIn,
    IN      PIRP            Irp,
    IN      PUNKNOWN        UnknownMiniport,
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(DeviceObjectIn);
    ASSERT(Irp);
    ASSERT(UnknownMiniport);
    ASSERT(ResourceList);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing WAVECYCLIC Port (0x%08x)",this));

    DeviceObject = DeviceObjectIn;

    KeInitializeMutex(&ControlMutex,1);

    KeInitializeMutex( &m_PinListMutex, 1 );
    InitializeListHead( &m_PinList );

    KeInitializeSpinLock( &(m_EventList.ListLock) );
    InitializeListHead( &(m_EventList.List) );
    m_EventContext.ContextInUse = FALSE;
    KeInitializeDpc( &m_EventDpc,
                     PKDEFERRED_ROUTINE(PcGenerateEventDeferredRoutine),
                     PVOID(&m_EventContext) );
    
    NTSTATUS ntStatus = UnknownMiniport->QueryInterface( IID_IMiniportWaveCyclic,
                                                         (PVOID *) &Miniport );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = Miniport->Init( UnknownAdapter,
                                   ResourceList,
                                   PPORTWAVECYCLIC(this) );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor);

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus =
                    PcCreateSubdeviceDescriptor
                    (
                        m_pPcFilterDescriptor,
                        SIZEOF_ARRAY(TopologyCategories),
                        (GUID*)TopologyCategories,
                        SIZEOF_ARRAY(PinInterfacesStream),
                        (KSPIN_INTERFACE*)PinInterfacesStream,
                        SIZEOF_ARRAY(PropertyTable_FilterWaveCyclic),
                        PropertyTable_FilterWaveCyclic,
                        0,      // FilterEventSetCount
                        NULL,   // FilterEventSets
                        SIZEOF_ARRAY(PropertyTable_PinWaveCyclic),
                        PropertyTable_PinWaveCyclic,
                        SIZEOF_ARRAY(EventTable_PinWaveCyclic),
                        EventTable_PinWaveCyclic,
                        &m_pSubdeviceDescriptor
                    );
                if (NT_SUCCESS(ntStatus))
                {
                    NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPinCount,(PVOID *)&m_MPPinCountI);
                }
            }
        }
    }

    if(!NT_SUCCESS(ntStatus))
    {
        if (m_MPPinCountI)
        {
            m_MPPinCountI->Release();
            m_MPPinCountI = NULL;
        }

        if( Miniport )
        {
            Miniport->Release();
            Miniport = NULL;
        }
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("WaveCyclic Port Init done w/ status %x",ntStatus));

    return ntStatus;
}

/*****************************************************************************
 * CPortWaveCyclic::GetDeviceProperty()
 *****************************************************************************
 * Gets device properties from the registry for PnP devices.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
GetDeviceProperty
(
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
)
{
    return ::PcGetDeviceProperty(   PVOID(DeviceObject),
                                    DeviceProperty,
                                    BufferLength,
                                    PropertyBuffer,
                                    ResultLength );
}

/*****************************************************************************
 * CPortWaveCyclic::NewRegistryKey()
 *****************************************************************************
 * Opens/creates a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
NewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    return ::PcNewRegistryKey(  OutRegistryKey,
                                OuterUnknown,
                                RegistryKeyType,
                                DesiredAccess,
                                PVOID(DeviceObject),
                                PVOID(PSUBDEVICE(this)),
                                ObjectAttributes,
                                CreateOptions,
                                Disposition );
}

/*****************************************************************************
 * CPortWaveCyclic::ReleaseChildren()
 *****************************************************************************
 * Release child objects.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::
ReleaseChildren
(   void
)
{
    PAGED_CODE();

    POWER_STATE     PowerState;

    // set things to D3 before releasing the miniport
    PowerState.DeviceState = PowerDeviceD3;
    PowerChangeNotify( PowerState );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
        Miniport = NULL;
    }
}

/*****************************************************************************
 * CPortWaveCyclic::GetDescriptor()
 *****************************************************************************
 * Return the descriptor for this port
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
GetDescriptor
(   OUT     const SUBDEVICE_DESCRIPTOR **   ppSubdeviceDescriptor
)
{
    PAGED_CODE();

    ASSERT(ppSubdeviceDescriptor);

    *ppSubdeviceDescriptor = m_pSubdeviceDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CPortWaveCyclic::DataRangeIntersection()
 *****************************************************************************
 * Generate a format which is the intersection of two data ranges.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    ASSERT(DataRange);
    ASSERT(MatchingDataRange);
    ASSERT(ResultantFormatLength);

    return 
        Miniport->DataRangeIntersection
        (   PinId,
            DataRange,
            MatchingDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
}


/*****************************************************************************
 * CPortWaveCyclic::PowerChangeNotify()
 *****************************************************************************
 * Called by portcls to notify the port/miniport of a device power
 * state change.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::
PowerChangeNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    PPOWERNOTIFY pPowerNotify;

    if( Miniport )
    {
        // QI for the miniport notification interface
        NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPowerNotify,
                                                      (PVOID *)&pPowerNotify );

        // check if we're powering up
        if( PowerState.DeviceState == PowerDeviceD0 )
        {
            // notify the miniport
            if( NT_SUCCESS(ntStatus) )
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
    
            // notify each port pin
            KeWaitForSingleObject( &m_PinListMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            
            if( !IsListEmpty( &m_PinList ) )
            {
                for(PLIST_ENTRY listEntry = m_PinList.Flink;
                    listEntry != &m_PinList;
                    listEntry = listEntry->Flink)
                {
                    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)CONTAINING_RECORD( listEntry,
                                                                                 CPortPinWaveCyclic,
                                                                                 m_PinListEntry );

                    pin->PowerNotify( PowerState );
                }                
            }

            KeReleaseMutex( &m_PinListMutex, FALSE );
        
        } else  // we're powering down
        {
            // notify each port pin
            KeWaitForSingleObject( &m_PinListMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            
            if( !IsListEmpty( &m_PinList ) )
            {
                for(PLIST_ENTRY listEntry = m_PinList.Flink;
                    listEntry != &m_PinList;
                    listEntry = listEntry->Flink)
                {
                    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)CONTAINING_RECORD( listEntry,
                                                                                 CPortPinWaveCyclic,
                                                                                 m_PinListEntry );

                    pin->PowerNotify( PowerState );
                }                
            }

            KeReleaseMutex( &m_PinListMutex, FALSE );
            
            // notify the miniport
            if( NT_SUCCESS(ntStatus) )
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortWaveCyclic::PinCount()
 *****************************************************************************
 * Called by portcls to give the port\miniport a chance 
 * to override the default pin counts for this pin ID.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB,
                 ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,                           FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible);

        _DbgPrintF( DEBUGLVL_BLAB, 
                    ("Post-PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                      PinId,                           FilterNecessary,*FilterNecessary,
                      FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                      GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );
    }
}

/*****************************************************************************
 * PinTypeName
 *****************************************************************************
 * The name of the pin object type.
 */
static const WCHAR PinTypeName[] = KSSTRING_Pin;

/*****************************************************************************
 * CreateTable
 *****************************************************************************
 * Create dispatch table.
 */
static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,PinTypeName,0)
};

/*****************************************************************************
 * CPortWaveCyclic::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a filter object.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortWaveCyclic::NewIrpTarget"));

    ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
    ObjectCreate->CreateItemsList   = CreateTable;

    PUNKNOWN filterUnknown;
    NTSTATUS ntStatus =
        CreatePortFilterWaveCyclic
        (
            &filterUnknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PPORTFILTERWAVECYCLIC filterWaveCyclic;

        ntStatus =
            filterUnknown->QueryInterface
            (
                IID_IIrpTarget,
                (PVOID *) &filterWaveCyclic
            );

        if (NT_SUCCESS(ntStatus))
        {
            // The QI for IIrpTarget actually gets IPortFilterWaveCyclic.
            ntStatus = filterWaveCyclic->Init(this);
            if (NT_SUCCESS(ntStatus))
            {
                *ReferenceParent = TRUE;
                *IrpTarget = filterWaveCyclic;
            }
            else
            {
                filterWaveCyclic->Release();
            }
        }

        filterUnknown->Release();
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortWaveCyclic::NewSlaveDmaChannel()
 *****************************************************************************
 * Lower-edge function to create a slave DMA channel.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
NewSlaveDmaChannel
(
    OUT     PDMACHANNELSLAVE *  DmaChannel,
    IN      PUNKNOWN            OuterUnknown,
    IN      PRESOURCELIST       ResourceList,
    IN      ULONG               DmaIndex,
    IN      ULONG               MaximumLength,
    IN      BOOLEAN             DemandMode,
    IN      DMA_SPEED           DmaSpeed
)
{
    PAGED_CODE();

    ASSERT(DmaChannel);
    ASSERT(ResourceList);
    ASSERT(MaximumLength > 0);

    NTSTATUS            ntStatus;
    DEVICE_DESCRIPTION  deviceDescription;
    PREGISTRYKEY        DriverKey;

    // open the driver registry key
    ntStatus = NewRegistryKey (  &DriverKey,               // IRegistryKey
                                 NULL,                     // OuterUnknown
                                 DriverRegistryKey,        // Registry key type
                                 KEY_ALL_ACCESS,           // Access flags
                                 NULL,                     // ObjectAttributes
                                 0,                        // Create options
                                 NULL );                   // Disposition

    // if we cannot open the key, assume there is no UseFDMA entrie ->
    // try to allocate the DMA with passed DMA speed.
    // but if we can read the UseFDMA entrie (and it is set to TRUE), than
    // change the DMA speed to TypeF (that's FDMA).
    if(NT_SUCCESS(ntStatus))
    {
        // allocate data to hold key info
        PVOID KeyInfo = ExAllocatePoolWithTag(PagedPool, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),'yCvW');
                                                                                                        //  'WvCy'
        if(NULL != KeyInfo)
        {
            UNICODE_STRING  KeyName;
            ULONG           ResultLength;

            // make a unicode string for the value name
            RtlInitUnicodeString( &KeyName, L"UseFDMA" );
       
            // read UseFDMA key
            ntStatus = DriverKey->QueryValueKey( &KeyName,
                                  KeyValuePartialInformation,
                                  KeyInfo,
                                  sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                  &ResultLength );
                
            if(NT_SUCCESS(ntStatus))
            {
                PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyInfo);

                if(PartialInfo->DataLength == sizeof(DWORD))
                {
                    if (*(PDWORD(PartialInfo->Data)) != 0)
                    {
                        // set DMA speed to typeF (FDMA)
                        DmaSpeed = TypeF;
                    }
                }
            }
        
            // free the key info
            ExFreePool(KeyInfo);
        }
        
        // release the driver key
        DriverKey->Release();
    }
    
    
    // reinit
    ntStatus = STATUS_SUCCESS;

    
    // The first time we enter this loop, DmaSpeed may be TypeF (FDMA),
    // depending on the registry settings.
    // If something goes wrong, we will loop again but with DmaSpeed
    // setting of Compatible.
    // A third loop does not exist.
    do
    {
       // Try with DMA speed setting of FDMA
       ntStatus = PcDmaSlaveDescription
           (
               ResourceList,
               DmaIndex,
               DemandMode,
               TRUE,               // AutoInitialize
               DmaSpeed,
               MaximumLength,
               0,                  // DmaPort
               &deviceDescription
           );
       
       if (NT_SUCCESS(ntStatus))
       {
           PDMACHANNEL pDmaChannel;

           ntStatus = PcNewDmaChannel
            (
                &pDmaChannel,
                OuterUnknown,
                NonPagedPool,
                &deviceDescription,
                DeviceObject
            );

            //
            // Need to query for the slave part of the interface.
            //
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = pDmaChannel->QueryInterface
                     (   IID_IDmaChannelSlave
                     ,   (PVOID *) DmaChannel
                     );

                pDmaChannel->Release();
            }
       }

       // if a failure, try again with compatible mode
       if (!NT_SUCCESS(ntStatus) && (DmaSpeed == TypeF)) {
          DmaSpeed = Compatible;
       }
       else
          break;

    } while (TRUE);
    
    return ntStatus;
}

/*****************************************************************************
 * CPortWaveCyclic::NewMasterDmaChannel()
 *****************************************************************************
 * Lower-edge function to create a master DMA channel.
 */
STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
NewMasterDmaChannel
(
    OUT     PDMACHANNEL *   DmaChannel,
    IN      PUNKNOWN        OuterUnknown,
    IN      PRESOURCELIST   ResourceList    OPTIONAL,
    IN      ULONG           MaximumLength,
    IN      BOOLEAN         Dma32BitAddresses,
    IN      BOOLEAN         Dma64BitAddresses,
    IN      DMA_WIDTH       DmaWidth,
    IN      DMA_SPEED       DmaSpeed
)
{
    PAGED_CODE();

    ASSERT(DmaChannel);
    ASSERT(MaximumLength > 0);

    DEVICE_DESCRIPTION deviceDescription;

    PcDmaMasterDescription
    (
        ResourceList,
        (Dma32BitAddresses || Dma64BitAddresses), // set false if not 32 and not 64-bit addresses
        Dma32BitAddresses,
        FALSE,              // IgnoreCount
        Dma64BitAddresses,
        DmaWidth,
        DmaSpeed,
        MaximumLength,
        0,                  // DmaPort
        &deviceDescription
    );

    return
        PcNewDmaChannel
        (
            DmaChannel,
            OuterUnknown,
            NonPagedPool,
            &deviceDescription,
            DeviceObject
        );
}

#pragma code_seg()

/*****************************************************************************
 * CPortWaveCyclic::AddEventToEventList()
 *****************************************************************************
 * Adds an event to the port's event list.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::
AddEventToEventList
(
    IN  PKSEVENT_ENTRY  EventEntry
)
{
    ASSERT(EventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CPortWaveCyclic::AddEventToEventList"));

    KIRQL   oldIrql;

    if( EventEntry )
    {
        // grab the event list spin lock
        KeAcquireSpinLock( &(m_EventList.ListLock), &oldIrql );

        // add the event to the list tail
        InsertTailList( &(m_EventList.List),
                        (PLIST_ENTRY)((PVOID)EventEntry) );

        // release the event list spin lock
        KeReleaseSpinLock( &(m_EventList.ListLock), oldIrql );
    }
}

/*****************************************************************************
 * CPortWaveCyclic::GenerateEventList()
 *****************************************************************************
 * Wraps KsGenerateEventList for miniports.
 */
STDMETHODIMP_(void)
CPortWaveCyclic::
GenerateEventList
(
    IN  GUID*   Set     OPTIONAL,
    IN  ULONG   EventId,
    IN  BOOL    PinEvent,
    IN  ULONG   PinId,
    IN  BOOL    NodeEvent,
    IN  ULONG   NodeId
)
{
    if( KeGetCurrentIrql() > DISPATCH_LEVEL )
    {
        if( !m_EventContext.ContextInUse )
        {
            m_EventContext.ContextInUse = TRUE;
            m_EventContext.Set = Set;
            m_EventContext.EventId = EventId;
            m_EventContext.PinEvent = PinEvent;
            m_EventContext.PinId = PinId;
            m_EventContext.NodeEvent = NodeEvent;
            m_EventContext.NodeId = NodeId;
    
            KeInsertQueueDpc( &m_EventDpc,
                              PVOID(&m_EventList),
                              NULL );
        }
    } else
    {
        PcGenerateEventList( &m_EventList,
                             Set,
                             EventId,
                             PinEvent,
                             PinId,
                             NodeEvent,
                             NodeId );
    }
}

#ifdef DRM_PORTCLS

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
AddContentHandlers(ULONG ContentId,PVOID * paHandlers,ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
CreateContentMixed(PULONG paContentId,ULONG cContentId,PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
DestroyContent(ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
ForwardContentToDeviceObject(ULONG ContentId,PVOID Reserved,PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
ForwardContentToFileObject(ULONG ContentId,PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
ForwardContentToInterface(ULONG ContentId,PUNKNOWN pUnknown,ULONG NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

STDMETHODIMP_(NTSTATUS)
CPortWaveCyclic::
GetContentRights(ULONG ContentId,PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\drmhelp.c ===
#include "portclsp.h"

#ifdef DRM_PORTCLS

#include <drmk.h>

#pragma code_seg("PAGE")

NTSTATUS DrmForwardContentToStream(ULONG ContentId, PMINIPORTWAVEPCISTREAM pStream)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,
                                        (PUNKNOWN)pStream,
                                        sizeof(*pStream->lpVtbl)/sizeof(pStream->lpVtbl->QueryInterface));
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\filter.cpp ===
/*****************************************************************************
 * filter.cpp - cyclic wave port filter implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





#pragma code_seg("PAGE")

/*****************************************************************************
 * Constants
 */

/*****************************************************************************
 * PropertyTable_Pin
 *****************************************************************************
 * List of pin properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_Pin) 
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropertyHandler_Pin)
};

/*****************************************************************************
 * PropertyTable_Topology
 *****************************************************************************
 * List of topology properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TOPOLOGYSET
(
    PropertyTable_Topology,
    PropertyHandler_Topology
);

/*****************************************************************************
 * PropertyTable_FilterWaveCyclic
 *****************************************************************************
 * Table of properties supported by the filter property handler.
 */
KSPROPERTY_SET PropertyTable_FilterWaveCyclic[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(PropertyTable_Pin),
        PropertyTable_Pin,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(PropertyTable_Topology),
        PropertyTable_Topology,
        0,
        NULL
    )
};





/*****************************************************************************
 * Factory
 */

/*****************************************************************************
 * CPortFilterWaveCyclic()
 *****************************************************************************
 * Creates a cyclic wave port driver filter.
 */
NTSTATUS
CreatePortFilterWaveCyclic
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating WAVECYCLIC Filter"));

    STD_CREATE_BODY(CPortFilterWaveCyclic,Unknown,UnknownOuter,PoolType);
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortFilterWaveCyclic::~CPortFilterWaveCyclic()
 *****************************************************************************
 * Destructor.
 */
CPortFilterWaveCyclic::~CPortFilterWaveCyclic()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVECYCLIC Filter (0x%08x)",this));

    if (Port)
    {
        Port->Release();
    }

    if (m_propertyContext.pulPinInstanceCounts)
    {
        delete [] m_propertyContext.pulPinInstanceCounts;
    }
}

/*****************************************************************************
 * CPortFilterWaveCyclic::Init()
 *****************************************************************************
 * Initializes the object.
 */
HRESULT
CPortFilterWaveCyclic::
Init
(
    IN      CPortWaveCyclic *  Port_
)
{
    PAGED_CODE();

    ASSERT(Port_);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing WAVECYCLIC Filter (0x%08x)",this));

    Port = Port_;
    Port->AddRef();

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(Port);
    m_propertyContext.pSubdeviceDescriptor = Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = Port->Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);
    m_propertyContext.pulPinInstanceCounts = 
        new(NonPagedPool,'cIcP') ULONG[Port->m_pSubdeviceDescriptor->PinCount];

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (! m_propertyContext.pulPinInstanceCounts)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortFilterWaveCyclic::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a pin object.
 */

//
// Define the dispatch table for child objects of the pin 
// (e.g. clocks, allocators)
// 

static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;
static const WCHAR ClockTypeName[] = KSSTRING_Clock;

static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,ClockTypeName,0),
    DEFINE_KSCREATE_ITEM( CPortFilterWaveCyclic::AllocatorDispatchCreate, AllocatorTypeName, 0 )
};
 
STDMETHODIMP_(NTSTATUS)
CPortFilterWaveCyclic::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown    OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    ASSERT(Port);
    ASSERT(Port->m_pSubdeviceDescriptor);
    ASSERT(Port->m_pSubdeviceDescriptor->PinDescriptors);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterWaveCyclic::NewPin"));

    PKSPIN_CONNECT pinConnect;
    NTSTATUS ntStatus =
        PcValidateConnectRequest
        (
            Irp,
            Port->m_pSubdeviceDescriptor,
            &pinConnect
        );

    if (NT_SUCCESS(ntStatus)) 
    {
        ULONG PinId = pinConnect->PinId;

        Port->PinCount
        ( 
            PinId,
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterNecessary),
            &(m_propertyContext.pulPinInstanceCounts[PinId]),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterPossible),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalCurrent),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalPossible) 
        );

        ntStatus = 
            PcValidatePinCount
            (
                PinId,
                Port->m_pSubdeviceDescriptor,
                m_propertyContext.pulPinInstanceCounts
            );

        if (NT_SUCCESS(ntStatus))
        {
            ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
            ObjectCreate->CreateItemsList   = CreateTable;

            PUNKNOWN pinUnknown;
            ntStatus =
                CreatePortPinWaveCyclic
                (
                    &pinUnknown,
                    GUID_NULL,
                    OuterUnknown,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                PPORTPINWAVECYCLIC pinWaveCyclic;

                ntStatus =
                    pinUnknown->QueryInterface
                    (
                        IID_IIrpTarget,
                        (PVOID *) &pinWaveCyclic
                    );

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // The QI for IIrpTarget actually gets IPortPinWaveCyclic.
                    //
                    ntStatus = 
                        pinWaveCyclic->Init
                        (
                            Port,
                            this,
                            pinConnect,
                            &Port->m_pSubdeviceDescriptor->
                                PinDescriptors[pinConnect->PinId]
                        );

                    if (NT_SUCCESS(ntStatus))
                    {
                        *ReferenceParent = TRUE;
                        *IrpTarget = pinWaveCyclic;
                    }
                    else
                    {
                        pinWaveCyclic->Release();
                    }
                }

                pinUnknown->Release();
            }

            if (! NT_SUCCESS(ntStatus))
            {
                PcTerminateConnection
                (   Port->m_pSubdeviceDescriptor
                ,   m_propertyContext.pulPinInstanceCounts
                ,   pinConnect->PinId
                );
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortFilterWaveCyclic::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWaveCyclic::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTFILTERWAVECYCLIC(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the GUID.
        *Object = PVOID(PPORTFILTERWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortFilterWaveCyclic::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWaveCyclic::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterWaveCyclic::DeviceIoControl"));

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySetCount,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySets,
				&m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(Port->m_EventList);
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

/*****************************************************************************
 * CPortFilterWaveCyclic::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterWaveCyclic::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // free any events in the port event list associated with this
    // filter instance
    //
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( IrpStack->FileObject,
                     &( Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortFilterWaveCyclic);
DEFINE_INVALID_WRITE(CPortFilterWaveCyclic);
DEFINE_INVALID_FLUSH(CPortFilterWaveCyclic);
DEFINE_INVALID_QUERYSECURITY(CPortFilterWaveCyclic);
DEFINE_INVALID_SETSECURITY(CPortFilterWaveCyclic);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortFilterWaveCyclic);
DEFINE_INVALID_FASTREAD(CPortFilterWaveCyclic);
DEFINE_INVALID_FASTWRITE(CPortFilterWaveCyclic);


NTSTATUS 
CPortFilterWaveCyclic::AllocatorDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Dispatches the create request for the allocator to the default
    KS function.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet for the create.

Return:
    result from KsCreateDefaultAllocator();

--*/

{
    NTSTATUS Status;
    
    Status = KsCreateDefaultAllocator( Irp );
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp,IO_NO_INCREMENT );
    return Status;
} 


/*****************************************************************************
 * PropertyHandler_Pin()
 *****************************************************************************
 * Property handler for pin description properties.
 */
static
NTSTATUS
PropertyHandler_Pin
(
    IN      PIRP        Irp,
    IN      PKSP_PIN    Pin,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);

    return
        PcPinPropertyHandler
        (   Irp
        ,   Pin
        ,   Data
        );
}

/*****************************************************************************
 * PropertyHandler_Topology()
 *****************************************************************************
 * Property handler for topology.
 */
static
NTSTATUS
PropertyHandler_Topology
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    return
        KsTopologyPropertyHandler
        (
            Irp,
            Property,
            Data,
            pSubdeviceDescriptor->Topology
        );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\private.h ===
/*****************************************************************************
 * private.h - cyclic wave port private definitions
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _WAVECYC_PRIVATE_H_
#define _WAVECYC_PRIVATE_H_

#include "portclsp.h"

#ifdef DRM_PORTCLS
#include <drmk.h>
#endif  // DRM_PORTCLS

#include "stdunk.h"

#include "stdio.h"
#include "stdarg.h"        

#ifndef PC_KDEXT
#if (DBG)
#define STR_MODULENAME  "WaveCyclic: "
#define DEBUG_VARIABLE WAVECYCDebug
#endif
#endif

#include <ksdebug.h>

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif

#define WAVECYC_NOTIFICATION_FREQUENCY 10

//#define DEBUG_WAVECYC_DPC   1

#ifdef DEBUG_WAVECYC_DPC

#define KSSTATE_TO_STRING(x) \
    (   ((x) == KSSTATE_RUN) ? "KSSTATE_RUN" : \
        ((x) == KSSTATE_PAUSE) ? "KSSTATE_PAUSE" : \
        ((x) == KSSTATE_ACQUIRE) ? "KSSTATE_ACQUIRE" : \
        ((x) == KSSTATE_STOP) ? "KSSTATE_STOP" : "UNDEFINED" )

#define MAX_DEBUG_RECORDS   10

typedef struct
{
    KSSTATE DbgPinState;
    ULONG   DbgDmaPosition;
    ULONG   DbgCopy1Bytes;
    ULONG   DbgCopy1From;
    ULONG   DbgCopy1To;
    ULONG   DbgCopy2Bytes;
    ULONG   DbgCopy2From;
    ULONG   DbgCopy2To;
    ULONG   DbgCompletedBytes;
    ULONG   DbgCompletedFrom;
    ULONG   DbgCompletedTo;
    ULONG   DbgBufferSize;
    ULONG   DbgSampleSize;
    ULONG   DbgWindowSize;
    BOOL    DbgSetPosition;
    BOOL    DbgStarvation;
    ULONG   DbgStarvationBytes;
    ULONG   DbgFrameSize;
    USHORT  DbgDmaSamples[4];
} CYCLIC_DEBUG_RECORD, *PCYCLIC_DEBUG_RECORD;

#endif

// timeout thresholds
#define SETFORMAT_TIMEOUT_THRESHOLD     15      // in seconds
#define LASTDPC_TIMEOUT_THRESHOLD        2      // in seconds
#define LASTDMA_MOVE_THRESHOLD           2      // in seconds
#define RECOVERY_ATTEMPT_LIMIT          10      // in attempts

//
//  We cannot track the last completion, because KMixer 
//  sometimes intentionally starves PortCls.
//
//#define TRACK_LAST_COMPLETE
#ifdef  TRACK_LAST_COMPLETE
#define LASTCOMPLETE_TIMEOUT_THRESHOLD   2      // in seconds
#endif  //  TRACK_LAST_COMPLETE


//
// THE SIZES HERE MUST AGREE WITH THE DEFINITION IN FILTER.CPP AND PIN.CPP.
//
extern KSPROPERTY_SET PropertyTable_FilterWaveCyclic[2];
extern KSPROPERTY_SET PropertyTable_PinWaveCyclic[4];
extern KSEVENT_SET    EventTable_PinWaveCyclic[2];

/*****************************************************************************
 * Structures
 */
 
 typedef enum {
    PositionEvent,
    EndOfStreamEvent
 } PORT_EVENTTYPE;

/*****************************************************************************
 * POSITION_EVENT_ENTRY
 *****************************************************************************
 * Position event as it is stored in the event list.
 */
typedef struct {
    KSEVENT_ENTRY   EventEntry;
    PORT_EVENTTYPE  EventType;
    ULONG           Reserved;
    ULONGLONG       ullPosition;
} POSITION_EVENT_ENTRY, *PPOSITION_EVENT_ENTRY;

typedef struct {
    KSEVENT_ENTRY   EventEntry;
    PORT_EVENTTYPE  EventType;
    ULONG           Reserved;
} ENDOFSTREAM_EVENT_ENTRY, *PENDOFSTREAM_EVENT_ENTRY;


/*****************************************************************************
 * Interfaces
 */

class CPortWaveCyclic;
class CPortFilterWaveCyclic;
class CPortPinWaveCyclic;

/*****************************************************************************
 * IPortFilterWaveCyclic
 *****************************************************************************
 * Interface for cyclic wave filters.
 */
DECLARE_INTERFACE_(IPortFilterWaveCyclic,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortWaveCyclic *   Port
    )   PURE;
};

typedef IPortFilterWaveCyclic *PPORTFILTERWAVECYCLIC;

/*****************************************************************************
 * IPortPinWaveCyclic
 *****************************************************************************
 * Interface for cyclic wave pins.
 */
DECLARE_INTERFACE_(IPortPinWaveCyclic,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortWaveCyclic *       Port,
        IN      CPortFilterWaveCyclic * Filter,
        IN      PKSPIN_CONNECT          PinConnect,
        IN      PKSPIN_DESCRIPTOR       PinDescriptor
    )   PURE;
    
    STDMETHOD_(ULONG, GetCompletedPosition)( VOID ) PURE;
    STDMETHOD_(LONGLONG, GetCycleCount)( VOID ) PURE;
    STDMETHOD_(ULONG, GetDeviceBufferSize)( VOID ) PURE;
    STDMETHOD_(PIRPSTREAM, GetIrpStream)( VOID ) PURE;
    STDMETHOD_(PMINIPORTWAVECYCLICSTREAM, GetMiniport)( VOID ) PURE;
};

typedef IPortPinWaveCyclic *PPORTPINWAVECYCLIC;

interface IWaveCyclicClock;
typedef IWaveCyclicClock *PWAVECYCLICCLOCK;

typedef struct {
    LIST_ENTRY          ListEntry;
    PWAVECYCLICCLOCK    IWaveCyclicClock;
    PFILE_OBJECT        FileObject;
    PKSPIN_LOCK         ListLock;
    ULONG               Reserved;
} WAVECYCLICCLOCK_NODE, *PWAVECYCLICCLOCK_NODE;

DECLARE_INTERFACE_(IWaveCyclicClock,IIrpTarget) 
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_( PWAVECYCLICCLOCK_NODE, GetNodeStructure )( THIS ) PURE;
    STDMETHOD_(NTSTATUS, GenerateEvents )( THIS_ PFILE_OBJECT FileObject ) PURE;
    STDMETHOD_(NTSTATUS, SetState )( KSSTATE State ) PURE;
};


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CPortWaveCyclic
 *****************************************************************************
 * Wave port driver.
 */
class CPortWaveCyclic
:   public IPortWaveCyclic,
    public IPortEvents,
    public ISubdevice,
#ifdef DRM_PORTCLS
    public IDrmPort2,
#endif  // DRM_PORTCLS
    public IPortClsVersion,
    public CUnknown
{
private:
    PMINIPORTWAVECYCLIC     Miniport;
    PPINCOUNT               m_MPPinCountI;

    PDEVICE_OBJECT          DeviceObject;
    PSUBDEVICE_DESCRIPTOR   m_pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    m_pPcFilterDescriptor;
    
    INTERLOCKED_LIST        m_EventList;
    KDPC                    m_EventDpc;
    EVENT_DPC_CONTEXT       m_EventContext;

    KMUTEX                  ControlMutex;

    LIST_ENTRY              m_PinList;
    KMUTEX                  m_PinListMutex;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortWaveCyclic);
    ~CPortWaveCyclic();

    IMP_ISubdevice;
    IMP_IPortWaveCyclic;
    IMP_IPortEvents;
#ifdef DRM_PORTCLS
    IMP_IDrmPort2;
#endif  // DRM_PORTCLS
    IMP_IPortClsVersion;

    //
    // property handlers, etc.
    //

    friend class CPortFilterWaveCyclic;
    friend class CPortPinWaveCyclic;

    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    void
    PcGenerateEventDeferredRoutine
    (
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2        
    );

#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
};

/*****************************************************************************
 * CPortFilterWaveCyclic
 *****************************************************************************
 * Filter implementation for cyclic wave port.
 */
class CPortFilterWaveCyclic : public IPortFilterWaveCyclic, public CUnknown
{
private:
    CPortWaveCyclic *   Port;
    PROPERTY_CONTEXT    m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortFilterWaveCyclic);
    ~CPortFilterWaveCyclic();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortWaveCyclic *  Port
    );
    
    //
    // helper functions
    //

    static    
    NTSTATUS 
    AllocatorDispatchCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    
    //
    // friends
    //

    friend class CPortPinWaveCyclic;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
};

/*****************************************************************************
 * CPortPinWaveCyclic
 *****************************************************************************
 * Pin implementation for cyclic wave port.
 */
class CPortPinWaveCyclic
:   public IPortPinWaveCyclic,
    public IIrpStreamNotify,
    public IServiceSink,
    public IKsShellTransport,
    public IKsWorkSink,
    public CUnknown
{
private:
    LIST_ENTRY                  m_PinListEntry;
    
    PIKSSHELLTRANSPORT          m_TransportSink;
    PIKSSHELLTRANSPORT          m_TransportSource;
    PDEVICE_OBJECT              m_ConnectionDeviceObject;
    PFILE_OBJECT                m_ConnectionFileObject;
    PIKSSHELLTRANSPORT          m_RequestorTransport;
    PIKSSHELLTRANSPORT          m_QueueTransport;
    KSSTATE                     m_State;
    KSRESET                     m_ResetState;
    INTERLOCKEDLIST_HEAD        m_IrpsToSend;
    INTERLOCKEDLIST_HEAD        m_IrpsOutstanding;
    PKSWORKER                   m_Worker;
    WORK_QUEUE_ITEM             m_WorkItem;

    CPortWaveCyclic *           m_Port;
    CPortFilterWaveCyclic *     m_Filter;
    PROPERTY_CONTEXT            m_propertyContext;

    PMINIPORTWAVECYCLICSTREAM   m_Stream;
    ULONG                       m_Id;
    PKSPIN_DESCRIPTOR           m_Descriptor;
    PKSDATAFORMAT               m_DataFormat;
    KSPIN_DATAFLOW              m_DataFlow;   // Because descriptor is paged.

    WORK_QUEUE_ITEM             m_SetFormatWorkItem;
    PKSDATAFORMAT               m_pPendingDataFormat;
    PIRP                        m_pPendingSetFormatIrp;
    BOOL                        m_WorkItemIsPending;
    BOOL                        m_SetPropertyIsPending;

    KSSTATE                     m_DeviceState;
    KSSTATE                     m_CommandedState;

    ULONGLONG                   m_ullPosition;
    KSPIN_LOCK                  m_ksSpinLockDpc;

    PIRPSTREAMVIRTUAL           m_IrpStream;
    PDMACHANNEL                 m_DmaChannel;
    PSERVICEGROUP               m_ServiceGroup;

    ULONG                       m_ulDmaCopy;
    ULONG                       m_ulDmaComplete;
    ULONG                       m_ulDmaWindowSize;
    ULONGLONG                   m_ullPlayPosition;

    ULONG                       m_ulMinBytesReadyToTransfer;
    ULONG                       m_ulSampleSize;
    
    PFILE_OBJECT                m_AllocatorFileObject;
    PFILE_OBJECT                m_ClockFileObject;
    
    LIST_ENTRY                  m_ClockList;
    KSPIN_LOCK                  m_ClockListLock;
    ULONG                       m_FrameSize;
    
    BOOLEAN                     m_bSetPosition;
    BOOLEAN                     m_bJustReceivedIrp;

    //
    // Physical position computation
    //
    BOOLEAN                     m_Flushing;

    ULONG                       m_ulDmaPosition;
    LONGLONG                    m_ulDmaCycles;
    
    ULONGLONG                   m_ullByteCount;
    ULONGLONG                   m_ullServiceCount;
    ULONGLONG                   m_ullStarvationCount;
    ULONGLONG                   m_ullStarvationBytes;

    LONGLONG                    m_LastStateChangeTimeSample;
    ULONG                       m_GlitchType;
    ULONG                       m_DMAGlitchType;

#if (DBG)
    ULONGLONG                   m_ullServiceTime;
    ULONGLONG                   m_ullServiceIntervalSum;
    ULONG                       m_ulMaxServiceInterval;

    ULONG                       m_ulMaxBytesCopied;
    ULONG                       m_ulMaxBytesCompleted;
#endif

    BOOL                        m_bInitCompleted;
    BOOL                        m_Suspended;

    WORK_QUEUE_ITEM             m_RecoveryWorkItem;
    BOOL                        m_RecoveryItemIsPending;
    BOOL                        m_TimeoutsRegistered;
    ULONG                       m_SecondsSinceLastDpc;
    ULONG                       m_SecondsSinceSetFormatRequest;
#ifdef  TRACK_LAST_COMPLETE
    ULONG                       m_SecondsSinceLastComplete;
#endif  //  TRACK_LAST_COMPLETE
    ULONG                       m_SecondsSinceDmaMove;
    ULONG                       m_RecoveryCount;
    ULONG                       m_OldDmaPosition;

#ifdef DEBUG_WAVECYC_DPC
    ULONG                       DebugRecordCount;
    BOOL                        DebugEnable;

    PCYCLIC_DEBUG_RECORD        DebugRecord;

    void
    DumpDebugRecords(
        void
    );
#endif


    void
    Copy(
        IN      BOOLEAN     WriteOperation,
        IN      ULONG       RequestedSize,
        OUT     PULONG      ActualSize,
        IN OUT  PVOID       Buffer
    );

    BOOLEAN
    BufferValuesAreValid(
        IN      PCHAR   pCharWhere
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortPinWaveCyclic);
    ~CPortPinWaveCyclic();

    IMP_IIrpTarget;
    IMP_IIrpStreamNotify;
    IMP_IServiceSink;
    IMP_IKsShellTransport;
    IMP_IKsWorkSink;
    
    //
    // helper functions
    // 

    STDMETHODIMP_(NTSTATUS)
    GetKsAudioPosition
    (   OUT     PKSAUDIO_POSITION   pKsAudioPosition
    );

    STDMETHODIMP_(void)
    PowerNotify(
        POWER_STATE PowerState
    );

    void
    GenerateClockEvents(
        void
    );

    void        
    GenerateEndOfStreamEvents(
        void
    );
        
    void 
    GeneratePositionEvents(
        void
    );
    
    NTSTATUS SynchronizedSetFormat(
        IN PKSDATAFORMAT   inDataFormat
    );

    NTSTATUS WorkerItemSetFormat(
        void
    );

    NTSTATUS WorkerItemAttemptRecovery(
        void
    );

    void FailPendedSetFormat(void);

    void
    RealignBufferPosToFrame(
        void
    );

    STDMETHODIMP_(NTSTATUS) 
    ReflectDeviceStateChange(
        KSSTATE State
    );
        
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortWaveCyclic *       Port,
        IN      CPortFilterWaveCyclic * Filter,
        IN      PKSPIN_CONNECT          PinConnect,
        IN      PKSPIN_DESCRIPTOR       PinDescriptor
    );
    
    STDMETHODIMP_( LONGLONG ) GetCycleCount( VOID );
    
    STDMETHODIMP_( ULONG ) GetCompletedPosition( VOID );
    
    STDMETHODIMP_( ULONG ) GetDeviceBufferSize( VOID ) {
        return m_DmaChannel->BufferSize();
    }
    
    STDMETHODIMP_( PIRPSTREAM ) GetIrpStream( VOID ) {
        if( m_IrpStream )
        {
            m_IrpStream->AddRef();
        }
        return m_IrpStream;
    }
    
    STDMETHODIMP_( PMINIPORTWAVECYCLICSTREAM ) GetMiniport( VOID ) {
        if( m_Stream )
        {
            m_Stream->AddRef();
        }
        return m_Stream;
    }

    NTSTATUS
    SetupIoTimeouts
    (
        IN  BOOL    Register
    );
    
    //
    // helper functions
    //
    static
    NTSTATUS
    PinPropertyStreamAllocator(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE AllocatorHandle
    );
        
    static
    NTSTATUS
    PinPropertyStreamMasterClock(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE ClockHandle
    );
        
    static
    NTSTATUS 
    PinPropertyAllocatorFraming(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSALLOCATOR_FRAMING AllocatorFraming
    );
    
    static
    NTSTATUS    
    AddEndOfStreamEvent(
        IN PIRP Irp,
        IN PKSEVENTDATA EventData,
        IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry
    );
        
    //
    // friends
    //
    friend CPortWaveCyclic;

    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );
    friend
    NTSTATUS
    PinPropertySetContentId
    (
        IN      PIRP            pIrp,
        IN      PKSPROPERTY     pKsProperty,
        IN      PVOID           pvData
    );
    friend
    NTSTATUS
    PinPropertyPosition
    (
        IN      PIRP                Irp,
        IN      PKSPROPERTY         Property,
        IN OUT  PKSAUDIO_POSITION   Position
    );
    friend
    NTSTATUS
    PinAddEvent_Position
    (
        IN      PIRP                                    pIrp,
        IN      PLOOPEDSTREAMING_POSITION_EVENT_DATA    pPositionEventData,
        IN      PPOSITION_EVENT_ENTRY                   pPositionEventEntry
    );
    friend
    VOID
    WaveCyclicIoTimeout
    (
        IN  PDEVICE_OBJECT  pDeviceObject,
        IN  PVOID           pContext
    );

    //  The worker item for synchronous format changes.
    friend void PropertyWorkerItem(IN PVOID Parameter);

    // The worker item for timeout recovery
    friend void RecoveryWorkerItem(IN PVOID Parameter);

#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif

    NTSTATUS 
    DistributeDeviceState(
        IN KSSTATE NewState,
        IN KSSTATE OldState
        );
    void 
    DistributeResetState(
        IN KSRESET NewState
        );
    static
    NTSTATUS
    IoCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
        );
    NTSTATUS
    BuildTransportCircuit(
        void
        );
    void
    CancelIrpsOutstanding(
        void
        );
};

#ifndef PC_KDEXT    // debugger extension don't current support the clock
//
// CPortClockWaveCyclic
//
// This class supports the clock interface for a pin object.
//

class CPortClockWaveCyclic : 
    public IWaveCyclicClock,
    public CUnknown
{
private:
    PPORTPINWAVECYCLIC      m_IPortPin;
    KSPIN_LOCK              m_ClockLock,
                            m_EventLock;
    LIST_ENTRY              m_EventList;
    KMUTEX                  m_StateMutex;
    WAVECYCLICCLOCK_NODE    m_ClockNode;
    LONGLONG                m_LastTime, 
                            m_LastPhysicalTime,
                            m_LastPhysicalPosition;
    KSSTATE                 m_DeviceState;
    ULONG                   m_DeviceBufferSize;

public:
    DECLARE_STD_UNKNOWN();
    IMP_IIrpTarget;
    
    CPortClockWaveCyclic( 
        IN PUNKNOWN UnkOuter,
        IN PPORTPINWAVECYCLIC IPortPin,
        OUT NTSTATUS *Status );
    ~CPortClockWaveCyclic();
    
    //
    // Implement IWaveCyclicClock
    //
    
    STDMETHODIMP_(PWAVECYCLICCLOCK_NODE)
    GetNodeStructure( 
        VOID 
        ) 
    {
        return &m_ClockNode;
    }
    
    STDMETHODIMP_(NTSTATUS)
    GenerateEvents( 
        PFILE_OBJECT FileObject
        );
        
    STDMETHODIMP_(NTSTATUS)
    SetState(
        KSSTATE State
        );
        
    //
    // helper functions (also the DPC interface)
    //      
    
    static
    LONGLONG
    FASTCALL
    GetCurrentTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentPhysicalTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedPhysicalTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    //
    // property handlers and event handlers
    //
    
    static
    NTSTATUS
    AddEvent(
        IN PIRP Irp,
        IN PKSEVENT_TIME_INTERVAL EventTime,
        IN PKSEVENT_ENTRY EventEntry
        );
    
    static
    NTSTATUS
    GetFunctionTable(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
        );
        
    static
    NTSTATUS
    GetCorrelatedTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
    
    static
    NTSTATUS
    GetTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetCorrelatedPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
        
    static
    NTSTATUS
    GetPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetResolution(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSRESOLUTION Resolution
        );
        
    static
    NTSTATUS
    GetState(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSSTATE State
        );
        
};
#endif  // PC_KDEXT

/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * CPortFilterWaveCyclic()
 *****************************************************************************
 * Creates a cyclic wave port driver filter.
 */
NTSTATUS
CreatePortFilterWaveCyclic
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID    Interface,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * CreatePortPinWaveCyclic()
 *****************************************************************************
 * Creates a cyclic wave port driver pin.
 */
NTSTATUS
CreatePortPinWaveCyclic(
    OUT PUNKNOWN *Unknown,
    IN REFCLSID Interface,
    IN PUNKNOWN UnknownOuter OPTIONAL,
    IN POOL_TYPE PoolType
    );

//
// CreatePortClockWaveCyclic
//      Creates a clock object for the wave cyclic pin type.
// 

NTSTATUS
CreatePortClockWaveCyclic(
    OUT PUNKNOWN *Unknown,
    IN PPORTPINWAVECYCLIC IPortPin,    
    IN REFCLSID Interface,
    IN PUNKNOWN UnknownOuter OPTIONAL,
    IN POOL_TYPE PoolType
    );
    
#ifdef DRM_PORTCLS

/*****************************************************************************
 * DrmForwardContentToStream()
 *****************************************************************************
 * Convenient type-safe wrapper for DrmForwardContentToInterface.
 */
EXTERN_C
NTSTATUS
DrmForwardContentToStream(
    ULONG ContentId,
    PMINIPORTWAVECYCLICSTREAM pMiniportWaveCyclicStream
    );

#endif  // DRM_PORTCLS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\pin.cpp ===
/*****************************************************************************
 * pin.cpp - PCI wave port pin implementation
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"


#define HACK_FRAME_COUNT        3
#define HACK_SAMPLE_RATE        44100
#define HACK_BYTES_PER_SAMPLE   2
#define HACK_CHANNELS           2
#define HACK_MS_PER_FRAME       10
#define HACK_FRAME_SIZE         (   (   HACK_SAMPLE_RATE\
                                    *   HACK_BYTES_PER_SAMPLE\
                                    *   HACK_CHANNELS\
                                    *   HACK_MS_PER_FRAME\
                                    )\
                                /   1000\
                                )

 
//
// IRPLIST_ENTRY is used for the list of outstanding IRPs.  This structure is
// overlayed on the Parameters section of the current IRP stack location.  The
// reserved PVOID at the top preserves the OutputBufferLength, which is the
// only parameter that needs to be preserved.
//
typedef struct IRPLIST_ENTRY_
{
    PVOID       Reserved;
    PIRP        Irp;
    LIST_ENTRY  ListEntry;
} IRPLIST_ENTRY, *PIRPLIST_ENTRY;
 
#define IRPLIST_ENTRY_IRP_STORAGE(Irp) \
    PIRPLIST_ENTRY(&IoGetCurrentIrpStackLocation(Irp)->Parameters)

/*****************************************************************************
 * Constants.
 */

#pragma code_seg("PAGE")

DEFINE_KSPROPERTY_TABLE(PinPropertyTableConnection)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(
        PinPropertyDeviceState,
        PinPropertyDeviceState ),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(
        PinPropertyDataFormat,
        PinPropertyDataFormat ),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING( 
        CPortPinWavePci::PinPropertyAllocatorFraming )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableStream)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR( 
        CPortPinWavePci::PinPropertyStreamAllocator, 
        CPortPinWavePci::PinPropertyStreamAllocator ),

    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK( 
        CPortPinWavePci::PinPropertyStreamMasterClock,
        CPortPinWavePci::PinPropertyStreamMasterClock )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableAudio)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_POSITION,
        PinPropertyPosition,
        sizeof(KSPROPERTY),
        sizeof(KSAUDIO_POSITION),
        PinPropertyPosition,
        NULL,0,NULL,NULL,0
    )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableDrmAudioStream)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        PinPropertySetContentId,                        // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};     

KSPROPERTY_SET PropertyTable_PinWavePci[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(PinPropertyTableStream),
        PinPropertyTableStream,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(PinPropertyTableConnection),
        PinPropertyTableConnection,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(PinPropertyTableAudio),
        PinPropertyTableAudio,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_DrmAudioStream,
        SIZEOF_ARRAY(PinPropertyTableDrmAudioStream),
        PinPropertyTableDrmAudioStream,
        0,NULL
    )
};

DEFINE_KSEVENT_TABLE(PinEventTable)
{
    DEFINE_KSEVENT_ITEM(
        KSEVENT_LOOPEDSTREAMING_POSITION,
        sizeof(LOOPEDSTREAMING_POSITION_EVENT_DATA),
        sizeof(POSITION_EVENT_ENTRY) - sizeof(KSEVENT_ENTRY),
        PFNKSADDEVENT(PinAddEvent_Position),
        NULL,
        NULL
        )
};

DEFINE_KSEVENT_TABLE(ConnectionEventTable) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_ENDOFSTREAM,
        sizeof(KSEVENTDATA),
        sizeof(ENDOFSTREAM_EVENT_ENTRY) - sizeof( KSEVENT_ENTRY ),
        PFNKSADDEVENT(CPortPinWavePci::AddEndOfStreamEvent),
        NULL, 
        NULL
        )
};

KSEVENT_SET EventTable_PinWavePci[] =
{
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_LoopedStreaming,
        SIZEOF_ARRAY(PinEventTable),
        PinEventTable
        ),
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Connection,
        SIZEOF_ARRAY(ConnectionEventTable),
        ConnectionEventTable
        )
    
};

/*****************************************************************************
 * Factory
 */

/*****************************************************************************
 * CreatePortPinWavePci()
 *****************************************************************************
 * Creates a PCI wave port driver pin.
 */
NTSTATUS
CreatePortPinWavePci
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF (DEBUGLVL_LIFETIME, ("Creating WAVEPCI Pin"));

    STD_CREATE_BODY_
    (
        CPortPinWavePci,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTPINWAVEPCI
    );
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortPinWavePci::~CPortPinWavePci()
 *****************************************************************************
 * Destructor.
 */
CPortPinWavePci::~CPortPinWavePci()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVEPCI Pin (0x%08x)", this));

    ASSERT(!Stream);
    ASSERT(!m_IrpStream);

    if( ServiceGroup )
    {
        // note: ServiceGroup->RemoveMember is called in ::Close.
        // release is done here to prevent leaks on failed ::Init
        ServiceGroup->Release();
        ServiceGroup = NULL;
    }
    if (m_Worker)
    {
        KsUnregisterWorker(m_Worker);
        m_Worker = NULL;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsWorker NULL, never unregistered!"));
    }

    if (DataFormat)
    {
        ExFreePool(DataFormat);
        DataFormat = NULL;
    }
    
    if (Port)
    {
        Port->Release();
        Port = NULL;
    }
    
    if (Filter)
    {
        Filter->Release();
        Filter = NULL;
    }
}

/*****************************************************************************
 * CPortPinWavePci::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTPINWAVEPCI(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the GUID.
        *Object = PVOID(PPORTPINWAVEPCI(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IServiceSink))
    {
        *Object = PVOID(PSERVICESINK(this));
    }
    else if (IsEqualGUIDAligned( Interface,IID_IKsShellTransport ))
    {
        *Object = PVOID(PIKSSHELLTRANSPORT( this ));

    } 
    else
    if (IsEqualGUIDAligned( Interface,IID_IKsWorkSink ))
    {
        *Object = PVOID(PIKSWORKSINK( this ));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPreFetchOffset))
    {
        *Object = PVOID(PPREFETCHOFFSET(this));
    } 
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortPinWavePci::Init()
 *****************************************************************************
 * Initializes the object.
 */
HRESULT
CPortPinWavePci::
Init
(
    IN      CPortWavePci *          Port_,
    IN      CPortFilterWavePci *    Filter_,
    IN      PKSPIN_CONNECT          PinConnect,
    IN      PKSPIN_DESCRIPTOR       PinDescriptor,
    IN      PDEVICE_OBJECT          DeviceObject
)
{
    PAGED_CODE();

    ASSERT(Port_);
    ASSERT(Filter_);
    ASSERT(PinConnect);
    ASSERT(PinDescriptor);
    ASSERT(DeviceObject);

    _DbgPrintF( DEBUGLVL_LIFETIME, ("Initializing WAVEPCI Pin (0x%08x)", this));

    Port = Port_;
    Port->AddRef();

    Filter = Filter_;
    Filter->AddRef();

    Id          = PinConnect->PinId;
    Descriptor  = PinDescriptor;
    m_DeviceState = KSSTATE_STOP;
    m_Flushing  = FALSE;
    m_Suspended = FALSE;

    m_ulPreFetchOffset        = 0;
    m_ullPrevWriteOffset      = 0;
    m_bDriverSuppliedPrefetch = FALSE;

    InitializeListHead( &m_ClockList );
    KeInitializeSpinLock( &m_ClockListLock );

    KsInitializeWorkSinkItem( &m_WorkItem, this );
    NTSTATUS ntStatus = KsRegisterCountedWorker( DelayedWorkQueue,
                                                 &m_WorkItem,
                                                 &m_Worker );

    InitializeInterlockedListHead( &m_IrpsToSend );
    InitializeInterlockedListHead( &m_IrpsOutstanding );

    KeInitializeDpc( &m_ServiceTimerDpc,
                     PKDEFERRED_ROUTINE(TimerServiceRoutine),
                     PVOID(this) );
    KeInitializeTimer( &m_ServiceTimer );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcCaptureFormat( &DataFormat,
                                    PKSDATAFORMAT(PinConnect + 1),
                                    Port->m_pSubdeviceDescriptor,
                                    Id );
    }

    //
    // Reference the next pin if this is a source.  This must be undone if
    // this function fails.
    //
    if (NT_SUCCESS(ntStatus) && PinConnect->PinToHandle)
    {
        ntStatus = ObReferenceObjectByHandle( PinConnect->PinToHandle,
                                              GENERIC_READ | GENERIC_WRITE,
                                              NULL,
                                              KernelMode,
                                              (PVOID *) &m_ConnectionFileObject,
                                              NULL );

        if (NT_SUCCESS(ntStatus))
        {
            m_ConnectionDeviceObject = IoGetRelatedDeviceObject(m_ConnectionFileObject);
        }
    }

    if(NT_SUCCESS(ntStatus))
    {
        ntStatus =
            Port->Miniport->NewStream
            (
                &Stream,
                NULL,
                NonPagedPool,
                PPORTWAVEPCISTREAM(this),
                Id,
                Descriptor->DataFlow == KSPIN_DATAFLOW_OUT,
                DataFormat,
                &DmaChannel,
                &ServiceGroup
            );

        if(!NT_SUCCESS(ntStatus))
        {
            // don't trust any of the return parameters fro the miniport
            DmaChannel = NULL;
            ServiceGroup = NULL;
            Stream = NULL;
        }
    }

    if(NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewIrpStreamPhysical
            (
                &m_IrpStream,
                NULL,
                Descriptor->DataFlow == KSPIN_DATAFLOW_IN,
                PinConnect,
                DeviceObject,
                DmaChannel->GetAdapterObject()
            );

        if(NT_SUCCESS(ntStatus))
        {
            ntStatus = BuildTransportCircuit();

#if (DBG)
            if(!NT_SUCCESS(ntStatus))
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWavePci::Init BuildTransportCircuit() returned 0x%X",ntStatus));
            }
#endif

            if( NT_SUCCESS(ntStatus) )
            {
                m_IrpStream->RegisterPhysicalNotifySink(PIRPSTREAMNOTIFYPHYSICAL(this));
    
                if (ServiceGroup)
                {
                    ServiceGroup->AddMember(PSERVICESINK(this));
                } 
                else
                {
                    // if NewStream didn't provide us with a service group, we need to set up
                    // periodic timer DPCs for processing position and clock events.
                    m_UseServiceTimer = TRUE;
                }
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        // add the pin to the port pin list
        KeWaitForSingleObject( &(Port->m_PinListMutex),
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
                                                         
        InsertTailList( &(Port->m_PinList),
                        &m_PinListEntry );

        KeReleaseMutex( &(Port->m_PinListMutex), FALSE );
        
        //
        // Set up context for properties.
        //
        m_propertyContext.pSubdevice           = PSUBDEVICE(Port);
        m_propertyContext.pSubdeviceDescriptor = Port->m_pSubdeviceDescriptor;
        m_propertyContext.pPcFilterDescriptor  = Port->m_pPcFilterDescriptor;
        m_propertyContext.pUnknownMajorTarget  = Port->Miniport;
        m_propertyContext.pUnknownMinorTarget  = Stream;
        m_propertyContext.ulNodeId             = ULONG(-1);

        //
        // Turn on all nodes whose use is specified in the format.  The DSound
        // format contains some capabilities bits.  The port driver uses
        // PcCaptureFormat to convert the DSound format to a WAVEFORMATEX
        // format, making sure the specified caps are satisfied by nodes in
        // the topology.  If the DSound format is used, this call enables all
        // the nodes whose corresponding caps bits are turned on in the format.
        //
        PcAcquireFormatResources
        (
            PKSDATAFORMAT(PinConnect + 1),
            Port->m_pSubdeviceDescriptor,
            Id,
            &m_propertyContext
        );

        _DbgPrintF( DEBUGLVL_BLAB, ("Stream created"));
    }
    else
    {
        // release the allocator if it was assigned
        if( m_AllocatorFileObject )
        {
            ObDereferenceObject( m_AllocatorFileObject );
            m_AllocatorFileObject = NULL;
        }

        // dereference the next pin if this is a source pin
        if( m_ConnectionFileObject )
        {
            ObDereferenceObject( m_ConnectionFileObject );
            m_ConnectionFileObject = NULL;
        }

        PIKSSHELLTRANSPORT distribution;
        if( m_RequestorTransport )
        {
            distribution = m_RequestorTransport;
        }
        else
        {
            distribution = m_QueueTransport;
        }

        if( distribution )
        {
            distribution->AddRef();
            while( distribution )
            {
                PIKSSHELLTRANSPORT nextTransport;
                distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
                distribution->Release();
                distribution = nextTransport;
            }
        }

        // dereference the queue if there is one
        if( m_QueueTransport )
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        // dereference the requestor if there is one
        if( m_RequestorTransport )
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }

        if (m_IrpStream)
        {
            m_IrpStream->Release();
            m_IrpStream = NULL;
        }
    }

    return ntStatus;
}

#pragma code_seg()

STDMETHODIMP_(NTSTATUS) 
CPortPinWavePci::NewIrpTarget(
    OUT PIRPTARGET * IrpTarget,
    OUT BOOLEAN * ReferenceParent,
    IN PUNKNOWN UnkOuter,
    IN POOL_TYPE PoolType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PKSOBJECT_CREATE ObjectCreate
    )

/*++

Routine Description:
    Handles the NewIrpTarget method for IIrpTargetFactory interface.

Arguments:
    OUT PIRPTARGET * IrpTarget -
    
    OUT BOOLEAN * ReferenceParent -

    IN PUNKNOWN UnkOuter -

    IN POOL_TYPE PoolType -

    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

    OUT PKSOBJECT_CREATE ObjectCreate -

Return:

--*/

{
    NTSTATUS                Status;
    PKSCLOCK_CREATE         ClockCreate;
    PWAVEPCICLOCK           WavePciClock;
    PUNKNOWN                Unknown;
    
    PAGED_CODE();

    ASSERT( IrpTarget );
    ASSERT( DeviceObject );
    ASSERT( Irp );
    ASSERT( ObjectCreate );
    ASSERT( Port );

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortPinWavePci::::NewIrpTarget"));
    
    Status = 
        KsValidateClockCreateRequest( 
            Irp,
            &ClockCreate );
    
    if (NT_SUCCESS( Status )) {
    
        //
        // Clocks use spinlocks, this better be NonPaged
        //
        
        ASSERT( PoolType == NonPagedPool );
    
        Status =
            CreatePortClockWavePci(
                &Unknown,
                this,
                GUID_NULL,
                UnkOuter,
                PoolType );

        if (NT_SUCCESS( Status )) {

            Status =
                Unknown->QueryInterface(
                    IID_IIrpTarget,
                    (PVOID *) &WavePciClock );

            if (NT_SUCCESS( Status )) {
                PWAVEPCICLOCK_NODE   Node;
                KIRQL                irqlOld;
                
                //
                // Hook this child into the list of clocks.  Note that
                // when this child is released, it will remove ITSELF
                // from this list by acquiring the given SpinLock.
                //
                
                Node = WavePciClock->GetNodeStructure();
                Node->ListLock = &m_ClockListLock;
                Node->FileObject = 
                    IoGetCurrentIrpStackLocation( Irp )->FileObject;
                KeAcquireSpinLock( &m_ClockListLock, &irqlOld );
                InsertTailList( 
                    &m_ClockList, 
                    &Node->ListEntry );
                KeReleaseSpinLock( &m_ClockListLock, irqlOld );
                
                *ReferenceParent = FALSE;
                *IrpTarget = WavePciClock;
            }

            Unknown->Release();
        }
    }

    return Status;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinWavePci::SetPreFetchOffset()
 *****************************************************************************
 * Set the prefetch offset for this pin, and
 * turn on that code path in GetKsAudioPosition.
 */
STDMETHODIMP_(VOID)
CPortPinWavePci::
SetPreFetchOffset
(
    IN  ULONG PreFetchOffset
)
{
    m_ulPreFetchOffset = PreFetchOffset;
    m_bDriverSuppliedPrefetch = TRUE;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinWavePci::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT( irpSp );

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortPinWavePci::DeviceIoControl"));

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PROPERTY"));

        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                Port->m_pSubdeviceDescriptor->PinPropertyTables[Id].PropertySetCount,
                Port->m_pSubdeviceDescriptor->PinPropertyTables[Id].PropertySets,
                &m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_ENABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = Id;
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->PinEventTables[Id].EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->PinEventTables[Id].EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }              
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_DISABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(Port->m_EventList);
            EventContext.ulPinId = Id;
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->PinEventTables[Id].EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->PinEventTables[Id].EventSets;
            
            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }              
        break;

    case IOCTL_KS_WRITE_STREAM:
    case IOCTL_KS_READ_STREAM:
        if
        (   m_TransportSink
        &&  (!m_ConnectionFileObject)
        &&  (Descriptor->Communication == KSPIN_COMMUNICATION_SINK)
        &&  (   (   (Descriptor->DataFlow == KSPIN_DATAFLOW_IN)
                &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                    ==  IOCTL_KS_WRITE_STREAM
                    )
                )
            ||  (   (Descriptor->DataFlow == KSPIN_DATAFLOW_OUT)
                &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                    ==  IOCTL_KS_READ_STREAM
                    )
                )
            )
        )
        {
            if (m_DeviceState == KSSTATE_STOP) {
                //
                // Stopped...reject.
                //
                ntStatus = STATUS_INVALID_DEVICE_STATE;
            }
            else if (m_Flushing) 
            {
                //
                // Flushing...reject.
                //
                ntStatus = STATUS_DEVICE_NOT_READY;
            }
            else
            {
                // We going to submit the IRP to our pipe, so make sure that
                // we start out with a clear status field.
                Irp->IoStatus.Status = STATUS_SUCCESS;
                
                //
                // Send around the circuit.  We don't use KsShellTransferKsIrp
                // because we want to stop if we come back around to this pin.
                //
                PIKSSHELLTRANSPORT transport = m_TransportSink;
                while (transport) {
                    if (transport == PIKSSHELLTRANSPORT(this)) {
                        //
                        // We have come back around to the pin.  Just complete
                        // the IRP.
                        //
                        if (ntStatus == STATUS_PENDING) {
                            ntStatus = STATUS_SUCCESS;
                        }
                        break;
                    }

                    PIKSSHELLTRANSPORT nextTransport;
                    ntStatus = transport->TransferKsIrp(Irp,&nextTransport);

                    ASSERT(NT_SUCCESS(ntStatus) || ! nextTransport);

                    transport = nextTransport;
                }
            }
        }
        break;
        
    case IOCTL_KS_RESET_STATE:
        {
            KSRESET ResetType = KSRESET_BEGIN;  //  initial value

            ntStatus = KsAcquireResetValue( Irp, &ResetType );
            DistributeResetState(ResetType);
        }
        break;
        
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortPinWavePci::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);
    
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::Close"));

    if( m_UseServiceTimer )
    {
        KeCancelTimer( &m_ServiceTimer );
    }

    // Remove this pin from the port's list of pins
    if(Port)
    {
        KeWaitForSingleObject( &(Port->m_PinListMutex),
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        RemoveEntryList( &m_PinListEntry );

        KeReleaseMutex( &(Port->m_PinListMutex), FALSE );
    }

    // release the service group
    if( ServiceGroup )
    {
        ServiceGroup->RemoveMember(PSERVICESINK(this));
    }

    // release the clock if it was assigned
    if( m_ClockFileObject )
    {
        ObDereferenceObject( m_ClockFileObject );
        m_ClockFileObject = NULL;
    }

    // release the allocator if it was assigned
    if( m_AllocatorFileObject )
    {
        ObDereferenceObject( m_AllocatorFileObject );
        m_AllocatorFileObject = NULL;
    }

    // dereference the next pin if this is a source pin
    if( m_ConnectionFileObject )
    {
        ObDereferenceObject( m_ConnectionFileObject );
        m_ConnectionFileObject = NULL;
    }

    // Release the stream.
    if(Stream)
    {
        Stream->Release();
        Stream = NULL;
    }

    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport) {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    }
    else
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // If this section owns the pipe, it must disconnect the entire circuit.
    //
    if (distribution) {

        //
        // We are going to use Connect() to set the transport sink for each
        // component in turn to NULL.  Because Connect() takes care of the
        // back links, transport source pointers for each component will
        // also get set to NULL.  Connect() gives us a referenced pointer
        // to the previous transport sink for the component in question, so
        // we will need to do a release for each pointer obtained in this
        // way.  For consistency's sake, we will release the pointer we
        // start with (distribution) as well, so we need to AddRef it first.
        //
        distribution->AddRef();
        while (distribution) {
            PIKSSHELLTRANSPORT nextTransport;
            distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
            distribution->Release();
            distribution = nextTransport;
        }
    }

    //
    // Dereference the queue if there is one.
    //
    if (m_QueueTransport) {
        m_QueueTransport->Release();
        m_QueueTransport = NULL;
    }
    
    //
    // Dereference the requestor if there is one.
    //
    if (m_RequestorTransport) {
        m_RequestorTransport->Release();
        m_RequestorTransport = NULL;
    }

    // Release the irpstream...
    m_IrpStream->Release();
    m_IrpStream = NULL;

    //
    // Decrement instance counts.
    //
    ASSERT(Port);
    ASSERT(Filter);
    PcTerminateConnection
    (   
        Port->m_pSubdeviceDescriptor,
        Filter->m_propertyContext.pulPinInstanceCounts,
        Id
    );

    //
    // free any events in the port event list associated with this pin
    //
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( irpSp->FileObject,
                     &( Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortPinWavePci);
DEFINE_INVALID_WRITE(CPortPinWavePci);
DEFINE_INVALID_FLUSH(CPortPinWavePci);
DEFINE_INVALID_QUERYSECURITY(CPortPinWavePci);
DEFINE_INVALID_SETSECURITY(CPortPinWavePci);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortPinWavePci);
DEFINE_INVALID_FASTREAD(CPortPinWavePci);
DEFINE_INVALID_FASTWRITE(CPortPinWavePci);

#pragma code_seg()

/*****************************************************************************
 * CPortPinWavePci::IrpSubmitted()
 *****************************************************************************
 * Handles notification that an irp was submitted.
 */
STDMETHODIMP_(void)
CPortPinWavePci::
IrpSubmitted
(
    IN      PIRP        Irp,
    IN      BOOLEAN     WasExhausted
)
{
    if( WasExhausted && Stream )
    {
        Stream->MappingAvailable();
    }
}

/*****************************************************************************
 * CPortPinWavePci::MappingsCancelled()
 *****************************************************************************
 * Handles notification that mappings are being cancelled.
 */
STDMETHODIMP_(void)
CPortPinWavePci::
MappingsCancelled
(
    IN      PVOID           FirstTag,
    IN      PVOID           LastTag,
    OUT     PULONG          MappingsCancelled
)
{
    if(Stream)
    {
        Stream->RevokeMappings(FirstTag,
                                 LastTag,
                                 MappingsCancelled);
    }
}

STDMETHODIMP_(NTSTATUS) 
CPortPinWavePci::ReflectDeviceStateChange(
    KSSTATE State
    )

/*++

Routine Description:
    Reflects the device state change to any component that requires
    interactive state change information.  Note that the objects

Arguments:
    KSSTATE State -
        new device state

Return:
    STATUS_SUCCESS

--*/

{
    KIRQL               irqlOld;
    PWAVEPCICLOCK_NODE  ClockNode;
    PLIST_ENTRY         ListEntry;
    
    KeAcquireSpinLock( &m_ClockListLock, &irqlOld );
    
    for (ListEntry = m_ClockList.Flink; 
        ListEntry != &m_ClockList; 
        ListEntry = ListEntry->Flink) {
        
        ClockNode = 
            (PWAVEPCICLOCK_NODE)
                CONTAINING_RECORD( ListEntry,
                                   WAVEPCICLOCK_NODE,
                                   ListEntry);
        ClockNode->IWavePciClock->SetState(State );
    }
    
    KeReleaseSpinLock( &m_ClockListLock, irqlOld );
    
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinWavePci::PowerNotify()
 *****************************************************************************
 * Called by the port to notify of power state changes.
 */
STDMETHODIMP_(void)
CPortPinWavePci::
PowerNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    // grab the control mutex
    KeWaitForSingleObject( &Port->ControlMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    // do the right thing based on power state
    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // keep track of whether or not we're suspended
            m_Suspended = FALSE;

            // if we're not in the right state, change the miniport stream state.
            if( m_DeviceState != CommandedState )
            {
                //
                // Transitions go through the intermediate states.
                //
                if (m_DeviceState == KSSTATE_STOP)              //  going to stop
                {
                    switch (CommandedState)
                    {
                        case KSSTATE_RUN:                       //  going from run
                            Stream->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                     //  going from run/pause
                            Stream->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                   //  already only one state away
                            break;
                    }
                }
                else if (m_DeviceState == KSSTATE_ACQUIRE)      //  going to acquire
                {
                    if (CommandedState == KSSTATE_RUN)          //  going from run
                    {
                        Stream->SetState(KSSTATE_PAUSE);        //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_PAUSE)        //  going to pause
                {
                    if (CommandedState == KSSTATE_STOP)         //  going from stop
                    {
                        Stream->SetState(KSSTATE_ACQUIRE);      //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_RUN)          //  going to run
                {
                    switch (CommandedState)
                    {
                        case KSSTATE_STOP:                      //  going from stop
                            Stream->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                   //  going from acquire
                            Stream->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                     //  already only one state away
                            break;         
                    }
                }

                // we should now be one state away from our target
                Stream->SetState(m_DeviceState);
                CommandedState = m_DeviceState;
             }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            //
            // keep track of whether or not we're suspended
            m_Suspended = TRUE;

            // if we're not in KSSTATE_STOP, place the stream
            // in the stop state so that DMA is stopped.
            switch (m_DeviceState)
            {
                case KSSTATE_RUN:
                    Stream->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                case KSSTATE_PAUSE:
                    Stream->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                case KSSTATE_ACQUIRE:
                    Stream->SetState(KSSTATE_STOP);
            }
            CommandedState = KSSTATE_STOP;
            break;

        default:
            _DbgPrintF(DEBUGLVL_TERSE,("Unknown Power State"));
            break;
    }

    // release the control mutex
    KeReleaseMutex(&Port->ControlMutex, FALSE);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinWavePci::SetDeviceState()
 *****************************************************************************
 *
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
SetDeviceState
(   
    IN  KSSTATE             NewState,
    IN  KSSTATE             OldState,
    OUT PIKSSHELLTRANSPORT* NextTransport
)
{
    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::SetDeviceState(0x%08x)",this));

    ASSERT(NextTransport);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( m_State != NewState )
    {
        m_State = NewState;

        if( NewState > OldState )
        {
            *NextTransport = m_TransportSink;
        }
        else
        {
            *NextTransport = m_TransportSource;
        }
    }

    // set the miniport stream state if we're not suspended.
    if( FALSE == m_Suspended )
    {
        ntStatus = Stream->SetState(NewState);

        if( NT_SUCCESS(ntStatus) )
        {
            CommandedState = NewState;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        switch (NewState)
        {
        case KSSTATE_STOP:
            if( OldState != KSSTATE_STOP )
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.SetDeviceState: cancelling outstanding IRPs",this));
                CancelIrpsOutstanding();

                m_ullPrevWriteOffset    = 0; //  Reset this.
                m_ullPlayPosition       = 0;
                m_ullPosition           = 0;
            }
            break;

        case KSSTATE_PAUSE:
            //
            //  If we cross a position marker, 
            //  but pause the stream before RequestService fires, 
            //  this event would not fire otherwise.
            //
            if( OldState != KSSTATE_RUN )
            {
                KIRQL oldIrql;
                KeRaiseIrql(DISPATCH_LEVEL,&oldIrql);

                GeneratePositionEvents();

                KeLowerIrql(oldIrql);
            }
            _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_PAUSE"));
            break;

        case KSSTATE_RUN:
            _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_RUN"));
            break;
        }

        if (NT_SUCCESS(ntStatus))
        {
            ReflectDeviceStateChange(NewState);
            m_DeviceState = NewState;

            if( m_UseServiceTimer )
            {
                if( (m_DeviceState == KSSTATE_PAUSE) ||
                    (m_DeviceState == KSSTATE_RUN) )
                {
                    LARGE_INTEGER TimeoutTime = RtlConvertLongToLargeInteger( -100000 );    // 20ms relative
                    KeSetTimerEx( &m_ServiceTimer,
                                  TimeoutTime,
                                  20,   // 20ms periodic
                                  &m_ServiceTimerDpc );
                }
                else
                {
                    KeCancelTimer( &m_ServiceTimer );
                }
            }
        }
    }
    else
    {
        *NextTransport = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDeviceState()
 *****************************************************************************
 * Handles device state property access for the pin.
 */
static
NTSTATUS
PinPropertyDeviceState
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PKSSTATE    DeviceState
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DeviceState);

    CPortPinWavePci *that = 
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp(Irp);
    CPortWavePci *port = that->Port;

    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_BLAB,("PinPropertyDeviceState"));

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        // Handle property get.
        *DeviceState = that->m_DeviceState;
        Irp->IoStatus.Information = sizeof(KSSTATE);
        ntStatus = STATUS_SUCCESS;
        if( (that->Descriptor->DataFlow == KSPIN_DATAFLOW_OUT) &&
            (*DeviceState == KSSTATE_PAUSE) )
        {
            ntStatus = STATUS_NO_DATA_DETECTED;
        }
    }
    else
    {
        // Serialize.
        KeWaitForSingleObject
        (
            &port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );

        if( *DeviceState < that->m_DeviceState )
        {
            KSSTATE oldState = that->m_DeviceState;
            that->m_DeviceState = *DeviceState;

            ntStatus = that->DistributeDeviceState( *DeviceState, oldState );
            if( !NT_SUCCESS(ntStatus) )
            {
                that->m_DeviceState = oldState;
            }
        }
        else
        {
            ntStatus = that->DistributeDeviceState( *DeviceState, that->m_DeviceState );
            if( NT_SUCCESS(ntStatus) )
            {
                that->m_DeviceState = *DeviceState;
            }
        }

        KeReleaseMutex(&port->ControlMutex,FALSE);
    }

    return ntStatus;
}

/*****************************************************************************
 * PinPropertyDataFormat()
 *****************************************************************************
 * Handles data format property access for the pin.
 */
static
NTSTATUS
PinPropertyDataFormat
(
    IN PIRP                 Irp,
    IN PKSPROPERTY          Property,
    IN OUT PKSDATAFORMAT    DataFormat
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DataFormat);

    _DbgPrintF( DEBUGLVL_BLAB, ("PinPropertyDataFormat"));

    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);
    CPortPinWavePci *that = 
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp(Irp);
    CPortWavePci *port = that->Port;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        if (that->DataFormat)
        {
            if  (   !irpSp->Parameters.DeviceIoControl.OutputBufferLength
                )
            {
                Irp->IoStatus.Information = that->DataFormat->FormatSize;
                ntStatus = STATUS_BUFFER_OVERFLOW;
            }
            else
            if  (   irpSp->Parameters.DeviceIoControl.OutputBufferLength 
                >=  sizeof(that->DataFormat->FormatSize)
                )
            {
                RtlCopyMemory
                (
                    DataFormat,
                    that->DataFormat,
                    that->DataFormat->FormatSize
                );
                Irp->IoStatus.Information = that->DataFormat->FormatSize;
            }
            else
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(*DataFormat))
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        PKSDATAFORMAT FilteredDataFormat = NULL;

        //
        // Filter offensive formats.
        //
        ntStatus = 
            PcCaptureFormat
            (
                &FilteredDataFormat,
                DataFormat,
                port->m_pSubdeviceDescriptor,
                that->Id
            );

        if(NT_SUCCESS(ntStatus))
        {
            // Serialize
            KeWaitForSingleObject
            (
                &port->ControlMutex,
                Executive,
                KernelMode,
                FALSE,          // Not alertable.
                NULL
            );

            BOOL ResumeFlag = FALSE;

            // pause the stream if running
            if(that->m_DeviceState == KSSTATE_RUN)
            {
                ntStatus = that->DistributeDeviceState( KSSTATE_PAUSE, KSSTATE_RUN );
                if(NT_SUCCESS(ntStatus))
                {
                    ResumeFlag = TRUE;
                }
            }

            if(NT_SUCCESS(ntStatus))
            {
                // set the format on the miniport stream
                ntStatus = that->Stream->SetFormat(FilteredDataFormat);

                if(NT_SUCCESS(ntStatus))
                {
                    if( that->DataFormat )
                    {
                        ExFreePool(that->DataFormat);
                    }

                    that->DataFormat = FilteredDataFormat;
                    FilteredDataFormat = NULL;
                }

                if(ResumeFlag == TRUE)
                {
                    // restart the stream if required
                    NTSTATUS ntStatus2 = that->DistributeDeviceState( KSSTATE_RUN, KSSTATE_PAUSE );

                    if(NT_SUCCESS(ntStatus) && !NT_SUCCESS(ntStatus2))
                    {
                        ntStatus = ntStatus2;
                    }
                }
            }

            // Unserialize
            KeReleaseMutex(&port->ControlMutex,FALSE);

            if( FilteredDataFormat )
            {
                ExFreePool(FilteredDataFormat);
            }
        }
    }

    return ntStatus;
}

NTSTATUS 
CPortPinWavePci::PinPropertyAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSALLOCATOR_FRAMING AllocatorFraming
    )

/*++

Routine Description:
    Returns the allocator framing structure for the device.

Arguments:
    IN PIRP Irp -
        I/O request packet

    IN PKSPROPERTY Property -
        property containing allocator framing request

    OUT PKSALLOCATOR_FRAMING AllocatorFraming -
        resultant structure filled in by the port driver

Return:
    STATUS_SUCCESS

--*/

{
    CPortPinWavePci     *WavePciPin;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS Status;
    
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(AllocatorFraming);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("PinPropertyAllocatorFraming") );

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    
    ASSERT(irpSp);
    
    WavePciPin =
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp( Irp );
    
    Status = WavePciPin->Stream->GetAllocatorFraming( AllocatorFraming );

    // Now make sure the driver allocator meets some minimum alignment and
    // frame count requirements.
    
    if (NT_SUCCESS(Status)) {

        ULONG CacheAlignment = KeGetRecommendedSharedDataAlignment()-1;

        if (AllocatorFraming->FileAlignment < CacheAlignment) {
            AllocatorFraming->FileAlignment = CacheAlignment;
        }

        if (AllocatorFraming->Frames < 8) {
            AllocatorFraming->Frames = 8;
        }

    }

    return Status;

}

#pragma code_seg()

/*****************************************************************************
 * GetPosition()
 *****************************************************************************
 * Gets the current position.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
GetPosition
(   
    IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
)
{
    return Stream->GetPosition(&pIrpStreamPosition->ullStreamPosition);
}

/*****************************************************************************
 * GetKsAudioPosition()
 *****************************************************************************
 * Gets the current position offsets.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
GetKsAudioPosition
(   
    OUT     PKSAUDIO_POSITION   pKsAudioPosition
)
{
    ASSERT(pKsAudioPosition);

    //
    // Ask the IrpStream for position information.
    //
    IRPSTREAM_POSITION irpStreamPosition;
    NTSTATUS ntStatus = m_IrpStream->GetPosition(&irpStreamPosition);

    if (NT_SUCCESS(ntStatus))
    {
        if (!m_bDriverSuppliedPrefetch)
        {
            if (irpStreamPosition.bLoopedInterface)
            {
                // ASSERT(irpStreamPosition.ullStreamPosition >= irpStreamPosition.ullUnmappingPosition);

                //
                // Using looped interface.
                //
                // The play offset is based on the unmapping offset into the
                // packet.  Only ullStreamPosition reflects the port driver's
                // adjustment of the unmapping position, so the difference
                // between this value and the unmapping position must be
                // applied to the offset.
                //
                // WriteOffset is based on the mapping offset into the packet.
                //
                // For looped packets, a modulo is applied to both values.
                // Both offsets can reach the packet size, and the play offset
                // will often exceed it due to the adjustment.  For one-shots,
                // offsets are returned to zero when they reach or exceed the
                // buffer size.  Go figure.
                //
                ULONG ulPlayOffset = irpStreamPosition.ulUnmappingOffset;
                ULONGLONG ullPlayDelta = irpStreamPosition.ullStreamPosition -
                                         irpStreamPosition.ullUnmappingPosition;

                ULONG ulPlayAdjustment = ULONG( ullPlayDelta - irpStreamPosition.ullStreamOffset );

                ulPlayOffset += ulPlayAdjustment;

                if (irpStreamPosition.ulUnmappingPacketSize == 0)
                {
                    pKsAudioPosition->PlayOffset = 0;
                }
                else if (irpStreamPosition.bUnmappingPacketLooped)
                {
                    pKsAudioPosition->PlayOffset = ulPlayOffset % irpStreamPosition.ulUnmappingPacketSize;
                }
                else
                {
                    if (ulPlayOffset < irpStreamPosition.ulUnmappingPacketSize)
                    {
                        pKsAudioPosition->PlayOffset = ulPlayOffset;
                    }
                    else
                    {
                        pKsAudioPosition->PlayOffset = 0;
                    }
                }

                ULONG ulWriteOffset = irpStreamPosition.ulMappingOffset;

                if (irpStreamPosition.ulMappingPacketSize == 0)
                {
                    pKsAudioPosition->WriteOffset = 0;
                }
                else if (irpStreamPosition.bMappingPacketLooped)
                {
                    // set write offset equal to play offset for looped buffers
                    pKsAudioPosition->WriteOffset = pKsAudioPosition->PlayOffset;
                    //pKsAudioPosition->WriteOffset = ulWriteOffset % irpStreamPosition.ulMappingPacketSize;
                }
                else
                {
                    if( ulWriteOffset < irpStreamPosition.ulMappingPacketSize )
                    {
                        pKsAudioPosition->WriteOffset = ulWriteOffset;
                    }
                    else
                    {
                        pKsAudioPosition->WriteOffset = 0;
                    }
                }
            }
            else
            {
                //
                // Using standard interface.
                //
                // PlayOffset is based on the 'stream position', which is the
                // unmapping position with an adjustment from the port for
                // better accuracy.  The WriteOffset is the mapping position.
                // In starvation cases, the stream position can exceed the
                // current extent, so we limit the play offset accordingly.
                // Starvation cases can also produce anomolies in which there
                // is retrograde motion, so we fix that too.
                //
                pKsAudioPosition->PlayOffset = irpStreamPosition.ullStreamPosition;
                pKsAudioPosition->WriteOffset = irpStreamPosition.ullMappingPosition;

                //
                // Make sure we don't go beyond the current extent.
                //
                if( pKsAudioPosition->PlayOffset > irpStreamPosition.ullCurrentExtent )
                {
                    pKsAudioPosition->PlayOffset = irpStreamPosition.ullCurrentExtent;
                }

                //
                // Never back up.
                //
                if (pKsAudioPosition->PlayOffset < m_ullPlayPosition)
                {
                    pKsAudioPosition->PlayOffset = m_ullPlayPosition;
                }
                else
                {
                    m_ullPlayPosition = pKsAudioPosition->PlayOffset;
                }
            }
        }
        else    //  if prefetch
        {
            ULONGLONG ullWriteOffset;
            ULONG preFetchOffset = m_ulPreFetchOffset;
            if (KSSTATE_RUN != m_State)
            {
                preFetchOffset = 0;            
            }
            
            if (irpStreamPosition.bLoopedInterface)
            {
                //
                // Using looped interface.
                //
                // Same as above, but WriteOffset is based on play offset, plus prefetch amount.
                //
                ULONGLONG ullPlayOffset = irpStreamPosition.ulUnmappingOffset;
                ULONGLONG ullPlayDelta = irpStreamPosition.ullStreamPosition -
                                         irpStreamPosition.ullUnmappingPosition;

                ULONG ulPlayAdjustment = ULONG( ullPlayDelta - irpStreamPosition.ullStreamOffset );

                ullPlayOffset += ulPlayAdjustment;

                //
                // Increment the modified ullPlayOffset by prefetch amount to get ullWriteOffset
                // (and we DO want the unwrapped running version of the play position).
                //
                ullWriteOffset = ullPlayOffset + preFetchOffset;

                if (irpStreamPosition.ulUnmappingPacketSize)
                {
                    if (!irpStreamPosition.bUnmappingPacketLooped)
                    {
                        // One-shot, so RTZ instead of wrap-around.
                        if (ullPlayOffset < irpStreamPosition.ulUnmappingPacketSize)
                        {
                            // One-shot still playing.
                            pKsAudioPosition->PlayOffset = ullPlayOffset;
                        }
                        else
                        {
                            // One-shot, played correctly and wrapped.
                            pKsAudioPosition->PlayOffset = 0;
                        }
                    }
                    else
                    {
                        // Looping buffer, so play position wraps around.
                        pKsAudioPosition->PlayOffset = ullPlayOffset % irpStreamPosition.ulUnmappingPacketSize;
                    }
                }
                else    //  No IRP?
                {
                    pKsAudioPosition->PlayOffset = 0;
                }

                //
                // Now handle the write position.
                //
                if (irpStreamPosition.ulMappingPacketSize)
                {
                    //
                    // Cache ullWriteOffset if greater than previous value (we can't go backwards).
                    // No need to do this if we are returning 0 (in either success or error cases).
                    //
                    if (!irpStreamPosition.bMappingPacketLooped)
                    {
                        //
                        // One-shot, so RTZ instead of wrap-around.
                        //
                        if (ullWriteOffset < irpStreamPosition.ulMappingPacketSize)
                        {
                            //
                            // One-shot buffer that driver hasn't written completely yet.
                            // Now compare to cached value and use the higher of the two.
                            //
                            if (ullWriteOffset > m_ullPrevWriteOffset)
                            {
                                // Going forward, so update the cached value.
                                m_ullPrevWriteOffset = ullWriteOffset;
                            }
                            else
                            {
                                //  We can't go backwards, use cached value.
                                ullWriteOffset = m_ullPrevWriteOffset;
                            }
                            pKsAudioPosition->WriteOffset = ullWriteOffset;
                        }
                        else
                        {
                            //
                            // One-shot, completely written and ReturnedToZero.
                            // No need to mess with cached value.
                            // 
                            pKsAudioPosition->WriteOffset = m_ullPrevWriteOffset = 0;
                        }
                    }
                    else
                    {
                        //
                        // Looped buffer, so wrap-around.
                        //
                        if (ullWriteOffset > m_ullPrevWriteOffset)
                        {
                            //  bump up the previous running val
                            m_ullPrevWriteOffset = ullWriteOffset;
                        }
                        else
                        {
                            //  can't go backwards so use the previious running val
                            ullWriteOffset = m_ullPrevWriteOffset;
                        }
                        //
                        // Mind the wrap for looped buffers.
                        //
                        pKsAudioPosition->WriteOffset = ullWriteOffset % irpStreamPosition.ulMappingPacketSize;
                    }
                }
                else    //  No IRP?
                {
                    pKsAudioPosition->WriteOffset = m_ullPrevWriteOffset = 0;
                }
            }
            else
            {
                //
                // Using standard interface.
                //
                // Same as above, but WriteOffset is based on play offset, plus prefetch amount.
                //
                pKsAudioPosition->PlayOffset = irpStreamPosition.ullStreamPosition;

                if( pKsAudioPosition->PlayOffset > irpStreamPosition.ullCurrentExtent )
                {
                    // Make sure we don't go beyond the current extent.
                    pKsAudioPosition->PlayOffset = irpStreamPosition.ullCurrentExtent;
                }

                if (pKsAudioPosition->PlayOffset > m_ullPlayPosition)
                {
                    // 
                    // Cache the streamed play position.
                    //
                    m_ullPlayPosition = pKsAudioPosition->PlayOffset;
                }
                else
                {
                    //
                    // Never back up, so use the cached play position.
                    //
                    pKsAudioPosition->PlayOffset = m_ullPlayPosition;
                }
                
                // increment PlayOffset by the prefetch amount
                pKsAudioPosition->WriteOffset = pKsAudioPosition->PlayOffset + preFetchOffset;

                //
                // We can't report more than the mapping position, certainly...
                //
                if (pKsAudioPosition->WriteOffset > irpStreamPosition.ullMappingPosition)
                {
                    //
                    // ...so clamp it instead.
                    //
                    pKsAudioPosition->WriteOffset = irpStreamPosition.ullMappingPosition;
                }

                if (pKsAudioPosition->WriteOffset > m_ullPrevWriteOffset)
                {
                    //
                    // Cache WriteOffset if greater than previous WriteOffset.
                    //
                    m_ullPrevWriteOffset = pKsAudioPosition->WriteOffset;
                }
                else
                {
                    //
                    // Otherwise, use previous value (we cannot go backwards).
                    //
                    pKsAudioPosition->WriteOffset = m_ullPrevWriteOffset;
                }
            }   //  standard interface
        }       //  prefetch
    }           //  getposition returned success

    return ntStatus;
}

/*****************************************************************************
 * PinPropertyPosition()
 *****************************************************************************
 * Handles position property access for the pin.
 */
static
NTSTATUS
PinPropertyPosition
(
    IN      PIRP                pIrp,
    IN      PKSPROPERTY         pKsProperty,
    IN OUT  PKSAUDIO_POSITION   pKsAudioPosition
)
{
    PAGED_CODE();
    
    NTSTATUS ntStatus;

    ASSERT(pIrp);
    ASSERT(pKsProperty);
    ASSERT(pKsAudioPosition);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyPosition"));
    CPortPinWavePci *that =
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp(pIrp);
    ASSERT(that);

    if (pKsProperty->Flags & KSPROPERTY_TYPE_GET)
    {
        ntStatus = that->GetKsAudioPosition(pKsAudioPosition);

        if (NT_SUCCESS(ntStatus))
        {
            pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);
        }
    }
    else
    {
        ASSERT(that->Port);
        ASSERT(that->m_IrpStream);
        ASSERT(that->DataFormat);
        ASSERT(that->DataFormat->SampleSize);

        ULONGLONG ullOffset = pKsAudioPosition->PlayOffset - 
                             (pKsAudioPosition->PlayOffset % that->DataFormat->SampleSize);

        BOOL RestartNeeded = FALSE;

        // grab the control mutex
        KeWaitForSingleObject( &that->Port->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        if (that->m_DeviceState == KSSTATE_RUN)
        {
            that->Stream->SetState(KSSTATE_PAUSE);
            RestartNeeded = TRUE;
        }

        // We previously raised to DISPATCH_LEVEL around SetPacketOffsets.
        // However, SetPacketOffsets grabs a spinlock first off, so this
        // can't be the whole story.  I believe the reason this code exists 
        // is to attempt to synchronize any additional SetPos calls that 
        // arrive.  However, this is unnecessary since we are already 
        // synchronized down at the "HW access".
        // 
        ntStatus = that->m_IrpStream->SetPacketOffsets( ULONG(ullOffset),
                                                        ULONG(ullOffset) );

        if (NT_SUCCESS(ntStatus))
        {
            //
            //  Reset this - driver will catch up next time position is called.
            //
            that->m_ullPrevWriteOffset = 0; 

            that->m_ullPlayPosition = ullOffset;
            that->m_ullPosition     = ullOffset;
            that->m_bSetPosition    = TRUE;

            that->Stream->MappingAvailable();
        }

        if (RestartNeeded)
        {
            that->Stream->SetState(KSSTATE_RUN);
        }
        KeReleaseMutex(&that->Port->ControlMutex,FALSE);
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertySetContentId
 *****************************************************************************
 *
 */
static
NTSTATUS
PinPropertySetContentId
(
    IN PIRP        pIrp,
    IN PKSPROPERTY pKsProperty,
    IN PVOID       pvData
)
{
    PAGED_CODE();

    ULONG ContentId;
    NTSTATUS ntStatus;
    
    ASSERT(pIrp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    _DbgPrintF(DEBUGLVL_VERBOSE,("WavePci: PinPropertySetContentId"));
    if (KernelMode == pIrp->RequestorMode)
    {
        CPortPinWavePci *that = (CPortPinWavePci *) KsoGetIrpTargetFromIrp(pIrp);
        ASSERT(that);

        ContentId = *(PULONG)pvData;
        ntStatus = DrmForwardContentToStream(ContentId, that->Stream);
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    return ntStatus;
}

/*****************************************************************************
 * PinAddEvent_Position()
 *****************************************************************************
 * Enables the position pin event.
 */
static
NTSTATUS
PinAddEvent_Position
(
    IN      PIRP                                    pIrp,
    IN      PLOOPEDSTREAMING_POSITION_EVENT_DATA    pPositionEventData,
    IN      PPOSITION_EVENT_ENTRY                   pPositionEventEntry
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pPositionEventData);
    ASSERT(pPositionEventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinAddEvent_Position"));
    CPortPinWavePci *that =
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp(pIrp);
    ASSERT(that);

    //
    // Copy the position information.
    //
    pPositionEventEntry->EventType = PositionEvent;
    pPositionEventEntry->ullPosition = pPositionEventData->Position;

    //
    // Add the entry to the list.
    //
    that->Port->AddEventToEventList( &(pPositionEventEntry->EventEntry) );

    return STATUS_SUCCESS;
}

NTSTATUS    
CPortPinWavePci::AddEndOfStreamEvent(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry
    )

/*++

Routine Description:
    Handler for "add event" of end of stream events.

Arguments:
    IN PIRP Irp -
        I/O request packet

    IN PKSEVENTDATA EventData -
        pointer to event data

    IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry -
        event entry

Return:

--*/

{
    CPortPinWavePci  *PinWavePci;
    
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(EventData);
    ASSERT(EndOfStreamEventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("AddEndOfStreamEvent"));
    
    PinWavePci =
        (CPortPinWavePci *) KsoGetIrpTargetFromIrp( Irp );
    ASSERT( PinWavePci );        
    
    EndOfStreamEventEntry->EventType = EndOfStreamEvent;

    //
    // Add the entry to the list.
    //
    PinWavePci->Port->AddEventToEventList( &(EndOfStreamEventEntry->EventEntry) );

    return STATUS_SUCCESS;
}    

#pragma code_seg()
void
CPortPinWavePci::GenerateClockEvents(
    void
    )

/*++

Routine Description:
    Walks the list of children clock objects and requests 
    a clock event update.

Arguments:
    None.

Return:
    Nothing.

--*/

{
    PWAVEPCICLOCK_NODE  ClockNode;
    PLIST_ENTRY         ListEntry;
    
    if (!IsListEmpty(&m_ClockList)) {

        KeAcquireSpinLockAtDpcLevel( &m_ClockListLock );
        
        for (ListEntry = m_ClockList.Flink; 
            ListEntry != &m_ClockList; 
            ListEntry = ListEntry->Flink) {
            
            ClockNode = 
                (PWAVEPCICLOCK_NODE)
                    CONTAINING_RECORD( ListEntry,
                                       WAVEPCICLOCK_NODE,
                                       ListEntry);
            ClockNode->IWavePciClock->GenerateEvents( ClockNode->FileObject );
        }
        
        KeReleaseSpinLockFromDpcLevel( &m_ClockListLock );

    }

}

void
CPortPinWavePci::GenerateEndOfStreamEvents(
    void
    )
{
    KIRQL                       irqlOld;
    PENDOFSTREAM_EVENT_ENTRY    EndOfStreamEventEntry;
    PLIST_ENTRY                 ListEntry;
    
    if (!IsListEmpty( &(Port->m_EventList.List) )) {

        KeAcquireSpinLock( &(Port->m_EventList.ListLock), &irqlOld );

        for (ListEntry = Port->m_EventList.List.Flink;
             ListEntry != &(Port->m_EventList.List);) {
            EndOfStreamEventEntry =
                CONTAINING_RECORD(
                    ListEntry,
                    ENDOFSTREAM_EVENT_ENTRY,
                    EventEntry.ListEntry );

            ListEntry = ListEntry->Flink;
            
            //
            // Generate the end of stream event if the event type
            // is correct.
            //
            
            if (EndOfStreamEventEntry->EventType == EndOfStreamEvent) {
                KsGenerateEvent( &EndOfStreamEventEntry->EventEntry );
            }
        }

        KeReleaseSpinLock( &(Port->m_EventList.ListLock), irqlOld );
    }
}

/*****************************************************************************
 * GeneratePositionEvents()
 *****************************************************************************
 * Generates position events.
 */
void
CPortPinWavePci::
GeneratePositionEvents
(   void
)
{
    if (! IsListEmpty(&(Port->m_EventList.List)))
    {
        KSAUDIO_POSITION ksAudioPosition;

        if (NT_SUCCESS(GetKsAudioPosition(&ksAudioPosition)))
        {
            ULONGLONG ullPosition = ksAudioPosition.PlayOffset;

            KeAcquireSpinLockAtDpcLevel(&(Port->m_EventList.ListLock));

            for
            (
                PLIST_ENTRY pListEntry = Port->m_EventList.List.Flink;
                pListEntry != &(Port->m_EventList.List);
            )
            {
                PPOSITION_EVENT_ENTRY pPositionEventEntry =
                    CONTAINING_RECORD
                    (
                        pListEntry,
                        POSITION_EVENT_ENTRY,
                        EventEntry.ListEntry
                    );

                pListEntry = pListEntry->Flink;
                
                //
                // Generate an event if its in the interval.
                //
                if( pPositionEventEntry->EventType == PositionEvent )
                {
                    if( m_ullPosition <= ullPosition )
                    {
                        if( (pPositionEventEntry->ullPosition >= m_ullPosition) &&
                            (pPositionEventEntry->ullPosition < ullPosition) )
                        {
                            KsGenerateEvent(&pPositionEventEntry->EventEntry);
                        }
                    }
                    else
                    {
                        if( (pPositionEventEntry->ullPosition >= m_ullPosition) ||
                            (pPositionEventEntry->ullPosition < ullPosition) )
                        {
                            KsGenerateEvent(&pPositionEventEntry->EventEntry);
                        }
                    }
                }
            }

            KeReleaseSpinLockFromDpcLevel(&(Port->m_EventList.ListLock));

            m_ullPosition = ullPosition;
        }
    }
}

/*****************************************************************************
 * CPortPinWavePci::GetMapping()
 *****************************************************************************
 * Gets a mapping.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
GetMapping
(
    IN      PVOID               Tag,
    OUT     PPHYSICAL_ADDRESS   PhysicalAddress,
    OUT     PVOID *             VirtualAddress,
    OUT     PULONG              ByteCount,
    OUT     PULONG              Flags
)
{
    ASSERT(PhysicalAddress);
    ASSERT(VirtualAddress);
    ASSERT(ByteCount);
    ASSERT(Flags);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( m_IrpStream )
    {
        m_IrpStream->GetMapping( Tag,
                                 PhysicalAddress,
                                 VirtualAddress,
                                 ByteCount,
                                 Flags );
        if (*ByteCount == 0)
        {
            ntStatus = STATUS_NOT_FOUND;
        }
    }
    else
    {
        *ByteCount = 0;
        ntStatus = STATUS_NOT_FOUND;
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortPinWavePci::ReleaseMapping()
 *****************************************************************************
 * Releases mappings.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
ReleaseMapping
(
    IN      PVOID   Tag
)
{
    m_IrpStream->ReleaseMapping(Tag);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CPortPinWavePci::TerminatePacket()
 *****************************************************************************
 * Terminates the current packet.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
TerminatePacket
(   void
)
{
    m_IrpStream->TerminatePacket();

    return STATUS_SUCCESS;
}


//
// KSPROPSETID_Stream handlers
//

NTSTATUS
CPortPinWavePci::PinPropertyStreamAllocator
(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
)
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      irpSp;
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of 
        // allocators.  The returned handle is always NULL, but we
        // signal that we support the creation of allocators by
        // returning STATUS_SUCCESS.
        //
        *AllocatorHandle = NULL;
        Status = STATUS_SUCCESS;
    }
    else 
    {
        CPortPinWavePci  *PinWavePci;
        
        
    
        PinWavePci =
            (CPortPinWavePci *) KsoGetIrpTargetFromIrp( Irp );
        
        //
        // The allocator can only be specified when the device is
        // in KSSTATE_STOP.
        //
        
        KeWaitForSingleObject(
            &PinWavePci->Port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );
        
        if (PinWavePci->m_DeviceState != KSSTATE_STOP) {
            KeReleaseMutex( &PinWavePci->Port->ControlMutex, FALSE );
            return STATUS_INVALID_DEVICE_STATE;
        }
        
        //
        // Release the previous allocator, if any.
        //
        
        if (PinWavePci->m_AllocatorFileObject) {
            ObDereferenceObject( PinWavePci->m_AllocatorFileObject );
            PinWavePci->m_AllocatorFileObject = NULL;
        }
        
        //
        // Reference this handle and store the resultant pointer 
        // in the filter instance.  Note that the default allocator
        // does not ObReferenceObject() for its parent 
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the allocator and the pin object has a reference to the
        // allocator file object.
        //
        if (*AllocatorHandle != NULL) {
            Status = 
                ObReferenceObjectByHandle( 
                    *AllocatorHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    NULL,
                    ExGetPreviousMode(), 
                    (PVOID *) &PinWavePci->m_AllocatorFileObject,
                    NULL );
        }
        else
        {
            Status = STATUS_SUCCESS;
        }        
        KeReleaseMutex( &PinWavePci->Port->ControlMutex, FALSE );
    }        

    return Status;
}

NTSTATUS
CPortPinWavePci::PinPropertyStreamMasterClock
(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE ClockHandle
)
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      irpSp;
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of 
        // clocks.  The returned handle is always NULL, but we
        // signal that we support the creation of clocks by
        // returning STATUS_SUCCESS.
        //
        *ClockHandle = NULL;
        Status = STATUS_SUCCESS;
    }
    else
    {
        CPortPinWavePci  *PinWavePci;
        
        _DbgPrintF( DEBUGLVL_VERBOSE,("CPortPinWavePci setting master clock") );
    
        PinWavePci =
            (CPortPinWavePci *) KsoGetIrpTargetFromIrp( Irp );
        
        //
        // The clock can only be specified when the device is
        // in KSSTATE_STOP.
        //
        
        KeWaitForSingleObject(
            &PinWavePci->Port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );
        
        if (PinWavePci->m_DeviceState != KSSTATE_STOP) {
            KeReleaseMutex( &PinWavePci->Port->ControlMutex, FALSE );
            return STATUS_INVALID_DEVICE_STATE;
        }
        
        //
        // Release the previous clock, if any.
        //
        
        if (PinWavePci->m_ClockFileObject) {
            ObDereferenceObject( PinWavePci->m_ClockFileObject );
            PinWavePci->m_ClockFileObject = NULL;
        }
        
        //
        // Reference this handle and store the resultant pointer 
        // in the filter instance.  Note that the default clock
        // does not ObReferenceObject() for its parent 
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the clock and the pin object has a reference to the
        // clock file object.
        //
        if (*ClockHandle != NULL) {
            Status = 
                ObReferenceObjectByHandle( 
                    *ClockHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    NULL,
                    ExGetPreviousMode(), 
                    (PVOID *) &PinWavePci->m_ClockFileObject,
                    NULL );
        }
        else
        {
            Status = STATUS_SUCCESS;
        }        
        KeReleaseMutex( &PinWavePci->Port->ControlMutex, FALSE );
    }        

    return Status;
}

/*****************************************************************************
 * CPortPinWavePci::RequestService()
 *****************************************************************************
 * Service the pin.
 */
STDMETHODIMP_(void)
CPortPinWavePci::
RequestService
(   void
)
{
    //
    //  We only need service streams if they are running (big perf win)
    //
    if (Stream && (KSSTATE_RUN == m_DeviceState))
    {
        Stream->Service();
        GeneratePositionEvents();
        GenerateClockEvents();
    }
}

STDMETHODIMP_(NTSTATUS)
CPortPinWavePci::
TransferKsIrp
(
    IN PIRP Irp,
    OUT PIKSSHELLTRANSPORT* NextTransport
)

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the shell 
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::TransferKsIrp"));

    ASSERT(NextTransport);

    NTSTATUS status;

    if (m_ConnectionFileObject)
    {
        //
        // Source pin.
        //
        if (m_Flushing || (m_State == KSSTATE_STOP))
        {
            //
            // Shunt IRPs to the next component if we are reset or stopped.
            //
            *NextTransport = m_TransportSink;
        } 
        else
        {
            //
            // Send the IRP to the next device.
            //
            KsAddIrpToCancelableQueue( &m_IrpsToSend.ListEntry,
                                       &m_IrpsToSend.SpinLock,
                                       Irp,
                                       KsListEntryTail,
                                       NULL );

            KsIncrementCountedWorker(m_Worker);
            *NextTransport = NULL;
        }

        status = STATUS_PENDING;
    } 
    else
    {
        //
        // Sink pin:  complete the IRP.
        //
        PKSSTREAM_HEADER StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );
    
        PIO_STACK_LOCATION irpSp =  IoGetCurrentIrpStackLocation( Irp );
    
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_KS_WRITE_STREAM)
        {
            ASSERT( StreamHeader );
        
            //
            // Signal end-of-stream event for the renderer.
            //
            if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
        
                GenerateEndOfStreamEvents();
            }            
        }

        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        status = STATUS_PENDING;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS 
CPortPinWavePci::
DistributeDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState
    )

/*++

Routine Description:

    This routine sets the state of the pipe, informing all components in the
    pipe of the new state.  A transition to stop state destroys the pipe.

Arguments:

    NewState -
        The new state.

Return Value:

    Status.

--*/
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::DistributeDeviceState(%p)",this));

    KSSTATE state = OldState;
    KSSTATE targetState = NewState;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Determine if this pipe section controls the entire pipe.
    //
    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport) {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } 
    else 
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // Proceed sequentially through states.
    //
    while (state != targetState) {
        KSSTATE oldState = state;

        if (ULONG(state) < ULONG(targetState)) {
            state = KSSTATE(ULONG(state) + 1);
        } 
        else 
        {
            state = KSSTATE(ULONG(state) - 1);
        }

        NTSTATUS statusThisPass = STATUS_SUCCESS;

        //
        // Distribute state changes if this section is in charge.
        //
        if (distribution)
        {
            //
            // Tell everyone about the state change.
            //
            _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWavePci::DistributeDeviceState(%p) distributing transition from %d to %d",this,oldState,state));
            PIKSSHELLTRANSPORT transport = distribution;
            PIKSSHELLTRANSPORT previousTransport = NULL;
            while (transport)
            {
                PIKSSHELLTRANSPORT nextTransport;
                statusThisPass = 
                    transport->SetDeviceState(state,oldState,&nextTransport);

                ASSERT(NT_SUCCESS(statusThisPass) || ! nextTransport);

                if (NT_SUCCESS(statusThisPass))
                {
                    previousTransport = transport;
                    transport = nextTransport;
                } 
                else
                {
                    //
                    // Back out on failure.
                    //
                    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.DistributeDeviceState:  failed transition from %d to %d",this,oldState,state));
                    while (previousTransport)
                    {
                        transport = previousTransport;
                        (void) transport->SetDeviceState(oldState,state,&previousTransport);
                    }
                    break;
                }
            }
        }

        if (NT_SUCCESS(status) && !NT_SUCCESS(statusThisPass))
        {
            //
            // First failure:  go back to original state.
            //
            state = oldState;
            targetState = OldState;
            status = statusThisPass;
        }
    }

    return status;
}

void 
CPortPinWavePci::
DistributeResetState(
    IN KSRESET NewState
    )

/*++

Routine Description:

    This routine informs transport components that the reset state has 
    changed.

Arguments:

    NewState -
        The new reset state.

Return Value:

--*/

{
    PAGED_CODE();
    
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::DistributeResetState"));

    //
    // If this section of the pipe owns the requestor, or there is a 
    // non-shell pin up the pipe (so there's no bypass), this pipe is
    // in charge of telling all the components about state changes.
    //
    // (Always)

    //
    // Set the state change around the circuit.
    //
    PIKSSHELLTRANSPORT transport = 
        m_RequestorTransport ? 
         m_RequestorTransport : 
         m_QueueTransport;

    while (transport) {
        transport->SetResetState(NewState,&transport);
    }

    m_ResetState = NewState;
}

STDMETHODIMP_(void)
CPortPinWavePci::
Connect
(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
)
/*++

Routine Description:

    This routine establishes a shell transport connection.

Arguments:

Return Value:

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::Connect"));

    PAGED_CODE();

    KsShellStandardConnect(
        NewTransport,
        OldTransport,
        DataFlow,
        PIKSSHELLTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}

STDMETHODIMP_(void)
CPortPinWavePci::
SetResetState(
    IN KSRESET ksReset,
    OUT PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::SetResetState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
        if (m_Flushing) {
            CancelIrpsOutstanding();
            m_ullPrevWriteOffset    = 0; //  Reset this.
            m_ullPlayPosition       = 0;
            m_ullPosition           = 0;
        }
    } 
    else
    {
        *NextTransport = NULL;
    }
}

#if DBG
STDMETHODIMP_(void)
CPortPinWavePci::
DbgRollCall(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"Pin%p %d (%s) refs=%d",this,Id,m_ConnectionFileObject ? "src" : "snk",references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}

static
void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgPrintCircuit"));

    PAGED_CODE();

    ASSERT(Transport);

#define MAX_NAME_SIZE 64

    PIKSSHELLTRANSPORT transport = Transport;
    while (transport) {
        CHAR name[MAX_NAME_SIZE + 1];
        PIKSSHELLTRANSPORT next;
        PIKSSHELLTRANSPORT prev;

        transport->DbgRollCall(MAX_NAME_SIZE,name,&next,&prev);
        _DbgPrintF(DEBUGLVL_VERBOSE,("  %s",name));

        if (prev) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            prev->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (next2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" SOURCE'S(0x%08x) SINK(0x%08x) != THIS(%08x)",prev,next2,transport));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" NO SOURCE"));
        }

        if (next) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            next->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (prev2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" SINK'S(0x%08x) SOURCE(0x%08x) != THIS(%08x)",next,prev2,transport));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" NO SINK"));
        }

        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));

        transport = next;
        if (transport == Transport) {
            break;
        }
    }
}
#endif

STDMETHODIMP_(void)
CPortPinWavePci::
Work
(   void
)

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it sends
    IRPs to the connected pin using IoCallDriver().

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::Work"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do
    {
        PIRP irp = KsRemoveIrpFromCancelableQueue( &m_IrpsToSend.ListEntry,
                                                   &m_IrpsToSend.SpinLock,
                                                   KsListEntryHead,
                                                   KsAcquireAndRemoveOnlySingleItem );

        //
        // Irp's may have been cancelled, but the loop must still run through
        // the reference counting.
        //
        if (irp) {
            if (m_Flushing || (m_State == KSSTATE_STOP)) {
                //
                // Shunt IRPs to the next component if we are reset or stopped.
                //
                KsShellTransferKsIrp(m_TransportSink,irp);
            }
            else
            {
                //
                // Set up the next stack location for the callee.  
                //
                IoCopyCurrentIrpStackLocationToNext(irp);

                PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation(irp);

                irpSp->Parameters.DeviceIoControl.IoControlCode =
                    (Descriptor->DataFlow == KSPIN_DATAFLOW_OUT) ?
                     IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM;
                irpSp->DeviceObject = m_ConnectionDeviceObject;
                irpSp->FileObject = m_ConnectionFileObject;

                //
                // Add the IRP to the list of outstanding IRPs.
                //
                PIRPLIST_ENTRY irpListEntry = IRPLIST_ENTRY_IRP_STORAGE(irp);
                irpListEntry->Irp = irp;
                ExInterlockedInsertTailList(
                    &m_IrpsOutstanding.ListEntry,
                    &irpListEntry->ListEntry,
                    &m_IrpsOutstanding.SpinLock);

                IoSetCompletionRoutine( irp,
                                        CPortPinWavePci::IoCompletionRoutine,
                                        PVOID(this),
                                        TRUE,
                                        TRUE,
                                        TRUE);

                IoCallDriver(m_ConnectionDeviceObject,irp);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#pragma code_seg()

NTSTATUS
CPortPinWavePci::
IoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles the completion of an IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::IoCompletionRoutine 0x%08x",Irp));

//    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    CPortPinWavePci *pin = (CPortPinWavePci *) Context;

    //
    // Remove the IRP from the list of IRPs.  Most of the time, it will be at
    // the head of the list, so this is cheaper than it looks.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&pin->m_IrpsOutstanding.SpinLock,&oldIrql);
    for(PLIST_ENTRY listEntry = pin->m_IrpsOutstanding.ListEntry.Flink;
        listEntry != &pin->m_IrpsOutstanding.ListEntry;
        listEntry = listEntry->Flink) {
            PIRPLIST_ENTRY irpListEntry = 
                CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

            if (irpListEntry->Irp == Irp) {
                RemoveEntryList(listEntry);
                break;
            }
        }
    ASSERT(listEntry != &pin->m_IrpsOutstanding.ListEntry);
    KeReleaseSpinLock(&pin->m_IrpsOutstanding.SpinLock,oldIrql);

    NTSTATUS status;
    if (pin->m_TransportSink) {
        //
        // The transport circuit is up, so we can forward the IRP.
        //
        status = KsShellTransferKsIrp(pin->m_TransportSink,Irp);
    }
    else
    {
        //
        // The transport circuit is down.  This means the IRP came from another
        // filter, and we can just complete this IRP.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.IoCompletionRoutine:  got IRP %p with no transport",pin,Irp));
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        status = STATUS_SUCCESS;
    }

    //
    // Transport objects typically return STATUS_PENDING meaning that the
    // IRP won't go back the way it came.
    //
    if (status == STATUS_PENDING) {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS
CPortPinWavePci::
BuildTransportCircuit
(   void
)
/*++

Routine Description:

    This routine initializes a pipe object.  This includes locating all the
    pins associated with the pipe, setting the Pipe and NextPinInPipe pointers
    in the appropriate pin structures, setting all the fields in the pipe
    structure and building the transport circuit for the pipe.  The pipe and
    the associated components are left in acquire state.
    
    The filter's control mutex must be acquired before this function is called.

Arguments:

    Pin -
        Contains a pointer to the pin requesting the creation of the pipe.

Return Value:

    Status.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::BuildTransportCircuit"));

    PAGED_CODE();

    BOOLEAN masterIsSource = m_ConnectionFileObject != NULL;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Create a queue.
    //
    status = m_IrpStream->QueryInterface(__uuidof(IKsShellTransport),(PVOID *) &m_QueueTransport);

    PIKSSHELLTRANSPORT hot;
    PIKSSHELLTRANSPORT cold;
    if (NT_SUCCESS(status))
    {
        //
        // Connect the queue to the master pin.  The queue is then the dangling
        // end of the 'hot' side of the circuit.
        //
        hot = m_QueueTransport;
        ASSERT(hot);

        hot->Connect(PIKSSHELLTRANSPORT(this),NULL,Descriptor->DataFlow);

        //
        // The 'cold' side of the circuit is either the upstream connection on
        // a sink pin or a requestor connected to same on a source pin.
        //
        if (masterIsSource) {
            //
            // Source pin...needs a requestor.
            //
            status = KspShellCreateRequestor( &m_RequestorTransport,
                                              (KSPROBE_STREAMREAD |
                                               KSPROBE_ALLOCATEMDL |
                                               KSPROBE_PROBEANDLOCK |
                                               KSPROBE_SYSTEMADDRESS),
                                              0,   // TODO:  header size
                                              HACK_FRAME_SIZE,
                                              HACK_FRAME_COUNT,
                                              m_ConnectionDeviceObject,
                                              m_AllocatorFileObject );

            if (NT_SUCCESS(status))
            {
                PIKSSHELLTRANSPORT(this)->Connect(m_RequestorTransport,NULL,Descriptor->DataFlow);
                cold = m_RequestorTransport;
            }
        }
        else
        {
            //
            // Sink pin...no requestor required.
            //
            cold = PIKSSHELLTRANSPORT(this);
        }

    }

    //
    // Now we have a hot end and a cold end to hook up to other pins in the
    // pipe, if any.  There are three cases:  1, 2 and many pins.
    // TODO:  Handle headless pipes.
    //
    if (NT_SUCCESS(status))
    {
        //
        // No other pins.  This is the end of the pipe.  We connect the hot
        // and the cold ends together.  The hot end is not really carrying
        // data because the queue is not modifying the data, it is producing
        // or consuming it.
        //
        cold->Connect(hot,NULL,Descriptor->DataFlow);
    }

    //
    // Clean up after a failure.
    //
    if (! NT_SUCCESS(status))
    {
        //
        // Dereference the queue if there is one.
        //
        if (m_QueueTransport)
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_RequestorTransport)
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }
    }

#if DBG
    if (NT_SUCCESS(status))
    {
        VOID DbgPrintCircuit( IN PIKSSHELLTRANSPORT Transport );
        _DbgPrintF(DEBUGLVL_VERBOSE,("TRANSPORT CIRCUIT:\n"));
        DbgPrintCircuit(PIKSSHELLTRANSPORT(this));
    }
#endif

    return status;
}

#pragma code_seg()
void
CPortPinWavePci::
CancelIrpsOutstanding
(   void
)
/*++

Routine Description:

    Cancels all IRP's on the outstanding IRPs list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWavePci::CancelIrpsOutstanding"));

    //
    // This algorithm searches for uncancelled IRPs starting at the head of
    // the list.  Every time such an IRP is found, it is cancelled, and the
    // search starts over at the head.  This will be very efficient, generally,
    // because IRPs will be removed by the completion routine when they are
    // cancelled.
    //
    for (;;) {
        //
        // Take the spinlock and search for an uncancelled IRP.  Because the
        // completion routine acquires the same spinlock, we know IRPs on this
        // list will not be completely cancelled as long as we have the 
        // spinlock.
        //
        PIRP irp = NULL;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
        for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
            listEntry != &m_IrpsOutstanding.ListEntry;
            listEntry = listEntry->Flink) {
                PIRPLIST_ENTRY irpListEntry = 
                    CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

                if (! irpListEntry->Irp->Cancel) {
                    irp = irpListEntry->Irp;
                    break;
                }
            }

        //
        // If there are no uncancelled IRPs, we are done.
        //
        if (! irp) {
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
            break;
        }

        //
        // Mark the IRP cancelled whether we can call the cancel routine now
        // or not.
        // 
        irp->Cancel = TRUE;

        //
        // If the cancel routine has already been removed, then this IRP
        // can only be marked as canceled, and not actually canceled, as
        // another execution thread has acquired it. The assumption is that
        // the processing will be completed, and the IRP removed from the list
        // some time in the near future.
        //
        // If the element has not been acquired, then acquire it and cancel it.
        // Otherwise, it's time to find another victim.
        //
        PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);

        //
        // Since the Irp has been acquired by removing the cancel routine, or
        // there is no cancel routine and we will not be cancelling, it is safe 
        // to release the list lock.
        //
        KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

        if (driverCancel) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  cancelling IRP %p",this,irp));
            //
            // This needs to be acquired since cancel routines expect it, and
            // in order to synchronize with NTOS trying to cancel Irp's.
            //
            IoAcquireCancelSpinLock(&irp->CancelIrql);
            driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  uncancelable IRP %p",this,irp));
        }
    }
}

/*****************************************************************************
 * TimerServiceRoutine()
 *****************************************************************************
 * This routine is called via timer when no service group is supplied by the
 * stream.  This is done so that position and clock events will get serviced.
 *
 */
VOID
TimerServiceRoutine
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(Dpc);
    ASSERT(DeferredContext);

    // get the context
    CPortPinWavePci *pin = (CPortPinWavePci *)DeferredContext;

    pin->RequestService();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\clock.cpp ===
/*++

    Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    Clock.cpp

Abstract:
    
    This module implements the clock handler

Author:

    bryanw 07-Oct-1997

--*/

#include "private.h"

DEFINE_KSPROPERTY_CLOCKSET( 
    ClockPropertyHandlers,
    CPortClockWavePci::GetTime,
    CPortClockWavePci::GetPhysicalTime,
    CPortClockWavePci::GetCorrelatedTime,
    CPortClockWavePci::GetCorrelatedPhysicalTime,
    CPortClockWavePci::GetResolution,
    CPortClockWavePci::GetState,
    CPortClockWavePci::GetFunctionTable );

DEFINE_KSPROPERTY_SET_TABLE( ClockPropertyTable )
{
    DEFINE_KSPROPERTY_SET( 
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY( ClockPropertyHandlers ),
        ClockPropertyHandlers,
        0, 
        NULL)
};

DEFINE_KSEVENT_TABLE( ClockEventHandlers ) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof( KSEVENT_TIME_INTERVAL ),
        sizeof( ULONGLONG ) + sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CPortClockWavePci::AddEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof( KSEVENT_TIME_MARK ),
        sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CPortClockWavePci::AddEvent,
        NULL,
        NULL)
};

DEFINE_KSEVENT_SET_TABLE( ClockEventTable )
{
    DEFINE_KSEVENT_SET( 
        &KSEVENTSETID_Clock, 
        SIZEOF_ARRAY( ClockEventHandlers ),
        ClockEventHandlers)
};

//
//
//

#pragma code_seg("PAGE")

NTSTATUS
CreatePortClockWavePci(
    OUT PUNKNOWN *Unknown,
    IN PPORTPINWAVEPCI IPortPin,
    IN REFCLSID Interface,
    IN PUNKNOWN UnknownOuter OPTIONAL,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:
    Creates a cyclic-wave clock object for the port.

Arguments:
    IN PFILE_OBJECT FileObject -
        associated file object
        
    OUT PUNKNOWN *Unknown -
        resultant pointer to our unknown
        
    IN PPORTPINWAVEPCI - 
        wave cyclic pin interface

    IN REFCLSID Interface -
        interface requested

    IN PUNKNOWN UnknownOuter OPTIONAL -
        pointer to the controlling unknown

    IN POOL_TYPE PoolType -
        pool type for allocation

Return:

--*/

{
    CPortClockWavePci    *WavePciClock;
    NTSTATUS                Status;
    
    PAGED_CODE();

    ASSERT(Unknown);
    
    _DbgPrintF(
        DEBUGLVL_VERBOSE, ("CreatePortClockWavePci") );
    
    //
    // Create the object
    //
    
    WavePciClock =
        new(PoolType) 
            CPortClockWavePci( UnknownOuter, IPortPin, &Status );
    if (NULL == WavePciClock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if (NT_SUCCESS( Status )) {
        WavePciClock->AddRef();
        *Unknown = WavePciClock;
    } else {
        delete WavePciClock;
        *Unknown = NULL;
    }
    return Status;
}

CPortClockWavePci::CPortClockWavePci(
    IN PUNKNOWN UnkOuter,
    IN PPORTPINWAVEPCI IPortPin,    
    OUT NTSTATUS *Status
    ) :
    CUnknown( UnkOuter )

/*++

Routine Description:
    CPortClockWavePci constructor.
    
    Initializes the object.
    
Arguments:
    IN PUNKNOWN UnkOuter -
        controlling unknown

    OUT NTSTATUS *Status -
        return status

Return:
    Nothing

--*/

{
    _DbgPrintF(
        DEBUGLVL_VERBOSE,
        ("CPortClockWavePci::CPortClockWavePci") );
        
    ASSERT( IPortPin );
    
    KeInitializeMutex( &m_StateMutex, 0 );
    KeInitializeSpinLock( &m_EventLock );
    KeInitializeSpinLock( &m_ClockLock );
    InitializeListHead( &m_EventList );
    
    RtlZeroMemory( &m_ClockNode, sizeof( m_ClockNode ) );
    m_ClockNode.IWavePciClock = this;
    
    m_IPortPin = IPortPin;
    m_IPortPin->AddRef();

    *Status = STATUS_SUCCESS;       
}

#pragma code_seg()

CPortClockWavePci::~CPortClockWavePci()
{
    _DbgPrintF(
        DEBUGLVL_VERBOSE,
        ("CPortClockWavePci::~CPortClockWavePci") );

    if (m_ClockNode.ListEntry.Flink) {
        KIRQL irqlOld;
        
        //
        // If the parent object linked us in, unlink from the list
        // using the provided spinlock.
        //
        
        KeAcquireSpinLock( m_ClockNode.ListLock, &irqlOld );
        RemoveEntryList( &m_ClockNode.ListEntry );
        KeReleaseSpinLock( m_ClockNode.ListLock, irqlOld );
    }        
    m_IPortPin->Release();
}

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortClockWavePci::NonDelegatingQueryInterface(
    REFIID Interface,
    PVOID * Object
    )
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF( 
        DEBUGLVL_VERBOSE,
        ("CPortClockWavePci::NonDelegatingQueryInterface") );
    if (IsEqualGUIDAligned( Interface, IID_IUnknown )) {
        *Object = PVOID(PIRPTARGET( this ));
    } else if (IsEqualGUIDAligned( Interface, IID_IIrpTarget )) {
        *Object = PVOID(PIRPTARGET( this ));
    } else if (IsEqualGUIDAligned( Interface, IID_IWavePciClock )) {
        *Object = PVOID(PWAVEPCICLOCK( this ));
    } else {
        *Object = NULL;
    }

    if (*Object) {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWavePci::DeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Processes device I/O control for this file object on this device object
    
Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to I/O request packet

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;
    
    PAGED_CODE();

    ASSERT( DeviceObject );
    ASSERT( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortClockWavePci::DeviceIoControl"));

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:
        Status = 
            KsPropertyHandler( 
                Irp, 
                SIZEOF_ARRAY( ClockPropertyTable ),
                (PKSPROPERTY_SET) ClockPropertyTable );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWavePci::EnableEvent"));

        Status = 
            KsEnableEvent( 
                Irp, 
                SIZEOF_ARRAY( ClockEventTable ), 
                (PKSEVENT_SET) ClockEventTable, 
                NULL, 
                KSEVENTS_NONE,
                NULL);
        break;

    case IOCTL_KS_DISABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWavePci::DisableEvent"));
    
        Status = 
            KsDisableEvent( 
                Irp, 
                &m_EventList,
                KSEVENTS_SPINLOCK,
                &m_EventLock );
        break;

    default:
    
        return KsDefaultDeviceIoCompletion( DeviceObject, Irp );

    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWavePci::Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Close handler for the clock file object

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS success or an appropriate error code

--*/

{
    PIO_STACK_LOCATION irpSp;
    
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWavePci::Close"));
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Free events associated with this pin.
    //
    
    KsFreeEventList(
        irpSp->FileObject,
        &m_EventList,
        KSEVENTS_SPINLOCK,
        &m_EventLock );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CPortClockWavePci);
DEFINE_INVALID_READ(CPortClockWavePci);
DEFINE_INVALID_WRITE(CPortClockWavePci);
DEFINE_INVALID_FLUSH(CPortClockWavePci);
DEFINE_INVALID_QUERYSECURITY(CPortClockWavePci);
DEFINE_INVALID_SETSECURITY(CPortClockWavePci);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortClockWavePci);
DEFINE_INVALID_FASTREAD(CPortClockWavePci);
DEFINE_INVALID_FASTWRITE(CPortClockWavePci);

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortClockWavePci::GenerateEvents(
    PFILE_OBJECT FileObject
    )
{
    LONGLONG                Time;
    PLIST_ENTRY             ListEntry;
    
    if (m_DeviceState == KSSTATE_RUN) {
    
        Time = GetCurrentTime( FileObject );

        ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
        
        KeAcquireSpinLockAtDpcLevel( &m_EventLock );

        for(ListEntry = m_EventList.Flink; 
            ListEntry != &m_EventList;) {
            
            PKSEVENT_ENTRY  EventEntry;
            PKSINTERVAL     Interval;

            EventEntry = 
                (PKSEVENT_ENTRY)
                    CONTAINING_RECORD( ListEntry, KSEVENT_ENTRY, ListEntry );
                
            //
            // Pre-inc, KsGenerateEvent() can remove this item from the list.
            //    
            ListEntry = ListEntry->Flink;
            //
            // The event-specific data was added onto the end of the entry.
            //
            Interval = (PKSINTERVAL)(EventEntry + 1);
            //
            // Time for this event to go off.
            //
            if (Interval->TimeBase <= Time) {
                _DbgPrintF(
                    DEBUGLVL_VERBOSE, ("Generating event for time: %ld at time: %ld",
                    Interval->TimeBase, Time) );
            
                if (EventEntry->EventItem->EventId != 
                        KSEVENT_CLOCK_INTERVAL_MARK) {
                    //
                    // A single-shot should only go off once, so make
                    // it a value which will never be reached again.
                    //
                    Interval->TimeBase = 0x7fffffffffffffff;
                
                } else {
                    LONGLONG    Intervals;
                    //
                    // An interval timer should only go off once per time,
                    // so update it to the next timeout.
                    //
                    Intervals = 
                        (Time - Interval->TimeBase + Interval->Interval - 1) / Interval->Interval;
                    Interval->TimeBase += Intervals * Interval->Interval;
                } 
                        
                KsGenerateEvent( EventEntry );
            }
        }
        
        KeReleaseSpinLockFromDpcLevel( &m_EventLock );
    }
    
    return STATUS_SUCCESS;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWavePci::SetState(
    KSSTATE State
    )

/*++

Routine Description:
    This method is called by the port to notify of a state change.

Arguments:
    KSSTATE State -
        New state

Return:
    STATUS_SUCCESS

--*/

{
    //
    // Synchronize with GetState,
    //
    KeWaitForMutexObject(
        &m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );

    //
    // set the new state,
    //        
    m_DeviceState = State;
    switch (State) {
    
    case KSSTATE_STOP:
        m_LastTime = m_LastPhysicalTime = 0;
        break;
        
    case KSSTATE_RUN:
        break;
    }
    
    //
    // and then release the mutex.
    //
    KeReleaseMutex( &m_StateMutex, FALSE );
    
    return STATUS_SUCCESS;
}    

NTSTATUS
CPortClockWavePci::AddEvent(
    IN PIRP                     Irp,
    IN PKSEVENT_TIME_INTERVAL   EventTime,
    IN PKSEVENT_ENTRY           EventEntry
    )

/*++

Routine Description:

    This is the AddEvent() handler for the clock events.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:

    IN PIRP Irp - 
        pointer to the I/O request packet    

    IN PKSEVENT_TIME_INTERVAL EventTime -
        specified time interval or one shot

    IN PKSEVENT_ENTRY EventEntry -
        pointer to event entry structure

Return Value:
    STATUS_SUCCESS

--*/

{
    KIRQL                   irqlOld;
    PKSINTERVAL             Interval;
    CPortClockWavePci    *WavePciClock;
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);
        
    ASSERT( WavePciClock );
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWavePci::AddEvent"));
            
    //
    // Space for the interval is located at the end of the basic 
    // event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an 
    // interval. In both cases the first LONGLONG is present and saved.
    //
    Interval->TimeBase = EventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
        Interval->Interval = EventTime->Interval;
    }

    KeAcquireSpinLock( &WavePciClock->m_EventLock, &irqlOld );
    InsertHeadList( &WavePciClock->m_EventList, &EventEntry->ListEntry );
    KeReleaseSpinLock( &WavePciClock->m_EventLock, irqlOld );
    //
    // If this event is passed, signal immediately.
    // Note, KS_CLOCK_POSITION_MARK is a one-shot event.
    //
    WavePciClock->GenerateEvents(IoGetCurrentIrpStackLocation( Irp )->FileObject);
    
    return STATUS_SUCCESS;
}

LONGLONG
FASTCALL
CPortClockWavePci::GetCurrentTime(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:
    Computes the current presentation time, this is the actual position in
    the stream which may halt due to starvation.
    
    NOTE: This routine acquires a spinlock, must be in non-paged code.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 
        
Return:
    resultant presentation time normalized to 100ns units.

--*/

{
    KIRQL                   irqlOld;
    LONGLONG                StreamTime;
    NTSTATUS                Status;
    PMINIPORTWAVEPCISTREAM  Miniport;
    CPortClockWavePci       *WavePciClock;
    BOOLEAN                 lockHeld = FALSE;
        
    WavePciClock = (CPortClockWavePci *) KsoGetIrpTargetFromFileObject(FileObject);
        
    StreamTime = 0;
    
    Miniport = WavePciClock->m_IPortPin->GetMiniport();
    if( !Miniport )
    {
        Status = STATUS_UNSUCCESSFUL;
    } 
    else
    {
        KeAcquireSpinLock( &WavePciClock->m_ClockLock, &irqlOld );
        lockHeld = TRUE;
        
        Status = Miniport->GetPosition( PULONGLONG( &StreamTime ) );
        
        if (NT_SUCCESS(Status)) 
        {
            //
            // Normalize the physical position.
            //
            Status = Miniport->NormalizePhysicalPosition( &StreamTime );
        }
        Miniport->Release();            
    }
       
    if (NT_SUCCESS(Status)) 
    {
        //
        // Verify that this new time is >= to the last reported time.  
        // If not, set the time to the last reported time.  Flag this 
        /// as an error in debug.
        //
        if (StreamTime < WavePciClock->m_LastTime) 
        {
            _DbgPrintF( DEBUGLVL_ERROR, 
                        ("new time is less than last reported time! (%ld, %ld)",
                        StreamTime, WavePciClock->m_LastTime) );
        } 
        else 
        {
            //
            // Set m_LastTime to the updated time.
            //
            WavePciClock->m_LastTime = StreamTime;
        }
    } 
    else 
    {
        StreamTime = WavePciClock->m_LastTime;
    }
    
    if (lockHeld)
    {
        KeReleaseSpinLock(&WavePciClock->m_ClockLock, irqlOld);
    }
    
    return StreamTime;
}

LONGLONG
FASTCALL
CPortClockWavePci::GetCurrentCorrelatedTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:


Arguments:
    PFILE_OBJECT FileObject -

    PLONGLONG SystemTime -
        pointer 

Return:
    current presentation time in 100ns

--*/

{
    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    //  Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);
    return GetCurrentTime( FileObject );
}    

LONGLONG
FASTCALL
CPortClockWavePci::GetCurrentPhysicalTime(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:
    Computes the current physical time.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 

Return:
    current physical time in 100ns

--*/

{
    KIRQL                   irqlOld;
    LONGLONG                PhysicalTime;
    NTSTATUS                Status;
    PMINIPORTWAVEPCISTREAM  Miniport;
    CPortClockWavePci       *WavePciClock;
    BOOLEAN                 lockHeld = FALSE;
    
    WavePciClock = (CPortClockWavePci *) KsoGetIrpTargetFromFileObject(FileObject);

    PhysicalTime = 0;
    
    Miniport = WavePciClock->m_IPortPin->GetMiniport();    
    if (!Miniport)
    {
        Status = STATUS_UNSUCCESSFUL;
    } 
    else
    {
        KeAcquireSpinLock( &WavePciClock->m_ClockLock, &irqlOld );
        lockHeld = TRUE;
        
        Status = Miniport->GetPosition( PULONGLONG( &PhysicalTime ));
        if (NT_SUCCESS( Status )) 
        {
            Status = Miniport->NormalizePhysicalPosition( &PhysicalTime );
        }            
        Miniport->Release();            
    }
    
    if (NT_SUCCESS(Status)) 
    {
        //
        // Verify that this new physical time is >= to the last
        // reported physical time.  If not, set the time to the 
        // last reported time.  Flag this as an error in debug.
        //
        if (PhysicalTime < WavePciClock->m_LastPhysicalTime) 
        {
            _DbgPrintF( DEBUGLVL_ERROR, 
                        ("new physical time is less than last reported physical time! (%ld, %ld)",
                        PhysicalTime, WavePciClock->m_LastPhysicalTime) );
        } 
        else 
        {
            //
            // Set m_LastPhysicalTime to the updated time.
            //
            WavePciClock->m_LastPhysicalTime = PhysicalTime;
        }
    } 
    else 
    {
        PhysicalTime = WavePciClock->m_LastPhysicalTime;
    }
    
    if (lockHeld)
    {
        KeReleaseSpinLock( &WavePciClock->m_ClockLock, irqlOld );
    }
    
    return PhysicalTime;
}

LONGLONG
FASTCALL
CPortClockWavePci::GetCurrentCorrelatedPhysicalTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object

    PLONGLONG SystemTime -
        pointer to the resultant system time

Return:
    current physical time in 100ns

--*/

{

    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    // Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME( Frequency.QuadPart, Time );
    
    return GetCurrentTime( FileObject );
}    



#pragma code_seg("PAGE")

NTSTATUS
CPortClockWavePci::GetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    )

/*++

Routine Description:
    Retrieves the DPC interface function table for this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable -
        pointer to the resultant function table

Return:

--*/

{
    PAGED_CODE();
    FunctionTable->GetTime = GetCurrentTime;
    FunctionTable->GetPhysicalTime = GetCurrentPhysicalTime;
    FunctionTable->GetCorrelatedTime = GetCurrentCorrelatedTime;
    FunctionTable->GetCorrelatedPhysicalTime = GetCurrentCorrelatedPhysicalTime;
    Irp->IoStatus.Information = sizeof(*FunctionTable);
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWavePci::GetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current presentation time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWavePci    *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);

    CorrelatedTime->Time = 
        WavePciClock->GetCurrentCorrelatedTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject, 
            &CorrelatedTime->SystemTime );
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}    

NTSTATUS
CPortClockWavePci::GetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Retrieves the current presentation time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWavePci    *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);

    *Time = WavePciClock->GetCurrentTime( 
        IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
     
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWavePci::GetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated physical time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWavePci    *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);
    
    CorrelatedTime->Time =
        WavePciClock->GetCurrentCorrelatedPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject,
            &CorrelatedTime->SystemTime );
    
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWavePci::GetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Returns the clock's physical time.  This is the actual clock physical time 
    which is not halted for starvation, etc.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant time in 100 ns units

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    CPortClockWavePci    *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);

    *Time = 
        WavePciClock->GetCurrentPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWavePci::GetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    )
/*++

Routine Description:
    Retrieves the resolution of this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure
        
    OUT PKSRESOLUTIONM Resolution -
        pointer to the resultant resolution structure which stores the
        granularity and error in 100ns units.
        
Return Value:
    STATUS_SUCCESS

--*/
{
    LONGLONG                    OneByte = 1;
    PMINIPORTWAVEPCISTREAM   Miniport;
    CPortClockWavePci        *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);
    
    Miniport = WavePciClock->m_IPortPin->GetMiniport();
    if( !Miniport )
    {
        return STATUS_UNSUCCESSFUL;
    } else
    {
        //
        // This clock has a resolution dependant on the data format.  Assume
        // that for cyclic devices, a byte position is computed for the DMA
        // controller and convert this to 100ns units.  The error (event 
        // notification error) is +/- NotificationFrequency/2
          
        Resolution->Granularity = 
            Miniport->NormalizePhysicalPosition( &OneByte );
        Miniport->Release();
    }
           
    //
    // NTRAID#Windows Bugs-65581-2001/01/02-fberreth Clock granularity/error misreport.
    // portcls cannot know what the error of GetPosition in the miniport is.
    //
    
//  Resolution->Error = 
//      (_100NS_UNITS_PER_SECOND / 1000 * WAVECYC_NOTIFICATION_FREQUENCY) / 2;
    
    Resolution->Error = 0;
        
    Irp->IoStatus.Information = sizeof(*Resolution);
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWavePci::GetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    )

/*++

Routine Description:
    Returns the underlying pin's state.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSSTATE State -
        pointer to resultant KSSTATE

Return:
    STATUS_SUCCESS

--*/

{
    CPortClockWavePci    *WavePciClock;
    
    PAGED_CODE();
    
    WavePciClock =
        (CPortClockWavePci *) KsoGetIrpTargetFromIrp(Irp);

    //
    // Synchronize with SetState,
    //        
    KeWaitForMutexObject(
        &WavePciClock->m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );
    //
    // retrieve the state
    //        
    *State = WavePciClock->m_DeviceState;
    //
    // and then release the mutex
    //
    KeReleaseMutex( &WavePciClock->m_StateMutex, FALSE );
    
    Irp->IoStatus.Information = sizeof(*State);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\private.h ===
/*****************************************************************************
 * private.h - PCI wave port private definitions
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _WAVEPCI_PRIVATE_H_
#define _WAVEPCI_PRIVATE_H_

#include "portclsp.h"

#ifdef DRM_PORTCLS
#include <drmk.h>
#endif  // DRM_PORTCLS

#include "stdunk.h"

#include "stdio.h"
#include "stdarg.h"

#include "ksdebug.h"

#ifndef PC_KDEXT
#if (DBG)
#define STR_MODULENAME  "WavePci: "
#endif
#endif  // PC_KDEXT

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif

//
// THE SIZES HERE MUST AGREE WITH THE DEFINITION IN FILTER.CPP AND PIN.CPP.
//
extern KSPROPERTY_SET PropertyTable_FilterWavePci[2];
extern KSPROPERTY_SET PropertyTable_PinWavePci[4];
extern KSEVENT_SET    EventTable_PinWavePci[2];






#ifndef PC_KDEXT    // these are already defined in wavecyc\private.h
/*****************************************************************************
 * Structures
 */

 typedef enum {
    PositionEvent,
    EndOfStreamEvent
 } PORT_EVENTTYPE;
 

/*****************************************************************************
 * POSITION_EVENT_ENTRY
 *****************************************************************************
 * Position event as it is stored in the event list.
 */
typedef struct {
    KSEVENT_ENTRY   EventEntry;
    PORT_EVENTTYPE  EventType;
    ULONG           Reserved;
    ULONGLONG       ullPosition;
} POSITION_EVENT_ENTRY, *PPOSITION_EVENT_ENTRY;

typedef struct {
    KSEVENT_ENTRY   EventEntry;
    PORT_EVENTTYPE  EventType;
    ULONG           Reserved;
} ENDOFSTREAM_EVENT_ENTRY, *PENDOFSTREAM_EVENT_ENTRY;
#endif  // PC_KDEXT

/*****************************************************************************
 * Interfaces
 */

class CPortWavePci;
class CPortFilterWavePci;
class CPortPinWavePci;

/*****************************************************************************
 * IPortFilterWavePci
 *****************************************************************************
 * Interface for PCI wave filters.
 */
DECLARE_INTERFACE_(IPortFilterWavePci,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortWavePci *Port
    )   PURE;
};

typedef IPortFilterWavePci *PPORTFILTERWAVEPCI;

/*****************************************************************************
 * IPortPinWavePci
 *****************************************************************************
 * Interface for PCI wave pins.
 */
DECLARE_INTERFACE_(IPortPinWavePci,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortWavePci *      Port,
        IN      CPortFilterWavePci *Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor,
        IN      PDEVICE_OBJECT      DeviceObject
    )   PURE;
    STDMETHOD_(PIRPSTREAM, GetIrpStream)( VOID ) PURE;
    STDMETHOD_(PMINIPORTWAVEPCISTREAM, GetMiniport)( VOID ) PURE;
};

typedef IPortPinWavePci *PPORTPINWAVEPCI;

interface IWavePciClock;
typedef IWavePciClock *PWAVEPCICLOCK;

typedef struct {
    LIST_ENTRY      ListEntry;
    PWAVEPCICLOCK   IWavePciClock;
    PFILE_OBJECT    FileObject;
    PKSPIN_LOCK     ListLock;
    ULONG           Reserved;
} WAVEPCICLOCK_NODE, *PWAVEPCICLOCK_NODE;

DECLARE_INTERFACE_(IWavePciClock,IIrpTarget) 
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_( PWAVEPCICLOCK_NODE, GetNodeStructure )( THIS ) PURE;
    STDMETHOD_(NTSTATUS, GenerateEvents )( THIS_ PFILE_OBJECT FileObject ) PURE;
    STDMETHOD_(NTSTATUS, SetState )( KSSTATE State ) PURE;
};

/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CPortWavePci
 *****************************************************************************
 * Wave port driver.
 */
class CPortWavePci
:   public IPortWavePci,
    public IPortEvents,
    public IServiceSink,
    public ISubdevice,
#ifdef DRM_PORTCLS
    public IDrmPort2,
#endif  // DRM_PORTCLS
    public IPortClsVersion,
    public CUnknown
{
private:
    PDEVICE_OBJECT          DeviceObject;

    KMUTEX                  ControlMutex;

    KSPIN_LOCK              NotifyLock;
    LIST_ENTRY              NotifyQueue;

    PMINIPORTWAVEPCI        Miniport;
    PPINCOUNT               m_MPPinCountI;

    PSUBDEVICE_DESCRIPTOR   m_pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    m_pPcFilterDescriptor;

    PADAPTER_OBJECT         BusMasterAdapterObject;
    ULONG                   MaxMapRegisters;

    PSERVICEGROUP           ServiceGroup;

    INTERLOCKED_LIST        m_EventList;
    KDPC                    m_EventDpc;
    EVENT_DPC_CONTEXT       m_EventContext;

    LIST_ENTRY              m_PinList;
    KMUTEX                  m_PinListMutex;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortWavePci);
    ~CPortWavePci();

    IMP_ISubdevice;
    IMP_IPortWavePci;
    IMP_IServiceSink;
    IMP_IPortEvents;
#ifdef DRM_PORTCLS
    IMP_IDrmPort2;
#endif  // DRM_PORTCLS
    IMP_IPortClsVersion;

    //
    // friends
    //       

    friend class CPortFilterWavePci;
    friend class CPortPinWavePci;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN PIRP                 Irp,
        IN PKSPROPERTY          Property,
        IN OUT PKSDATAFORMAT    DataFormat
    );
    friend
    void
    PcGenerateEventDeferredRoutine
    (
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2        
    );
    friend
    NTSTATUS
    PinPropertyPosition
    (
        IN      PIRP                pIrp,
        IN      PKSPROPERTY         pKsProperty,
        IN OUT  PKSAUDIO_POSITION   pKsAudioPosition
    );
#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
};

/*****************************************************************************
 * CPortFilterWavePci
 *****************************************************************************
 * Filter implementation for Pci wave port.
 */
class CPortFilterWavePci
:   public IPortFilterWavePci,
    public CUnknown
{
private:
    CPortWavePci *      Port;
    PROPERTY_CONTEXT    m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortFilterWavePci);
    ~CPortFilterWavePci();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortWavePci *Port
    );

    //
    // helper functions
    //

    static    
    NTSTATUS 
    AllocatorDispatchCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
        
    //
    // friends
    //
    
    friend class CPortPinWavePci;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
};

/*****************************************************************************
 * CPortPinWavePci
 *****************************************************************************
 * Pin implementation for Pci wave port.
 */
class CPortPinWavePci
:   public IPortPinWavePci,
    public IPortWavePciStream,
    public IIrpStreamNotifyPhysical,
    public IServiceSink,
    public IKsShellTransport,
    public IKsWorkSink,
    public IPreFetchOffset,
    public CUnknown
{
private:
    LIST_ENTRY                  m_PinListEntry;

    PIKSSHELLTRANSPORT          m_TransportSink;
    PIKSSHELLTRANSPORT          m_TransportSource;
    PDEVICE_OBJECT              m_ConnectionDeviceObject;
    PFILE_OBJECT                m_ConnectionFileObject;
    PIKSSHELLTRANSPORT          m_RequestorTransport;
    PIKSSHELLTRANSPORT          m_QueueTransport;
    KSSTATE                     m_State;
    KSRESET                     m_ResetState;
    INTERLOCKEDLIST_HEAD        m_IrpsToSend;
    INTERLOCKEDLIST_HEAD        m_IrpsOutstanding;
    PKSWORKER                   m_Worker;
    WORK_QUEUE_ITEM             m_WorkItem;

    CPortWavePci *              Port;
    CPortFilterWavePci *        Filter;
    PROPERTY_CONTEXT            m_propertyContext;

    PMINIPORTWAVEPCISTREAM      Stream;
    ULONG                       Id;
    PKSPIN_DESCRIPTOR           Descriptor;
    PKSDATAFORMAT               DataFormat;

    ULONGLONG                   m_ullPosition;

    PDMACHANNEL                 DmaChannel;
    PSERVICEGROUP               ServiceGroup;
    
    KSSTATE                     m_DeviceState;
    KSSTATE                     CommandedState;
    
    PFILE_OBJECT                m_AllocatorFileObject;
    PFILE_OBJECT                m_ClockFileObject;
    
    LIST_ENTRY                  m_ClockList;
    KSPIN_LOCK                  m_ClockListLock;

    PIRPSTREAMPHYSICAL          m_IrpStream;
    BOOLEAN                     m_Flushing;

    BOOLEAN                     m_bSetPosition;
    BOOLEAN                     m_bDriverSuppliedPrefetch;

    ULONG                       m_ulPreFetchOffset;

    ULONGLONG                   m_ullPrevWriteOffset;
    ULONGLONG                   m_ullPlayPosition;

    BOOL                        m_Suspended;

    BOOL                        m_UseServiceTimer;
    KTIMER                      m_ServiceTimer;
    KDPC                        m_ServiceTimerDpc;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortPinWavePci);
    ~CPortPinWavePci();

    IMP_IIrpTarget;
    IMP_IPortWavePciStream;
    IMP_IIrpStreamNotifyPhysical;
    IMP_IServiceSink;
    IMP_IKsShellTransport;
    IMP_IKsWorkSink;
    IMP_IPreFetchOffset;

    STDMETHODIMP_(NTSTATUS)
    GetKsAudioPosition
    (   OUT     PKSAUDIO_POSITION   pKsAudioPosition
    );

    STDMETHODIMP_(void)
    PowerNotify(
        POWER_STATE PowerState
        );

    void
    GenerateClockEvents(
        void
        );
    
    void        
    GenerateEndOfStreamEvents(
        void
        );
        
    void GeneratePositionEvents
    (   void
    );

    /*************************************************************************
     * IPortPinWavePci methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortWavePci *      Port,
        IN      CPortFilterWavePci *Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor,
        IN      PDEVICE_OBJECT      DeviceObject
    );
    
    STDMETHODIMP_( PIRPSTREAM ) GetIrpStream( VOID ) {
        if( m_IrpStream )
        {
            m_IrpStream->AddRef();
        }
        return m_IrpStream;
    }
    
    STDMETHODIMP_( PMINIPORTWAVEPCISTREAM ) GetMiniport( VOID ) {
        if( Stream )
        {
            Stream->AddRef();
        }
        return Stream;
    }

    //
    // helper functions
    //
    
    static
    NTSTATUS
    PinPropertyStreamAllocator(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE AllocatorHandle
        );
        
    static
    NTSTATUS
    PinPropertyStreamMasterClock(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE ClockHandle
        );
        
    static
    NTSTATUS    
    AddEndOfStreamEvent(
        IN PIRP Irp,
        IN PKSEVENTDATA EventData,
        IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry
        );
        
    static
    NTSTATUS 
    PinPropertyAllocatorFraming(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSALLOCATOR_FRAMING AllocatorFraming
        );
        
    STDMETHODIMP_(NTSTATUS) 
    ReflectDeviceStateChange(
        KSSTATE State
        );

    NTSTATUS
    DistributeDeviceState
    (
        IN  KSSTATE     NewState,
        IN  KSSTATE     OldState
    );

    void
    DistributeResetState
    (
        IN  KSRESET     NewState
    );

    static
    NTSTATUS
    IoCompletionRoutine
    (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
    );

    NTSTATUS
    BuildTransportCircuit
    (
        void
    );

    void
    CancelIrpsOutstanding
    (
        void
    );
       
    //
    // friends
    //
        
    friend class CPortWavePci;

    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN PIRP                 Irp,
        IN PKSPROPERTY          Property,
        IN OUT PKSDATAFORMAT    DataFormat
    );
    friend
    NTSTATUS
    PinPropertySetContentId
    (
        IN PIRP		        pIrp,
        IN PKSPROPERTY          pKsProperty,
        IN PVOID                pvData
    );
    friend
    NTSTATUS
    PinPropertyPosition
    (
        IN      PIRP                pIrp,
        IN      PKSPROPERTY         pKsProperty,
        IN OUT  PKSAUDIO_POSITION   pKsAudioPosition
    );
    friend
    NTSTATUS
    PinAddEvent_Position
    (
        IN      PIRP                                    pIrp,
        IN      PLOOPEDSTREAMING_POSITION_EVENT_DATA    pPositionEventData,
        IN      PPOSITION_EVENT_ENTRY                   pPositionEventEntry
    );
    friend
    VOID
    TimerServiceRoutine
    (
        IN  PKDPC   Dpc,
        IN  PVOID   DeferredContext,
        IN  PVOID   SystemArgument1,
        IN  PVOID   SystemArgument2
    );
#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
};

#ifndef PC_KDEXT    // clocks are not currently supported with the debugger extensions
//
// CPortClockWavePci
//
// This class supports the clock interface for a pin object.
//

class CPortClockWavePci : 
    public IWavePciClock,
    public CUnknown
{
private:
    PPORTPINWAVEPCI      m_IPortPin;
    KSPIN_LOCK           m_ClockLock,
                         m_EventLock;
    LIST_ENTRY           m_EventList;
    KMUTEX               m_StateMutex;
    WAVEPCICLOCK_NODE    m_ClockNode;
    LONGLONG             m_LastTime, 
                         m_LastPhysicalTime;
    KSSTATE              m_DeviceState;

public:
    DECLARE_STD_UNKNOWN();
    IMP_IIrpTarget;
    
    CPortClockWavePci( 
        IN PUNKNOWN UnkOuter,
        IN PPORTPINWAVEPCI IPortPin,
        OUT NTSTATUS *Status );
    ~CPortClockWavePci();
    
    //
    // Implement IWavePciClock
    //
    
    STDMETHODIMP_(PWAVEPCICLOCK_NODE)
    GetNodeStructure( 
        VOID 
        ) 
    {
        return &m_ClockNode;
    }
    
    STDMETHODIMP_(NTSTATUS)
    GenerateEvents( 
        PFILE_OBJECT FileObject
        );
        
    STDMETHODIMP_(NTSTATUS)
    SetState(
        KSSTATE State
        );
        
    //
    // helper functions (also the DPC interface)
    //      
    
    static
    LONGLONG
    FASTCALL
    GetCurrentTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentPhysicalTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedPhysicalTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    //
    // property handlers and event handlers
    //
    
    static
    NTSTATUS
    AddEvent(
        IN PIRP Irp,
        IN PKSEVENT_TIME_INTERVAL EventTime,
        IN PKSEVENT_ENTRY EventEntry
        );
    
    static
    NTSTATUS
    GetFunctionTable(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
        );
        
    static
    NTSTATUS
    GetCorrelatedTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
    
    static
    NTSTATUS
    GetTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetCorrelatedPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
        
    static
    NTSTATUS
    GetPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetResolution(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSRESOLUTION Resolution
        );
        
    static
    NTSTATUS
    GetState(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSSTATE State
        );
        
};
#endif  // PC_KDEXT

/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * CPortFilterWavePci()
 *****************************************************************************
 * Creates a PCI wave port driver filter.
 */
NTSTATUS
CreatePortFilterWavePci
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * CreatePortPinWavePci()
 *****************************************************************************
 * Creates a PCI wave port driver pin.
 */
NTSTATUS
CreatePortPinWavePci
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

//
// CreatePortClockWavePci
//      Creates a clock object for the wave PCI pin type.
// 

NTSTATUS
CreatePortClockWavePci(
    OUT PUNKNOWN *Unknown,
    IN PPORTPINWAVEPCI IPortPin,    
    IN REFCLSID Interface,
    IN PUNKNOWN UnknownOuter OPTIONAL,
    IN POOL_TYPE PoolType
    );
    
#ifdef DRM_PORTCLS

/*****************************************************************************
 * DrmForwardContentToStream()
 *****************************************************************************
 * Convenient type-safe wrapper for DrmForwardContentToInterface.
 */
EXTERN_C
NTSTATUS
DrmForwardContentToStream(
    ULONG ContentId,
    PMINIPORTWAVEPCISTREAM pMiniportWavePciStream
    );

#endif  // DRM_PORTCLS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\61883cmd.h ===
#ifndef ___61883CMD_H___
#define ___61883CMD_H___

#define ANY_SERIAL_BUS_PLUG 0x7F
#define ANY_EXTERNAL_PLUG   0xFF

#define MIN_EXTERNAL_PLUG_NUMBER 0x80

#define EXTERNAL_PLUG_TYPE    0x01
#define SERIAL_BUS_PLUG_TYPE  0x02

typedef struct _COMMON_UNIT_PLUG_INFO {
    LIST_ENTRY List;
    ULONG fPlugType;
    ULONG ulPlugNumber;
    CMP_PLUG_TYPE CmpPlugType;
    PSUBUNIT_PLUG pConnectedSubunitPlug;
    BOOLEAN fLocked;
    BOOLEAN fPermanent;
    BOOLEAN fStreaming;
} COMMON_UNIT_PLUG_INFO, *PCOMMON_UNIT_PLUG_INFO;

typedef COMMON_UNIT_PLUG_INFO EXTERNAL_PLUG, *PEXTERNAL_PLUG;

typedef struct {
    COMMON_UNIT_PLUG_INFO;

    PKSDEVICE pKsDevice;
    HANDLE hPlug;
    HANDLE hConnection;
    AV_PCR AvPcr;
    PUCHAR pBuffer;
    LIST_ENTRY DataBufferList;
    KEVENT kEventConnected;
} CMP_REGISTER, *PCMP_REGISTER;

//======================================================================

NTSTATUS
Av61883GetSetUnitInfo(
    PKSDEVICE pKsDevice,
    ULONG ulCommand,
    ULONG nLevel,
    OUT PVOID pUnitInfo
    );

NTSTATUS
Av61883GetPlugHandle( 
    IN PKSDEVICE pKsDevice,
    IN ULONG ulPlugNumber,
    IN CMP_PLUG_TYPE CmpPlugType,
    OUT PVOID *hPlug
    );

NTSTATUS
Av61883ConnectCmpPlugs(
    IN PKSDEVICE pKsDevice,
    IN ULONG fFlags,
    IN PVOID hInPlug,
    IN PVOID hOutPlug,
    KSPIN_DATAFLOW DataFlow,
    PKSDATAFORMAT pKsDataFormat,
    OUT PVOID *hConnection
    );

NTSTATUS
Av61883DisconnectCmpPlugs(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection 
    );

NTSTATUS
Av61883StartTalkingOrListening(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection,
    ULONG ulFunction
    );

NTSTATUS
Av61883StopTalkOrListen(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection 
    );

NTSTATUS
Av61883CreateCMPPlug(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister,
    PCMP_NOTIFY_ROUTINE pNotifyRtn,
    PULONG pPlugNumber,
    HANDLE *phPlug
    );

NTSTATUS
Av61883ReleaseCMPPlug(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister 
    );

NTSTATUS
Av61883GetCmpPlugState(
    IN PKSDEVICE pKsDevice,
    IN PVOID hPlug,
    OUT PCMP_GET_PLUG_STATE pPlugState 
    );

NTSTATUS
Av61883SetCMPPlugValue(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister,
    PAV_PCR pAvPcr 
    );

NTSTATUS
Av61883RegisterForBusResetNotify(
    IN PKSDEVICE pKsDevice,
    IN ULONG fFlags
    );

VOID
Av61883Initialize(
    PKSDEVICE pKsDevice 
    );

NTSTATUS
Av61883CMPPlugMonitor(
    PKSDEVICE pKsDevice,
    BOOLEAN fOnOff
    );

NTSTATUS
Av61883ReserveVirtualPlug( 
    PCMP_REGISTER *ppCmpRegister,
    ULONG ulSubunitId,
    CMP_PLUG_TYPE CmpPlugType
    );

VOID
Av61883ReleaseVirtualPlug(
    PCMP_REGISTER pCmpRegister
    );

NTSTATUS
Av61883CreateVirtualSerialPlugs(
    PKSDEVICE pKsDevice,
    ULONG ulNumInputPlugs,
    ULONG ulNumOutputPlugs 
    );

NTSTATUS
Av61883CreateVirtualExternalPlugs(
    PKSDEVICE pKsDevice,
    ULONG ulNumInputPlugs,
    ULONG ulNumOutputPlugs 
    );

NTSTATUS
Av61883RemoveVirtualSerialPlugs(
    PKSDEVICE pKsDevice 
    );

NTSTATUS
Av61883RemoveVirtualExternalPlugs(
    PKSDEVICE pKsDevice 
    );

CYCLE_TIME
Bus1394CycleTimeDiff(
    CYCLE_TIME ct1, 
    CYCLE_TIME ct2 
    );

LONG
Bus1394CycleTimeCompare(
    CYCLE_TIME ct1, 
    CYCLE_TIME ct2 
    );

NTSTATUS
Bus1394GetCycleTime( 
    IN PDEVICE_OBJECT pNextDeviceObject,
    OUT PCYCLE_TIME pCycleTime 
    );

NTSTATUS
Bus1394GetNodeAddress(
    IN PDEVICE_OBJECT pNextDeviceObject,
    ULONG fNodeFlag,
    OUT PNODE_ADDRESS pNodeAddress 
    );

NTSTATUS
Bus1394GetGenerationCount(
    IN PDEVICE_OBJECT pNextDeviceObject,
    PULONG pGenerationCount 
    );

NTSTATUS
Bus1394QuadletRead(
    IN PDEVICE_OBJECT pNextDeviceObject,
    ULONG ulAddressLow,
    ULONG ulGenerationCount,
    PULONG pValue 
    );

#endif // ___61883CMD_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\61883.c ===
#include "Common.h"

NTSTATUS
Av61883SubmitRequestSync(
    IN PDEVICE_OBJECT pPhysicalDeviceObject,
    IN PAV_61883_REQUEST pRequest )
{
    NTSTATUS ntStatus, status;
    PIRP pIrp;
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;

    pKsEvent = (PKEVENT)(pRequest+1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_61883_CLASS,
                pPhysicalDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, // INTERNAL
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pRequest;

    // Call the 61883 class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pPhysicalDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject( pKsEvent, Suspended, KernelMode, FALSE, NULL );

        ntStatus = pIoStatus->Status;
    }

    return ntStatus;
}

// Device Info Function

NTSTATUS
Av61883GetSetUnitInfo(
    PKSDEVICE pKsDevice,
    ULONG ulCommand,
    ULONG nLevel,
    OUT PVOID pUnitInfo )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, ulCommand);
    pAv61883Request->GetUnitInfo.nLevel      = nLevel;
    pAv61883Request->GetUnitInfo.Information = pUnitInfo;
 
    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject,
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883GetPlugHandle( 
    IN PKSDEVICE pKsDevice,
    IN ULONG ulPlugNumber,
    IN CMP_PLUG_TYPE CmpPlugType,
    OUT PVOID *hPlug )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_GetPlugHandle);
    pAv61883Request->GetPlugHandle.Type     = CmpPlugType;
    pAv61883Request->GetPlugHandle.PlugNum  = ulPlugNumber;
 
    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    if ( NT_SUCCESS(ntStatus) ) {
        *hPlug = pAv61883Request->GetPlugHandle.hPlug;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883GetCmpPlugState(
    IN PKSDEVICE pKsDevice,
    IN PVOID hPlug,
    OUT PCMP_GET_PLUG_STATE pPlugState )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_GetPlugState);
    pAv61883Request->GetPlugState.hPlug = hPlug;
 
    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory( pPlugState, &pAv61883Request->GetPlugState, sizeof(CMP_GET_PLUG_STATE));
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883ConnectCmpPlugs(
    IN PKSDEVICE pKsDevice,
    IN ULONG fFlags,
    IN PVOID hInPlug,
    IN PVOID hOutPlug,
    KSPIN_DATAFLOW DataFlow,
    PKSDATAFORMAT pKsDataFormat,
    OUT PVOID *hConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PWAVEFORMATEX pWavFmt = (PWAVEFORMATEX)(pKsDataFormat+1);
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory(pAv61883Request, sizeof(AV_61883_REQUEST));

    INIT_61883_HEADER(pAv61883Request, Av61883_Connect);
    pAv61883Request->Flags = fFlags;

    pAv61883Request->Connect.Type        = CMP_PointToPoint;
    pAv61883Request->Connect.hInputPlug  = hInPlug;
    pAv61883Request->Connect.hOutputPlug = hOutPlug;

    pAv61883Request->Connect.Format.FMT = FMT_AUDIO_MUSIC;
    pAv61883Request->Connect.Format.BlockSize = (UCHAR)pWavFmt->nChannels; // Number of Channels 


    pAv61883Request->Connect.Format.FDF_hi = (UCHAR)((EVT_AM824<<4));
    pAv61883Request->Connect.Format.FDF_hi |= ( pWavFmt->nSamplesPerSec == 32000 ) ? SFC_32000Hz :
                                              ( pWavFmt->nSamplesPerSec == 44100 ) ? SFC_44100Hz :
                                              ( pWavFmt->nSamplesPerSec == 48000 ) ? SFC_48000Hz :
                                              ( pWavFmt->nSamplesPerSec == 96000 ) ? SFC_96000Hz :
                                                                                     SFC_48000Hz ;

    pAv61883Request->Connect.Format.BlockPeriod = (8000*3072)/pWavFmt->nSamplesPerSec;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    if ( NT_SUCCESS(ntStatus) ) {
        *hConnection = pAv61883Request->Connect.hConnect;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883DisconnectCmpPlugs(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_Disconnect);
    pAv61883Request->Disconnect.hConnect = hConnection;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

// Talk and Listen
NTSTATUS
Av61883StartTalkingOrListening(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection,
    ULONG ulFunction )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory( pAv61883Request, sizeof(AV_61883_REQUEST) );

    INIT_61883_HEADER(pAv61883Request, ulFunction);

    switch( ulFunction ) {
        case Av61883_Talk:
            pAv61883Request->Flags = CIP_TALK_DOUBLE_BUFFER;
            pAv61883Request->Talk.hConnect = hConnection;
            break;
        case Av61883_Listen:
            pAv61883Request->Listen.hConnect = hConnection;
            break;
        default:
            TRAP;
            break;
    }

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883StopTalkOrListen(
    IN PKSDEVICE pKsDevice,
    IN PVOID hConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    DbgLog( "83Stop", 0,0,0,0);

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory( pAv61883Request, sizeof(AV_61883_REQUEST) );

    INIT_61883_HEADER(pAv61883Request, Av61883_Stop);

    pAv61883Request->Stop.hConnect = hConnection;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

VOID
BusResetWorker(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    NTSTATUS ntStatus = Bus1394GetNodeAddress( pKsDevice->NextDeviceObject,
                                               USE_LOCAL_NODE,
                                               &pHwDevExt->NodeAddress );
    _DbgPrintF( DEBUGLVL_VERBOSE, ("[BusResetWorker] LocalNodeAddress: %x\n",
                                  pHwDevExt->NodeAddress ));
}

void
BusResetNotificationRtn(
    PKSDEVICE pKsDevice,
    PBUS_GENERATION_NODE pBusResetInfo  )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[BusResetNotificationRtn] Local: %x, Device: %x Generation; %d\n",
                                  pBusResetInfo->LocalNodeAddress, 
                                  pBusResetInfo->DeviceNodeAddress,
                                  pBusResetInfo->GenerationCount ));

    pHwDevExt->ulGenerationCount = pBusResetInfo->GenerationCount;
//    pHwDevExt->NodeAddress = pBusResetInfo->LocalNodeAddress;
    pUnitInfo->NodeAddress = pBusResetInfo->DeviceNodeAddress;

    // Need to queue a work item to get the current Local Node Address for CCM.
    ExInitializeWorkItem( &pHwDevExt->BusResetWorkItem, BusResetWorker, pKsDevice );
    ExQueueWorkItem( &pHwDevExt->BusResetWorkItem, DelayedWorkQueue );
}

NTSTATUS
Av61883RegisterForBusResetNotify(
    IN PKSDEVICE pKsDevice,
    IN ULONG fFlags )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus;

    if (pHwDevExt->fSurpriseRemoved) return STATUS_SUCCESS;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_BusResetNotify);

    pAv61883Request->BusResetNotify.pfnNotify = BusResetNotificationRtn;
    pAv61883Request->BusResetNotify.Context   = pKsDevice;
    pAv61883Request->BusResetNotify.Flags     = fFlags;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}


NTSTATUS
Av61883CreateCMPPlug(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister,
    PCMP_NOTIFY_ROUTINE pNotifyRtn,
    PULONG pPlugNumber,
    HANDLE *phPlug )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[Av61883CreateCMPPlug] Enter Notify: %x\n", pNotifyRtn));

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_CreatePlug);
    pAv61883Request->CreatePlug.PlugType      = pCmpRegister->CmpPlugType;
    pAv61883Request->CreatePlug.Pcr.ulongData = pCmpRegister->AvPcr.ulongData;
    pAv61883Request->CreatePlug.pfnNotify     = pNotifyRtn;
    pAv61883Request->CreatePlug.Context       = pCmpRegister;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );
    if ( NT_SUCCESS(ntStatus) ) {
        *pPlugNumber = pAv61883Request->CreatePlug.PlugNum;
        *phPlug = pAv61883Request->CreatePlug.hPlug;
        _DbgPrintF( DEBUGLVL_VERBOSE, ("[Av61883CreateCMPPlug] SUCCESS! PlugNumber: %d\n", *pPlugNumber));
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

NTSTATUS
Av61883ReleaseCMPPlug(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[Av61883ReleaseCMPPlug] \n"));

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_DeletePlug);
    pAv61883Request->DeletePlug.hPlug = pCmpRegister->hPlug;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;

}

NTSTATUS
Av61883SetCMPPlugValue(
    PKSDEVICE pKsDevice,
    PCMP_REGISTER pCmpRegister,
    PAV_PCR pAvPcr )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_BLAB, ("[Av61883SetCMPPlugValue] Enter\n"));

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_SetPlug);
    pAv61883Request->SetPlug.hPlug         = pCmpRegister->hPlug;
    pAv61883Request->SetPlug.Pcr.ulongData = pCmpRegister->AvPcr.ulongData;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;
}

void
PCRMonitorCallback(
    IN PCMP_MONITOR_INFO pMonitorInfo )
{
    PCMP_REGISTER pCmpRegister;
    KIRQL kIrql;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PCRMonitorCallback] Plug# %d\n", pMonitorInfo->PlugNum));

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );
    if ( !IsListEmpty(&AvcSubunitGlobalInfo.UnitPlugConnections) ) {
        pCmpRegister = (PCMP_REGISTER)AvcSubunitGlobalInfo.UnitPlugConnections.Flink;
        while ( pCmpRegister != (PCMP_REGISTER)&AvcSubunitGlobalInfo.UnitPlugConnections ) {
            if (( pCmpRegister->ulPlugNumber == pMonitorInfo->PlugNum ) && 
                ( pCmpRegister->CmpPlugType  == pMonitorInfo->PlugType)) {
                pCmpRegister->AvPcr = pMonitorInfo->Pcr;
                _DbgPrintF( DEBUGLVL_VERBOSE, ("[PCRMonitorCallback] Update Plug# %d, AvPcr: %x\n",
                                            pCmpRegister->ulPlugNumber, pCmpRegister->AvPcr.ulongData));
            }
            pCmpRegister = (PCMP_REGISTER)pCmpRegister->List.Flink;
        }
    }
    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );
    
}

NTSTATUS
Av61883CMPPlugMonitor(
    PKSDEVICE pKsDevice,
    BOOLEAN fOnOff )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAV_61883_REQUEST pAv61883Request;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pAv61883Request = (PAV_61883_REQUEST)
    		ExAllocateFromNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList);
    if ( !pAv61883Request ) return STATUS_INSUFFICIENT_RESOURCES;

    INIT_61883_HEADER(pAv61883Request, Av61883_MonitorPlugs);
    pAv61883Request->MonitorPlugs.Flags     = (fOnOff) ? REGISTER_MONITOR_PLUG_NOTIFY :
                                                         DEREGISTER_MONITOR_PLUG_NOTIFY;
    pAv61883Request->MonitorPlugs.pfnNotify = PCRMonitorCallback;
    pAv61883Request->MonitorPlugs.Context   = pKsDevice;

    ntStatus = Av61883SubmitRequestSync( pKsDevice->NextDeviceObject, 
                                         pAv61883Request );

    ExFreeToNPagedLookasideList(&pHwDevExt->Av61883CmdLookasideList, pAv61883Request);

    return ntStatus;

}

void
oPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo )
{
    PCMP_REGISTER pCmpRegister = pNotifyInfo->Context;
    PAV_PCR pAvPcr = &pNotifyInfo->Pcr;
    PAV_PCR pRegPcr = &pCmpRegister->AvPcr;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    _DbgPrintF(DEBUGLVL_BLAB, ("[oPCRAccessCallback]: pNotifyInfo: %x Old: %x New: %x\n", 
                                   pNotifyInfo, pRegPcr->ulongData, pAvPcr->ulongData ));

    if ( pRegPcr->ulongData != pAvPcr->ulongData ) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("[oPCRAccessCallback]: **CMP PCR Changed Old: %x New: %x\n",
                                      pRegPcr->ulongData, pAvPcr->ulongData ));

        if (( pAvPcr->iPCR.PPCCounter == 0 ) && ( pAvPcr->iPCR.BCCCounter == 0 )){
            if ( pRegPcr->iPCR.PPCCounter || pRegPcr->iPCR.BCCCounter ) {
                // If Counts have gone to 0 stop Talking
                _DbgPrintF(DEBUGLVL_BLAB, ("[oPCRAccessCallback]: STOP Talking Old: %x New: %x\n",
                                             pRegPcr->ulongData, pAvPcr->ulongData ));
                KeResetEvent( &pCmpRegister->kEventConnected );
            }
        }
        else if (( pAvPcr->iPCR.PPCCounter ) || ( pAvPcr->iPCR.BCCCounter )) {
            if ( !(pRegPcr->iPCR.PPCCounter || pRegPcr->iPCR.BCCCounter) ) {
                // Need to open the associated local device pin

                _DbgPrintF(DEBUGLVL_BLAB, ("[oPCRAccessCallback]: START Talking Old: %x New: %x\n",
                                             pRegPcr->ulongData, pAvPcr->ulongData ));

                // If counts have gone from 0 to > 0 start Talking
                KeSetEvent( &pCmpRegister->kEventConnected, 0, FALSE );
            }
        }

        pRegPcr->ulongData = pAvPcr->ulongData;

    }
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }
}

void
iPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo )
{
    PCMP_REGISTER pCmpRegister = pNotifyInfo->Context;
    PAV_PCR pAvPcr = &pNotifyInfo->Pcr;
    PAV_PCR pRegPcr = &pCmpRegister->AvPcr;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[iPCRAccessCallback]: pNotifyInfo: %x Old: %x New: %x\n", 
                                   pNotifyInfo, pRegPcr->ulongData, pAvPcr->ulongData ));

/*
    if ( pRegPcr->ulongData != pAvPcr->ulongData ) {
        if (( pAvPcr->iPCR.PPCCounter == 0 ) && ( pAvPcr->iPCR.BCCCounter == 0 )){
            if ( pRegPcr->iPCR.PPCCounter || pRegPcr->iPCR.BCCCounter ) {
                // If Counts have gone to 0 stop Listening
                _DbgPrintF(DEBUGLVL_VERBOSE, ("[iPCRAccessCallback]: STOP Listening\n"));
                TRAP;
 
//              ntStatus = CmpStopListening( pCmpRegister, &pNotifyInfo->Pcr );
            }
        }
        else if (( pAvPcr->iPCR.PPCCounter ) || ( pAvPcr->iPCR.BCCCounter )) {
            if ( !(pRegPcr->iPCR.PPCCounter || pRegPcr->iPCR.BCCCounter) ) {
                // Need to open the associated local device pin

                _DbgPrintF(DEBUGLVL_VERBOSE, ("[iPCRAccessCallback]: START Listening\n"));

                // If counts have gone from 0 to > 0 start Listening
//              ntStatus = CmpStartListening( pCmpRegister, &pNotifyInfo->Pcr );
            }
        }
    }
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }
*/
}

NTSTATUS
Av61883ReserveVirtualPlug( 
    PCMP_REGISTER *ppCmpRegister,
    ULONG ulSubunitId,
    CMP_PLUG_TYPE CmpPlugType )
{
    PCMP_REGISTER pCmpRegister = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL KIrql;

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &KIrql );
    if ( !IsListEmpty(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[CmpPlugType].List) ) {
        pCmpRegister = (PCMP_REGISTER)
            RemoveHeadList(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[CmpPlugType].List);
        InsertTailList(&AvcSubunitGlobalInfo.UnitPlugConnections, &pCmpRegister->List);
        AvcSubunitGlobalInfo.ulUnitPlugConnectionCount++;
    }
    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, KIrql );

    *ppCmpRegister = pCmpRegister;

    if ( !pCmpRegister ) {
        ntStatus = STATUS_NOT_FOUND;
    }

    return ntStatus;
}

VOID
Av61883ReleaseVirtualPlug(
    PCMP_REGISTER pCmpRegister )
{
    KIRQL KIrql;

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &KIrql );

    RemoveEntryList(&pCmpRegister->List);
    AvcSubunitGlobalInfo.ulUnitPlugConnectionCount--;

    InsertHeadList( &AvcSubunitGlobalInfo.UnitSerialBusPlugs[pCmpRegister->CmpPlugType].List, 
                    &pCmpRegister->List );

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, KIrql );
}

NTSTATUS
Av61883CreateVirtualSerialPlugs(
    PKSDEVICE pKsDevice,
    ULONG ulNumInputPlugs,
    ULONG ulNumOutputPlugs )
{
    PCMP_REGISTER  pCmpRegister;
    AV_PCR AvPcrIn, AvPcrOut;
    ULONG ulPlgCnt;
    ULONG i, j;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    AvPcrOut.ulongData       = 0;
    AvPcrOut.oPCR.OverheadID = 0xf;
    AvPcrOut.oPCR.Payload    = 0x1a;
    AvPcrOut.oPCR.DataRate   = 2; // Hardcode to 400 for the PC.
    AvPcrOut.oPCR.OnLine     = TRUE;

    AvPcrIn.ulongData   = 0;
    AvPcrIn.oPCR.OnLine = TRUE;

    for ( j=CMP_PlugOut; j<=CMP_PlugIn; j++ ) {
        ulPlgCnt = (j==CMP_PlugOut) ? ulNumOutputPlugs : ulNumInputPlugs;
        for ( i=0; i<ulPlgCnt; i++ ) {
            pCmpRegister = AllocMem( NonPagedPool, sizeof(CMP_REGISTER) );
            if ( !pCmpRegister ) return STATUS_INSUFFICIENT_RESOURCES;

            pCmpRegister->pKsDevice       = pKsDevice;
            pCmpRegister->fPlugType       = SERIAL_BUS_PLUG_TYPE;
            pCmpRegister->CmpPlugType     = (CMP_PLUG_TYPE)j;
            pCmpRegister->AvPcr.ulongData = (j == CMP_PlugIn) ? AvPcrIn.ulongData :
                                                                AvPcrOut.ulongData;
            KeInitializeEvent ( &pCmpRegister->kEventConnected, NotificationEvent, TRUE );

            ntStatus = Av61883CreateCMPPlug( pKsDevice,
                                             pCmpRegister,
                                             (j == CMP_PlugIn) ? iPCRAccessCallback :
                                                                 oPCRAccessCallback,
                                             &pCmpRegister->ulPlugNumber,
                                             &pCmpRegister->hPlug );
            if ( NT_SUCCESS(ntStatus) ) {
                InsertTailList(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].List, &pCmpRegister->List);
                AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].ulCount++;
            }
            else if ( ntStatus == STATUS_INSUFFICIENT_RESOURCES ){
                ntStatus = STATUS_SUCCESS;
                FreeMem( pCmpRegister );
                break;
            }
            else {
                FreeMem( pCmpRegister );
                return ntStatus;
            }
        }
    }


    ntStatus = Av61883CMPPlugMonitor( pKsDevice, TRUE );
    if ( NT_SUCCESS(ntStatus) ) {
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fPlugMonitor = TRUE;
    }

#if DBG
    if ( !NT_SUCCESS(ntStatus) ) TRAP;
#endif

    return ntStatus;

}

NTSTATUS
Av61883CreateVirtualExternalPlugs(
    PKSDEVICE pKsDevice,
    ULONG ulNumInputPlugs,
    ULONG ulNumOutputPlugs )
{
    PEXTERNAL_PLUG pExternalPlug;
    ULONG ulPlgCnt;
    ULONG i, j;

    for ( j=CMP_PlugOut; j<=CMP_PlugIn; j++ ) {
        ulPlgCnt = (j==CMP_PlugOut) ? ulNumOutputPlugs : ulNumInputPlugs;
        for ( i=0; i<ulPlgCnt; i++ ) {
            pExternalPlug = AllocMem( NonPagedPool, sizeof(EXTERNAL_PLUG) );
            if ( !pExternalPlug ) return STATUS_INSUFFICIENT_RESOURCES;
                
            pExternalPlug->fPlugType    = EXTERNAL_PLUG_TYPE;
            pExternalPlug->CmpPlugType  = j;
            pExternalPlug->ulPlugNumber = MIN_EXTERNAL_PLUG_NUMBER + i;

            AvcSubunitGlobalInfo.UnitExternalPlugs[j].ulCount++;
            InsertTailList(&AvcSubunitGlobalInfo.UnitExternalPlugs[j].List, &pExternalPlug->List);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
Av61883RemoveVirtualSerialPlugs(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PCMP_REGISTER pCmpRegister;
    NTSTATUS ntStatus;
    ULONG j;

    // Turn off Plug Monitor.
    if ( pHwDevExt->fPlugMonitor )
        ntStatus = Av61883CMPPlugMonitor( pKsDevice, FALSE );
    
    for ( j=CMP_PlugOut; j<=CMP_PlugIn; j++ ) {
        while( !IsListEmpty(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].List) ) {
            pCmpRegister = (PCMP_REGISTER)RemoveHeadList(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].List);

            if (!pHwDevExt->fSurpriseRemoved) {

                ntStatus = Av61883ReleaseCMPPlug( pKsDevice, pCmpRegister );
                if ( NT_SUCCESS(ntStatus) || STATUS_NO_SUCH_DEVICE == ntStatus) {
                    FreeMem(pCmpRegister);
                }
                else {
                    // the pCmpRegister memory may still be accessed, let it leak
                }

                _DbgPrintF(DEBUGLVL_VERBOSE,("[Av61883RemoveVirtualSerialPlugs] j: %d UnitSerialBusPlugs[j].ulCount: %d\n",
                                            j, AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].ulCount ));
            }
            else {

                // no reason to release the plug, just free the memory
                FreeMem(pCmpRegister);
            }
            AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].ulCount--;
        }
        ASSERT( AvcSubunitGlobalInfo.UnitSerialBusPlugs[j].ulCount == 0 );

    }

    return STATUS_SUCCESS;

}

NTSTATUS
Av61883RemoveVirtualExternalPlugs(
    PKSDEVICE pKsDevice )
{
    PEXTERNAL_PLUG pExternalPlug;
    ULONG j;

    for ( j=CMP_PlugOut; j<=CMP_PlugIn; j++ ) {
        while( !IsListEmpty(&AvcSubunitGlobalInfo.UnitExternalPlugs[j].List) ) {
            pExternalPlug = (PEXTERNAL_PLUG)RemoveHeadList(&AvcSubunitGlobalInfo.UnitExternalPlugs[j].List);
            FreeMem(pExternalPlug);
            AvcSubunitGlobalInfo.UnitExternalPlugs[j].ulCount--;
        }
        ASSERT( AvcSubunitGlobalInfo.UnitExternalPlugs[j].ulCount == 0 );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\1394bus.c ===
#include "Common.h"

NTSTATUS
Bus1394SubmitRequestSync(
    IN PDEVICE_OBJECT pPhysicalDeviceObject,
    IN PIRB pIrb )
{
    NTSTATUS ntStatus, status;
    PIRP pIrp;
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;

    pKsEvent = (PKEVENT)(pIrb+1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_1394_CLASS,
                pPhysicalDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, // INTERNAL
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pIrb;

    // Call the 61883 class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pPhysicalDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject( pKsEvent, Suspended, KernelMode, FALSE, NULL );

        ntStatus = pIoStatus->Status;
    }

    return ntStatus;
}


#define	CYCLE_TIME_CYCLE_OFFSET_MAX		3071
#define	CYCLE_TIME_CYCLE_COUNT_MAX		7999
#define	CYCLE_TIME_SECOND_COUNT_MAX		127

#define	CYCLE_TIME_CYCLE_OFFSET_OVER	3072
#define	CYCLE_TIME_CYCLE_COUNT_OVER		8000
#define	CYCLE_TIME_SECOND_COUNT_OVER	128

CYCLE_TIME
Bus1394CycleTimeAdd(
    CYCLE_TIME ct1, 
    CYCLE_TIME ct2 )
{
	ULONG tmp;

	tmp = ct1.CL_CycleOffset + ct2.CL_CycleOffset;
    if ( tmp >= CYCLE_TIME_CYCLE_OFFSET_OVER ) {
        ct1.CL_CycleCount += tmp/CYCLE_TIME_CYCLE_OFFSET_OVER;
    }
	ct1.CL_CycleOffset = tmp%CYCLE_TIME_CYCLE_OFFSET_OVER;

	tmp = ct1.CL_CycleCount + ct2.CL_CycleCount;
	if (tmp >= CYCLE_TIME_CYCLE_COUNT_OVER) {
		ct1.CL_SecondCount+= tmp/CYCLE_TIME_CYCLE_COUNT_OVER;
	}
	ct1.CL_CycleCount = tmp%CYCLE_TIME_CYCLE_COUNT_OVER;

	ct1.CL_SecondCount += ct2.CL_SecondCount;
	return ct1;
}

CYCLE_TIME
Bus1394CycleTimeDiff(
    CYCLE_TIME ct1, 
    CYCLE_TIME ct2 )
{
	if (ct1.CL_CycleOffset < ct2.CL_CycleOffset) {
		if (ct1.CL_CycleCount == 0) {
			ct1.CL_SecondCount--;
			ct1.CL_CycleCount += CYCLE_TIME_CYCLE_COUNT_OVER;
		}
		ct1.CL_CycleCount--;
		ct1.CL_CycleOffset += CYCLE_TIME_CYCLE_OFFSET_OVER;
	}
	ct1.CL_CycleOffset -= ct2.CL_CycleOffset;
	if (ct1.CL_CycleCount < ct2.CL_CycleCount) {
		ct1.CL_SecondCount--;
		ct1.CL_CycleCount += CYCLE_TIME_CYCLE_COUNT_OVER;
	}
	ct1.CL_CycleCount -= ct2.CL_CycleCount;
	ct1.CL_SecondCount -= ct2.CL_SecondCount;
	return ct1;
}

LONG
Bus1394CycleTimeCompare(
    CYCLE_TIME ct1, 
    CYCLE_TIME ct2 )
{
    LONG rVal = 0;

    if ( ct1.CL_SecondCount > ct2.CL_SecondCount ) {
        rVal = -1;
    }
    else if ( ct1.CL_SecondCount < ct2.CL_SecondCount ) {
        rVal = 1;
    }
    else {
        if ( ct1.CL_CycleCount > ct2.CL_CycleCount ) {
            rVal = -1;
        }
        else if ( ct1.CL_CycleCount < ct2.CL_CycleCount ) {
            rVal = 1;
        }
        else {
            if ( ct1.CL_CycleOffset > ct2.CL_CycleOffset ) {
                rVal = -1;
            }
            else if ( ct1.CL_CycleOffset < ct2.CL_CycleOffset ) {
                rVal = 1;
            }
        }
    }

    return rVal;
}


NTSTATUS
Bus1394GetCycleTime( 
    IN PDEVICE_OBJECT pNextDeviceObject,
    OUT PCYCLE_TIME pCycleTime )
{
    NTSTATUS ntStatus;
    PIRB pIrb;

    pIrb = AllocMem(NonPagedPool, sizeof(IRB) + sizeof (KSEVENT) + sizeof(IO_STATUS_BLOCK));
    if ( !pIrb ) return STATUS_INSUFFICIENT_RESOURCES;

    pIrb->FunctionNumber = REQUEST_ISOCH_QUERY_CYCLE_TIME;
    pIrb->Flags = 0;

    ntStatus = Bus1394SubmitRequestSync( pNextDeviceObject, 
                                         pIrb );
    if ( NT_SUCCESS( ntStatus ) ) {
        *pCycleTime = pIrb->u.IsochQueryCurrentCycleTime.CycleTime;
        DbgLog("BsGtCyc", pIrb, pCycleTime->CL_SecondCount, 
                          pCycleTime->CL_CycleCount, pCycleTime->CL_CycleOffset);
    }

    FreeMem( pIrb );

    return ntStatus;
}

NTSTATUS
Bus1394GetNodeAddressCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PIRB pIrb )
{
    PNODE_ADDRESS pNodeAddress;

    pNodeAddress = *((PNODE_ADDRESS *)(pIrb+1));

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[Bus1394GetNodeAddressCallback]: pIrb: %x pNodeAddress: %x\n",
                                   pIrb, pNodeAddress ));

    if ( STATUS_SUCCESS == pIrp->IoStatus.Status ) {
        *pNodeAddress = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;
    }

    FreeMem(pIrb);

    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Bus1394GetNodeAddress(
    IN PDEVICE_OBJECT pNextDeviceObject,
    ULONG fNodeFlag,
    OUT PNODE_ADDRESS pNodeAddress )
{
    PIO_STACK_LOCATION pNextIrpStack;
    NTSTATUS ntStatus;
    PIRB pIrb;
    PIRP pIrp;

    pIrb = AllocMem(NonPagedPool, sizeof(IRB) + sizeof(PNODE_ADDRESS) );
    if ( !pIrb ) return STATUS_INSUFFICIENT_RESOURCES;

    pIrp = IoAllocateIrp(pNextDeviceObject->StackSize, FALSE);
    if ( !pIrp ) {
        FreeMem(pIrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[Bus1394GetNodeAddress]: pIrb: %x pNodeAddress: %x\n", pIrb, pNodeAddress));

    pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    pIrb->Flags = 0;
    pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fNodeFlag;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextIrpStack != NULL);

    pNextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    pNextIrpStack->Parameters.Others.Argument1 = pIrb;

    *((PNODE_ADDRESS *)(pIrb+1)) = pNodeAddress;

    IoSetCompletionRoutine( pIrp,
                            Bus1394GetNodeAddressCallback,
                            pIrb,
                            TRUE, TRUE, TRUE );

    ntStatus = IoCallDriver(pNextDeviceObject, pIrp);

    return ntStatus;
}

NTSTATUS
Bus1394GetGenerationCount(
    IN PDEVICE_OBJECT pNextDeviceObject,
    PULONG pGenerationCount )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRB     pIrb;

    pIrb = AllocMem(NonPagedPool, sizeof(IRB) + sizeof (KSEVENT) + sizeof(IO_STATUS_BLOCK));
    if ( !pIrb ) return STATUS_INSUFFICIENT_RESOURCES;

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;

    ntStatus = Bus1394SubmitRequestSync( pNextDeviceObject, pIrb );

    if ( NT_SUCCESS(ntStatus) ) {
        *pGenerationCount = pIrb->u.GetGenerationCount.GenerationCount;
    }

    FreeMem(pIrb);

    return ntStatus;
} 

NTSTATUS
Bus1394QuadletRead(
    IN PDEVICE_OBJECT pNextDeviceObject,
    ULONG ulAddressLow,
    ULONG ulGenerationCount,
    PULONG pValue )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRB     pIrb;
    PMDL     pMdl;

    pIrb = AllocMem(NonPagedPool, sizeof(IRB) + sizeof (KSEVENT) + sizeof(IO_STATUS_BLOCK));
    if ( !pIrb ) return STATUS_INSUFFICIENT_RESOURCES;

    pMdl = IoAllocateMdl(pValue, sizeof(ULONG), FALSE, FALSE, NULL);
    if (!pMdl) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(pMdl);

    pIrb->FunctionNumber = REQUEST_ASYNC_READ;
    pIrb->Flags = 0;

    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = (USHORT)0xffff;
    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  = ulAddressLow;
    pIrb->u.AsyncRead.nNumberOfBytesToRead = 4;
    pIrb->u.AsyncRead.nBlockSize = 0;
    pIrb->u.AsyncRead.fulFlags = 0;
    pIrb->u.AsyncRead.Mdl = pMdl;
    pIrb->u.AsyncRead.ulGeneration = ulGenerationCount;
    pIrb->u.AsyncRead.chPriority = 0;
    pIrb->u.AsyncRead.nSpeed = 0;
    pIrb->u.AsyncRead.tCode = 0;
    pIrb->u.AsyncRead.Reserved = 0;

    ntStatus = Bus1394SubmitRequestSync( pNextDeviceObject, pIrb );

    if (pMdl) IoFreeMdl(pMdl);

    FreeMem(pIrb);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\stdunk\stdunk.cpp ===
/*****************************************************************************
 * stdunk.cpp - standard unknown implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "portcls.h"
#include "stdunk.h"





/*****************************************************************************
 * CUnknown implementation
 */

/*****************************************************************************
 * CUnknown::CUnknown()
 *****************************************************************************
 * Constructor.
 */
CUnknown::CUnknown(PUNKNOWN pUnknownOuter)
:   m_lRefCount(0)
{
    if (pUnknownOuter)
    {
        m_pUnknownOuter = pUnknownOuter;
    }
    else
    {
        m_pUnknownOuter = PUNKNOWN(dynamic_cast<PNONDELEGATINGUNKNOWN>(this));
    }
}

/*****************************************************************************
 * CUnknown::~CUnknown()
 *****************************************************************************
 * Destructor.
 */
CUnknown::~CUnknown(void)
{
}




/*****************************************************************************
 * INonDelegatingUnknown implementation
 */

/*****************************************************************************
 * CUnknown::NonDelegatingAddRef()
 *****************************************************************************
 * Register a new reference to the object without delegating to the outer
 * unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef(void)
{
    ASSERT(m_lRefCount >= 0);

    InterlockedIncrement(&m_lRefCount);

    return ULONG(m_lRefCount);
}

/*****************************************************************************
 * CUnknown::NonDelegatingRelease()
 *****************************************************************************
 * Release a reference to the object without delegating to the outer unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease(void)
{
    ASSERT(m_lRefCount > 0);

    if (InterlockedDecrement(&m_lRefCount) == 0)
	{
        m_lRefCount++;
        delete this;
        return 0;
	}

    return ULONG(m_lRefCount); 
}

/*****************************************************************************
 * CUnknown::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS) CUnknown::NonDelegatingQueryInterface
(
    REFIID  rIID,
    PVOID * ppVoid
)
{
    ASSERT(ppVoid);

    if (IsEqualGUIDAligned(rIID,IID_IUnknown))
    {
        *ppVoid = PVOID(PUNKNOWN(this));
    }
    else
    {
        *ppVoid = NULL;
    }
    
    if (*ppVoid)
    {
        PUNKNOWN(*ppVoid)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavepci\port.cpp ===
/*****************************************************************************
 * port.cpp - PCI wave port driver
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreatePortWavePci()
 *****************************************************************************
 * Creates a PCI wave port driver.
 */
NTSTATUS
CreatePortWavePci
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF (DEBUGLVL_LIFETIME, ("Creating WAVEPCI Port"));

    STD_CREATE_BODY_
    (
        CPortWavePci,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTWAVEPCI
    );
}

/*****************************************************************************
 * PortDriverWavePci
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverWavePci =
{
    &CLSID_PortWavePci,
    CreatePortWavePci
};

/*****************************************************************************
 * Member functions
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CPortWavePci::~CPortWavePci()
 *****************************************************************************
 * Destructor.
 */
CPortWavePci::~CPortWavePci()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVEPCI Port (0x%08x)", this));

    if (m_pSubdeviceDescriptor)
    {
        PcDeleteSubdeviceDescriptor(m_pSubdeviceDescriptor);
    }

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
        Miniport = NULL;
    }

    if (ServiceGroup)
    {
        ServiceGroup->RemoveMember(PSERVICESINK(this));
        ServiceGroup->Release();
        ServiceGroup = NULL;
    }

    // TODO:  Kill notification queue?
}

/*****************************************************************************
 * CPortWavePci::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPort))
    {
        *Object = PVOID(PPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortWavePci))
    {
        *Object = PVOID(PPORTWAVEPCI(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_ISubdevice))
    {
        *Object = PVOID(PSUBDEVICE(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IIrpTargetFactory))
    {
        *Object = PVOID(PIRPTARGETFACTORY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IServiceSink))
    {
        *Object = PVOID(PSERVICESINK(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortEvents))
    {
        *Object = PVOID(PPORTEVENTS(this));
    }
#ifdef DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort))
    {
        *Object = PVOID(PDRMPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort2))
    {
        *Object = PVOID(PDRMPORT2(this));
    }
#endif  // DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IPortClsVersion))
    {
        *Object = PVOID(PPORTCLSVERSION(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

static
GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

static
KSPIN_INTERFACE PinInterfacesStream[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING,
      0
   },
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_LOOPED_STREAMING,
      0
   }
};

/*****************************************************************************
 * CPortWavePci::Init()
 *****************************************************************************
 * Initializes the port.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
Init
(
    IN      PDEVICE_OBJECT  DeviceObjectIn,
    IN      PIRP            Irp,
    IN      PUNKNOWN        UnknownMiniport,
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(DeviceObjectIn);
    ASSERT(Irp);
    ASSERT(UnknownMiniport);
    ASSERT(ResourceList);

    _DbgPrintF( DEBUGLVL_LIFETIME, ("Initializing WAVEPCI Port (0x%08x)", this));

    DeviceObject = DeviceObjectIn;

    KeInitializeMutex(&ControlMutex,1);

    KeInitializeMutex( &m_PinListMutex, 1 );
    InitializeListHead( &m_PinList );

    KeInitializeSpinLock( &(m_EventList.ListLock) );
    InitializeListHead( &(m_EventList.List) );
    m_EventContext.ContextInUse = FALSE;
    KeInitializeDpc( &m_EventDpc,
                     PKDEFERRED_ROUTINE(PcGenerateEventDeferredRoutine),
                     PVOID(&m_EventContext) );

    NTSTATUS ntStatus = UnknownMiniport->QueryInterface( IID_IMiniportWavePci,
                                                         (PVOID *) &Miniport );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = Miniport->Init( UnknownAdapter,
                                   ResourceList,
                                   PPORTWAVEPCI(this),
                                   &ServiceGroup );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor);

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus =
                    PcCreateSubdeviceDescriptor
                    (
                        m_pPcFilterDescriptor,
                        SIZEOF_ARRAY(TopologyCategories),
                        TopologyCategories,
                        SIZEOF_ARRAY(PinInterfacesStream),
                        PinInterfacesStream,
                        SIZEOF_ARRAY(PropertyTable_FilterWavePci),
                        PropertyTable_FilterWavePci,
                        0,      // FilterEventSetCount
                        NULL,   // FilterEventSets
                        SIZEOF_ARRAY(PropertyTable_PinWavePci),
                        PropertyTable_PinWavePci,
                        SIZEOF_ARRAY(EventTable_PinWavePci),
                        EventTable_PinWavePci,
                        &m_pSubdeviceDescriptor
                    );

                if (NT_SUCCESS(ntStatus) && ServiceGroup)
                {
                    ServiceGroup->AddMember(PSERVICESINK(this));
                }
                if (NT_SUCCESS(ntStatus))
                {
                    NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPinCount,(PVOID *)&m_MPPinCountI);
                }
            }
        }
    }

    if(!NT_SUCCESS(ntStatus))
    {
        if (m_MPPinCountI)
        {
            m_MPPinCountI->Release();
            m_MPPinCountI = NULL;
        }

        if( Miniport )
        {
            Miniport->Release();
            Miniport = NULL;
        }
    }


    _DbgPrintF( DEBUGLVL_BLAB, ("Port Init done w/ status %x",ntStatus));

    return ntStatus;
}

/*****************************************************************************
 * CPortWavePci::GetDeviceProperty()
 *****************************************************************************
 * Gets device properties from the registry for PnP devices.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
GetDeviceProperty
(
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
)
{
    return ::PcGetDeviceProperty(   PVOID(DeviceObject),
                                    DeviceProperty,
                                    BufferLength,
                                    PropertyBuffer,
                                    ResultLength );
}

/*****************************************************************************
 * CPortWavePci::NewRegistryKey()
 *****************************************************************************
 * Opens/creates a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
NewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    return ::PcNewRegistryKey(  OutRegistryKey,
                                OuterUnknown,
                                RegistryKeyType,
                                DesiredAccess,
                                PVOID(DeviceObject),
                                PVOID(PSUBDEVICE(this)),
                                ObjectAttributes,
                                CreateOptions,
                                Disposition );
}

/*****************************************************************************
 * CPortWavePci::ReleaseChildren()
 *****************************************************************************
 * Release child objects.
 */
STDMETHODIMP_(void)
CPortWavePci::
ReleaseChildren
(   void
)
{
    PAGED_CODE();

    _DbgPrintF (DEBUGLVL_LIFETIME, ("ReleaseChildren of WAVEPCI Port (0x%08x)", this));

    POWER_STATE     PowerState;

    // set things to D3 before releasing the miniport
    PowerState.DeviceState = PowerDeviceD3;
    PowerChangeNotify( PowerState );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
        Miniport = NULL;
    }

    if (ServiceGroup)
    {
        ServiceGroup->RemoveMember(PSERVICESINK(this));
        ServiceGroup->Release();
        ServiceGroup = NULL;
    }
}

/*****************************************************************************
 * CPortWavePci::GetDescriptor()
 *****************************************************************************
 * Return the descriptor for this port
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
GetDescriptor
(   OUT     const SUBDEVICE_DESCRIPTOR **   ppSubdeviceDescriptor
)
{
    PAGED_CODE();

    ASSERT(ppSubdeviceDescriptor);

    *ppSubdeviceDescriptor = m_pSubdeviceDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CPortWavePci::DataRangeIntersection()
 *****************************************************************************
 * Generate a format which is the intersection of two data ranges.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    ASSERT(DataRange);
    ASSERT(MatchingDataRange);
    ASSERT(ResultantFormatLength);

    return 
        Miniport->DataRangeIntersection
        (   PinId,
            DataRange,
            MatchingDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
}

/*****************************************************************************
 * CPortWavePci::PowerChangeNotify()
 *****************************************************************************
 * Called by portcls to notify the port/miniport of a device power
 * state change.
 */
STDMETHODIMP_(void)
CPortWavePci::
PowerChangeNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    PPOWERNOTIFY pPowerNotify;

    if( Miniport )
    {
        // QI for the miniport notification interface
        NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPowerNotify,
                                                      (PVOID *)&pPowerNotify );

        // check if we're powering up
        if( PowerState.DeviceState == PowerDeviceD0 )
        {
            // notify the miniport
            if( NT_SUCCESS(ntStatus) )
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
    
            // notify each port pin
            KeWaitForSingleObject( &m_PinListMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            
            if( !IsListEmpty( &m_PinList ) )
            {
                for(PLIST_ENTRY listEntry = m_PinList.Flink;
                    listEntry != &m_PinList;
                    listEntry = listEntry->Flink)
                {
                    CPortPinWavePci *pin = (CPortPinWavePci *)CONTAINING_RECORD( listEntry,
                                                                                 CPortPinWavePci,
                                                                                 m_PinListEntry );

                    pin->PowerNotify( PowerState );
                }                
            }

            KeReleaseMutex( &m_PinListMutex, FALSE );
        
        } else  // we're powering down
        {
            // notify each port pin
            KeWaitForSingleObject( &m_PinListMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            
            if( !IsListEmpty( &m_PinList ) )
            {
                for(PLIST_ENTRY listEntry = m_PinList.Flink;
                    listEntry != &m_PinList;
                    listEntry = listEntry->Flink)
                {
                    CPortPinWavePci *pin = (CPortPinWavePci *)CONTAINING_RECORD( listEntry,
                                                                                 CPortPinWavePci,
                                                                                 m_PinListEntry );

                    pin->PowerNotify( PowerState );
                }                
            }

            KeReleaseMutex( &m_PinListMutex, FALSE );
            
            // notify the miniport
            if( NT_SUCCESS(ntStatus) )
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortWavePci::PinCount()
 *****************************************************************************
 * Called by portcls to give the port\miniport a chance 
 * to override the default pin counts for this pin ID.
 */
STDMETHODIMP_(void)
CPortWavePci::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, 
                ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,                           FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible);

        _DbgPrintF( DEBUGLVL_BLAB, 
                    ("Post-PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                      PinId,                           FilterNecessary,*FilterNecessary,
                      FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                      GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );
    }
}

/*****************************************************************************
 * CPortWavePci::NewMasterDmaChannel()
 *****************************************************************************
 * Creates a new DMACHANNEL object
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
NewMasterDmaChannel
(
    OUT     PDMACHANNEL *       OutDmaChannel,
    IN      PUNKNOWN            OuterUnknown    OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PRESOURCELIST       ResourceList    OPTIONAL,
    IN      BOOLEAN             ScatterGather,
    IN      BOOLEAN             Dma32BitAddresses,
    IN      BOOLEAN             Dma64BitAddresses,
    IN      BOOLEAN             IgnoreCount,
    IN      DMA_WIDTH           DmaWidth,
    IN      DMA_SPEED           DmaSpeed,
    IN      ULONG               MaximumLength,
    IN      ULONG               DmaPort
)
{
    PAGED_CODE();

    ASSERT(OutDmaChannel);

    DEVICE_DESCRIPTION      DeviceDescription;

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortWavePci::NewMasterDmaChannel"));

    // setup device description
    PcDmaMasterDescription( ResourceList,
                            ScatterGather,
                            Dma32BitAddresses,
                            IgnoreCount,
                            Dma64BitAddresses,
                            DmaWidth,
                            DmaSpeed,
                            MaximumLength,
                            DmaPort,
                            &DeviceDescription );

    // create DMACHANNEL object
    return PcNewDmaChannel( OutDmaChannel,
                            OuterUnknown,
                            PoolType,
                            &DeviceDescription,
                            DeviceObject );
}

#pragma code_seg()

/*****************************************************************************
 * CPortWavePci::Notify()
 *****************************************************************************
 * Receives notification from the adapter ISR.  Note, this routine runs at
 * device IRQL.
 */
STDMETHODIMP_(void)
CPortWavePci::
Notify
(
    IN  PSERVICEGROUP   ServiceGroup
)
{
    ASSERT(ServiceGroup);

    ServiceGroup->RequestService();
}

/*****************************************************************************
 * CPortWavePci::RequestService()
 *****************************************************************************
 * 
 */
STDMETHODIMP_(void)
CPortWavePci::
RequestService
(   void
)
{
    Miniport->Service();
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * PinTypeName
 *****************************************************************************
 * The name of the pin object type.
 */
static const WCHAR PinTypeName[] = KSSTRING_Pin;

/*****************************************************************************
 * CreateTable
 *****************************************************************************
 * Create dispatch table.
 */
static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,PinTypeName,0)
};

/*****************************************************************************
 * CPortWavePci::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a filter object.
 */
STDMETHODIMP_(NTSTATUS)
CPortWavePci::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortWavePci::NewIrpTarget"));

    ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
    ObjectCreate->CreateItemsList   = CreateTable;

    PUNKNOWN filterUnknown;
    NTSTATUS ntStatus =
        CreatePortFilterWavePci
        (
            &filterUnknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PPORTFILTERWAVEPCI filterWavePci;

        ntStatus =
            filterUnknown->QueryInterface
            (
                IID_IIrpTarget,
                (PVOID *) &filterWavePci
            );

        if (NT_SUCCESS(ntStatus))
        {
            // The QI for IIrpTarget actually gets IPortFilterWavePci.
            ntStatus = filterWavePci->Init(this);
            if (NT_SUCCESS(ntStatus))
            {
                *IrpTarget = filterWavePci;
                *ReferenceParent = TRUE;
            }
            else
            {
                filterWavePci->Release();
            }
        }

        filterUnknown->Release();
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CPortWavePci::AddEventToEventList()
 *****************************************************************************
 * Adds an event to the port's event list.
 */
STDMETHODIMP_(void)
CPortWavePci::
AddEventToEventList
(
    IN  PKSEVENT_ENTRY  EventEntry
)
{
    ASSERT(EventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CPortWavePci::AddEventToEventList"));

    KIRQL   oldIrql;

    if( EventEntry )
    {
        // grab the event list spin lock
        KeAcquireSpinLock( &(m_EventList.ListLock), &oldIrql );

        // add the event to the list tail
        InsertTailList( &(m_EventList.List),
                        (PLIST_ENTRY)((PVOID)EventEntry) );

        // release the event list spin lock
        KeReleaseSpinLock( &(m_EventList.ListLock), oldIrql );
    }
}

/*****************************************************************************
 * CPortWavePci::GenerateEventList()
 *****************************************************************************
 * Wraps KsGenerateEventList for miniports.
 */
STDMETHODIMP_(void)
CPortWavePci::
GenerateEventList
(
    IN  GUID*   Set     OPTIONAL,
    IN  ULONG   EventId,
    IN  BOOL    PinEvent,
    IN  ULONG   PinId,
    IN  BOOL    NodeEvent,
    IN  ULONG   NodeId
)
{
    if( KeGetCurrentIrql() > DISPATCH_LEVEL )
    {
        if( !m_EventContext.ContextInUse )
        {
            m_EventContext.ContextInUse = TRUE;
            m_EventContext.Set = Set;
            m_EventContext.EventId = EventId;
            m_EventContext.PinEvent = PinEvent;
            m_EventContext.PinId = PinId;
            m_EventContext.NodeEvent = NodeEvent;
            m_EventContext.NodeId = NodeId;
    
            KeInsertQueueDpc( &m_EventDpc,
                              PVOID(&m_EventList),
                              NULL );
        }
    } else
    {
        PcGenerateEventList( &m_EventList,
                             Set,
                             EventId,
                             PinEvent,
                             PinId,
                             NodeEvent,
                             NodeId );
    }
}

#ifdef DRM_PORTCLS

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
AddContentHandlers(ULONG ContentId,PVOID * paHandlers,ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
CreateContentMixed(PULONG paContentId,ULONG cContentId,PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
DestroyContent(ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
ForwardContentToDeviceObject(ULONG ContentId,PVOID Reserved,PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
ForwardContentToFileObject(ULONG ContentId,PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
ForwardContentToInterface(ULONG ContentId,PUNKNOWN pUnknown,ULONG NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

STDMETHODIMP_(NTSTATUS)
CPortWavePci::
GetContentRights(ULONG ContentId,PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\am824.c ===
#include "Common.h"

#define IEC958_PREAMBLE_CODE_B    0x30000000
#define IEC958_PREAMBLE_CODE_W1   0x20000000
#define IEC958_PREAMBLE_CODE_M    0x10000000
#define IEC958_PREAMBLE_CODE_W    0x00000000

#define IEC958_CHANNEL_STATUS     0x04000000

#define IEC958_BLOCK_SIZE        192

UCHAR                    
EvenParityLookupTable[] = { 
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0 
};

void
AM824IEC958FromPCM( 
    PPIN_CONTEXT pPinContext,
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn,
    ULONG ulNumChannels,
    ULONG ulSampleRate )
{
    ULONG ulNumSamples = (pKsStreamPtrOffsetIn->Remaining>>2) / ulNumChannels;
    ULONG ulPreambleCode;
    ULONG i, j;
	union {
		PUCHAR pData;
		PULONG pulData;
	} u;

    u.pData = pKsStreamPtrOffsetIn->Data;

    for (i=0; i<ulNumSamples; i++) {

        pPinContext->ulSampleCount %= IEC958_BLOCK_SIZE;

        ulPreambleCode = ( pPinContext->ulSampleCount == 0 ) ? IEC958_PREAMBLE_CODE_B :
                                                               IEC958_PREAMBLE_CODE_M ;

        for (j=0; j<ulNumChannels; j++, u.pulData++) {
            ULONG ulDataValue;

            switch ( pPinContext->ulSampleCount ) {
                case 2: // No Copy Protect
                    *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    break;
                case 24: 
                    if ( ulSampleRate == 32000 ) {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    }
                    else {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    }
                    break;
                case 25: 
                    if (( ulSampleRate == 32000 ) || ( ulSampleRate == 48000 ) ){
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    }
                    else {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    }
                    break;
                default:
                    *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    break;
            }

            // parity check
            ulDataValue = (ULONG)((u.pData[0] & 0xF) ^ u.pData[1] ^ u.pData[2] ^ u.pData[3]);
            u.pData[0] |= EvenParityLookupTable[ulDataValue];
//            ulPreambleCode &= IEC958_PREAMBLE_CODE_W1;
            ulPreambleCode = 0;

//            DbgLog("AM824",j,pPinContext->ulSampleCount,*u.pulData, 0);
        }

        pPinContext->ulSampleCount++;
    }
}

#define AM824_RAW_24BIT 0x40
#define AM824_RAW_20BIT 0x41
#define AM824_RAW_16BIT 0x42

void
AM824RawFromPCM( 
    PPIN_CONTEXT pPinContext,
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn,
    ULONG ulNumBits )
{
    ULONG ulNumSamples = (pKsStreamPtrOffsetIn->Remaining>>2);
    ULONG ulHeader = 0;
    PULONG pulData;
    ULONG i;

    pulData = (PULONG)pKsStreamPtrOffsetIn->Data;

    switch (ulNumBits) {
        case 16: ulHeader = AM824_RAW_16BIT; break;
        case 20: ulHeader = AM824_RAW_20BIT; break;
        case 24: ulHeader = AM824_RAW_24BIT; break;

        default:
            break;
    }

    for (i=0; i<ulNumSamples; i++, pulData++) {
        *pulData = bswap((*pulData)>>8) | ulHeader;
    }
}

void
AM824ToPCM( PPIN_CONTEXT pPinContext )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetOut;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulNumWords;
    PULONG pulData;
    ULONG i;
    KIRQL irql;

    DbgLog("824ToPc", pPinContext, 0, 0, 0);

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    while ( !IsListEmpty(&pPinContext->CompletedRequestList ) ) {
        pAVListEntry = 
            (PAV_CLIENT_REQUEST_LIST_ENTRY)RemoveHeadList(&pPinContext->CompletedRequestList);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        pKsStreamPtr = pAVListEntry->pKsStreamPtr;
        pKsStreamPtrOffsetOut = pKsStreamPtr->Offset;
        ulNumWords = pKsStreamPtrOffsetOut->Remaining>>2;
        pulData    = (PULONG)pKsStreamPtrOffsetOut->Data;

        DbgLog("824ToP1", pKsStreamPtr, ulNumWords, pulData, 0);

        for (i=0; i<ulNumWords; i++, pulData++) {
            *pulData = (bswap(*pulData))<<8;
        }

        KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                0,
                                                pKsStreamPtrOffsetOut->Count,
                                                TRUE );

        // Need to free the Clone
        KsStreamPointerDelete(pKsStreamPtr);

        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    }

    pPinContext->fWorkItemInProgress = FALSE;
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

}

ULONG ulMaxSecondCount = 0;

ULONG
AM824FrameCallback( 
    IN PCIP_NOTIFY_INFO pNotifyInfo )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry = 
        (PAV_CLIENT_REQUEST_LIST_ENTRY)pNotifyInfo->Context;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;
    KIRQL irql;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

    // Get the cycle time and data offset from the returned CIP Frame. Use them
    // later to calculate current position information.
    pPinContext->KsAudioPosition.PlayOffset += pPinContext->ulLastBufferSize;

    pPinContext->ulLastBufferSize = pAVListEntry->pKsStreamPtr->Offset->Count;

    pPinContext->InitialCycleTime = pAVListEntry->Av61883Request.AttachFrame.Frame->Timestamp;

    DbgLog("824CbCT", pPinContext->InitialCycleTime.CL_SecondCount, 
                      pPinContext->InitialCycleTime.CL_CycleCount, 
                      pPinContext->InitialCycleTime.CL_CycleOffset, 
                      0 );

    if ( pPinContext->InitialCycleTime.CL_SecondCount > ulMaxSecondCount )
        ulMaxSecondCount = pPinContext->InitialCycleTime.CL_SecondCount;

    if ( !pPinContext->fStreamStarted ) {
        pPinContext->fStreamStarted = TRUE;
    }

    RemoveEntryList(&pAVListEntry->List);
    if (((++pPinContext->ulUsedBuffers) + pPinContext->ulCancelledBuffers) == pPinContext->ulAttachCount) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("*******STARVED!!!!!*******\n"));    
        pPinContext->fStreamStarted = FALSE;
        pPinContext->KsAudioPosition.PlayOffset += pPinContext->ulLastBufferSize;
        DbgLog("824CBkS", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
    
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    DbgLog("824FCBk", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);

    if ( pAVListEntry->pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        
        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );
        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }
    else {
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( !pPinContext->fWorkItemInProgress ) {
            pPinContext->fWorkItemInProgress = TRUE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            InsertTailList(&pPinContext->CompletedRequestList, &pAVListEntry->List);

            // Initialize worker for data reformat
            ExInitializeWorkItem( &pPinContext->PinWorkItem,
                                  AM824ToPCM,
                                  pPinContext );
            ExQueueWorkItem( &pPinContext->PinWorkItem, CriticalWorkQueue );
        }
        else {
            InsertTailList(&pPinContext->CompletedRequestList, &pAVListEntry->List);

            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
    }

	return 0;
}

NTSTATUS
AM824AttachCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;

    if ( !NT_SUCCESS(pIrp->IoStatus.Status) ) {

        // Add wasted data offset to position
        pPinContext->KsAudioPosition.PlayOffset += pAVListEntry->pKsStreamPtr->Offset->Count;

        // Set error status code in stream pointer.
        KsStreamPointerSetStatusCode (pAVListEntry->pKsStreamPtr, pIrp->IoStatus.Status);

        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );

        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }

    // Free the Irp used to attach the buffer.
    IoFreeIrp(pIrp);
    
	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AM824CreateCipRequest( 
    PKSPIN pKsPin,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn = pKsStreamPtr->Offset;
    PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pKsPin->ConnectionFormat+1);
    ULONG ulNumChannels = pWavFormatPCMEx->Format.nChannels;
    ULONG ulSampleRate  = pWavFormatPCMEx->Format.nSamplesPerSec;
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PCIP_ATTACH_FRAME pCipAttachFrame;
    PCIP_FRAME pCipFrame;
    PIO_STACK_LOCATION pNextIrpStack;
    PIRP pIrp;

    // Get a request entry from our lookaside
    pAVListEntry = (PAV_CLIENT_REQUEST_LIST_ENTRY)
        ExAllocateFromNPagedLookasideList(&pPinContext->CipRequestLookasideList);
    if ( NULL == pAVListEntry ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVListEntry, sizeof(AV_CLIENT_REQUEST_LIST_ENTRY) + sizeof(CIP_FRAME));

    pAVListEntry->pKsPin       = pKsPin;
    pAVListEntry->pKsStreamPtr = pKsStreamPtr;
    
    pCipFrame = (PCIP_FRAME)(pAVListEntry + 1);
    pCipAttachFrame = &pAVListEntry->Av61883Request.AttachFrame;

    INIT_61883_HEADER(&pAVListEntry->Av61883Request, Av61883_AttachFrame);
    pCipAttachFrame->hConnect     = pPinContext->hConnection;
    pCipAttachFrame->SourceLength = ulNumChannels*sizeof(ULONG); // Block Size
    pCipAttachFrame->FrameLength  = pKsStreamPtrOffsetIn->Count;
    pCipAttachFrame->Frame        = pCipFrame;

    pCipFrame->Flags         = CIP_AUDIO_STYLE_SYT;
    pCipFrame->Packet        = pKsStreamPtrOffsetIn->Data;
    pCipFrame->pfnNotify     = AM824FrameCallback;
    pCipFrame->NotifyContext = pAVListEntry;

    // Assume that the data format gives us data for each channel in 32 bits 
    // per channel format regardless of the data bit width. This can be 
    // enforced with the proper data intersection code.

    // If Rendering reformat data before attaching
    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        // ISSUE-2001/01/10-dsisolak Assuming IEC958 for now. 
        switch (pPinContext->pFwAudioDataRange->ulTransportType) {
            case MLAN_AM824_IEC958:
                DbgLog("AMtoIEC", pPinContext, pKsStreamPtrOffsetIn, 0, 0);
                ASSERT( ulSampleRate <= 48000 );
                AM824IEC958FromPCM( pPinContext, 
                                    pKsStreamPtrOffsetIn, 
                                    ulNumChannels,
                                    ulSampleRate );
                break;

            case MLAN_AM824_RAW:
                AM824RawFromPCM( pPinContext, pKsStreamPtrOffsetIn, 
                                 pWavFormatPCMEx->Samples.wValidBitsPerSample );
                break;

            case MLAN_24BIT_PACKED:
                TRAP;
                break;
        }
    }

    // Prepare an IRP to make this request
    pIrp = IoAllocateIrp(pPinContext->pPhysicalDeviceObject->StackSize, FALSE);
    if (NULL == pIrp) return STATUS_INSUFFICIENT_RESOURCES;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    pNextIrpStack->Parameters.Others.Argument1 = &pAVListEntry->Av61883Request;

    IoSetCompletionRoutine( pIrp, AM824AttachCallback,((PVOID)pAVListEntry), 
                            TRUE, TRUE, TRUE );

    ExInterlockedInsertHeadList( &pPinContext->OutstandingRequestList, 
                                 &pAVListEntry->List,
                                 &pPinContext->PinSpinLock );

    InterlockedIncrement( &pPinContext->ulAttachCount );

    return IoCallDriver( pPinContext->pPhysicalDeviceObject, pIrp );

}

NTSTATUS
AM824ProcessData( PKSPIN pKsPin )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
	PKSDEVICE pKsDevice = (PKSDEVICE)pKsFilter->Context;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    NTSTATUS ntStatus;

    if ( pPinContext->pCmpRegister ) {
        if ( !pPinContext->pCmpRegister->AvPcr.oPCR.PPCCounter ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ERROR: LostConnection %x\n", 
                                         pPinContext->pCmpRegister->AvPcr.ulongData));
            return STATUS_DEVICE_NOT_READY;
        }
    }

    // Get the next stream pointer from the queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );

    if ( pKsStreamPtr ) {

        if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
            // Need to change data formats if possible???.
            KsStreamPointerSetStatusCode (pKsStreamPtr, STATUS_NOT_SUPPORTED);
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );

            return STATUS_SUCCESS;
        }
        else if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM ) {
            if ( !pKsStreamPtr->Offset->Data ) {
                KsStreamPointerUnlock( pKsStreamPtr, TRUE );
                return STATUS_SUCCESS;
            }
        }

        // Update the Write Offset.
        pPinContext->KsAudioPosition.WriteOffset += pKsStreamPtr->Offset->Count;

        // Clone Stream pointer to keep queue moving.
        ntStatus = KsStreamPointerClone( pKsStreamPtr, 
		                                 NULL, 0, 
			    						 &pKsCloneStreamPtr ); 
	    if ( NT_SUCCESS(ntStatus) ) {

            ntStatus = AM824CreateCipRequest( pKsPin, pKsCloneStreamPtr );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("ERROR: AM824CreateCipRequest falied: %x", ntStatus ));
            }

            if ( !pPinContext->fIsTalking ) {
                if ((pKsPin->DataFlow == KSPIN_DATAFLOW_IN) && NT_SUCCESS(ntStatus)) {

                    _DbgPrintF(DEBUGLVL_VERBOSE, ("Start Talking...\n"));
                    ntStatus = 
                        Av61883StartTalkingOrListening( pKsDevice,
                                                        pPinContext->hConnection,
                                                        Av61883_Talk );
                    if (NT_SUCCESS(ntStatus)) {
                        pPinContext->fIsTalking = TRUE;
                    }
                }
            }

            // Unlock the stream pointer. This will really only unlock after last clone is deleted.
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );

        }

        if ( ntStatus == STATUS_PENDING ) ntStatus = STATUS_SUCCESS;
    }
    else {
        TRAP;
        return STATUS_DEVICE_DATA_ERROR;
    }

    return ntStatus;

}

NTSTATUS
AM824CancelCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;
    KIRQL irql;

    if ( NT_SUCCESS(pIrp->IoStatus.Status) ) {

        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if (((++pPinContext->ulCancelledBuffers) + pPinContext->ulUsedBuffers ) == pPinContext->ulAttachCount) {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("*******Cancel STARVED!!!!!*******\n"));    
            KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
        }
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        DbgLog("824CCBk", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);


        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }

    // Free the Irp used to cancel the buffer.
    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AM824CancelRequest( 
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = pAVListEntry->pKsPin->Context;
    PCIP_CANCEL_FRAME pCipCancelFrame = &pAVListEntry->Av61883Request.CancelFrame;
    PCIP_FRAME pCipFrame = pAVListEntry->Av61883Request.AttachFrame.Frame;
    PIO_STACK_LOCATION pNextIrpStack;
    PIRP pIrp;

    INIT_61883_HEADER(&pAVListEntry->Av61883Request, Av61883_CancelFrame);
    pCipCancelFrame->hConnect = pPinContext->hConnection;
    pCipCancelFrame->Frame    = pCipFrame;

    pIrp = IoAllocateIrp(pPinContext->pPhysicalDeviceObject->StackSize, FALSE);
    if (NULL == pIrp) return STATUS_INSUFFICIENT_RESOURCES;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    pNextIrpStack->Parameters.Others.Argument1 = &pAVListEntry->Av61883Request;

    IoSetCompletionRoutine( pIrp, AM824CancelCallback,((PVOID)pAVListEntry), 
                            TRUE, TRUE, TRUE );

    return IoCallDriver( pPinContext->pPhysicalDeviceObject, pIrp );
}

NTSTATUS
AM824AudioPosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition )
{
    PWAVEFORMATEX pWavFmtEx = (PWAVEFORMATEX)(pKsPin->ConnectionFormat + 1);
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONGLONG ulAvgBytesPerSec = pWavFmtEx->nAvgBytesPerSec;
    ULONGLONG ullPlayOffset;
    CYCLE_TIME InitCycleTime, CycleTime;
    NTSTATUS ntStatus;
    ULONGLONG ulSeconds;
    ULONGLONG ulCycles;
    KIRQL kIrql;

    // Get the cycle time of last completed data request.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    InitCycleTime = pPinContext->InitialCycleTime;
    ullPlayOffset = pPinContext->KsAudioPosition.PlayOffset;
    KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

    // Get the current cycle time.
    ntStatus = Bus1394GetCycleTime( pPinContext->pPhysicalDeviceObject, &CycleTime );

    // Calculate the difference in time from the start time to current and
    // translate that into cycles.

    if ( NT_SUCCESS(ntStatus) ) {
        DbgLog("AM824P1", InitCycleTime.CL_SecondCount, 
                          InitCycleTime.CL_CycleCount,
                          CycleTime.CL_SecondCount,
                          CycleTime.CL_CycleCount );

        CycleTime.CL_SecondCount &= 0x7;

        if ( Bus1394CycleTimeCompare( InitCycleTime, CycleTime ) < 1 ) {
            CYCLE_TIME TmpCycleTime1 = { 0, 8000, 7 };

            // We crossed 0, counter rolled over.
            TmpCycleTime1 = Bus1394CycleTimeDiff( TmpCycleTime1, InitCycleTime );

            ulSeconds = (ULONGLONG)(TmpCycleTime1.CL_SecondCount + CycleTime.CL_SecondCount);
            ulCycles =  (ULONGLONG)(TmpCycleTime1.CL_CycleCount  + CycleTime.CL_CycleCount);

        }
        else {
            CycleTime = Bus1394CycleTimeDiff( CycleTime, InitCycleTime );

            ulSeconds = (ULONGLONG)CycleTime.CL_SecondCount;
            ulCycles  = (ULONGLONG)CycleTime.CL_CycleCount;

        }

//        if ( ulSeconds ) TRAP;

        if ( ulSeconds >= 6 ) { 
            // if the time has elapsed this much assume an error and use the current play offset
            ulSeconds = ulCycles = 0;
        }

        // Calculate the amount of data sent per cycle on average.and multiply by number
        // of cycles elapsed since start.
        pPosition->PlayOffset = ullPlayOffset +
                                ulSeconds * ulAvgBytesPerSec + 
                               ((ulCycles * ulAvgBytesPerSec) / 8000 );

        DbgLog("AM824P2", ulSeconds, ulCycles, pPosition->WriteOffset, pPosition->PlayOffset);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\audio.c ===
#include "Common.h"

// #include "InfoBlk.h"

NTSTATUS
AudioPinCreate(
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt  = pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PFW_PIN_DESCRIPTOR pPinDescriptors;
    PAUDIO_CONFIGURATION pAudioConfig;
    PFUNCTION_BLOCK pFunctionBlocks;
    NTSTATUS ntStatus;
    ULONG ulTermFbNum[32];
    ULONG ulTermFBCnt = 0;
    ULONG ulNumPins;
    ULONG ulSrcCnt = 0; 
    ULONG i, j, k;

    // If the Audio subunit swallows a stream fix up pins and descriptors such that
    // it is represented in a way the topology parser can understand.
    // For each function block make sure there is a destination and source for it. 
    // If there is not then the audio subunit swallowed it and we have to make one.
    pAudioConfig = pAudioSubunitInfo->pAudioConfigurations;
    pFunctionBlocks = pAudioConfig->pFunctionBlocks;

    for ( i=0; i<pAudioConfig->ulNumberOfFunctionBlocks; i++ ) {
        BOOLEAN fDestFound = FALSE;
        _DbgPrintF( DEBUGLVL_VERBOSE, ("pFunctionBlocks[i].ulBlockId: %x\n",pFunctionBlocks[i].ulBlockId));

        // First check if there is another Function block connected.
        for ( j=0; j<pAudioConfig->ulNumberOfFunctionBlocks; j++) {
            if ( i != j ) {
                for (k=0; k<pFunctionBlocks[j].ulNumInputPlugs; k++) {
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("pSourceId 1: %x\n",
                             (ULONG)*((PUSHORT)&pFunctionBlocks[j].pSourceId[k])));
                    if ( pFunctionBlocks[i].ulBlockId == (ULONG)*((PUSHORT)(&pFunctionBlocks[j].pSourceId[k])) ) {
                        fDestFound = TRUE;
                    }
                }
            }
        }

        // If the destination of the data from FB i is not another FB, check source plugs
        for ( j=0; j<pAudioConfig->ulNumberOfSourcePlugs; j++ ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("pSourceId 2: %x\n",
                             (ULONG)*((PUSHORT)&pAudioConfig->pSourceId[j])));
            if ( pFunctionBlocks[i].ulBlockId == (ULONG)*((PUSHORT)&pAudioConfig->pSourceId[j]) ) {
                fDestFound = TRUE;
            }
        }

        // If still not found, need to fix up the plug counts and structures to
        // reflect a permenent connection to an external plug.
        if ( !fDestFound )
            ulTermFbNum[ulTermFBCnt++] = i;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Number of swallowed streams: ulTermFBCnt: %d\n",ulTermFBCnt));

    // Get the number of pins as the AV/C class driver sees it.
    ntStatus = AvcGetPinCount( pKsDevice, &ulNumPins );
    _DbgPrintF( DEBUGLVL_VERBOSE, ("AvcGetPinCount: ntStatus: %x ulNumPins: %d\n",ntStatus,ulNumPins));
    if ( NT_SUCCESS(ntStatus) && (0 != ulNumPins)) {
        pAudioSubunitInfo->ulDevicePinCount = ulNumPins + ulTermFBCnt;
        pPinDescriptors = AllocMem( PagedPool, 
                                  (ulNumPins+ulTermFBCnt) * sizeof(FW_PIN_DESCRIPTOR));
        if ( pPinDescriptors ) {
            pAudioSubunitInfo->pPinDescriptors = pPinDescriptors;
            KsAddItemToObjectBag(pKsDevice->Bag, pPinDescriptors, FreeMem);

            // Get info from AVC.sys for real pins
            for (i=0; ((i<ulNumPins) && NT_SUCCESS(ntStatus)); i++) {
                pPinDescriptors[i].ulPinId   = i;
                pPinDescriptors[i].fFakePin  = FALSE;
                pPinDescriptors[i].bmFormats = 0;
                pPinDescriptors[i].bmTransports = 0;
                pPinDescriptors[i].fStreamingPin = FALSE;
                ntStatus = AvcGetPinDescriptor( pKsDevice, i, 
                                                &pPinDescriptors[i].AvcPinDescriptor );
                if ( NT_SUCCESS(ntStatus) ) {
                    ntStatus = AvcGetPinConnectInfo( pKsDevice, i,
                                                     &pPinDescriptors[i].AvcPreconnectInfo );
                    if ( NT_SUCCESS(ntStatus) ) {
                        PAVCPRECONNECTINFO pAvcPreconnectInfo = &pPinDescriptors[i].AvcPreconnectInfo.ConnectInfo;
                        ULONG ulPlugNum = pAvcPreconnectInfo->SubunitPlugNumber;
                        pPinDescriptors[i].SourceId = pAudioConfig->pSourceId[ulPlugNum];
                        if ( pAvcPreconnectInfo->DataFlow == KSPIN_DATAFLOW_OUT ) ulSrcCnt++;
                        _DbgPrintF( DEBUGLVL_VERBOSE, ("[AudioPinCreate]ulSrcCnt: %d\n",ulSrcCnt));
                    }
                }
            }

            // Make up info for Fake pins
            if ( NT_SUCCESS(ntStatus) ) {
                for ( ; i<(ulNumPins+ulTermFBCnt); i++ ) {
                    pPinDescriptors[i].ulPinId  = i;
                    pPinDescriptors[i].fFakePin = TRUE;
                    pPinDescriptors[i].bmFormats = 0;
                    pPinDescriptors[i].bmTransports = 0;
                    pPinDescriptors[i].fStreamingPin = FALSE;
                    pPinDescriptors[i].SourceId = 
                        *(PSOURCE_ID)&pFunctionBlocks[ulTermFbNum[i-ulNumPins]].ulBlockId;
                    pPinDescriptors[i].AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber = ulSrcCnt++;
                    pPinDescriptors[i].AvcPreconnectInfo.ConnectInfo.Flags = KSPIN_FLAG_AVC_PERMANENT;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AudioPinCreate]ulSrcCnt: %d (Fake)\n",ulSrcCnt));
                }
            }
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
#if DBG
    else {
        TRAP;
    }
#endif
    // Now that we have all of our pins determine which ones are streaming and if 
    // they are streaming, what data format they will accept (if possible).
    for (i=0; i<pAudioSubunitInfo->ulDevicePinCount; i++) {
        PAVCPRECONNECTINFO pPreConnInfo = &pPinDescriptors[i].AvcPreconnectInfo.ConnectInfo;
        _DbgPrintF( DEBUGLVL_VERBOSE,("pPinDescriptors[%d]: %x\n",i,&pPinDescriptors[i]));
        if ( pPreConnInfo->Flags & (KSPIN_FLAG_AVC_FIXEDPCR | KSPIN_FLAG_AVC_PCRONLY) ) {
            pPinDescriptors[i].fStreamingPin = TRUE;
        }
        else if ( pPreConnInfo->Flags & KSPIN_FLAG_AVC_PERMANENT ) {
            pPinDescriptors[i].fStreamingPin = FALSE;
        }
        else {
            // Unconnected Subunit Pin. 
            // First determine what connections can be made for each subunit plug, then try to
            // determine what formats the plug will accept.
            if ( KSPIN_DATAFLOW_IN == pPreConnInfo->DataFlow ) {
                // If there is a Input serial bus plug assume the subunit can be streamed to.
                if (pUnitInfo->CmpUnitCaps.NumInputPlugs)
                    pPinDescriptors[i].fStreamingPin = TRUE;
            }
            else if ( KSPIN_DATAFLOW_OUT == pPreConnInfo->DataFlow ) {
                // If there is a Output serial bus plug assume the subunit can stream to it.
                if (pUnitInfo->CmpUnitCaps.NumOutputPlugs)
                    pPinDescriptors[i].fStreamingPin = TRUE;
            }
        }
        
        if ( pPinDescriptors[i].fStreamingPin ) {
            ULONG ulCapIndx = (KSPIN_DATAFLOW_IN == pPreConnInfo->DataFlow) ?
                              AVC_CAP_INPUT_PLUG_FMT : AVC_CAP_OUTPUT_PLUG_FMT;
            ULONG ulSerialPlugCnt = (KSPIN_DATAFLOW_IN == pPreConnInfo->DataFlow) ?
                              pUnitInfo->CmpUnitCaps.NumInputPlugs :
                              pUnitInfo->CmpUnitCaps.NumOutputPlugs ;
            for (j=0; j<ulSerialPlugCnt; j++) {
                UCHAR ucFDF;
                UCHAR ucFMT;

                if ( pUnitInfo->fAvcCapabilities[ulCapIndx].fCommand ) {
                    // Note: The FDFs being checked are all AM824
                    // If the device supports it try to find out what formats can be 
                    // set on the plug.
                    ucFMT = FMT_AUDIO_MUSIC;
                    for (k=0; k<MAX_SFC_COUNT; k++) {
                        ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                                        pPreConnInfo->DataFlow, 
                                                        j,
                                                        AVC_CTYPE_SPEC_INQ,
                                                        &ucFMT,
                                                        &ucFDFs[k] );
                        if ( NT_SUCCESS(ntStatus) ) {
                            _DbgPrintF( DEBUGLVL_TERSE, ("Settable FS: %x\n",ucFDFs[k]));
                            pPinDescriptors[i].bmFormats |= 1<<ucFDFs[k];
                        }
                        else {
                            _DbgPrintF( DEBUGLVL_TERSE, ("Cannot set FS: %x\n",ucFDFs[k]));
                        }
                    }

                    if ( !pPinDescriptors[i].bmFormats ) {
                        // Someone lied to us. Reset the flag.
                        pUnitInfo->fAvcCapabilities[ulCapIndx].fCommand = FALSE;
                    }
                }
            
                if ( pUnitInfo->fAvcCapabilities[ulCapIndx].fStatus ) {
                    // Get the current format and assume it is what is always used 
                    // until some better method comes along

                    ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                                    pPreConnInfo->DataFlow, 
                                                    j,
                                                    AVC_CTYPE_STATUS,
                                                    &ucFMT,
                                                    &ucFDF );

                    if ( NT_SUCCESS(ntStatus) ) { 
                        ASSERT(ucFMT == FMT_AUDIO_MUSIC);
                        pPinDescriptors[i].bmFormats    |= 1<<(ucFDF & 0x0f);
                        pPinDescriptors[i].bmTransports |= 1<<((ucFDF & 0x0f)>>4);
                    }
                }
                else {
                    // Need to Make assumptions
                    pPinDescriptors[i].bmFormats    |= 1<<SFC_48000Hz;
                    pPinDescriptors[i].bmTransports |= 1<<EVT_AM824;
                }
                _DbgPrintF( DEBUGLVL_TERSE, ("pPinDescriptors[i].bmFormats: %x\n",
                                              pPinDescriptors[i].bmFormats));
                _DbgPrintF( DEBUGLVL_TERSE, ("pPinDescriptors[i].bmTransports: %x\n",
                                              pPinDescriptors[i].bmTransports));
            }
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("pPinDescriptors[%d]: %x, Streaming: %x Flags: %x\n",
                                   i,&pPinDescriptors[i], 
                                   pPinDescriptors[i].fStreamingPin,
                                   pPreConnInfo->Flags ));
    }

    return ntStatus;
}

NTSTATUS
AudioFunctionBlockCommand(
    PKSDEVICE pKsDevice,
    UCHAR     ucCtype,
    PVOID     pFBSpecificData,
    ULONG     pFBSpecificDataSize )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    NTSTATUS ntStatus;
    PUCHAR pOperands;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // Set up command in AvcIrb.
    pAvcIrb->CommandType   = ucCtype;
    pAvcIrb->Opcode        = AVC_AUDIO_FB_COMMAND;
    pAvcIrb->OperandLength = pFBSpecificDataSize;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AudioFunctionBlockCommand] ucCtype: %x\n",ucCtype));

    RtlCopyMemory(&pOperands[0], pFBSpecificData, pFBSpecificDataSize);

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory(pFBSpecificData, &pOperands[0], pFBSpecificDataSize);
    }
#if DBG
    else {
        _DbgPrintF( DEBUGLVL_ERROR, ("[AudioFunctionBlockCommand]Error pAvcIrb: %x\n",pAvcIrb));
    }
#endif

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AudioSet61883IsochParameters(
    IN PKSDEVICE pKsDevice )
{
    UNIT_ISOCH_PARAMS UnitIsochParams;

    UnitIsochParams.RX_NumPackets     = 50;
    UnitIsochParams.RX_NumDescriptors = 3;
    UnitIsochParams.TX_NumPackets     = 50;
    UnitIsochParams.TX_NumDescriptors = 3;

    return Av61883GetSetUnitInfo( pKsDevice,
                                  Av61883_SetUnitInfo,
                                  SET_UNIT_INFO_ISOCH_PARAMS,
                                  &UnitIsochParams );
}

NTSTATUS
AudioSetSampleRateOnPlug(
    PKSPIN pKsPin,
    ULONG ulSampleRate )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;
    BOOLEAN bSettable = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR ucFDF;

    // Determine if the sample rate is settable. If not return success and assume the device
    // will do the sync up with the data.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        bSettable = pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fCommand;
    }
    else {
        bSettable = pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fCommand;
    }

    if ( bSettable ) {
        UCHAR ucFMT = FMT_AUDIO_MUSIC;

        // Figure out the correct FDF value
        switch( ulSampleRate ) {
            case 32000: ucFDF = SFC_32000Hz; break;
            case 44100: ucFDF = SFC_44100Hz; break;
            case 48000: ucFDF = SFC_48000Hz; break;
            case 96000: ucFDF = SFC_96000Hz; break;
        }

        // If this is a grouped device set on all devices

        if ( pGrpInfo ) {
            ULONG i;
            for ( i=0; ((i<pGrpInfo->ulDeviceCount) && NT_SUCCESS(ntStatus)); i++) {
                ntStatus = 
                    AvcPlugSignalFormat( pGrpInfo->pHwDevExts[i]->pKsDevice,
                                         pKsPin->DataFlow,
                                         pPinContext->pPinGroupInfo[i].ulPlugNumber,
                                         AVC_CTYPE_CONTROL,
                                         &ucFMT,
                                         &ucFDF );
            }
        }
        else {
            ntStatus = 
                AvcPlugSignalFormat( pHwDevExt->pKsDevice,
                                     pKsPin->DataFlow,
                                     pPinContext->ulSerialPlugNumber,
                                     AVC_CTYPE_CONTROL,
                                     &ucFMT,
                                     &ucFDF );
            
        }
    }

    return ntStatus;
}


NTSTATUS
AvcSubunitInitialize(
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo;
    AVC_BOOLEAN bPowerState;
    ULONG ulPlugNumber;
    ULONG ulSubunitId;
    NTSTATUS ntStatus;
    ULONG i, j;

    // Allocate space for the Audio Subunit info 
    pAudioSubunitInfo = AllocMem( NonPagedPool, sizeof(AUDIO_SUBUNIT_INFORMATION) );
    if ( !pAudioSubunitInfo ) return STATUS_INSUFFICIENT_RESOURCES;

    pHwDevExt->pAvcSubunitInformation = pAudioSubunitInfo;

    RtlZeroMemory( pAudioSubunitInfo, sizeof(AUDIO_SUBUNIT_INFORMATION) );

    KsAddItemToObjectBag(pKsDevice->Bag, pAudioSubunitInfo, FreeMem);

    // Determine if PLUG INFO is available on the Subunit
    ntStatus = AvcGetPlugInfo( pKsDevice, FALSE, (PUCHAR)&pAudioSubunitInfo->PlugInfo);
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_PLUG_INFO].fStatus = TRUE;
    }
//    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
//        return ntStatus;
//    }

    // Determine if Subunit POWER Status and possibly control available.
    ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_STATUS, &bPowerState );
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus = TRUE;
//        ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_CONTROL, &bPowerState );
        ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_POWER );
        if ( NT_SUCCESS(ntStatus) ) {
            pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand = TRUE;
        }
    }
//    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
//        return ntStatus;
//    }

    // Determine if Audio Subunit has been implemented. (If so, save descriptor)
    ntStatus = AvcGetSubunitIdentifierDesc( pKsDevice, (PUCHAR *)&pAudioSubunitInfo->pSubunitIdDesc );
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_SUBUNIT_IDENTIFIER_DESC].fStatus = TRUE;
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        // Currently we require the Subunit Id Descriptor
        return ntStatus;
    }

#ifdef TOPO_FAKE
    // If the Audio Subunit doesn't exist, make one up.
    if (!(pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_SUBUNIT_IDENTIFIER_DESC].fStatus)) {
        ntStatus = BuildFakeSubunitDescriptor( pKsDevice );
        if ( !NT_SUCCESS(ntStatus) ) {
            // Didn't find a descriptor and couldn't fake one. Give up.
            return ntStatus;
        }
    }
#endif

    // Parse Audio Subunit Descriptor (real or fake)
    ntStatus = ParseAudioSubunitDescriptor( pKsDevice );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = AudioPinCreate( pKsDevice );
        if ( !NT_SUCCESS(ntStatus) ) {
            return ntStatus;
        }
    }

    // Get the subunit Id from the first plug/pin. All should be the same.
    // ISSUE-2001/01/10-dsisolak Could be an extended Id
    ulSubunitId = (pAudioSubunitInfo->pPinDescriptors[0].AvcPreconnectInfo.ConnectInfo.SubunitAddress[0])&0x7; 
    // Determine if this device is CCM controled (for each destination plug)
    for ( i=0,ulPlugNumber = 0; i<pAudioSubunitInfo->ulDevicePinCount; i++ ) {
        PFW_PIN_DESCRIPTOR pPinDesc = &pAudioSubunitInfo->pPinDescriptors[i];
        if ( pPinDesc->fStreamingPin &&
           ( KSPIN_DATAFLOW_IN == pPinDesc->AvcPinDescriptor.PinDescriptor.DataFlow )) {
           ULONG ulSubunitPlugNumber = (ULONG)pPinDesc->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;

            ntStatus = CCMCheckSupport( pKsDevice, 
                                        ulSubunitId, 
                                        ulSubunitPlugNumber );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand = TRUE;
                pUnitInfo->fAvcCapabilities[AVC_CAP_CCM].fStatus  = TRUE;
                pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand = TRUE;
                pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fStatus  = TRUE;
            }
            else if (STATUS_NOT_IMPLEMENTED == ntStatus) {
                ntStatus = STATUS_SUCCESS;
            }
        }
    }

    
    ntStatus = AudioSet61883IsochParameters( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF( DEBUGLVL_ERROR, ("Cannot SetIsoch Parameters: %x\n",ntStatus));
    }

    // If the device is powered off, turn it on.
    if ( pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand ) {
        ASSERT(pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus);
        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) && ( bPowerState == AVC_OFF )) {
            bPowerState = AVC_ON;
            ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_CONTROL, &bPowerState );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("Cannot Turn On Power: %x\n",ntStatus));
            }
        }
        if ( NT_SUCCESS(ntStatus) ) 
            pUnitInfo->bPowerState = bPowerState;
        else
            pUnitInfo->bPowerState = AVC_ON; // ASSUME that no idiot made a device you can't turn on.
    }

    // Need to power up subunit???
    if ( pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand ) {
        ASSERT(pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus);
        ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) && ( bPowerState == AVC_OFF )) {
            bPowerState = AVC_ON;
            ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_CONTROL, &bPowerState );
#if DBG            
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("Cannot Turn On Power: %x\n",ntStatus));
            }
#endif
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\audio.h ===
#ifndef ___FWAUDIO_AUDIO_H___
#define ___FWAUDIO_AUDIO_H___

// FDF identifier
#define FMT_AUDIO_MUSIC 0x10

// 15 predefined and Master channel
#define MAX_DEFINED_CHANNELS 16 

// Values for the EVT field of the CIP FDF
#define EVT_AM824       0
#define EVT_24x4PACK    1
#define EVT_32BIT_FLOAT 2
#define EVT_32or64BIT   3

// Values for the SFC field of the CIP FDF
#define SFC_32000Hz     0
#define SFC_44100Hz     1
#define SFC_48000Hz     2
#define SFC_96000Hz     4

#define MAX_SFC_COUNT   4

extern UCHAR ucFDFs[MAX_SFC_COUNT];

// Values for th FN field of the CIP (Fraction Number)
#define FN_NOT_DIVIDED  0
#define FN_DIVIDED_BY_2 1
#define FN_DIVIDED_BY_4 2
#define FN_DIVIDED_BY_8 3

// Chanel Cluster Flags
#define CHANNEL_CLUSTER_SAME_AS_MASTER        0
#define CHANNEL_CLUSTER_SAME_AS_UPSTREAM      1
#define CHANNEL_CLUSTER_GENERIC_MULTISPEAKER  2

// Function Block Types
// Function Block Types
enum {
    FB_SELECTOR = 0x80,
    FB_FEATURE,
    FB_PROCESSING,
    FB_CODEC
} FUNCTION_BLOCK_TYPE;

#define MAX_FUNCTION_BLOCK_TYPES 4

// Function Block Avc Command
#define AVC_AUDIO_FB_COMMAND 0xB8

// Subunit Plug types
#define SUBUNIT_DESTINATION_PLUG_TYPE   0xF0
#define SUBUNIT_SOURCE_PLUG_TYPE        0xF1

#define MAX_FUNCTION_BLOCK_TYPES 4

// Function Block Control Attributes
#define FB_CTRL_ATTRIB_RESOLUTION  0x01
#define FB_CTRL_ATTRIB_MINIMUM     0x02
#define FB_CTRL_ATTRIB_MAXIMUM     0x03
#define FB_CTRL_ATTRIB_DEFAULT     0x04
#define FB_CTRL_ATTRIB_DURATION    0x08
#define FB_CTRL_ATTRIB_CURRENT     0x10
#define FB_CTRL_ATTRIB_MOVE        0x18
#define FB_CTRL_ATTRIB_DELTA       0x19

// Function Block Control Command Types
#define FB_CTRL_TYPE_CONTROL       AVC_CTYPE_CONTROL<<8
#define FB_CTRL_TYPE_STATUS        AVC_CTYPE_STATUS<<8
#define FB_CTRL_TYPE_NOTIFY        AVC_CTYPE_NOTIFY<<8
#define FB_CTRL_TYPE_MASK          0xFF00

// Terminal type masks
#define STREAMING_TERMINAL  0x0101
#define INPUT_MASK          0x0200
#define OUTPUT_MASK         0x0300
#define BIDIRECTIONAL_MASK  0x0400
#define TELEPHONY_MASK      0x0500
#define EXTERNAL_MASK       0x0600
#define EMBEDDED_MASK       0x0700

#define DATA_FORMAT_TYPE_MASK        0xF000

// Terminal Data Types
#define AUDIO_DATA_TYPE_TIME_BASED   0x0000
#define AUDIO_DATA_TYPE_PCM          0x0001
#define AUDIO_DATA_TYPE_PCM8         0x0002
#define AUDIO_DATA_TYPE_IEEE_FLOAT   0x0003

#define AUDIO_DATA_TYPE_COMPRESSED   0x1000
#define AUDIO_DATA_TYPE_AC3          0x1001
#define AUDIO_DATA_TYPE_MPEG         0x1002
#define AUDIO_DATA_TYPE_DTS          0x1003

// MLan Data Transport Types
#define MLAN_AM824_IEC958 0
#define MLAN_AM824_RAW    1
#define MLAN_24BIT_PACKED 2

// Map KSNODE_TYPE GUIDs to Indexes
#define NODE_TYPE_NONE          0
#define NODE_TYPE_DAC           1
#define NODE_TYPE_ADC           2
#define NODE_TYPE_SRC           3
#define NODE_TYPE_SUPERMIX      4
#define NODE_TYPE_MUX           5
#define NODE_TYPE_SUM           6
#define NODE_TYPE_MUTE          7
#define NODE_TYPE_VOLUME        8
#define NODE_TYPE_BASS          9
#define NODE_TYPE_MID           10
#define NODE_TYPE_TREBLE        11
#define NODE_TYPE_BASS_BOOST    12
#define NODE_TYPE_EQUALIZER     13
#define NODE_TYPE_AGC           14
#define NODE_TYPE_DELAY         15
#define NODE_TYPE_LOUDNESS      16
#define NODE_TYPE_PROLOGIC      17
#define NODE_TYPE_STEREO_WIDE   18
#define NODE_TYPE_REVERB        19
#define NODE_TYPE_CHORUS        20
#define NODE_TYPE_DEV_SPEC      21
#define NODE_TYPE_TONE          22


#define MapFuncsToNodeTypes( a ) \
{\
    a[KSPROPERTY_AUDIO_LATENCY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_COPY_PROTECTION]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CHANNEL_CONFIG]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_VOLUMELEVEL]           = NODE_TYPE_VOLUME; \
    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_QUALITY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_TABLE]       = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_CAPS]        = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MUX_SOURCE]            = NODE_TYPE_MUX; \
    a[KSPROPERTY_AUDIO_MUTE]                  = NODE_TYPE_MUTE; \
    a[KSPROPERTY_AUDIO_BASS]                  = NODE_TYPE_BASS; \
    a[KSPROPERTY_AUDIO_MID]                   = NODE_TYPE_MID; \
    a[KSPROPERTY_AUDIO_TREBLE]                = NODE_TYPE_TREBLE; \
    a[KSPROPERTY_AUDIO_BASS_BOOST]            = NODE_TYPE_BASS_BOOST; \
    a[KSPROPERTY_AUDIO_EQ_LEVEL]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_NUM_EQ_BANDS]          = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_EQ_BANDS]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_AGC]                   = NODE_TYPE_AGC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_LOUDNESS]              = NODE_TYPE_LOUDNESS; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \
}

// Feature Unit Control Selectors
#define MUTE_CONTROL                0x01
#define VOLUME_CONTROL              0x02
#define LR_BALANCE_CONTROL          0x03
#define FR_BALANCE_CONTROL          0x04
#define BASS_CONTROL                0x05
#define MID_CONTROL                 0x06
#define TREBLE_CONTROL              0x07
#define GRAPHIC_EQUALIZER_CONTROL   0x08
#define AUTOMATIC_GAIN_CONTROL      0x09
#define DELAY_CONTROL               0x0A
#define BASS_BOOST_CONTROL          0x0B
#define LOUDNESS_CONTROL            0x0C

// Controls for error checking only
#define DEV_SPECIFIC_CONTROL    0x1001

// Feature Unit Flags
#define MUTE_FLAG               0x8000
#define VOLUME_FLAG             0x4000
#define LR_BALANCE_FLAG         0x2000
#define FR_BALANCE_FLAG         0x1000
#define BASS_FLAG               0x0800
#define MID_FLAG                0x0400
#define TREBLE_FLAG             0x0200
#define GRAPHIC_EQUALIZER_FLAG  0x0100
#define AUTOMATIC_GAIN_FLAG     0x0080
#define DELAY_FLAG              0x0040
#define BASS_BOOST_FLAG         0x0020
#define LOUDNESS_FLAG           0x0010

#define MUTE_CONTROL_FLAG               0x0080
#define VOLUME_CONTROL_FLAG             0x0040
#define LR_BALANCE_CONTROL_FLAG         0x0020
#define FR_BALANCE_CONTROL_FLAG         0x0010
#define BASS_CONTROL_FLAG               0x0008
#define MID_CONTROL_FLAG                0x0004
#define TREBLE_CONTROL_FLAG             0x0002
#define GRAPHIC_EQUALIZER_CONTROL_FLAG  0x0001
#define AUTOMATIC_GAIN_CONTROL_FLAG     0x8000
#define DELAY_CONTROL_FLAG              0x4000
#define BASS_BOOST_CONTROL_FLAG         0x2000
#define LOUDNESS_CONTROL_FLAG           0x1000

// Process Function Block Process types
#define MIXER_PROCESS               0x01
#define GENERIC_PROCESS             0x02
#define UP_DOWN_MIXER               0x03
#define DOLBY_PRO_LOGIC             0x04
#define STEREO_EXTENDER             0x05
#define REVERBERATION               0x06
#define CHORUS                      0x07
#define DYNAMIC_RANGE_COMPRESSION   0x08

// Process Function Block Process Controls
#define ENABLE_CONTROL              0x01
#define MODE_CONTROL                0x02
#define MIXER_CONTROL 				0x03
#define SPACIOUSNESS_CONTROL        0x03
#define REVERBTYPE_CONTROL          0x03
#define REVERBLEVEL_CONTROL         0x04
#define REVERBTIME_CONTROL          0x05
#define REVERBEARLYTIME_CONTROL     0x06
#define REVERBDELAY_CONTROL         0x07
#define CHORUSRATE_CONTROL          0x03
#define CHORUSDEPTH_CONTROL         0x04
#define COMPRESSION_RATIO_CONTROL   0x03
#define MAXAMPL_CONTROL             0x04
#define THRESHOLD_CONTROL           0x05
#define ATTACKTIME_CONTROL          0x06
#define RELEASETIME_CONTROL         0x07
#define GUID_CONTROL                0x03



#define ABSOLUTE_NODE_FLAG  0x80000000L
#define NODE_MASK           0x7fffffffL

#define MAX_APP_FRAMES_PER_ATTACH 80  // 10 ms of data
#define MAX_ATTACHED_FRAMES       8   // total 80 ms submitted

enum {
    CA_RESOLUTION = 1,
    CA_MINIMUM    = 2,
    CA_MAXIMUM    = 3,
    CA_DEFAULT    = 4,
    CA_DURATION = 0x08,
    CA_CURRENT  = 0x10,
    CA_MOVE     = 0x18,
    CA_DELTA    = 0x19
} FB_CONTROL_ATTRIBUTE;

#define GET_NODE_INFO_FROM_FILTER(pKsFilter,ulNodeID) \
        &((PTOPOLOGY_NODE_INFO)(pKsFilter)->Descriptor->NodeDescriptors)[(ulNodeID)]

//#define SA_HACK

#ifdef SA_HACK
#define SA_VENDOR_ID 0x509e
#define SA_MODEL_ID  0x534120
#endif
//================================================================

#pragma pack( push, descriptor_structs, 1)

typedef struct {
	UCHAR Rsvd1;
	UCHAR ucControlSpecInfoSize;
	UCHAR Rsvd2;
    UCHAR ucControlSize;
    UCHAR ucGeneralTag;
    UCHAR bmaControls[];
} FEATURE_FUNCTION_BLOCK, *PFEATURE_FUNCTION_BLOCK;

typedef struct {
    UCHAR ucPlaceholder;
} CODEC_FUNCTION_BLOCK, *PCODEC_FUNCTION_BLOCK;

typedef struct {
    UCHAR ucPlaceholder;
} PROCESS_FUNCTION_BLOCK, *PPROCESS_FUNCTION_BLOCK;

typedef struct {
    union {
        UCHAR ucFunctionBlockType;
        UCHAR ucSubunitPlugType;
    };
    union {
        UCHAR ucFunctionBlockID;
        UCHAR ucSubunitPlugNumber;
    };
} SOURCE_ID, *PSOURCE_ID;

typedef struct {
    USHORT usLength;
    USHORT usInfoFieldsLength;
    UCHAR  ucVersion;
    UCHAR  ucNumberOfConfigurations;
} AUDIO_SUBUNIT_DEPENDENT_INFO, *PAUDIO_SUBUNIT_DEPENDENT_INFO;

typedef struct {
    USHORT usLength;
    USHORT usID;
    USHORT usMasterClusterStructureLength;
    UCHAR  ucNumberOfChannels;
    UCHAR  ucChannelConfigType;
    USHORT usPredefinedChannelConfig;
    USHORT usChannelNameIndex[];
} CONFIGURATION_DEPENDENT_INFO, *PCONFIGURATION_DEPENDENT_INFO;

typedef struct {
    UCHAR ucNumLinks;
    SOURCE_ID pSourceID[];
} SOURCE_PLUG_LINK_INFO, *PSOURCE_PLUG_LINK_INFO;

typedef struct {
    USHORT usLength;
    UCHAR  ucType;
    UCHAR  ucID;
    USHORT usNameIndex;
    UCHAR  ucNumberOfInputPlugs;
} FUNCTION_BLOCK_DEPENDENT_INFO, *PFUNCTION_BLOCK_DEPENDENT_INFO;

typedef struct {
    UCHAR ucNumBlocks;
    FUNCTION_BLOCK_DEPENDENT_INFO FBDepInfo[];
} FUNCTION_BLOCKS_INFO, *PFUNCTION_BLOCKS_INFO;

typedef struct {
    USHORT usLength;
    UCHAR  ucNumberOfChannels;
    UCHAR  ucChannelConfigType;
    USHORT usPredefinedChannelConfig;
    USHORT usNonPredefinedChannelConfig;
} FBLOCK_CHANNEL_CLUSTER, *PFBLOCK_CHANNEL_CLUSTER;

typedef struct {
    UCHAR ucControlAttribute;
    UCHAR ucControlType;
} FBLOCK_REQUEST_TYPE, *PFBLOCK_REQUEST_TYPE;

typedef struct {
    SOURCE_ID FBlockId;
    UCHAR ucControlAttribute;
} FBLOCK_COMMAND_COMMON, *PFBLOCK_COMMAND_COMMON;

typedef struct {
    FBLOCK_COMMAND_COMMON Common;
    UCHAR ucSelectorLength;
    UCHAR ucChannelNumber;
    UCHAR ucControlSelector;
} FEATURE_FBLOCK_COMMAND, *PFEATURE_FBLOCK_COMMAND;


#pragma pack( pop, descriptor_structs )

typedef struct {
    ULONG ulTransportType;
    ULONG ulBitsPerChannel;
    ULONG ulSampleRateType;
    ULONG pSampleRate[MAX_SFC_COUNT];
} PCM_FORMAT, *PPCM_FORMAT;

typedef struct {
    ULONG ulNumberOfChannels;
    ULONG ulPredefinedChannelConfig;
    ULONG ulNonPredefinedChannelConfig;
} CHANNEL_CLUSTER, *PCHANNEL_CLUSTER;

typedef struct {
    PFUNCTION_BLOCK_DEPENDENT_INFO pBase;
    ULONG ulType;
    ULONG ulBlockId;
    ULONG ulNumInputPlugs;
    PSOURCE_ID pSourceId;
    ULONG ulFunctionTypeInfoLength;
    PVOID pFunctionTypeInfo;
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
} FUNCTION_BLOCK, *PFUNCTION_BLOCK;

typedef struct {
    PCONFIGURATION_DEPENDENT_INFO pBase;
    ULONG ulNumberOfSourcePlugs;
    PSOURCE_ID pSourceId;
    ULONG ulNumberOfFunctionBlocks;
    PFUNCTION_BLOCK pFunctionBlocks;
    CHANNEL_CLUSTER ChannelCluster;
} AUDIO_CONFIGURATION, *PAUDIO_CONFIGURATION;

typedef struct {
    ULONG ulTerminalPinType;
    KSPIN_DATAFLOW KsPinDataFlow;
    ULONG ulFormatType;
    ULONG ulFormatCount;
} TERMINAL_PIN_INFO, *PTERMINAL_PIN_INFO;

typedef struct {
    ULONG ulPinId;
    ULONG fStreamingPin;
    ULONG fFakePin;
    ULONG bmFormats;
    ULONG bmTransports;
    SOURCE_ID SourceId;
    AVC_PIN_DESCRIPTOR  AvcPinDescriptor;
    AVC_PRECONNECT_INFO AvcPreconnectInfo;
    AVC_SETCONNECT_INFO AvcSetConnectInfo;
} FW_PIN_DESCRIPTOR, *PFW_PIN_DESCRIPTOR;

// Cached Values for DB Level Controls
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} DB_LEVEL_CACHE, *PDB_LEVEL_CACHE;

// Structure to Cache channel based Boolean control values
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    BOOL fLastValueSet;
} BOOLEAN_CTRL_CACHE, *PBOOLEAN_CTRL_CACHE;

// Cached Values for Processing Unit Node ranges
typedef struct {
    ULONG ulControlBit;
    ULONG ulControlSelector;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} PROCESS_CTRL_RANGE, *PPROCESS_CTRL_RANGE;

// Cached Values for Processing Unit Node controls
typedef struct {
    BOOL fEnableBit;
    BOOL fEnabled;
    ULONG bmControlBitMap;
} PROCESS_CTRL_CACHE, *PPROCESS_CTRL_CACHE;

typedef struct _TOPOLOGY_NODE_INFO
TOPOLOGY_NODE_INFO, *PTOPOLOGY_NODE_INFO;

typedef
NTSTATUS
(*NODE_CACHE_UPDATE_RTN)(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pChanged );

#define MASTER_FIX

// Information about each Topology node
typedef struct _TOPOLOGY_NODE_INFO {
    KSNODE_DESCRIPTOR KsNodeDesc;         // 4  Long Words
    KSAUTOMATION_TABLE KsAutomationTable; // 10 Long Words
    ULONG ulBlockId;
    union {
        PFUNCTION_BLOCK pFunctionBlk;
        ULONG ulPinId;
    };
    ULONG ulNodeType;
    ULONG ulControlType;
    ULONG ulChannelConfig;
    ULONG ulChannels;
    ULONG ulCacheValid;
    ULONG ulNumCachedValues;
    PVOID pCachedValues;

#ifdef MASTER_FIX
    BOOLEAN fMasterChannel;
#endif

    BOOLEAN fEventable;
    ULONG ulEventsEnabled;
    NODE_CACHE_UPDATE_RTN pCacheUpdateRtn;
};

// DataRange Structures to associate Interfaces with Datarange
typedef struct _FWAUDIO_DATARANGE {

    KSDATARANGE_AUDIO KsDataRangeAudio;

	ULONG ulDataType;

	ULONG ulValidDataBits;

	ULONG ulTransportType;

	ULONG ulMaxSampleRate;

	ULONG ulNumChannels;

	ULONG ulChannelConfig;

	ULONG ulSlotSize;

	PFW_PIN_DESCRIPTOR pFwPinDescriptor;

} FWAUDIO_DATARANGE, *PFWAUDIO_DATARANGE;

typedef struct {
    LIST_ENTRY List;
    PKSPIN pKsPin;
    PKSSTREAM_POINTER pKsStreamPtr;
    AV_61883_REQUEST Av61883Request;
} AV_CLIENT_REQUEST_LIST_ENTRY, *PAV_CLIENT_REQUEST_LIST_ENTRY;

#define MAX_GROUP_DEVICE_COUNT 32

typedef struct {
    GUID DeviceGroupGUID;
    ULONG ulChannelConfig;
    ULONG ulDeviceChannelCfg;
    ULONG ulDeviceCount;
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pBackupSubunitIdDesc;
    PAUDIO_CONFIGURATION pBackupAudioConfiguration;
    PHW_DEVICE_EXTENSION pHwDevExts[MAX_GROUP_DEVICE_COUNT];
} DEVICE_GROUP_INFO, *PDEVICE_GROUP_INFO;

typedef struct {
    PVOID hConnection;
    ULONG ulPlugNumber;
} PIN_GROUP_INFO, *PPIN_GROUP_INFO;

// Context for each opened pin
typedef struct _PIN_CONTEXT {

    ULONG ulAttachCount;
    ULONG ulUsedBuffers;
    ULONG ulCancelledBuffers;

    PVOID hConnection;

    PDEVICE_GROUP_INFO pDevGrpInfo;
    PPIN_GROUP_INFO pPinGroupInfo;

    ULONG ulSerialPlugNumber;

    PVOID pHwDevExt;

    PDEVICE_OBJECT pPhysicalDeviceObject;

    PFWAUDIO_DATARANGE pFwAudioDataRange;

    PCMP_REGISTER pCmpRegister;

    ULONG DrmContentId;

    union {
        ULONG fIsTalking;
        ULONG fIsListening;
        ULONG fIsStreaming;
    };

    ULONG ulSampleCount;

    LIST_ENTRY OutstandingRequestList;
    
	KSAUDIO_POSITION KsAudioPosition;
    ULONG ulLastBufferSize;
	CYCLE_TIME InitialCycleTime;
	BOOLEAN fStreamStarted;

    KSPIN_LOCK PinSpinLock;

    KEVENT PinStarvationEvent;

    NPAGED_LOOKASIDE_LIST CipRequestLookasideList;

    ULONG fWorkItemInProgress;
    WORK_QUEUE_ITEM PinWorkItem;
    LIST_ENTRY CompletedRequestList;

    ULONG fReconnect;
    CCM_SIGNAL_SOURCE CcmSignalSource;
    CCM_INPUT_SELECT CcmInputSelect;    

} PIN_CONTEXT, *PPIN_CONTEXT;


typedef struct {

    ULONG ulDevicePinCount;
    PFW_PIN_DESCRIPTOR pPinDescriptors;

    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc;

    PAUDIO_CONFIGURATION pAudioConfigurations;

    PDEVICE_GROUP_INFO pDeviceGroupInfo;

    AVC_PLUG_INFORMATION PlugInfo;

    AVC_COMMAND_CAPS fAvcCapabilities[AVC_CAP_MAX];

} AUDIO_SUBUNIT_INFORMATION, *PAUDIO_SUBUNIT_INFORMATION;

//===================================================================

NTSTATUS
AudioFunctionBlockCommand(
    PKSDEVICE pKsDevice,
    UCHAR     ucCtype,
    PVOID     pFBSpecificData,
    ULONG     pFBSpecificDataSize 
    );

NTSTATUS
AudioSetSampleRateOnPlug(
    PKSPIN    pKsPin,
    ULONG     ulSampleRate 
    );


#endif //___FWAUDIO_AUDIO_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\avcaudid.h ===
#ifndef ___AVC_AUDIO_PROPERTY_GUIDS___
#define ___AVC_AUDIO_PROPERTY_GUIDS___


// {4336CDCB-3BDD-42f4-9D5F-AA93747B7281}
DEFINE_GUID(KSPROPSETID_AvcAudio, 
0x4336cdcb, 0x3bdd, 0x42f4, 0x9d, 0x5f, 0xaa, 0x93, 0x74, 0x7b, 0x72, 0x81);


/*  SA Speaker group GUID
// {B6E83811-1F33-436a-AE37-FCB6CFDFE03A}
DEFINE_GUID(<<name>>, 
0xb6e83811, 0x1f33, 0x436a, 0xae, 0x37, 0xfc, 0xb6, 0xcf, 0xdf, 0xe0, 0x3a);
*/

enum {
    AVC_AUDIO_VENDOR_DEPENDENT
};

#endif // ___AVC_AUDIO_PROPERTY_GUIDS___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\avc.c ===
#include "Common.h"

NTSTATUS
AvcCheckResponse( 
    NTSTATUS ntStatus,
    UCHAR ucResponseCode )
{
    if ( STATUS_SUCCESS == ntStatus ) {
        switch(ucResponseCode) {
            case AVC_RESPONSE_NOTIMPL:
                ntStatus = STATUS_NOT_IMPLEMENTED;
                break;
            case AVC_RESPONSE_ACCEPTED:
            case AVC_RESPONSE_STABLE:
                ntStatus = STATUS_SUCCESS;
                break;
            case AVC_RESPONSE_REJECTED:
                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            case AVC_RESPONSE_IN_TRANSITION:
            case AVC_RESPONSE_CHANGED:
            case AVC_RESPONSE_INTERIM:
                ntStatus = STATUS_SUCCESS;
                break;
            default:
                ntStatus = STATUS_SUCCESS;
                break;
        }
    }
    else if ( STATUS_TIMEOUT == ntStatus ) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    return ntStatus;
}


NTSTATUS
AvcSubmitIrbSync(
    IN PKSDEVICE pKsDevice,
    PAVC_COMMAND_IRB pAvcIrb )
{
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS ntStatus, status;
    PIRP pIrp;

    // Get event and status pointers
    pKsEvent  = (PKEVENT)(pAvcIrb + 1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

#if 0
    pAvcIrb->TimeoutFlag = TRUE;
    pAvcIrb->RetryFlag   = TRUE;
    pAvcIrb->Retries     = 100;
    pAvcIrb->Timeout.QuadPart = 0xFFFFFFFF;
#endif

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pAvcIrb->Function = AVC_FUNCTION_COMMAND;

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_AVC_CLASS,
                pKsDevice->NextDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE,
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        FreeMem(pKsEvent);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pAvcIrb;

    // Call the 61883 class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pKsDevice->NextDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        // ISSUE-2001/02/06-dsisolak Need to timeout wait
        status = KeWaitForSingleObject( pKsEvent, Executive, KernelMode, FALSE, NULL );

    }

    ntStatus = AvcCheckResponse( pIoStatus->Status, pAvcIrb->ResponseCode );

    return ntStatus;
}

NTSTATUS
AvcSubmitMultifuncIrbSync(
    PKSDEVICE pKsDevice,
    PAVC_MULTIFUNC_IRB pAvcIrb,
    AVC_FUNCTION AvcFunc )
{
    IN PDEVICE_OBJECT pPhysicalDeviceObject = pKsDevice->NextDeviceObject;
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS ntStatus, status;
    PIRP pIrp;

    // Get event and status pointers
    pKsEvent  = (PKEVENT)(pAvcIrb + 1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pAvcIrb->Function = AvcFunc;

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_AVC_CLASS,
                pPhysicalDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE,
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        FreeMem(pKsEvent);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pAvcIrb;

    // Call the Avc class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pPhysicalDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject( pKsEvent, Suspended, KernelMode, FALSE, NULL );

        ntStatus = pIoStatus->Status;
    }


    return ntStatus;
}

NTSTATUS
AvcOpenDescriptorCommand(
    PKSDEVICE pKsDevice,
    AVC_DESCRIPTOR_TYPE AvcDescType,
    PUCHAR pAvcDescTypeSpecRef,
    ULONG ulTypeSpecRefLen,
    UCHAR ucSubFunction,
    BOOLEAN fUnitCommand )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    ULONG i;
    NTSTATUS ntStatus;
    UCHAR ucUnitAddress = 0xFF;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcOpenCloseDescriptor] ucSubFunction = %x\n",ucSubFunction));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    if ( fUnitCommand ) {
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr     = &ucUnitAddress;
    }

    pOperands = pAvcIrb->Operands;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = AVC_OPEN_DESCRIPTOR;
    pAvcIrb->OperandLength = 3 + ulTypeSpecRefLen;

    pOperands[0] = (UCHAR)AvcDescType;

    for ( i=1; i<(ulTypeSpecRefLen+1); i++ ) {
        pOperands[i] = pAvcDescTypeSpecRef[i-1];
    }
    pOperands[i++] = ucSubFunction; //AVC_SUBFUNC_READ_OPEN;
    pOperands[i] = 0x00;
    
    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcReadDescriptor(
    PKSDEVICE pKsDevice,
    AVC_DESCRIPTOR_TYPE AvcDescType,
    PUCHAR pAvcDescTypeSpecRef,
    ULONG ulTypeSpecRefLen,
    ULONG ulDataLength,
    ULONG ulOffsetAddress,
    PULONG pDescriptorLength,
    PUCHAR pDescriptor,
    BOOLEAN fUnitCommand )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    NTSTATUS ntStatus;
    ULONG ulDataLenOffset;
    UCHAR ucUnitAddress = 0xFF;
    ULONG i=0;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcReadDescriptor]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    if ( fUnitCommand ) {
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr     = &ucUnitAddress;
    }

    pOperands = pAvcIrb->Operands;

    // Set up Read Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = AVC_READ_DESCRIPTOR;
    pAvcIrb->OperandLength = 7 + ulTypeSpecRefLen;

    pOperands[0] = AvcDescType; // AVC_DESCTYPE_UNIT_IDENTIFIER;
    for ( i=1; i<(ulTypeSpecRefLen+1); i++ ) {
        pOperands[i] = pAvcDescTypeSpecRef[i-1];
    }

    pOperands[i] = 0xFF;

    i += 2; // Space for read result and reserved fields
    ulDataLenOffset = i;
    pOperands[i++] = ((PUCHAR)&ulDataLength)[2];
    pOperands[i++] = ((PUCHAR)&ulDataLength)[1];
    pOperands[i++] = ((PUCHAR)&ulOffsetAddress)[2];
    pOperands[i++] = ((PUCHAR)&ulOffsetAddress)[1];

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        // ISSUE-2001/01/10-dsisolak Need to check read status
        *pDescriptorLength = ((ULONG)pOperands[ulDataLenOffset]<<8) |
                              (ULONG)pOperands[ulDataLenOffset+1];
        if ( pDescriptor ) {
            RtlCopyMemory( pDescriptor,
                           &pOperands[ulDataLenOffset+4],
                           *pDescriptorLength );
        }
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcGetSubunitIdentifierDesc(
    PKSDEVICE pKsDevice,
    PUCHAR *ppSuDescriptor )
{
    PUCHAR pDescriptor;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetSubunitIdentifierDesc]\n"));

    // Open the Subunit Identifier Descriptor
    ntStatus = AvcOpenDescriptorCommand( pKsDevice, 
                                         AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                         NULL,
                                         0,
                                         (UCHAR)AVC_SUBFUNC_READ_OPEN,
                                         FALSE );
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = AvcReadDescriptor( pKsDevice,
                                      AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                      NULL,
                                      0,
                                      0,
                                      0, 
                                      &ulDescLen,
                                      NULL,
                                      FALSE );

    }

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    // Save the Subunit Identifier Desc.
    pDescriptor = AllocMem( NonPagedPool, ulDescLen+2 );
    if ( NULL == pDescriptor ) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        KsAddItemToObjectBag(pKsDevice->Bag, pDescriptor, FreeMem);
        ntStatus = AvcReadDescriptor( pKsDevice,
                                      AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                      NULL,
                                      0,
                                      0,
                                      0, 
                                      &ulDescLen,
                                      pDescriptor,
                                      FALSE );
       if ( NT_SUCCESS(ntStatus) ) {
           *ppSuDescriptor = pDescriptor;
           _DbgPrintF( DEBUGLVL_VERBOSE, ("Subunit Descriptor: %x\n", pDescriptor ));
       }
    }


    return ntStatus;
}


NTSTATUS
AvcPlugSignalFormat(
    PKSDEVICE pKsDevice,
    KSPIN_DATAFLOW KsDataFlow,
    ULONG ulSerialPlug,
    UCHAR ucCmdType,
    PUCHAR pFMT,
    PUCHAR pFDF )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    PUCHAR pOperands;
    ULONG ulDescLen;
    NTSTATUS ntStatus;


    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // Set up command in AvcIrb.
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;
    pAvcIrb->CommandType   = ucCmdType;
    pAvcIrb->Opcode        = (KSPIN_DATAFLOW_IN == KsDataFlow) ? 
                                               AVC_INPUT_PLUG_SIGNAL_FORMAT  :
                                               AVC_OUTPUT_PLUG_SIGNAL_FORMAT ;
    pAvcIrb->OperandLength = 5;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcSetPlugSignalFormat] %s %s\n",
                                      (pAvcIrb->Opcode == AVC_INPUT_PLUG_SIGNAL_FORMAT) ?
                                                   "INPUT_PLUG_FORMAT " :
                                                   "OUTPUT_PLUG_FORMAT",
                                      (ucCmdType == AVC_CTYPE_CONTROL) ? 
                                                   "AVC_CTYPE_CONTROL" :
                                                   "AVC_CTYPE_STATUS"));
    ASSERT(ulSerialPlug<=30);

    pOperands[0] = (UCHAR)ulSerialPlug;

    switch ( ucCmdType ) {
        case AVC_CTYPE_CONTROL:
        case AVC_CTYPE_SPEC_INQ:
            pOperands[1] = *pFMT | (UCHAR)(2<<6);
            pOperands[2] = *pFDF;
            pOperands[3] = 0;
            pOperands[4] = 0;
            break;

        case AVC_CTYPE_STATUS:
            *(PULONG)(&pOperands[1]) = 0xffffffff;
            break;

        default:
            TRAP;  // Should never happen.
            break;
    }

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) && ( ucCmdType == AVC_CTYPE_STATUS )) {
        *pFMT = pOperands[1] & 0x3f;
        *pFDF = pOperands[2];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcGetPlugInfo(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    PUCHAR pPlugCounts )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPlugInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // If this is a unit command set the appropriate address
    if (fUnitFlag) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = AVC_PLUG_INFO;
    pAvcIrb->OperandLength = 5;

    *(PULONG)(&pOperands[1]) = 0xFFFFFFFF;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        ULONG i;
        for (i=1;i<5;i++)
            pPlugCounts[i-1] = pOperands[i];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcConnectDisconnect(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_CONNECTION pAvcConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnectDisconnect]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = (UCHAR)ulFunction;
    pAvcIrb->OperandLength = 5;

    *((PAVC_CONNECTION)&pOperands[0]) = *pAvcConnection;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS( ntStatus ) ) {
        *pAvcConnection = *((PAVC_CONNECTION)&pOperands[0]) ;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcConnectDisconnectAV(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_AV_CONNECTION pAvConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnectDisconnectAV]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = (UCHAR)ulFunction;
    pAvcIrb->OperandLength = 5;

    *((PAVC_AV_CONNECTION)&pOperands[0]) = *pAvConnection;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory( pAvConnection,
                       &pOperands[0],
                       5 );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcConnections(
    PKSDEVICE pKsDevice,
    PULONG pNumConnections,
    PVOID pConnections )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnections]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = AVC_CONNECTIONS_STATUS;
    pAvcIrb->OperandLength = 1;

    pOperands[0] = 0xFF;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        ULONG i;
        *pNumConnections = (ULONG)pOperands[0];
        if (pConnections) {
            RtlCopyMemory( pConnections,
                           &pOperands[1],
                           *pNumConnections * 5 );
#if DBG
            for ( i=0; i<*pNumConnections; i++ ) {
                PAVC_CONNECTION pAvcConnections = (PAVC_CONNECTION)pConnections;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("Connection %d: Locked: %d Permanent: %d\n",i,
                                                    pAvcConnections[i].fLock, pAvcConnections[i].fPermanent ));
                _DbgPrintF( DEBUGLVL_VERBOSE, ("    Source: SubunitID: %x, SubunitType: %x, Plug#: %x\n",
                                                    pAvcConnections[i].SourcePlug.SubunitId,
                                                    pAvcConnections[i].SourcePlug.SubunitType,
                                                    pAvcConnections[i].SourcePlug.ucPlugNumber ));
                _DbgPrintF( DEBUGLVL_VERBOSE, ("    Dest:   SubunitID: %x, SubunitType: %x, Plug#: %x\n",
                                                    pAvcConnections[i].DestinationPlug.SubunitId,
                                                    pAvcConnections[i].DestinationPlug.SubunitType,
                                                    pAvcConnections[i].DestinationPlug.ucPlugNumber ));
            }
#endif
        }
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcPower(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    AvcCommandType ulCommandType,
    PAVC_BOOLEAN pPowerState )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcPower]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = AVC_POWER;
    pAvcIrb->OperandLength = 1;

    pOperands[0] = (ulCommandType == AVC_CTYPE_STATUS) ? 0x7f : (UCHAR)*pPowerState;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS( ntStatus ) ) {
        *pPowerState = (AVC_BOOLEAN)pOperands[0];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcVendorDependent(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    ULONG ulCommandType,
    ULONG ulVendorId,
    ULONG ulDataLength,
    PVOID pData )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcVendorDependent]\n"));
    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = AVC_VENDOR_DEPENDENT;
    pAvcIrb->OperandLength = 3 + ulDataLength;

    pOperands[0] = ((PUCHAR)&ulVendorId)[2];
    pOperands[1] = ((PUCHAR)&ulVendorId)[1];
    pOperands[2] = ((PUCHAR)&ulVendorId)[0];

    RtlCopyMemory( &pOperands[3], pData, ulDataLength );

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        // Check if the response is successful.
        RtlCopyMemory( pData, pOperands, ulDataLength );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGeneralInquiry(
    PKSDEVICE pKsDevice,
    BOOLEAN fUnitFlag,
    UCHAR ucOpcode )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;


    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)AVC_CTYPE_GEN_INQ;
    pAvcIrb->Opcode        = ucOpcode;
    pAvcIrb->OperandLength = 0;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGeneralInquiry] Command: %x Response: %x\n", 
                                 ucOpcode, pAvcIrb->ResponseCode ));

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinCount( 
    PKSDEVICE pKsDevice,
    PULONG pNumberOfPins )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinCount]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_PIN_COUNT );
    if ( NT_SUCCESS(ntStatus) ) {
        *pNumberOfPins = pAvcIrb->PinCount.PinCount;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinDescriptor(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PIN_DESCRIPTOR pAvcPinDesc )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinDescriptor]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinDescriptor.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_PIN_DESCRIPTOR );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcPinDesc = pAvcIrb->PinDescriptor;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PRECONNECT_INFO pAvcPreconnectInfo )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinConnectInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinDescriptor.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_CONNECTINFO );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcPreconnectInfo = pAvcIrb->PreConnectInfo;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcSetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    HANDLE hPlug,
    ULONG ulUnitPlugId,
    ULONG usSubunitAddress,
    PAVC_SETCONNECT_INFO pAvcSetconnectInfo )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcSetPinConnectInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->SetConnectInfo.PinId = ulPinId;
    pAvcIrb->SetConnectInfo.ConnectInfo.SubunitAddress[0] = (UCHAR)usSubunitAddress;
    pAvcIrb->SetConnectInfo.ConnectInfo.hPlug = hPlug;
    pAvcIrb->SetConnectInfo.ConnectInfo.UnitPlugNumber = ulUnitPlugId;
    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_SET_CONNECTINFO );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcSetconnectInfo = pAvcIrb->SetConnectInfo;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcAcquireReleaseClear( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    AVC_FUNCTION AvcFunction )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcAcquireReleaseClear]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinId.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AvcFunction );

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcUnitInfoInitialize(  
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo;
    ULONG ulNumConnections;
    NTSTATUS ntStatus;
    ULONG i;

    pUnitInfo = AllocMem( NonPagedPool, sizeof(AVC_UNIT_INFORMATION) );
    if ( !pUnitInfo ) return STATUS_INSUFFICIENT_RESOURCES;

    pHwDevExt->pAvcUnitInformation = pUnitInfo;

    // Bag pUnitInfo for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pUnitInfo, FreeMem);

    RtlZeroMemory( pUnitInfo, sizeof(AVC_UNIT_INFORMATION) );

    // First get CMP Plug info (I know this is not really AV/C 
    // but the info is necessary for calculations below)

    // Get the Local Node Address for later use
    ntStatus = 
        Bus1394GetNodeAddress( pKsDevice->NextDeviceObject,
                               USE_LOCAL_NODE,
                               &pHwDevExt->NodeAddress );

    // Get the "device capabilities" (Plug Control Register info)
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                          Av61883_GetUnitInfo,
                                          GET_UNIT_INFO_CAPABILITIES,
                                          &pUnitInfo->CmpUnitCaps );
    }

    // Get the 61883 Config ROM info
    if ( NT_SUCCESS(ntStatus) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("NumOutputPlugs: %d NumInputPlugs %d\n",
                                      pUnitInfo->CmpUnitCaps.NumOutputPlugs,
                                      pUnitInfo->CmpUnitCaps.NumInputPlugs ));

        ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                          Av61883_GetUnitInfo,
                                          GET_UNIT_INFO_IDS,
                                          &pUnitInfo->IEC61883UnitIds );

        _DbgPrintF( DEBUGLVL_VERBOSE, ("VendorID: %x ModelID %x\n",
                                      pUnitInfo->IEC61883UnitIds.VendorID,
                                      pUnitInfo->IEC61883UnitIds.ModelID ));
    }

    ntStatus = AvcGetPlugInfo( pKsDevice, TRUE, (PUCHAR)&pUnitInfo->PlugInfo );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->fAvcCapabilities[AVC_CAP_PLUG_INFO].fStatus = TRUE;
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Serial In: %d Serial Out: %d Ext In: %d Ext Out: %d\n",
                                      pUnitInfo->PlugInfo.ucSerialBusInputPlugCnt,
                                      pUnitInfo->PlugInfo.ucSerialBusOutputPlugCnt,
                                      pUnitInfo->PlugInfo.ucExternalInputPlugCnt,
                                      pUnitInfo->PlugInfo.ucExternalOutputPlugCnt ));
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    ntStatus = AvcConnections( pKsDevice, &ulNumConnections, NULL );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->ulNumConnections = ulNumConnections;
        pUnitInfo->pConnections = AllocMem(PagedPool, ulNumConnections * sizeof(AVC_CONNECTION) );
        if ( !pUnitInfo->pConnections ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        // Bag for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pUnitInfo->pConnections, FreeMem);

        ntStatus = AvcConnections( pKsDevice, &ulNumConnections, pUnitInfo->pConnections );
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &pUnitInfo->bPowerState );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus = TRUE;
//        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_CONTROL, &pUnitInfo->bPowerState );
        ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_POWER );
        if ( NT_SUCCESS(ntStatus) ) {
            pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand = TRUE;
        }
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    // Determine if the data format on the plug is discoverable and can change.
    for ( i=0; i<pUnitInfo->CmpUnitCaps.NumInputPlugs; i++) {
        UCHAR ucFDF;
        UCHAR ucFMT;
        ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                        KSPIN_DATAFLOW_IN, 
                                        i, 
                                        AVC_CTYPE_STATUS,
                                        &ucFMT,
                                        &ucFDF );

        if ( NT_SUCCESS(ntStatus) || (STATUS_NOT_IMPLEMENTED == ntStatus)) {
            if (NT_SUCCESS(ntStatus)) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fStatus = TRUE;
            }

            ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_INPUT_PLUG_SIGNAL_FORMAT );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fCommand = TRUE;
            }
            else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
                return ntStatus;
            }
        }
        else {
            return ntStatus;
        }
    }

    for ( i=0; i<pUnitInfo->CmpUnitCaps.NumOutputPlugs; i++) {
        UCHAR ucFDF;
        UCHAR ucFMT;
        ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                        KSPIN_DATAFLOW_OUT, 
                                        i, 
                                        AVC_CTYPE_STATUS, 
                                        &ucFMT,
                                        &ucFDF );

        if ( NT_SUCCESS(ntStatus) || (STATUS_NOT_IMPLEMENTED == ntStatus)) {
            if (NT_SUCCESS(ntStatus)) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fStatus = TRUE;
            }

            ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_OUTPUT_PLUG_SIGNAL_FORMAT );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fCommand = TRUE;
            }
            else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
                return ntStatus;
            }
        }
    }

    if ( STATUS_NOT_IMPLEMENTED == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\ccm.h ===
#ifndef ___AVC_CCM_H___
#define ___AVC_CCM_H___

#define MAX_IPCR 0x1E

typedef enum {
    INPUT_SELECT_SUBFN_CONNECT,
    INPUT_SELECT_SUBFN_PATHCHANGE,
    INPUT_SELECT_SUBFN_SELECT,
    INPUT_SELECT_SUBFN_DISCONNECT
} INPUT_SELECT_SUBFUNCTION;

#pragma pack( push, ccm_structs, 1)

#define bfResultStatus bfControlStatus

typedef struct {
    UCHAR ucStatus;
    AVC_PLUG_DEFINITION SignalSource;
    AVC_PLUG_DEFINITION SignalDestination;
} CCM_SIGNAL_SOURCE, *PCCM_SIGNAL_SOURCE;

typedef struct {
    UCHAR ucSubFunction;
    UCHAR bfControlStatus:4,
          bfStatus       :4;
    USHORT usNodeId;
    UCHAR ucOutputPlug;
    UCHAR ucInputPlug;
    AVC_PLUG_DEFINITION SignalDestination;
    UCHAR Rsvd;
} CCM_INPUT_SELECT, *PCCM_INPUT_SELECT;

#pragma pack( pop, ccm_structs )

NTSTATUS
CCMSignalSource( 
    PKSDEVICE pKsDevice,
    AvcCommandType ulCommandType,
    PCCM_SIGNAL_SOURCE pInCCMSignalSource 
    );

NTSTATUS
CCMCheckSupport(
    PKSDEVICE pKsDevice,
    ULONG ulSubunitId,
    ULONG ulPlugNumber 
    );

NTSTATUS
CCMInputSelectControl (
    PKSDEVICE pKsDevice,
    ULONG ulSubFunction,
    USHORT usNodeId,
    UCHAR ucOutputPlug,
    PAVC_PLUG_DEFINITION pSignalDestination 
    );

NTSTATUS
CCMInputSelectStatus (
    PKSDEVICE pKsDevice,
    UCHAR ucInputPlug,
    PCCM_INPUT_SELECT pInCcmInputSelect 
    );

#endif // ___AVC_CCM_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\avccmd.h ===
#ifndef ___FWAUDVD_AVCCMD_H___
#define ___FWAUDVD_AVCCMD_H___

// AV/C Commands
#define AVC_VENDOR_DEPENDENT          0x00
#define AVC_PLUG_RESERVE              0x01
#define AVC_PLUG_INFO                 0x02
#define AVC_OPEN_DESCRIPTOR           0x08
#define AVC_READ_DESCRIPTOR           0x09
#define AVC_WRITE_DESCRIPTOR          0x0A
#define AVC_SEARCH_DESCRIPTOR         0x0B
#define AVC_OBJECT_NUM_SELECT         0x0D
#define AVC_DIGITAL_OUTPUT            0x10
#define AVC_DIGITAL_INPUT             0x11
#define AVC_CHANNEL_USAGE             0x12
#define AVC_OUTPUT_PLUG_SIGNAL_FORMAT 0x18
#define AVC_INPUT_PLUG_SIGNAL_FORMAT  0x19
#define AVC_CONNECT_AV                0x20
#define AVC_DISCONNECT_AV             0x21
#define AVC_CONNECTIONS_STATUS        0x22
#define AVC_CONNECT                   0x24
#define AVC_DISCONNECT                0x25
#define AVC_UNIT_INFO                 0x30
#define AVC_SUBUNIT_INFO              0x31
#define AVC_POWER                     0xB2

#define UNIT_SUBUNIT_ADDRESS 0xFF
#define UNIT_SUBUNIT_ID      0x07

#define MAX_AVC_COMMAND_SIZE 512

// AV/C Descriptor operand subfunctions
#define AVC_SUBFUNC_CLOSE      0
#define AVC_SUBFUNC_READ_OPEN  1
#define AVC_SUBFUNC_WRITE_OPEN 3

// AV/C Descriptor Types
typedef enum {
    AVC_DESCTYPE_UNIT_IDENTIFIER    = 0xFF,
    AVC_DESCTYPE_SUBUNIT_IDENTIFIER = 0x00,
    AVC_DESCTYPE_OBJLIST_BY_ID      = 0x10,
    AVC_DESCTYPE_OBJLIST_BY_TYPE    = 0x11,
    AVC_DESCTYPE_OBJENTRY_BY_POS    = 0x20,
    AVC_DESCTYPE_OBJENTRY_BY_ID     = 0x21
} AVC_DESCRIPTOR_TYPE, *PAVC_DESCRIPTOR_TYPE;

typedef enum {
    AVC_ON  = 0x70,
    AVC_OFF = 0x60
} AVC_BOOLEAN, *PAVC_BOOLEAN;

// AVC definitions
#define IS_AVC_EXTERNAL_PLUG(a)  ((((UCHAR)a >  0x7f) && ((UCHAR)a < 0x9f)) || ((UCHAR)a == 0xff))
#define IS_AVC_SERIALBUS_PLUG(a) ((((UCHAR)a >= 0x00) && ((UCHAR)a < 0x1f)) || ((UCHAR)a == 0x7f))

// AV/C Capabilities Flags
enum {
    AVC_CAP_CONNECTIONS,
    AVC_CAP_CONNECT,
    AVC_CAP_PLUG_INFO,
    AVC_CAP_INPUT_PLUG_FMT,
    AVC_CAP_OUTPUT_PLUG_FMT,
    AVC_CAP_SUBUNIT_IDENTIFIER_DESC,
    AVC_CAP_CCM,
    AVC_CAP_POWER,
    AVC_CAP_MAX
} AVC_CAP_COMMANDS;

//===============================================================================

#pragma pack( push, avc_structs, 1)

typedef struct {
    UCHAR ucDescriptorLengthHi;
    UCHAR ucDescriptorLengthLo;
    UCHAR ucGenerationID;
    UCHAR ucSizeOfListID;
    UCHAR ucSizeOfObjectID;
    UCHAR ucSizeOfObjectPosition;
    UCHAR ucNumberOfRootObjectListsHi;
    UCHAR ucNumberOfRootObjectListsLo;
} SUBUNIT_INFO_DESCRIPTOR, *PSUBUNIT_IDENTIFIER_DESCRIPTOR;

typedef struct {
    UCHAR SubunitId:3;
    UCHAR SubunitType:5;
    UCHAR ucPlugNumber;
} AVC_PLUG_DEFINITION, *PAVC_PLUG_DEFINITION;

typedef struct {
    UCHAR fPermanent:1;
    UCHAR fLock:1;
    UCHAR Rsrvd:6;
    AVC_PLUG_DEFINITION SourcePlug;
    AVC_PLUG_DEFINITION DestinationPlug;
} AVC_CONNECTION, *PAVC_CONNECTION;

typedef struct {
    UCHAR AudioDstType:2;
    UCHAR VideoDstType:2;
    UCHAR AudioSrcType:2;
    UCHAR VideoSrcType:2;
    UCHAR ucVideoSource;
    UCHAR ucAudioSource;
    UCHAR ucVideoDestination;
    UCHAR ucAudioDestination;
} AVC_AV_CONNECTION, *PAVC_AV_CONNECTION;

typedef struct {
    union {
        UCHAR ucDestinationPlugCnt;
        UCHAR ucSerialBusInputPlugCnt;
    };
    union {
        UCHAR ucSourcePlugCnt;
        UCHAR ucSerialBusOutputPlugCnt;
    };
    UCHAR ucExternalInputPlugCnt;
    UCHAR ucExternalOutputPlugCnt;
} AVC_PLUG_INFORMATION, *PAVC_PLUG_INFORMATION;

#pragma pack( pop, avc_structs )

typedef struct {
    BOOLEAN fCommand;
    BOOLEAN fStatus;
    BOOLEAN fNotify;
} AVC_COMMAND_CAPS, *PAVC_COMMAND_CAPS;

typedef struct {
    AVC_COMMAND_CAPS fAvcCapabilities[AVC_CAP_MAX];

    GET_UNIT_CAPABILITIES CmpUnitCaps;
    GET_UNIT_IDS IEC61883UnitIds;

    ULONG ulNumConnections;
    PAVC_CONNECTION pConnections;

    AVC_BOOLEAN bPowerState;

    AVC_PLUG_INFORMATION PlugInfo;

    NODE_ADDRESS NodeAddress;

} AVC_UNIT_INFORMATION, *PAVC_UNIT_INFORMATION;

typedef struct __SUBUNIT_PLUG {
    AVC_PLUG_DEFINITION AvcPlug;

    CMP_PLUG_TYPE PlugType;

    PVOID pConnectedUnitPlug;

    PVOID pContext;

} SUBUNIT_PLUG, *PSUBUNIT_PLUG;


//===============================================================================

// AVC.c Prototypes
NTSTATUS
AvcSubmitIrbSync(
    IN PKSDEVICE pKsDevice,
    PAVC_COMMAND_IRB pAvcIrb 
    );

NTSTATUS
AvcConnections(
    PKSDEVICE pKsDevice,
    PULONG pNumConnections,
    PVOID pConnections 
    );

NTSTATUS
AvcGeneralInquiry(
    PKSDEVICE pKsDevice,
    BOOLEAN fUnitFlag,
    UCHAR ucOpcode 
    );

NTSTATUS
AvcPower(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    AvcCommandType ulCommandType,
    PAVC_BOOLEAN pPowerState
    );

NTSTATUS
AvcGetSubunitIdentifierDesc(
    PKSDEVICE pKsDevice,
    PUCHAR *ppSuDescriptor
    );

NTSTATUS
AvcCheckResponse( 
    NTSTATUS ntStatus,
    UCHAR ucResponseCode
    );

NTSTATUS
AvcGetPlugInfo(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    PUCHAR pPlugCounts
    );

NTSTATUS
AvcConnectDisconnect(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_CONNECTION pAvcConnection
    );

NTSTATUS
AvcConnectDisconnectAV(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_AV_CONNECTION pAvConnection 
    );

NTSTATUS
AvcPlugSignalFormat(
    PKSDEVICE pKsDevice,
    KSPIN_DATAFLOW KsDataFlow,
    ULONG ulSerialPlug,
    UCHAR ucCmdType,
    PUCHAR pFMT,
    PUCHAR pFDF 
    );

NTSTATUS
AvcVendorDependent(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    ULONG ulCommandType,
    ULONG ulVendorId,
    ULONG ulDataLength,
    PVOID pData 
    );

NTSTATUS
AvcGetPinCount( 
    PKSDEVICE pKsDevice,
    PULONG pNumberOfPins 
    );

NTSTATUS
AvcGetPinDescriptor(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PIN_DESCRIPTOR pAvcPinDesc 
    );

NTSTATUS
AvcGetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PRECONNECT_INFO pAvcPreconnectInfo 
    );

NTSTATUS
AvcSetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    HANDLE hPlug,
    ULONG ulUnitPlugId,
    ULONG usSubunitAddress,
    PAVC_SETCONNECT_INFO pAvcSetconnectInfo
    );

NTSTATUS
AvcAcquireReleaseClear( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    AVC_FUNCTION AvcFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\busproto.h ===
#ifndef ___BUSDEV_PROTO_H___
#define ___BUSDEV_PROTO_H___

// Filter.c
NTSTATUS
FilterCreateFilterFactory(
    PKSDEVICE pKsDevice,
    BOOLEAN fEnableInterfaces
    );

NTSTATUS
FilterDestroyFilterFactory(
    PKSDEVICE pKsDevice 
    );

// Pin.c
NTSTATUS
PinBuildDescriptors( 
    PKSDEVICE pKsDevice, 
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx, 
    PULONG pNumPins,
    PULONG pPinDecSize 
    );

NTSTATUS
PinSurpriseRemove(
    PKSPIN pKsPin 
    );

// ParseDsc.c
PAUDIO_SUBUNIT_DEPENDENT_INFO 
ParseFindAudioSubunitDependentInfo(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc 
    );

PCONFIGURATION_DEPENDENT_INFO
ParseFindFirstAudioConfiguration(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc 
    );

PFUNCTION_BLOCKS_INFO
ParseFindFunctionBlocksInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo 
    );

VOID
ParseFunctionBlock( 
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    PFUNCTION_BLOCK pFunctionBlock 
    );

NTSTATUS
ParseAudioSubunitDescriptor( 
    PKSDEVICE pKsDevice 
    );

VOID
CountTopologyComponents(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories 
    );

ULONG
CountDeviceBridgePins( 
    PKSDEVICE pKsDevice
    );

ULONG
CountFormatsForPin( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber
    );

void
GetPinDataRanges( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber, 
    PKSDATARANGE_AUDIO *ppAudioDataRanges,
    PFWAUDIO_DATARANGE pAudioDataRange 
    );

VOID
GetCategoryForBridgePin(
    PKSDEVICE pKsDevice, 
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID 
    );

BOOLEAN
IsSampleRateInRange(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulSampleRate 
    );

PFWAUDIO_DATARANGE
GetDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PFWAUDIO_DATARANGE pFwDataRange,
    ULONG ulDataRangeCnt 
    );

ULONG
FindSourceForSrcPlug( 
    PHW_DEVICE_EXTENSION pHwDevExt, 
    ULONG ulPinId 
    );

USHORT
usBitSwapper(
    USHORT usInVal );


// Property.c
NTSTATUS
CreateFeatureFBlockRequest( 
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PVOID pData,
    ULONG ulByteCount,
    USHORT usRequestType 
    );

NTSTATUS
InitializeDbLevelCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount 
    );

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo
    );

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets 
    );

VOID
BuildPinPropertySet( 
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPROPERTY_ITEM pStrmPropItems,
    PKSPROPERTY_SET pStrmPropSet,
    PULONG pNumItems,
    PULONG pNumSets 
    );

// Topology.c
NTSTATUS
BuildFilterTopology( 
    PKSDEVICE pKsDevice 
    );


// AM824.c
NTSTATUS
AM824ProcessData( 
    PKSPIN pKsPin 
    );

NTSTATUS
AM824CancelRequest( 
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry 
    );

NTSTATUS
AM824AudioPosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition
    );

#ifdef TOPO_FAKE
// TopoFake.c
NTSTATUS
BuildFakeUnitDescriptor( 
    PKSDEVICE pKsDevice 
    );
#endif

NTSTATUS
BuildFakeSubunitDescriptor( 
    PKSDEVICE pKsDevice 
    );

// Intrsect.c
ULONG
GetIntersectFormatSize( 
    PFWAUDIO_DATARANGE pAudioDataRange 
    );

ULONG
ConvertDatarangeToFormat(
    PFWAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat 
    );

PFWAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PFWAUDIO_DATARANGE *ppFWAudioRanges,
    ULONG ulAudioRangeCount 
    );

// CCM.c
NTSTATUS
CCMSetSignalSource( 
    PKSDEVICE pKsDevice,
    AVC_PLUG_DEFINITION SignalSource,
    AVC_PLUG_DEFINITION SignalDestination 
    );

// Registry.c
NTSTATUS
RegistryReadMultiDeviceConfig(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfMultiDevice,
    GUID *pSpkrGrpGUID,
    PULONG pChannelConfig 
    );

// Grouping.c
NTSTATUS
GroupingDeviceGroupSetup (
    PKSDEVICE pKsDevice 
    );

PHW_DEVICE_EXTENSION
GroupingFindChannelExtension(
    PKSDEVICE pKsDevice,
    PULONG pChannelIndx 
    );

// Timer.c
NTSTATUS
TimerInitialize(
    PKSDEVICE pKsDevice 
    );

NTSTATUS
TimerStop( 
    PHW_DEVICE_EXTENSION pHwDevExt
    );

// HwEvent.c
NTSTATUS
HwEventAddHandler(
    IN PIRP pIrp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry 
    );

VOID
HwEventRemoveHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSEVENT_ENTRY pEventEntry 
    );

NTSTATUS
HwEventSupportHandler(
    IN PIRP Irp,
    IN PKSEVENT pKsEvent,
    IN OUT PVOID Data 
    );

#endif // ___BUSDEV_PROTO_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\ccm.c ===
#include "Common.h"

#define CCM_CMD_SIGNAL_SOURCE 0x1A
#define CCM_CMD_INPUT_SELECT  0x1B
#define CCM_CMD_OUTPUT_PRESET 0x1C


NTSTATUS
CCMSignalSource( 
    PKSDEVICE pKsDevice,
    AvcCommandType ulCommandType,
    PCCM_SIGNAL_SOURCE pInCCMSignalSource )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PCCM_SIGNAL_SOURCE pCCMSignalSource;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCCMSignalSource = (PCCM_SIGNAL_SOURCE)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = ulCommandType;
    pAvcIrb->Opcode        = CCM_CMD_SIGNAL_SOURCE;
    pAvcIrb->OperandLength = 5;

    if ( AVC_CTYPE_CONTROL == ulCommandType ) {
        pCCMSignalSource->ucStatus = 0x0F;
        pCCMSignalSource->SignalSource = pInCCMSignalSource->SignalSource;
    }
    else {
        pCCMSignalSource->ucStatus = 0xFF;
        *((PUSHORT)&pCCMSignalSource->SignalSource) = 0xFEFF;
    }

    pCCMSignalSource->SignalDestination = pInCCMSignalSource->SignalDestination;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMSignalSource] %s pAvcIrb: %x\n",
                                   ( AVC_CTYPE_CONTROL == ulCommandType ) ?
                                               "AVC_CTYPE_CONTROL" : "AVC_CTYPE_STATUS",
                                   pAvcIrb ));

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory( pInCCMSignalSource,
                       pCCMSignalSource,
                       sizeof(CCM_SIGNAL_SOURCE) );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
CCMInputSelectControl (
    PKSDEVICE pKsDevice,
    ULONG ulSubFunction,
    USHORT usNodeId,
    UCHAR ucOutputPlug,
    PAVC_PLUG_DEFINITION pSignalDestination )
{
    
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PCCM_INPUT_SELECT pCcmInputSelect;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCcmInputSelect = (PCCM_INPUT_SELECT)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = CCM_CMD_INPUT_SELECT;
    pAvcIrb->OperandLength = 9;

    // Fill In Input Select request
    pCcmInputSelect->ucSubFunction     = (UCHAR)ulSubFunction;
    pCcmInputSelect->bfResultStatus    = 0xf;
    pCcmInputSelect->usNodeId          = bswapw(usNodeId);
    pCcmInputSelect->ucInputPlug       = 0xFF;
    pCcmInputSelect->ucOutputPlug      = ucOutputPlug;
    pCcmInputSelect->SignalDestination = *pSignalDestination;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
#if DBG
        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMInputSelectControl] Failed pAvcIrb: %x\n",pAvcIrb ));
        }
#endif

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

 }

NTSTATUS
CCMInputSelectStatus (
    PKSDEVICE pKsDevice,
    UCHAR ucInputPlug,
    PCCM_INPUT_SELECT pInCcmInputSelect )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PCCM_INPUT_SELECT pCcmInputSelect;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCcmInputSelect = (PCCM_INPUT_SELECT)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = CCM_CMD_INPUT_SELECT;
    pAvcIrb->OperandLength = 9;

    // Fill In Input Select request
    ((PULONG)pCcmInputSelect)[0] = 0xFFFFFFFF;
    ((PULONG)pCcmInputSelect)[1] = 0xFFFFFFFF;
    pCcmInputSelect->ucInputPlug = ucInputPlug;
    pAvcIrb->Operands[6] = 0xFF;
    pAvcIrb->Operands[7] = 0xFE;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        *pInCcmInputSelect = *pCcmInputSelect;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMInputSelectStatus] pAvcIrb: %x\n",pAvcIrb ));

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

 }

NTSTATUS
CCMCheckSupport(
    PKSDEVICE pKsDevice,
    ULONG ulSubunitId,
    ULONG ulPlugNumber )
{
    CCM_SIGNAL_SOURCE CcmSignalSource;
    NTSTATUS ntStatus;

    CcmSignalSource.SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
    CcmSignalSource.SignalDestination.SubunitId    = (UCHAR)ulSubunitId;
    CcmSignalSource.SignalDestination.ucPlugNumber = (UCHAR)ulPlugNumber;

    ntStatus = CCMSignalSource( pKsDevice, 
                                AVC_CTYPE_STATUS,
                                &CcmSignalSource );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMCheckSupport]:CcmSignalSource: %x ntStatus: %x\n",
                                   &CcmSignalSource, ntStatus ));
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\dbglog.h ===
#ifndef __DBGLOG_H
#define __DBGLOG_H

#define DEBUG_LOG 1

#if DBG && DEBUG_LOG
// structure and calls to save data in debug buffer

typedef struct _DBG_LOG_ENTRY {
    CHAR     le_name[8];      // Identifying string
    LARGE_INTEGER SysTime;    // System Time
//    ULONG    Irql;            // Current Irql
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
    ULONG    le_info4;        // entry specific info
} DBG_LOG_ENTRY, *PDBG_LOG_ENTRY;

typedef struct _DBG_BUFFER {
    UCHAR LGFlag[16];
    ULONG EntryCount;
    PDBG_LOG_ENTRY pLogHead;
    PDBG_LOG_ENTRY pLogTail;
    PDBG_LOG_ENTRY pLog;
} DBG_BUFFER, *PDBG_BUFFER;

VOID
DbugLogEntry( 
    IN CHAR *Name,
    IN ULONG Info1,
    IN ULONG Info2,
    IN ULONG Info3,
    IN ULONG Info4
    );

VOID
DbugLogInitialization(void);

VOID
DbugLogUnInitialization(void);

#define DbgLogInit() DbugLogInitialization()
#define DbgLogUnInit() DbugLogUnInitialization()
#define DbgLog(a,b,c,d,e) DbugLogEntry(a,(ULONG)(ULONG_PTR)b,(ULONG)(ULONG_PTR)c,(ULONG)(ULONG_PTR)d,(ULONG)(ULONG_PTR)e)

#else
#define DbgLogInit()
#define DbgLogUnInit()
#define DbgLog(a,b,c,d,e)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

#define PSEUDO_HID

// #define TOPO_FAKE

#define SUM_HACK

#include "stdarg.h"
#include "stdio.h"

#include "wdm.h"
#include "windef.h"

#define NOBITMAP
#include "mmsystem.h"
#include "mmreg.h"
#undef NOBITMAP

#include "ks.h"
#include "ksmedia.h"
#include "wdmguid.h"

#include "1394.h"
#include "61883.h"
#include "Avc.h"

#include <initguid.h>

#include "Device.h"

#include "AvcAudId.h"
#include "AvcCmd.h"
#include "61883Cmd.h"

#include "CCM.h"
#include "Audio.h"

#include "Debug.h"

#include "BusProto.h"

#include <unknown.h>
#include <drmk.h>

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define LOCKED_BSS      bss_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS    bss_seg("PAGEDATA", "DATA")

#define MAX_ULONG 0xFFFFFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\debug.h ===
#ifndef __DEBUG_H
#define __DEBUG_H

#define TRAP KdBreakPoint()

#define DBGMEMMAP 0

#if (DBG)
#define STR_MODULENAME "'1394 Audio: "
#endif

#if DBG && DBGMEMMAP

typedef struct {
    ULONG TotalBytes;
    KSPIN_LOCK SpinLock;
    LIST_ENTRY List;
} MEM_TRACKER, *PMEM_TRACKER;

extern PMEM_TRACKER LogMemMap;

VOID
InitializeMemoryList( VOID );

PVOID
USBAudioAllocateTrack(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    );

#define AllocMem USBAudioAllocateTrack
#define FreeMem USBAudioDeallocateTrack

#else

#define AllocMem ExAllocatePool
#define FreeMem ExFreePool

#endif

#if DBG
VOID
DumpUnitDescriptor( PUCHAR pAddr );

VOID
DumpAllUnitDescriptors( 
    PUCHAR BeginAddr, PUCHAR EndAddr );

VOID
DumpDescriptor( PVOID pDescriptor );

VOID
DumpAllDescriptors(
    PVOID pConfigurationDescriptor 
    );

#define DumpDesc DumpDescriptor
#define DumpAllDesc DumpAllDescriptors
#define DumpAllUnits DumpAllUnitDescriptors
#define DumpUnitDesc DumpUnitDescriptor

#else

#define DumpDesc(a)
#define DumpAllDesc(a)
#define DumpAllUnits(a,b)
#define DumpUnitDesc(a)

#endif

#if DBG

#define DEBUGLVL_BLAB    4
#define DEBUGLVL_VERBOSE 3
#define DEBUGLVL_TERSE   2
#define DEBUGLVL_ERROR   1

#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_TERSE
#endif

extern ULONG DriverDebugLevel;

#define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= DriverDebugLevel) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        if ((lvl) == DEBUGLVL_ERROR) {\
             TRAP;\
        } \
    } \
}

#else

#define _DbgPrintF(lvl, strings)

#endif

#include "dbglog.h"

//------------------------------- End of File --------------------------------
#endif // #ifndef __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\debug.c ===
#include "common.h"

#if DBG
ULONG DriverDebugLevel = DEBUGLVL_TERSE;
#endif

#if DBG && DEBUG_LOG

LONG LogRefCnt = 0L;

PDBG_BUFFER LogPtr = NULL;
KSPIN_LOCK LogSpinLock;

#define DBG_LOG_DEPTH  1024

VOID
DbugLogInitialization(void)
{
    if (InterlockedIncrement(&LogRefCnt) == 1) {

        // First one here, so go ahead and initialize

        LogPtr = AllocMem( NonPagedPool, sizeof( DBG_BUFFER ));
        if ( !LogPtr ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Could NOT Allocate debug buffer ptr\n"));
            return;
        }
        LogPtr->pLog = AllocMem( NonPagedPool, sizeof(DBG_LOG_ENTRY)*DBG_LOG_DEPTH );
        if ( !LogPtr->pLog ) {
            FreeMem( LogPtr );
            LogPtr = NULL;
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Could NOT Allocate debug buffer\n"));
            return;
        }

        strcpy(LogPtr->LGFlag, "DBG_BUFFER");

        LogPtr->pLogHead = LogPtr->pLog;
        LogPtr->pLogTail = LogPtr->pLogHead + DBG_LOG_DEPTH - 1;
        LogPtr->EntryCount = 0;

        KeInitializeSpinLock(&LogSpinLock);
    }
}

VOID
DbugLogUnInitialization(void)
{
    if (InterlockedDecrement(&LogRefCnt) == 0) {

        // Last one out, free the buffer

        if (LogPtr) {
            FreeMem( LogPtr->pLog );
            FreeMem( LogPtr );
            LogPtr = NULL;
        }
    }
}

VOID
DbugLogEntry( 
    IN CHAR *Name,
    IN ULONG Info1,
    IN ULONG Info2,
    IN ULONG Info3,
    IN ULONG Info4
    )
/*++

Routine Description:

    Adds an Entry to log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (LogPtr == NULL)
        return;

    KeAcquireSpinLock( &LogSpinLock, &irql );
    if (LogPtr->pLogHead > LogPtr->pLog)
        LogPtr->pLogHead -= 1;    // Decrement to next entry
    else
        LogPtr->pLogHead = LogPtr->pLogTail;

    if (strlen(Name) > 7)
        strcpy(LogPtr->pLogHead->le_name, "*strER*");
    else
        strcpy(LogPtr->pLogHead->le_name, Name);
//    LogPtr->pLogHead->Irql = irql;
    KeQuerySystemTime( &LogPtr->pLogHead->SysTime );
    LogPtr->pLogHead->le_info1 = Info1;
    LogPtr->pLogHead->le_info2 = Info2;
    LogPtr->pLogHead->le_info3 = Info3;
    LogPtr->pLogHead->le_info4 = Info4;

    LogPtr->EntryCount++;

    KeReleaseSpinLock( &LogSpinLock, irql );

    return;
}

#endif

#if DBG && DBGMEMMAP

#pragma LOCKED_DATA
PMEM_TRACKER LogMemMap;
#pragma PAGEABLE_DATA

VOID
InitializeMemoryList( VOID )
{
   LogMemMap = ExAllocatePool( NonPagedPool, sizeof( MEM_TRACKER ) );
   if ( !LogMemMap ) {
       _DbgPrintF(DEBUGLVL_VERBOSE, ("MEMORY TRACKER ALLOCATION FAILED!!!"));
       TRAP;
   }
   LogMemMap->TotalBytes = 0;
   InitializeListHead( &LogMemMap->List );
   KeInitializeSpinLock( &LogMemMap->SpinLock );
   _DbgPrintF(DEBUGLVL_VERBOSE, ("'Initialize MEMORY TRACKER LogMemMap: %x\n",
               LogMemMap));
}

PVOID
USBAudioAllocateTrack(
    POOL_TYPE PoolType,
    ULONG NumberOfBytes
    )
{
    PVOID pMem;
    KIRQL irql;
    ULONG TotalReqSize = NumberOfBytes + sizeof(ULONG) + sizeof(LIST_ENTRY);

    if ( !(pMem = ExAllocatePool( PoolType, TotalReqSize ) ) ) {
        TRAP;
        return pMem;
    }
    
    RtlZeroMemory( pMem, TotalReqSize );

    KeAcquireSpinLock( &LogMemMap->SpinLock, &irql );
    InsertHeadList( &LogMemMap->List, (PLIST_ENTRY)pMem );
    LogMemMap->TotalBytes += NumberOfBytes;
    KeReleaseSpinLock( &LogMemMap->SpinLock, irql );

    pMem = (PLIST_ENTRY)pMem + 1;

    *(PULONG)pMem = NumberOfBytes;

    pMem = (PULONG)pMem + 1;

    return pMem;
}

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    )
{
    PULONG pNumberOfBytes = (PULONG)pMem - 1;
    PLIST_ENTRY ple = (PLIST_ENTRY)pNumberOfBytes - 1;
    KIRQL irql;

    KeAcquireSpinLock( &LogMemMap->SpinLock, &irql );
    RemoveEntryList(ple);
    LogMemMap->TotalBytes -= *pNumberOfBytes;
    KeReleaseSpinLock( &LogMemMap->SpinLock, irql );


    ExFreePool(ple);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\filter.c ===
#include "Common.h"

#ifdef PSEUDO_HID
extern const KSEVENT_SET HwEventSetTable[];
#endif

NTSTATUS
FilterCreate(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp )
{
    PKSFILTERFACTORY pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    NTSTATUS ntStatus = STATUS_SUCCESS;

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    if ( pKsFilterFactory ) {
        // Get device extension for filter context
        PKSDEVICE pKsDevice = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
 
        if ( pKsDevice ) {

            InterlockedIncrement(&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulFilterCount);

            pKsFilter->Context = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
        }
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    
	return ntStatus;
}

NTSTATUS
FilterClose(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp )
{
    PKSFILTERFACTORY pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    NTSTATUS ntStatus = STATUS_SUCCESS;

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    if ( pKsFilterFactory ) {
        // Get device extension for filter context
        PKSDEVICE pKsDevice = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
 
        if ( pKsDevice )
            InterlockedDecrement(&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulFilterCount);
    }

    return ntStatus;
}

const
KSFILTER_DISPATCH
KsFilterDispatch =
{
    FilterCreate,
    FilterClose,
    NULL,
    NULL
};

NTSTATUS
FilterCreateKsFilterContext( 
    PKSDEVICE pKsDevice,
    PBOOLEAN  pGrouping )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pKsFilterDescriptor = &pHwDevExt->KsFilterDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSPROPERTY_ITEM pDevPropItems;
    PKSPROPERTY_SET pDevPropSet;
    ULONG ulNumPropItems = 1;
    ULONG ulNumPropSets = 1;

    PAGED_CODE();

    // Check if device is part of a group. If so take care of it. If not, continue.
    ntStatus = GroupingDeviceGroupSetup( pKsDevice );
    if ( ntStatus == STATUS_DEVICE_BUSY ) {
        *pGrouping = TRUE;
        return ntStatus;
    }

    RtlZeroMemory( pKsFilterDescriptor, sizeof(KSFILTER_DESCRIPTOR) );

    // Fill in static values of KsFilterDescriptor
    pKsFilterDescriptor->Dispatch      = &KsFilterDispatch;
    pKsFilterDescriptor->ReferenceGuid = &KSNAME_Filter;
    pKsFilterDescriptor->Version       = KSFILTER_DESCRIPTOR_VERSION;
    pKsFilterDescriptor->Flags         = 0;

    // Build the descriptors for the device pins
    ntStatus = PinBuildDescriptors( pKsDevice, 
                                    (PKSPIN_DESCRIPTOR_EX *)&pKsFilterDescriptor->PinDescriptors, 
                                    &pKsFilterDescriptor->PinDescriptorsCount,
                                    &pKsFilterDescriptor->PinDescriptorSize );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Topology for the device filter
    ntStatus = BuildFilterTopology( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Filter Property Sets
    BuildFilterPropertySet( pKsFilterDescriptor,
                            NULL,
                            NULL,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsAutomationTable = 
		(PKSAUTOMATION_TABLE)AllocMem( NonPagedPool, 
		                               sizeof(KSAUTOMATION_TABLE) +
                                       (ulNumPropItems * sizeof(KSPROPERTY_ITEM)) +
                                       (ulNumPropSets  * sizeof(KSPROPERTY_SET)));

    if (!pKsAutomationTable ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsAutomationTable, FreeMem);

    RtlZeroMemory(pKsAutomationTable, sizeof(KSAUTOMATION_TABLE));

    pDevPropItems = (PKSPROPERTY_ITEM)(pKsAutomationTable + 1);
    pDevPropSet   = (PKSPROPERTY_SET)(pDevPropItems + ulNumPropItems);

    BuildFilterPropertySet( pKsFilterDescriptor,
                            pDevPropItems,
                            pDevPropSet,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsFilterDescriptor->AutomationTable = (const KSAUTOMATION_TABLE *)pKsAutomationTable;
    pKsAutomationTable->PropertySetsCount = ulNumPropSets;
    pKsAutomationTable->PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
    pKsAutomationTable->PropertySets      = (const KSPROPERTY_SET *)pDevPropSet;

#ifdef PSEUDO_HID
    pKsAutomationTable->EventSetsCount    = 1;
    pKsAutomationTable->EventItemSize     = sizeof(KSEVENT_ITEM);
    pKsAutomationTable->EventSets         = HwEventSetTable;
#endif

    pHwDevExt->bFilterContextCreated = TRUE;

    return STATUS_SUCCESS;

}

NTSTATUS
FilterCreateFilterFactory(
    PKSDEVICE pKsDevice,
    BOOLEAN fEnableInterfaces )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pKsFilterDescriptor = &pHwDevExt->KsFilterDescriptor;
    BOOLEAN fGrouping = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( !pHwDevExt->bFilterContextCreated ) {
        ntStatus = FilterCreateKsFilterContext( pKsDevice, &fGrouping );
    }

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = KsCreateFilterFactory( pKsDevice->FunctionalDeviceObject,
                                          pKsFilterDescriptor,
                                          L"GLOBAL",
                                          NULL,
                                          0,
                                          NULL, // Sleep Callback
                                          NULL, // Wake Callback
                                          &pHwDevExt->pKsFilterFactory );

        if ( NT_SUCCESS(ntStatus) && fEnableInterfaces ) {
            ntStatus = KsFilterFactorySetDeviceClassesState (pHwDevExt->pKsFilterFactory, TRUE);
        }
    }
    else if ( fGrouping && ( ntStatus == STATUS_DEVICE_BUSY ) ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;    
}

NTSTATUS
FilterDestroyFilterFactory(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    NTSTATUS ntStatus = KsDeleteFilterFactory(pHwDevExt->pKsFilterFactory);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("FilterDestroyFilterFactory: %x\n", ntStatus) );

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\device.c ===
#include "Common.h"

#define DEFAULT_PLUG_COUNT	2

AVC_SUBUNIT_GLOBAL_INFO AvcSubunitGlobalInfo;

#ifdef VIRTUAL_DEVICE
NTSTATUS
VAvcInitializeDevice(
    PKSDEVICE pKsDevice );

NTSTATUS
RegistryReadVirtualDeviceEntry(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfVirtualDevice );
#endif

NTSTATUS
AvcUnitInfoInitialize(  
    IN PKSDEVICE pKsDevice );

void
iPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo );

void
oPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo );

NTSTATUS
AvcSubunitInitialize( 
    PKSDEVICE pKsDevice );

NTSTATUS
DeviceCreate(
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);

    // Create the Hardware Device Extension
    pHwDevExt = AllocMem(NonPagedPool, sizeof(HW_DEVICE_EXTENSION) );
    if ( !pHwDevExt ) return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt, FreeMem);

    RtlZeroMemory(pHwDevExt, sizeof(HW_DEVICE_EXTENSION));

    pKsDevice->Context = pHwDevExt;

    pHwDevExt->pKsDevice = pKsDevice;

#ifdef VIRTUAL_DEVICE
    // Determine if this is an actual device or a virtual device.
    ntStatus = RegistryReadVirtualDeviceEntry( pKsDevice, &pHwDevExt->fVirtualSubunitFlag );
    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;    
#endif

    // Initialize Debug log
    DbgLogInit();
    DbgLog("TEST",1,2,3,4);

    // Create the 61883 command lookaside
    ExInitializeNPagedLookasideList(
        &pHwDevExt->Av61883CmdLookasideList,
        NULL,
        NULL,
        0,
        sizeof(AV_61883_REQUEST) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    // Initialize AV/C Request packet lookaside lists
    ExInitializeNPagedLookasideList(
        &pHwDevExt->AvcCommandLookasideList,
        NULL,
        NULL,
        0,
        sizeof(AVC_COMMAND_IRB) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    ExInitializeNPagedLookasideList(
        &pHwDevExt->AvcMultifuncCmdLookasideList,
        NULL,
        NULL,
        0,
        sizeof(AVC_MULTIFUNC_IRB) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    InitializeListHead( &pHwDevExt->List );

    return ntStatus;
}

NTSTATUS
AddToDeviceExtensionList(
    IN PKSDEVICE pKsDevice
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fFirstDevice = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL kIrql;

    ExAcquireFastMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorFMutex);

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    // The device can only be added once, make sure we haven't already done this
    if (IsListEmpty( &pHwDevExt->List )) {

        // Check if this will be the first device on the global list
        if (IsListEmpty( &AvcSubunitGlobalInfo.DeviceExtensionList )) {
            fFirstDevice = TRUE;
        }

        InsertTailList( &AvcSubunitGlobalInfo.DeviceExtensionList, &pHwDevExt->List );
    }

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    // If not done already, create initial Unit plugs
    if ( fFirstDevice ) {
        ntStatus = Av61883CreateVirtualSerialPlugs( pKsDevice, 
                                                    DEFAULT_PLUG_COUNT, 
                                                    DEFAULT_PLUG_COUNT );
        if ( NT_SUCCESS(ntStatus) ) {
            ntStatus = Av61883CreateVirtualExternalPlugs( pKsDevice,
                                                          DEFAULT_PLUG_COUNT, 
                                                          DEFAULT_PLUG_COUNT );
        }
    }

    ExReleaseFastMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorFMutex);

    return ntStatus;
}

void
RemoveFromDeviceExtensionList(
    IN PKSDEVICE pKsDevice
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fLastDevice = FALSE;
    KIRQL kIrql;

    ExAcquireFastMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorFMutex);

    // Remove the device extension from the global list
    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    // The device can only be removed once, make sure we haven't already done this
    if ( !IsListEmpty( &pHwDevExt->List ) ) {

        RemoveEntryList( &pHwDevExt->List );
        InitializeListHead( &pHwDevExt->List );

        // Check if this was the last device on the global list
        if (IsListEmpty( &AvcSubunitGlobalInfo.DeviceExtensionList )) {
            fLastDevice = TRUE;
        }
    }

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    // If the last one here, need to destroy created CMP registers
    if ( fLastDevice ) {
        Av61883RemoveVirtualSerialPlugs( pKsDevice );
        Av61883RemoveVirtualExternalPlugs( pKsDevice );
    }
    else {
        if ( !pHwDevExt->fSurpriseRemoved && pHwDevExt->fPlugMonitor ) {
            PHW_DEVICE_EXTENSION pNextHwDevExt = NULL;

            Av61883CMPPlugMonitor( pKsDevice, FALSE );
            pHwDevExt->fPlugMonitor = FALSE;

            // Get the next device on the global list and give it this burden
            // (note that the only routines that change the global list also
            // hold AvcPlugMonitorFMutex, so no need to grab the spin lock)
            pNextHwDevExt = (PHW_DEVICE_EXTENSION)AvcSubunitGlobalInfo.DeviceExtensionList.Flink;

            if ( NT_SUCCESS(Av61883CMPPlugMonitor( pNextHwDevExt->pKsDevice, TRUE )) ) {
                pNextHwDevExt->fPlugMonitor = TRUE;
            }
        }
    }

    ExReleaseFastMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorFMutex);

    return;
}

NTSTATUS
DeviceStart(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fVirtualSubunitFlag = FALSE;
    ULONG ulDiagLevel = DIAGLEVEL_NONE;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceStart]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);

    // If returning after a STOP, then just restart the timer DPC
    if (pHwDevExt->fStopped) {
#ifdef PSEUDO_HID
        ntStatus = TimerInitialize( pKsDevice );
#endif
        pHwDevExt->fStopped = FALSE;

        return ntStatus;
    }

    // Make it so that 61883 will not try to assign a broadcast address
    // to a plug when disconnected.
    ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                      Av61883_SetUnitInfo,
                                      SET_UNIT_INFO_DIAG_LEVEL,
                                      &ulDiagLevel );

    // Go on if this fails. It SHOULD not matter.

#if DBG
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }
#endif

    ntStatus = AddToDeviceExtensionList(pKsDevice);
    if ( NT_SUCCESS(ntStatus) ) {

#ifdef VIRTUAL_DEVICE
        if ( fVirtualSubunitFlag ) {
            ntStatus = VAvcInitializeDevice( pKsDevice );
        }
        else
#endif
        {
            ntStatus = AvcUnitInfoInitialize ( pKsDevice );
            if ( NT_SUCCESS(ntStatus) ) {
                ntStatus = AvcSubunitInitialize( pKsDevice );

                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = FilterCreateFilterFactory( pKsDevice, FALSE );
                    if (NT_SUCCESS(ntStatus)) {
                        ntStatus = Av61883RegisterForBusResetNotify( pKsDevice,
                                                                    REGISTER_BUS_RESET_NOTIFY );
#ifdef PSEUDO_HID
                        if (NT_SUCCESS(ntStatus)) {
                            ntStatus = TimerInitialize( pKsDevice );
                        }
#endif
                    }
                }
            }
        }
    }

    return ntStatus;
}

NTSTATUS
DevicePostStart (
    IN PKSDEVICE Device )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DevicePostStart]\n"));

    PAGED_CODE();

    ASSERT(Device);

    return STATUS_SUCCESS;
}

NTSTATUS
DeviceQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceQueryStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCancelStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
DeviceStop(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceStop]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    if ( !pHwDevExt->fStopped ) {
#ifdef PSEUDO_HID
        TimerStop( pHwDevExt );
#endif
        pHwDevExt->fStopped = TRUE;
    }

}

NTSTATUS
DeviceQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCancelRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
DeviceRemove(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    KIRQL kIrql;
    NTSTATUS ntStatus;
    ULONG j;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceRemove]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);

    // Only do this once
    if ( pHwDevExt->fRemoved ) return;
    pHwDevExt->fRemoved = TRUE;

    if ( !pHwDevExt->fStopped ) {

#ifdef PSEUDO_HID
        TimerStop( pHwDevExt );
#endif
        // Do not set fStopped to TRUE here... this is a REMOVE not a STOP
    }

    Av61883RegisterForBusResetNotify( pKsDevice, DEREGISTER_BUS_RESET_NOTIFY );

    RemoveFromDeviceExtensionList( pKsDevice );

    ExDeleteNPagedLookasideList ( &pHwDevExt->Av61883CmdLookasideList );
    ExDeleteNPagedLookasideList ( &pHwDevExt->AvcCommandLookasideList );
    ExDeleteNPagedLookasideList ( &pHwDevExt->AvcMultifuncCmdLookasideList );

    // Need to free up debug log resources
    DbgLogUnInit();
}

NTSTATUS
DeviceQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES pCapabilities )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DeviceQueryCapabilities]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    pCapabilities->Size              = sizeof(DEVICE_CAPABILITIES);
    pCapabilities->Version           = 1;  // the version documented here is version 1
    pCapabilities->LockSupported     = FALSE;
    pCapabilities->EjectSupported    = FALSE; // Ejectable in S0
    pCapabilities->Removable         = TRUE;
    pCapabilities->DockDevice        = FALSE;
    pCapabilities->UniqueID          = FALSE;
    pCapabilities->SilentInstall     = TRUE;
    pCapabilities->RawDeviceOK       = FALSE;
    pCapabilities->SurpriseRemovalOK = TRUE;
    pCapabilities->HardwareDisabled  = FALSE;

    pCapabilities->DeviceWake        = PowerDeviceUnspecified;
    pCapabilities->D1Latency         = 0;
    pCapabilities->D2Latency         = 0;
    pCapabilities->D3Latency         = 20000; // 2 Seconds (in 100 usec units)

    return STATUS_SUCCESS;
}

void
DeviceSurpriseRemoval(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    ULONG i;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceSurpriseRemoval]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // For each filter, Check for open pins. If found Close them.
    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            // Find each open pin for this open filter
            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                while (pKsPin) {

                    PinSurpriseRemove( pKsPin );

                    // Get the next pin
                    pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fSurpriseRemoved = TRUE;
}

NTSTATUS
DeviceQueryPowerState (
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action
)
{

    _DbgPrintF(DEBUGLVL_VERBOSE,("[DeviceQueryPowerState]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceSetPowerState(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceSetPowerState]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

const
KSDEVICE_DISPATCH
KsDeviceDispatchTable =
{
    DeviceCreate,
    DeviceStart,
    NULL, // DevicePostStart,
    DeviceQueryStop,
    DeviceCancelStop,
    DeviceStop,
    DeviceQueryRemove,
    DeviceCancelRemove,
    DeviceRemove,
    DeviceQueryCapabilities,
    DeviceSurpriseRemoval,
    DeviceQueryPowerState,
    DeviceSetPowerState
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\drivrent.c ===
#include "common.h"

#ifdef TIME_BOMB
#include "..\..\timebomb\timebomb.c"
#endif

extern const
KSDEVICE_DISPATCH
KsDeviceDispatchTable;

const
KSDEVICE_DESCRIPTOR
KsDeviceDescriptor =
{
    &KsDeviceDispatchTable,
    0,
    NULL
};

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName )
{
    ULONG i;
    _DbgPrintF(DEBUGLVL_TERSE,("[DriverEntry]\n"));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
    #endif

    // Initialize Global Information
    AvcSubunitGlobalInfo.ulVirtualSubunitCount = 0;

    for ( i=CMP_PlugOut; i<=CMP_PlugIn; i++ ) {
        AvcSubunitGlobalInfo.UnitSerialBusPlugs[i].ulCount = 0;
        AvcSubunitGlobalInfo.UnitExternalPlugs[i].ulCount = 0;
        InitializeListHead(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[i].List);
        InitializeListHead(&AvcSubunitGlobalInfo.UnitExternalPlugs[i].List);
    }

    InitializeListHead(&AvcSubunitGlobalInfo.UnitPlugConnections);
    InitializeListHead(&AvcSubunitGlobalInfo.DeviceExtensionList);
    InitializeListHead(&AvcSubunitGlobalInfo.VirtualDeviceExtensionList);
    InitializeListHead(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList);

    KeInitializeSpinLock(&AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock);
    ExInitializeFastMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorFMutex);

    return
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &KsDeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\device.h ===
#ifndef ___FW_DEVICE_H___
#define ___FW_DEVICE_H___

#define FWAUDIO_POOLTAG 'UAWF'

//========================================================================

typedef struct {
    ULONG ulCount;
    LIST_ENTRY List;
} UNIT_PLUG_SET, *PUNIT_PLUG_SET;

typedef struct {
    ULONG ulVirtualSubunitCount;
    LIST_ENTRY DeviceExtensionList;
    LIST_ENTRY VirtualDeviceExtensionList;
    LIST_ENTRY DeviceInterfaceSymlinkList;
    LIST_ENTRY UnitPlugConnections;
    UNIT_PLUG_SET UnitSerialBusPlugs[2];
    UNIT_PLUG_SET UnitExternalPlugs[2];
    ULONG ulUnitPlugConnectionCount;
    KSPIN_LOCK AvcGlobalInfoSpinlock;
    FAST_MUTEX AvcPlugMonitorFMutex;
} AVC_SUBUNIT_GLOBAL_INFO, *PAVC_SUBUNIT_GLOBAL_INFO;

extern AVC_SUBUNIT_GLOBAL_INFO AvcSubunitGlobalInfo;

typedef struct _HW_DEVICE_EXTENSION HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

// Hardware device extension
typedef struct _HW_DEVICE_EXTENSION {

    LIST_ENTRY List;

    PKSDEVICE pKsDevice;

    ULONG ulFilterCount;

    BOOLEAN fVirtualSubunitFlag;

    BOOLEAN fPlugMonitor;

    BOOLEAN fStopped;

    BOOLEAN fRemoved;

    BOOLEAN fSurpriseRemoved;

    NODE_ADDRESS NodeAddress;
    ULONG ulGenerationCount;

    PVOID pAvcUnitInformation;

    PVOID pAvcSubunitInformation;

#ifdef PSEUDO_HID
    KSPIN_LOCK TimerSpinLock;
    KDPC TimerDPC;
    KTIMER kTimer;
    KEVENT kTimerWIEvent;
    WORK_QUEUE_ITEM TimerWorkItem;
    BOOLEAN bTimerWorkItemQueued;
#endif

    WORK_QUEUE_ITEM BusResetWorkItem;

    BOOLEAN bFilterContextCreated;
    PKSFILTERFACTORY pKsFilterFactory;
    KSFILTER_DESCRIPTOR KsFilterDescriptor;

    NPAGED_LOOKASIDE_LIST Av61883CmdLookasideList;

    NPAGED_LOOKASIDE_LIST AvcCommandLookasideList;

    NPAGED_LOOKASIDE_LIST AvcMultifuncCmdLookasideList;

};

#endif // ___FW_DEVICE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\hwevent.h ===
#ifndef ___AVCAUDIO_HARDWARE_EVENT_H___
#define ___AVCAUDIO_HARDWARE_EVENT_H___

#ifdef PSEUDO_HID
// EVENT Set for node hardware events.
static DEFINE_KSEVENT_TABLE(HwEventItem) {
    DEFINE_KSEVENT_ITEM( KSEVENT_CONTROL_CHANGE,
                         sizeof(KSEVENTDATA),
                         sizeof(ULONG) + sizeof(PTOPOLOGY_NODE_INFO),
                         HwEventAddHandler,
                         HwEventRemoveHandler,
                         HwEventSupportHandler )
};

DEFINE_KSEVENT_SET_TABLE( HwEventSetTable ) {
    DEFINE_KSEVENT_SET( &KSEVENTSETID_AudioControlChange,
                        1,
                        HwEventItem )
};
#endif

#endif //___AVCAUDIO_HARDWARE_EVENT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\hwevent.c ===
#include "Common.h"

typedef struct {
    KSEVENT_ENTRY KsEventEntry;
    ULONG ulNodeId;
    PTOPOLOGY_NODE_INFO pNodeInfo;
} HW_KSEVENT_ENTRY, *PHW_KSEVENT_ENTRY;

NTSTATUS
HwEventAddHandler(
    IN PIRP pIrp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;

    if ( pKsFilter ) { 
    
        pHwKsEventEntry->ulNodeId = KsGetNodeIdFromIrp( pIrp );

        pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter, pHwKsEventEntry->ulNodeId);
        pHwKsEventEntry->pNodeInfo = pNodeInfo;

        pNodeInfo->ulEventsEnabled++;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Events Enabled for node: %d Filter: %x NodeInfo: %x\n",
                                      pHwKsEventEntry->ulNodeId, pKsFilter, pNodeInfo) );

        ntStatus = KsDefaultAddEventHandler( pIrp, pEventData, pEventEntry );
    }

    return ntStatus;
}

VOID
HwEventRemoveHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;

    RemoveEntryList(&pEventEntry->ListEntry);

    pHwKsEventEntry->pNodeInfo->ulEventsEnabled--;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Events Disabled for node: %d NodeInfo: %x\n",
                                  pHwKsEventEntry->ulNodeId, pHwKsEventEntry->pNodeInfo ) );
}

NTSTATUS
HwEventSupportHandler(
    IN PIRP pIrp,
    IN PKSEVENT pKsEvent,
    IN OUT PVOID Data )
{
    PKSE_NODE pKsNodeEvent = (PKSE_NODE)pKsEvent;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[HwEventSupportHandler]: pKsFilter: %x \n", pKsFilter) );

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter, pKsNodeEvent->NodeId);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[HwEventSupportHandler]: NodeId: %x pKsFilter: %x pNodeInfo: %x\n",
                                  pKsNodeEvent->NodeId, pKsFilter, pNodeInfo) );

    if ( pNodeInfo->fEventable ) ntStatus = STATUS_SUCCESS;

    return ntStatus;

}

BOOLEAN
HwEventGenerateOnNodeCallback(
    IN PVOID Context,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;
    
    return ( *(PULONG)Context == pHwKsEventEntry->ulNodeId );
}

VOID
HwEventGenerateOnNode(
    PKSDEVICE pKsDevice,
    PULONG pNodeId )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;

    KsAcquireDevice( pKsDevice );

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {

        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterGenerateEvents( pKsFilter,
                                    &KSEVENTSETID_AudioControlChange,
                                    KSEVENT_CONTROL_CHANGE,
                                    0,
                                    NULL,
                                    HwEventGenerateOnNodeCallback,
                                    pNodeId );


            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );

        }

        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    KsReleaseDevice( pKsDevice );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\nameguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nameguid.h
//
//--------------------------------------------------------------------------


#define STATIC_USBNODENAME_BassBoost \
    0x1A71EBE0L, 0x959E, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1

#define STATIC_USBNODENAME_StereoExtender \
    0xFD4F0300L, 0x9632, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\property.c ===
#include "Common.h"

#include "Property.h"

#define MAXPINNAME      256

#define DB_SCALE_16BIT 0x100
#define DB_SCALE_8BIT  0x4000

#define MAX_EQ_BANDS 30

#define NEGATIVE_INFINITY 0xFFFF8000

#define MASTER_CHANNEL 0xffffffff

// extern ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pKsPropPin, PVOID pData )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PKSDEVICE pKsDevice;
    ULONG BufferLength;
    PWCHAR StringBuffer;
    ULONG StringLength;
    ULONG ulPinIndex;
    NTSTATUS Status;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;

    pKsDevice = (PKSDEVICE)pKsFilter->Context;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] pKsPropPin->PinId %x\n",
                                 pKsPropPin->PinId));

    BufferLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.OutputBufferLength;

    // Get the Friendly name for this device and append a subscript if there
    // is more than one pin on this device.

    StringBuffer = AllocMem(NonPagedPool, MAXPINNAME);
    if (!StringBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoGetDeviceProperty(
        pKsDevice->PhysicalDeviceObject,
        DevicePropertyDeviceDescription,
        MAXPINNAME,
        StringBuffer,
        &StringLength);

    if(!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] IoGetDeviceProperty failed(%x)\n", Status));
        FreeMem(StringBuffer);
        return Status;
    }

    //  Compute actual length adding the pin subscript
    if (!BufferLength) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] StringLength: %x\n",StringLength));
        pIrp->IoStatus.Information = StringLength;
        Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (BufferLength < StringLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else {
        BufferLength = BufferLength / sizeof(WCHAR);
        wcsncpy(pData, StringBuffer, min(BufferLength,MAXPINNAME));
        StringLength = (wcslen(pData) + 1) * sizeof(WCHAR);
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] String: %ls\n",pData));
        ASSERT(StringLength <= BufferLength * sizeof(WCHAR));
        pIrp->IoStatus.Information = StringLength;
        Status = STATUS_SUCCESS;
    }

    FreeMem(StringBuffer);

    return Status;
}

NTSTATUS DrmAudioStream_SetContentId (
    IN PIRP                          pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pData )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PKSPIN pKsPin = KsGetPinFromIrp(pIrp);
    PPIN_CONTEXT pPinContext;
    PKSDEVICE pKsDevice;
    DRMRIGHTS DrmRights;
    ULONG ContentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( !(pKsPin && pKsFilter) ) return STATUS_INVALID_PARAMETER;
    pPinContext = pKsPin->Context;
    pKsDevice = (PKSDEVICE)pKsFilter->Context;

    KsPinAcquireProcessingMutex(pKsPin);

    // Extract content ID and rights
    ContentId = pData->ContentId;
    DrmRights = pData->DrmRights;

    // If device has digital outputs and rights require them disabled,
    //  then we fail since we have no way to disable the digital outputs.
    if ( DrmRights.DigitalOutputDisable ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmAudioStream_SetContentId] Content has digital disabled\n"));
        ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        ASSERT(pProperty->DrmForwardContentToDeviceObject);

        // Forward content to common class driver PDO
        ntStatus = pProperty->DrmForwardContentToDeviceObject( ContentId,
                                                               pKsDevice->NextDeviceObject,
                                                               pPinContext->hConnection );
    }

    //  Store this in the pin context because we need to reforward if the pipe handle
    //  changes due to a power state change.
    pPinContext->DrmContentId = ContentId;

    KsPinReleaseProcessingMutex(pKsPin);

    return ntStatus;
}

typedef struct {
    FEATURE_FBLOCK_COMMAND FeatureCmd;
    UCHAR ucDataLength;
    UCHAR ucValueHigh;
    UCHAR ucValueLow;
} DBLEVEL_FEATURE_REQUEST, *PDBLEVEL_FEATURE_REQUEST;

NTSTATUS
CreateFeatureFBlockRequest( 
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannelIndx,
    PVOID pData,
    ULONG ulByteCount,
    USHORT usRequestType )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;

    PFBLOCK_REQUEST_TYPE pFBReqType = (PFBLOCK_REQUEST_TYPE)&usRequestType;
    PSOURCE_ID pSourceId = (PSOURCE_ID)&pNodeInfo->ulBlockId;
    DBLEVEL_FEATURE_REQUEST DbLvlReq;
    PUCHAR pcData = (PUCHAR)pData;
    ULONG i=0;
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;

    DbLvlReq.FeatureCmd.Common.FBlockId = *pSourceId;
    DbLvlReq.FeatureCmd.Common.ucControlAttribute = pFBReqType->ucControlAttribute;

    DbLvlReq.FeatureCmd.ucControlSelector = (UCHAR)pNodeInfo->ulControlType;
    DbLvlReq.FeatureCmd.ucSelectorLength = 2;
    DbLvlReq.FeatureCmd.ucChannelNumber  = (UCHAR)ulChannelIndx;
    DbLvlReq.ucDataLength = (UCHAR)ulByteCount;
    DbLvlReq.ucValueHigh  = (ulByteCount & 1) ? pcData[0] : pcData[1];
    DbLvlReq.ucValueLow   = pcData[0];

    // Check for device grouping and act accordingly
    if ( pGrpInfo ) {
        // If this is a Master Channel.

#ifdef MASTER_FIX
        if ( pNodeInfo->fMasterChannel )
#else
        if ( ulChannelIndx == 0 )
#endif
        {
            ASSERT( ulChannelIndx == 0 );
            if (pFBReqType->ucControlType == AVC_CTYPE_CONTROL) {
                // Loop through each device in the group and send the same value.
                i=0;
                do {
                    ntStatus = AudioFunctionBlockCommand( pGrpInfo->pHwDevExts[i++]->pKsDevice,
                                                          pFBReqType->ucControlType,
                                                          &DbLvlReq,
                                                          (ulByteCount & 1) ?
                                                              sizeof(DBLEVEL_FEATURE_REQUEST)-1 :
                                                              sizeof(DBLEVEL_FEATURE_REQUEST));    
                } while ( NT_SUCCESS(ntStatus) && (i<pGrpInfo->ulDeviceCount) );
            }
            else {
                ntStatus = AudioFunctionBlockCommand( pKsDevice,
                                                      pFBReqType->ucControlType,
                                                      &DbLvlReq,
                                                      (ulByteCount & 1) ?
                                                         sizeof(DBLEVEL_FEATURE_REQUEST)-1 :
                                                         sizeof(DBLEVEL_FEATURE_REQUEST));
            }
        }
        else {
            // Find the correct extension for the channel.
            PHW_DEVICE_EXTENSION pChHwDevExt = GroupingFindChannelExtension( pKsDevice, &ulChannelIndx );

            if ( pChHwDevExt ) {
                DbLvlReq.FeatureCmd.ucChannelNumber = (UCHAR)ulChannelIndx;
                ntStatus = 
                       AudioFunctionBlockCommand( pChHwDevExt->pKsDevice,
                                                  pFBReqType->ucControlType,
                                                  &DbLvlReq,
                                                  (ulByteCount & 1) ?
                                                     sizeof(DBLEVEL_FEATURE_REQUEST)-1 :
                                                     sizeof(DBLEVEL_FEATURE_REQUEST));
            }
        }
    }
    else {
        ntStatus = AudioFunctionBlockCommand( pKsDevice,
                                              pFBReqType->ucControlType,
                                              &DbLvlReq,
                                              (ulByteCount & 1) ?
                                                 sizeof(DBLEVEL_FEATURE_REQUEST)-1 :
                                                 sizeof(DBLEVEL_FEATURE_REQUEST));
    }

    if ( NT_SUCCESS(ntStatus) ) {
        if (ulByteCount & 1) {
            pcData[0] = DbLvlReq.ucValueHigh;
            pcData[1] = 0;
        }
        else {
            pcData[0] = DbLvlReq.ucValueLow;
            pcData[1] = DbLvlReq.ucValueHigh;
        }
    }

    return ntStatus;
}

NTSTATUS
UpdateDbLevelControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged )
{
    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG ulByteCount;
    LONG lData;
    ULONG i;

    if ( pNodeInfo->ulControlType != VOLUME_CONTROL ) {
        ulByteCount = 1;
        lData = 0x7F;
    } 
    else {
        ulByteCount = 2;
        lData = 0x7FFF;
    }

    *pfChanged = FALSE;

    for ( i=0; i<pNodeInfo->ulNumCachedValues; i++ ) {
        ntStatus = CreateFeatureFBlockRequest(  pKsDevice, 
                                                pNodeInfo,
                                                pDbCache[i].ulChannelIndex,
                                                &lData,
                                                ulByteCount, 
                                                (USHORT)(FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS) );
        if ( NT_SUCCESS(ntStatus) ) {
            LONG lDelta = pDbCache[i].Range.SteppingDelta;
            LONG lCurrentCacheValue = pDbCache[i].lLastValueSet;

            // Determine if this value is within range of what is cached. If so
            // no update is necessary. If not, update the cache and set changed flag.
            if ( ulByteCount == 2 ) {
                lData = (LONG)((SHORT)lData) * DB_SCALE_16BIT;
            }
            else {
                lData = (LONG)((CHAR)lData) * DB_SCALE_8BIT;
            }
            if (( lData <= lCurrentCacheValue-lDelta ) ||
                ( lData >= lCurrentCacheValue+lDelta )) {
                // Update the Cache and set the changed flag
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Control Level Change %x to %x\n", 
                                                lCurrentCacheValue, lData ));
                pDbCache[i].lLastValueSet = lData;
                *pfChanged = TRUE;
            }
        }
        else {
            *pfChanged = FALSE;
        }
    }

    return ntStatus;
}

NTSTATUS
UpdateBooleanControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged )
{
    PBOOLEAN_CTRL_CACHE pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;
    ULONG ulAvcBoolean = 0xFF;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;

    *pfChanged = FALSE;

    for ( i=0; i<pNodeInfo->ulNumCachedValues; i++ ) {
        ntStatus = CreateFeatureFBlockRequest(  pKsDevice, 
                                                pNodeInfo,
                                                pBoolCache[i].ulChannelIndex,
                                                &ulAvcBoolean,
                                                1, 
                                                (USHORT)(FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS) );
        if ( NT_SUCCESS(ntStatus) ) {
            ulAvcBoolean = ( ulAvcBoolean == AVC_ON ) ? TRUE : FALSE;
            if ( pBoolCache->fLastValueSet != ulAvcBoolean ) {
                pBoolCache->fLastValueSet = ulAvcBoolean;
                *pfChanged = TRUE;
            }
        }
        else {
            *pfChanged = FALSE;
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetDBLevel(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PLONG plData,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    USHORT usRequestType )
{
    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lScaleFactor;
    LONG lData;
    PUCHAR pcData = (PUCHAR)&lData;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetSetDBLevel] ulChannel: %x lData: %x\n",ulChannel, *plData) );

    // Determine if this request is beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    if ( !(pNodeInfo->ulCacheValid & (1<<ulChannel) ) ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pDbCache += ulChannel;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    lScaleFactor = ( ulDataBitCount == 8 ) ? DB_SCALE_8BIT : DB_SCALE_16BIT;

    switch( usRequestType>>8 ) {
        case AVC_CTYPE_STATUS:
            *plData = pDbCache->lLastValueSet;
            ntStatus = STATUS_SUCCESS;
            break;
        case AVC_CTYPE_CONTROL:
            if ( *plData == pDbCache->lLastValueSet ) {
                ntStatus = STATUS_SUCCESS;
            }
            else {
                if ( *plData < pDbCache->Range.Bounds.SignedMinimum ) {
                    if ( ulDataBitCount == 16 )
                        lData = NEGATIVE_INFINITY; // Detect volume control to silence
                    else
                        lData = pDbCache->Range.Bounds.SignedMinimum / lScaleFactor;
                }
                else if ( *plData > pDbCache->Range.Bounds.SignedMaximum ) {
                    lData = pDbCache->Range.Bounds.SignedMaximum / lScaleFactor;
                }
                else  {
                    lData = *plData / lScaleFactor;
                }

                _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetSetDBLevel] ulChannelIndex: %x lData: %x\n",
                                                pDbCache->ulChannelIndex, lData) );

                ntStatus = 
                     CreateFeatureFBlockRequest(  pKsDevice, 
                                                  pNodeInfo,
                                                  pDbCache->ulChannelIndex,
                                                  &lData,
                                                  ulDataBitCount>>3, 
                                                  usRequestType );

                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = *plData;
                }
            }
            break;
        default:
            ntStatus  = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

#if DBG
    if (!NT_SUCCESS(ntStatus) ) TRAP;
#endif

    return ntStatus;
}

NTSTATUS
GetDbLevelRange(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lData;
    USHORT usRequestType;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    for ( usRequestType=FB_CTRL_ATTRIB_RESOLUTION; 
                usRequestType<=FB_CTRL_ATTRIB_MAXIMUM; 
                      usRequestType++ ) {

        lData = (ulDataBitCount == 16) ? 0x7FFF : 0x7F;

        ntStatus = 
             CreateFeatureFBlockRequest( pKsDevice,
                                         pNodeInfo,
                                         ulChannel,
                                         &lData,
                                         ulDataBitCount>>3,
                                         (USHORT)(usRequestType | FB_CTRL_TYPE_STATUS));

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetDbLevelRange ERROR: %x\n",ntStatus));
            break;
        }
        else {
            if ( ulDataBitCount == 8 ) {
                lData = (LONG)((CHAR)lData)  * DB_SCALE_8BIT;
            }
            else {
                lData = (LONG)((SHORT)lData) * DB_SCALE_16BIT;
            }

            switch( usRequestType ) {
                case FB_CTRL_ATTRIB_MINIMUM:
                    pRange->Bounds.SignedMinimum = lData;
                    break;
                case FB_CTRL_ATTRIB_MAXIMUM:
                    pRange->Bounds.SignedMaximum = lData;
                    break;
                case FB_CTRL_ATTRIB_RESOLUTION:
                    pRange->SteppingDelta = lData;
                    break;
            }
        }

        DbgLog("DBRnge", ntStatus, pRange, usRequestType, pNodeInfo );
    }

    return ntStatus;
}

NTSTATUS
InitializeDbLevelCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount )
{
    NTSTATUS ntStatus;
    LONG lScaleFactor;
    LONG lData;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        lData = 0x7F;
    } 
    else {
        lScaleFactor = DB_SCALE_16BIT;
        lData = 0x7FFF;
    }

    ntStatus = GetDbLevelRange( pKsDevice,
                                pNodeInfo,
                                pDbCache->ulChannelIndex,
                                ulDataBitCount,
                                &pDbCache->Range );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = CreateFeatureFBlockRequest( pKsDevice,
                                         pNodeInfo,
                                         pDbCache->ulChannelIndex,
                                         &lData,
                                         ulDataBitCount>>3,
                                         (USHORT)(FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS) );

        if ( NT_SUCCESS(ntStatus) ) {
            if ( pNodeInfo->ulControlType == VOLUME_CONTROL ) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Current Volume Level: %x\n", lData));
                pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: pDbCache->lLastValueSet=%d\n",pDbCache->lLastValueSet));
                if ( (pDbCache->lLastValueSet >= pDbCache->Range.Bounds.SignedMaximum) ||
                     (pDbCache->lLastValueSet <= pDbCache->Range.Bounds.SignedMinimum) ) {
                    lData = ( pDbCache->Range.Bounds.SignedMinimum +
                             ( pDbCache->Range.Bounds.SignedMaximum - pDbCache->Range.Bounds.SignedMinimum) / 2 )
                            / lScaleFactor;
                   _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: volume at max (%d) or min (%d), setting to average %d\n",
                                               pDbCache->Range.Bounds.SignedMaximum,
                                               pDbCache->Range.Bounds.SignedMinimum,
                                               lData));
                }
                ntStatus = 
                     CreateFeatureFBlockRequest( pKsDevice,
                                                 pNodeInfo,
                                                 pDbCache->ulChannelIndex,
                                                 &lData,
                                                 ulDataBitCount>>3,
                                                 (USHORT)(FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL) );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: setting lastvalue to %d\n",pDbCache->lLastValueSet));
                }
                else {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: error setting volume %d\n",lData));
                }
            }
            else {
                pDbCache->lLastValueSet = (LONG)((CHAR)lData) * lScaleFactor;
            }
        }
    }

    return ntStatus;

}


NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS: 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;
    NTSTATUS ntStatus;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetVolumeLevel] pNodeInfo %x\n",pNodeInfo));

    ntStatus = GetSetDBLevel( (PKSDEVICE)pKsFilter->Context,
                              pNodeInfo,
                              pData,
                              pNAC->Channel,
                              16,
                              usRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS 
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus;
    
    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS: 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetToneLevel] pNodeInfo %x\n",pNodeInfo));

    ntStatus = GetSetDBLevel( (PKSDEVICE)pKsFilter->Context,
                              pNodeInfo,
                              pData,
                              pNAC->Channel,
                              8,
                              usRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS 
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    ULONG ulChannel = pNAC->Channel;
    PBOOLEAN_CTRL_CACHE pBoolCache;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ?
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS:
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;


    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);
    pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;

    // Determine if this is a request for the Master channel or beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pBoolCache += ulChannel;
    DbgLog("GSBool", &pNodeInfo, ulChannel, pBoolCache, 0 );

    if ( pNodeInfo->ulCacheValid & (1<<ulChannel)  ) {
        if ((usRequestType>>8) == AVC_CTYPE_STATUS) {
            *(PBOOL)pValue = pBoolCache->fLastValueSet;
            ntStatus = STATUS_SUCCESS;
        }
        else if ( pBoolCache->fLastValueSet == *(PBOOL)pValue ){
            ntStatus = STATUS_SUCCESS;
        }
        else {
            UCHAR ucValue = (UCHAR)((*(PBOOL)pValue) ? AVC_ON : AVC_OFF);
            ntStatus = CreateFeatureFBlockRequest( pKsFilter->Context,
                                                   pNodeInfo,
                                                   pBoolCache->ulChannelIndex,
                                                   &ucValue,
                                                   1, 
                                                   usRequestType );
        }
    }
    else { 
        UCHAR ucValue;

        if ( (usRequestType>>8) == AVC_CTYPE_STATUS ) ucValue = 0xFF;
        else ucValue = (UCHAR)((*(PBOOL)pValue) ? AVC_ON : AVC_OFF);

        ntStatus = CreateFeatureFBlockRequest( pKsFilter->Context,
                                               pNodeInfo,
                                               pBoolCache->ulChannelIndex,
                                               &ucValue,
                                               1, 
                                               usRequestType );

        if ( NT_SUCCESS(ntStatus) && ( (usRequestType>>8) == AVC_CTYPE_STATUS )) {
            *(PBOOL)pValue = ((ucValue & 0xff) == AVC_ON) ? TRUE : FALSE;
            pNodeInfo->ulCacheValid |= (1<<ulChannel) ;
        }
    }

    if ( NT_SUCCESS(ntStatus)) {
        pBoolCache->fLastValueSet = *(PBOOL)pValue;
        pIrp->IoStatus.Information = sizeof(BOOL);
    }

#if DBG
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetBoolean] failed pNodeInfo %x Status: %x\n",
                                      pNodeInfo, ntStatus ));

    }
#endif

    return ntStatus;
}

NTSTATUS 
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC pPropDevSpec = 
        (PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    NTSTATUS ntStatus;

    ULONG ulCommandType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? AVC_CTYPE_STATUS  :
                                                                       AVC_CTYPE_CONTROL ; 

    // Simple passthrough to send vendor dependent commands through
    ntStatus = AvcVendorDependent( pKsFilter->Context,
                                   pPropDevSpec->DeviceInfo, 
                                   ulCommandType,
                                   pPropDevSpec->DevSpecificId,
                                   pPropDevSpec->Length,
                                   pData );
    return ntStatus;
}

NTSTATUS 
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSPIN pKsPin = KsGetPinFromIrp(pIrp);
    PKSAUDIO_POSITION pPosition = pData;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus;

    if ( !pKsPin ) return STATUS_INVALID_PARAMETER;
    pPinContext = pKsPin->Context;

    ASSERT(pKsProperty->Flags & KSPROPERTY_TYPE_GET);

    if ( ((PHW_DEVICE_EXTENSION)pPinContext->pHwDevExt)->fSurpriseRemoved ) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    pPosition->WriteOffset = pPinContext->KsAudioPosition.WriteOffset;

    if ( !pPinContext->fStreamStarted ) {
        pPosition->PlayOffset = pPinContext->KsAudioPosition.PlayOffset;
    }
    else {
        // Assume AM824 for now
        ntStatus = AM824AudioPosition( pKsPin, pPosition );
    }

    DbgLog("GetPos", pPinContext, &pPinContext->KsAudioPosition,
                     pPosition->WriteOffset, pPosition->PlayOffset);

    return ntStatus;
}


NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] pNodeInfo %x NodeId %x\n",
                                 pNodeInfo,
                                 pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] ulChannelConfig %x ulNumChannels %x\n",
                                     pNodeInfo->ulChannelConfig,
                                     ulNumChannels));

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                       sizeof(KSPROPERTY_MEMBERSHEADER);
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_BOOL;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);

            pMembers->MembersFlags = 0;
            pMembers->MembersSize  = 0;
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->fMasterChannel) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }
            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
        }
    }

    return ntStatus;
}

NTSTATUS 
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PKSDEVICE pKsDevice;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pKsDevice = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupport] pNodeInfo %x NodeId %x \n",pNodeInfo,pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;
/*
        if ( pNodeProperty->Property.Id == KSPROPERTY_AUDIO_EQ_LEVEL ) {
            ntStatus = GetEqualizerValues( pFilterContext->pPhysicalDeviceObject,
                                           pNodeInfo,
                                           (USHORT)0xffff,
                                           GET_CUR,
                                           NULL,
                                           NULL,
                                           &ulNumChannels );
            if ( !NT_SUCCESS( ntStatus ) )
                return ntStatus;
        }
*/
        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION)   +
                                       sizeof(KSPROPERTY_MEMBERSHEADER) +
                                       (sizeof(KSPROPERTY_STEPPING_LONG) * ulNumChannels );
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_I4;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);
            PKSPROPERTY_STEPPING_LONG pRange   = (PKSPROPERTY_STEPPING_LONG)(pMembers + 1);

            pMembers->MembersFlags = KSPROPERTY_MEMBER_STEPPEDRANGES;
            pMembers->MembersSize  = sizeof(KSPROPERTY_STEPPING_LONG);
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = (ulNumChannels > 2) ? KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL : 0;

            // If there is a Master channel, make this node UNIFORM
            if ( pNodeInfo->fMasterChannel ) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }

            switch ( pNodeProperty->Property.Id ) {
                case KSPROPERTY_AUDIO_VOLUMELEVEL:
                case KSPROPERTY_AUDIO_BASS:
                case KSPROPERTY_AUDIO_MID:
                case KSPROPERTY_AUDIO_TREBLE:
                    {
                     ULONG ulControlType =
                         (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_VOLUMELEVEL) ? VOLUME_CONTROL  :
                         (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_BASS)        ? BASS_CONTROL  :
                         (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_MID )        ? MID_CONTROL   :
                                                                                        TREBLE_CONTROL;
                     PDB_LEVEL_CACHE pDbCache = pNodeInfo->pCachedValues;
                     ULONG ulControlSize = (ulControlType == VOLUME_CONTROL ) ? 16 : 8;
                     ULONG i;

//                     pMembers->Flags = pNodeInfo->ulChannelConfig>>1;

                     for (i=0; i<ulNumChannels; i++) {
                         if (pNodeInfo->ulCacheValid & (1<<i)) { // If we already got this don't do it again
                             RtlCopyMemory(&pRange[i],&pDbCache[i].Range, sizeof(KSPROPERTY_STEPPING_LONG));
                             ntStatus = STATUS_SUCCESS;
                         }
                         else {
                             ntStatus = GetDbLevelRange( pKsDevice,
                                                         pNodeInfo,
                                                         pDbCache[i].ulChannelIndex,
                                                         ulControlSize,
                                                         &pRange[i] );
                             if ( !NT_SUCCESS(ntStatus) ) {
                                 break;
                             }
                         }
                     }

                     if ( NT_SUCCESS(ntStatus) )
                         pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    }
                    break;
/*
                case KSPROPERTY_AUDIO_EQ_LEVEL:
                    ntStatus = GetEqDbRanges( pFilterContext->pPhysicalDeviceObject,
                                              pNodeInfo,
                                              (USHORT)0xffff,
                                              pRange );
                    pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    break;
*/
                case KSPROPERTY_AUDIO_WIDENESS:
                    // Need a range of spaciousness percentages
                default:
                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
            }
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo )
{
    ULONG ulNodeType = pNodeInfo->ulNodeType;
    PKSPROPERTY_SET pPropSet = (PKSPROPERTY_SET)&NodePropertySetTable[ulNodeType];

    if ( pPropSet->PropertiesCount ) {
        pNodeInfo->KsAutomationTable.PropertySetsCount = 1;
        pNodeInfo->KsAutomationTable.PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pNodeInfo->KsAutomationTable.PropertySets      = pPropSet;
    }
}

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets )
{
    ULONG ulNumPinPropItems = 1;
//    ULONG ulNumAudioPropItems = 1;
    ULONG ulNumAudioPropItems = 0;
    PKSPROPERTY_ITEM pPinProps  = pDevPropItems;
    PKSPROPERTY_ITEM pAudioProp = pDevPropItems + ulNumPinPropItems;

    ASSERT(pNumSets);

    *pNumSets = ulNumPinPropItems + ulNumAudioPropItems; // There always is an Pin property set and a vendor dependent property

    if ( pDevPropItems ) {
        RtlCopyMemory(pDevPropItems++, &PinPropertyItems[KSPROPERTY_PIN_NAME], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pDevPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_DEV_SPECIFIC], sizeof(KSPROPERTY_ITEM) );

        if ( pDevPropSet ) {
            pDevPropSet->Set             = &KSPROPSETID_Pin;
            pDevPropSet->PropertiesCount = ulNumPinPropItems;
            pDevPropSet->PropertyItem    = pPinProps;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;

/*
            pDevPropSet++;

            pDevPropSet->Set             = &KSPROPSETID_Audio;
            pDevPropSet->PropertiesCount = ulNumAudioPropItems;
            pDevPropSet->PropertyItem    = pAudioProp;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;
*/
        }
    }

    if (pNumItems) {
        *pNumItems = ulNumPinPropItems;
    }

}

VOID
BuildPinPropertySet( PHW_DEVICE_EXTENSION pHwDevExt,
                     PKSPROPERTY_ITEM pStrmPropItems,
                     PKSPROPERTY_SET pStrmPropSet,
                     PULONG pNumItems,
                     PULONG pNumSets )
{
    ULONG ulNumAudioProps  = 3;
    ULONG NumDrmAudioStreamProps = 1;

//    ULONG ulNumStreamProps = 1;
//    ULONG ulNumConnectionProps = 1;

    // For now we hardcode this to a known set.
//    *pNumSets = 3;
    *pNumSets = 2;

//    if (pNumItems) *pNumItems = ulNumAudioProps + ulNumStreamProps + ulNumConnectionProps;
    if (pNumItems) *pNumItems = ulNumAudioProps +
                                NumDrmAudioStreamProps ;

    if (pStrmPropItems) {
        PKSPROPERTY_ITEM pAudItms = pStrmPropItems;
        PKSPROPERTY_ITEM pDRMItms = pStrmPropItems + ulNumAudioProps;
//        PKSPROPERTY_ITEM pStrmItms = pStrmPropItems + ulNumAudioProps;
//        PKSPROPERTY_ITEM pConnItms = pStrmPropItems + (ulNumAudioProps+ulNumStreamProps);

        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_LATENCY], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_POSITION], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems++, &StreamItm[0], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems,   &ConnectionItm[0], sizeof(KSPROPERTY_ITEM) );

        RtlCopyMemory(pStrmPropItems++, &DrmAudioStreamPropertyItems[KSPROPERTY_DRMAUDIOSTREAM_CONTENTID], sizeof(KSPROPERTY_ITEM) );


        if (pStrmPropSet) {

            // Audio Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Audio;
            pStrmPropSet->PropertiesCount = ulNumAudioProps;
            pStrmPropSet->PropertyItem    = pAudItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // DRM Property Set
            pStrmPropSet->Set             = &KSPROPSETID_DrmAudioStream;
            pStrmPropSet->PropertiesCount = NumDrmAudioStreamProps;
            pStrmPropSet->PropertyItem    = pDRMItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;
/*
            // Stream Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Stream;
            pStrmPropSet->PropertiesCount = ulNumStreamProps;
            pStrmPropSet->PropertyItem    = pStrmItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // Connection Properties
            pStrmPropSet->Set             = &KSPROPSETID_Connection;
            pStrmPropSet->PropertiesCount = ulNumConnectionProps;
            pStrmPropSet->PropertyItem    = pConnItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
*/
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\intrsect.c ===
#include "Common.h"


ULONG
GetIntersectFormatSize( PFWAUDIO_DATARANGE pAudioDataRange )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    ULONG rval = 0;

    if (IS_VALID_WAVEFORMATEX_GUID(pSubFormat)) {
        if (( (pAudioDataRange->ulSlotSize<<3) <= 16 ) &&
            ( pAudioDataRange->ulNumChannels   <= 2 )){
            rval = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else
        rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );

    return rval;
}

ULONG
ConvertDatarangeToFormat(
    PFWAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;

    // Copy datarange directly from interface info.
    *pFormat = pAudioDataRange->KsDataRangeAudio.DataRange;

    if ( IS_VALID_WAVEFORMATEX_GUID(pSubFormat) ) {
        if (( (pAudioDataRange->ulSlotSize<<3) <= 16 ) &&
            ( pAudioDataRange->ulNumChannels   <= 2 )){
             // Don't think this will happen but just in case...
            
			PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

            pWavFormatEx->wFormatTag      = EXTRACT_WAVEFORMATEX_ID(pSubFormat);
            pWavFormatEx->nChannels       = (WORD)pAudioDataRange->ulNumChannels;
            pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatEx->wBitsPerSample  = (WORD)(pAudioDataRange->ulSlotSize<<3);
            pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
            pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
            pWavFormatEx->cbSize          = 0;

            pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
        }
        else {
            PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pFormat+1) ;
            pWavFormatPCMEx->Format.wFormatTag      = WAVE_FORMAT_EXTENSIBLE;
            pWavFormatPCMEx->Format.nChannels       = (WORD)pAudioDataRange->ulNumChannels;
            pWavFormatPCMEx->Format.nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatPCMEx->Format.wBitsPerSample  = (WORD)pAudioDataRange->ulSlotSize<<3;
            pWavFormatPCMEx->Format.nBlockAlign     = pWavFormatPCMEx->Format.nChannels *
                                                      (WORD)pAudioDataRange->ulSlotSize;
            pWavFormatPCMEx->Format.nAvgBytesPerSec = pWavFormatPCMEx->Format.nSamplesPerSec *
                                                      pWavFormatPCMEx->Format.nBlockAlign;
            pWavFormatPCMEx->Format.cbSize          = sizeof(WAVEFORMATPCMEX) - sizeof(WAVEFORMATEX);
            pWavFormatPCMEx->Samples.wValidBitsPerSample = (WORD)pAudioDataRange->ulValidDataBits;
            pWavFormatPCMEx->dwChannelMask          = pAudioDataRange->ulChannelConfig;
            pWavFormatPCMEx->SubFormat              = KSDATAFORMAT_SUBTYPE_PCM;

            pFormat->FormatSize = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }

    return pFormat->FormatSize;
}


BOOLEAN
CheckFormatMatch(
    PKSDATARANGE_AUDIO pInDataRange,
    PKSDATARANGE_AUDIO pInterfaceRange )
{
    PKSDATARANGE pInRange = (PKSDATARANGE)pInDataRange;
    PKSDATARANGE pStreamRange = (PKSDATARANGE)pInterfaceRange;
    BOOLEAN fRval = FALSE;

    // Check Format and subformat types
    if (IsEqualGUID(&pInRange->MajorFormat, &pStreamRange->MajorFormat) ||
        IsEqualGUID(&pInRange->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        if (IsEqualGUID(&pInRange->SubFormat, &pStreamRange->SubFormat) ||
            IsEqualGUID(&pInRange->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
            if (IsEqualGUID(&pInRange->Specifier, &pStreamRange->Specifier) ||
                IsEqualGUID(&pInRange->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
                fRval = TRUE;
            }
        }
    }

    // Now that we know we have an audio format check the dataranges
    if ( fRval ) {

      if (pInDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {

        fRval = FALSE;
        if ( pInDataRange->MaximumChannels >= pInterfaceRange->MaximumChannels ) {
            if ( pInDataRange->MaximumSampleFrequency >= pInterfaceRange->MaximumSampleFrequency ) {
                if (pInDataRange->MinimumSampleFrequency <= pInterfaceRange->MaximumSampleFrequency ) {
                    if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                        if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                            fRval = TRUE;
                        }
                    }
                    else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                        fRval = TRUE;
                    }
                }
            }
            else if ( pInDataRange->MinimumSampleFrequency >= pInterfaceRange->MinimumSampleFrequency ) {
                if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                    if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                        fRval = TRUE;
                    }
                }
                else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                    fRval = TRUE;
                }
            }
        }
      }
    }

    return fRval;
}


VOID
GetMaxSampleRate(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulRequestedMaxSR,
    ULONG ulFormatType )
{

    ULONG ulMaxSampleRate = 0;
    ULONG ulIFMaxSR;
    ULONG j;

    if ( ulFormatType == AUDIO_DATA_TYPE_TIME_BASED) {
        pFWAudioRange->ulMaxSampleRate = 
            pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
/*
		PPCM_FORMAT pPCMFmt = (PPCM_FORMAT)pFWAudioRange->pFormat;
        if (pPCMFmt->ulSampleRateType == 0) {
            ulIFMaxSR = pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pFWAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                               ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pFWAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pPCMFmt->ulSampleRateType; j++ ) {
                ulIFMaxSR  = pPCMFmt->pSampleRate[j];
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pFWAudioRange->ulMaxSampleRate ) )
                    pFWAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
  */
    }

/*
    else { // Its Type II
        pT2AudioDesc = (PAUDIO_CLASS_TYPE2_STREAM)pFWAudioRange->pAudioDescriptor;
        if (pT2AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pFWAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                               ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pFWAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT2AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT2AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pFWAudioRange->ulMaxSampleRate ) )
                    pFWAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
*/

}

PFWAUDIO_DATARANGE
FindBestMatchForInterfaces(
    PFWAUDIO_DATARANGE *ppFWAudioRange,
    ULONG ulAudioRangeCount,
    ULONG ulRequestedMaxSR  )
{
    PFWAUDIO_DATARANGE pFWAudioRange;

    ULONG ulMaxSampleRate = 0;
    ULONG ulMaxChannels   = 0;
    ULONG ulMaxSampleSize = 0;
    ULONG ulRngeCnt;
    ULONG ulFormatType;
    ULONG i;

     ulFormatType = ppFWAudioRange[0]->ulDataType & DATA_FORMAT_TYPE_MASK;
    // Determine if this is Time Based or Compressed Data Format. Since we've already weeded
    // out the impossibilities via CheckFormatMatch this should be the same for all
    // interfaces left in the list.

    for ( i=0; i<ulAudioRangeCount; i++ ) {
        GetMaxSampleRate( ppFWAudioRange[i],
                          ulRequestedMaxSR,
                          ulFormatType );
    }

    // Now eliminate lower frequency interfaces. First find the best then
    // eliminate others that don't meet it.
    for ( i=0; i<ulAudioRangeCount; i++ ) {
        pFWAudioRange = ppFWAudioRange[i];
        if ( pFWAudioRange->ulMaxSampleRate > ulMaxSampleRate ) {
            ulMaxSampleRate = pFWAudioRange->ulMaxSampleRate;
        }
    }
    for ( i=0, ulRngeCnt=ulAudioRangeCount; i<ulAudioRangeCount; i++ ) {
        pFWAudioRange = ppFWAudioRange[i];
        if ( pFWAudioRange->ulMaxSampleRate < ulMaxSampleRate ) {
            ppFWAudioRange[i] = NULL; ulRngeCnt--;
        }
    }


    if ((ulFormatType == AUDIO_DATA_TYPE_TIME_BASED) && (ulRngeCnt > 1)) {
        // Now find the highest number of channels and eliminate others
        for ( i=0; i<ulAudioRangeCount; i++ ) {
            if ( ppFWAudioRange[i] ) {

                if ( ppFWAudioRange[i]->ulNumChannels > ulMaxChannels ) {
                    ulMaxChannels = ppFWAudioRange[i]->ulNumChannels;
                }
                if ( ppFWAudioRange[i]->ulValidDataBits > ulMaxSampleSize ) {
                    ulMaxSampleSize = ppFWAudioRange[i]->ulValidDataBits;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppFWAudioRange[i] ) {
                if ( ppFWAudioRange[i]->ulNumChannels < ulMaxChannels ) {
                    ppFWAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppFWAudioRange[i] ) {
                if ( ppFWAudioRange[i]->ulValidDataBits < ulMaxSampleSize ) {
                    ppFWAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }
    }

    i=0;
    while ( !ppFWAudioRange[i] ) i++;

    return ppFWAudioRange[i];
}

PFWAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PFWAUDIO_DATARANGE *ppFWAudioRanges,
    ULONG ulAudioRangeCount )
{
    ULONG ulMaximumSampleFrequency = MAX_ULONG;

    PFWAUDIO_DATARANGE *ppFWAudioRange;
    PFWAUDIO_DATARANGE pFWAudioRange;
    PFWAUDIO_DATARANGE pMatchedRange;
    ULONG ulRngeCnt = 0;
    ULONG i;

    // Allocate space for copy of range pointers
    ppFWAudioRange = (PFWAUDIO_DATARANGE *)AllocMem(NonPagedPool, ulAudioRangeCount*sizeof(PFWAUDIO_DATARANGE));
    if ( !ppFWAudioRange ) {
        return NULL;
    }

    // Make a list of those ranges which match the input request
    for (i=0; i<ulAudioRangeCount; i++) {
        pFWAudioRange = ppFWAudioRanges[i];
        if ( CheckFormatMatch(pKsAudioRange, &pFWAudioRange->KsDataRangeAudio) ) {
            ppFWAudioRange[ulRngeCnt++] = ppFWAudioRanges[i];
        }
    }

    // Set this ulMaximumSampleFrequency only if it exists in pKsAudioRange
    if (pKsAudioRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
        ulMaximumSampleFrequency = pKsAudioRange->MaximumSampleFrequency;
    }

    // If there are no matches return NULL
    if ( ulRngeCnt == 0 ) {
        FreeMem( ppFWAudioRange );
        return NULL;
    }

    // If there is only 1 match we're done
    else if ( ulRngeCnt == 1 ) {
        pMatchedRange = ppFWAudioRange[0];
        GetMaxSampleRate( pMatchedRange,
                          ulMaximumSampleFrequency,
                          pMatchedRange->ulDataType & DATA_FORMAT_TYPE_MASK );
        FreeMem( ppFWAudioRange );
        return pMatchedRange;
    }

    // Now narrow choices based on best possible match.
    pMatchedRange =
        FindBestMatchForInterfaces( ppFWAudioRange,
                                    ulRngeCnt,
                                    pKsAudioRange->MaximumSampleFrequency );
    FreeMem(ppFWAudioRange);

    return pMatchedRange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\grouping.c ===
#include <Common.h>

ULONG 
GroupingMergeFeatureFBlock(
    PFUNCTION_BLOCK pFunctionBlock,
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    ULONG ulChannelCount )
{
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);
    PFEATURE_FUNCTION_BLOCK pFeatureFB;
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    PUSHORT pFBDepLen, pLen;
    ULONG ulAddedBytes;
    ULONG i;

    // First copy over the old Block
    RtlCopyMemory( pFBDepInfo,
                   pFunctionBlock->pBase,
                   (ULONG)bswapw(pFunctionBlock->pBase->usLength) );

    // First find the Channel Cluster
    ulFBIndx += ((ULONG)pFBDepInfo->ucNumberOfInputPlugs * sizeof(SOURCE_ID));

    pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    // Update the channel count in the Feature Function block
    pChannelCluster->ucNumberOfChannels = (UCHAR)ulChannelCount;

    // For now we can only merge if the channel config matches the master
    ASSERT( pChannelCluster->ucChannelConfigType < 2 );

    ulFBIndx += ((ULONG)bswapw(pChannelCluster->usLength) + sizeof(USHORT));

    pFBDepLen = (PUSHORT)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += sizeof(USHORT);

    pFeatureFB = (PFEATURE_FUNCTION_BLOCK)&pcFBDepInfo[ulFBIndx];

    ulAddedBytes = pFeatureFB->ucControlSize * (ulChannelCount-1);

    for (i=2; i<=ulChannelCount; i++) {
        ULONG j;
        for (j=0; j<pFeatureFB->ucControlSize; j++)
            pFeatureFB->bmaControls[(i*pFeatureFB->ucControlSize)+j] = 
                        pFeatureFB->bmaControls[pFeatureFB->ucControlSize+j];
    }

    pLen = (PUSHORT)((PUCHAR)pChannelCluster + (ULONG)bswapw(pChannelCluster->usLength) + sizeof(USHORT));

    _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
    *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );
    
    pFeatureFB->ucControlSpecInfoSize += (UCHAR)ulAddedBytes;
    pFBDepInfo->usLength = bswapw( bswapw(pFBDepInfo->usLength) + (USHORT)ulAddedBytes );

    return ulAddedBytes;
}

ULONG 
GroupingMergeFBlock(
    PFUNCTION_BLOCK pFunctionBlock,
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    ULONG ulChannelCount )
{
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    PUSHORT pFBDepLen;

    // First copy over the old Block
    RtlCopyMemory( pFBDepInfo,
                   pFunctionBlock->pBase,
                   (ULONG)bswapw(pFunctionBlock->pBase->usLength) );

    // First find the Channel Cluster
    ulFBIndx += ((ULONG)pFBDepInfo->ucNumberOfInputPlugs * sizeof(SOURCE_ID));

    pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    // For now we can only merge if the channel config matches the master
    ASSERT( pChannelCluster->ucChannelConfigType < 2 );

    ulFBIndx += ((ULONG)bswapw(pFunctionBlock->pChannelCluster->usLength) + sizeof(USHORT));

    pFBDepLen = (PUSHORT)&pcFBDepInfo[ulFBIndx];

    return 0;
}


NTSTATUS
GroupingMergeDevices(
    PKSDEVICE pKsDevice,
    ULONG ulDeviceCount )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    ULONG ulChannelCount = 0;
    ULONG ulAddedBytes = 0;
    ULONG ulTemp = pGrpInfo->ulChannelConfig;

    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;

#ifdef SA_HACK
    if (( pUnitInfo->IEC61883UnitIds.VendorID == SA_VENDOR_ID ) &&
        ( pUnitInfo->IEC61883UnitIds.ModelID  == SA_MODEL_ID  )) {
        pUnitInfo->IEC61883UnitIds.ModelID++; // Do this to avoid reswapping
    }
#endif

    // Store total count of devices in current device extension. Backup device info.
    pGrpInfo->ulDeviceCount = ulDeviceCount;
    pGrpInfo->pBackupSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
    pGrpInfo->pBackupAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;

    // Count the number of channels in the group channel config.
    while ( ulTemp ) {
        ulChannelCount++;
        ulTemp = (ulTemp & (ulTemp-1));
    }

    // Merge the descriptors. For now this will be just a combining of the 
    // controls in any feature function block, an update of the Master channel cluster, 
    // and an update (if necessary) of the individual channel cluster structures.
    pAudioSubunitInfo->pSubunitIdDesc = AllocMem( PagedPool, MAX_AVC_OPERAND_BYTES );
    if ( pAudioSubunitInfo->pSubunitIdDesc ) {
        PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
        PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;
        PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo;
        PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo; 
        PFUNCTION_BLOCKS_INFO pFBlocksInfo;
        PFUNCTION_BLOCK pFunctionBlock;
        PUSHORT pLen;
        ULONG i;
        ULONG ulIdSize = (ULONG)((pGrpInfo->pBackupSubunitIdDesc->ucDescriptorLengthHi<<8) |
                                  pGrpInfo->pBackupSubunitIdDesc->ucDescriptorLengthLo     );

        // Copy the original first to get a starting point.
        RtlCopyMemory( pSubunitIdDesc,
                       pGrpInfo->pBackupSubunitIdDesc,
                       ulIdSize );

        pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );

        // ISSUE-2001/01/10-dsisolak Assume only one configuration
        pConfigDepInfo  = ParseFindFirstAudioConfiguration( pSubunitIdDesc );

        // Find the Master channel Cluster and adjust
        pConfigDepInfo->ucNumberOfChannels = (UCHAR)ulChannelCount;
        pConfigDepInfo->usPredefinedChannelConfig = bswapw(usBitSwapper((USHORT)pGrpInfo->ulChannelConfig));

        // Now go through function blocks and update channel configs and controls for all channels
        pFBlocksInfo = ParseFindFunctionBlocksInfo( pConfigDepInfo );
        pFBDepInfo   = pFBlocksInfo->FBDepInfo;
        pFunctionBlock = pAudioSubunitInfo->pAudioConfigurations->pFunctionBlocks;
        for ( i=0; i<(ULONG)pFBlocksInfo->ucNumBlocks; i++ ) {
            PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;

            switch (pFunctionBlock->ulType) {
                case FB_FEATURE:
                    ulAddedBytes += GroupingMergeFeatureFBlock( pFunctionBlock++, 
                                                                pFBDepInfo,
                                                                ulChannelCount );
                    break;
                default:
                    ulAddedBytes += GroupingMergeFBlock( pFunctionBlock++, 
                                                         pFBDepInfo,
                                                         ulChannelCount );
                    break;
            }

            pFBDepInfo = (PFUNCTION_BLOCK_DEPENDENT_INFO)
                (pcFBDepInfo + ((ULONG)bswapw(pFBDepInfo->usLength)) + 2);

        }

        // Update descriptor size fields
        pLen = (PUSHORT)pSubunitIdDesc;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pAudioSUDepInfo->usLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pAudioSUDepInfo->usInfoFieldsLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pConfigDepInfo->usLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        // Reparse descriptor for combined device.
        ntStatus = ParseAudioSubunitDescriptor( pKsDevice );

    }

    return ntStatus;
}

NTSTATUS
GroupingDeviceGroupSetup (
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PDEVICE_GROUP_INFO pGrpInfo;

    BOOLEAN fDeviceGrouped = FALSE;
    GUID    DeviceGroupGUID;
    ULONG   ulChannelConfig;
    ULONG   ulMergedChannelCfg = 0;
    ULONG   ulDeviceCount = 0;

    NTSTATUS ntStatus;
    KIRQL kIrql;

    ntStatus = RegistryReadMultiDeviceConfig( pKsDevice,
                                             &fDeviceGrouped,
                                             &DeviceGroupGUID,
                                             &ulChannelConfig );

    _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo: %x fDeviceGrouped: %x ulChannelConfig: %x ntStatus: %x\n",
                                  pAudioSubunitInfo, fDeviceGrouped, ulChannelConfig, ntStatus ) );

    if ( (NT_SUCCESS(ntStatus) && fDeviceGrouped) ) {
        pGrpInfo = 
            pAudioSubunitInfo->pDeviceGroupInfo = 
                AllocMem( NonPagedPool, sizeof(DEVICE_GROUP_INFO) );
        if ( !pAudioSubunitInfo->pDeviceGroupInfo ) return STATUS_INSUFFICIENT_RESOURCES;
        KsAddItemToObjectBag(pKsDevice->Bag, pGrpInfo, FreeMem);

        _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo->pDeviceGroupInfo: %x \n",
                                      pAudioSubunitInfo->pDeviceGroupInfo ) );

        pGrpInfo->DeviceGroupGUID    = DeviceGroupGUID;
        pGrpInfo->ulChannelConfig    = ulChannelConfig;
        pGrpInfo->ulDeviceChannelCfg = 
            pAudioSubunitInfo->pAudioConfigurations->ChannelCluster.ulPredefinedChannelConfig;
//        pGrpInfo->pHwDevExts[ulDeviceCount++] = pHwDevExt;
//        ulMergedChannelCfg = pGrpInfo->ulDeviceChannelCfg;
    }
    else {
        // Device not grouped. Treat as a separate device.
        return STATUS_SUCCESS;
    }

    // Get the Channel position(s) of this device and the associated devices.
    // If they merge to form the required channel config, create a filter factory.
    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    pHwDevExt = (PHW_DEVICE_EXTENSION)AvcSubunitGlobalInfo.DeviceExtensionList.Flink;

    while ( pHwDevExt != (PHW_DEVICE_EXTENSION)&AvcSubunitGlobalInfo.DeviceExtensionList ) {
        pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

        if ( !pAudioSubunitInfo ) break;
        _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo: %x pDeviceGroupInfo: %x\n",
                    pAudioSubunitInfo, pAudioSubunitInfo->pDeviceGroupInfo ) );
        if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
            if ( IsEqualGUID( &DeviceGroupGUID, &pAudioSubunitInfo->pDeviceGroupInfo->DeviceGroupGUID ) ) {
                pGrpInfo->pHwDevExts[ulDeviceCount++] = pHwDevExt;

                // Get the Channel config from this device and merge it
                ulMergedChannelCfg |= pAudioSubunitInfo->pDeviceGroupInfo->ulDeviceChannelCfg;

                _DbgPrintF( DEBUGLVL_TERSE, ("ulMergedChannelCfg: %x ulChannelConfig: %x\n",
                                              ulMergedChannelCfg, ulChannelConfig ));
            }
        }

        pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDevExt->List.Flink;
    }

    _DbgPrintF( DEBUGLVL_TERSE, ("Final: ulMergedChannelCfg: %x ulChannelConfig: %x\n",
                                  ulMergedChannelCfg, ulChannelConfig ));

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    if ( ulMergedChannelCfg == ulChannelConfig ) {
        ntStatus = GroupingMergeDevices( pKsDevice, ulDeviceCount );
    }
    else
        ntStatus = STATUS_DEVICE_BUSY;
    
    return ntStatus;
}

PHW_DEVICE_EXTENSION
GroupingFindChannelExtension(
    PKSDEVICE pKsDevice,
    PULONG pChannelIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    PHW_DEVICE_EXTENSION pHwDevExtRet = NULL; 
    ULONG i, j, k;

    for (i=0; ((i<pGrpInfo->ulDeviceCount) && !pHwDevExtRet); i++) {
        ULONG ulDevChCfg;
        pHwDevExt = pGrpInfo->pHwDevExts[i];
        ulDevChCfg = ((PAUDIO_SUBUNIT_INFORMATION)pHwDevExt->pAvcSubunitInformation)->pDeviceGroupInfo->ulDeviceChannelCfg;
        if ( ulDevChCfg & (1<<*pChannelIndex) ) {
            pHwDevExtRet = pHwDevExt;
            // Determine the index on the device
            for (j=0, k=0; j<*pChannelIndex; j++) {
                if ( ulDevChCfg & (1<<j) ) k++;
            }

            *pChannelIndex = k;
        }
    }

    

    return pHwDevExtRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\pin.c ===
#include "Common.h"


NTSTATUS
PinValidateDataFormat( 
    PKSPIN pKsPin, 
    PFWAUDIO_DATARANGE pFWAudioRange )
{
    PKSDATARANGE_AUDIO pKsDataRangeAudio = &pFWAudioRange->KsDataRangeAudio;
    PKSDATAFORMAT pFormat = pKsPin->ConnectionFormat;
    NTSTATUS ntStatus = STATUS_NO_MATCH;
    union {
        PWAVEFORMATEX    pWavFmtEx;
        PWAVEFORMATPCMEX pWavFmtPCMEx;
    } u;

    u.pWavFmtEx = (PWAVEFORMATEX)(pFormat + 1);

    if ( IS_VALID_WAVEFORMATEX_GUID(&pKsDataRangeAudio->DataRange.SubFormat) ) {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pFWAudioRange, u.pWavFmtEx->nSamplesPerSec ) ){
                    if ( u.pWavFmtEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((u.pWavFmtPCMEx->Samples.wValidBitsPerSample == pFWAudioRange->ulValidDataBits ) &&
                            (u.pWavFmtPCMEx->dwChannelMask == pFWAudioRange->ulChannelConfig))
                                ntStatus = STATUS_SUCCESS;
                    }
                    else if ((u.pWavFmtEx->nChannels <= 2) && (u.pWavFmtEx->wBitsPerSample <= 16)) {
                        ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
    }

    return ntStatus;
    
}

#define FS_32000_INDEX 0
#define FS_44100_INDEX 1
#define FS_48000_INDEX 2
#define FS_96000_INDEX 3
#define FS_MAX_INDEX   4

KS_FRAMING_RANGE                      // 10ms    20ms    Step (Must Multiply by # Channels)
AllocatorFramingTable[FS_MAX_INDEX] = {{ 320*4,  640*4,  32*4},   //Fs 32000 32bit data
                                       { 441*4,  882*4, 441*4},   //Fs 44100 32bit data
                                       { 480*4,  960*4,  48*4},   //Fs 48000 32bit data
                                       { 960*4, 1920*4,  96*4}    //Fs 96000 32bit data
};

#if DBG

NTSTATUS
ReportPlugValue(
    PKSDEVICE pKsDevice,
    ULONG ulPlugNum,
    KSPIN_DATAFLOW KsPinDataflow,
    PULONG pValue )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    ULONG ulValue;
    NTSTATUS ntStatus1 = STATUS_SUCCESS;

    // Get the current value of the remote plug.
    if ( NT_SUCCESS( ntStatus1 ) ) {
        ntStatus1 = Bus1394QuadletRead( pKsDevice->NextDeviceObject,
                                        (KsPinDataflow == KSPIN_DATAFLOW_IN) ? 0xf0000984+ulPlugNum :
                                                                               0xf0000904+ulPlugNum,
                                        pHwDevExt->ulGenerationCount,
                                        pValue );
        if ( !NT_SUCCESS(ntStatus1) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Could not read PCR Value: %x\n",ntStatus1));
        }
        else {
            *pValue = bswap(*pValue);
        }
    }
    else {
        _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Could not Get Gen Count: %x\n",ntStatus1));
    }

    return ntStatus1;

}

#endif

NTSTATUS
PinDisconnectPlugs(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Disconnect plug(s) to release channel
    if ( pGrpInfo ) {
        ULONG i=0;
        for (i=0; i<pGrpInfo->ulDeviceCount; i++) {
            ntStatus = Av61883DisconnectCmpPlugs( pGrpInfo->pHwDevExts[i]->pKsDevice,
                                                  pPinContext->pPinGroupInfo[i].hConnection );
#if DBG
            if ( !NT_SUCCESS(ntStatus) ) {
                TRAP;
            }
#endif
        }
    }
    else if ( pPinContext->hConnection )
        ntStatus = Av61883DisconnectCmpPlugs( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                              pPinContext->hConnection );

    if ( pPinContext->pCmpRegister ) {
        Av61883ReleaseVirtualPlug(pPinContext->pCmpRegister);
    }

    ExDeleteNPagedLookasideList(&pPinContext->CipRequestLookasideList);

    return ntStatus;

}

NTSTATUS
PinCreateCCMConnection( 
    PKSPIN pKsPin )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
    PPIN_CONTEXT pPinContext = pKsPin->Context;
	PCMP_REGISTER pCmpRegister = pPinContext->pCmpRegister;
    NTSTATUS ntStatus = STATUS_SUCCESS;
	PKSDEVICE pKsDevice;
	USHORT usNodeAddress;
    KIRQL kIrql;
    UCHAR ucSubunitId;
    UCHAR ucPlugNumber;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;

    pKsDevice = (PKSDEVICE)pKsFilter->Context;
    ucPlugNumber = (UCHAR)pPinContext->pFwAudioDataRange->pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;
    ucSubunitId  = pPinContext->pFwAudioDataRange->pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitAddress[0] & 7;
    usNodeAddress = *(PUSHORT)&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->NodeAddress;

    // Determine what the device's audio subunit plug is connected to before disconnecting it
    // so we can reconnect when the stream is completed.
    {
     PCCM_SIGNAL_SOURCE pCcmSignalSource = &pPinContext->CcmSignalSource;
     NTSTATUS ntStatus;

     pCcmSignalSource->SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
     pCcmSignalSource->SignalDestination.SubunitId    = ucSubunitId;
     pCcmSignalSource->SignalDestination.ucPlugNumber = ucPlugNumber;

     ntStatus = CCMSignalSource( pKsDevice, 
                                 AVC_CTYPE_STATUS,
                                 pCcmSignalSource );

     if ( NT_SUCCESS(ntStatus) ) {
         _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinCreateCCMConnection]:CcmSignalSource: %x ntStatus: %x\n",
                                        pCcmSignalSource, ntStatus ));

         // Figure out if the Audio subunit is connected to the serial plug. If so, find out
         // if the source of the serial plug is the PC or not.
         if (( pCcmSignalSource->SignalSource.SubunitType  == AVC_SUBUNITTYPE_UNIT ) && 
             ( pCcmSignalSource->SignalSource.SubunitId    == UNIT_SUBUNIT_ID      ) &&
             ( pCcmSignalSource->SignalSource.ucPlugNumber <= MAX_IPCR )) {
             PCCM_INPUT_SELECT pCcmInputSelect = &pPinContext->CcmInputSelect;

             ntStatus = CCMInputSelectStatus ( pKsDevice,
                                               pCcmSignalSource->SignalSource.ucPlugNumber,
                                               pCcmInputSelect );
             if ( bswapw(pCcmInputSelect->usNodeId) != usNodeAddress ) {
                 // We need to save the reconnect info.
                 pPinContext->fReconnect = 2;
//                 TRAP;
             }
         }
         else {
             pPinContext->fReconnect = 1;
         }
     }
    }

    if ( !NT_SUCCESS(ntStatus) ) {
//        TRAP;
        ntStatus = STATUS_SUCCESS;
    }

    // First check if connection is already made
    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinCreateCCMConnection]: oPcr: %x\n", pCmpRegister->AvPcr.ulongData));
    if ( !pCmpRegister->AvPcr.oPCR.PPCCounter ) {
        CCM_SIGNAL_SOURCE CcmSignalSource;
        LARGE_INTEGER EvtTimeout;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Using CCM to make connection...\n"));
    
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
        KeResetEvent( &pCmpRegister->kEventConnected );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

        CcmSignalSource.SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
        CcmSignalSource.SignalDestination.SubunitId    = ucSubunitId;
        CcmSignalSource.SignalDestination.ucPlugNumber = ucPlugNumber;

        ntStatus = CCMInputSelectControl ( pKsDevice,
                                           INPUT_SELECT_SUBFN_CONNECT,
                                           usNodeAddress, 
                                           (UCHAR)pCmpRegister->ulPlugNumber,
                                           &CcmSignalSource.SignalDestination );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] Failed 4 %x\n",ntStatus));
            return ntStatus;
        }

        // Specify a timeout of 1 second
        EvtTimeout.QuadPart = -10000 * 1000;
        // Wait for event to be signalled
        ntStatus = KeWaitForSingleObject( &pCmpRegister->kEventConnected,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &EvtTimeout );
        if ( ntStatus == STATUS_TIMEOUT ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ERROR: CCM Connection Timed out\n"));
            ntStatus = STATUS_DEVICE_NOT_READY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           NULL,
                                           pCmpRegister->hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           &pPinContext->hConnection );
    }

    return ntStatus;
}

NTSTATUS
PinCreateConnection(
    PKSPIN pKsPin,
    PKSDEVICE pKsDevice,
    PAVC_UNIT_INFORMATION pAvcUnitInformation,
    PFW_PIN_DESCRIPTOR pFwPinDescriptor,
    PVOID *hConnection,
    PULONG pPlugNumber )
{

    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulNumPlugs;
    CMP_PLUG_TYPE CmpPlugType;
    ULONG ulPlugNum;
    HANDLE hPlug;
    NTSTATUS ntStatus;

    CmpPlugType = ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ? CMP_PlugIn : CMP_PlugOut;

    if ( pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.Flags & KSPIN_FLAG_AVC_FIXEDPCR ) {
        ulPlugNum = pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.UnitPlugNumber;
        ntStatus = 
            Av61883GetPlugHandle( pKsDevice, ulPlugNum, CmpPlugType, &hPlug );
    }
    else {
        // Need to choose a Plug Number if not permanently attached to pin..
        ulNumPlugs = ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ?
                     pAvcUnitInformation->CmpUnitCaps.NumInputPlugs  :
                     pAvcUnitInformation->CmpUnitCaps.NumOutputPlugs ;
        for (ulPlugNum=0; ulPlugNum<ulNumPlugs; ulPlugNum++) {
            ntStatus = 
                Av61883GetPlugHandle( pKsDevice, ulPlugNum, CmpPlugType, &hPlug );
            if ( NT_SUCCESS(ntStatus) ) {
                break;
            }
        }
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR, ("[PinCreateConnection]ERROR: Could not allocate a device plug\n"));
        return ntStatus;
    }

    // Make AV/C connection
    ntStatus = AvcSetPinConnectInfo( pKsDevice, 
                                     pFwPinDescriptor->ulPinId, 
                                     hPlug,
                                     ulPlugNum,
                                     UNIT_SUBUNIT_ADDRESS,
                                     &pFwPinDescriptor->AvcSetConnectInfo );

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed AvcSetPinConnectInfo %x\n",ntStatus));
        return ntStatus;
    }

    ntStatus = AvcAcquireReleaseClear( pKsDevice, 
                                       pFwPinDescriptor->ulPinId, 
                                       AVC_FUNCTION_ACQUIRE );
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed AvcAcquireReleaseClear %x\n",ntStatus));
        return ntStatus;
    }

#if DBG
    {
     ULONG ulValue;
     ReportPlugValue( pKsDevice, ulPlugNum, pKsPin->DataFlow, &ulValue );
     _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Before PCR Value: %x\n",ulValue ));
    }
#endif

    // Connect Plug to host.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           hPlug,
                                           pPinContext->pCmpRegister->hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           hConnection );
    }
    else {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           pPinContext->pCmpRegister->hPlug,
                                           hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           hConnection );
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed Av61883ConnectCmpPlugs %x\n",ntStatus));
        return ntStatus;
    }

    *pPlugNumber = ulPlugNum;

#if DBG
    {
     ULONG ulValue;
     ReportPlugValue( pKsDevice, ulPlugNum, pKsPin->DataFlow, &ulValue );
     _DbgPrintF( DEBUGLVL_TERSE, ( "[PinCreateConnection] After PCR Value: %x\n",ulValue ));
    }
#endif

    return ntStatus;
}


NTSTATUS
PinCreateGroupConnection(
    PKSPIN pKsPin,
    PKSDEVICE pKsDevice,
    PAVC_UNIT_INFORMATION pAvcUnitInformation,
    PFW_PIN_DESCRIPTOR pFwPinDescriptor )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;

    // For each device in the group make the necessary plug connection.
    for (i=0; i<pGrpInfo->ulDeviceCount && NT_SUCCESS(ntStatus); i++) {
        ULONG ulPlugNumber;
        pHwDevExt = pGrpInfo->pHwDevExts[i];
        pPinContext->pPinGroupInfo[i].hConnection = NULL;
        ntStatus = PinCreateConnection( pKsPin,
                                        pHwDevExt->pKsDevice,
                                        pAvcUnitInformation,
                                        pFwPinDescriptor,
                                        &pPinContext->pPinGroupInfo[i].hConnection,
                                        &pPinContext->pPinGroupInfo[i].ulPlugNumber );
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Group Pin %d Plug Number: %d\n", i, 
                                     pPinContext->pPinGroupInfo[i].ulPlugNumber ));
    }

    if ( NT_SUCCESS(ntStatus) ) {
        pPinContext->hConnection = pPinContext->pPinGroupInfo[0].hConnection;
    }
    else {
        ULONG j;
        NTSTATUS ntStatus1;
        for (j=0; j<i; j++) {
            ntStatus1 = Av61883DisconnectCmpPlugs( pGrpInfo->pHwDevExts[j]->pKsDevice,
                                                   pPinContext->pPinGroupInfo[i].hConnection );
            pPinContext->pPinGroupInfo[i].hConnection = NULL;
        }
    }

    return ntStatus;
}


NTSTATUS
PinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
	PKSDEVICE pKsDevice;
	PHW_DEVICE_EXTENSION pHwDevExt;
	PAVC_UNIT_INFORMATION pAvcUnitInformation;
	PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor;
    PCMP_REGISTER pCmpRegister;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPIN_CONTEXT pPinContext;

    PAGED_CODE();

    // Initialize locals
    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pKsDevice = pKsFilter->Context;
    pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    pAvcUnitInformation = pHwDevExt->pAvcUnitInformation;
    pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreate] Failed 1 %x\n",STATUS_INSUFFICIENT_RESOURCES));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    RtlZeroMemory( pPinContext, sizeof(PIN_CONTEXT) );

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] pin %d Context: %x\n",pKsPin->Id, pPinContext));

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    pPinContext->pPhysicalDeviceObject = pKsDevice->NextDeviceObject;

    // Find the Streaming Terminal to match the data format of the Pin.
    pPinContext->pFwAudioDataRange = 
        GetDataRangeForFormat( pKsPin->ConnectionFormat,
                               (PFWAUDIO_DATARANGE)pKsPin->Descriptor->PinDescriptor.DataRanges[0],
                               pKsPin->Descriptor->PinDescriptor.DataRangesCount );
    if ( !pPinContext->pFwAudioDataRange ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreate] Failed 2 %x\n",STATUS_INVALID_DEVICE_REQUEST));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pFwPinDescriptor = pPinContext->pFwAudioDataRange->pFwPinDescriptor;

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Clear StreamStarted flag. This is used to calculate audio position.
//    pPinContext->fStreamStartedFlag = FALSE;

    // Set initial Outstanding and Completed Request Lists
    InitializeListHead(&pPinContext->OutstandingRequestList);
    InitializeListHead(&pPinContext->CompletedRequestList);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, SynchronizationEvent, FALSE );

    // Do Hardware Initialization and make CMP connections
    if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
        pPinContext->pDevGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    }

    // Make the connection from PC Unit Serial bus output plug to subunit destination plug
    ntStatus = Av61883ReserveVirtualPlug( &pCmpRegister, 0, 
                                          ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ? CMP_PlugOut :
                                                                                      CMP_PlugIn );
    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    pPinContext->pCmpRegister = pCmpRegister;

    if (( pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand ) && 
        ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN )) {
        ntStatus = PinCreateCCMConnection( pKsPin );
    }
    
    else if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
        pPinContext->pPinGroupInfo = AllocMem( PagedPool, sizeof(PIN_GROUP_INFO)*
                                                          pAudioSubunitInfo->pDeviceGroupInfo->ulDeviceCount );
        if ( !pPinContext->pPinGroupInfo ) {
            Av61883ReleaseVirtualPlug( pCmpRegister );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->pPinGroupInfo, FreeMem);

        // NOTE: Grouped devices cannot be CCM.
        ntStatus = PinCreateGroupConnection( pKsPin,
                                             pKsDevice,
                                             pAvcUnitInformation, 
                                             pFwPinDescriptor );
    }

    else {
        ntStatus = PinCreateConnection( pKsPin,
                                        pKsDevice,
                                        pAvcUnitInformation, 
                                        pFwPinDescriptor,
                                        &pPinContext->hConnection,
                                        &pPinContext->ulSerialPlugNumber );
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] Connection Failed %x\n",ntStatus));
        // Release acquired local plug
        Av61883ReleaseVirtualPlug( pCmpRegister );
        return ntStatus;
    }


    // Initialize Lookaside list for CIP request structures
    ExInitializeNPagedLookasideList(
        &pPinContext->CipRequestLookasideList,
        NULL,
        NULL,
        0,
        sizeof(AV_CLIENT_REQUEST_LIST_ENTRY) + sizeof(CIP_FRAME),
        'UAWF',
        30);

    {
        PWAVEFORMATEXTENSIBLE pWavFmt = (PWAVEFORMATEXTENSIBLE)(pKsPin->ConnectionFormat+1);
        ULONG ulNumChannels = (ULONG)pWavFmt->Format.nChannels;
        ULONG ulIndex = ( pWavFmt->Format.nSamplesPerSec == 32000 ) ? FS_32000_INDEX :
                        ( pWavFmt->Format.nSamplesPerSec == 44100 ) ? FS_44100_INDEX :
                        ( pWavFmt->Format.nSamplesPerSec == 48000 ) ? FS_48000_INDEX :
                                                                      FS_96000_INDEX;

        ntStatus = AudioSetSampleRateOnPlug( pKsPin, pWavFmt->Format.nSamplesPerSec );

        // Setup approriate allocator framing for the interface selected.
        KsEdit( pKsPin, &pKsPin->Descriptor, FWAUDIO_POOLTAG );
        KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, FWAUDIO_POOLTAG );

        // Set up allocator such that roughly 32 ms of data gets sent in a buffer.
        pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = AllocatorFramingTable[ulIndex].MinFrameSize * ulNumChannels;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = AllocatorFramingTable[ulIndex].MaxFrameSize * ulNumChannels;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping     = AllocatorFramingTable[ulIndex].Stepping     * ulNumChannels;
    }

    return ntStatus;
}

VOID
PinWaitForStarvation(PKSPIN pKsPin)
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    KIRQL irql;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ((pPinContext->ulCancelledBuffers + pPinContext->ulUsedBuffers ) != pPinContext->ulAttachCount) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinWaitForStarvation] pin %d Context: %x List: %x\n",
                                    pKsPin->Id, pPinContext, &pPinContext->OutstandingRequestList));
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinWaitForStarvation] Wait Complete\n"));
        
    }
    else
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
}

NTSTATUS
PinClose(
    IN PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
    PKSDEVICE pKsDevice;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pKsDevice = pKsFilter->Context;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] pin %d Context: %x\n",pKsPin->Id, pPinContext));

#if DBG
    if ( pPinContext->ulAttachCount != (pPinContext->ulUsedBuffers + pPinContext->ulCancelledBuffers)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] ulAttachCount %d ulUsedBuffers: %d ulCancelledBuffers %d\n",
                         pPinContext->ulAttachCount, 
                         pPinContext->ulUsedBuffers,
                         pPinContext->ulCancelledBuffers ));
    }
#endif

    if ( !((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fSurpriseRemoved ) {

        // Disconnect plugs.
        ntStatus = PinDisconnectPlugs( pKsPin );

        if ( NT_SUCCESS(ntStatus) ) {
            // Need to reconnect if CCM and PC was not the source of the audio before the stream started
            if ( pPinContext->fReconnect ) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] Reconnect: %x\n",pPinContext->fReconnect));
                if ( pPinContext->fReconnect == 1 ) {
                    // Reconnect to subunit plug within device or external plug
                    ntStatus = CCMSignalSource( pKsDevice, 
                                                AVC_CTYPE_CONTROL,
                                                &pPinContext->CcmSignalSource );
                }
                else if ( pPinContext->fReconnect == 2 ) {
                    // Reconnect to serial bus device
                    ntStatus = CCMInputSelectControl ( pKsDevice,
                                                       INPUT_SELECT_SUBFN_CONNECT,
                                                       bswapw(pPinContext->CcmInputSelect.usNodeId), 
                                                       pPinContext->CcmInputSelect.ucOutputPlug,
                                                       &pPinContext->CcmInputSelect.SignalDestination );

                }
            }
        }

        ExDeleteNPagedLookasideList( &pPinContext->CipRequestLookasideList );
    }

    return ntStatus;
}

NTSTATUS
PinCancelOutstandingRequests(
    IN PKSPIN pKsPin )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    KIRQL kIrql;

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    while ( !IsListEmpty(&pPinContext->OutstandingRequestList) ) {
        pAVListEntry = (PAV_CLIENT_REQUEST_LIST_ENTRY)
            RemoveHeadList( &pPinContext->OutstandingRequestList );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Canceling Request: %x\n",pAVListEntry) );
        
        AM824CancelRequest(pAVListEntry);

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

    return STATUS_SUCCESS;
}

NTSTATUS
PinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] pin %d Context: %x From: %d To: %d\n",
                                pKsPin->Id, pPinContext, FromState, ToState));

    switch( ToState ) {
        case KSSTATE_STOP:
            DbgLog( "KSSTOP", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                              pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            if (pPinContext->fIsStreaming && !pHwDevExt->fSurpriseRemoved) {
                if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
                    // Wait for Pin Starvation 
                    PinWaitForStarvation( pKsPin );
                }
    
                ntStatus = Av61883StopTalkOrListen( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                                    pPinContext->hConnection );

                if ( !NT_SUCCESS(ntStatus) ) TRAP;

                // If capturing, Cancel all outstanding requests.
                if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
                    PinCancelOutstandingRequests( pKsPin );

                    // Wait for Pin Starvation
                    PinWaitForStarvation( pKsPin );
                }

                pPinContext->fIsStreaming = FALSE;
            }
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] STOP\n"));

            break;

        case KSSTATE_ACQUIRE:
            DbgLog( "KSACQIR", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] ACQUIRE\n"));
            break;

        case KSSTATE_PAUSE:
            DbgLog( "KSPAUSE", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PAUSE\n"));

            
            break;

        case KSSTATE_RUN: 
   
            DbgLog( "KSRUN",   pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] RUN\n"));

            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {

                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] Start Listening\n"));
                ntStatus = 
                    Av61883StartTalkingOrListening( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                                    pPinContext->hConnection,
                                                    Av61883_Listen );
                if ( NT_SUCCESS(ntStatus) )
                    pPinContext->fIsListening = TRUE;
            }
    }

#if DBG
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] ERROR: ntStatus: %x\n", ntStatus));
    }
#endif

    return ntStatus;
}


NTSTATUS
PinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL )
{

    NTSTATUS ntStatus = STATUS_NO_MATCH;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDataFormat] pin %d\n",pKsPin->Id));

    // If the old format is not NULL then the pin has already been created.
    if ( OldFormat ) {
        PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
        ULONG ulFormatType = pPinContext->pFwAudioDataRange->ulDataType & DATA_FORMAT_TYPE_MASK;

        // If the pin has already been created make sure no other interface is used
        if ((PFWAUDIO_DATARANGE)DataRange == pPinContext->pFwAudioDataRange) {
            ntStatus = PinValidateDataFormat(  pKsPin, 
				                               (PFWAUDIO_DATARANGE)DataRange );
        }

        if ( NT_SUCCESS(ntStatus) && (ulFormatType == AUDIO_DATA_TYPE_TIME_BASED)) {
            ULONG ulSampleRate =
                ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
            ntStatus = AudioSetSampleRateOnPlug( pKsPin, ulSampleRate );
        }
    }
    // Otherwise simply check if this is a valid format
    else
        ntStatus = PinValidateDataFormat(  pKsPin, 
		                                   (PFWAUDIO_DATARANGE)DataRange );

    _DbgPrintF(DEBUGLVL_VERBOSE,("Exit [PinSetDataFormat] status: %x\n",ntStatus));

    return ntStatus;
}

NTSTATUS
PinProcess(
    IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    DbgLog("PinProc", pKsPin, pPinContext, 0, 0);

    switch( pPinContext->pFwAudioDataRange->ulTransportType ) {
        case MLAN_AM824_IEC958:
            ntStatus = AM824ProcessData( pKsPin );
            break;
        case MLAN_AM824_RAW:
        case MLAN_24BIT_PACKED:
        default:
            ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    return ntStatus;
}

NTSTATUS
PinConnect(
    IN PKSPIN pKsPin
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinConnect] pin %d\n",pKsPin->Id));
    return STATUS_SUCCESS;
}

void
PinDisconnect(
    IN PKSPIN pKsPin
    )
{
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinDisconnect] pin %d\n",pKsPin->Id));
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
//        ntStatus = RenderStreamClose( pKsPin );
    }
    else {
//        ntStatus = CaptureStreamClose( pKsPin );
    }
}

NTSTATUS
PinDataIntersectHandler(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    ULONG ulPinId = pKsPinProperty->PinId;
    PKSPIN_DESCRIPTOR_EX pKsPinDescriptorEx;
    PFWAUDIO_DATARANGE pFwAudioRange;
    NTSTATUS ntStatus = STATUS_NO_MATCH;

    if ( !pKsFilter ) {
        return STATUS_INVALID_PARAMETER;
    }

    pKsPinDescriptorEx = 
        (PKSPIN_DESCRIPTOR_EX)&pKsFilter->Descriptor->PinDescriptors[ulPinId];

    pFwAudioRange = 
        FindDataIntersection((PKSDATARANGE_AUDIO)DataRange,
                             (PFWAUDIO_DATARANGE *)pKsPinDescriptorEx->PinDescriptor.DataRanges,
                             pKsPinDescriptorEx->PinDescriptor.DataRangesCount);

    if ( pFwAudioRange ) {

        *pDataSize = GetIntersectFormatSize( pFwAudioRange );

        if ( !DataBufferSize ) {
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else if ( *pDataSize > DataBufferSize ) {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ( *pDataSize <= DataBufferSize ) {
            ConvertDatarangeToFormat( pFwAudioRange,
                                      (PKSDATAFORMAT)pData );
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

void
PinReset(
    IN PKSPIN pKsPin
    )
{
}

NTSTATUS
PinSurpriseRemove(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSurpriseRemove] pin %d\n",pKsPin->Id));

    // Stop the talk/listen if streaming.
    if ( pPinContext->fIsStreaming ) {
        ntStatus = Av61883StopTalkOrListen( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                            pPinContext->hConnection );
        if ( !NT_SUCCESS(ntStatus) ) {
            TRAP;
        }
    }

    // Cancel all submitted data requests if any. Wait for them to return.
    ntStatus = PinCancelOutstandingRequests( pKsPin );
    if ( NT_SUCCESS(ntStatus) ) {
        PinWaitForStarvation( pKsPin );
    }

    // Disconnect plugs.
    ntStatus = PinDisconnectPlugs( pKsPin );

    return ntStatus;
}

/*
struct _KSPIN_DISPATCH {
    PFNKSPINIRP Create;
    PFNKSPINIRP Close;
    PFNKSPIN Process;
    PFNKSPINVOID Reset;
    PFNKSPINSETDATAFORMAT SetDataFormat;
    PFNKSPINSETDEVICESTATE SetDeviceState;
    PFNKSPIN Connect;
    PFNKSPINVOID Disconnect;
    const KSCLOCK_DISPATCH* Clock;
    const KSALLOCATOR_DISPATCH* Allocator;
};
*/

const
KSPIN_DISPATCH
PinDispatch =
{
    PinCreate,
    PinClose,
    PinProcess,
    PinReset,
    PinSetDataFormat,
    PinSetDeviceState,
    PinConnect,
    PinDisconnect,
    NULL,
    NULL
};

const
KSDATAFORMAT BridgePinDataFormat[] = 
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_AUDIO},
    {STATIC_KSDATAFORMAT_SUBTYPE_ANALOG},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

DEFINE_KSPIN_INTERFACE_TABLE(PinInterface) {
   {
    STATICGUIDOF(KSINTERFACESETID_Standard),
    KSINTERFACE_STANDARD_STREAMING,
    0
   }
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMedium) {
    {
     STATICGUIDOF(KSMEDIUMSETID_Standard),
     KSMEDIUM_TYPE_ANYINSTANCE,
     0
    }
};

const
PKSDATAFORMAT pBridgePinFormats = (PKSDATAFORMAT)BridgePinDataFormat;

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED,
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    8,
    sizeof(ULONG) - 1,
    0, 
    0
);

NTSTATUS
PinBuildDescriptors( 
    PKSDEVICE pKsDevice, 
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx, 
    PULONG pNumPins,
    PULONG pPinDecSize )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    
    PKSPIN_DESCRIPTOR_EX pPinDescEx;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    ULONG ulNumPins, i, j = 0;
    ULONG ulNumBridgePins;
    ULONG ulNumStreamPins;
    PKSPROPERTY_ITEM pStrmPropItems;
    PKSPROPERTY_SET pStrmPropSet;
    ULONG ulNumPropertyItems = 1;
    ULONG ulNumPropertySets = 1;
    GUID *pTTypeGUID;
    ULONG ulFormatCount = 0;
    PKSDATARANGE_AUDIO *ppAudioDataRanges;
    PFWAUDIO_DATARANGE pAudioDataRange;

    // Determine the number of Pins in the Filter ( Should = # Plug Registers )
    // ISSUE-2001/01/10-dsisolak: For now assume only 1 configuration
    ulNumPins       = pAudioSubunitInfo->ulDevicePinCount;
    ulNumBridgePins = CountDeviceBridgePins( pKsDevice );
    ulNumStreamPins = ulNumPins - ulNumBridgePins;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinBuildDescriptors] ulNumPins: %d ulNumBridgePins: %d\n",
                                    ulNumPins, ulNumBridgePins ));

    // Determine the number of Properties and Property Sets for the Pin.
    BuildPinPropertySet( pHwDevExt,
                         NULL,
                         NULL,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Count the total number of data ranges in the device.
    for ( i=0; i<ulNumStreamPins; i++ ) {
        ulFormatCount += CountFormatsForPin( pKsDevice, i );
    }

    // Allocate all the space we need to describe the Pins in the device.
    *pPinDecSize = sizeof(KSPIN_DESCRIPTOR_EX);
    *pNumPins = ulNumPins;
    pPinDescEx = *ppPinDescEx =
       (PKSPIN_DESCRIPTOR_EX)AllocMem(NonPagedPool, 
	                                    (ulNumPins * 
                                         ( sizeof(KSPIN_DESCRIPTOR_EX) +
                                           sizeof(KSAUTOMATION_TABLE)  +
                                           sizeof(KSALLOCATOR_FRAMING_EX) )) +
                                        (ulFormatCount *
                                         (  sizeof(PKSDATARANGE_AUDIO)  +
                                            sizeof(FWAUDIO_DATARANGE) )) +
                                        (ulNumPropertySets*sizeof(KSPROPERTY_SET)) +
                                        (ulNumPropertyItems*sizeof(KSPROPERTY_ITEM)) +
                                        (ulNumBridgePins*sizeof(GUID)) );
    if ( !pPinDescEx )
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pPinDescEx, FreeMem);

    // Zero out all descriptors to start
    RtlZeroMemory(pPinDescEx, ulNumPins*sizeof(KSPIN_DESCRIPTOR_EX));

    // Set the pointer for the Automation Tables
    pKsAutomationTable = (PKSAUTOMATION_TABLE)(pPinDescEx + ulNumPins);
    RtlZeroMemory(pKsAutomationTable, ulNumPins * sizeof(KSAUTOMATION_TABLE));

    // Set pointers to Property Sets for Streaming Pins
    pStrmPropSet   = (PKSPROPERTY_SET)(pKsAutomationTable+ulNumPins);
    pStrmPropItems = (PKSPROPERTY_ITEM)(pStrmPropSet + ulNumPropertySets);

    // Set pointer to Terminal Type GUIDS
    pTTypeGUID = (GUID *)(pStrmPropItems + ulNumPropertyItems);

    // Set Pointers for DataRange pointers and DataRanges for streaming Pins
    ppAudioDataRanges = (PKSDATARANGE_AUDIO *)(pTTypeGUID + ulNumBridgePins);
    pAudioDataRange   = (PFWAUDIO_DATARANGE)(ppAudioDataRanges + ulFormatCount);

    // Set pointer to Allocator Framing structures for Streaming Pins
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)(pAudioDataRange + ulFormatCount);

    BuildPinPropertySet( pHwDevExt,
                         pStrmPropItems,
                         pStrmPropSet,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // For each pin generated by AVC.sys fill in the Descriptor for it.
    for ( i=0; i<ulNumPins; i++ ) {
        PFW_PIN_DESCRIPTOR pFwPinDesc = &pAudioSubunitInfo->pPinDescriptors[i];
        PAVCPRECONNECTINFO pPreConnInfo = &pFwPinDesc->AvcPreconnectInfo.ConnectInfo;
        ULONG ulFormatsForPin;

        // If the pin is a streaming pin, fill in the descriptor accordingly
        // (Whatever is not already filled in by AVC.sys)

        if ( pFwPinDesc->fStreamingPin ) {
            pPinDescEx[i].Dispatch = &PinDispatch;
            pPinDescEx[i].AutomationTable = &pKsAutomationTable[i];

            pKsAutomationTable[i].PropertySetsCount = ulNumPropertySets;
            pKsAutomationTable[i].PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
            pKsAutomationTable[i].PropertySets      = pStrmPropSet;

            pPinDescEx[i].PinDescriptor = pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            ulFormatsForPin = CountFormatsForPin( pKsDevice, i );

            pPinDescEx[i].PinDescriptor.DataRangesCount = ulFormatsForPin;
        
            pPinDescEx[i].PinDescriptor.DataRanges = (const PKSDATARANGE *)ppAudioDataRanges;

            GetPinDataRanges( pKsDevice, i, ppAudioDataRanges, pAudioDataRange );

            ppAudioDataRanges += ulFormatsForPin;
            pAudioDataRange   += ulFormatsForPin;

            if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
                pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;
                pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER;
            }
            else {
                pPinDescEx[i].PinDescriptor.Category = (GUID*) &PINNAME_CAPTURE;
                pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING | KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY;
            }

            pPinDescEx[i].InstancesPossible  = 1;
            pPinDescEx[i].InstancesNecessary = 0;

            pPinDescEx[i].IntersectHandler = PinDataIntersectHandler;

            // Set up Allocator Framing
            pPinDescEx[i].AllocatorFraming = &AllocatorFraming;

        }
        else {
            PKSPIN_DESCRIPTOR pKsPinDesc = &pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            pPinDescEx[i].Dispatch = NULL;
            pPinDescEx[i].AutomationTable = NULL;

            _DbgPrintF( DEBUGLVL_VERBOSE, ("Non-Streaming Pin: %x\n", pFwPinDesc));

            if ( pFwPinDesc->fFakePin ) {

                pFwPinDesc->AvcPinDescriptor.PinId = i;
                
                pKsPinDesc->InterfacesCount = 1;
                pKsPinDesc->Interfaces = PinInterface;
                pKsPinDesc->MediumsCount = 1;
                pKsPinDesc->Mediums = PinMedium;
                pKsPinDesc->DataFlow = KSPIN_DATAFLOW_OUT;
            }

            pKsPinDesc->Communication = KSPIN_COMMUNICATION_BRIDGE;

            pPinDescEx[i].PinDescriptor = pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
            pPinDescEx[i].PinDescriptor.DataRanges = &pBridgePinFormats;
            pPinDescEx[i].PinDescriptor.Category = &pTTypeGUID[j];

            GetCategoryForBridgePin( pKsDevice, i, &pTTypeGUID[j++] );

            pPinDescEx[i].InstancesPossible  = 0;
            pPinDescEx[i].InstancesNecessary = 0;

        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinBuildDescriptors] ppAudioDataRanges: %x\n", ppAudioDataRanges ));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\parsedsc.c ===
#include "Common.h"

UCHAR ucFDFs[MAX_SFC_COUNT] = { SFC_32000Hz,
                                SFC_44100Hz,
                                SFC_48000Hz,
                                SFC_96000Hz };


PAUDIO_SUBUNIT_DEPENDENT_INFO 
ParseFindAudioSubunitDependentInfo(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc )
{
    PUCHAR pTmpOffset = (PUCHAR)pSubunitIdDesc;
    ULONG ulASUOffset, ulNumRootLists;

    ulNumRootLists = (ULONG)((pSubunitIdDesc->ucNumberOfRootObjectListsHi<<8) |
                              pSubunitIdDesc->ucNumberOfRootObjectListsLo     );

    _DbgPrintF( DEBUGLVL_VERBOSE, (" ulNumRootLists %d\n",ulNumRootLists));
    ulASUOffset = 8 + (ulNumRootLists * (ULONG)pSubunitIdDesc->ucSizeOfListID);

    return (PAUDIO_SUBUNIT_DEPENDENT_INFO)&pTmpOffset[ulASUOffset];

}

PCONFIGURATION_DEPENDENT_INFO
ParseFindFirstAudioConfiguration(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc )
{
    PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;

    pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );

    return (PCONFIGURATION_DEPENDENT_INFO)(pAudioSUDepInfo + 1);
}

PSOURCE_PLUG_LINK_INFO
ParseFindSourcePlugLinkInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo )
{
    return (PSOURCE_PLUG_LINK_INFO)
            ((PUCHAR)pConfigDepInfo + (3*sizeof(USHORT)) +
             (ULONG)bswapw(pConfigDepInfo->usMasterClusterStructureLength) );
}

PFUNCTION_BLOCKS_INFO
ParseFindFunctionBlocksInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo )
{
    PSOURCE_PLUG_LINK_INFO pSourcePlugInfo = ParseFindSourcePlugLinkInfo(pConfigDepInfo);

    return (PFUNCTION_BLOCKS_INFO)(pSourcePlugInfo->pSourceID + (ULONG)pSourcePlugInfo->ucNumLinks);
}

VOID
ParseFunctionBlock( 
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    PFUNCTION_BLOCK pFunctionBlock )
{
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);

    pFunctionBlock->pBase  = pFBDepInfo;
    pFunctionBlock->ulType = (ULONG)pFBDepInfo->ucType;
    pFunctionBlock->ulBlockId = (ULONG)(*(PUSHORT)&pFBDepInfo->ucType);
    pFunctionBlock->ulNumInputPlugs = (ULONG)pFBDepInfo->ucNumberOfInputPlugs;

    pFunctionBlock->pSourceId = (PSOURCE_ID)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += (pFunctionBlock->ulNumInputPlugs * sizeof(SOURCE_ID));

    pFunctionBlock->pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += ((ULONG)bswapw(pFunctionBlock->pChannelCluster->usLength) + sizeof(USHORT));

    pFunctionBlock->ulFunctionTypeInfoLength = (ULONG)bswapw(*(PUSHORT)(&pcFBDepInfo[ulFBIndx]));

    ulFBIndx += sizeof(USHORT);

	pFunctionBlock->pFunctionTypeInfo = &pcFBDepInfo[ulFBIndx];
			
    _DbgPrintF( DEBUGLVL_VERBOSE, (" pFunctionBlock: %x pFBDepInfo: %x\n",
                                     pFunctionBlock, pFBDepInfo ));

}

NTSTATUS
ParseAudioSubunitDescriptor( 
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
    PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo;
    PSOURCE_PLUG_LINK_INFO pSourcePlugInfo;
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo;
    PFBLOCK_CHANNEL_CLUSTER pFBChannelCluster;
    ULONG ulNumConfigs;
    PAUDIO_CONFIGURATION pAudioConfig;
    PFUNCTION_BLOCK pFunctionBlocks;
    PFUNCTION_BLOCKS_INFO pFunctionBlocksInfo;
    ULONG i;

#ifdef SA_HACK
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    if (( pUnitInfo->IEC61883UnitIds.VendorID == SA_VENDOR_ID ) &&
        ( pUnitInfo->IEC61883UnitIds.ModelID  == SA_MODEL_ID  )) {

        PUCHAR pTmpOffset = (PUCHAR)pSubunitIdDesc;
        *((PUSHORT)&pTmpOffset[22]) = usBitSwapper(*((PUSHORT)&pTmpOffset[22]));
//        *((PUSHORT)&pTmpOffset[48]) = usBitSwapper(*((PUSHORT)&pTmpOffset[48]));
//        *((PUSHORT)&pTmpOffset[50]) = usBitSwapper(*((PUSHORT)&pTmpOffset[50]));
    }

#endif

    _DbgPrintF( DEBUGLVL_TERSE, ("[ParseAudioSubunitDescriptor] %x\n", pSubunitIdDesc));

    pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );
    ulNumConfigs = (ULONG)pAudioSUDepInfo->ucNumberOfConfigurations;

    pAudioConfig = 
        pAudioSubunitInfo->pAudioConfigurations = 
                  (PAUDIO_CONFIGURATION)AllocMem( NonPagedPool, 
                                                  ulNumConfigs * sizeof(AUDIO_CONFIGURATION) );
    if ( !pAudioConfig ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pAudioConfig, FreeMem);

    pConfigDepInfo = (PCONFIGURATION_DEPENDENT_INFO)(pAudioSUDepInfo + 1);

    _DbgPrintF( DEBUGLVL_VERBOSE, (" ucNumberOfConfigurations %d\n",pAudioSUDepInfo->ucNumberOfConfigurations));

    for (i=0; i<ulNumConfigs; i++ ) {
        ULONG j;

        pAudioConfig[i].pBase = pConfigDepInfo;

        // Get the Master Channel Cluster information
        pAudioConfig[i].ChannelCluster.ulNumberOfChannels = 
            (ULONG)pConfigDepInfo->ucNumberOfChannels;
        pAudioConfig[i].ChannelCluster.ulPredefinedChannelConfig = 
            (ULONG)usBitSwapper(bswapw(pConfigDepInfo->usPredefinedChannelConfig));

        _DbgPrintF( DEBUGLVL_VERBOSE, (" ulNumberOfChannels: %d\n",pAudioConfig[i].ChannelCluster.ulNumberOfChannels));
        _DbgPrintF( DEBUGLVL_VERBOSE, (" ulPredefinedChannelConfig: %x\n",pAudioConfig[i].ChannelCluster.ulPredefinedChannelConfig));

        // ISSUE-2001/01/10-dsisolak Need to figure out what to do with Undefined channels!

        pSourcePlugInfo = ParseFindSourcePlugLinkInfo( pConfigDepInfo );
        pAudioConfig[i].ulNumberOfSourcePlugs = (ULONG)pSourcePlugInfo->ucNumLinks;
        pAudioConfig[i].pSourceId = pSourcePlugInfo->pSourceID;

        pFunctionBlocksInfo = ParseFindFunctionBlocksInfo( pConfigDepInfo );
        pAudioConfig[i].ulNumberOfFunctionBlocks = (ULONG)pFunctionBlocksInfo->ucNumBlocks;

        pFunctionBlocks = 
            pAudioConfig[i].pFunctionBlocks = (PFUNCTION_BLOCK)
                     AllocMem( NonPagedPool, (ULONG)pFunctionBlocksInfo->ucNumBlocks * sizeof(FUNCTION_BLOCK));
        if ( !pFunctionBlocks )  return STATUS_INSUFFICIENT_RESOURCES;

        KsAddItemToObjectBag(pKsDevice->Bag, pFunctionBlocks, FreeMem);

        pFBDepInfo = pFunctionBlocksInfo->FBDepInfo;
        for (j=0; j<pAudioConfig[i].ulNumberOfFunctionBlocks; j++) {
            PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;

            ParseFunctionBlock( pFBDepInfo, &pFunctionBlocks[j] );

            pFBDepInfo = (PFUNCTION_BLOCK_DEPENDENT_INFO)
                (pcFBDepInfo + ((ULONG)bswapw(pFBDepInfo->usLength)) + 2);
        }

        pConfigDepInfo = (PCONFIGURATION_DEPENDENT_INFO)
            ((PUCHAR)pConfigDepInfo + (ULONG)bswap(pConfigDepInfo->usLength));
    }

    return STATUS_SUCCESS;
}

VOID
CountTopologyComponents(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories )
{
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    // ISSUE-2001/01/10-dsisolak: Assuming only one configuration
    PAUDIO_CONFIGURATION pAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;
    PFUNCTION_BLOCK pFunctionBlocks = pAudioConfiguration->pFunctionBlocks;
    ULONG i;
    union {
        PVOID pFBInfo;
        PFEATURE_FUNCTION_BLOCK pFeature;
        PCODEC_FUNCTION_BLOCK pCodec;
        PPROCESS_FUNCTION_BLOCK pProcess;
    } u;

    // Initialize Values
    *pNumCategories  = 1; // Need to add space for KSCATEGORY_AUDIO
    *pNumNodes       = 0;
    *pNumConnections = 0;
    *pbmCategories   = 0;

    // Go through device plugs and create nodes/connections for them
    for (i=0; i<pAudioSubunitInfo->ulDevicePinCount; i++) {
        KSPIN_DATAFLOW KsDataFlow = pAudioSubunitInfo->pPinDescriptors[i].AvcPinDescriptor.PinDescriptor.DataFlow;
        (*pNumNodes)++;
        (*pNumConnections)++;
        if ( pAudioSubunitInfo->pPinDescriptors[i].fStreamingPin ) {
            (*pNumConnections)++;
            if ( KSPIN_DATAFLOW_OUT == KsDataFlow ) {
                if ( !(*pbmCategories & KSPIN_DATAFLOW_IN ) ) {
                    (*pbmCategories) |= KSPIN_DATAFLOW_IN;
                    (*pNumCategories)++;
                }
            }
        }
        else {
            if ( !(*pbmCategories & KsDataFlow) ) {
                (*pbmCategories) |= KsDataFlow;
                (*pNumCategories)++;
            }
        }
    }
    
    // Go through the function blocks and count nodes and connections
    for (i=0; i<pAudioConfiguration->ulNumberOfFunctionBlocks; i++) {
        u.pFBInfo = pFunctionBlocks[i].pFunctionTypeInfo;
//        _DbgPrintF(DEBUGLVL_VERBOSE, ("u.pFBInfo: %x\n",u.pFBInfo));

        switch( pFunctionBlocks[i].ulType ) {

            case FB_SELECTOR:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            case FB_FEATURE:
                {

                 ULONG bmMergedControls = 0;
                 ULONG bmControls;
                 ULONG j, k;
                 ULONG ulNumChannels = pFunctionBlocks[i].pChannelCluster->ucNumberOfChannels;

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Feature Fblk # Channels: %x\n",ulNumChannels));

                 ASSERT(u.pFeature->ucControlSize <= sizeof(ULONG) );

#ifdef MASTER_FIX

                 // First Check if there are Master channel controls
                 bmControls = 0;
                 for (j=0; j<u.pFeature->ucControlSize; j++) {
                     bmControls <<= 8;
                     bmControls |= u.pFeature->bmaControls[j];
                 }

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Master Controls: %x\n",bmControls));

#ifdef SUM_HACK
                 // Add a sum node to put before the Master Control. Thus the fader will not 
                 // show up in sndvol unless there is another Feature unit later.
                 if ( bmControls ) {
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }
#endif

                 while (bmControls) {
                     bmControls = (bmControls & (bmControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }


                 // Create a new node and connection for each feature.
                 for (k=0; k<ulNumChannels; k++) {
                     bmControls = 0;
                     for (j=0; j<u.pFeature->ucControlSize; j++) {
                         bmControls <<= 8;
                         bmControls |= u.pFeature->bmaControls[(k+1)*u.pFeature->ucControlSize+j];
                     }
                     bmMergedControls |= bmControls;
                 }

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Channel Controls: %x\n",bmControls));

                 // Count the nodes and connections
                 while (bmMergedControls) {
                     bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }

#else
                 // Create a new node and connection for each feature.
                 for (k=0; k<=ulNumChannels; k++) {
                     bmControls = 0;
                     for (j=0; j<u.pFeature->ucControlSize; j++) {
                         bmControls <<= 8;
                         bmControls |= u.pFeature->bmaControls[k*u.pFeature->ucControlSize+j];
                     }
                     bmMergedControls |= bmControls;
                 }

                 // Count the nodes and connections
                 while (bmMergedControls) {
                     bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }

                 if ( 
#endif

                }
                break;

            case FB_PROCESSING:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            case FB_CODEC:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            default:
                TRAP;
                break;
        }
    }
}

ULONG
CountDeviceBridgePins( 
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor = pAudioSubunitInfo->pPinDescriptors;
    ULONG ulBridgePinCount = 0;
    ULONG i;

    for (i=0; i<pAudioSubunitInfo->ulDevicePinCount; pFwPinDescriptor++, i++) {
        if ( !pFwPinDescriptor->fStreamingPin ) {
            ulBridgePinCount++;
        }
/*
        else if ( pAvcPreconnectInfo->Flags & KSPIN_FLAG_AVC_PERMANENT ) { 
            if ( !( pAvcPreconnectInfo->Flags & (KSPIN_FLAG_AVC_FIXEDPCR | KSPIN_FLAG_AVC_PCRONLY) ) ) {
                ulBridgePinCount++;
            }
        }
        else {
            TRAP; // ISSUE-2001/01/10-dsisolak Need to heuristically determine what connections are
                  // possible for this Subunit Plug.
        }
*/
    }

    return ulBridgePinCount;
}

ULONG
CountFormatsForPin( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PFW_PIN_DESCRIPTOR pPinDesc = 
        &(((PAUDIO_SUBUNIT_INFORMATION)pHwDevExt->pAvcSubunitInformation)->pPinDescriptors[ulPinNumber]);
    ULONG ulFormatCnt = 0;
    ULONG ulTransportCnt = 0;
    ULONG i;

    if ( pPinDesc->fFakePin ) ulFormatCnt = ulTransportCnt = 1; // Only one format for fake pins: Analog
    else if ( !pPinDesc->fStreamingPin ) ulFormatCnt = ulTransportCnt = 1; // Only one format for bridge pins: Analog
    else {
        for (i=0; i<MAX_SFC_COUNT; i++) {
            if ( pPinDesc->bmFormats & (1<<ucFDFs[i]) ) {
                ulFormatCnt++;
            }
            if ( pPinDesc->bmTransports & (1<<i) ) {
                ulTransportCnt++;
            }
        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Pin # %d: ulFormatCnt: %d, ulTransportCnt: %d\n",
                                    ulPinNumber, ulFormatCnt, ulTransportCnt ));

    ASSERT((ulFormatCnt * ulTransportCnt) >= 1);
    ASSERT(ulTransportCnt == 1);  // ISSUE-2001/01/10-dsisolak: What to do about multiple transports for a data type?

    return (ulFormatCnt * ulTransportCnt);
}

VOID
ConvertDescriptorToDatarange(
    ULONG ulFormatType,
    ULONG ulChannelCount,
    ULONG ulTransportType,
    ULONG ulSampleRate,
    PFWAUDIO_DATARANGE pAudioDataRange )
{
	PKSDATARANGE_AUDIO pKsAudioRange = &pAudioDataRange->KsDataRangeAudio;

	// Create the KSDATARANGE_AUDIO structure
    pKsAudioRange->DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
    pKsAudioRange->DataRange.Reserved   = 0;
    pKsAudioRange->DataRange.Flags      = 0;
    pKsAudioRange->DataRange.SampleSize = 0;
    pKsAudioRange->DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO; // Everything is Audio.
    pKsAudioRange->DataRange.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    // Map the USB format to a KS sub-format, if possible.
    switch ( ulFormatType ) {
        case AUDIO_DATA_TYPE_PCM:
        case AUDIO_DATA_TYPE_PCM8:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;         break;
        case AUDIO_DATA_TYPE_IEEE_FLOAT:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;  break;
        case AUDIO_DATA_TYPE_AC3:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_AC3_AUDIO;   break;
        case AUDIO_DATA_TYPE_MPEG:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MPEG;        break;
        default:
            // This USB format does not map to a sub-format!
            pKsAudioRange->DataRange.SubFormat = GUID_NULL;                        break;
    }

    // Fill-in the correct data for the specified WAVE format.
    switch( ulFormatType & DATA_FORMAT_TYPE_MASK ) {

        case AUDIO_DATA_TYPE_TIME_BASED:
            // Fill in the audio range information
            pKsAudioRange->MaximumChannels   = ulChannelCount;
			pAudioDataRange->ulTransportType = ulTransportType;

            switch(ulTransportType) {
			    case MLAN_AM824_IEC958:
                case MLAN_AM824_RAW:
					 pKsAudioRange->MinimumBitsPerSample =
						 pKsAudioRange->MaximumBitsPerSample = 32;
                     pAudioDataRange->ulValidDataBits = 24;

					 break;

                case MLAN_24BIT_PACKED:
					 pKsAudioRange->MinimumBitsPerSample =
						 pKsAudioRange->MaximumBitsPerSample = 24;
                     pAudioDataRange->ulValidDataBits = 24; // 24bits in 24bits packed
					 break;

			    default:
					 TRAP;
					 break;
            }

			pKsAudioRange->MinimumSampleFrequency = ulSampleRate;
            pKsAudioRange->MaximumSampleFrequency = ulSampleRate;

            break;

        default:
            // This format does not map to a WAVE format!

            TRAP;
            break;
    }

}

void
GetPinDataRanges( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber, 
    PKSDATARANGE_AUDIO *ppAudioDataRanges,
    PFWAUDIO_DATARANGE pAudioDataRange )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinNumber];
    PAUDIO_CONFIGURATION pAudioConfig = pAudioSubunitInfo->pAudioConfigurations;
    ULONG ulFormatCount = CountFormatsForPin( pKsDevice, ulPinNumber );

    ULONG ulChannelConfig = pAudioConfig->ChannelCluster.ulPredefinedChannelConfig;
    ULONG ulChannelCnt    = pAudioConfig->ChannelCluster.ulNumberOfChannels;

    ULONG ulSRBit;
    ULONG ulSFCMask;
    ULONG i;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetPinDataRanges]: Transport:%x, SR:%x\n",
                                   pPinDescriptor->bmTransports,
                                   pPinDescriptor->bmFormats ));

    ASSERT( pPinDescriptor->bmTransports == (1<<EVT_AM824) );

    // For each Sample Rate create a separate datarange?

    for (i=0,ulSRBit=0;i<ulFormatCount;i++) {
        
        while ( !(pPinDescriptor->bmFormats & (1<<ucFDFs[ulSRBit])) ) ulSRBit++;
        
        // Find the channel config for this pin;
        ulSFCMask = ucFDFs[ulSRBit];
        ConvertDescriptorToDatarange( AUDIO_DATA_TYPE_PCM,
                                      ulChannelCnt,
                                      EVT_AM824,
                                      (ulSFCMask & SFC_32000Hz ) ? 32000 :
                                      (ulSFCMask & SFC_44100Hz ) ? 44100 :
                                      (ulSFCMask & SFC_48000Hz ) ? 48000 :
                                                                   96000 ,
                                      &pAudioDataRange[i] );

        ppAudioDataRanges[i] = &pAudioDataRange[i].KsDataRangeAudio;

		// Fill in Misc. Datarange info
		pAudioDataRange[i].ulDataType      = AUDIO_DATA_TYPE_PCM; // Assuming PCM for now.
		pAudioDataRange[i].ulNumChannels   = ulChannelCnt;
		pAudioDataRange[i].ulChannelConfig = ulChannelConfig; 
		pAudioDataRange[i].ulSlotSize      = pAudioDataRange[i].KsDataRangeAudio.MinimumBitsPerSample>>3;
        pAudioDataRange[i].pFwPinDescriptor = pPinDescriptor;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetPinDataRanges]: pAudioDataRange[%d]: %x\n",i, &pAudioDataRange[i]));
    }
}

BOOLEAN
IsSampleRateInRange(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulSampleRate )
{

    ULONG ulMinSampleRate, ulMaxSampleRate;
    BOOLEAN bInRange = FALSE;

    if ( (pFWAudioRange->ulDataType & DATA_FORMAT_TYPE_MASK ) == AUDIO_DATA_TYPE_TIME_BASED) {
        // Currently very simplistic. Need to update when devices get more sophisticated
        if ( ulSampleRate == pFWAudioRange->KsDataRangeAudio.MinimumSampleFrequency )
            bInRange = TRUE;
    }

	return bInRange;
}

VOID
GetCategoryForBridgePin(
    PKSDEVICE pKsDevice, 
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulBridgePinNumber];
    PAVCPRECONNECTINFO pAvcPreconnectInfo = &pPinDescriptor->AvcPreconnectInfo.ConnectInfo;

    if ( pPinDescriptor->fFakePin ) {
        INIT_USB_TERMINAL(pTTypeGUID, 0x0301); // KSNODETYPE_SPEAKER
    }
    else if ( KSPIN_DATAFLOW_OUT == pAvcPreconnectInfo->DataFlow ){
        INIT_USB_TERMINAL(pTTypeGUID, 0x0301); // KSNODETYPE_SPEAKER
    }
    else {
        INIT_USB_TERMINAL(pTTypeGUID, 0x0201); // KSNODETYPE_MICROPHONE
    }
}


PFWAUDIO_DATARANGE
GetDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PFWAUDIO_DATARANGE pFwDataRange,
    ULONG ulDataRangeCnt )
{
    PFWAUDIO_DATARANGE pOutFwDataRange = NULL;

    union {
        PWAVEFORMATEX pDataFmtWave;
        PWAVEFORMATPCMEX pDataFmtPcmEx;
    } u;

    PKSDATARANGE pStreamRange;
    ULONG ulFormatType;
    ULONG fFound = FALSE;
    ULONG i;

    u.pDataFmtWave = &((PKSDATAFORMAT_WAVEFORMATEX)pFormat)->WaveFormatEx;

    for ( i=0; ((i<ulDataRangeCnt) && !fFound); ) {
        // Verify the Format GUIDS first
        pStreamRange = (PKSDATARANGE)&pFwDataRange[i].KsDataRangeAudio;
        if ( IsEqualGUID(&pFormat->MajorFormat, &pStreamRange->MajorFormat) &&
             IsEqualGUID(&pFormat->SubFormat,   &pStreamRange->SubFormat)   &&
             IsEqualGUID(&pFormat->Specifier,   &pStreamRange->Specifier) ) {

            // Based on the Data Type check remainder of format paramters
            ulFormatType = pFwDataRange[i].ulDataType & DATA_FORMAT_TYPE_MASK;
            switch( ulFormatType ) {
                case AUDIO_DATA_TYPE_TIME_BASED:
                    if ( u.pDataFmtWave->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((pFwDataRange[i].ulNumChannels   == u.pDataFmtPcmEx->Format.nChannels      ) &&
                           ((pFwDataRange[i].ulSlotSize<<3)  == u.pDataFmtPcmEx->Format.wBitsPerSample ) &&
                           ( pFwDataRange[i].ulValidDataBits == u.pDataFmtPcmEx->Samples.wValidBitsPerSample ) )
                            fFound = TRUE;
                    }
                    else {
                        if ((pFwDataRange[i].ulNumChannels   == u.pDataFmtWave->nChannels      ) &&
                           ( pFwDataRange[i].ulValidDataBits == u.pDataFmtWave->wBitsPerSample ))
                            fFound = TRUE;
                    }

                    // If all other paramters match check sample rate
                    if ( fFound ) {
						fFound = IsSampleRateInRange( &pFwDataRange[i], u.pDataFmtWave->nSamplesPerSec );
                    }

                    break;

                case AUDIO_DATA_TYPE_COMPRESSED:
/*
                    fFound = IsSampleRateInRange( u1.pT2AudioDescriptor,
                                                  u.pDataFmtWave->nSamplesPerSec,
                                                  ulFormatType );
                    break;
*/
                default:
                    TRAP;
                    break;
            }

        }

        if (!fFound) i++;
    }

    if ( fFound ) {
        pOutFwDataRange = &pFwDataRange[i];
    }

    return pOutFwDataRange;
}

ULONG
FindSourceForSrcPlug( 
    PHW_DEVICE_EXTENSION pHwDevExt, 
    ULONG ulPinId )
{
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PFW_PIN_DESCRIPTOR pFwPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinId];
    PSOURCE_ID pSourceId = &pFwPinDescriptor->SourceId;

    _DbgPrintF(DEBUGLVL_VERBOSE,("FindSourceForSrcPlug: ulPinId: %x pSourceId: %x\n",
                                   ulPinId, pSourceId ));

    return (ULONG)*(PUSHORT)pSourceId;
}

USHORT
usBitSwapper(USHORT usInVal)
{
    ULONG i;
    USHORT usRetVal = 0;

    _DbgPrintF( DEBUGLVL_BLAB, ("[usBitSwapper] Preswap: %x\n",usInVal));

    for ( i=0; i<(sizeof(USHORT)*8); i++ ) {
        usRetVal |= (usInVal & (1<<i)) ? (0x8000>>i) : 0;
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("[usBitSwapper] Postswap: %x\n",usRetVal));

    return usRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\timer.c ===
#include "Common.h"

#ifdef PSEUDO_HID

extern VOID
HwEventGenerateOnNode(
    PKSDEVICE pKsDevice,
    PULONG pNodeId );

VOID
TimerGetControlChanges(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PTOPOLOGY_NODE_INFO pNodeInfo = (PTOPOLOGY_NODE_INFO)pHwDevExt->KsFilterDescriptor.NodeDescriptors;
    ULONG ulNodeCount = pHwDevExt->KsFilterDescriptor.NodeDescriptorsCount;
    ULONG i;

    if ( pHwDevExt->ulFilterCount ) {
        // If a node is eventable, check the control's current value and send event if changed.
        for ( i=0; i<ulNodeCount; i++ ) {
            if ( pNodeInfo[i].fEventable && pNodeInfo[i].ulEventsEnabled ) {
                BOOLEAN bControlChange = FALSE;
                // Poll the device's control level
//                _DbgPrintF( DEBUGLVL_VERBOSE, ("[TimerGetControlChanges] Node %d\n", i) );
                pNodeInfo[i].pCacheUpdateRtn( pKsDevice, &pNodeInfo[i], &bControlChange );
                if ( bControlChange ) {
                    HwEventGenerateOnNode( pKsDevice, &i );
                }
            }
        }
    }
}

VOID
TimerWorkItem(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    BOOLEAN bPowerStateChange = FALSE;
    AVC_BOOLEAN bPowerState = AVC_ON;
    NTSTATUS ntStatus;
    KIRQL kIrql;

    if ( pHwDevExt->fSurpriseRemoved ) goto exit;

    // Need to check all control values if the node events are enabled.

    // Check Power if device allows. We need to add or remove filter factories
    // if the power comes on/off
    if ( pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus ) {
        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) ) {
            if ( bPowerState != pUnitInfo->bPowerState ) {
                _DbgPrintF( DEBUGLVL_TERSE, ("Power State Change: From: %x To: %x\n",
                                             pUnitInfo->bPowerState, bPowerState) );
                bPowerStateChange = TRUE;
                pUnitInfo->bPowerState = bPowerState;
            }
        }
    }

    if ( bPowerStateChange ) {
        if ( bPowerState == AVC_OFF ) {
            // Destroy Filter Factory
            ntStatus = FilterDestroyFilterFactory( pKsDevice );
            _DbgPrintF( DEBUGLVL_TERSE, ("Destroyed Filter Factory Status: %x\n", ntStatus ));
        }
        else {
            // Create Filter Factory
            ntStatus = FilterCreateFilterFactory( pKsDevice, TRUE );
            _DbgPrintF( DEBUGLVL_TERSE, ("Created Filter Factory Status: %x\n", ntStatus ));
        }
    }

    if ( bPowerState == AVC_ON ) {
        // Check for control changes.
        TimerGetControlChanges( pKsDevice );
    }

exit:
    KeAcquireSpinLock( &pHwDevExt->TimerSpinLock, &kIrql );
    pHwDevExt->bTimerWorkItemQueued = FALSE;
    KeSetEvent( &pHwDevExt->kTimerWIEvent, 0, FALSE );
    KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );
    
}

VOID
TimerDPCCallBack(
    IN struct _KDPC *Dpc,
    IN PKSDEVICE pKsDevice,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;

    // Queue a work item to check power and control levels if not already queued.
    KeAcquireSpinLockAtDpcLevel( &pHwDevExt->TimerSpinLock );
    if ( !pHwDevExt->bTimerWorkItemQueued ) {
        pHwDevExt->bTimerWorkItemQueued = TRUE;
        KeReleaseSpinLockFromDpcLevel(&pHwDevExt->TimerSpinLock);
        ExQueueWorkItem( &pHwDevExt->TimerWorkItem, DelayedWorkQueue );
    }
    else {
        KeReleaseSpinLockFromDpcLevel(&pHwDevExt->TimerSpinLock);
    }
}

NTSTATUS
TimerInitialize(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKTIMER pKTimer = &pHwDevExt->kTimer;
    PKDPC pKDpc = &pHwDevExt->TimerDPC;
    BOOLEAN bResult;
    LARGE_INTEGER  LITime;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TimerInitialize]WI ADDR %x TimerDPCCallBack: %x\n",
                                 TimerWorkItem, TimerDPCCallBack ) );

    ExInitializeWorkItem( &pHwDevExt->TimerWorkItem, TimerWorkItem, pKsDevice );

    KeInitializeSpinLock( &pHwDevExt->TimerSpinLock );

    KeInitializeDpc( pKDpc, TimerDPCCallBack, pKsDevice );

    KeInitializeTimer(pKTimer);

    KeInitializeEvent( &pHwDevExt->kTimerWIEvent, SynchronizationEvent, FALSE );

    pHwDevExt->bTimerWorkItemQueued = FALSE;

    LITime.QuadPart = -10000000;
    bResult = KeSetTimerEx( pKTimer, LITime, 500, pKDpc );

    return STATUS_SUCCESS;

}

NTSTATUS
TimerStop( 
    PHW_DEVICE_EXTENSION pHwDevExt )
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    KIRQL kIrql;
    BOOLEAN bResult = KeCancelTimer( &pHwDevExt->kTimer );

    if ( bResult ) ntStatus = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE, ( "Timer Cancelled: %x bTimerWorkItemQueued %x\n",
                                   bResult, pHwDevExt->bTimerWorkItemQueued));
    
    KeAcquireSpinLock( &pHwDevExt->TimerSpinLock, &kIrql );
    if ( pHwDevExt->bTimerWorkItemQueued ) {
        KeResetEvent( &pHwDevExt->kTimerWIEvent );
        KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );
        KeWaitForSingleObject( &pHwDevExt->kTimerWIEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );

    return ntStatus;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\property.h ===
#ifndef ___PROPERTY_H___
#define ___PROPERTY_H___

/*****************************************************************************

                        Definitions of Properties

*****************************************************************************/
// Declare Handlers for Pin Properties
NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pPin, PVOID pData );


// Declare Handlers for Item Map
NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS 
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS 
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

// Declare Handler for DRM
NTSTATUS
DrmAudioStream_SetContentId(
    IN PIRP pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID pvData
    );

static const
KSPROPERTY_ITEM PinPropertyItems[]={
    {
     (ULONG) KSPROPERTY_PIN_CINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CTYPES,      // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAFLOW,    // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATARANGES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAINTERSECTION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_INTERFACES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_MEDIUMS,     // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_COMMUNICATION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_GLOBALCINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NECESSARYINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PHYSICALCONNECTION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CATEGORY,    // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NAME,        // PropertyId
     (PFNKSHANDLER) GetPinName,          // pfnGetHandler
     sizeof(KSP_PIN),                    // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CONSTRAINEDDATARANGES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PROPOSEDATAFORMAT,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM AudioPropertyItems[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) FALSE,               // GetSupported
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LATENCY,   // PropertyId
     GetAudioLatency,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (LONGLONG),                  // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_COPY_PROTECTION, // PropertyId
     GetSetCopyProtection,               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_COPY_PROTECTION),   // MinData
     GetSetCopyProtection,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHANNEL_CONFIG, // PropertyId
     GetChannelConfiguration,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_CHANNEL_CONFIG),    // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL, // PropertyId
     GetSetVolumeLevel,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_POSITION,  // PropertyId
     GetAudioPosition,                   // GetSupported
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_RANGE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_QUALITY,   // PropertyId
     NULL,                               // GetSupported
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_SAMPLING_RATE, // PropertyId
     GetSetSampleRate,                   // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetSampleRate,                   // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOL),                      // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,      // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (BOOL),                      // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS,      // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MID,       // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,    // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_DELAY,     // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_WIDE_MODE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDENESS,  // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_REVERB_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHORUS_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DEV_SPECIFIC, // PropertyId
     GetSetDeviceSpecific,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_DEV_SPECIFIC),  // MinProperty
     sizeof (BYTE),                      // MinData
     GetSetDeviceSpecific,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};


// AC-3 Property set.

static const KSPROPERTY_ITEM AC3PropItm[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) FALSE,               // GetSupported
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ERROR_CONCEALMENT,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ALTERNATE_AUDIO,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_ALTERNATE_AUDIO),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DOWNMIX,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_DOWNMIX),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_BIT_STREAM_MODE,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (ULONG),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DIALOGUE_LEVEL,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_LANGUAGE_CODE,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ROOM_TYPE,   // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM TopologyItm[]={
    {
     (ULONG) KSPROPERTY_TOPOLOGYNODE_ENABLE,  // PropertyId
     GetSetTopologyNodeEnable,           // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     GetSetTopologyNodeEnable,           // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM ConnectionItm[]={
  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(NULL)
};

static const KSPROPERTY_ITEM StreamItm[]={
  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(NULL,NULL)
};


// Property sets for individual node types

static const 
KSPROPERTY_ITEM VolumePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL,  // PropertyId
     GetSetVolumeLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MutePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,  // PropertyId
     GetSetBoolean,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupportBoolean,             // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM BassPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM TreblePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MidrangePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MID,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM BassBoostPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM EqualizerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MixerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM AGCPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MuxPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM LoudnessPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
};

static DEFINE_KSPROPERTY_SET_TABLE(NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_NONE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DAC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_ADC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SRC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_SUPERMIX
                           SIZEOF_ARRAY(MixerPropertyItems),
                           (PVOID) MixerPropertyItems,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUX
                           SIZEOF_ARRAY(MuxPropertyItem),
                           (PVOID) MuxPropertyItem,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SUM
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUTE
                           SIZEOF_ARRAY(MutePropertyItem),
                           (PVOID) MutePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_VOLUME
                           SIZEOF_ARRAY(VolumePropertyItem),
                           (PVOID) VolumePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_BASS
                           SIZEOF_ARRAY(BassPropertyItem),
                           (PVOID) BassPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MID
                           SIZEOF_ARRAY(MidrangePropertyItem),
                           (PVOID) MidrangePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_TREBLE
                           SIZEOF_ARRAY(TreblePropertyItem),
                           (PVOID) TreblePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_BASS_BOOST
                           SIZEOF_ARRAY(BassBoostPropertyItem),
                           (PVOID) BassBoostPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_EQUALIZER
                           SIZEOF_ARRAY(EqualizerPropertyItems),
                           (PVOID) EqualizerPropertyItems,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_AGC
                           SIZEOF_ARRAY(AGCPropertyItem),
                           (PVOID) AGCPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_LOUDNESS
                           SIZEOF_ARRAY(LoudnessPropertyItem),
                           (PVOID) LoudnessPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_PROLOGIC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_STEREO_WIDE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_REVERB
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_CHORUS
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DEV_SPEC
                           0,
                           NULL,
                           0, NULL )

};


// DRM
DEFINE_KSPROPERTY_TABLE(DrmAudioStreamPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSP_DRMAUDIOSTREAM_CONTENTID),           // cbMinGetPropertyInput
        sizeof(KSDRMAUDIOSTREAM_CONTENTID),             // cbMinGetDataInput
        DrmAudioStream_SetContentId,                    // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\registry.c ===
#include "Common.h"

#define AVC_VIRTUAL_DEVICE_KEY L"Virtual1394Device"
#define SPEAKER_GROUP_ID  L"AudioGroupGUID"
#define SPEAKER_GROUP_CFG L"AudioGroupConfig"

PSZ
DbgUnicode2Sz(
    PWSTR pwstr )
{
    static char sz[256];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    sz[0] = '\0';
    if(pwstr != NULL) {
        RtlInitUnicodeString(&UnicodeString, pwstr);
        RtlInitAnsiString(&AnsiString, sz);
        AnsiString.MaximumLength = sizeof(sz);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    }
    return(sz);
}

NTSTATUS
OpenDeviceInterface(
    PWSTR pwstrDevice,
    PHANDLE pHandle )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("OpenDeviceInterface: (%s) \n", DbgUnicode2Sz(pwstrDevice)));

    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeDeviceString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    return( ZwCreateFile( pHandle,
                GENERIC_READ | GENERIC_WRITE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OPEN,
                0,
                NULL,
                0));
}


static NTSTATUS
RegistryOpenKey(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir )
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pcwstr);

    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE,
      hRootDir,
      NULL);

    return(ZwOpenKey(
      pHandle,
      KEY_READ | KEY_NOTIFY | KEY_WRITE,
      &ObjectAttributes));
}

NTSTATUS
RegistryQueryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi )
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, pcwstrValueName);
    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION)AllocMem(PagedPool, cbValue);
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);

    if(!NT_SUCCESS(Status)) {
        FreeMem( *ppkvfi );
        *ppkvfi = NULL;
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
RegistryReadMultiDeviceConfig(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfMultiDevice,
    GUID *pSpkrGrpGUID,
    PULONG pChannelConfig )
{
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    HANDLE hRootHandle;
    NTSTATUS ntStatus;
    UNICODE_STRING ustrGUID;
    PCWSTR pGuidString;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[RegistryReadMultiDeviceConfig] Enter\n"));

    *pfMultiDevice  = FALSE;
    *pChannelConfig = 0;

    // Determine if this is a virtual device instance
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->NextDeviceObject,
        PLUGPLAY_REGKEY_DEVICE,
        KEY_READ,
        &hRootHandle );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = RegistryQueryValue( hRootHandle, SPEAKER_GROUP_ID, &pkvfi );
        if ( NT_SUCCESS(ntStatus) ) {
            pGuidString = (PCWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset);
            RtlInitUnicodeString(&ustrGUID, pGuidString);
            ntStatus = RtlGUIDFromString( &ustrGUID, pSpkrGrpGUID );
            FreeMem(pkvfi);
            ntStatus = RegistryQueryValue( hRootHandle, SPEAKER_GROUP_CFG, &pkvfi );
            if ( NT_SUCCESS(ntStatus) ) {
                if( pkvfi->Type == REG_DWORD ) {
                    *pfMultiDevice = TRUE;
                    *pChannelConfig = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
                }
                else {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }
        }
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[RegistryReadMultiDeviceConfig] Leave Status; %x\n",ntStatus));
    return ntStatus;
}


NTSTATUS
RegistryReadVirtualDeviceEntry(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfVirtualDevice )
{
    HANDLE hRootHandle;
    NTSTATUS ntStatus;

    *pfVirtualDevice = FALSE;

    // Determine if this is a virtual device instance
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->NextDeviceObject,
        PLUGPLAY_REGKEY_DRIVER,
        KEY_ALL_ACCESS,
        &hRootHandle );

    if (NT_SUCCESS(ntStatus)) {
        OBJECT_ATTRIBUTES DeviceAttributes;
        HANDLE hDevHandle;
        UNICODE_STRING uniName;

        // Determine whether this is a virtual device
        RtlInitUnicodeString( &uniName, AVC_VIRTUAL_DEVICE_KEY );

        InitializeObjectAttributes(
            &DeviceAttributes,
            &uniName,
            OBJ_CASE_INSENSITIVE,
            hRootHandle,
            NULL);

        // Try to access the virtual device list key
        ntStatus = ZwOpenKey(
            &hDevHandle,
            KEY_ALL_ACCESS,
            &DeviceAttributes );

        if ( NT_SUCCESS(ntStatus) ) {

            _DbgPrintF(DEBUGLVL_VERBOSE, ("fVirtualSubunitFlag = TRUE\n"));
            *pfVirtualDevice = TRUE;
            ZwClose(hDevHandle);
        }
        else {
            ntStatus = STATUS_SUCCESS;
        }

        ZwClose(hRootHandle);
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("IoOpenDeviceRegistryKey Failed!"));
        TRAP;
    }

    return ntStatus;
}

NTSTATUS
RegistryReadVirtualizeKey(
    PUNICODE_STRING pustrFilterName,
    PULONG pVirtualizeFlag )
{
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    HANDLE hkeyDeviceClass = NULL;
    HANDLE hkeyValue = NULL;
    NTSTATUS ntStatus;

    ntStatus = IoOpenDeviceInterfaceRegistryKey( pustrFilterName,
                                                 KEY_READ ,
                                                 &hkeyDeviceClass );

    if ( NT_SUCCESS(ntStatus) ) {
#if 0
        HANDLE hKeyHandle;
        OBJECT_ATTRIBUTES DeviceAttributes;
        HANDLE hDevHandle;
        UNICODE_STRING uniName;

        RtlInitUnicodeString(&uniName, AVC_VIRTUAL_DEVICE_KEY);

        InitializeObjectAttributes(
            &DeviceAttributes,
            &uniName,
            OBJ_CASE_INSENSITIVE,
            hkeyDeviceClass,
            NULL);

        ntStatus = ZwCreateKey( &hKeyHandle,  
                                KEY_ALL_ACCESS,
                                &DeviceAttributes,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL );
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Key Created Status: %x\n",ntStatus));
        if ( NT_SUCCESS(ntStatus) ) {
            ZwClose(hKeyHandle);
        }
        TRAP;
#endif
        ntStatus = RegistryOpenKey( AVC_VIRTUAL_DEVICE_KEY, &hkeyValue, hkeyDeviceClass );
        if ( NT_SUCCESS(ntStatus) ) {
            ntStatus = RegistryQueryValue( hkeyValue, L"Enabled", &pkvfi );
            if ( NT_SUCCESS(ntStatus) ) {
                if( pkvfi->Type == REG_DWORD ) {
                    ntStatus = STATUS_SUCCESS;
                    *pVirtualizeFlag = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
                }
                else {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
                FreeMem( pkvfi );
            }
        }
    }

    if ( hkeyDeviceClass )
        ZwClose( hkeyDeviceClass );

    if ( hkeyValue )
        ZwClose( hkeyValue );

    return ntStatus;

}

/*
NTSTATUS
GetLocalDeviceObjects( 
    PWSTR *pwstrDeviceInterface,
    PFILE_OBJECT *pFileObject,
    PDEVICE_OBJECT *pDeviceObject )
{
    PPNP_NOTIFICATION_INFO pPnPNotificationInfo;
    UNICODE_STRING ustrInterfaceName;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL KIrql;

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &KIrql);
    if ( !IsListEmpty(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList) ) {
        pPnPNotificationInfo = (PPNP_NOTIFICATION_INFO)
            RemoveHeadList(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList);
    }
    else {
        ntStatus = STATUS_NO_MORE_ENTRIES;
    }
    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, KIrql);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("pPnPNotificationInfo: %x Status: %x\n",
                                   pPnPNotificationInfo, ntStatus ));

    if ( NT_SUCCESS(ntStatus) ) {
        *pwstrDeviceInterface = pPnPNotificationInfo->pwstrDeviceInterface;
        RtlInitUnicodeString( &ustrInterfaceName, *pwstrDeviceInterface );
        ntStatus = IoGetDeviceObjectPointer( &ustrInterfaceName,
                                             FILE_READ_DATA | FILE_WRITE_DATA,
                                             pFileObject, pDeviceObject );
        FreeMem(pPnPNotificationInfo);
    }

    return ntStatus;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\avcaudio\topology.c ===
#include "Common.h"

#include "nameguid.h"
#include "HwEvent.h"

#if DBG
char CntrlStrings[13][28] = { 
"Wrong",
"MUTE_CONTROL",
"VOLUME_CONTROL",
"LR_BALANCE_CONTROL",
"FR_BALANCE_CONTROL",
"BASS_CONTROL",
"MID_CONTROL",
"TREBLE_CONTROL",
"GRAPHIC_EQUALIZER_CONTROL",
"AUTOMATIC_GAIN_CONTROL",
"DELAY_CONTROL",
"BASS_BOOST_CONTROL",
"LOUDNESS_CONTROL"
};
#endif

extern
NTSTATUS
UpdateDbLevelControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged );

extern
NTSTATUS
UpdateBooleanControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged );

static GUID AVCNODENAME_BassBoost = {STATIC_USBNODENAME_BassBoost};

// Map of Audio properties to nodes
// ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

typedef
NTSTATUS
(*PFUNCTION_BLK_PROCESS_RTN)( PKSDEVICE pKsDevice,
                              PFUNCTION_BLOCK pFunctionBlock,
                              PTOPOLOGY_NODE_INFO pNodeDescriptors,
                              PKSTOPOLOGY_CONNECTION pConnections,
                              PULONG pNodeIndex,
                              PULONG pConnectionIndex );

ULONG
ConvertPinTypeToNodeType(
    PFW_PIN_DESCRIPTOR pFwPinDescriptor,
    GUID *TopologyNode,
    GUID *TopologyNodeName )
{
    ULONG NodeType = NODE_TYPE_NONE;

    if ( pFwPinDescriptor->fStreamingPin ) {
        // All endpoints support SRC
        *TopologyNode = KSNODETYPE_SRC;
        NodeType = NODE_TYPE_SRC;
    }
    else {

        switch ( pFwPinDescriptor->AvcPinDescriptor.PinDescriptor.DataFlow ) {
            case KSPIN_DATAFLOW_IN:
                *TopologyNode = KSNODETYPE_ADC;
                NodeType = NODE_TYPE_ADC;
                break;
            case KSPIN_DATAFLOW_OUT:
                *TopologyNode = KSNODETYPE_DAC;
                NodeType = NODE_TYPE_DAC;
                break;
            default:
                *TopologyNode = GUID_NULL;
                NodeType = NODE_TYPE_NONE;
                break;
            }
    }

    *TopologyNodeName = *TopologyNode;
    return NodeType;
}

#ifdef MASTER_FIX
NTSTATUS
TopologyNodesFromFeatureFBControls(
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex,
    BOOLEAN bMasterChannel,
    ULONG ulSourceNode )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFEATURE_FUNCTION_BLOCK pFeatureFBlk = (PFEATURE_FUNCTION_BLOCK)pFunctionBlock->pFunctionTypeInfo;

    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;
    ULONG ulNumChannels      = (bMasterChannel) ? 1 : (ULONG)pFunctionBlock->pChannelCluster->ucNumberOfChannels;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmControls;
    ULONG i, j;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TopologyNodesFromFeatureFB] 1: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x Master Flag: %d\n",
                                     pFunctionBlock, pNodeInfo, pConnection, bMasterChannel ));
    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TopologyNodesFromFeatureFB] 2: ulNodeNumber: %d\n", ulNodeNumber ));

    pChannelCntrls = (PULONG)AllocMem( NonPagedPool, ulNumChannels*sizeof(ULONG) );
    if ( !pChannelCntrls ) return STATUS_INSUFFICIENT_RESOURCES;

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    if ( bMasterChannel ) {
        bmControls = 0;
        for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
            bmControls <<= 8;
            bmControls |= pFeatureFBlk->bmaControls[j];
        }

        pChannelCntrls[0] = bmControls;
        ulMergedControls  = bmControls;

#ifdef SUM_HACK
        if ( ulMergedControls ) {

            _DbgPrintF(DEBUGLVL_TERSE, ("SUM: pNode: %x, pConnection: %x Source: %x\n",
                                         &pNodeInfo[ulNodeNumber], pConnection, ulSourceNode ));

            // Insert a sum node
            pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_SUM;
            pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_SUM;
            pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_SUM;

            // Make the connection
            pConnection->FromNode    = ulSourceNode;
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = ulNodeNumber;
            pConnection->ToNodePin   = 1;
            pConnection++; ulConnectionsCount++;

            ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
        }
#endif

    }
    else {
        for ( i=0; i<ulNumChannels; i++ ) {
            bmControls = 0;
            for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
                bmControls <<= 8;
                bmControls |= pFeatureFBlk->bmaControls[(i+1)*pFeatureFBlk->ucControlSize+j];
            }

            pChannelCntrls[i] = bmControls;
            ulMergedControls |= bmControls;
        }
    }

    if ( !ulMergedControls ) {
        FreeMem(pChannelCntrls);
        return STATUS_MEMBER_NOT_IN_GROUP;
    }

    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        pNodeInfo[ulNodeNumber].fMasterChannel = bMasterChannel;

        // Copy Block Id for easier parsing later
        pNodeInfo[ulNodeNumber].ulBlockId = pFunctionBlock->ulBlockId;

        // Determine which channels this control is valid for
        if ( bMasterChannel ) {
            ulCurControlChannels = 1;
            pNodeInfo[ulNodeNumber].ulChannelConfig = 1;
        }
        else {
            ulCurControlChannels = 0;
            pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        
            for ( i=0; i<ulNumChannels; i++ ) {

                if (pChannelCntrls[i] & ulCurrentControl) {
                    // Determine which Channel pChannelCntrls[i] reflects

                    // ISSUE-2001/01/10-dsisolak: Does not consider undefined channel configurations
                    ULONG ulTmpConfig  = (ULONG)bswapw(pFunctionBlock->pChannelCluster->usPredefinedChannelConfig);
                    ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
  
                    ulCurControlChannels++;

                    for (j=0; j<i; j++) {
                        ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                        ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                    }

                    pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
                }
            }

        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].pFunctionBlk = pFunctionBlock;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                if ( bMasterChannel ) pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSAUDFNAME_MASTER_MUTE;
                else                  pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                if ( bMasterChannel ) pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSAUDFNAME_MASTER_VOLUME;
                else                  pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &AVCNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;

            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType   = AUTOMATIC_GAIN_CONTROL;
                break;

            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType   = DELAY_CONTROL;
                break;

            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType   = LOUDNESS_CONTROL;
                break;

            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType   = DEV_SPECIFIC_CONTROL;
                break;
        }

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      (PDB_LEVEL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j;
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));

                    ntStatus = InitializeDbLevelCache( pKsDevice,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }
                }
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      (PBOOLEAN_CTRL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j;
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS ntStatus;
                    ULONG UnMute = AVC_OFF;

                    ntStatus = 
                        CreateFeatureFBlockRequest( pKsDevice,
                                                    &pNodeInfo[ulNodeNumber],
                                                    pBCache->ulChannelIndex,
                                                    &UnMute,
                                                    1,
                                                    FB_CTRL_TYPE_CONTROL | FB_CTRL_ATTRIB_CURRENT );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case GRAPHIC_EQUALIZER_FLAG:
               // Currently GEQ is not Cached
            default:
                 break;
        }

        _DbgPrintF( DEBUGLVL_TERSE, ("Node: %d Feature: %x %s pNodeInfo: %x\n",
                                        ulNodeNumber,
                                        pNodeInfo[ulNodeNumber].ulControlType,
                                        (pNodeInfo[ulNodeNumber].ulControlType == DEV_SPECIFIC_CONTROL) ?
                                            "DEVICE_SPECIFIC" :
                                            CntrlStrings[pNodeInfo[ulNodeNumber].ulControlType],
                                        &pNodeInfo[ulNodeNumber] ));

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }


    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);


    return STATUS_SUCCESS;
}


NTSTATUS
ProcessFeatureFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    ULONG ulSourceNode = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessFeatureFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x\n",
                                     pFunctionBlock, pNodeInfo ));

    // Create nodes for Master Channel controls
    ntStatus = 
        TopologyNodesFromFeatureFBControls( pKsDevice,
                                            pFunctionBlock,
                                            pNodeInfo,
                                            pConnections,
                                            pNodeIndex,
                                            pConnectionIndex,
#ifdef SUM_HACK
                                            FALSE,
#else
                                            TRUE,
#endif
                                            ulSourceNode );

    if ( NT_SUCCESS(ntStatus) || (ntStatus == STATUS_MEMBER_NOT_IN_GROUP )) {
        if ( NT_SUCCESS(ntStatus) ) {
            ulSourceNode = ( ABSOLUTE_NODE_FLAG | (*pNodeIndex-1) );
        }

        // Create nodes for individual channel controls
        ntStatus = 
            TopologyNodesFromFeatureFBControls( pKsDevice,
                                                pFunctionBlock,
                                                pNodeInfo,
                                                pConnections,
                                                pNodeIndex,
                                                pConnectionIndex,
#ifdef SUM_HACK
                                                TRUE,
#else
                                                FALSE,
#endif
                                                ulSourceNode );

        if ( ntStatus == STATUS_MEMBER_NOT_IN_GROUP ) ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#else

NTSTATUS
ProcessFeatureFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFEATURE_FUNCTION_BLOCK pFeatureFBlk = (PFEATURE_FUNCTION_BLOCK)pFunctionBlock->pFunctionTypeInfo;

    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;
    ULONG ulNumChannels      = (ULONG)pFunctionBlock->pChannelCluster->ucNumberOfChannels;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmChannelConfig;
    ULONG ulSourceNode;
    ULONG bmControls;
    ULONG i, j;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessFeatureFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x\n",
                                     pFunctionBlock, pNodeInfo, pConnection ));

    pChannelCntrls = (PULONG)AllocMem( NonPagedPool, (ulNumChannels+1)*sizeof(ULONG) );
    if ( !pChannelCntrls ) return STATUS_INSUFFICIENT_RESOURCES;

    // ISSUE-2001/01/10-dsisolak: Does not consider undefined channel configurations
    bmChannelConfig = (ULONG)bswapw(pFunctionBlock->pChannelCluster->usPredefinedChannelConfig);

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    for ( i=0; i<=ulNumChannels; i++ ) {
        bmControls = 0;
        for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
            bmControls <<= 8;
            bmControls |= pFeatureFBlk->bmaControls[i*pFeatureFBlk->ucControlSize+j];
        }

        pChannelCntrls[i] = bmControls;
        ulMergedControls |= bmControls;
    }

    ulSourceNode = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;

    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        // Copy Block Id for easier parsing later
        pNodeInfo[ulNodeNumber].ulBlockId = pFunctionBlock->ulBlockId;

        // Determine which channels this control is valid for
        ulCurControlChannels = 0;
        pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        for ( i=0; i<=ulNumChannels; i++ ) {

            if (pChannelCntrls[i] & ulCurrentControl) {
                // Determine which Channel pChannelCntrls[i] reflects

                // NEED TO SHIFT bmChannelConfig and ADD 1 for omnipresent master channel
                ULONG ulTmpConfig = (bmChannelConfig<<1)+1;
                ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
  
                ulCurControlChannels++;

                for (j=0; j<i; j++) {
                    ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                    ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                }

                pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
            }
        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].pFunctionBlk = pFunctionBlock;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &AVCNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;

            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType   = AUTOMATIC_GAIN_CONTROL;
                break;

            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType   = DELAY_CONTROL;
                break;

            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType   = LOUDNESS_CONTROL;
                break;

            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType   = DEV_SPECIFIC_CONTROL;
                break;
        }

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Feature: %x pNodeInfo: %x\n", 
                                        pNodeInfo[ulNodeNumber].ulControlType,
                                        &pNodeInfo[ulNodeNumber] ));

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      (PDB_LEVEL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j;
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));

                    ntStatus = InitializeDbLevelCache( pKsDevice,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }

                }
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      (PBOOLEAN_CTRL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j;
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS ntStatus;
                    ULONG UnMute = AVC_OFF;

                    ntStatus = 
                        CreateFeatureFBlockRequest( pKsDevice,
                                                    &pNodeInfo[ulNodeNumber],
                                                    pBCache->ulChannelIndex,
                                                    &UnMute,
                                                    1,
                                                    FB_CTRL_TYPE_CONTROL | FB_CTRL_ATTRIB_CURRENT );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case GRAPHIC_EQUALIZER_FLAG:
               // Currently GEQ is not Cached
            default:
                 break;
        }

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }


    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);


    return STATUS_SUCCESS;
}

#endif

NTSTATUS
ProcessSelectorFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    return STATUS_SUCCESS;
}

NTSTATUS
ProcessProcessingFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PTOPOLOGY_NODE_INFO pNodeInfo = pNodeDescriptors + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessProcessingFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x\n",
                                     pFunctionBlock, pNodeInfo, pConnection ));

    pNodeInfo->pFunctionBlk    = pFunctionBlock;
    pNodeInfo->ulBlockId       = pFunctionBlock->ulBlockId;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
    pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;

    pConnection->FromNode    = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = (*pNodeIndex)++;
    pConnection->ToNodePin   = 1;

    (*pConnectionIndex)++;

    return STATUS_SUCCESS;
}

NTSTATUS
ProcessCodecFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    return STATUS_SUCCESS;
}

NTSTATUS
ProcessPinDescriptor( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinId];
    ULONG ulPlugNum = pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;

    pNodeInfo->ulPinId = ulPinId;
    pNodeInfo->ulNodeType =
                 ConvertPinTypeToNodeType( pFwPinDescriptor,
                                           (GUID *)pNodeInfo->KsNodeDesc.Type,
                                           (GUID *)pNodeInfo->KsNodeDesc.Name );

    _DbgPrintF(DEBUGLVL_VERBOSE,("ProcessPin: ID; %d pNodeInfo: %x pConnection: %x \n", 
                                ulPinId, pNodeInfo, pConnection));

	switch( pFwPinDescriptor->AvcPinDescriptor.PinDescriptor.DataFlow ) {
	    case KSPIN_DATAFLOW_IN:

	        pNodeInfo->ulBlockId = SUBUNIT_DESTINATION_PLUG_TYPE | (ulPlugNum<<8);

            // Make the connection to this node
            pConnection->FromNodePin = ulPinId;
            pConnection->FromNode    = KSFILTER_NODE;
            pConnection->ToNode      = (*pNodeIndex)++;
            pConnection->ToNodePin   = 1;
            (*pConnectionIndex)++;
	        break;

		case KSPIN_DATAFLOW_OUT:

	        pNodeInfo->ulBlockId = SUBUNIT_SOURCE_PLUG_TYPE | (ulPlugNum<<8);

            pConnection->FromNode    = FindSourceForSrcPlug( pHwDevExt, ulPinId );
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = (*pNodeIndex)++;
            pConnection->ToNodePin   = 1;
            pConnection++; (*pConnectionIndex)++;

            // Make the connection to the outside world
            pConnection->ToNodePin   = ulPinId;
            pConnection->FromNode    = SUBUNIT_SOURCE_PLUG_TYPE | (ulPlugNum<<8);
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = KSFILTER_NODE;
            (*pConnectionIndex)++;
            break;

		default:
			return STATUS_NOT_IMPLEMENTED;
	}

    return STATUS_SUCCESS;
}


PFUNCTION_BLK_PROCESS_RTN 
pFunctionBlockProcessRtn[MAX_FUNCTION_BLOCK_TYPES] = {
    ProcessSelectorFunctionBlock,
    ProcessFeatureFunctionBlock,
    ProcessProcessingFunctionBlock,
    ProcessCodecFunctionBlock,
};

NTSTATUS
BuildFilterTopology( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PKSFILTER_DESCRIPTOR pFilterDesc = &pHwDevExt->KsFilterDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // ISSUE-2001/01/10-dsisolak Assume only 1 configuration for now
    PAUDIO_CONFIGURATION pAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;
    PFUNCTION_BLOCK pFunctionBlocks = pAudioConfiguration->pFunctionBlocks;

    ULONG ulNumCategories;
    ULONG ulNumNodes;
    ULONG ulNumConnections;
    ULONG bmCategories;

    GUID* pCategoryGUIDs;
    GUID* pTmpGUIDptr;
    PTOPOLOGY_NODE_INFO pNodeDescriptors;
    PKSTOPOLOGY_CONNECTION pConnections;

    ULONG ulNodeIndex = 0;
    ULONG ulConnectionIndex = 0;
    ULONG i;

    // Now that we've processed the Audio Subunit descriptor
    // a bit lets munch through it and build our topology.
    CountTopologyComponents( pHwDevExt,
                             &ulNumCategories,
                             &ulNumNodes,
                             &ulNumConnections,
                             &bmCategories );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("ulNumCategories %d, ulNumNodes %d, ulNumConnections %d, bmCategories %x \n",
                                    ulNumCategories, ulNumNodes, ulNumConnections, bmCategories ));

    // Set the Node Descriptor size to be that of the KS descriptor +
    // necessary local information.
    pFilterDesc->NodeDescriptorSize = sizeof(TOPOLOGY_NODE_INFO);

    // Allocate Space for Topology Items
    pCategoryGUIDs = (GUID*)
        AllocMem( NonPagedPool, (ulNumCategories  * sizeof(GUID)) +
                                (ulNumNodes       * ( sizeof(TOPOLOGY_NODE_INFO) +
                                                      sizeof(GUID) +
                                                      sizeof(GUID) ) ) +
                                (ulNumConnections * sizeof(KSTOPOLOGY_CONNECTION)) );
    if ( !pCategoryGUIDs ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the topology for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pCategoryGUIDs, FreeMem);

    // Set the pointers to the different topology components
    pNodeDescriptors = (PTOPOLOGY_NODE_INFO)(pCategoryGUIDs + ulNumCategories);
    pConnections = (PKSTOPOLOGY_CONNECTION)(pNodeDescriptors + ulNumNodes);

    pFilterDesc->Categories      = (const GUID*)pCategoryGUIDs;
    pFilterDesc->NodeDescriptors = (const KSNODE_DESCRIPTOR*)pNodeDescriptors;
    pFilterDesc->Connections     = (const KSTOPOLOGY_CONNECTION*)pConnections;

    // Clear all Node info structures
    RtlZeroMemory(pNodeDescriptors, ulNumNodes * sizeof(TOPOLOGY_NODE_INFO));

    // Initialize Node GUID Pointers
    pTmpGUIDptr = (GUID *)(pConnections + ulNumConnections);
    for ( i=0; i<ulNumNodes; i++ ) {
        pNodeDescriptors[i].KsNodeDesc.Type = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.Name = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.AutomationTable = 
                           &pNodeDescriptors[i].KsAutomationTable;
    }

    // Fill in Filter Categories
    i=0;
    pCategoryGUIDs[i++] = KSCATEGORY_AUDIO;
    if ( bmCategories & KSPIN_DATAFLOW_OUT )
        pCategoryGUIDs[i++] = KSCATEGORY_RENDER;
    if ( bmCategories & KSPIN_DATAFLOW_IN )
        pCategoryGUIDs[i++] = KSCATEGORY_CAPTURE;

    ASSERT (i==ulNumCategories);

    pFilterDesc->CategoriesCount = ulNumCategories;

    // First go through plugs and assign topology components for them.
    for (i=0; ((i<pAudioSubunitInfo->ulDevicePinCount) && NT_SUCCESS(ntStatus)); i++) {
        ntStatus = ProcessPinDescriptor(  pKsDevice,
                                          i,
                                          pNodeDescriptors,
                                          pConnections,
                                          &ulNodeIndex,
                                          &ulConnectionIndex );
    }

    for (i=0; ((i<pAudioConfiguration->ulNumberOfFunctionBlocks) && NT_SUCCESS(ntStatus)); i++) {
        ntStatus = 
            (*pFunctionBlockProcessRtn[pFunctionBlocks[i].ulType & 0xf])( pKsDevice,
                                                                          &pFunctionBlocks[i],
                                                                          pNodeDescriptors,
                                                                          pConnections,
                                                                          &ulNodeIndex,
                                                                          &ulConnectionIndex );
    }

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    // Set Topology component counts in Filter Descriptor
    pFilterDesc->NodeDescriptorsCount = ulNodeIndex;
    pFilterDesc->ConnectionsCount     = ulConnectionIndex;

    DbgLog("TopoAdr", pFilterDesc->NodeDescriptors, pFilterDesc->Connections, ulConnectionIndex, ulNodeIndex);

    // Fix-up all of the connections to map their node #'s correctly.
    for (i=0; i < ulConnectionIndex; i++) {
        if (pConnections->FromNode != KSFILTER_NODE) {
            if (pConnections->FromNode & ABSOLUTE_NODE_FLAG)
                pConnections->FromNode = (pConnections->FromNode & NODE_MASK);
            else {
                // Find the correct node number for FromNode.
                // Note: if a unit has multiple nodes, the From node is always the last node
                // for that unit.
                for ( ulNodeIndex=ulNumNodes; ulNodeIndex > 0; ulNodeIndex-- ) {
                    if ( pConnections->FromNode == pNodeDescriptors[ulNodeIndex-1].ulBlockId ) {
                        pConnections->FromNode = ulNodeIndex-1;
                        break;
                    }
                }
            }
        }

        pConnections++;
    }

    // For each node initialize its automation table for its associated properties.
    for (i=0; i<ulNumNodes; i++) {
        BuildNodePropertySet( &pNodeDescriptors[i] );

#ifdef PSEUDO_HID
        if ( pNodeDescriptors[i].fEventable ) {
//            _DbgPrintF( DEBUGLVL_VERBOSE, ("Node: %d pNodeDescriptors: %x \n", i, &pNodeDescriptors[i] ));

            pNodeDescriptors[i].KsAutomationTable.EventSetsCount = 1;
            pNodeDescriptors[i].KsAutomationTable.EventItemSize  = sizeof(KSEVENT_ITEM);
            pNodeDescriptors[i].KsAutomationTable.EventSets      = HwEventSetTable;
        }
#endif

    }

    // Stick this here as a convienience
    // Initialize Map of Audio Properties to nodes
//    MapFuncsToNodeTypes( MapPropertyToNode );

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\capture.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       capture.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define INPUT_PACKETS_PER_REQ    10

NTSTATUS
CaptureReQueueUrb( 
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo );

NTSTATUS
CaptureBytePosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    ULONG ulCurrentFrame;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG ulInputDataBytes, ulOutputBufferBytes;

    //  Routine currently assumes TypeI data
    ASSERT( (pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK) ==
             USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED );


    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    ntStatus = KsPinGetAvailableByteCount( pKsPin, 
                                           &ulInputDataBytes,
                                           &ulOutputBufferBytes );

    DbgLog("CapPos1", irql, pCapturePinContext->ulAvgBytesPerSec, ulInputDataBytes, ulOutputBufferBytes );

    if ( !NT_SUCCESS(ntStatus) ) {
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        DbgLog( "CapBPEr", ntStatus, pKsPin, 0, 0 );
        TRAP;
    	return ntStatus;
    }
    
    pPosition->PlayOffset = pPosition->WriteOffset = pPinContext->ullWriteOffset;

    if ( pPinContext->fStreamStartedFlag ) {
        ntStatus = GetCurrentUSBFrame(pPinContext, &ulCurrentFrame);

        if (NT_SUCCESS(ntStatus)) {
        	// Add all completed URBs if they are less than submitted
        	pPosition->PlayOffset = pPinContext->ullTotalBytesReturned;
        	
        	// Calculate current offset based on Current frame.
        	if ((ulCurrentFrame - pPinContext->ulStreamUSBStartFrame ) < 0x7fffffff) {
            	pPosition->PlayOffset += 
            	    (( ulCurrentFrame - pPinContext->ulStreamUSBStartFrame ) *
            	    pCapturePinContext->ulAvgBytesPerSec) / 1000;
            	if ( pPosition->PlayOffset > pPosition->WriteOffset + ulOutputBufferBytes)
                    pPosition->PlayOffset = pPosition->WriteOffset + ulOutputBufferBytes;
            }

            ASSERT(pPosition->PlayOffset>=pPosition->WriteOffset);
            ASSERT(pPosition->PlayOffset<=pPosition->WriteOffset + ulOutputBufferBytes);

            DbgLog("CapBPos", pPosition->PlayOffset, pPosition->WriteOffset, 
                              ulCurrentFrame, pPinContext->ulStreamUSBStartFrame );
        }

    }

    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    DbgLog("CapPos2", irql, pCapturePinContext->ulAvgBytesPerSec, pPosition->WriteOffset, pPosition->PlayOffset );

    return ntStatus;

}

VOID
CaptureAvoidPipeStarvationWorker( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    ULONG ulInputDataBytes, ulOutputBufferBytes;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    KIRQL irql;

    // Grab the process mutex
    KsPinAcquireProcessingMutex( pKsPin );

    // First make sure that data buffer starvation still in affect
    if ( NT_SUCCESS( KsPinGetAvailableByteCount( pKsPin, 
                                                 &ulInputDataBytes,
                                                 &ulOutputBufferBytes ) ) ) {
        NTSTATUS ntStatus;

        DbgLog("CapAPSW", ulInputDataBytes, ulOutputBufferBytes, 0, 0 );      

        if ( !ulOutputBufferBytes ) {

            // Grab spinlock to remove first full buffer from queue
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->FullBufferQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            // Release the processing mutex
            KsPinReleaseProcessingMutex( pKsPin );

            // Account for the lost bytes? Set discontinuity flag
            pCapturePinContext->fDataDiscontinuity = TRUE;
            pCapturePinContext->ulErrantPackets += INPUT_PACKETS_PER_REQ;

            // Resubmit the request
            ntStatus = CaptureReQueueUrb( pCapBufInfo );
        }
        else {
            KsPinReleaseProcessingMutex( pKsPin );
        }
    
    }
    else {
        KsPinReleaseProcessingMutex( pKsPin );
    }

}

VOID
CaptureGateOnWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureGateOnWorkItem] pin %d\n",pKsPin->Id));

    do
    {
        // Don't want to turn on the gate if we are not running
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
        if (!pCapturePinContext->fRunning) {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            // Acquire the Process Mutex to ensure there will be no new requests during the gate operation
            KsPinAcquireProcessingMutex( pKsPin );

            KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );

            KsPinAttemptProcessing( pKsPin, TRUE );

            DbgLog("CProcOn", pKsPin, 0, 0, 0 );

            KsPinReleaseProcessingMutex( pKsPin );
        }
    } while ( KsDecrementCountedWorker(pCapturePinContext->GateOnWorkerObject) );
}

NTSTATUS
CaptureCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    NTSTATUS ntStatus = pIrp->IoStatus.Status;
    KIRQL irql;

    DbgLog("CUrbCmp", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );

    if ( pCapBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("CUrbErr", pCapBufInfo, pPinContext,
                          pCapBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status, 0 );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( pCapturePinContext->fRunning ) {
        BOOLEAN fNeedToProcess;
        ULONG i;

        if ( pPinContext->fUrbError ) {
            DbgLog("CapUrEr", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            // Queue errant URB
            InsertTailList( &pCapturePinContext->UrbErrorQueue, &pCapBufInfo->List );

            if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
                KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
            }
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        else if (!NT_SUCCESS(ntStatus)) {
            DbgLog("CapNTEr", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            pPinContext->fUrbError = TRUE;

//          pPinContext->fStreamStartedFlag = FALSE;
            if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) )
                KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );

            // Queue errant URB and queue work item
            InsertTailList( &pCapturePinContext->UrbErrorQueue, &pCapBufInfo->List );

            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            KsIncrementCountedWorker(pCapturePinContext->ResetWorkerObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
            DbgLog("CapStrv", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            pPinContext->fUrbError = TRUE;
            KsIncrementCountedWorker(pCapturePinContext->ResetWorkerObject);
            KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
        }
        else if ( 2 == pPinContext->ulOutstandingUrbCount ) {
            ULONG ulInputDataBytes, ulOutputBufferBytes;
            if ( NT_SUCCESS( KsPinGetAvailableByteCount( pKsPin, 
                                                         &ulInputDataBytes,
                                                         &ulOutputBufferBytes ) ) ) {
                DbgLog("CapStv2", ulInputDataBytes, ulOutputBufferBytes, 0, 0 );
                if ( !ulOutputBufferBytes ) {

                    // Data starvation has occurred. Need to requeue before pipe starvation occurs.
                    KsIncrementCountedWorker(pCapturePinContext->RequeueWorkerObject);
                }
            }
        }

        // Queue the completed URB for processing
        fNeedToProcess = IsListEmpty( &pCapturePinContext->FullBufferQueue ) &&
                                      !pCapturePinContext->fProcessing;
        InsertTailList( &pCapturePinContext->FullBufferQueue, &pCapBufInfo->List );

        if ( fNeedToProcess ) {
            pCapturePinContext->fProcessing = TRUE;

            // Queue a work item to handle this so that we don't race with the gate
            // count in the processing routine

            KsIncrementCountedWorker(pCapturePinContext->GateOnWorkerObject);
        }

        for (i=0; i<INPUT_PACKETS_PER_REQ; i++) {
        	PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket = 
        		    &pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket[i];
            if ( USBD_SUCCESS(pIsoPacket->Status) )
                pPinContext->ullTotalBytesReturned += pIsoPacket->Length;
        }

        pPinContext->ulStreamUSBStartFrame = 
                    pCapBufInfo->pUrb->UrbIsochronousTransfer.StartFrame +
                    INPUT_PACKETS_PER_REQ;
        DbgLog( "CapCBPs", pPinContext->ullTotalBytesReturned,
        	               pPinContext->ulStreamUSBStartFrame,
        	               pPinContext->ullWriteOffset,
        	               pPinContext->ulOutstandingUrbCount );

    }
    else if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        DbgLog("CapNtRn", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CaptureInitializeUrbAndIrp( PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PIRP pIrp = pCapBufInfo->pIrp;
    PURB pUrb = pCapBufInfo->pUrb;
    PIO_STACK_LOCATION pNextStack;
    ULONG siz, j;

    siz = GET_ISO_URB_SIZE(INPUT_PACKETS_PER_REQ);

    // Initialize all URBs to zero
    RtlZeroMemory(pUrb, siz);

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT) siz;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP |
                                                   USBD_TRANSFER_DIRECTION_IN;
    pUrb->UrbIsochronousTransfer.StartFrame      = 0;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = INPUT_PACKETS_PER_REQ;

    for ( j=0; j<INPUT_PACKETS_PER_REQ; j++ )
      pUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = j*pPinContext->ulMaxPacketSize;

    pUrb->UrbIsochronousTransfer.TransferBuffer       = pCapBufInfo->pData;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = INPUT_PACKETS_PER_REQ*
                                                        pPinContext->ulMaxPacketSize;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextStack->Parameters.Others.Argument1 = pCapBufInfo->pUrb;
    pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, CaptureCompleteCallback, pCapBufInfo, TRUE, TRUE, TRUE );

    DbgLog("IniIrpU", pCapBufInfo, pIrp, pUrb, pNextStack );

}

NTSTATUS
CaptureReQueueUrb( PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    KIRQL irql;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( pCapturePinContext->fRunning ) {
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        CaptureInitializeUrbAndIrp( pCapBufInfo );

        InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);

        DbgLog("ReQue", pPinContext, pPinContext->ulOutstandingUrbCount,
                        pCapBufInfo, 0);
        ASSERT(pPinContext->ulOutstandingUrbCount <= CAPTURE_URBS_PER_PIN);

        ntStatus = IoCallDriver( pPinContext->pNextDeviceObject,
                                 pCapBufInfo->pIrp );
    }
    else
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return ntStatus;

}

VOID
CaptureResetWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo = NULL;
    NTSTATUS ntStatus;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureResetWorkItem] pin %d\n",pKsPin->Id));

    do
    {
        // Acquire the Process Mutex to ensure there will be no new requests during the reset
        KsPinAcquireProcessingMutex( pKsPin );

        pCapturePinContext->fDataDiscontinuity = TRUE;

        ntStatus = 
            KeWaitForMutexObject( &pCapturePinContext->CaptureInitMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL );

        // Abort the Pipe and wait for it to clear
        ntStatus = AbortUSBPipe( pPinContext );
        if ( NT_SUCCESS(ntStatus) ) {

            // IF still running resubmit errant Urbs
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            if ( pCapturePinContext->fRunning ) {

                // Requeue Urbs
                while ( !IsListEmpty(&pCapturePinContext->UrbErrorQueue) ) {
                    pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->UrbErrorQueue);
                    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
                    ntStatus = CaptureReQueueUrb( pCapBufInfo );
                    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

                    if ( !NT_SUCCESS(ntStatus) ) {
                        // An error here means that the ResetWorkerObject has been incremented
                        // and the UrbErrorQueue has another entry. If we just keep trying to
                        // empty the UrbErrorQueue, we stand the chance of going into an infinite
                        // loop (especially if this failed due to Surprise Removal).
                        //
                        // Breaking out now lets the AbortUSBPipe get another stab at clearing
                        // things up. If it fails, then we know something is very wrong, and
                        // we will halt the recovery process.
                        break;
                    }
                }
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            }
            else
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }

        KeReleaseMutex( &pCapturePinContext->CaptureInitMutex, FALSE );

        KsPinReleaseProcessingMutex( pKsPin );
    } while (KsDecrementCountedWorker(pCapturePinContext->ResetWorkerObject));
}

NTSTATUS
CaptureProcess( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo = NULL;
    PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulStreamRemaining;
    ULONG ulIsochBuffer;
    ULONG ulIsochRemaining;
    ULONG ulIsochBufferOffset;
    PUCHAR pIsochData;
    KIRQL irql;

    // While there is device data available and there are data buffers to
    // be filled copy device data to data buffers.

    DbgLog("CapProc", pKsPin, pPinContext, pCapturePinContext, 0 );

    // First check if there is a capture buffer in use and complete it if so
    if ( pCapturePinContext->pCaptureBufferInUse ) {
        pCapBufInfo         = pCapturePinContext->pCaptureBufferInUse;
        pIsoPacket          = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;
        ulIsochBuffer       = pCapturePinContext->ulIsochBuffer;
        ulIsochBufferOffset = pCapturePinContext->ulIsochBufferOffset;
        ulIsochRemaining    = pIsoPacket[ulIsochBuffer].Length - ulIsochBufferOffset;
        pIsochData          = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;

        pCapturePinContext->pCaptureBufferInUse = NULL;
        DbgLog("CapInf1", pCapBufInfo, ulIsochBuffer, ulIsochBufferOffset, pIsochData );
    }
    else {
        BOOLEAN fFound = FALSE;
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

        while ( !IsListEmpty( &pCapturePinContext->FullBufferQueue) && !fFound ) {
            pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->FullBufferQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            ulIsochBuffer = 0;
            pIsoPacket = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;
            while ( USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) && 
                  ( ulIsochBuffer < INPUT_PACKETS_PER_REQ) ) {
                ulIsochBuffer++;
                pCapturePinContext->ulErrantPackets++;
                pCapturePinContext->fDataDiscontinuity = TRUE;
            }

            fFound = ulIsochBuffer < INPUT_PACKETS_PER_REQ;

            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

            if ( !fFound ) {
                // Requeue used capture buffer
                NTSTATUS ntStatus = CaptureReQueueUrb( pCapBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    // Log this, but it's okay to continue flushing the data we already have
                    DbgLog("CReQErr", pCapBufInfo, pCapturePinContext, pPinContext, ntStatus );
                }
            }
        }

        if ( !fFound ) {
            _DbgPrintF(DEBUGLVL_TERSE,("[CaptureProcess] No valid data returned from device yet. Returning STATUS_PENDING!\n"));
            KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
            pCapturePinContext->fProcessing = FALSE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            DbgLog("CapBail", pKsPin, pPinContext, pCapturePinContext, pCapturePinContext->fProcessing );
            return STATUS_PENDING;
        }
        else {
            // Set stream started flag if not already done
            if ( !pPinContext->fStreamStartedFlag ) {
                pPinContext->fStreamStartedFlag    = TRUE;
            }
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            ulIsochBufferOffset = 0;
            pIsochData          = pCapBufInfo->pData;
            ulIsochRemaining    = pIsoPacket[ulIsochBuffer].Length;
            DbgLog("CapInf2", pCapBufInfo, ulIsochBuffer, ulIsochBufferOffset, pIsochData );
        }
    }

    // Get leading edge
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureProcess] Leading edge is NULL\n"));
        DbgLog("CapBl2", pKsPin, pPinContext, pCapturePinContext, pCapturePinContext->fProcessing );
        return STATUS_SUCCESS;
    }

    if (  pCapturePinContext->fDataDiscontinuity && pKsStreamPtr->StreamHeader ) {
        pKsStreamPtr->StreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
        pCapturePinContext->fDataDiscontinuity = FALSE;
    }

    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;

    DbgLog("DatPtr", pKsStreamPtr, pKsStreamPtr->OffsetOut.Data, pKsStreamPtr->StreamHeader->Data, 0);

    // Fill buffer with captured data
    while ( pKsStreamPtr && pCapBufInfo ) {

        ULONG ulCopySize = ( ulIsochRemaining <= ulStreamRemaining ) ?
                             ulIsochRemaining  : ulStreamRemaining;

        DbgLog("CapLp1", pKsStreamPtr, pCapBufInfo, ulIsochRemaining, ulStreamRemaining );
        DbgLog("CapLp2", pKsStreamPtr->OffsetOut.Data, pIsochData, 0, 0 );

        ASSERT((LONG)ulStreamRemaining > 0);
        ASSERT((LONG)ulIsochBufferOffset >= 0);

        RtlCopyMemory( pKsStreamPtr->OffsetOut.Data,
                       pIsochData + ulIsochBufferOffset,
                       ulCopySize );

        ulStreamRemaining -= ulCopySize;
        ulIsochRemaining  -= ulCopySize;

        // Check if done with this stream header
        if ( !ulStreamRemaining ) {
            KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr, 0, ulCopySize, TRUE );
            // Get Next stream header if there is one.
            if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
            }
        }
        else {
            KsStreamPointerAdvanceOffsets( pKsStreamPtr, 0, ulCopySize, FALSE );
        }

        pPinContext->ullWriteOffset += ulCopySize;

        // Check if Done with isoch cycle data
        if ( !ulIsochRemaining ) {

            // Check if not done with capture buffer
            while (( ++ulIsochBuffer < INPUT_PACKETS_PER_REQ ) && 
                     USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) );

            if ( ulIsochBuffer < INPUT_PACKETS_PER_REQ ) {
                ulIsochBufferOffset = 0;
                pIsochData = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;
                ulIsochRemaining = pIsoPacket[ulIsochBuffer].Length;
            }
            else {
                NTSTATUS ntStatus;
                BOOLEAN fFound = FALSE;

                // Requeue used capture buffer
                ntStatus = CaptureReQueueUrb( pCapBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    // Log this, but it's okay to continue flushing the data we already have
                    DbgLog("CReQErr", pCapBufInfo, pCapturePinContext, pPinContext, ntStatus );
                }

                // Check if there is more captured data queued
                // Grab Spinlock to check capture queue
                KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                while ( !IsListEmpty( &pCapturePinContext->FullBufferQueue ) & !fFound) {
                    pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)
                           RemoveHeadList(&pCapturePinContext->FullBufferQueue);
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

                    // Find the first good packet in the Urb.

                    ulIsochBuffer = 0;
                    pIsoPacket = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;

                    while ( USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) && 
                          ( ulIsochBuffer < INPUT_PACKETS_PER_REQ) ) {
                        ulIsochBuffer++;
                        pCapturePinContext->ulErrantPackets++;
                        pCapturePinContext->fDataDiscontinuity = TRUE;
                    }

                    fFound = ulIsochBuffer < INPUT_PACKETS_PER_REQ;

                    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                }
                if ( !fFound ) {
                    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
                    pCapturePinContext->fProcessing = FALSE;
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

                    DbgLog("CPrcOff", pCapBufInfo, pCapturePinContext, pPinContext, pCapturePinContext->fProcessing );
                    pCapBufInfo = NULL;
                }
                else {
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                    ulIsochBufferOffset = 0;
                    ulIsochRemaining = pIsoPacket[ulIsochBuffer].Length;
                    pIsochData       = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;
                }
            }
        }
        else {
            ulIsochBufferOffset += ulCopySize;
        }
    }

    if ( !pCapBufInfo ) {
        if ( pKsStreamPtr ) {
            KsStreamPointerUnlock(pKsStreamPtr, FALSE);
        }

        DbgLog("CapPend", pCapturePinContext, pPinContext, pCapturePinContext->fProcessing, 0 );

        // No more capture buffers pending from the device.  Return STATUS_PENDING so that KS
        // doesn't keep calling back into the process routine.  The AndGate should have been
        // turned off at this point to prevent an endless loop too.
        return STATUS_PENDING;
    }
    else { // if ( !pKsStreamPtr )
        pCapturePinContext->pCaptureBufferInUse = pCapBufInfo;
        pCapturePinContext->ulIsochBuffer       = ulIsochBuffer;
        pCapturePinContext->ulIsochBufferOffset = ulIsochBufferOffset;

        DbgLog("CapScss", pCapturePinContext, pPinContext, pCapturePinContext->fProcessing, 0 );

        // Allow KS to call us back if there is more available buffers from the client.  We
        // are ready to process more data.
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CaptureStartIsocTransfer(
    PPIN_CONTEXT pPinContext
    )
{
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    NTSTATUS ntStatus;
    ULONG i;

    if (!pCapturePinContext->fRunning) {


        ntStatus = 
            KeWaitForMutexObject( &pCapturePinContext->CaptureInitMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL );

        pCapturePinContext->fRunning = TRUE;
        pCapBufInfo = pCapturePinContext->CaptureDataBufferInfo;

        for ( i=0; i<CAPTURE_URBS_PER_PIN; i++, pCapBufInfo++ ) {
            InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);

            ASSERT(pPinContext->ulOutstandingUrbCount <= CAPTURE_URBS_PER_PIN);
            DbgLog("CapStrt", pPinContext, pPinContext->ulOutstandingUrbCount,
                              pCapturePinContext->CaptureDataBufferInfo[i].pIrp, i);

            CaptureInitializeUrbAndIrp( pCapBufInfo );

            ntStatus = IoCallDriver( pPinContext->pNextDeviceObject,
                                     pCapturePinContext->CaptureDataBufferInfo[i].pIrp);

            if ( !NT_SUCCESS(ntStatus) ) {
                pCapturePinContext->fRunning = FALSE;
                return ntStatus;
            }
        }

        KeReleaseMutex( &pCapturePinContext->CaptureInitMutex, FALSE );

    }

    return STATUS_SUCCESS;
}


NTSTATUS
CaptureStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureStateChange] NewKsState: %d pKsPin: %x\n", NewKsState, pKsPin));
    DbgLog("CState", pPinContext, pCapturePinContext, NewKsState, OldKsState );

    if (OldKsState != NewKsState) {
        switch(NewKsState) {
            case KSSTATE_STOP:
                if ( pCapturePinContext->fRunning ) AbortUSBPipe( pPinContext );

                KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
                pPinContext->fUrbError = FALSE;
                pCapturePinContext->fRunning = FALSE;
                pCapturePinContext->ulErrantPackets = 0;
                pCapturePinContext->fDataDiscontinuity = FALSE;
                pCapturePinContext->fProcessing = FALSE;
                pPinContext->ullWriteOffset = 0;
                pPinContext->ullTotalBytesReturned = 0;

                InitializeListHead( &pCapturePinContext->UrbErrorQueue );
                InitializeListHead( &pCapturePinContext->FullBufferQueue  );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                break;

            case KSSTATE_ACQUIRE:
            case KSSTATE_PAUSE:
                KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
                pPinContext->fUrbError = FALSE;
                pCapturePinContext->fRunning = FALSE;
                pCapturePinContext->fDataDiscontinuity = FALSE;
                pCapturePinContext->ulErrantPackets = 0;
                pCapturePinContext->fProcessing = FALSE;
                pCapturePinContext->pCaptureBufferInUse = NULL;
                pCapturePinContext->ulIsochBuffer = 0;
                pCapturePinContext->ulIsochBufferOffset = 0;

                InitializeListHead( &pCapturePinContext->UrbErrorQueue );
                InitializeListHead( &pCapturePinContext->FullBufferQueue  );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                USBAudioPinWaitForStarvation( pKsPin );
                break;

            case KSSTATE_RUN:
                ntStatus = CaptureStartIsocTransfer( pPinContext );
                break;

        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CaptureStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    ULONG ulUrbSize = GET_ISO_URB_SIZE(INPUT_PACKETS_PER_REQ);
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUCHAR pData;
    PURB pUrbs;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureStreamInit] pKsPin: %x\n", pKsPin));

    pPinContext->PinType = WaveIn;

    // Allocate Capture Context and data buffers
    pCapturePinContext = pPinContext->pCapturePinContext =
        AllocMem(NonPagedPool, sizeof(CAPTURE_PIN_CONTEXT) +
                               CAPTURE_URBS_PER_PIN *
                                        ( ulUrbSize +
                                        ( (pPinContext->ulMaxPacketSize) * INPUT_PACKETS_PER_REQ )) );
    if (!pCapturePinContext)
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsPin->Bag, pCapturePinContext, FreeMem);

    pCapBufInfo = pCapturePinContext->CaptureDataBufferInfo;

    pUrbs = (PURB)(pCapturePinContext + 1);

    pData = (PUCHAR)pUrbs + ulUrbSize * CAPTURE_URBS_PER_PIN;

    for ( i=0; i<CAPTURE_URBS_PER_PIN; i++, pCapBufInfo++ ) {
        pCapBufInfo->pKsPin = pKsPin;
        pCapBufInfo->pData  = pData + (i*pPinContext->ulMaxPacketSize*INPUT_PACKETS_PER_REQ);
        pCapBufInfo->pUrb   = (PURB)((PUCHAR)pUrbs + (ulUrbSize*i));
        pCapBufInfo->pIrp   = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if (!pCapBufInfo->pIrp) return STATUS_INSUFFICIENT_RESOURCES;
        KsAddItemToObjectBag(pKsPin->Bag, pCapBufInfo->pIrp, IoFreeIrp);
    }

    // Set pCapturePinContext->ulAvgBytesPerSec for position info
    switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
        case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
            {
                PKSDATAFORMAT_WAVEFORMATEX pFmt = (PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat;
                pCapturePinContext->ulAvgBytesPerSec = pFmt->WaveFormatEx.nAvgBytesPerSec;
                pCapturePinContext->ulCurrentSampleRate = pFmt->WaveFormatEx.nSamplesPerSec;
                pCapturePinContext->ulBytesPerSample = ((ULONG)pFmt->WaveFormatEx.wBitsPerSample >> 3) *
                                                        (ULONG)pFmt->WaveFormatEx.nChannels;

                // Set the current Sample rate
                ntStatus = SetSampleRate(pKsPin, &pCapturePinContext->ulCurrentSampleRate);
                if (!NT_SUCCESS(ntStatus)) {
                    return ntStatus;
                }
            }
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
        case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
        default:
            return STATUS_NOT_SUPPORTED;
            break;
    }

    // Set up allocator such that roughly 10 ms of data gets sent in a buffer.
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
                                 (pCapturePinContext->ulCurrentSampleRate/100) * pCapturePinContext->ulBytesPerSample;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = 
                                 (pCapturePinContext->ulCurrentSampleRate/100) * pCapturePinContext->ulBytesPerSample;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = pCapturePinContext->ulBytesPerSample;

    // Initialize the Full Buffer list
    InitializeListHead( &pCapturePinContext->FullBufferQueue );

    // Set initial running flag to FALSE
    pCapturePinContext->fRunning = FALSE;

    // Set initial running flag to FALSE
    pCapturePinContext->fProcessing = FALSE;

    // Set initial Data Discontinuity flag to FALSE
    pCapturePinContext->fDataDiscontinuity = FALSE;

    // Initialize buffer in use pointer
    pCapturePinContext->pCaptureBufferInUse = NULL;

    // Initialize Worker item, object and list for potential error recovery
    InitializeListHead( &pCapturePinContext->UrbErrorQueue );

    ExInitializeWorkItem( &pCapturePinContext->ResetWorkItem,
                          CaptureResetWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->ResetWorkItem,
                                        &pCapturePinContext->ResetWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Initialize Worker item for turning the Gate on when new data arrives from the deveice
    ExInitializeWorkItem( &pCapturePinContext->GateOnWorkItem,
                          CaptureGateOnWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->GateOnWorkItem,
                                        &pCapturePinContext->GateOnWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Initialize Worker item, object and list for potential error recovery
    InitializeListHead( &pCapturePinContext->OutstandingUrbQueue );

    ExInitializeWorkItem( &pCapturePinContext->RequeueWorkItem,
                          CaptureAvoidPipeStarvationWorker,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->RequeueWorkItem,
                                        &pCapturePinContext->RequeueWorkerObject);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    KeInitializeMutex( &pCapturePinContext->CaptureInitMutex, PASSIVE_LEVEL );

    // Disable Processing on the pin until data is available.
    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    return ntStatus;
}

NTSTATUS
CaptureStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;

    _DbgPrintF(DEBUGLVL_TERSE,("[CaptureStreamClose] pin %d pKsPin: %x\n",pKsPin->Id, pKsPin));

    // Clear out all pending KS workitems by unregistering the worker routine
    KsUnregisterWorker( pCapturePinContext->ResetWorkerObject );
    KsUnregisterWorker( pCapturePinContext->GateOnWorkerObject );

    // Wait for all outstanding Urbs to complete.
    USBAudioPinWaitForStarvation( pKsPin );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__


/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

   common.h

Abstract:

   This is the WDM ksshell minidriver.  This module contains
   header definitions and include files needed by all modules in the project

Author:

Environment:

   Kernel mode only


Revision History:

--*/

#include <stdarg.h>
#include <stdio.h>

#include <wdm.h>
#include <windef.h>

#include <ks.h>

#include <mmsystem.h>
#define NOBITMAP
#include <mmreg.h>
#include <ksmedia.h>
#include <midi.h>

#include <usbdrivr.h>

#include <unknown.h>
#include <drmk.h>

#include "Descript.h"
#include "USBAudio.h"

#include "debug.h"
#include "proto.h"


#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define LOCKED_BSS      bss_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS    bss_seg("PAGEDATA", "DATA")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\dbglog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dbglog.h
//
//--------------------------------------------------------------------------

#ifndef __DBGLOG_H
#define __DBGLOG_H

#define DEBUG_LOG 1

#if DBG && DEBUG_LOG

#define DBG_LOG_STRNG   "DBG_BUFFER"

// structures and calls to save data in debug buffer
typedef struct _DEBUG_LOG_ENTRY {
    CHAR     le_name[8];      // Identifying string
    LARGE_INTEGER SysTime;    // System Time
//    ULONG    Irql;            // Current Irql
    ULONG_PTR le_info1;       // entry specific info
    ULONG_PTR le_info2;       // entry specific info
    ULONG_PTR le_info3;       // entry specific info
    ULONG_PTR le_info4;       // entry specific info
} DEBUG_LOG_ENTRY, *PDEBUG_LOG_ENTRY;

typedef struct _DBG_BUFFER {
    UCHAR LGFlag[16];
    ULONG EntryCount;
    PDEBUG_LOG_ENTRY pLogHead;
    PDEBUG_LOG_ENTRY pLogTail;
    PDEBUG_LOG_ENTRY pLog;
} DBG_BUFFER, *PDBG_BUFFER;

VOID
DbugLogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3,
    IN ULONG_PTR Info4
    );

VOID
DbugLogInitialization(void);

VOID
DbugLogUninitialization(void);

#define DbgLogInit() DbugLogInitialization()
#define DbgLogUninit() DbugLogUninitialization()
#define DbgLog(a,b,c,d,e) DbugLogEntry(a,(ULONG_PTR)b,(ULONG_PTR)c,(ULONG_PTR)d, (ULONG_PTR)e)

#else
#define DbgLogInit()
#define DbgLogUninit()
#define DbgLog(a,b,c,d,e)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include "common.h"

#if DBG && DEBUG_LOG

#define LOGSIZE     1024

PDBG_BUFFER gpLogPtr;
KSPIN_LOCK LogSpinLock;
ULONG ulNumDevices = 0;

#ifdef _X86_
#ifndef UNDER_NT

VOID __cdecl
dprintf(
    PSZ pszFmt,
    PVOID Arg1,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [Arg1]
    __asm mov eax, 0x73
    __asm int 41h
}

CHAR
dgetc(
)
{
    __asm mov ax, 0x77          // get command char
    __asm mov bl, 1             // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}

CHAR
DebugGetCommandChar(
)
{
    __asm mov ax, 0x77          // get command char
    __asm mov bl, 1             // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}

VOID
DumpUSBAudioLog( ULONG Count )
{
    ULONG HeadPtr;
    ULONG TailPtr;
    ULONG CurrPtr;
    ULONG LogPtr;
    ULONG i;

    PDBG_BUFFER pDbgLog;

    pDbgLog = gpLogPtr;

    if ( strcmp(pDbgLog->LGFlag, "DBG_BUFFER") ) {
        dprintf("ERROR: Debug Log Flag Mismatch: %x\n", pDbgLog);
        return;
    }

    LogPtr  =  (ULONG)pDbgLog->pLog;
    HeadPtr = ((ULONG)pDbgLog->pLogHead - LogPtr)/sizeof( DEBUG_LOG_ENTRY );
    TailPtr = ((ULONG)pDbgLog->pLogTail - LogPtr)/sizeof( DEBUG_LOG_ENTRY );

    if ( !Count || ( Count > pDbgLog->EntryCount ) ) {
        Count = pDbgLog->EntryCount;
    }

    dprintf("USB Debug Log: Printing %d entries\n", (PVOID)Count);

    CurrPtr = HeadPtr;
    for (i=0;((i<Count) && (CurrPtr<=TailPtr));i++,CurrPtr++) {
//        dprintf ("%8s: %2d %08x   %08x %08x %08x %08x\n",
        dprintf ("%8s: %08x   %08x %08x %08x %08x\n",
                          pDbgLog->pLog[CurrPtr].le_name,
//                         LogPtr[CurrPtr].Irql,
                          pDbgLog->pLog[CurrPtr].SysTime.LowPart/1000,
                          pDbgLog->pLog[CurrPtr].le_info1,
                          pDbgLog->pLog[CurrPtr].le_info2,
                          pDbgLog->pLog[CurrPtr].le_info3,
                          pDbgLog->pLog[CurrPtr].le_info4
                          );
    }

    for (CurrPtr=0;((i<Count) && (CurrPtr<HeadPtr));i++,CurrPtr++) {
//        dprintf ("%8s: %2d %08x   %08x %08x %08x %08x\n",
        dprintf ("%8s: %08x   %08x %08x %08x %08x\n",
                          pDbgLog->pLog[CurrPtr].le_name,
//                          LogPtr[CurrPtr].Irql,
                          pDbgLog->pLog[CurrPtr].SysTime.LowPart/1000,
                          pDbgLog->pLog[CurrPtr].le_info1,
                          pDbgLog->pLog[CurrPtr].le_info2,
                          pDbgLog->pLog[CurrPtr].le_info3,
                          pDbgLog->pLog[CurrPtr].le_info4
                          );
    }
}

VOID
DebugCommand(
)
{
    CHAR c;
    ULONG Count = 0;
    ULONG ulDigit;

    while((c = DebugGetCommandChar()) != '\0') {
        if (c >= '0' && c <= '9') {
            ulDigit = c - '0';
            Count = (Count * 10) + ulDigit;
        }
    }
    DumpUSBAudioLog(Count);
}

VOID
DebugDotCommand(
)
{
    DebugCommand();
    __asm xor eax, eax
    __asm retf
}

VOID
InitializeDebuggerCommand(
)
{
    static char *pszHelp = ".Z [n] - Dump [n] USBAudio Debug Log Entries\n";

    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'Z'
        mov esi, offset DebugDotCommand
        mov edi, pszHelp
        mov eax, 0x70   // DS_RegisterDotCommand
        int 41h
exitlab:
    }
}

VOID
UninitializeDebuggerCommand(
)
{
    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'Z'
        mov eax, 0x72   // DS_DeRegisterDotCommand
        int 41h
exitlab:
    }
}

#endif // ! UNDER_NT
#endif // _X86_

VOID
DbugLogInitialization(void)
{
    if (0 == ulNumDevices) {

#ifndef UNDER_NT
        InitializeDebuggerCommand();
#endif

        gpLogPtr = AllocMem( NonPagedPool, sizeof( DBG_BUFFER ));
        if ( !gpLogPtr ) {
            _DbgPrintF( DEBUGLVL_TERSE, ("Could NOT Allocate debug buffer ptr\n"));
            return;
        }
        gpLogPtr->pLog = AllocMem( NonPagedPool, sizeof(DEBUG_LOG_ENTRY) * LOGSIZE );
        if ( !gpLogPtr->pLog ) {
            FreeMem( gpLogPtr );
            gpLogPtr = NULL;
            _DbgPrintF( DEBUGLVL_TERSE, ("Could NOT Allocate debug buffer\n"));
            return;
        }

        strcpy(gpLogPtr->LGFlag, DBG_LOG_STRNG);

        gpLogPtr->pLogHead = gpLogPtr->pLog;
        gpLogPtr->pLogTail = gpLogPtr->pLogHead + LOGSIZE - 1;
        gpLogPtr->EntryCount = 0;

        KeInitializeSpinLock(&LogSpinLock);
    }

    ulNumDevices++;
}

VOID
DbugLogUninitialization(void)
{
    ulNumDevices--;
    _DbgPrintF(DEBUGLVL_TERSE,("[DbugLogUninitialization] ulNumDevices=%d\n",ulNumDevices));
    if (0 == ulNumDevices) {

        _DbgPrintF(DEBUGLVL_TERSE,("[DbugLogUninitialization] Freeing\n"));
        if ( gpLogPtr->pLog ) {
            FreeMem( gpLogPtr->pLog );
        }

        if ( gpLogPtr ) {
            FreeMem( gpLogPtr );
        }

#ifndef UNDER_NT
        UninitializeDebuggerCommand();
#endif
    }
}

VOID
DbugLogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3,
    IN ULONG_PTR Info4
    )
/*++

Routine Description:

    Adds an Entry to USBD log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (gpLogPtr == NULL)
        return;

    KeAcquireSpinLock( &LogSpinLock, &irql );
    if (gpLogPtr->pLogHead > gpLogPtr->pLog)
        gpLogPtr->pLogHead -= 1;    // Decrement to next entry
    else
        gpLogPtr->pLogHead = gpLogPtr->pLogTail;

    if (strlen(Name) > 7)
        strcpy(gpLogPtr->pLogHead->le_name, "*strER*");
    else
        strcpy(gpLogPtr->pLogHead->le_name, Name);
//    LogPtr->pLogHead->Irql = irql;
    KeQuerySystemTime( &gpLogPtr->pLogHead->SysTime );
    gpLogPtr->pLogHead->le_info1 = Info1;
    gpLogPtr->pLogHead->le_info2 = Info2;
    gpLogPtr->pLogHead->le_info3 = Info3;
    gpLogPtr->pLogHead->le_info4 = Info4;

    gpLogPtr->EntryCount++;

    KeReleaseSpinLock( &LogSpinLock, irql );

    return;
}

#endif

#if DBG && DBGMEMMAP

#pragma LOCKED_DATA
PMEM_TRACKER UsbAudioMemMap;
#pragma PAGEABLE_DATA

VOID
InitializeMemoryList( VOID )
{
   UsbAudioMemMap = ExAllocatePool( NonPagedPool, sizeof( MEM_TRACKER ) );
   if ( !UsbAudioMemMap ) {
       _DbgPrintF(DEBUGLVL_TERSE, ("MEMORY TRACKER ALLOCATION FAILED!!!"));
       TRAP;
   }
   UsbAudioMemMap->TotalBytes = 0;
   InitializeListHead( &UsbAudioMemMap->List );
   KeInitializeSpinLock( &UsbAudioMemMap->SpinLock );
   _DbgPrintF(DEBUGLVL_TERSE, ("'Initialize MEMORY TRACKER UsbAudioMemMap: %x\n",
               UsbAudioMemMap));
}

PVOID
USBAudioAllocateTrack(
    POOL_TYPE PoolType,
    ULONG NumberOfBytes
    )
{
    PVOID pMem;
    KIRQL irql;
    ULONG TotalReqSize = NumberOfBytes + sizeof(ULONG) + sizeof(LIST_ENTRY);

    if ( !(pMem = ExAllocatePool( PoolType, TotalReqSize ) ) ) {
        TRAP;
        return pMem;
    }

    RtlZeroMemory( pMem, TotalReqSize );

    KeAcquireSpinLock( &UsbAudioMemMap->SpinLock, &irql );
    InsertHeadList( &UsbAudioMemMap->List, (PLIST_ENTRY)pMem );
    UsbAudioMemMap->TotalBytes += NumberOfBytes;
    KeReleaseSpinLock( &UsbAudioMemMap->SpinLock, irql );

    pMem = (PLIST_ENTRY)pMem + 1;

    *(PULONG)pMem = NumberOfBytes;

    pMem = (PULONG)pMem + 1;

    return pMem;
}

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    )
{
    PULONG pNumberOfBytes = (PULONG)pMem - 1;
    PLIST_ENTRY ple = (PLIST_ENTRY)pNumberOfBytes - 1;
    KIRQL irql;

    KeAcquireSpinLock( &UsbAudioMemMap->SpinLock, &irql );
    RemoveEntryList(ple);
    UsbAudioMemMap->TotalBytes -= *pNumberOfBytes;
    KeReleaseSpinLock( &UsbAudioMemMap->SpinLock, irql );


    ExFreePool(ple);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\descript.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       descript.h
//
//--------------------------------------------------------------------------

#ifndef ___DESCRIPTORS_H___
#define ___DESCRIPTORS_H___

#define USBAUDIO_POOL_TAG 'AbsU'

#define MS_PER_SEC 1000

#define USB_CLASS_AUDIO     0x20

#define ABSOLUTE_NODE_FLAG  0x80000000L
#define NODE_MASK           0x7fffffffL

// Class Specific Endpoint Feature enable bits
#define ENDPOINT_SAMPLE_FREQ_MASK       1
#define ENDPOINT_PITCH_MASK             2

// Class Specific Endpoint Lock Delay bits
#define EP_LOCK_DELAY_UNITS_MS          1
#define EP_LOCK_DELAY_UNITS_SAMPLES     2

// Channel Config
#define LEFT_CHANNEL            0x01
#define RIGHT_CHANNEL           0x02
#define CENTER_CHANNEL          0x04
#define LFE_CHANNEL             0x08
#define LEFT_SURROUND_CHANNEL   0x10
#define RIGHT_SURROUND_CHANNEL  0x20
#define LEFT_CENTER_CHANNEL     0x40
#define RIGHT_CENTER_CHANNEL    0x80
#define SURROUND_CHANNEL        0x100
#define SIDE_LEFT_CHANNEL       0x200
#define SIDE_RIGHT_CHANNEL      0x400
#define TOP_CHANNEL             0x800

// Audio sub-classes
#define SUBCLASS_UNDEFINED              0x00
#define AUDIO_SUBCLASS_CONTROL          0x01
#define AUDIO_SUBCLASS_STREAMING        0x02
#define AUDIO_SUBCLASS_MIDISTREAMING    0x03

// Audio Class-Specific AC Interface Descriptor Subtypes
#define HEADER_UNIT     0x01
#define INPUT_TERMINAL  0x02
#define OUTPUT_TERMINAL 0x03
#define MIXER_UNIT      0x04
#define SELECTOR_UNIT   0x05
#define FEATURE_UNIT    0x06
#define PROCESSING_UNIT 0x07
#define EXTENSION_UNIT  0x08
#define MAX_TYPE_UNIT   0x09

// Audio Class-Specific AS Interface Descriptor Subtypes
#define AS_GENERAL      0x01
#define FORMAT_TYPE     0x02
#define FORMAT_SPECIFIC 0x03

// Processing Unit Process Types
#define UP_DOWNMIX_PROCESS          0x01
#define DOLBY_PROLOGIC_PROCESS      0x02
#define STEREO_EXTENDER_PROCESS     0x03
#define REVERBERATION_PROCESS       0x04
#define CHORUS_PROCESS              0x05
#define DYN_RANGE_COMP_PROCESS      0x06

// Audio Class-Specific Endpoint Descriptor Subtypes
#define EP_GENERAL  0x01

// Audio Class-Specific MS Interface Descriptor Subtypes
#define MS_HEADER       0x01
#define MIDI_IN_JACK    0x02
#define MIDI_OUT_JACK   0x03
#define MIDI_ELEMENT    0x04

// Audio Class-Specific MS Endpoint Descriptor Subtypes
#define MS_GENERAL      0x01

// Audio MS MIDI IN and OUT Jack types
#define JACK_TYPE_EMBEDDED      0x01
#define JACK_TYPE_EXTERNAL      0x02

// Class-Specific Request Codes
#define CLASS_SPECIFIC_GET_MASK 0x80

#define SET_CUR 0x01
#define GET_CUR 0x81
#define SET_MIN 0x02
#define GET_MIN 0x82
#define SET_MAX 0x03
#define GET_MAX 0x83
#define SET_RES 0x04
#define GET_RES 0x84
#define SET_MEM 0x05
#define GET_MEM 0x85
#define GET_STAT    0xFF

// Terminal Control Selectors
#define COPY_PROTECT_CONTROL    0x01

// Feature Unit Control Selectors
#define MUTE_CONTROL                0x01
#define VOLUME_CONTROL              0x02
#define BASS_CONTROL                0x03
#define MID_CONTROL                 0x04
#define TREBLE_CONTROL              0x05
#define GRAPHIC_EQUALIZER_CONTROL   0x06
#define AUTOMATIC_GAIN_CONTROL      0x07
#define DELAY_CONTROL               0x08
#define BASS_BOOST_CONTROL          0x09
#define LOUDNESS_CONTROL            0x0A

// Feature Unit Flags
#define MUTE_FLAG               0x01
#define VOLUME_FLAG             0x02
#define BASS_FLAG               0x04
#define MID_FLAG                0x08
#define TREBLE_FLAG             0x10
#define GRAPHIC_EQUALIZER_FLAG  0x20
#define AUTOMATIC_GAIN_FLAG     0x40
#define DELAY_FLAG              0x80
#define BASS_BOOST_FLAG         0x100
#define LOUDNESS_FLAG           0x200

// Up/Down-mix Processing Unit Control Selectors
#define UD_ENABLE_CONTROL       0x01
#define UD_MODE_SELECT_CONTROL  0x02

// Dolby Prologic Processing Unit Control Selectors
#define DP_ENABLE_CONTROL       0x01
#define DP_MODE_SELECT_CONTROL  0x02

// 3D_Stereo Extender Processing Unit Control Selectors
#define ENABLE_CONTROL          0x01
#define SPACIOUSNESS_CONTROL    0x03

// Reverberation Processing Unit Control Selectors
#define RV_ENABLE_CONTROL       0x01
#define REVERB_LEVEL_CONTROL    0x02
#define REVERB_TIME_CONTROL     0x03
#define REVERB_FEEDBACK_CONTROL 0x04

// Chorus Processing Unit Control Selectors
#define CH_ENABLE_CONTROL       0x01
#define CHORUS_LEVEL_CONTROL    0x02
#define CHORUS_RATE_CONTROL     0x03
#define CHORUS_DEPTH_CONTROL    0x04

// Dynamic Range Compressor Unit Control Selectors
#define DR_ENABLE_CONTROL           0x01
#define COMPRESSION_RATE_CONTROL    0x02
#define MAXAMPL_CONTROL             0x03
#define THRESHOLD_CONTROL           0x04
#define ATTACK_TIME                 0x05
#define RELEASE_TIME                0x06

// Extension Unit Control Selectors
#define XU_ENABLE_CONTROL       0x01

// Endpoint Control Selectors
#define SAMPLING_FREQ_CONTROL   0x01
#define PITCH_CONTROL   0x02

// Endpoint Bitmapped Attributes
#define EP_SYNC_TYPE_MASK       0xc
#define EP_ASYNC_SYNC_TYPE      0x4
#define EP_SHARED_SHARE_TYPE    0x10

// Controls for error checking only
#define DEV_SPECIFIC_CONTROL 0x1001

// bmRequestType field values for requests
#define USB_COMMAND_TO_INTERFACE 0x21
#define USB_COMMAND_TO_ENDPOINT  0x22

// Terminal type masks
#define USB_Streaming       0x0101
#define Input_Mask          0x0200
#define Output_Mask         0x0300
#define Bidirectional_Mask  0x0400
#define Telephony_Mask      0x0500
#define External_Mask       0x0600
#define Embedded_Mask       0x0700

// External terminal types
#define External_Undefined              0x0600  // I/O External Terminal, undefined Type.
#define Analog_connector                0x0601  // I/O A generic analog connector.
#define Digital_audio_interface         0x0602  // I/O A generic digital audio interface.
#define Line_connector                  0x0603  // I/O An analog connector at standard line
                                                // levels. Usually uses 3.5mm.
#define Legacy_audio_connector          0x0604  // I/O An input connector assumed to be
                                                // connected to the lineout of the legacy
                                                // audio system of the host computer. Used
                                                // for backward compatibility.
#define SPDIF_interface                 0x0605  // I/O An S/PDIF digital audio interface. The
                                                // Associated Interface descriptor can be
                                                // used to reference an interface used for
                                                // controlling special functions of this
                                                // interface.
#define DA_stream_1394                  0x0606  // I/O An interface to audio streams on a 1394 bus.
#define DV_stream soundtrack_1394       0x0607  // I/O An interface to soundtrack of A/V stream
                                                // on a 1394 bus.

// Embedded terminal types
#define Embedded_Undefined              0x0700
#define Level_Calibration_Noise_Source  0x0701
#define Equalization_Noise              0x0702
#define CD_player                       0x0703
#define DAT                             0x0704
#define DCC                             0x0705
#define MiniDisk                        0x0706
#define Analog_Tape                     0x0707
#define Phonograph                      0x0708
#define VCR_Audio                       0x0709
#define Video_Disc_Audio                0x070A
#define DVD_Audio                       0x070B
#define TV_Tuner_Audio                  0x070C
#define Satellite_Receiver_Audio        0x070D
#define Cable_Tuner_Audio               0x070E
#define DSS_Audio                       0x070F
#define Radio_Receiver                  0x0710
#define Radio_Transmitter               0x0711
#define Multitrack_Recorder             0x0712
#define Synthesizer                     0x0713

#define USBAUDIO_DATA_FORMAT_TYPE_MASK         0xF000

// Audio Data Format Type I codes
#define USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED  0x0000
#define USBAUDIO_DATA_FORMAT_PCM               0x0001
#define USBAUDIO_DATA_FORMAT_PCM8              0x0002
#define USBAUDIO_DATA_FORMAT_IEEE_FLOAT        0x0003
#define USBAUDIO_DATA_FORMAT_ALAW              0x0004
#define USBAUDIO_DATA_FORMAT_MULAW             0x0005

// Audio Data Format Type II codes
#define USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED  0x1000
#define USBAUDIO_DATA_FORMAT_MPEG               0x1001
#define USBAUDIO_DATA_FORMAT_AC3                0x1002

// Audio Data Format Type III codes
#define USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED 0x2000
#define USBAUDIO_DATA_FORMAT_IEC1937_AC3        0x2001
#define USBAUDIO_DATA_FORMAT_IEC1937_MPEG1_1    0x2002

// Map KSNODE_TYPE GUIDs to Indexes
#define NODE_TYPE_NONE          0
#define NODE_TYPE_DAC           1
#define NODE_TYPE_ADC           2
#define NODE_TYPE_SRC           3
#define NODE_TYPE_SUPERMIX      4
#define NODE_TYPE_MUX           5
#define NODE_TYPE_SUM           6
#define NODE_TYPE_MUTE          7
#define NODE_TYPE_VOLUME        8
#define NODE_TYPE_BASS          9
#define NODE_TYPE_MID           10
#define NODE_TYPE_TREBLE        11
#define NODE_TYPE_BASS_BOOST    12
#define NODE_TYPE_EQUALIZER     13
#define NODE_TYPE_AGC           14
#define NODE_TYPE_DELAY         15
#define NODE_TYPE_LOUDNESS      16
#define NODE_TYPE_PROLOGIC      17
#define NODE_TYPE_STEREO_WIDE   18
#define NODE_TYPE_REVERB        19
#define NODE_TYPE_CHORUS        20
#define NODE_TYPE_DEV_SPEC      21

#define MapFuncsToNodeTypes( a ) \
{\
    a[KSPROPERTY_AUDIO_LATENCY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_COPY_PROTECTION]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CHANNEL_CONFIG]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_VOLUMELEVEL]           = NODE_TYPE_VOLUME; \
    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_QUALITY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_TABLE]       = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_CAPS]        = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MUX_SOURCE]            = NODE_TYPE_MUX; \
    a[KSPROPERTY_AUDIO_MUTE]                  = NODE_TYPE_MUTE; \
    a[KSPROPERTY_AUDIO_BASS]                  = NODE_TYPE_BASS; \
    a[KSPROPERTY_AUDIO_MID]                   = NODE_TYPE_MID; \
    a[KSPROPERTY_AUDIO_TREBLE]                = NODE_TYPE_TREBLE; \
    a[KSPROPERTY_AUDIO_BASS_BOOST]            = NODE_TYPE_BASS_BOOST; \
    a[KSPROPERTY_AUDIO_EQ_LEVEL]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_NUM_EQ_BANDS]          = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_EQ_BANDS]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_AGC]                   = NODE_TYPE_AGC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_LOUDNESS]              = NODE_TYPE_LOUDNESS; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \
}

//=====================================================================//

#pragma pack( push, pcm2usb_structs, 1)

// Sample Rate
typedef struct {
    UCHAR bSampleFreqByte1;
    UCHAR bSampleFreqByte2;
    UCHAR bSampleFreqByte3;
    } AUDIO_SAMPLE_RATE, *PAUDIO_SAMPLE_RATE;

// Audio Format Type Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bFormatType;
    UCHAR bNumberOfChannels;
    UCHAR bSlotSize;
    UCHAR bBitsPerSample;
    UCHAR bSampleFreqType;
    AUDIO_SAMPLE_RATE pSampleRate[];
    } AUDIO_CLASS_TYPE1_STREAM,   AUDIO_CLASS_STREAM,
    *PAUDIO_CLASS_TYPE1_STREAM, *PAUDIO_CLASS_STREAM;

// Audio Format Type Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bFormatType;
    USHORT wMaxBitRate;
    USHORT wSamplesPerFrame;
    UCHAR bSampleFreqType;
    AUDIO_SAMPLE_RATE pSampleRate[];
    } AUDIO_CLASS_TYPE2_STREAM, *PAUDIO_CLASS_TYPE2_STREAM;

// Audio Class-Specific stream interface general descriptor

typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // AS_GENERAL descriptor subtype
    UCHAR bTerminalLink;        // The terminal id connected to the endpoint for this interface
    UCHAR bDelay;               // Delay introduced by the data path
    USHORT wFormatTag;          // The audio data format used to communicate with this endpoint
    } AUDIO_GENERAL_STREAM, *PAUDIO_GENERAL_STREAM;

// Audio Specific Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    } AUDIO_SPECIFIC, *PAUDIO_SPECIFIC;

// Audio Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    } AUDIO_UNIT, *PAUDIO_UNIT;

// Audio Header Unit
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // HEADER_UNIT descriptor subtype
    USHORT bcdAudioSpec;        // USB audio class spec revision number
    USHORT wTotalLength;        // Total length, including all units and terminals
    UCHAR bInCollection;        // number of audio streaming interfaces
    UCHAR baInterfaceNr[];      // interface number array
    } AUDIO_HEADER_UNIT, *PAUDIO_HEADER_UNIT;

// Audio Input Terminal Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // INPUT_TERMINAL descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wTerminalType;       // Type of terminal
    UCHAR bAssocTerminal;       // Associated output terminal
    UCHAR bNrChannels;          // Number of logical output channels in the cluster
    USHORT wChannelConfig;      // Spatial locations of the logical channels
    UCHAR iChannelNames;        // Index of 1st string descriptor describing channels
    UCHAR iTerminal;            // Index of string descriptor describing this unit
    } AUDIO_INPUT_TERMINAL, *PAUDIO_INPUT_TERMINAL;

// Audio Output Terminal Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // OUTPUT_TERMINAL descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wTerminalType;       // Type of terminal
    UCHAR bAssocTerminal;       // Associated input terminal
    UCHAR bSourceID;            // ID of Unit or Terminal connected to this Terminal
    UCHAR iTerminal;            // Index of string descriptor describing this unit
    } AUDIO_OUTPUT_TERMINAL, *PAUDIO_OUTPUT_TERMINAL;

// Audio Mixer Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // MIXER_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_MIXER_UNIT, *PAUDIO_MIXER_UNIT;

typedef struct {
    UCHAR bNrChannels;          // Number of output channels
    USHORT wChannelConfig;      // Spatial Location of channels
    UCHAR iChannelNames;        // Index to string desc. for first channel
    UCHAR bmControls[];         // Bitmap of which controls are programmable
    } AUDIO_MIXER_UNIT_CHANNELS, *PAUDIO_MIXER_UNIT_CHANNELS;

// Audio Selector Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // SELECTOR_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_SELECTOR_UNIT, *PAUDIO_SELECTOR_UNIT;

// Audio Feature Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // FEATURE_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bSourceID;            // ID of Unit or Terminal connected to this Feature Unit
    UCHAR bControlSize;         // Size (in bytes) of each element in bmaProps array
    UCHAR bmaControls[];        // Indicates available controls for each channel
    } AUDIO_FEATURE_UNIT, *PAUDIO_FEATURE_UNIT;

// Audio Processing Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // PROCESSING_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wProcessType;        // Type of processing performed by this Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_PROCESSING_UNIT, *PAUDIO_PROCESSING_UNIT;

// Audio Channel Info Block
typedef struct {
    UCHAR bNrChannels;          // Number of output channels in the cluster
    USHORT wChannelConfig;      // Spatial locations of the logical channels
    UCHAR iChannelNames;        // Channel names
    UCHAR bControlSize;         // Size in bytes of the bmControls field
    UCHAR bmControls[];         // Bit-mapped controls available
    } AUDIO_CHANNELS, *PAUDIO_CHANNELS;

// Audio Extension Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // EXTENSION_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wExtensionCode;      // Vendor-specific code identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_EXTENSION_UNIT, *PAUDIO_EXTENSION_UNIT;

// AC Interrupt Endpoint Descriptor
typedef struct _USB_INTERRUPT_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
    UCHAR bRefresh;
    UCHAR bSynchAddress;
} USB_INTERRUPT_ENDPOINT_DESCRIPTOR, *PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR;

typedef struct _AUDIO_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bDescriptorSubtype;
    UCHAR bmAttributes;
    UCHAR bLockDelayUnits;
    USHORT wLockDelay;
} AUDIO_ENDPOINT_DESCRIPTOR, *PAUDIO_ENDPOINT_DESCRIPTOR;

typedef struct _PIN_TERMINAL_MAP {
    ULONG PinNumber;
    ULONG BridgePin;
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    };
} PIN_TERMINAL_MAP, *PPIN_TERMINAL_MAP;

// MIDI Streaming Class-Specific stream interface general descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // MS_HEADER descriptor subtype
    USHORT bcdAudioSpec;        // USB audio class spec revision number
    USHORT wTotalLength;        // Total length, including all units and terminals

    } MIDISTREAMING_GENERAL_STREAM, *PMIDISTREAMING_GENERAL_STREAM;

// MIDI Streaming Source Connections
typedef struct {
    UCHAR SourceID;
    UCHAR SourcePin;
    } MIDISTREAMING_SOURCECONNECTIONS, *PMIDISTREAMING_SOURCECONNECTIONS;

// MIDI Streaming Element Descriptor, part 1
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // ELEMENT
    UCHAR bElementID;           // ID of this element
    UCHAR bNrInputPins;         // Number of input pins of this element
    MIDISTREAMING_SOURCECONNECTIONS baSourceConnections[]; // Source connection information
    } MIDISTREAMING_ELEMENT, *PMIDISTREAMING_ELEMENT;

// MIDI Streaming Element Descriptor, part 2 (the rest of the element descriptor)
typedef struct {
    UCHAR bNrOutputPins;        // number of output pins on the element
    UCHAR bInTerminalLink;      // terminal id of the input terminal
    UCHAR bOutTerminalLink;     // terminal id of the output terminal
    UCHAR bElCapsSize;          // size of bmElementCaps
    UCHAR bmElementCaps[];      // caps bitmap
    } MIDISTREAMING_ELEMENT2, *PMIDISTREAMING_ELEMENT2;

// MIDI Streaming MIDI IN Jack Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // Jack subtype
    UCHAR bJackType;            // EMBEDDED vs. EXTERNAL
    UCHAR bJackID;              // ID of the Jack
    } MIDISTREAMING_MIDIIN_JACK, *PMIDISTREAMING_MIDIIN_JACK;


// MIDI Streaming MIDI OUT Jack Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // Jack subtype
    UCHAR bJackType;            // EMBEDDED vs. EXTERNAL
    UCHAR bJackID;              // ID of the Jack
    UCHAR bNrInputPins;         // Number of input pins on this jack
    MIDISTREAMING_SOURCECONNECTIONS baSourceConnections[]; // Source connection information
    } MIDISTREAMING_MIDIOUT_JACK, *PMIDISTREAMING_MIDIOUT_JACK;


// MIDI Streaming MIDI Endpoint Descriptor
typedef struct _MIDISTREAMING_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_ENDPOINT descriptor type
    UCHAR bDescriptorSubtype;   // MS_GENERAL descriptor subtype
    UCHAR bNumEmbMIDIJack;      // Number of embedded jacks
    UCHAR baAssocJackID[];      // IDs of the embedded jacks
} MIDISTREAMING_ENDPOINT_DESCRIPTOR, *PMIDISTREAMING_ENDPOINT_DESCRIPTOR;


#pragma pack( pop, pcm2usb_structs )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __DEBUG_H
#define __DEBUG_H

#define DBGMEMMAP 0

#if (DBG)
#define STR_MODULENAME "'USB Audio: "
#endif

#ifdef LOG_TO_FILE

NTSTATUS NTAPI 
FileOpenRoutine (
    PHW_DEVICE_EXTENSION deviceExtension
    );

NTSTATUS NTAPI 
FileIoRoutine (
    PHW_DEVICE_EXTENSION deviceExtension,
    PVOID buffer, 
    ULONG length
    );

NTSTATUS NTAPI 
FileCloseRoutine (
    PHW_DEVICE_EXTENSION deviceExtension
    );

#endif

#if DBG && DBGMEMMAP

typedef struct {
    ULONG TotalBytes;
    KSPIN_LOCK SpinLock;
    LIST_ENTRY List;
} MEM_TRACKER, *PMEM_TRACKER;

extern PMEM_TRACKER UsbAudioMemMap;

VOID
InitializeMemoryList( VOID );

PVOID
USBAudioAllocateTrack(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    );

#define AllocMem USBAudioAllocateTrack
#define FreeMem USBAudioDeallocateTrack

#else

#define AllocMem ExAllocatePool
#define FreeMem ExFreePool

#endif

#if DBG
VOID
DumpUnitDescriptor( PUCHAR pAddr );

VOID
DumpAllUnitDescriptors( 
    PUCHAR BeginAddr, PUCHAR EndAddr );

VOID
DumpDescriptor( PVOID pDescriptor );

VOID
DumpAllDescriptors(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor 
    );

#define DumpDesc DumpDescriptor
#define DumpAllDesc DumpAllDescriptors
#define DumpAllUnits DumpAllUnitDescriptors
#define DumpUnitDesc DumpUnitDescriptor

#else

#define DumpDesc(a)
#define DumpAllDesc(a)
#define DumpAllUnits(a,b)
#define DumpUnitDesc(a)

#endif

#if DBG

#define TRAP DbgBreakPoint()

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_VERBOSE
#endif

extern ULONG USBAudioDebugLevel;

#define PCM2USB_KdPrint(_x_) \
{\
    if ( USBAudioDebugLevel >= DEBUGLVL_VERBOSE ) {\
        DbgPrint(STR_MODULENAME); \
        DbgPrint _x_ ;\
    } \
}

#define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= USBAudioDebugLevel) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        if ((lvl) == DEBUGLVL_ERROR) {\
             DbgBreakPoint();\
        } \
    } \
}

#else

#define TRAP 
#define PCM2USB_KdPrint(_x_)
#define _DbgPrintF(lvl, strings)

#endif

#include "dbglog.h"

//------------------------------- End of File --------------------------------
#endif // #ifndef __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\descript.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       descript.c
//
//--------------------------------------------------------------------------

#include "common.h"

#if DBG

VOID
DumpGenericDescriptor( PUCHAR pDescriptor )
{
    ULONG i, j;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("GENERIC DESCRIPTOR: %x\n  ",pDescriptor));

    for (i=0; i<pDescriptor[0];) {
       for ( j=0; (j<16 && i<pDescriptor[0]); j++, i++ )
           _DbgPrintF(DEBUGLVL_VERBOSE,(" 0x%2.2x",pDescriptor[i] ));
       _DbgPrintF(DEBUGLVL_VERBOSE,("\n ",pDescriptor[i] ));
    }
}

VOID DumpHeaderUnit( PAUDIO_HEADER_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("HEADER UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdAudioSpec:      0x%4.4x\n",pDescriptor->bcdAudioSpec));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:       0x%4.4x\n",pDescriptor->wTotalLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  InCollection:      0x%2.2x (# Streaming I/F's)\n",pDescriptor->bInCollection));
    for ( i=0; i<pDescriptor->bInCollection; i++ )
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baInterfaceNr[%d]:  0x%2.2x\n",i,pDescriptor->baInterfaceNr[i]));

}

VOID DumpInputTerminal( PAUDIO_INPUT_TERMINAL pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("INPUT TERMINAL: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wTerminalType:     0x%4.4x\n",pDescriptor->wTerminalType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAssocTerminal:    0x%2.2x\n",pDescriptor->bAssocTerminal));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrChannels:       0x%2.2x\n",pDescriptor->bNrChannels));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wChannelConfig:    0x%4.4x\n",pDescriptor->wChannelConfig));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iChannelNames:     0x%2.2x\n",pDescriptor->iChannelNames));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iTerminal:         0x%2.2x\n",pDescriptor->iTerminal));

}

VOID DumpOutputTerminal( PAUDIO_OUTPUT_TERMINAL pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("OUTPUT TERMINAL: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wTerminalType:     0x%4.4x\n",pDescriptor->wTerminalType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAssocTerminal:    0x%2.2x\n",pDescriptor->bAssocTerminal));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSourceID:         0x%2.2x\n",pDescriptor->bSourceID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iTerminal:         0x%2.2x\n",pDescriptor->iTerminal));
}

VOID DumpMixerUnit( PAUDIO_MIXER_UNIT pDescriptor )
{
    ULONG i;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels =
           (PAUDIO_MIXER_UNIT_CHANNELS)(pDescriptor->baSourceID + pDescriptor->bNrInPins);

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MIXER UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));

    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrChannels:       0x%2.2x\n",pMixChannels->bNrChannels));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wChannelConfig:    0x%4.4x\n",pMixChannels->wChannelConfig));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iChannelNames:     0x%2.2x\n",pMixChannels->iChannelNames));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmControls:        0x%2.2x\n",pMixChannels->bmControls[0]));

}

VOID DumpSelectorUnit( PAUDIO_SELECTOR_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("SELECTOR UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));
}

VOID DumpFeatureUnit( PAUDIO_FEATURE_UNIT pDescriptor )
{
    ULONG i;
    PUCHAR pCurrentOffset = pDescriptor->bmaControls;
    ULONG ulControlVal = 0;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("FEATURE UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSourceID:         0x%2.2x\n",pDescriptor->bSourceID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bControlSize:      0x%2.2x\n",pDescriptor->bControlSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmaControls:\n"));

    while ( pCurrentOffset < ((PUCHAR)pDescriptor + (pDescriptor->bLength-1)) ) {
        ulControlVal = 0;
        for ( i=pDescriptor->bControlSize; i>0; i--) {
            ulControlVal<<=8;
            ulControlVal |= (pCurrentOffset[i-1]);
        }
        pCurrentOffset += pDescriptor->bControlSize;
        if (pDescriptor->bControlSize == 1) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%2.2x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 2 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%4.4x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 3 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%6.6x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 4 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%8.8x\n",ulControlVal));
        }
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iFeature:          0x%2.2x\n",pCurrentOffset[0]));

    _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
}

VOID DumpProcessUnit( PAUDIO_PROCESSING_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("PROCESSING UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wProcessType:      0x%2.2x\n",pDescriptor->wProcessType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));

}

VOID DumpExtensionUnit( PAUDIO_EXTENSION_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("EXTENSION UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wExtensionCode:    0x%2.2x\n",pDescriptor->wExtensionCode));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));
}

VOID
DumpUnitDescriptor( PUCHAR pAddr )
{
   PAUDIO_UNIT pCommonDesc = (PAUDIO_UNIT)pAddr;

   switch( pCommonDesc->bDescriptorSubtype ) {
       case HEADER_UNIT:     DumpHeaderUnit((PAUDIO_HEADER_UNIT)pCommonDesc);        break;
       case INPUT_TERMINAL:  DumpInputTerminal((PAUDIO_INPUT_TERMINAL)pCommonDesc);  break;
       case OUTPUT_TERMINAL: DumpOutputTerminal((PAUDIO_OUTPUT_TERMINAL)pCommonDesc);break;
       case MIXER_UNIT:      DumpMixerUnit((PAUDIO_MIXER_UNIT)pCommonDesc);          break;
       case SELECTOR_UNIT:   DumpSelectorUnit((PAUDIO_SELECTOR_UNIT)pCommonDesc);    break;
       case FEATURE_UNIT:    DumpFeatureUnit((PAUDIO_FEATURE_UNIT)pCommonDesc);      break;
       case PROCESSING_UNIT: DumpProcessUnit((PAUDIO_PROCESSING_UNIT)pCommonDesc);   break;
       case EXTENSION_UNIT:  DumpExtensionUnit((PAUDIO_EXTENSION_UNIT)pCommonDesc);  break;
       default:  DumpGenericDescriptor( (PUCHAR)pCommonDesc );                       break;
   }
}

VOID
DumpAllUnitDescriptors( PUCHAR BeginAddr, PUCHAR EndAddr )
{
    PUCHAR pCurrentOffset = BeginAddr;

    _DbgPrintF(DEBUGLVL_VERBOSE,("------------ DUMPING ALL DESCRIPTORS ------------\n"));

    while ( pCurrentOffset < EndAddr ) {
        DumpUnitDescriptor( pCurrentOffset );
        pCurrentOffset += pCurrentOffset[0];
    }
}

VOID
DumpDeviceDescriptor( PUSB_DEVICE_DESCRIPTOR pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("DEVICE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdUSB:            0x%4.4x\n",pDescriptor->bcdUSB));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceClass:       0x%2.2x\n",pDescriptor->bDeviceClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceSubClass:    0x%2.2x\n",pDescriptor->bDeviceSubClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceProtocol:    0x%2.2x\n",pDescriptor->bDeviceProtocol));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bMaxPacketSize:    0x%2.2x\n",pDescriptor->bMaxPacketSize0));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT idVendor:          0x%4.4x\n",pDescriptor->idVendor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT idProduct:         0x%4.4x\n",pDescriptor->idProduct));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdDevice:         0x%4.4x\n",pDescriptor->bcdDevice));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Manufacturer:      0x%2.2x\n",pDescriptor->iManufacturer));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Product:           0x%2.2x\n",pDescriptor->iProduct));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SerialNumber:      0x%2.2x\n",pDescriptor->iSerialNumber));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  NumConfigurations: 0x%2.2x\n",pDescriptor->bNumConfigurations));

}

VOID
DumpConfigDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CONFIGURATION DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:        0x%4.4x\n",pDescriptor->wTotalLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  NumInterfaces:      0x%2.2x\n",pDescriptor->bNumInterfaces));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  ConfigurationValue: 0x%2.2x\n",pDescriptor->bConfigurationValue));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Configuration:      0x%2.2x\n",pDescriptor->iConfiguration));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:       0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  MaxPower:           0x%2.2x\n",pDescriptor->MaxPower));

}

VOID
DumpEndpointDescriptor(
    PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:           0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:   0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  EndpointAddress:  0x%2.2x\n",pDescriptor->bEndpointAddress));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:     0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT MaxPacketSize:    0x%4.4x\n",pDescriptor->wMaxPacketSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Interval:         0x%2.2x\n",pDescriptor->bInterval));
    if (pDescriptor->bLength >= sizeof(USB_INTERRUPT_ENDPOINT_DESCRIPTOR)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Refresh:          0x%2.2x\n",pDescriptor->bRefresh));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SynchAddress:     0x%2.2x\n",pDescriptor->bSynchAddress));
    }

}

VOID
DumpInterfaceDescriptor(
    PUSB_INTERFACE_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("INTERFACE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceNumber:   0x%2.2x\n",pDescriptor->bInterfaceNumber));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAlternateSetting:  0x%2.2x\n",pDescriptor->bAlternateSetting));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumEndpoints:      0x%2.2x\n",pDescriptor->bNumEndpoints));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceClass:    0x%2.2x",pDescriptor->bInterfaceClass));
    if (pDescriptor->bInterfaceClass == USB_DEVICE_CLASS_AUDIO) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio)\n"));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceSubClass: 0x%2.2x",pDescriptor->bInterfaceSubClass));
    if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_CONTROL ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio Control)\n"));
    }
    else if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_STREAMING ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio Streaming)\n"));
    }
    else if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_MIDISTREAMING ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio MIDI Streaming)\n"));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceProtocol: 0x%2.2x\n",pDescriptor->bInterfaceProtocol));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iInterface:         0x%2.2x\n",pDescriptor->iInterface));
}


VOID
DumpAudioSubclassSpecificEndpointDescriptor(PAUDIO_ENDPOINT_DESCRIPTOR pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS AUDIO ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:       0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bLockDelayUnits:    0x%2.2x\n",pDescriptor->bLockDelayUnits));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wLockDelay:         0x%4.4x\n",pDescriptor->wLockDelay));
}

VOID
DumpMIDISubclassSpecificEndpointDescriptor(PMIDISTREAMING_ENDPOINT_DESCRIPTOR pDescriptor)
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS MIDI ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumEmbMIDIJack:    0x%2.2x\n",pDescriptor->bNumEmbMIDIJack));
    for (i=0;i<pDescriptor->bNumEmbMIDIJack; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baAssocJackID[%d]:   0x%2.2x\n",i,pDescriptor->baAssocJackID[i]));
}

VOID
DumpClassSpecificEndpointDescriptor(PUCHAR pDescriptor, ULONG SubClassFlag)
{
    ULONG ulDescriptorSubtype = (ULONG)((PUCHAR)pDescriptor)[2];

    switch (SubClassFlag) {
        case AUDIO_SUBCLASS_CONTROL:
            switch(ulDescriptorSubtype) {
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_STREAMING:
            switch(ulDescriptorSubtype) {
                case AS_GENERAL:
                    DumpAudioSubclassSpecificEndpointDescriptor((PAUDIO_ENDPOINT_DESCRIPTOR)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_MIDISTREAMING:
            switch(ulDescriptorSubtype) {
                case MS_GENERAL:
                    DumpMIDISubclassSpecificEndpointDescriptor((PMIDISTREAMING_ENDPOINT_DESCRIPTOR)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        default:
            DumpGenericDescriptor( pDescriptor );
            break;
    }
}

VOID
DumpAudioSubclassSpecificGeneralDescriptor(PAUDIO_GENERAL_STREAM pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS GENERAL STREAM DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bTerminalLink:      0x%2.2x\n",pDescriptor->bTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bDelay:             0x%2.2x\n",pDescriptor->bDelay));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wFormatTag:         0x%4.4x\n",pDescriptor->wFormatTag));
}

VOID
DumpAudioSubclassSpecificFormatTypeDescriptor(PAUDIO_CLASS_STREAM pDescriptor)
{
    PAUDIO_CLASS_TYPE1_STREAM pT1Desc = (PAUDIO_CLASS_TYPE1_STREAM)pDescriptor;
    PAUDIO_CLASS_TYPE2_STREAM pT2Desc = (PAUDIO_CLASS_TYPE2_STREAM)pDescriptor;
    ULONG MinSampleRate, MaxSampleRate;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS FORMAT TYPE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bFormatType:        0x%2.2x\n",pDescriptor->bFormatType));

    if (pDescriptor->bFormatType == 1) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumberOfChannels:  0x%2.2x\n",pT1Desc->bNumberOfChannels));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSlotSize:          0x%2.2x\n",pT1Desc->bSlotSize));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bBitsPerSample:     0x%2.2x\n",pT1Desc->bBitsPerSample));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSampleFreqType:    0x%2.2x\n",pT1Desc->bSampleFreqType));
        if (pT1Desc->bSampleFreqType == 0) { // Continuous Range
            MinSampleRate = pT1Desc->pSampleRate[0].bSampleFreqByte1 +
                     256L * pT1Desc->pSampleRate[0].bSampleFreqByte2 +
                   65536L * pT1Desc->pSampleRate[0].bSampleFreqByte3;
            MaxSampleRate = pT1Desc->pSampleRate[1].bSampleFreqByte1 +
                     256L * pT1Desc->pSampleRate[1].bSampleFreqByte2 +
                   65536L * pT1Desc->pSampleRate[1].bSampleFreqByte3;
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MinSampleRate       0x%6.6x\n",MinSampleRate));
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MaxSampleRate       0x%6.6x\n",MaxSampleRate));
        }
        else {
            for ( i=0; i<(ULONG)pT1Desc->bSampleFreqType; i++ ) {
                MaxSampleRate = pT1Desc->pSampleRate[i].bSampleFreqByte1 +
                         256L * pT1Desc->pSampleRate[i].bSampleFreqByte2 +
                       65536L * pT1Desc->pSampleRate[i].bSampleFreqByte3;
                _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE SampleRate[%x]       0x%6.6x\n",i,MaxSampleRate));
            }
        }
    }
    else if (pDescriptor->bFormatType == 2) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wMaxBitRate:        0x%4.4x\n",pT2Desc->wMaxBitRate));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wSamplesPerFrame:   0x%4.4x\n",pT2Desc->wSamplesPerFrame));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSampleFreqType:    0x%2.2x\n",pT2Desc->bSampleFreqType));
    if (pT2Desc->bSampleFreqType == 0) { // Continuous Range
            MinSampleRate = pT2Desc->pSampleRate[0].bSampleFreqByte1 +
                     256L * pT2Desc->pSampleRate[0].bSampleFreqByte2 +
                   65536L * pT2Desc->pSampleRate[0].bSampleFreqByte3;
            MaxSampleRate = pT2Desc->pSampleRate[1].bSampleFreqByte1 +
                     256L * pT2Desc->pSampleRate[1].bSampleFreqByte2 +
                   65536L * pT2Desc->pSampleRate[1].bSampleFreqByte3;
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MinSampleRate        0x%6.6x\n",MinSampleRate));
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MaxSampleRate        0x%6.6x\n",MaxSampleRate));
        }
        else {
            for ( i=0; i<(ULONG)pT2Desc->bSampleFreqType; i++ ) {
                MaxSampleRate = pT2Desc->pSampleRate[i].bSampleFreqByte1 +
                         256L * pT2Desc->pSampleRate[i].bSampleFreqByte2 +
                       65536L * pT2Desc->pSampleRate[i].bSampleFreqByte3;
                _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE SampleRate[%x]      0x%6.6x\n",i,MaxSampleRate));
            }
        }
    }
}

VOID
DumpMIDISubclassSpecificGeneralDescriptor(PMIDISTREAMING_GENERAL_STREAM pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS GENERAL STREAM DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdAudioSpec:       0x%4.4x\n",pDescriptor->bcdAudioSpec));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:        0x%4.4x\n",pDescriptor->wTotalLength));
}

VOID
DumpMIDISubclassSpecificMIDIOutJackDescriptor(PMIDISTREAMING_MIDIOUT_JACK pDescriptor)
{
    ULONG i;
    PMIDISTREAMING_SOURCECONNECTIONS pConnections;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS MIDI OUT JACK DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackType:          0x%2.2x",pDescriptor->bJackType));
    if (pDescriptor->bJackType == JACK_TYPE_EMBEDDED) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Embedded)\n"));
    } else if (pDescriptor->bJackType == JACK_TYPE_EXTERNAL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (External)\n"));
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackID:            0x%2.2x\n",pDescriptor->bJackID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInputPins:       0x%2.2x\n",pDescriptor->bNrInputPins));
    for (i=0;i<pDescriptor->bNrInputPins; i++) {
        pConnections = &pDescriptor->baSourceConnections[i];

        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourceID[%d]:        0x%2.2x\n",i,pConnections->SourceID));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourcePin[%d]:       0x%2.2x\n",i,pConnections->SourcePin));
    }

}

VOID
DumpMIDISubclassSpecificMIDIInJackDescriptor(PMIDISTREAMING_MIDIIN_JACK pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS MIDI IN JACK DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackType:          0x%2.2x",pDescriptor->bJackType));
    if (pDescriptor->bJackType == JACK_TYPE_EMBEDDED) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Embedded)\n"));
    } else if (pDescriptor->bJackType == JACK_TYPE_EXTERNAL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (External)\n"));
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackID:            0x%2.2x\n",pDescriptor->bJackID));
}

VOID
DumpMIDISubclassSpecificElementDescriptor(PMIDISTREAMING_ELEMENT pDescriptor)
{
    ULONG i;
    PMIDISTREAMING_SOURCECONNECTIONS pConnections;
    PMIDISTREAMING_ELEMENT2 pElementDescriptor2;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS ELEMENT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bElementID:         0x%2.2x\n",pDescriptor->bElementID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInputPins:       0x%2.2x\n",pDescriptor->bNrInputPins));
    for ( i=0;i<pDescriptor->bNrInputPins; i++ ) {
        pConnections = &pDescriptor->baSourceConnections[i];

        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourceID[%d]:       0x%2.2x\n",i,pConnections->SourceID));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourcePin[%d]:      0x%2.2x\n",i,pConnections->SourcePin));
    }

    pElementDescriptor2 = (PMIDISTREAMING_ELEMENT2)&pDescriptor->baSourceConnections[i];
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrOutputPins:      0x%2.2x\n",pElementDescriptor2->bNrOutputPins));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInTerminalLink:    0x%2.2x\n",pElementDescriptor2->bInTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bOutTerminalLink:   0x%2.2x\n",pElementDescriptor2->bOutTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bElCapsSize:        0x%2.2x\n",pElementDescriptor2->bElCapsSize));
    for ( i=0; i<pElementDescriptor2->bElCapsSize; i++ )
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmElementCaps[%d]:  0x%2.2x\n",i,pElementDescriptor2->bmElementCaps[i]));
}

VOID
DumpClassSpecInterfaceDescriptor( PVOID pDescriptor, ULONG SubClassFlag)
{
    ULONG ulDescriptorSubtype = (ULONG)((PUCHAR)pDescriptor)[2];

    switch (SubClassFlag) {
        case AUDIO_SUBCLASS_CONTROL:
            switch(ulDescriptorSubtype) {
                case HEADER_UNIT:
                    DumpHeaderUnit( (PAUDIO_HEADER_UNIT)pDescriptor );
                    break;
                case INPUT_TERMINAL:
                    DumpInputTerminal( (PAUDIO_INPUT_TERMINAL)pDescriptor );
                    break;
                case OUTPUT_TERMINAL:
                    DumpOutputTerminal( (PAUDIO_OUTPUT_TERMINAL)pDescriptor );
                    break;
                case MIXER_UNIT:
                    DumpMixerUnit((PAUDIO_MIXER_UNIT)pDescriptor);
                    break;
                case SELECTOR_UNIT:
                    DumpSelectorUnit((PAUDIO_SELECTOR_UNIT)pDescriptor);
                    break;
                case FEATURE_UNIT:
                    DumpFeatureUnit((PAUDIO_FEATURE_UNIT)pDescriptor);
                    break;
                case PROCESSING_UNIT:
                    DumpProcessUnit((PAUDIO_PROCESSING_UNIT)pDescriptor);
                    break;
                case EXTENSION_UNIT:
                    DumpExtensionUnit((PAUDIO_EXTENSION_UNIT)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_STREAMING:
            switch(ulDescriptorSubtype) {
                case AS_GENERAL:
                    DumpAudioSubclassSpecificGeneralDescriptor((PAUDIO_GENERAL_STREAM)pDescriptor);
                    break;
                case FORMAT_TYPE:
                    DumpAudioSubclassSpecificFormatTypeDescriptor((PAUDIO_CLASS_STREAM)pDescriptor);
                    break;
                case FORMAT_SPECIFIC:
                    DumpGenericDescriptor( pDescriptor );
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_MIDISTREAMING:
            switch(ulDescriptorSubtype) {
                case MS_HEADER:
                    DumpMIDISubclassSpecificGeneralDescriptor((PMIDISTREAMING_GENERAL_STREAM)pDescriptor);
                    break;
                case MIDI_IN_JACK:
                    DumpMIDISubclassSpecificMIDIInJackDescriptor((PMIDISTREAMING_MIDIIN_JACK)pDescriptor);
                    break;
                case MIDI_OUT_JACK:
                    DumpMIDISubclassSpecificMIDIOutJackDescriptor((PMIDISTREAMING_MIDIOUT_JACK)pDescriptor);
                    break;
                case MIDI_ELEMENT:
                    DumpMIDISubclassSpecificElementDescriptor((PMIDISTREAMING_ELEMENT)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        default:
            DumpGenericDescriptor( pDescriptor );
            break;
    }
}

VOID
DumpAllDescriptors(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    )
{
    ULONG ulFlag = SUBCLASS_UNDEFINED;
    PUCHAR pDescriptor = (PUCHAR)pConfigurationDescriptor;

    if ( pConfigurationDescriptor->bDescriptorType != USB_CONFIGURATION_DESCRIPTOR_TYPE )
        return;

    while ( pDescriptor < ((PUCHAR)pConfigurationDescriptor +
                                   pConfigurationDescriptor->wTotalLength) ) {
        switch ( ((PUCHAR)pDescriptor)[1] ) {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                DumpConfigDescriptor( (PUSB_CONFIGURATION_DESCRIPTOR)pDescriptor );
                break;
            case USB_INTERFACE_DESCRIPTOR_TYPE:
                DumpInterfaceDescriptor( (PUSB_INTERFACE_DESCRIPTOR)pDescriptor );
                ulFlag = ((PUSB_INTERFACE_DESCRIPTOR)pDescriptor)->bInterfaceSubClass;
                break;
            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                DumpEndpointDescriptor( (PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pDescriptor );
                break;
            case USB_INTERFACE_DESCRIPTOR_TYPE | USB_CLASS_AUDIO:
                DumpClassSpecInterfaceDescriptor( pDescriptor, ulFlag );
                break;
            case USB_ENDPOINT_DESCRIPTOR_TYPE  | USB_CLASS_AUDIO:
                DumpClassSpecificEndpointDescriptor( pDescriptor, ulFlag );
                break;
            case USB_STRING_DESCRIPTOR_TYPE:
            default:
                DumpGenericDescriptor( pDescriptor );
                break;
        }
        pDescriptor += pDescriptor[0];
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\filter.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filter.c
//
//--------------------------------------------------------------------------

#include "common.h"

NTSTATUS
USBAudioFilterCreate(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp
    )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSDEVICE pKsDevice;
    PFILTER_CONTEXT pFilterContext;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    if ( !pKsFilterFactory ) {
        return STATUS_INVALID_PARAMETER;
    }

    pKsDevice = KsFilterFactoryGetParentDevice( pKsFilterFactory );
    if ( !pKsDevice ) {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate the Filter Context
    pFilterContext = pKsFilter->Context = AllocMem(NonPagedPool, sizeof(FILTER_CONTEXT));
    if ( !pFilterContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( pFilterContext, sizeof(FILTER_CONTEXT) );

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsFilter->Bag, pFilterContext, FreeMem);

    // Get the hardware device extension and save it in the filter context.
    pFilterContext->pHwDevExt = pKsDevice->Context;
    pFilterContext->pNextDeviceObject = pKsDevice->NextDeviceObject;

    return STATUS_SUCCESS;
}

const
KSFILTER_DISPATCH
USBAudioFilterDispatch =
{
    USBAudioFilterCreate,
    NULL, // Close
    NULL, // Process
    NULL // Reset
};

NTSTATUS
USBAudioSyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] enter\n"));

    //
    // Allocate an Urb .
    //

    urb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] failed to alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     Index,
                                     LangId,
                                     Buffer,
                                     NULL,
                                     BufferLength,
                                     NULL);

        ntStatus = SubmitUrbToUsbdSynch(DevicePDO, urb);

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength > BufferLength) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] Invalid length returned, possible buffer overrun\n"));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus) && BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength != Buffer->bLength &&
            ExpectHeader) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] Bogus Descriptor from devce xfer buf %d descriptor %d\n",
                urb->UrbControlDescriptorRequest.TransferBufferLength,
                Buffer->bLength));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] GetDeviceDescriptor, string descriptor = %x\n",
                Buffer));

        FreeMem(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
USBAudioCheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    )
 /* ++
  *
  * Description:
  *
  * queries the device for a supported language id -- if the device supports
  * the language then the index for this language is returned .
  *
  * DevicePDO - device object to call with urb request
  *
  * LanguageId -
  *
  * Return:
  *
  * success if a particular language is is supported by a device
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PUSHORT supportedLangId;
    ULONG numLangIds, i;
    ULONG length;

    PAGED_CODE();

    usbString = AllocMem(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {
        //
        // first get the array of supported languages
        //
        ntStatus = USBAudioSyncGetStringDescriptor(DevicePDO,
                                                   0, //index 0
                                                   0, //langid 0
                                                   usbString,
                                                   MAXIMUM_USB_STRING_LENGTH,
                                                   &length,
                                                   TRUE);

        //
        // now check for the requested language in the array of supported
        // languages
        //

        //
        // NOTE: this seems a bit much -- we should be able to just ask for
        // the string with a given language id and expect it to fail but since
        // the array of supported languages is part of the USB spec we may as
        // well check it.
        //

        if (NT_SUCCESS(ntStatus)) {

            // subtract size of header
            numLangIds = (length - 2)/2;
            supportedLangId = (PUSHORT) &usbString->bString;

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioCheckDeviceLanguage] NumLangIds = %d\n", numLangIds));

            ntStatus = STATUS_NOT_SUPPORTED;
            for (i=0; i<numLangIds; i++) {
                if (*supportedLangId == LanguageId) {

                    ntStatus = STATUS_SUCCESS;
                    break;
                }
                supportedLangId++;
            }
        }

        FreeMem(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioCheckDeviceLanguage]Language %x -- not supported by this device = %x\n", LanguageId));
    }

    return ntStatus;

}

NTSTATUS
USBAudioGetStringFromDevice(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *StringBuffer,
    IN OUT PUSHORT StringBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    )
 /* ++
  *
  * Description:
  *
  * queries the device for the string then allocates a buffer just big enough to hold it.
  *
  * *SerialNumberBuffer is null if an error occurs, otherwise it is filled in
  *  with a pointer to the NULL terminated UNICODE serial number for the device
  *
  * DeviceObject - deviceobject to call with urb request
  *
  * LanguageId - 16 bit language id
  *
  * StringIndex - USB string Index to fetch
  *
  * Return:
  *
  * NTSTATUS code
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PVOID tmp;

    PAGED_CODE();

    *StringBuffer = NULL;
    *StringBufferLength = 0;

    usbString = AllocMem(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {

        ntStatus = USBAudioCheckDeviceLanguage(DevicePDO, LanguageId);

        if (NT_SUCCESS(ntStatus)) {
            //
            // this device supports our language,
            // go ahead and try to get the serial number
            //

            ntStatus = USBAudioSyncGetStringDescriptor(DevicePDO,
                                                       StringIndex, //index
                                                       LanguageId, //langid
                                                       usbString,
                                                       MAXIMUM_USB_STRING_LENGTH,
                                                       NULL,
                                                       TRUE);

            if (NT_SUCCESS(ntStatus)) {

                //
                // device returned a string!!!
                //

                _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioGetStringFromDevice] Device returned string = %x\n", usbString));

                //
                // allocate a buffer and copy the string to it
                //
                // NOTE: must use stock alloc function because
                // PnP frees this string.

                tmp = AllocMem(PagedPool, usbString->bLength);
                if (tmp) {
                    RtlZeroMemory(tmp, usbString->bLength);
                    RtlCopyMemory(tmp,
                                  &usbString->bString,
                                  usbString->bLength-2);
                    *StringBuffer = tmp;
                    *StringBufferLength = usbString->bLength;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        FreeMem(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
USBAudioRegSetValue(
    IN HANDLE hKey,
    IN PCWSTR szValueName,
    IN ULONG  Type,
    IN PVOID  pData,
    IN ULONG  cbData
)
{
    UNICODE_STRING ustr;

    RtlInitUnicodeString( &ustr, szValueName );

    return ZwSetValueKey( hKey,
                          &ustr,
                          0,
                          Type,
                          pData,
                          cbData );
}

NTSTATUS
USBAudioRegGetValue(
    IN HANDLE hKey,
    IN PCWSTR szValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, szValueName);
    Status = ZwQueryValueKey(
      hKey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION)AllocMem(PagedPool, cbValue);
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = ZwQueryValueKey(
      hKey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);

    if(!NT_SUCCESS(Status)) {
        FreeMem( *ppkvfi );
        *ppkvfi = NULL;
        goto exit;
    }
exit:
    return(Status);
}

VOID
USBAudioRegCloseKey( IN HANDLE hKey )
{
    ZwClose( hKey );
}

NTSTATUS
USBAudioRegCreateMediaCategoriesKey(
    IN PUNICODE_STRING puKeyName,
    OUT PHANDLE phKey
)
{
    HANDLE            hMediaCategoriesKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustr;
    ULONG             Disposition;
    NTSTATUS          ntStatus;

    // Open a key for the MediaCategories branch of the registry
    RtlInitUnicodeString( &ustr, MediaCategories );
    InitializeObjectAttributes( &ObjectAttributes,
                                &ustr,
                                OBJ_CASE_INSENSITIVE, // Attributes
                                NULL,
                                NULL );               // Security

    ntStatus = ZwOpenKey( &hMediaCategoriesKey,
                          KEY_ALL_ACCESS,
                          &ObjectAttributes );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Now create a key for szKeyName
    InitializeObjectAttributes( &ObjectAttributes,
                                puKeyName,
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hMediaCategoriesKey,
                                NULL );               // Security

    ntStatus = ZwCreateKey( phKey,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes,
                            0,                  // TitleIndex
                            NULL,               // Class
                            REG_OPTION_NON_VOLATILE,
                            &Disposition);

    ZwClose( hMediaCategoriesKey );

    return ntStatus;
}

NTSTATUS
USBAudioInitProductNameKey(
    IN PKSDEVICE pKsDevice,
    IN GUID *ProductNameGuid
)
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor = pHwDevExt->pDeviceDescriptor;
    UNICODE_STRING ProductNameGuidString;
    PWCHAR StringBuffer = NULL;
    USHORT StringBufferLength;
    HANDLE hProductNameKey = NULL;
    NTSTATUS ntStatus;

    ASSERT(pDeviceDescriptor);

    //  Guid to SZ
    ntStatus = RtlStringFromGUID( ProductNameGuid, &ProductNameGuidString );
    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Create unicode string from GUID\n"));
        return ntStatus;
    }

    //  Get the string from the device
    ntStatus = USBAudioGetStringFromDevice(pKsDevice->NextDeviceObject,
                                           &StringBuffer,
                                           &StringBufferLength,
                                           0x0409, // good'ol american english
                                           pDeviceDescriptor->iProduct);
    if (NT_SUCCESS(ntStatus) && (StringBuffer != NULL)) {

        //  Create the Product Name key in the registry under MediaCategories
        ntStatus = USBAudioRegCreateMediaCategoriesKey( &ProductNameGuidString,
                                                        &hProductNameKey );
        if (NT_SUCCESS(ntStatus)) {

            //  Place the Product string into the registry
            ntStatus = USBAudioRegSetValue( hProductNameKey,
                                            NodeNameValue,
                                            REG_SZ,
                                            StringBuffer,
                                            StringBufferLength);  // size in bytes
        }
        else {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Failed to create registry key\n"));
        }
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Device failed to give a product string\n"));
    }

    // Cleanup after ourselves
    RtlFreeUnicodeString( &ProductNameGuidString );

    if (hProductNameKey) {
        USBAudioRegCloseKey( hProductNameKey );
    }

    if (StringBuffer) {
        FreeMem( StringBuffer );
    }

    return ntStatus;
}

BOOL
IsValidProductStringDescriptor(
    IN PKSDEVICE pKsDevice,
    IN PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor
)
{
    HANDLE hRootHandle;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    NTSTATUS ntStatus;

    if (pDeviceDescriptor->iProduct == 0) {
        return FALSE;
    }

    // Read the registry to figure out if we are supposed to ignore the HW string
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->PhysicalDeviceObject,
        PLUGPLAY_REGKEY_DRIVER,
        KEY_ALL_ACCESS,
        &hRootHandle );

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBAudioRegGetValue( hRootHandle, L"IgnoreHwString", &pkvfi );
        if ( NT_SUCCESS(ntStatus) ) {
            if( pkvfi->Type == REG_DWORD ) {
                if (1 == *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset)) ) {
                    ntStatus = STATUS_SUCCESS;
                }
            }
            else {
                ntStatus = STATUS_INVALID_PARAMETER;
            }
            FreeMem( pkvfi );
        }

        ZwClose(hRootHandle);

        //  STATUS_SUCCESS means that we found the ignore hw string key and it was set to 1
        if (NT_SUCCESS(ntStatus)) {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("Ignoring the string descriptor!\n"));
            return FALSE;
        }
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("IoOpenDeviceRegistryKey Failed!\n"));
    }

    return TRUE;
}

NTSTATUS
USBAudioInitComponentId(
    IN PKSDEVICE pKsDevice,
    IN OUT PKSCOMPONENTID ComponentId
)
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor = pHwDevExt->pDeviceDescriptor;
    NTSTATUS ntStatus;

    ASSERT(pDeviceDescriptor);
    ASSERT(pUSBAudioFilterDescriptor);

    INIT_USBAUDIO_MID( &ComponentId->Manufacturer, pDeviceDescriptor->idVendor);
    INIT_USBAUDIO_PID( &ComponentId->Product, pDeviceDescriptor->idProduct);
    ComponentId->Component = KSCOMPONENTID_USBAUDIO;

    //  Check to make sure that string descriptor index is valid
    if (!IsValidProductStringDescriptor(pKsDevice, pDeviceDescriptor)) {
        ComponentId->Name = GUID_NULL;
    }
    else {
        // Create a GUID for the product string and place the string gathered from the device
        // into the registry if it exists
        INIT_USBAUDIO_PRODUCT_NAME( &ComponentId->Name,
                                    pDeviceDescriptor->idVendor,
                                    pDeviceDescriptor->idProduct,
                                    pDeviceDescriptor->iProduct);

        ntStatus = USBAudioInitProductNameKey( pKsDevice, &ComponentId->Name );
        if (!NT_SUCCESS(ntStatus)) {
            ComponentId->Name = GUID_NULL;
        }
    }

    ComponentId->Version = (ULONG)(pDeviceDescriptor->bcdDevice >> 8);
    ComponentId->Revision = (ULONG)pDeviceDescriptor->bcdDevice & 0xFF;

    return STATUS_SUCCESS;
}

NTSTATUS
USBAudioCreateFilterContext( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PKSCOMPONENTID pKsComponentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
#define FILTER_PROPS
#ifdef FILTER_PROPS
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSPROPERTY_ITEM pDevPropItems;
    PKSPROPERTY_SET pDevPropSet;
    ULONG ulNumPropItems;
    ULONG ulNumPropSets;
#endif

    PAGED_CODE();

    //TRAP;

    RtlZeroMemory( pUSBAudioFilterDescriptor, sizeof(KSFILTER_DESCRIPTOR) );

    // Fill in static values of USBAudioFilterDescriptor
    pUSBAudioFilterDescriptor->Dispatch      = &USBAudioFilterDispatch;
    pUSBAudioFilterDescriptor->ReferenceGuid = &KSNAME_Filter;
    pUSBAudioFilterDescriptor->Version       = KSFILTER_DESCRIPTOR_VERSION;
    pUSBAudioFilterDescriptor->Flags         = 0;

    pKsComponentId = AllocMem(NonPagedPool, sizeof(KSCOMPONENTID) );
    if (!pKsComponentId) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the KSCOMPONENTID for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsComponentId, FreeMem);
    RtlZeroMemory(pKsComponentId, sizeof(KSCOMPONENTID));

    // Fill in the allocated KSCOMPONENTID with values obtained from the device descriptors
    ntStatus = USBAudioInitComponentId ( pKsDevice, pKsComponentId );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    pUSBAudioFilterDescriptor->ComponentId = pKsComponentId;


    // Build the descriptors for the device pins
    ntStatus = USBAudioPinBuildDescriptors( pKsDevice,
                                            (PKSPIN_DESCRIPTOR_EX *)&pUSBAudioFilterDescriptor->PinDescriptors,
                                            &pUSBAudioFilterDescriptor->PinDescriptorsCount,
                                            &pUSBAudioFilterDescriptor->PinDescriptorSize );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Topology for the device filter
    ntStatus = BuildUSBAudioFilterTopology( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

#ifdef FILTER_PROPS // if there are properties that need supported on the filter, use this code
    // Build the Filter Property Sets
    BuildFilterPropertySet( pUSBAudioFilterDescriptor,
                            NULL,
                            NULL,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsAutomationTable = AllocMem(NonPagedPool, sizeof(KSAUTOMATION_TABLE) +
                                                (ulNumPropItems * sizeof(KSPROPERTY_ITEM)) +
                                                (ulNumPropSets  * sizeof(KSPROPERTY_SET)));

    if (!pKsAutomationTable ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsAutomationTable, FreeMem);

    RtlZeroMemory(pKsAutomationTable, sizeof(KSAUTOMATION_TABLE));

    pDevPropItems = (PKSPROPERTY_ITEM)(pKsAutomationTable + 1);
    pDevPropSet   = (PKSPROPERTY_SET)(pDevPropItems + ulNumPropItems);

    BuildFilterPropertySet( pUSBAudioFilterDescriptor,
                            pDevPropItems,
                            pDevPropSet,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pUSBAudioFilterDescriptor->AutomationTable = (const KSAUTOMATION_TABLE *)pKsAutomationTable;
    pKsAutomationTable->PropertySetsCount = ulNumPropSets;
    pKsAutomationTable->PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
    pKsAutomationTable->PropertySets      = (const KSPROPERTY_SET *)pDevPropSet;

    DbgLog("CreFilF", pUSBAudioFilterDescriptor, pDevPropSet, pDevPropItems, pKsDevice);
#else
    pUSBAudioFilterDescriptor->AutomationTable = NULL;

    DbgLog("CreFilF", pUSBAudioFilterDescriptor, pKsDevice, 0, 0);
#endif


    // Create the Filter for the device
    ntStatus = KsCreateFilterFactory( pKsDevice->FunctionalDeviceObject,
                                      pUSBAudioFilterDescriptor,
                                      L"GLOBAL",
                                      NULL,
                                      KSCREATE_ITEM_FREEONSTOP,
                                      NULL,
                                      NULL,
                                      NULL );

    if (!NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\device.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       device.c
//
//--------------------------------------------------------------------------

#include <initguid.h>
#include "common.h"
#include "perf.h"

NTSTATUS
USBAudioAddDevice(
    IN PKSDEVICE Device
)
{
    //DbgPrint("USB Audio in the house.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[CreateDevice]\n"));

    PAGED_CODE();

    ASSERT(Device);

    return STATUS_SUCCESS;
}

NTSTATUS
USBAudioPnpStart(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpStart]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);


#if DBG && DBGMEMMAP
    InitializeMemoryList();
#endif

    // Initialize Debug log

    DbgLogInit();
    DbgLog("TEST",1,2,3,4);

    //
    // Since we can get more than one PnpStart call without having a matching
    // PnpClose call, we need to make sure that we don't reinitialize our
    // context information for this pKsDevice.
    //
    if (!pKsDevice->Started) {
        // Allocate space for the Device Context
        pKsDevice->Context = AllocMem( NonPagedPool, sizeof(HW_DEVICE_EXTENSION));
        if (!pKsDevice->Context) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory(pKsDevice->Context, sizeof(HW_DEVICE_EXTENSION));

        // Bag the context for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pKsDevice->Context, FreeMem);

        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->pNextDeviceObject = pKsDevice->NextDeviceObject;

        ntStatus = StartUSBAudioDevice( pKsDevice );
        if (NT_SUCCESS(ntStatus)) {
            ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = FALSE;
            ntStatus = USBAudioCreateFilterContext( pKsDevice );
        }

        // Get the bus interface on USB
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBAudioGetUsbBusInterface( pKsDevice );
        }

        // Initialize perf logging.
        PerfRegisterProvider(pKsDevice->PhysicalDeviceObject);

        //
        // Individual MIDI pins (=device) are exposed for every MIDI jack.  Multiple jacks are
        // addressed via a single endpoint using the Code Index Number.  In order to arbitrate for
        // all of these pins on the same endpoint, the context needs to be stored at the KsDevice
        // level.
        //
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulInterfaceNumberSelected = MAX_ULONG;
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->pMIDIPipeInfo = NULL;
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->Pipes = NULL;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PnpStart] ignoring second start\n"));
    }

    return ntStatus;
}

NTSTATUS
USBAudioPnpQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
USBAudioPnpCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpCancelStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
USBAudioPnpStop(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpStop]\n"));

    PAGED_CODE();

    DbgLogUninit();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // Set a flag that the device needs to be stopped.
    StopUSBAudioDevice( pKsDevice );
    ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = TRUE;

    PerfUnregisterProvider(pKsDevice->PhysicalDeviceObject);
}

NTSTATUS
USBAudioPnpQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
USBAudioPnpCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpCancelRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
USBAudioPnpRemove(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    //DbgPrint("USB Audio leaving the house.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpRemove]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    if (!((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped) {

        // Probable surprise removal during device start
        StopUSBAudioDevice( pKsDevice );
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = TRUE;

        PerfUnregisterProvider(pKsDevice->PhysicalDeviceObject);
    }
    // In Win9x, if this occurs before a Stop on a pin then there has been a Surprise Removal.
}

NTSTATUS
USBAudioPnpQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES pCapabilities
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryCapabilities]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    pCapabilities->Size              = sizeof(DEVICE_CAPABILITIES);
    pCapabilities->Version           = 1;  // the version documented here is version 1
    pCapabilities->LockSupported     = FALSE;
    pCapabilities->EjectSupported    = FALSE; // Ejectable in S0
    pCapabilities->Removable         = TRUE;
    pCapabilities->DockDevice        = FALSE;
    pCapabilities->UniqueID          = FALSE;
    pCapabilities->SilentInstall     = TRUE;
    pCapabilities->RawDeviceOK       = FALSE;
    pCapabilities->SurpriseRemovalOK = TRUE;
    pCapabilities->HardwareDisabled  = FALSE;

    pCapabilities->DeviceWake        = PowerDeviceUnspecified;
    pCapabilities->D1Latency         = 0;
    pCapabilities->D2Latency         = 0;
    pCapabilities->D3Latency         = 20000; // 2 Seconds (in 100 usec units)

    return STATUS_SUCCESS;
}

void
USBAudioSurpriseRemoval(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    //DbgPrint("USB Audio leaving the house by surprise.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[SurpriseRemoval]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // For any currently streaming pin on any open filter of the device,
    // clean up and quit it.
}

NTSTATUS
USBAudioQueryPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioQueryPower] SysFrom: %d SysTo: %d DevFrom: %d DevTo: %d\n",
                               SystemFrom, SystemTo, DeviceFrom, DeviceTo));
    return STATUS_SUCCESS;
}

void
USBAudioSetPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    ULONG i;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioSetPower] From: %d To: %d\n",
                                From, To ));

    // First restore device settings from cached values
    if (To == PowerDeviceD0) {
        RestoreCachedSettings(pKsDevice);
    }

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            // Find each open pin for this open filter
            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                while (pKsPin) {

                    pPinContext = pKsPin->Context;
                    if ( (pPinContext->PinType == WaveOut) ||
                         (pPinContext->PinType == WaveIn) )  {
                        switch(To) {
                            case PowerDeviceD0:

                                // For the open Pin open the gate and restart data pump.
                                USBAudioPinReturnFromStandby( pKsPin );
                                break;

                            case PowerDeviceD1:
                            case PowerDeviceD2:
                            case PowerDeviceD3:

                                // For the open Pin close the gate and wait til all activity stops.
                                USBAudioPinGoToStandby( pKsPin );
                                break;
                        }
                    }

                    // Get the next pin
                    pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    _DbgPrintF(DEBUGLVL_TERSE,("exit [USBAudioSetPower] From: %d To: %d\n",
                                From, To ));
}

NTSTATUS
USBAudioDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
USBAudioGetUsbBusInterface(
    IN PKSDEVICE pKsDevice
    )
/*++

Routine Description:

    Query the stack for the 'USBDI' bus interface

Arguments:

Return Value:


--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP Irp;
    NTSTATUS ntStatus;
    KEVENT event;
    PHW_DEVICE_EXTENSION pHwDevExt;

    pHwDevExt = pKsDevice->Context;

    Irp = IoAllocateIrp(
        pKsDevice->NextDeviceObject->StackSize, FALSE);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pHwDevExt->pBusIf = AllocMem(NonPagedPool, sizeof(USB_BUS_INTERFACE_USBDI_V0));
    if (!pHwDevExt->pBusIf) {
        IoFreeIrp(Irp);
        return STATUS_UNSUCCESSFUL;
    }

    // Bag the bus interface for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pBusIf, FreeMem);

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           USBAudioDeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) pHwDevExt->pBusIf;
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*pHwDevExt->pBusIf);
    nextStack->Parameters.QueryInterface.Version =
       USB_BUSIF_USBDI_VERSION_0;

    ntStatus = IoCallDriver(pKsDevice->NextDeviceObject,
                            Irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface
        ASSERT(pHwDevExt->pBusIf->Version == USB_BUSIF_USBDI_VERSION_0);
        ASSERT(pHwDevExt->pBusIf->Size == sizeof(*pHwDevExt->pBusIf));
    }
    else {
        pHwDevExt->pBusIf = NULL;
        _DbgPrintF( DEBUGLVL_TERSE,("[USBAudioGetUsbBusInterface] Failed to get bus interface: %x\n", ntStatus));
        DbgLog("GetBIEr", ntStatus, 0, 0, 0);
    }

    IoFreeIrp(Irp);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\hardware.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       hardware.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define ONKYO_HACK

#ifdef ONKYO_HACK
#define ONKYO_VID 0x08BB
#define ONKYO_PID 0x2702
#endif

#if DBG
//#define DUMPDESC
#endif

NTSTATUS
USBAudioCancelCompleteSynch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pKevent
    )
{
    ASSERT(pKevent);
    KeSetEvent(pKevent, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SubmitUrbToUsbdSynch(PDEVICE_OBJECT pNextDeviceObject, PURB pUrb)
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP pIrp;
    KEVENT Kevent;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    // issue a synchronous request
    KeInitializeEvent(&Kevent, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                pNextDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &Kevent,
                &ioStatus);

    if ( !pIrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoSetCompletionRoutine(
        pIrp,
        USBAudioCancelCompleteSynch,
        &Kevent,
        TRUE,
        TRUE,
        TRUE
        );

    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    // pass the URB to the USB driver stack
    nextStack->Parameters.Others.Argument1 = pUrb;

    ntStatus = IoCallDriver(pNextDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {
        // Irp is pending. we have to wait till completion..
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        status = KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, &timeout);
        if (status == STATUS_TIMEOUT) {
            //
            // We got it to the IRP before it was completed. We can cancel
            // the IRP without fear of losing it, as the completion routine
            // won't let go of the IRP until we say so.
            //
            IoCancelIrp(pIrp);

            KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, NULL);

            // Return STATUS_TIMEOUT
            ioStatus.Status = status;
        }

    } else {
        ioStatus.Status = ntStatus;
    }

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ntStatus = ioStatus.Status;

    return ntStatus;
}

NTSTATUS
SelectDeviceConfiguration(
    PKSDEVICE pKsDevice,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_INTERFACE_DESCRIPTOR pAudioStreamingInterface;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingInterface;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PAUDIO_HEADER_UNIT pHeader;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    ULONG i, j = 0;
    PURB pUrb;

    // Allocate an interface list.
    pHwDevExt->pInterfaceList = AllocMem( NonPagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                                            (pConfigurationDescriptor->bNumInterfaces + 1) );
    if (!pHwDevExt->pInterfaceList) {
        return ntStatus;
    }

    //
    //  Validate the we have a legal ADC device by verifing if an Audio Streaming
    //  interface exists so must at least one Control interface
    //
    pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                  pConfigurationDescriptor,
                                  (PVOID) pConfigurationDescriptor,
                                  -1,        // interface number
                                  -1,        //  (Alternate Setting)
                                  USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                  AUDIO_SUBCLASS_STREAMING,        // Stream subclass (Interface Sub-Class)
                                  -1 ) ;    // protocol don't care    (InterfaceProtocol)

    if ( pAudioStreamingInterface ) {
        // Get the first control interface
        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               (PVOID) pConfigurationDescriptor,
                               -1,        // interface number
                               -1,        //  (Alternate Setting)
                               USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                               AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                               -1 );

        if (!pControlInterface) {
            // Give up because this is an invalid ADC device
            FreeMem(pHwDevExt->pInterfaceList);
            return STATUS_INVALID_PARAMETER;
        }
    }

    // Get the first Audio interface
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                pConfigurationDescriptor,
                                -1,        // interface number
                                -1,        //  (Alternate Setting)
                                USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                -1,        // any subclass (Interface Sub-Class)
                                -1 );
    // Nothing to see here, move on
    if ( !pAudioInterface ) {
        FreeMem(pHwDevExt->pInterfaceList);
        return STATUS_INVALID_PARAMETER;
    }

    // Loop through the audio device class interfaces
    while (pAudioInterface) {

        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_MIDISTREAMING:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found MIDIStreaming at %x\n",pAudioInterface));
                pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioInterface;
                break;
            case AUDIO_SUBCLASS_STREAMING:
                // This subclass is handled with the control class since they have to come together
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found AudioStreaming at %x\n",pAudioInterface));
                break;
            case AUDIO_SUBCLASS_CONTROL:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found AudioControl at %x\n",pAudioInterface));
                pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioInterface;

                pHeader = (PAUDIO_HEADER_UNIT)
                         GetAudioSpecificInterface( pConfigurationDescriptor,
                                                    pAudioInterface,
                                                    HEADER_UNIT );
                if ( !pHeader ) {
                    FreeMem(pHwDevExt->pInterfaceList);
                    return STATUS_INVALID_PARAMETER;
                }

                // Find each interface associated with this header
                for ( i=0; i<pHeader->bInCollection; i++ ) {
                    pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                (PVOID)pConfigurationDescriptor,
                                (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                -1,                               // Alternate Setting
                                USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                AUDIO_SUBCLASS_STREAMING,         // Audio Streaming (Interface Sub-Class)
                                -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                    if ( pAudioStreamingInterface ) {
                        pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioStreamingInterface;
                    } else {
                        // If there is no audio streaming interface, make sure that there is at least a MIDI interface
                        pMIDIStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                    pConfigurationDescriptor,
                                    (PVOID)pConfigurationDescriptor,
                                    (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                    -1,                               // Alternate Setting
                                    USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                    AUDIO_SUBCLASS_MIDISTREAMING,     // Audio Streaming (Interface Sub-Class)
                                    -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                        if ( !pMIDIStreamingInterface ) {
                            FreeMem(pHwDevExt->pInterfaceList);
                            return STATUS_INVALID_PARAMETER;
                        }
                    }
                }
                break;
            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("SelectDeviceConfiguration: Invalid SubClass %x\n  ",pAudioInterface->bInterfaceSubClass));
                break;
        }

        // pAudioInterface = GetNextAudioInterface(pConfigurationDescriptor, pAudioInterface);

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Next audio interface at %x\n",pAudioInterface));
    }

    pHwDevExt->pInterfaceList[j].InterfaceDescriptor = NULL; // Mark end of interface list

    pUrb = USBD_CreateConfigurationRequestEx( pConfigurationDescriptor,
                                              pHwDevExt->pInterfaceList ) ;
    if ( !pUrb ) {
        FreeMem(pHwDevExt->pInterfaceList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Request the configuration
    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(URB_STATUS(pUrb))) {
        FreeMem(pHwDevExt->pInterfaceList);
        ExFreePool(pUrb);
        return ntStatus;
    }

    // Save the configuration Handle to Select Interfaces later
    pHwDevExt->ConfigurationHandle = pUrb->UrbSelectConfiguration.ConfigurationHandle;

    // Bag the interface list for easy cleanup
    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pInterfaceList, FreeMem);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] NumInterfaces=%d InterfacesFound=%d\n",pConfigurationDescriptor->bNumInterfaces, j));
    ASSERT(j == pConfigurationDescriptor->bNumInterfaces);

    // Save the interfaces for this configuration as they will be deallocated with the URB
    for (i=0; i<j; i++) {
        PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
        pInterfaceInfo = pHwDevExt->pInterfaceList[i].Interface;
        pHwDevExt->pInterfaceList[i].Interface = AllocMem(NonPagedPool, pInterfaceInfo->Length);

        if (!pHwDevExt->pInterfaceList[i].Interface) {
            ExFreePool(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pInterfaceList[i].Interface, FreeMem);

        RtlCopyMemory(pHwDevExt->pInterfaceList[i].Interface, pInterfaceInfo, pInterfaceInfo->Length);
    }

    ExFreePool(pUrb);

    return STATUS_SUCCESS;
}

NTSTATUS
StartUSBAudioDevice( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    ULONG ulTotalDescriptorsSize;
    NTSTATUS ntStatus;
    PURB pUrb;

    // Allocate an urb to use
    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (!pUrb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate a device descriptor
    pDeviceDescriptor = AllocMem(NonPagedPool, sizeof(USB_DEVICE_DESCRIPTOR));
    if (!pDeviceDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Get the device descriptor for this device
    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_DEVICE_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pDeviceDescriptor,
                                  NULL,
                                  sizeof(USB_DEVICE_DESCRIPTOR),
                                  NULL );

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pDeviceDescriptor);
        FreeMem(pUrb);
        return ntStatus;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pDeviceDescriptor, FreeMem);

    // Get the Configuration Descriptor and all others
    pConfigurationDescriptor = AllocMem(NonPagedPool, sizeof(USB_CONFIGURATION_DESCRIPTOR));
    if (!pConfigurationDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Call down the first time just to get the total number of bytes for the descriptors.
    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pConfigurationDescriptor,
                                  NULL,
                                  sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                  NULL);

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pUrb);
        FreeMem(pConfigurationDescriptor);
        return ntStatus;
    }

    // Reallocate and call again to fill in all descriptors.
    ulTotalDescriptorsSize = pConfigurationDescriptor->wTotalLength;
    FreeMem(pConfigurationDescriptor);
    pConfigurationDescriptor = AllocMem(NonPagedPool, ulTotalDescriptorsSize);
    if (!pConfigurationDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pConfigurationDescriptor,
                                  NULL,
                                  ulTotalDescriptorsSize,
                                  NULL);

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pConfigurationDescriptor);
        return ntStatus;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pConfigurationDescriptor, FreeMem);

    // Free up the URB
    FreeMem(pUrb);

    ntStatus = SelectDeviceConfiguration( pKsDevice, pConfigurationDescriptor );
    if (NT_SUCCESS(ntStatus)) {
        // Save the Configuration and Device Descriptor pointers.
        pHwDevExt->pDeviceDescriptor = pDeviceDescriptor;
        pHwDevExt->pConfigurationDescriptor = pConfigurationDescriptor;

#ifdef DUMPDESC
        {
            ULONG LastLevel = USBAudioDebugLevel;

            USBAudioDebugLevel = DEBUGLVL_BLAB;
            DumpAllDesc(pConfigurationDescriptor);
            USBAudioDebugLevel = LastLevel;
        }
#endif
    }

#ifdef ONKYO_HACK
    _DbgPrintF( DEBUGLVL_TERSE, ("Vendor ID: %x, Product ID: %x\n", 
                                 pDeviceDescriptor->idVendor,
                                 pDeviceDescriptor->idProduct) );

    if (( pDeviceDescriptor->idVendor  == ONKYO_VID ) &&
        ( pDeviceDescriptor->idProduct == ONKYO_PID )) {

        *((PUCHAR)pConfigurationDescriptor + 0x36) ^= 2;
    }
#endif

    return ntStatus;

}

NTSTATUS
StopUSBAudioDevice( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    ULONG i;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    PURB pUrb;

    //
    // 1. Take care of outstanding MIDI Out Urbs
    //
    KsAcquireDevice( pKsDevice );

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                // Find each open pin for this open filter
                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                _DbgPrintF(DEBUGLVL_VERBOSE,("[StopUSBAudioDevice] Trying filter (%x), pinid (%d), pin (%x)\n",pKsFilter,i,pKsPin));

                while (pKsPin) {

                   pPinContext = pKsPin->Context;
                   if (pPinContext->PinType == MidiOut) {
                       // Found a MidiOut pin to cleanup
                       _DbgPrintF(DEBUGLVL_VERBOSE,("[StopUSBAudioDevice] Cleaning up MIDI Out pin (%x)\n",pKsPin));
                       AbortUSBPipe( pPinContext );
                   }

                   // Get the next pin
                   pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    KsReleaseDevice( pKsDevice );

    //
    // 2. Cleanup outstanding MIDI In Urbs
    //
    //  Free any currently allocated PipeInfo
    if (pHwDevExt->pMIDIPipeInfo) {
        USBMIDIInFreePipeInfo( pHwDevExt->pMIDIPipeInfo );
        pHwDevExt->pMIDIPipeInfo = NULL;
    }

    if (pHwDevExt->Pipes) {
        FreeMem(pHwDevExt->Pipes);
        pHwDevExt->Pipes = NULL;
    }

    // 3. Send a select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_SELECT_CONFIGURATION));
    if ( pUrb ) {

        UsbBuildSelectConfigurationRequest( pUrb,
                                            (USHORT)sizeof(struct _URB_SELECT_CONFIGURATION),
                                            NULL);

        ntStatus = SubmitUrbToUsbdSynch( pKsDevice->NextDeviceObject, pUrb );

        FreeMem(pUrb);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SelectStreamingAudioInterface(
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin )
{
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USHORT ulInterfaceLength;
    ULONG ulNumEndpoints, j;
    BOOLEAN fIsZeroBW = FALSE;
    ULONG size;
    PURB pUrb;

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    fIsZeroBW = IsZeroBWInterface( pHwDevExt->pConfigurationDescriptor,
                                   pInterfaceDescriptor );

    ulNumEndpoints = (ULONG)pInterfaceDescriptor->bNumEndpoints;

    // Allocate an interface request
    ulInterfaceLength = (USHORT)GET_USBD_INTERFACE_SIZE(ulNumEndpoints);

    size = GET_SELECT_INTERFACE_REQUEST_SIZE(ulNumEndpoints);

    pUrb = AllocMem(NonPagedPool, size);
    if (!pUrb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pUrb, size);

    // Find the correct interface in our list
    for (j=0; j < pHwDevExt->pConfigurationDescriptor->bNumInterfaces; j++) {
        if ( pHwDevExt->pInterfaceList[j].InterfaceDescriptor->bInterfaceNumber ==
             pInterfaceDescriptor->bInterfaceNumber )
            break;
    }

    // Didn't find a match
    if (j == pHwDevExt->pConfigurationDescriptor->bNumInterfaces) {
        FreeMem( pUrb );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Initialize the interface information
    pInterfaceInfo = &pUrb->UrbSelectInterface.Interface;
    pInterfaceInfo->InterfaceNumber  = pInterfaceDescriptor->bInterfaceNumber;
    pInterfaceInfo->Length           = ulInterfaceLength;
    pInterfaceInfo->AlternateSetting = pInterfaceDescriptor->bAlternateSetting;

    if ( !fIsZeroBW ) { // There must be a Pin if this is not 0 BW
        PPIN_CONTEXT pPinContext = pKsPin->Context;
        ULONG ulFormat = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
        if (ulFormat == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED )
            // We assume that usually nobody sends us more than 250 ms. of PCM Data per header.
            //    USBD should Adjust if it is more supossedly.
            pInterfaceInfo->Pipes[0].MaximumTransferSize = pPinContext->ulMaxPacketSize * 250;

            if (pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor == NULL) {
                pInterfaceInfo->Pipes[0].PipeFlags |= USBD_PF_MAP_ADD_TRANSFERS;
            }
        else if (ulFormat == USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED )
            pInterfaceInfo->Pipes[0].MaximumTransferSize = (1920*2)+32; // Max AC-3 Syncframe size
    }
    else if ( ulNumEndpoints )  // Zero BW but has an endpoint
        pInterfaceInfo->Pipes[0].MaximumTransferSize = 0;

    // set up the input parameters in our interface request structure.
    pUrb->UrbHeader.Length = (USHORT) size;
    pUrb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;
    pUrb->UrbSelectInterface.ConfigurationHandle = pHwDevExt->ConfigurationHandle;

    ntStatus = SubmitUrbToUsbdSynch(pHwDevExt->pNextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(pUrb->UrbSelectInterface.Hdr.Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("SelectStreamingAudioInterface: Select interface failed %x\n",ntStatus));
        FreeMem(pUrb);
        return ntStatus;
    }

    if ( !fIsZeroBW ) {
        PPIN_CONTEXT pPinContext = pKsPin->Context;

        // NOTE: We assume first pipe is data pipe!!!
        pPinContext->ulNumberOfPipes = pInterfaceInfo->NumberOfPipes;
        pPinContext->hPipeHandle = pInterfaceInfo->Pipes[0].PipeHandle;

        //  Check to see if secure data is being streamed
        if (pPinContext->DrmContentId) {
            // Forward content to common class driver PDO
            ntStatus = DrmForwardContentToDeviceObject(pPinContext->DrmContentId,
                                                       pPinContext->pNextDeviceObject,
                                                       pPinContext->hPipeHandle);
            if (!NT_SUCCESS(ntStatus)) {
                FreeMem(pUrb);
                return ntStatus;
            }
        }

        //  Free any existing pipe information
        if (pPinContext->Pipes) {
            FreeMem(pPinContext->Pipes);
        }

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pInterfaceInfo->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingAudioInterface] PipeHandle=%x\n", pPinContext->hPipeHandle));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingAudioInterface] ZeroBandwidth\n"));
    }

    FreeMem(pUrb);

    return ntStatus;
}

NTSTATUS
SelectStreamingMIDIInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin )
{
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USHORT ulInterfaceLength;
    ULONG ulNumEndpoints, j;
    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;
    BOOLEAN fIsZeroBW = FALSE;
    ULONG size;
    PURB pUrb;

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pFilterContext || !pPinContext || !pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[SelectStreamingMIDIInterface] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    ulInterfaceNumber = pPinContext->pMIDIPinContext->ulInterfaceNumber;
    ulEndpointNumber = pPinContext->pMIDIPinContext->ulEndpointNumber;
    ulNumEndpoints = (ULONG)pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor->bNumEndpoints;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface=%d Endpoint=%d NumEndpoints=%d CurrentSelectedInterface=%d\n",
                                 ulInterfaceNumber,
                                 ulEndpointNumber,
                                 ulNumEndpoints,
                                 pHwDevExt->ulInterfaceNumberSelected));

    ASSERT(ulNumEndpoints > ulEndpointNumber);

    // Check to see if interface is already opened
    if (pHwDevExt->ulInterfaceNumberSelected == ulInterfaceNumber) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface already selected %d\n",ulInterfaceNumber));

        pPinContext->ulNumberOfPipes = pHwDevExt->ulNumberOfMIDIPipes;
        pPinContext->hPipeHandle = pHwDevExt->Pipes[ulEndpointNumber].PipeHandle;

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pHwDevExt->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        // Add Pipes to Pin Bag
        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->Pipes, FreeMem);

        ntStatus = STATUS_SUCCESS;
    }
    else {
        //  Free any currently allocated PipeInfo
        if (pHwDevExt->pMIDIPipeInfo) {
            USBMIDIInFreePipeInfo( pHwDevExt->pMIDIPipeInfo );
        }

        if (pHwDevExt->Pipes) {
            FreeMem(pHwDevExt->Pipes);
        }

        // Allocate an interface request
        ulInterfaceLength = (USHORT)GET_USBD_INTERFACE_SIZE(ulNumEndpoints);

        size = GET_SELECT_INTERFACE_REQUEST_SIZE(ulNumEndpoints);

        pUrb = AllocMem(NonPagedPool, size);
        if (!pUrb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // Copy the interface information
        pInterfaceInfo = &pUrb->UrbSelectInterface.Interface;
        RtlCopyMemory( pInterfaceInfo,
                       pHwDevExt->pInterfaceList[ulInterfaceNumber].Interface,
                       ulInterfaceLength );
        pInterfaceInfo->Length = ulInterfaceLength;
        pInterfaceInfo->AlternateSetting =
            pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor->bAlternateSetting;

        for ( j=0; j < ulNumEndpoints; j++) {
            pInterfaceInfo->Pipes[j].MaximumTransferSize = pPinContext->ulMaxPacketSize;
        }

        // set up the input parameters in our interface request structure.
        pUrb->UrbHeader.Length = (USHORT) size;
        pUrb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;
        pUrb->UrbSelectInterface.ConfigurationHandle = pHwDevExt->ConfigurationHandle;

        ntStatus = SubmitUrbToUsbdSynch(pHwDevExt->pNextDeviceObject, pUrb);
        if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(pUrb->UrbSelectInterface.Hdr.Status)) {
            FreeMem(pUrb);
            return ntStatus;
        }

        pPinContext->ulNumberOfPipes = pInterfaceInfo->NumberOfPipes;
        pPinContext->hPipeHandle = pInterfaceInfo->Pipes[ulEndpointNumber].PipeHandle;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] NumberOfPipes=%d PipeHandle=%x\n",
                                     pPinContext->ulNumberOfPipes,
                                     pPinContext->hPipeHandle));

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pInterfaceInfo->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        // Add Pipes to Pin Bag
        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->Pipes, FreeMem);

        // Now update the Hardware context
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface selected %d\n",ulInterfaceNumber));
        pHwDevExt->ulInterfaceNumberSelected = ulInterfaceNumber;
        pHwDevExt->ulNumberOfMIDIPipes = pInterfaceInfo->NumberOfPipes;
        pHwDevExt->hPipeHandle = pInterfaceInfo->Pipes[ulEndpointNumber].PipeHandle;

        pHwDevExt->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pHwDevExt->ulNumberOfMIDIPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pHwDevExt->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pHwDevExt->Pipes,
                       pInterfaceInfo->Pipes,
                       pHwDevExt->ulNumberOfMIDIPipes*sizeof(USBD_PIPE_INFORMATION) );

        FreeMem(pUrb);
    }

    // Make sure a valid pipe handle is set
    ASSERT(pPinContext->hPipeHandle);

    return ntStatus;
}

NTSTATUS
SelectZeroBandwidthInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulPinNumber )
{
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor = pHwDevExt->pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    BOOLEAN fFound = FALSE;
    NTSTATUS ntStatus;

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    // First Find the 0 BW interface
    pInterfaceDescriptor =
        GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulPinNumber );

    while ( pInterfaceDescriptor && !(fFound = IsZeroBWInterface(pConfigurationDescriptor, pInterfaceDescriptor)) ) {
        pInterfaceDescriptor = GetNextAudioInterface(pConfigurationDescriptor, pInterfaceDescriptor);
    }

    if ( !fFound ) {
        TRAP; // This is a device design error. all interfaces must include 0 BW setting
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
        ntStatus =
            SelectStreamingAudioInterface( pInterfaceDescriptor, pHwDevExt, NULL );

    return ntStatus;
}

NTSTATUS
ResetUSBPipe( PDEVICE_OBJECT pNextDeviceObject,
              USBD_PIPE_HANDLE hPipeHandle )
{
    NTSTATUS ntStatus;
    PURB pUrb;

    ASSERT(hPipeHandle);

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbPipeRequest.PipeHandle = hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch( pNextDeviceObject, pUrb );

    FreeMem( pUrb );
    return ntStatus;

}

NTSTATUS
AbortUSBPipe( PPIN_CONTEXT pPinContext )
{
    NTSTATUS ntStatus;
    PURB pUrb;
    KIRQL irql;

    //DbgPrint("Performing Abort of USB Audio Pipe!!!\n");
    ASSERT(pPinContext->hPipeHandle);
    DbgLog("AbrtP", pPinContext, pPinContext->hPipeHandle, 0, 0 );

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
    pUrb->UrbPipeRequest.PipeHandle = pPinContext->hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch(pPinContext->pNextDeviceObject, pUrb);

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Abort Failed %x\n",ntStatus));
    }

    // Wait for all urbs on the pipe to clear
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    // Now reset the pipe and continue
    RtlZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbPipeRequest.PipeHandle = pPinContext->hPipeHandle;

    ntStatus = SubmitUrbToUsbdSynch(pPinContext->pNextDeviceObject, pUrb);

    pPinContext->fUrbError = FALSE;

    FreeMem(pUrb);

    return ntStatus;
}

NTSTATUS
GetCurrentUSBFrame(
    IN PPIN_CONTEXT pPinContext,
    OUT PULONG pUSBFrame
    )
/*++
GetCurrentUSBFrame

Arguments:
    pPinContext - pointer to the pin context for this instance

    pUSBFrame - pointer to storage for the current USB frame number

Return Value:
    NTSTATUS
--*/
{
    NTSTATUS ntStatus;
    ULONG ulCurrentUSBFrame;

    // Use function-based interfaces if available
    if (pPinContext->pHwDevExt->pBusIf) {

        // Call function-based ISO interface on USB to enable RT support
        ntStatus = pPinContext->pHwDevExt->pBusIf->QueryBusTime( pPinContext->pHwDevExt->pBusIf->BusContext,
                                                                 &ulCurrentUSBFrame);
    }
    else {

        ntStatus = STATUS_NOT_SUPPORTED;

    }


    if (NT_SUCCESS(ntStatus) && pUSBFrame!=NULL) {
        *pUSBFrame=ulCurrentUSBFrame;
        }

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\intrsect.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       intrsect.c
//
//--------------------------------------------------------------------------

#include "common.h"

ULONG
GetIntersectFormatSize( PUSBAUDIO_DATARANGE pAudioDataRange )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pAudioDataRange->pAudioDescriptor;
    ULONG rval = 0;

    if (IS_VALID_WAVEFORMATEX_GUID(pSubFormat)) {
        if (( pAudioDescriptor->bBitsPerSample <=16 ) &&
            ( pAudioDescriptor->bNumberOfChannels <=2 )){
            rval = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else
        rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );

    return rval;
}

ULONG
ConvertDatarangeToFormat(
    PUSBAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pAudioDataRange->pAudioDescriptor;

    // Copy datarange directly from interface info.
    *pFormat = pAudioDataRange->KsDataRangeAudio.DataRange;

    if ( IS_VALID_WAVEFORMATEX_GUID(pSubFormat) ) {
        if (( pAudioDescriptor->bBitsPerSample    <=16 ) &&
            ( pAudioDescriptor->bNumberOfChannels <=2 )){
            PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

            pWavFormatEx->wFormatTag      = EXTRACT_WAVEFORMATEX_ID(pSubFormat);
            pWavFormatEx->nChannels       = (WORD)pAudioDescriptor->bNumberOfChannels;
            pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatEx->wBitsPerSample  = (WORD)pAudioDescriptor->bBitsPerSample;
            pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
            pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
            pWavFormatEx->cbSize          = 0;

            pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
        }
        else {
            PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pFormat+1) ;
            pWavFormatPCMEx->Format.wFormatTag      = WAVE_FORMAT_EXTENSIBLE;
            pWavFormatPCMEx->Format.nChannels       = (WORD)pAudioDescriptor->bNumberOfChannels;
            pWavFormatPCMEx->Format.nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatPCMEx->Format.wBitsPerSample  = (WORD)pAudioDescriptor->bSlotSize<<3;
            pWavFormatPCMEx->Format.nBlockAlign     = (pWavFormatPCMEx->Format.nChannels *
                                                       pWavFormatPCMEx->Format.wBitsPerSample)>>3;
            pWavFormatPCMEx->Format.nAvgBytesPerSec = pWavFormatPCMEx->Format.nSamplesPerSec *
                                                      pWavFormatPCMEx->Format.nBlockAlign;
            pWavFormatPCMEx->Format.cbSize          = sizeof(WAVEFORMATPCMEX) - sizeof(WAVEFORMATEX);
            pWavFormatPCMEx->Samples.wValidBitsPerSample = (WORD)pAudioDescriptor->bBitsPerSample;
            pWavFormatPCMEx->dwChannelMask          = pAudioDataRange->ulChannelConfig;
            pWavFormatPCMEx->SubFormat              = KSDATAFORMAT_SUBTYPE_PCM;

            pFormat->FormatSize = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else {
        // NOTE: Hardcoded for AC-3
        // TODO: Need to support generic Type II
        PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor = (PAUDIO_CLASS_TYPE2_STREAM)pAudioDataRange->pAudioDescriptor;
        PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

        pWavFormatEx->wFormatTag      = WAVE_FORMAT_UNKNOWN;  // Used for AC-3

        pWavFormatEx->nChannels       = (WORD)6;
        pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
        pWavFormatEx->wBitsPerSample  = (WORD)0;
        pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
        pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
        pWavFormatEx->cbSize          = 0;

        pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
    }

    return pFormat->FormatSize;
}

BOOLEAN
CheckFormatMatch(
    PKSDATARANGE_AUDIO pInDataRange,
    PKSDATARANGE_AUDIO pInterfaceRange )
{
    PKSDATARANGE pInRange = (PKSDATARANGE)pInDataRange;
    PKSDATARANGE pStreamRange = (PKSDATARANGE)pInterfaceRange;
    BOOLEAN fRval = FALSE;

    // Check Format and subformat types
    if (IsEqualGUID(&pInRange->MajorFormat, &pStreamRange->MajorFormat) ||
        IsEqualGUID(&pInRange->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        if (IsEqualGUID(&pInRange->SubFormat, &pStreamRange->SubFormat) ||
            IsEqualGUID(&pInRange->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
            if (IsEqualGUID(&pInRange->Specifier, &pStreamRange->Specifier) ||
                IsEqualGUID(&pInRange->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
                fRval = TRUE;
            }
        }
    }

    // Now that we know we have an audio format check the dataranges
    if ( fRval ) {
        fRval = FALSE;

        if (pInDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
            if ( pInDataRange->MaximumChannels >= pInterfaceRange->MaximumChannels ) {
                if ( pInDataRange->MaximumSampleFrequency >= pInterfaceRange->MaximumSampleFrequency ) {
                    if (pInDataRange->MinimumSampleFrequency <= pInterfaceRange->MaximumSampleFrequency ) {
                        if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                            if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                                fRval = TRUE;
                            }
                        }
                        else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                            fRval = TRUE;
                        }
                    }
                }
                else if ( pInDataRange->MinimumSampleFrequency >= pInterfaceRange->MinimumSampleFrequency ) {
                    if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                        if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                            fRval = TRUE;
                        }
                    }
                    else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                        fRval = TRUE;
                    }
                }
            }
        }
        else {
            // If no audio specific range info, consider this a match
            fRval = TRUE;
        }
    }

    return fRval;
}

VOID
GetMaxSampleRate(
    PUSBAUDIO_DATARANGE pUSBAudioRange,
    ULONG ulRequestedMaxSR,
    ULONG ulFormatType )
{
    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDesc;
    PAUDIO_CLASS_TYPE2_STREAM pT2AudioDesc;

    ULONG ulMaxSampleRate = 0;
    ULONG ulIFMaxSR;
    ULONG j;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
        pT1AudioDesc = (PAUDIO_CLASS_TYPE1_STREAM)pUSBAudioRange->pAudioDescriptor;
        if (pT1AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pUSBAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pUSBAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                                ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pUSBAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT1AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT1AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT1AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT1AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pUSBAudioRange->ulMaxSampleRate ) )
                    pUSBAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
    else { // Its Type II
        pT2AudioDesc = (PAUDIO_CLASS_TYPE2_STREAM)pUSBAudioRange->pAudioDescriptor;
        if (pT2AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pUSBAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pUSBAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                                ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pUSBAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT2AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT2AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pUSBAudioRange->ulMaxSampleRate ) )
                    pUSBAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
}

PUSBAUDIO_DATARANGE
FindBestMatchForInterfaces(
    PUSBAUDIO_DATARANGE *ppUSBAudioRange,
    ULONG ulAudioRangeCount,
    ULONG ulRequestedMaxSR  )
{
    PUSBAUDIO_DATARANGE pUSBAudioRange;
    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDesc;

    ULONG ulMaxSampleRate = 0;
    ULONG ulMaxChannels   = 0;
    ULONG ulMaxSampleSize = 0;
    ULONG ulRngeCnt;
    ULONG ulFormatType;
    ULONG i;

     ulFormatType = ppUSBAudioRange[0]->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    // Determine if this is Type I or Type II interface. Since we've already weeded
    // out the impossibilities via CheckFormatMatch this should be the same for all
    // interfaces left in the list.

    for ( i=0; i<ulAudioRangeCount; i++ ) {
        GetMaxSampleRate( ppUSBAudioRange[i],
                          ulRequestedMaxSR,
                          ulFormatType );
    }

    // Now eliminate lower frequency interfaces. First find the best then
    // eliminate others that don't meet it.
    for ( i=0; i<ulAudioRangeCount; i++ ) {
        pUSBAudioRange = ppUSBAudioRange[i];
        if ( pUSBAudioRange->ulMaxSampleRate > ulMaxSampleRate ) {
            ulMaxSampleRate = pUSBAudioRange->ulMaxSampleRate;
        }
    }
    for ( i=0, ulRngeCnt=ulAudioRangeCount; i<ulAudioRangeCount; i++ ) {
        pUSBAudioRange = ppUSBAudioRange[i];
        if ( pUSBAudioRange->ulMaxSampleRate < ulMaxSampleRate ) {
            ppUSBAudioRange[i] = NULL; ulRngeCnt--;
        }
    }

    if ((ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) && (ulRngeCnt > 1)) {
        // Now find the highest number of channels and eliminate others
        for ( i=0; i<ulAudioRangeCount; i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bNumberOfChannels > ulMaxChannels ) {
                    ulMaxChannels = (ULONG)pT1AudioDesc->bNumberOfChannels;
                }
                if ( (ULONG)pT1AudioDesc->bBitsPerSample > ulMaxSampleSize ) {
                    ulMaxSampleSize = (ULONG)pT1AudioDesc->bBitsPerSample;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bNumberOfChannels < ulMaxChannels ) {
                    ppUSBAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bBitsPerSample < ulMaxSampleSize ) {
                    ppUSBAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }
    }

    i=0;
    while ( !ppUSBAudioRange[i] ) i++;

    return ppUSBAudioRange[i];
}

PUSBAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PUSBAUDIO_DATARANGE *ppUSBAudioRanges,
    ULONG ulAudioRangeCount )
{
    PUSBAUDIO_DATARANGE *ppUSBAudioRange;
    PUSBAUDIO_DATARANGE pUSBAudioRange;
    PUSBAUDIO_DATARANGE pMatchedRange;
    ULONG ulRngeCnt = 0;
    ULONG ulMaximumSampleFrequency = MAX_ULONG;  // default high value, if no audio
    ULONG i;                                     // data range info is sent.

    // Allocate space for copy of range pointers
    ppUSBAudioRange = AllocMem(NonPagedPool, ulAudioRangeCount*sizeof(PUSBAUDIO_DATARANGE));
    if ( !ppUSBAudioRange ) {
        return NULL;
    }

    // Make a list of those ranges which match the input request
    for (i=0; i<ulAudioRangeCount; i++) {
        pUSBAudioRange = ppUSBAudioRanges[i];
        if ( CheckFormatMatch(pKsAudioRange, &pUSBAudioRange->KsDataRangeAudio) ) {
            ppUSBAudioRange[ulRngeCnt++] = ppUSBAudioRanges[i];
        }
    }

    // Set this ulMaximumSampleFrequency only if it exists in pKsAudioRange
    if (pKsAudioRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
        ulMaximumSampleFrequency = pKsAudioRange->MaximumSampleFrequency;
    }

    // If there are no matches return NULL
    if ( ulRngeCnt == 0 ) {
        FreeMem( ppUSBAudioRange );
        return NULL;
    }

    // If there is only 1 match we're done
    else if ( ulRngeCnt == 1 ) {
        pMatchedRange = ppUSBAudioRange[0];
        GetMaxSampleRate( pMatchedRange,
                          ulMaximumSampleFrequency,
                          pMatchedRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK );
        FreeMem( ppUSBAudioRange );
        return pMatchedRange;
    }

    // Now narrow choices based on best possible match.
    pMatchedRange =
        FindBestMatchForInterfaces( ppUSBAudioRange,
                                    ulRngeCnt,
                                    ulMaximumSampleFrequency );
    FreeMem(ppUSBAudioRange);

    return pMatchedRange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\midiin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       midiin.c
//
//--------------------------------------------------------------------------

#include "common.h"

/* * A simple helper function to return the current
 * system time in 100 nanosecond units. It uses KeQueryPerformanceCounter
 */
ULONGLONG
GetCurrentTime
(   void
)
{
    LARGE_INTEGER   liFrequency,liTime;

    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

    // Convert ticks to 100ns units.
#ifndef UNDER_NT

    //
    //  HACKHACK! Since timeGetTime assumes 1193 VTD ticks per millisecond,
    //  instead of 1193.182 (or 1193.18 -- really spec'ed as 1193.18175),
    //  we should do the same (on Win 9x codebase only).
    //
    //  This means we drop the bottom three digits of the frequency.
    //  We need to fix this when the fix to timeGetTime is checked in.
    //  instead we do this:
    //
    liFrequency.QuadPart /= 1000;           //  drop the precision on the floor
    liFrequency.QuadPart *= 1000;           //  drop the precision on the floor

#endif  //  !UNDER_NT    //  Convert ticks to 100ns units.

    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}

NTSTATUS AbortMIDIInPipe
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo
)
{
    NTSTATUS ntStatus;
    PURB pUrb;
    KIRQL irql;

    ASSERT(pMIDIPipeInfo->hPipeHandle);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[AbortMIDIInPipe] pin %x\n",pMIDIPipeInfo));

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
    pUrb->UrbPipeRequest.PipeHandle = pMIDIPipeInfo->hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch(pMIDIPipeInfo->pNextDeviceObject, pUrb);

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Abort Failed %x\n",ntStatus));
    }

    // Wait for all urbs on the pipe to clear
    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
    if ( pMIDIPipeInfo->ulOutstandingUrbCount ) {
        KeResetEvent( &pMIDIPipeInfo->PipeStarvationEvent );
        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
        KeWaitForSingleObject( &pMIDIPipeInfo->PipeStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    // Now reset the pipe and continue
    RtlZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbPipeRequest.PipeHandle = pMIDIPipeInfo->hPipeHandle;

    ntStatus = SubmitUrbToUsbdSynch(pMIDIPipeInfo->pNextDeviceObject, pUrb);

    FreeMem(pUrb);

    if ( NT_SUCCESS(ntStatus) ) {
        pMIDIPipeInfo->fUrbError = FALSE;
    }

    return ntStatus;
}

VOID
USBMIDIInGateOnWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInGateOnWorkItem] pin %d\n",pKsPin->Id));

    // Don't want to turn on the gate if we are not running
//    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
//    if (!pMIDIInPinContext->fRunning) {
//        pMIDIInPinContext->fProcessing = FALSE;
//        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
//        return;
//    }
//    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    do
    {
        // Acquire the Process Mutex to ensure there will be no new requests during the gate operation
        KsPinAcquireProcessingMutex( pKsPin );

        KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );

        KsPinAttemptProcessing( pKsPin, TRUE );

        DbgLog("MProcOn", pKsPin, 0, 0, 0 );

        KsPinReleaseProcessingMutex( pKsPin );
    } while (KsDecrementCountedWorker(pMIDIInPinContext->GateOnWorkerObject));
}

NTSTATUS
USBMIDIInInitializeUrbAndIrp( PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PKSPIN pKsPin = pMIDIInBufInfo->pKsPin;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PIRP pIrp = pMIDIInBufInfo->pIrp;
    PURB pUrb = pMIDIInBufInfo->pUrb;
    PIO_STACK_LOCATION pNextStack;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pMIDIPipeInfo->hPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pMIDIInBufInfo->pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int) pMIDIPipeInfo->ulMaxPacketSize;

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    RtlZeroMemory(pMIDIInBufInfo->pData,pMIDIPipeInfo->ulMaxPacketSize);

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pMIDIPipeInfo->pNextDeviceObject->StackSize),
                     pMIDIPipeInfo->pNextDeviceObject->StackSize );

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextStack->Parameters.Others.Argument1 = pMIDIInBufInfo->pUrb;
    pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, USBMIDIInCompleteCallback, pMIDIInBufInfo, TRUE, TRUE, TRUE );

    DbgLog("IniIrpM", pMIDIInBufInfo, pIrp, pUrb, pNextStack );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInReQueueUrb( PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBMIDIInInitializeUrbAndIrp( pMIDIInBufInfo );

    InterlockedIncrement(&pMIDIPipeInfo->ulOutstandingUrbCount);
    ntStatus = IoCallDriver( pMIDIPipeInfo->pNextDeviceObject,
                             pMIDIInBufInfo->pIrp );

    return ntStatus;

}

VOID
USBMIDIInRequeueWorkItem
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo
)
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] pMidiPipeInfo %x\n",pMIDIPipeInfo));

    do
    {
        // Clear out any error if need be
        if (pMIDIPipeInfo->fUrbError) {
            ntStatus = AbortMIDIInPipe( pMIDIPipeInfo );  // TODO: Returning STATUS_DEVICE_DATA_ERROR (0xc000009c)
            if ( !NT_SUCCESS(ntStatus) ) {
                // TRAP; // Figure out what to do here
                pMIDIPipeInfo->fRunning = FALSE;
                _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] Abort Failed %x\n",ntStatus));
            }
        }

        if ( NT_SUCCESS(ntStatus) && !pMIDIPipeInfo->fUrbError) {
            KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            // Requeue Urbs
            while ( !IsListEmpty(&pMIDIPipeInfo->EmptyBufferQueue) ) {
                pMIDIInBufInfo = (PMIDIIN_URB_BUFFER_INFO)RemoveHeadList(&pMIDIPipeInfo->EmptyBufferQueue);
                KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
                ntStatus = USBMIDIInReQueueUrb( pMIDIInBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    //TRAP; // Figure out what to do here
                    pMIDIPipeInfo->fRunning = FALSE;
                    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
                    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] Requeue Failed %x\n",ntStatus));
                    break;
                }
                KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            }
            KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
        }
    } while (KsDecrementCountedWorker(pMIDIPipeInfo->RequeueUrbWorkerObject));

    return;
}

NTSTATUS
AddMIDIEventToPinQueue
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo,
    IN PUSBMIDIEVENTPACKET pMIDIEventPacket
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    PLIST_ENTRY ple;
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PMIDI_PIN_CONTEXT pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo;
    ULONG CableNumber;
    ULONG PinCableNumber;
    BOOL fNeedToProcess;
    KIRQL irql;

    // Undefined Message, don't add to pin queue
    if (pMIDIEventPacket->ByteLayout.CodeIndexNumber == 0x0 ||
        pMIDIEventPacket->ByteLayout.CodeIndexNumber == 0x1 ) {
        return STATUS_SUCCESS;
    }

    // Given this cable number, find the right pin
    CableNumber = pMIDIEventPacket->ByteLayout.CableNumber;

    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );

    for(ple = pMIDIPipeInfo->MIDIInActivePinList.Flink;
        ple != &pMIDIPipeInfo->MIDIInActivePinList;
        ple = ple->Flink)
    {
        pMIDIInPinListEntry = CONTAINING_RECORD(ple, MIDIIN_PIN_LISTENTRY, List);
        pKsPin = pMIDIInPinListEntry->pKsPin;
        pPinContext = pKsPin->Context;
        pMIDIPinContext = pPinContext->pMIDIPinContext;
        pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;

        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

        PinCableNumber = pMIDIPinContext->ulCableNumber;
        if (CableNumber == PinCableNumber) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[AddMIDIEventToPinQueue] Found CableNumber(%d) on pKsPin(%x)\n",
                                       pMIDIPinContext->ulCableNumber, pKsPin));

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            if ( (pMIDIInPinContext->fRunning) &&
                 (!IsListEmpty( &pMIDIInPinContext->USBMIDIEmptyEventQueue )) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEmptyEventQueue);

                // Copy the midi event and store the 100ns time this buffer was received
                pUSBMIDIEventInfo->USBMIDIEvent = *pMIDIEventPacket;
                pUSBMIDIEventInfo->ullTimeStamp = GetCurrentTime();

                // Queue the event for processing
                fNeedToProcess = IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue ) &&
                                         !pMIDIInPinContext->fProcessing;

                InsertTailList( &pMIDIInPinContext->USBMIDIEventQueue, &pUSBMIDIEventInfo->List );

                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                if ( fNeedToProcess ) {
                    pMIDIInPinContext->fProcessing = TRUE;

                    // Queue a work item to handle this so that we don't race with the gate
                    // count in the processing routine
                    KsIncrementCountedWorker(pMIDIInPinContext->GateOnWorkerObject);
                }
            }
            else {
                DbgLog("Dropped", pKsPin, *((LPDWORD)pMIDIEventPacket), 0, 0 );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            }

            KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            break;
        }

        KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
    }

    KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PUCHAR pMIDIInData;
    ULONG ulMIDIInRemaining;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    NTSTATUS ntStatus = pIrp->IoStatus.Status;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInCompleteCallback] pMIDIPipeInfo %x\n",pMIDIPipeInfo));
    DbgLog("MIData", *((LPDWORD)pMIDIInBufInfo->pData),
                     *((LPDWORD)pMIDIInBufInfo->pData+1),
                     *((LPDWORD)pMIDIInBufInfo->pData+2),
                     *((LPDWORD)pMIDIInBufInfo->pData+3) );

    if ( pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.Hdr.Status ) {
        DbgLog("MUrbErr", pMIDIInBufInfo, pMIDIPipeInfo,
                          pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.Hdr.Status, 0 );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        pMIDIPipeInfo->fUrbError = TRUE;
    }

    ulMIDIInRemaining = pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    pMIDIInData       = pMIDIInBufInfo->pData;
    while ( ulMIDIInRemaining >= sizeof(USBMIDIEVENTPACKET)) {
        AddMIDIEventToPinQueue(pMIDIPipeInfo, (PUSBMIDIEVENTPACKET)pMIDIInData);

        pMIDIInData += sizeof(USBMIDIEVENTPACKET);
        ulMIDIInRemaining -= sizeof(USBMIDIEVENTPACKET);
    }

    // Put Urb back on Empty urb queue
    KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    InsertTailList( &pMIDIPipeInfo->EmptyBufferQueue, &pMIDIInBufInfo->List );
    KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

    if ( 0 == InterlockedDecrement(&pMIDIPipeInfo->ulOutstandingUrbCount) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInCompleteCallback] Out of Urbs on pMIDIPipeInfo %x\n",pMIDIPipeInfo));
        KeSetEvent( &pMIDIPipeInfo->PipeStarvationEvent, 0, FALSE );
    }

    // Fire work item to requeue urb to device
    if ( pMIDIPipeInfo->fRunning ) {
        KsIncrementCountedWorker(pMIDIPipeInfo->RequeueUrbWorkerObject);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

ULONG ConvertCINToBytes
(
    BYTE CodeIndexNumber
)
{
    ULONG NumBytes = 0;

    switch (CodeIndexNumber) {
    case 0x5:
    case 0xF:
        NumBytes = 1;
        break;

    case 0x2:
    case 0x6:
    case 0xC:
    case 0xD:
        NumBytes = 2;
        break;

    case 0x3:
    case 0x4:
    case 0x7:
    case 0x8:
    case 0x9:
    case 0xA:
    case 0xB:
    case 0xE:
        NumBytes = 3;
        break;

    default:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("[ConvertCINToBytes] Unknown CIN received from device\n"));
    }

    return NumBytes;
}

VOID CopyUSBMIDIEvent
(
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo,
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext,
    PUCHAR pStreamPtrData,
    PUSBMIDIEVENTPACKET pMIDIPacket,
    PULONG pulCopySize
)
{
    PKSMUSICFORMAT pMusicHdr;
    ULONG BytesToCopy;

    ASSERT(*pulCopySize >= sizeof(*pMusicHdr) + sizeof(DWORD));

    pMusicHdr = (PKSMUSICFORMAT)pStreamPtrData;

    // Copy the MIDI data
    BytesToCopy = ConvertCINToBytes(pMIDIPacket->ByteLayout.CodeIndexNumber);
    RtlCopyMemory(pStreamPtrData+
                  sizeof(*pMusicHdr) +   // jump over the music header
                  pMusicHdr->ByteCount,  // and already written bytes
                  &pMIDIPacket->ByteLayout.MIDI_0, // jump over the CIN and CN
                  BytesToCopy);

    // TODO: For multiple music headers, need to produce proper TimeDeltaMs value
    if (pUSBMIDIEventInfo->ullTimeStamp < pMIDIInPinContext->ullStartTime ) {
        _DbgPrintF( DEBUGLVL_TERSE, ("[CopyUSBMIDIEvent] Event came in before pin went to KSSTATE_RUN!\n"));
        pMusicHdr->TimeDeltaMs = 0;
    }
    else {
        pMusicHdr->TimeDeltaMs =
            (ULONG)((pUSBMIDIEventInfo->ullTimeStamp - pMIDIInPinContext->ullStartTime) / 10000); // 100ns->Ms for delta MSec
    }
    pMusicHdr->ByteCount += BytesToCopy;

    {
        LPBYTE MIDIData = pStreamPtrData+sizeof(*pMusicHdr);
        _DbgPrintF( DEBUGLVL_VERBOSE, ("'[CopyUSBMIDIEvent] MIDIData = 0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
                                      *MIDIData,    *(MIDIData+1), *(MIDIData+2),
                                      *(MIDIData+3),*(MIDIData+4), *(MIDIData+5),
                                      *(MIDIData+6),*(MIDIData+7), *(MIDIData+8),
                                      *(MIDIData+9),*(MIDIData+10),*(MIDIData+11)) );
    }

    // update the actual copy size
    //*pulCopySize = sizeof(*pMusicHdr) + ((pMusicHdr->ByteCount + 3) & ~3);
    *pulCopySize = sizeof(*pMusicHdr) + pMusicHdr->ByteCount;
    _DbgPrintF( DEBUGLVL_VERBOSE, ("'[CopyUSBMIDIEvent] Copied %d bytes\n",*pulCopySize));

    return;
}

BOOL IsRealTimeEvent
(
    USBMIDIEVENTPACKET MIDIPacket
)
{
    return IS_REALTIME(MIDIPacket.ByteLayout.MIDI_0);
}

NTSTATUS
USBMIDIInProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInPinContext->pMIDIPipeInfo;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo = NULL;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulStreamRemaining;
    KIRQL irql;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[USBMIDIInProcessStreamPtr] pKsPin %x\n",pKsPin));
    DbgLog("MInProc", pKsPin, pPinContext, pMIDIPinContext, pMIDIInPinContext );

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( !IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue )) {
        pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);
        // Set stream started flag if not already done
        if ( !pPinContext->fStreamStartedFlag ) {
            pPinContext->fStreamStartedFlag = TRUE;
        }
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }
    else {
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
        pMIDIInPinContext->fProcessing = FALSE;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInProcessStreamPtr] No buffers ready yet!\n"));
        return STATUS_PENDING;
    }

    // Get leading edge
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[MIDIInProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;

    // check to see if there is room for more data into the stream
    while ( pKsStreamPtr && pUSBMIDIEventInfo) {
        ULONG ulCopySize = 0;

        //if (*((LPDWORD)pUSBMIDIEventInfo->USBMIDIEvent)) {
        //    DbgLog("MIData2", *((LPDWORD)pMIDIInData), pMIDIInBufInfo, ulMIDIInRemaining, pMIDIInData );
        //}

        // Undefined Message, ignore
        if (pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber == 0x0 ||
            pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber == 0x1 ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("'[USBMIDIInProcessStreamPtr] Undefined Message, ignore\n"));
        }
        else {
            // Valid USB MIDI Message
            ulCopySize = ulStreamRemaining;

            DbgLog("MInLp", pKsStreamPtr, pUSBMIDIEventInfo, ulStreamRemaining, pKsStreamPtr->OffsetOut.Data );

            //
            //  If this is a realtime message, complete any pending sysex data and
            //  allow the realtime message to completed by itself
            //
            if (IsRealTimeEvent(pUSBMIDIEventInfo->USBMIDIEvent)) {

                if (pMIDIInPinContext->ulMIDIBytesCopiedToStream) {
                    // Complete the dword-aligned buffer
                    KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                            0,
                                                            (pMIDIInPinContext->ulMIDIBytesCopiedToStream + 3) & ~3,
                                                            TRUE );
                    pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;

                    // Get Next stream header if there is one.
                    if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                        ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
                    }
                    else {
                        continue;
                    }
                }

                DbgLog("MInRT", pKsStreamPtr, pUSBMIDIEventInfo, ulStreamRemaining, pKsStreamPtr->OffsetOut.Data );
            }

            CopyUSBMIDIEvent( pUSBMIDIEventInfo,
                              pMIDIInPinContext,
                              pKsStreamPtr->OffsetOut.Data,
                              &pUSBMIDIEventInfo->USBMIDIEvent,
                              &ulCopySize );

            //
            // Complete frame if EOX, short message or ran out of room in frame for
            // continuation of SysEx
            //
            if ( (pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber != 0x4) ||
                 (ulCopySize + 3 > ulStreamRemaining) ) {

                if (ulCopySize + 3 > ulStreamRemaining) {
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("'[USBMIDIInProcessStreamPtr] Ending SysEx subpacket\n"));
                }

                // Complete the dword-aligned buffer
                KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr, 0, (ulCopySize + 3) & ~3, TRUE );
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;
                // Get Next stream header if there is one.
                if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
                }
            }
            else {
                //
                // store the total bytes copied so far so that those bytes
                // can be completed if the stream goes to a stop state
                //
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = ulCopySize;
            }
        }

        // Add this Event entry back to the free queue
        InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );

        // Check if there is more captured data queued
        // Grab Spinlock to check capture queue
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( !IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue )) {
            pUSBMIDIEventInfo =
                (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
        else {
            KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
            pMIDIInPinContext->fProcessing = FALSE;
            pUSBMIDIEventInfo = NULL;
            DbgLog("MPrcOff", pUSBMIDIEventInfo, pMIDIInPinContext, pPinContext, 0 );
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
    }

    if ( !pUSBMIDIEventInfo ) {
        if ( pKsStreamPtr )
            KsStreamPointerUnlock(pKsStreamPtr, FALSE);

        // No more capture buffers pending from the device.  Return STATUS_PENDING so that KS
        // doesn't keep calling back into the process routine.  The AndGate should have been
        // turned off at this point to prevent an endless loop too.
        return STATUS_PENDING;
    }
    else { // if ( !pKsStreamPtr )
        _DbgPrintF(DEBUGLVL_VERBOSE,("[MIDIInProcessStreamPtr] Starving Capture Pin\n"));

        // Allow KS to call us back if there is more available buffers from the client.  We
        // are ready to process more data.
        return STATUS_SUCCESS;
    }
}

NTSTATUS
USBMIDIInStartBulkTransfer(
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo
    )
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    NTSTATUS ntStatus;
    ULONG i;
    KIRQL irql;

    KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    pMIDIPipeInfo->fRunning = TRUE;
    while ( !IsListEmpty( &pMIDIPipeInfo->EmptyBufferQueue )) {
        pMIDIInBufInfo = (PMIDIIN_URB_BUFFER_INFO)RemoveHeadList(&pMIDIPipeInfo->EmptyBufferQueue);
        KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

        InterlockedIncrement(&pMIDIPipeInfo->ulOutstandingUrbCount);

        USBMIDIInInitializeUrbAndIrp( pMIDIInBufInfo );

        ntStatus = IoCallDriver( pMIDIPipeInfo->pNextDeviceObject,
                                 pMIDIInBufInfo->pIrp);

        if ( !NT_SUCCESS(ntStatus) ) {
            TRAP;
            pMIDIPipeInfo->fRunning = FALSE;
            return ntStatus;
        }
        KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    }
    KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo;
    PKSSTREAM_POINTER pKsStreamPtr;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONGLONG currentTime100ns;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIInStateChange] NewKsState: %d\n", NewKsState));

    currentTime100ns = GetCurrentTime();

    if (OldKsState == KSSTATE_RUN) {
        ASSERT(currentTime100ns >= pMIDIInPinContext->ullStartTime);
        pMIDIInPinContext->ullPauseTime = currentTime100ns - pMIDIInPinContext->ullStartTime;
    }

    switch(NewKsState) {
        case KSSTATE_STOP:
            // complete any pending sysex messages
            if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                pKsStreamPtr->StreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                        0,
                                                        (pMIDIInPinContext->ulMIDIBytesCopiedToStream + 3) & ~3,
                                                        TRUE );
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;
            }

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            pMIDIInPinContext->fRunning = FALSE;
            while ( !IsListEmpty(&pMIDIInPinContext->USBMIDIEventQueue) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);

                //  Clear out the entry and place back on the empty queue
                RtlZeroMemory(pUSBMIDIEventInfo,sizeof(MIDIIN_USBMIDIEVENT_INFO));
                InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );
            }
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
        case KSSTATE_ACQUIRE:
        case KSSTATE_PAUSE:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            if ((NewKsState == KSSTATE_ACQUIRE) &&
                (OldKsState == KSSTATE_STOP)) {
                pMIDIInPinContext->ullPauseTime = 0;
                pMIDIInPinContext->ullStartTime = 0;
            }

            pMIDIInPinContext->fRunning = FALSE;
            while ( !IsListEmpty(&pMIDIInPinContext->USBMIDIEventQueue) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);

                //  Clear out the entry and place back on the empty queue
                RtlZeroMemory(pUSBMIDIEventInfo,sizeof(MIDIIN_USBMIDIEVENT_INFO));
                InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );
            }
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
        case KSSTATE_RUN:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            ASSERT(currentTime100ns >= pMIDIInPinContext->ullPauseTime);
            pMIDIInPinContext->ullStartTime = currentTime100ns - pMIDIInPinContext->ullPauseTime;
            pMIDIInPinContext->fRunning = TRUE;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
    }

    return ntStatus;
}

NTSTATUS
USBMIDIPipeInit
(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN               pKsPin
)
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PUCHAR pData;
    PURB pUrbs;
    NTSTATUS ntStatus;
    UINT i;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPipeInit] pHwDevExt(%x) pKsPin(%x)\n",
                               pHwDevExt, pKsPin));

    ASSERT(!pHwDevExt->pMIDIPipeInfo);

    // Allocate memory for pipe info, capture buffers and urbs
    pMIDIPipeInfo = AllocMem(NonPagedPool, sizeof(MIDI_PIPE_INFORMATION) +
                                 MIDIIN_URBS_PER_PIPE * (ulUrbSize + pPinContext->ulMaxPacketSize));
    if (!pMIDIPipeInfo)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory(pMIDIPipeInfo,sizeof(MIDI_PIPE_INFORMATION));

    // Store in pipe info for easy access
    pMIDIPipeInfo->pHwDevExt = pHwDevExt;
    pMIDIPipeInfo->pNextDeviceObject = pPinContext->pNextDeviceObject;
    pMIDIPipeInfo->ulNumberOfPipes = pPinContext->ulNumberOfPipes;
    pMIDIPipeInfo->hPipeHandle = pPinContext->hPipeHandle;
    pMIDIPipeInfo->ulMaxPacketSize = pPinContext->ulMaxPacketSize;

    pMIDIPipeInfo->Pipes = (PUSBD_PIPE_INFORMATION)
           AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
    if (!pMIDIPipeInfo->Pipes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory( pMIDIPipeInfo->Pipes,
                   pPinContext->Pipes,
                   pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

    // Protection for data structures
    KeInitializeSpinLock(&pMIDIPipeInfo->PipeSpinLock);

    // Setup offsets for memory pool
    pUrbs = (PURB)(pMIDIPipeInfo + 1);
    pData = (PUCHAR)pUrbs + ulUrbSize * MIDIIN_URBS_PER_PIPE;

    // Initialize the Empty Buffer list
    InitializeListHead( &pMIDIPipeInfo->EmptyBufferQueue );

    pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
    for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
        pMIDIInBufInfo->pMIDIPipeInfo = pMIDIPipeInfo;
        pMIDIInBufInfo->pKsPin        = pKsPin;
        pMIDIInBufInfo->pData         = pData + (i * pPinContext->ulMaxPacketSize );
        pMIDIInBufInfo->pUrb          = (PURB)((PUCHAR)pUrbs + (ulUrbSize*i));
        pMIDIInBufInfo->pIrp          = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );

        // cleanup all irps and pipe info on failure
        if (!pMIDIInBufInfo->pIrp) {
            UINT j;

            pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
            for ( j=0; j<i; j++, pMIDIInBufInfo++ ) {
                if (pMIDIInBufInfo->pIrp) {
                    IoFreeIrp( pMIDIInBufInfo->pIrp );
                }
            }
            FreeMem( pMIDIPipeInfo );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        InsertTailList( &pMIDIPipeInfo->EmptyBufferQueue, &pMIDIInBufInfo->List );
    }

    // Initialize Worker item, object and list for potential error recovery
    ExInitializeWorkItem( &pMIDIPipeInfo->RequeueUrbWorkItem,
                          USBMIDIInRequeueWorkItem,
                          pMIDIPipeInfo );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pMIDIPipeInfo->RequeueUrbWorkItem,
                                        &pMIDIPipeInfo->RequeueUrbWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        // cleanup all irps and pipe info on failure
        pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
        for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
            ASSERT( pMIDIInBufInfo->pIrp );
            IoFreeIrp( pMIDIInBufInfo->pIrp );
        }
        FreeMem( pMIDIPipeInfo );
        return ntStatus;
    }

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pMIDIPipeInfo->PipeStarvationEvent, NotificationEvent, FALSE );

    // Initialize the Pin List
    InitializeListHead(&pMIDIPipeInfo->MIDIInActivePinList);

    // Finally, add the pipe info to the device context
    if (NT_SUCCESS(ntStatus)) {
        pHwDevExt->pMIDIPipeInfo = pMIDIPipeInfo;
    }

    return ntStatus;
}

PMIDI_PIPE_INFORMATION
USBMIDIInGetPipeInfo( PKSPIN pKsPin )
{
    // Find the device that this pin is created from
    PKSFILTER pKsFilter = NULL;
    PKSFILTERFACTORY pKsFilterFactory = NULL;
    PKSDEVICE pKsDevice = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    NTSTATUS ntStatus;

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter )) {
                if (pKsDevice = KsFilterFactoryGetParentDevice( pKsFilterFactory )) {
                    pHwDevExt = pKsDevice->Context;
                }
            }
        }
    }

    if (!pHwDevExt) {
        return NULL;
    }

    // If no pipe information already, initialize new pipeinfo structure
    if (!pHwDevExt->pMIDIPipeInfo) {
        ntStatus = USBMIDIPipeInit( pHwDevExt, pKsPin );
    }

    return pHwDevExt->pMIDIPipeInfo;
}

NTSTATUS
USBMIDIInFreePipeInfo( PMIDI_PIPE_INFORMATION pMIDIPipeInfo )
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    UINT i;

    // Clear out all pending KS workitems by unregistering the worker routine
    KsUnregisterWorker( pMIDIPipeInfo->RequeueUrbWorkerObject );

    // Make sure that no URBs are outstanding
    pMIDIPipeInfo->fRunning = FALSE;
    AbortMIDIInPipe( pMIDIPipeInfo );

    // Free the allocated irps
    pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
    for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
        IoFreeIrp( pMIDIInBufInfo->pIrp );
    }

    // Free the allocated pipes
    FreeMem( pMIDIPipeInfo->Pipes );

    // No more references to the pipe, so free context information
    pMIDIPipeInfo->pHwDevExt->pMIDIPipeInfo = NULL;
    FreeMem( pMIDIPipeInfo );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInRemovePinFromPipe
(
    IN PMIDI_PIPE_INFORMATION pMidiPipeInfo,
    IN PKSPIN pKsPin
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    PLIST_ENTRY ple;
    BOOL fListEmpty;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    KeAcquireSpinLock( &pMidiPipeInfo->PipeSpinLock, &irql );

    //  Remove pin from list of ones that are serviced by this endpoint
    for(ple = pMidiPipeInfo->MIDIInActivePinList.Flink;
        ple != &pMidiPipeInfo->MIDIInActivePinList;
        ple = ple->Flink)
    {
        pMIDIInPinListEntry = CONTAINING_RECORD(ple, MIDIIN_PIN_LISTENTRY, List);
        if (pMIDIInPinListEntry->pKsPin == pKsPin) {
            RemoveEntryList(&pMIDIInPinListEntry->List);
            FreeMem ( pMIDIInPinListEntry );
            break;
        }
    }

    fListEmpty = IsListEmpty(&pMidiPipeInfo->MIDIInActivePinList);

    KeReleaseSpinLock( &pMidiPipeInfo->PipeSpinLock, irql );

    //
    //  USBMIDIInFreePipeInfo( pMidiPipeInfo ) is called upon shutdown of device
    //  or a change in the selected interface
    //

    return ntStatus;
}

NTSTATUS
USBMIDIInAddPinToPipe
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo,
    IN PKSPIN pKsPin
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    BOOL fListEmpty;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pMIDIInPinListEntry =
        AllocMem(NonPagedPool, sizeof(MIDIIN_PIN_LISTENTRY));
    if (!pMIDIInPinListEntry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pMIDIInPinListEntry->pKsPin = pKsPin;

    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );

    fListEmpty = IsListEmpty(&pMIDIPipeInfo->MIDIInActivePinList);

    // Add this pin to the list of ones that are serviceable by this endpoint
    InsertTailList( &pMIDIPipeInfo->MIDIInActivePinList, &pMIDIInPinListEntry->List );

    KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    //  If this is the first Pin added to the pipe, start the data pump
    if (fListEmpty) {
        ntStatus = USBMIDIInStartBulkTransfer( pMIDIPipeInfo );
        if (!NT_SUCCESS(ntStatus)) {
            USBMIDIInRemovePinFromPipe( pMIDIPipeInfo, pKsPin);
        }
    }

    return ntStatus;
}

NTSTATUS
USBMIDIInStreamInit( IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UINT i;

    // Allocate Capture Context
    pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext =
        AllocMem(NonPagedPool, sizeof(MIDIIN_PIN_CONTEXT));
    if (!pMIDIInPinContext)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory( pMIDIInPinContext, sizeof(MIDIIN_PIN_CONTEXT) );

    KsAddItemToObjectBag(pKsPin->Bag, pMIDIInPinContext, FreeMem);

    // Set initial running flag to FALSE
    pMIDIInPinContext->fRunning = FALSE;

    // Set initial running flag to FALSE
    pMIDIInPinContext->fProcessing = FALSE;

    // No bytes copied to stream yet
    pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;

    // Initialize the Event lists
    InitializeListHead( &pMIDIInPinContext->USBMIDIEventQueue );
    InitializeListHead( &pMIDIInPinContext->USBMIDIEmptyEventQueue );

    for ( i=0; i<MIDIIN_EVENTS_PER_PIN; i++) {
        InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pMIDIInPinContext->USBMIDIEventInfo[i].List );
    }

    // Initialize Worker item for turning the Gate on when new data arrives from the device
    ExInitializeWorkItem( &pMIDIInPinContext->GateOnWorkItem,
                          USBMIDIInGateOnWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pMIDIInPinContext->GateOnWorkItem,
                                        &pMIDIInPinContext->GateOnWorkerObject );
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    // Disable Processing on the pin until data is available.
    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    // Get pipe info for this pin
    pMIDIInPinContext->pMIDIPipeInfo = USBMIDIInGetPipeInfo( pKsPin );
    if (!pMIDIInPinContext->pMIDIPipeInfo)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Add new pin to pipe info
    ntStatus = USBMIDIInAddPinToPipe( pMIDIInPinContext->pMIDIPipeInfo, pKsPin );

    return ntStatus;
}

NTSTATUS
USBMIDIInStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInPinContext->pMIDIPipeInfo;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIInStreamClose] pin %d\n",pKsPin->Id));

    KsUnregisterWorker( pMIDIInPinContext->GateOnWorkerObject );

    USBMIDIInRemovePinFromPipe( pMIDIPipeInfo, pKsPin);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\midiout.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       midiout.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define OUTSTANDING_URB_HIGHWATERMARK 10

BYTE
GenerateCodeIndexNumber (
    IN PMIDI_PIN_CONTEXT pMIDIPinContext,
    PBYTE MusicData, // only operate on 3 bytes at a time
    ULONG ulMusicDataBytesLeft,
    PULONG pulBytesUsed,
    BOOL fSysEx,
    BYTE bRunningStatus,
    PBOOL bUsedRunningStatusByte
)
{
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    BYTE StatusByte;
    BYTE CodeIndexNumber = 0xF;  // set it to something
    BYTE RealTimeByte;
    UINT i;

    StatusByte = *MusicData;
    *pulBytesUsed = 0;

    ASSERT(ulMusicDataBytesLeft); // guaranteed that at least one byte is valid
    ASSERT(!pMIDIOutPinContext->ulBytesCached); // there should be no bytes cached at this time

    if (!IS_STATUS(StatusByte) && !fSysEx) {
        StatusByte = bRunningStatus;
        *bUsedRunningStatusByte = TRUE;
    }
    else {
        *bUsedRunningStatusByte = FALSE;
    }

    // Check if any of the three bytes contain EOX making sure that it is ok
    // to touch the data by checking how many bytes are left in the stream
    if ( (ulMusicDataBytesLeft > 1) && IS_EOX( *(MusicData+1) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 2nd byte\n"));
        CodeIndexNumber = 0x6;
        *pulBytesUsed = 2;
    }
    else if ( (ulMusicDataBytesLeft > 2) && IS_EOX( *(MusicData+2) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 3rd byte\n"));
        CodeIndexNumber = 0x7;
        *pulBytesUsed = 3;
    }
    else if ( (ulMusicDataBytesLeft > 1) && IS_REALTIME( *(MusicData+1) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 2nd byte\n"));
        CodeIndexNumber = 0xF;
        *pulBytesUsed = 1;

        // exchange first two bytes
        RealTimeByte = *(MusicData+1);
        *(MusicData+1) = *(MusicData);
        *(MusicData) = RealTimeByte;
    }
    else if ( (ulMusicDataBytesLeft > 2) && IS_REALTIME( *(MusicData+2) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 3rd byte\n"));
        CodeIndexNumber = 0xF;
        *pulBytesUsed = 1;

        // save real time message, slide byte 1 and 2, and restore real time
        // message in vacated byte 1.
        RealTimeByte = *(MusicData+2);
        *(MusicData+2) = *(MusicData+1);
        *(MusicData+1) = *(MusicData);
        *(MusicData) = RealTimeByte;
    }
    else if ( IS_SYSTEM(StatusByte) || IS_DATA_BYTE(StatusByte) || fSysEx ) {
        if (IS_EOX( StatusByte ) || (StatusByte == MIDI_TUNEREQ) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 1st byte\n"));
            CodeIndexNumber = 0x5;
            *pulBytesUsed = 1;
        } else if( IS_REALTIME(StatusByte) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 1st byte\n"));
            CodeIndexNumber = 0xF;
            *pulBytesUsed = 1;
        } else if ( (StatusByte == MIDI_SONGPP) ) {
            // ||   (StatusByte == 0xF4)  // ignore undefined messages for now.
            // ||   (StatusByte == 0xF5) ) {
            CodeIndexNumber = 0x3;
            ASSERT(ulMusicDataBytesLeft >= 3);
            *pulBytesUsed = 3;
        } else if ( (StatusByte == MIDI_MTC) ||
                    (StatusByte == MIDI_SONGS) ) {
            CodeIndexNumber = 0x2;
            *pulBytesUsed = 2;
        }
        // Start or continuation of SysEx
        else if ( fSysEx || IS_SYSEX(StatusByte) || IS_DATA_BYTE(StatusByte) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("SysEx\n"));

            // Store the extra bytes to be played when there is a complete 3-byte sysex
            if (ulMusicDataBytesLeft < 3 ) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("[GenerateCodeIndexNumber] Caching bytes %d\n",
                                             ulMusicDataBytesLeft));
                pMIDIOutPinContext->ulBytesCached = ulMusicDataBytesLeft;
                for (i = 0; i < ulMusicDataBytesLeft; i++) {
                    pMIDIOutPinContext->CachedBytes[i];
                }
                *pulBytesUsed = 0;
            }
            else {
                CodeIndexNumber = 0x4;
                *pulBytesUsed = 3;
            }
        }
        else {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid MIDI Byte %x\n", StatusByte));
            //ASSERT(0);
        }
    }
    else if ( IS_STATUS(StatusByte) ) {
        CodeIndexNumber = StatusByte >> 4;
        if ( (StatusByte < MIDI_PCHANGE) || (StatusByte >= MIDI_PBEND) ) {
            *pulBytesUsed = 3;
        }
        else {
            *pulBytesUsed = 2;
        }

        //  Adjust bytes used because of running status
        if (*bUsedRunningStatusByte) {
            (*pulBytesUsed)--;
        }
    }
    else {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid MIDI Byte %x\n", StatusByte));
        //ASSERT(0);
    }

    //
    //  Cache the running status
    //
    if ( (StatusByte >= MIDI_NOTEOFF) && (StatusByte < MIDI_CLOCK) ) {
        pMIDIOutPinContext->bRunningStatus =
            (BYTE)((StatusByte < MIDI_SYSX) ? StatusByte : 0);
    }

    *pulBytesUsed = min(*pulBytesUsed, ulMusicDataBytesLeft);

    return CodeIndexNumber;
}

USBMIDIEVENTPACKET
CreateUSBMIDIEventPacket (
    IN PMIDI_PIN_CONTEXT pMIDIPinContext,
    LPBYTE pMIDIBytes,
    ULONG ulMusicDataBytesLeft,
    PULONG pulBytesUsed,
    BOOL fSysEx
)
{
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    USBMIDIEVENTPACKET MIDIPacket;
    BYTE bRunningStatus;
    BOOL bUsedRunningStatusByte;
    ULONG ulBytesCached = 0;

    MIDIPacket.RawBytes = 0;

    // Fill in the Cable Number
    MIDIPacket.ByteLayout.CableNumber = (UCHAR)pMIDIPinContext->ulCableNumber;

    // Now time for a little magic.  Since the MusicHdr is no longer important,
    // place the cached bytes over the top of the MusicHdr and reset the head
    // pointer to the cached bytes.
    ASSERT(pMIDIOutPinContext->ulBytesCached <= MAX_NUM_CACHED_MIDI_BYTES);
    if (pMIDIOutPinContext->ulBytesCached > 0 ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("[CreateUSBMIDIEventPacket] Using cached bytes %d\n",
                                     pMIDIOutPinContext->ulBytesCached));

        if (pMIDIOutPinContext->ulBytesCached > 1 ) {
            pMIDIBytes = pMIDIBytes--;
            *pMIDIBytes = pMIDIOutPinContext->CachedBytes[1];
        }

        pMIDIBytes = pMIDIBytes--;
        *pMIDIBytes = pMIDIOutPinContext->CachedBytes[0];

        // keep track of how many bytes were added to the stream.
        ulBytesCached = pMIDIOutPinContext->ulBytesCached;
        pMIDIOutPinContext->ulBytesCached = 0;
    }

    // Grab locally because it is changed in GenerateCodeIndexNumber and we want
    // the original value below
    bRunningStatus = pMIDIOutPinContext->bRunningStatus;

    // Fill in the Code Index Number
    MIDIPacket.ByteLayout.CodeIndexNumber = GenerateCodeIndexNumber(pMIDIPinContext,
                                                                    pMIDIBytes,
                                                                    ulMusicDataBytesLeft,
                                                                    pulBytesUsed,
                                                                    fSysEx,
                                                                    bRunningStatus,
                                                                    &bUsedRunningStatusByte);

    // Fill in the MIDI 1.0 bytes
    if (*pulBytesUsed > 0) {
        UINT i = 0;
        if (bUsedRunningStatusByte) {
            MIDIPacket.ByteLayout.MIDI_0 = bRunningStatus;
        }
        else {
            MIDIPacket.ByteLayout.MIDI_0 = *(pMIDIBytes);
            i++;
        }

        if (*pulBytesUsed > i) {
            MIDIPacket.ByteLayout.MIDI_1 = *(pMIDIBytes+i);
            i++;

            if (*pulBytesUsed > i) {
                MIDIPacket.ByteLayout.MIDI_2 = *(pMIDIBytes+i);
            }
        }
    }

    // don't report the cached bytes as used
    *pulBytesUsed = *pulBytesUsed - ulBytesCached;

    _DbgPrintF( DEBUGLVL_BLAB, ("MIDIEventPacket = 0x%08lx, ulBytesUsed = 0x%08lx\n",
                                  MIDIPacket, *pulBytesUsed));
    return MIDIPacket;
}

NTSTATUS
USBMIDIBulkCompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    PURB pUrb = pKsStreamPtr->Context;
    KIRQL irql;
    NTSTATUS ntStatus;

    ntStatus = pIrp->IoStatus.Status;
    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF( DEBUGLVL_BLAB, ("[USBMIDIBulkCompleteCallback] ntStatus = 0x%08lx\n", ntStatus));
    }

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    } else if (pPinContext->ulOutstandingUrbCount < OUTSTANDING_URB_HIGHWATERMARK) {
        KeSetEvent( &pMIDIOutPinContext->PinSaturationEvent, 0, FALSE );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    // Free our URB storage, decend the links
    while (pUrb) {
        PURB pUrbNext;

        pUrbNext = pUrb->UrbBulkOrInterruptTransfer.UrbLink;
        FreeMem(pUrb->UrbBulkOrInterruptTransfer.TransferBuffer); // pUSBMIDIEventPacket;
        FreeMem(pUrb);
        pUrb = pUrbNext;
    }

    // Free Irp
    IoFreeIrp( pIrp );

    // Delete the cloned stream pointer
    KsStreamPointerDelete( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

PURB CreateMIDIBulkUrb(
    PPIN_CONTEXT pPinContext,
    ULONG TransferDirection,
    PUSBMIDIEVENTPACKET pUSBMIDIEventPacket
)
{
    PURB pUrb;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

    pUrb = AllocMem( NonPagedPool, ulUrbSize );
    if (!pUrb) {
        return pUrb;
    }

    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pPinContext->hPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = TransferDirection;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pUSBMIDIEventPacket;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int) pPinContext->ulMaxPacketSize;

    DbgLog("MOData", *((LPDWORD)pUSBMIDIEventPacket),
                     *((LPDWORD)pUSBMIDIEventPacket+1),
                     *((LPDWORD)pUSBMIDIEventPacket+2),
                     *((LPDWORD)pUSBMIDIEventPacket+3) );
    DbgLog("MOData1", *((LPDWORD)pUSBMIDIEventPacket+4),
                      *((LPDWORD)pUSBMIDIEventPacket+5),
                      *((LPDWORD)pUSBMIDIEventPacket+6),
                      *((LPDWORD)pUSBMIDIEventPacket+7) );
    DbgLog("MOData2", *((LPDWORD)pUSBMIDIEventPacket+8),
                      *((LPDWORD)pUSBMIDIEventPacket+9),
                      *((LPDWORD)pUSBMIDIEventPacket+10),
                      *((LPDWORD)pUSBMIDIEventPacket+11) );
    DbgLog("MOData3", *((LPDWORD)pUSBMIDIEventPacket+12),
                      *((LPDWORD)pUSBMIDIEventPacket+13),
                      *((LPDWORD)pUSBMIDIEventPacket+14),
                      *((LPDWORD)pUSBMIDIEventPacket+15) );

    return pUrb;
}

NTSTATUS
SendBulkMIDIRequest(
    IN PKSSTREAM_POINTER pKsStreamPtr,
    PKSMUSICFORMAT MusicHdr,
    PULONG pulBytesConsumed
)
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    PKSSTREAM_POINTER pKsCloneStreamPtr;
    PUSBMIDIEVENTPACKET pUSBMIDIEventPacket;
    ULONG ulPacketSize;
    ULONG ulPacketOffset;
    LPBYTE pMIDIBytes;
    ULONG ulBytesUsedForPacket;
    ULONG ulBytesConsumedInStream = sizeof(KSMUSICFORMAT);
    ULONG ulBytesLeftInMusicHdr;
    BOOL bSysEx = FALSE;
    PIO_STACK_LOCATION nextStack;
    PURB pUrb;
    PIRP pIrp;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Initial value
    *pulBytesConsumed = 0;

    // Get a pointer to the MIDI data
    pMIDIBytes = (LPBYTE)(MusicHdr+1);
    ulBytesLeftInMusicHdr = MusicHdr->ByteCount;

    ASSERT(ulBytesLeftInMusicHdr < 0xFFFF0000);  // sanity check for now

    _DbgPrintF( DEBUGLVL_BLAB, ("ulBytesLeft = 0x%08lx\n",ulBytesLeftInMusicHdr));
    while (ulBytesLeftInMusicHdr) {

        if ( !NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ulPacketSize = pPinContext->ulMaxPacketSize;
        ulPacketOffset = 0;

        // Allocate USBMIDI Event Packet
        pUSBMIDIEventPacket = AllocMem( NonPagedPool, ulPacketSize );
        if ( !pUSBMIDIEventPacket ) {
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(pUSBMIDIEventPacket, ulPacketSize);

        while (ulPacketSize && ulBytesLeftInMusicHdr) {
            *(pUSBMIDIEventPacket+ulPacketOffset) =
                                   CreateUSBMIDIEventPacket( pMIDIPinContext,
                                                             pMIDIBytes,
                                                             ulBytesLeftInMusicHdr,
                                                             &ulBytesUsedForPacket,
                                                             bSysEx );

            // Must be an error in the stream or can't get enough sysex data for a 3-byte message
            if (!ulBytesUsedForPacket) {
                KsStreamPointerDelete( pKsCloneStreamPtr );
                FreeMem(pUSBMIDIEventPacket);
                IoFreeIrp(pIrp);
                return STATUS_SUCCESS;
            }

            // Update USB MIDI packet offsets
            ulPacketOffset++;
            ulPacketSize -= sizeof(USBMIDIEVENTPACKET);

            // Update the stream position
            pMIDIBytes += ulBytesUsedForPacket;
            ulBytesConsumedInStream += ulBytesUsedForPacket;
            ulBytesLeftInMusicHdr -= min(ulBytesUsedForPacket,ulBytesLeftInMusicHdr);
            _DbgPrintF( DEBUGLVL_BLAB, ("ulBytesLeft = 0x%08lx\n",ulBytesLeftInMusicHdr));

            ASSERT(ulBytesLeftInMusicHdr < 0xFFFF0000);  // sanity check for now

            // If there are bytes left we must be in SysEx mode
            bSysEx = TRUE;
        }

        pUrb = CreateMIDIBulkUrb(pPinContext, USBD_TRANSFER_DIRECTION_OUT, pUSBMIDIEventPacket);
        if ( !pUrb ) {
            FreeMem(pUSBMIDIEventPacket);
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        pKsCloneStreamPtr->Context = pUrb;

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        nextStack = IoGetNextIrpStackLocation(pIrp);
        ASSERT(nextStack != NULL);

        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = pUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

        // failure to allocate, clean up and return failure
        if (!pUSBMIDIEventPacket || !pUrb) {
            pUrb = nextStack->Parameters.Others.Argument1;
            while (pUrb) {
                PURB pUrbNext;

                pUrbNext = pUrb->UrbBulkOrInterruptTransfer.UrbLink;
                FreeMem(pUrb->UrbBulkOrInterruptTransfer.TransferBuffer); // pUSBMIDIEventPacket;
                FreeMem(pUrb);
                pUrb = pUrbNext;
            }
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        _DbgPrintF( DEBUGLVL_BLAB, ("Pipe = 0x%08lx, pUrb = 0x%08lx\n",
                                      pUrb->UrbBulkOrInterruptTransfer.PipeHandle,
                                      nextStack->Parameters.Others.Argument1));

        IoSetCompletionRoutine ( pIrp, USBMIDIBulkCompleteCallback, pKsCloneStreamPtr, TRUE, TRUE, TRUE );

        InterlockedIncrement( &pPinContext->ulOutstandingUrbCount );

        ntStatus = IoCallDriver( pPinContext->pNextDeviceObject, pIrp );
        if (NT_ERROR(ntStatus)) {
            _DbgPrintF( DEBUGLVL_TERSE, ("SendBulkMIDIRequest failed with status 0x%08lx\n",ntStatus));
            return ntStatus;
        }

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
        if (pPinContext->ulOutstandingUrbCount >= OUTSTANDING_URB_HIGHWATERMARK) {
            KeResetEvent( &pMIDIOutPinContext->PinSaturationEvent );
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            DbgLog("MOWait", pPinContext, pPinContext->ulOutstandingUrbCount, 0, 0 );

            KeWaitForSingleObject( &pMIDIOutPinContext->PinSaturationEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }

    }  // while (ulBytesLeftInMusicHdr)

    *pulBytesConsumed = ulBytesConsumedInStream;

    return ntStatus;
}

NTSTATUS
USBMIDIOutProcessStreamPtr( IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PKSMUSICFORMAT MusicHdr;
    ULONG ulMusicFrameSize;
    ULONG ulBytesConsumed;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Get the next Stream pointer from queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIOutProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    // Get a pointer to the data information from the stream pointer
    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;

    while ( pKsStreamPtrOffsetIn->Remaining > sizeof(KSMUSICFORMAT) ) {

        // Clone Stream pointer to keep queue moving.
        if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {

            MusicHdr = (PKSMUSICFORMAT)pKsStreamPtrOffsetIn->Data;
            ulMusicFrameSize = sizeof(KSMUSICFORMAT) + ((MusicHdr->ByteCount + 3) & ~3);

            if (pKsStreamPtrOffsetIn->Count < sizeof(KSMUSICFORMAT)) {
                _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] not enough data for PKSMUSICFORMAT\n"));
                KsStreamPointerDelete( pKsCloneStreamPtr );
                break;
            }
            else {
                // Consume as much of this MusicHdr as possible
                ntStatus = SendBulkMIDIRequest( pKsCloneStreamPtr,
                                                MusicHdr,
                                                &ulBytesConsumed ); // including KSMUSICFORMAT
            }

            DbgLog("MOProc", pKsCloneStreamPtr, MusicHdr, ulBytesConsumed, ulMusicFrameSize);

            // All bytes of this music header are consumed, move on to the
            // next music header
            if (ulMusicFrameSize == ((ulBytesConsumed + 3) & ~3) ) {
                pKsStreamPtrOffsetIn->Remaining -= ulMusicFrameSize;
                pKsStreamPtrOffsetIn->Data += ulMusicFrameSize;
            }
            else {
                _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] All bytes of this music header were not consumed\n"));
                //ASSERT(0); // shouldn't get here, but we should continue
                pKsStreamPtrOffsetIn->Remaining -= ulMusicFrameSize;
                pKsStreamPtrOffsetIn->Data += ulMusicFrameSize;
            }

            // Delete the stream pointer to release the buffer.
            KsStreamPointerDelete( pKsCloneStreamPtr );

        }
        else {
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] couldn't allocate clone\n"));
            break;
        }
    }

    // Unlock the stream pointer. This will really only unlock after last clone is deleted.
    KsStreamPointerUnlock( pKsStreamPtr, TRUE );

    return ntStatus;
}

NTSTATUS
USBMIDIOutStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] NewKsState: %d\n", NewKsState));

    switch(NewKsState) {
        case KSSTATE_STOP:
            USBMIDIOutPinWaitForStarvation( pKsPin );
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] Finished Stop\n"));
            break;

        case KSSTATE_ACQUIRE:
        case KSSTATE_PAUSE:
            USBMIDIOutPinWaitForStarvation( pKsPin );
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] Finished Acquire or Pause\n"));
            break;
        case KSSTATE_RUN:
        default:
            break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIOutStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;

    pMIDIPinContext->pMIDIOutPinContext = AllocMem( NonPagedPool, sizeof(MIDIOUT_PIN_CONTEXT));
    if ( !pMIDIPinContext->pMIDIOutPinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pMIDIPinContext->pMIDIOutPinContext, FreeMem);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pMIDIPinContext->pMIDIOutPinContext->PinSaturationEvent, NotificationEvent, FALSE );

    // Initialize the MIDI byte cache and running status
    pMIDIPinContext->pMIDIOutPinContext->ulBytesCached = 0;
    pMIDIPinContext->pMIDIOutPinContext->bRunningStatus = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIOutStreamClose( PKSPIN pKsPin )
{
    KIRQL irql;
    PPIN_CONTEXT pPinContext = pKsPin->Context;

    PAGED_CODE();

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStreamClose] Finished closing pin (%x)\n",pKsPin));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\nameguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       nameguid.h
//
//--------------------------------------------------------------------------


#define STATIC_USBNODENAME_BassBoost \
    0x1A71EBE0L, 0x959E, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1

#define STATIC_USBNODENAME_StereoExtender \
    0xFD4F0300L, 0x9632, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\parsedsc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       parsedsc.c
//
//--------------------------------------------------------------------------

#include "common.h"


PUSB_INTERFACE_DESCRIPTOR
GetNextAudioInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    ULONG ulInterfaceNumber;

    // IF descriptor is NULL there are no more beyond it.
    if ( !pInterfaceDescriptor ) return NULL;

    // Remember the InterfaceNumber
    ulInterfaceNumber = pInterfaceDescriptor->bInterfaceNumber;

    // Advance to the next one
    pInterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)
            ((PUCHAR)pInterfaceDescriptor + pInterfaceDescriptor->bLength);

    // Get the next audio descriptor for this InterfaceNumber
    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pInterfaceDescriptor,
                           ulInterfaceNumber,      // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           -1,                     // Interface Sub-Class
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    return ( pInterfaceDescriptor );
}

PUSB_INTERFACE_DESCRIPTOR
GetFirstAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PAUDIO_HEADER_UNIT pHeader;

    // Get the first control interface
    pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        pConfigurationDescriptor,
                        -1,        // interface number
                        -1,        //  (Alternate Setting)
                        USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                        -1 );

    if ( !pControlInterface ) return NULL;

    pHeader = (PAUDIO_HEADER_UNIT)
                  GetAudioSpecificInterface( pConfigurationDescriptor,
                                             pControlInterface,
                                             HEADER_UNIT);
    if ( !pHeader ) return NULL;

    // Get the first audio descriptor for this InterfaceNumber
    // Remember: the InterfaceNumber is virtual: we only include audio streaming interfaces!
    while ( ulInterfaceNumber >= pHeader->bInCollection ) {

        ulInterfaceNumber -= pHeader->bInCollection;

        // Get Next Control Interface
        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        (PUCHAR)pControlInterface + pControlInterface->bLength,
                        -1,                      // Interface number
                        -1,                      // Alternate Setting
                        USB_DEVICE_CLASS_AUDIO,  // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,  // control subclass (Interface Sub-Class)
                        -1 );

        if ( !pControlInterface ) return NULL;

        pHeader = (PAUDIO_HEADER_UNIT)
                   GetAudioSpecificInterface( pConfigurationDescriptor,
                                              pControlInterface,
                                              HEADER_UNIT);
        if ( !pHeader ) return NULL;
    }

    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           pHeader->baInterfaceNr[ulInterfaceNumber], // Interface number
                           -1,                       // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO,   // Audio Class (Interface Class)
                           AUDIO_SUBCLASS_STREAMING, // Stream subclass (Interface Sub-Class)
                           -1 ) ;                    // protocol don't care (InterfaceProtocol)

    return ( pInterfaceDescriptor );
}

PAUDIO_SPECIFIC
GetAudioSpecificInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    LONG lDescriptorSubtype )
{
    PAUDIO_SPECIFIC pDescriptor;

    // Find the stream descriptor for this interface and subtype
    pDescriptor = (PAUDIO_SPECIFIC)pInterfaceDescriptor;

    // Get the next audio interface descriptor.
    pInterfaceDescriptor =
         GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );

    do {
        pDescriptor = (PAUDIO_SPECIFIC)
            USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PUCHAR)pDescriptor + pDescriptor->bLength,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        if (pDescriptor == NULL ||
            (pInterfaceDescriptor && pDescriptor > ((PAUDIO_SPECIFIC)pInterfaceDescriptor)))
            return NULL;
    } while (lDescriptorSubtype != -1L &&
           pDescriptor->bDescriptorSubtype != lDescriptorSubtype);

    return pDescriptor;
}

PUSB_ENDPOINT_DESCRIPTOR
GetEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    BOOLEAN fGetAudioSpecificEndpoint )
{
    PUSB_INTERFACE_DESCRIPTOR pDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR  pEndpointDescriptor;
    ULONG DescriptorType =
        USB_ENDPOINT_DESCRIPTOR_TYPE | ((fGetAudioSpecificEndpoint) ? USB_CLASS_AUDIO : 0);

    // Get the next audio interface descriptor to check boundry
    pDescriptor = GetNextAudioInterface( pConfigurationDescriptor,
                                         pInterfaceDescriptor);

    pEndpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)
           USBD_ParseDescriptors( pConfigurationDescriptor,
                                  pConfigurationDescriptor->wTotalLength ,
                                  (PVOID) pInterfaceDescriptor,
                                  DescriptorType );

    if ( pEndpointDescriptor )
        if (pDescriptor && ((PVOID)pEndpointDescriptor > (PVOID)pDescriptor))
           pEndpointDescriptor = NULL;

    return pEndpointDescriptor;
}

PUSB_ENDPOINT_DESCRIPTOR
GetSyncEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    PUSB_ENDPOINT_DESCRIPTOR pSyncEPDescriptor = NULL;
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pDescriptor;
    ULONG ulSyncEndpointAddr;

    // Get the next audio interface descriptor to check boundry
    pDescriptor = GetNextAudioInterface( pConfigurationDescriptor,
                                         pInterfaceDescriptor);
    pEndpointDescriptor =
        GetEndpointDescriptor( pConfigurationDescriptor,
                               pInterfaceDescriptor,
                               FALSE );

    if ( pEndpointDescriptor  &&
       (( pEndpointDescriptor->bmAttributes & EP_SYNC_TYPE_MASK) == EP_ASYNC_SYNC_TYPE )) {
        ulSyncEndpointAddr = (ULONG)
           ((PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pEndpointDescriptor)->bSynchAddress;

        // Hack to get old DalSemi devices to work.
        ulSyncEndpointAddr |= 0x80;

        pSyncEPDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)
            USBD_ParseDescriptors( pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength ,
                                   (PUCHAR)pEndpointDescriptor + pEndpointDescriptor->bLength,
                                   USB_ENDPOINT_DESCRIPTOR_TYPE );
        if (pSyncEPDescriptor &&
           ((ULONG)pSyncEPDescriptor->bEndpointAddress == ulSyncEndpointAddr) ) {
            if (pDescriptor && ((PVOID)pSyncEPDescriptor > (PVOID)pDescriptor))
               pSyncEPDescriptor = NULL;
        }
        else
            pSyncEPDescriptor = NULL;
    }

    return pSyncEPDescriptor;
}


ULONG
GetMaxPacketSizeForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;

    pEndpointDescriptor = GetEndpointDescriptor( pConfigurationDescriptor,
                                                 pInterfaceDescriptor,
                                                 FALSE );

    if ( pEndpointDescriptor ) {
        return( (ULONG)pEndpointDescriptor->wMaxPacketSize );
    }
    else {
        return 0;
    }

}


PAUDIO_UNIT
GetUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitId )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PAUDIO_UNIT pUnit = NULL;
    ULONG fUnitFound = FALSE;

    // Starting at the configuration descriptor, find the control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor && !fUnitFound ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( pUnit && (pUnit->bUnitID != ulUnitId )) {
                pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
                if ((PUCHAR)pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength))
                    pUnit = NULL;
            }
            if ( pUnit && (pUnit->bUnitID == ulUnitId )) {
                fUnitFound = TRUE;
            }
        }
        if ( !fUnitFound )
            pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return pUnit;
}


BOOLEAN
IsSupportedFormat(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    BOOLEAN fSupported = FALSE;
    PAUDIO_CLASS_STREAM pAudioDescriptor;
    PAUDIO_GENERAL_STREAM pGeneralDescriptor = (PAUDIO_GENERAL_STREAM)
                GetAudioSpecificInterface( pConfigurationDescriptor,
                                           pInterfaceDescriptor,
                                           AS_GENERAL);

    if ( pGeneralDescriptor ) {
        switch ( pGeneralDescriptor->wFormatTag ) {
            case USBAUDIO_DATA_FORMAT_PCM:
                // Find the format-specific descriptor
                pAudioDescriptor = (PAUDIO_CLASS_STREAM)
                    USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID)((PUCHAR)pGeneralDescriptor + pGeneralDescriptor->bLength),
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

                if ( pAudioDescriptor && (pAudioDescriptor->bBitsPerSample != 8))
                    fSupported = TRUE;
                break;
            case USBAUDIO_DATA_FORMAT_PCM8:
            case USBAUDIO_DATA_FORMAT_IEEE_FLOAT:
            case USBAUDIO_DATA_FORMAT_ALAW:
            case USBAUDIO_DATA_FORMAT_MULAW:
            case USBAUDIO_DATA_FORMAT_MPEG:
            case USBAUDIO_DATA_FORMAT_AC3:
                fSupported = TRUE;
                break;
            default:
                break;
        }
    }

    return fSupported;

}


BOOLEAN
IsZeroBWInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    BOOLEAN ZeroBWFound = FALSE;

    if ( (ULONG)pInterfaceDescriptor->bNumEndpoints == 0 ) {
        ZeroBWFound = TRUE;
    }
    else if ( (ULONG)pInterfaceDescriptor->bNumEndpoints == 1 ) {
        ULONG MaxPacketSize =
               GetMaxPacketSizeForInterface( pConfigurationDescriptor,
                                             pInterfaceDescriptor );

        if ( !MaxPacketSize ) ZeroBWFound = TRUE;
    }

    return ZeroBWFound;
}

ULONG
CountTerminalUnits(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pAudioBridgePinCount,
    PULONG pMIDIPinCount,
    PULONG pMIDIBridgePinCount)
{
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PAUDIO_HEADER_UNIT pHeader;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    ULONG ulAudioBridgePinCount = 0;
    ULONG ulMIDIBridgePinCount = 0;
    ULONG ulAudioPinCount = 0;
    ULONG ulMIDIPinCount = 0;


    // Starting at the configuration descriptor, find the first audio interface.
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           -1,                     // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           -1,                     // any subclass (Interface Sub-Class)
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pAudioInterface ) {
        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_CONTROL:

                _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Found AudioControl at %x\n",pAudioInterface));
                if ( pHeader = (PAUDIO_HEADER_UNIT)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pHeader,
                                               pHeader->wTotalLength,
                                               ((PUCHAR)pHeader + pHeader->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case INPUT_TERMINAL:
                            case OUTPUT_TERMINAL:
                                if ( u.pInput->wTerminalType != USB_Streaming) {
                                   ulAudioBridgePinCount++;
                                }
                                ulAudioPinCount++;
                                break;

                            default:
                                break;
                        }

                        u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                        if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                            u.pUnit = NULL;
                        }
                    }
                }
                break;
            case AUDIO_SUBCLASS_MIDISTREAMING:

                _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Found MIDIStreaming at %x\n",pAudioInterface));

                if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                               pGeneralMIDIStreamDescriptor->wTotalLength,
                                               ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case MIDI_IN_JACK:
                            case MIDI_OUT_JACK:
                                if ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) {
                                   ulMIDIBridgePinCount++;
                                }
                                ulMIDIPinCount++;
                                ulAudioPinCount++;
                                break;

                            case MIDI_ELEMENT:
                                break;

                            default:
                                break;
                        }

                        // Find the next unit.
                        u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                            (PVOID) pGeneralMIDIStreamDescriptor,
                                            pGeneralMIDIStreamDescriptor->wTotalLength,
                                            (PUCHAR)u.pUnit + u.pUnit->bLength,
                                            USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    }
                }
                break;
            case AUDIO_SUBCLASS_STREAMING:
                break;
            default:
                break;
        }

        // pAudioInterface = GetNextAudioInterface(pConfigurationDescriptor, pAudioInterface);

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Next audio interface at %x\n",pAudioInterface));
    }

    if ( pAudioBridgePinCount )
        *pAudioBridgePinCount = ulAudioBridgePinCount;

    if ( pMIDIPinCount )
        *pMIDIPinCount = ulMIDIPinCount;

    if ( pMIDIBridgePinCount )
        *pMIDIBridgePinCount = ulMIDIBridgePinCount;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] AudioBridge=%d MIDIPin=%d MIDIBridgePin=%d\n",
                                 ulAudioBridgePinCount,
                                 ulMIDIPinCount,
                                 ulMIDIBridgePinCount));

    return ulAudioPinCount;
}


ULONG
CountFormatsForAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    ULONG ulCount = 0;

    pInterfaceDescriptor =
        GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    while ( pInterfaceDescriptor ) {
        if ( !IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) &&
              IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor )) {
            ulCount++;
        }
        pInterfaceDescriptor =
            GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
    }

    return ulCount;
}

ULONG
CountInputChannels(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitID )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_MIXER_UNIT pSourceMixer;
        PAUDIO_PROCESSING_UNIT pProcess;
        PAUDIO_EXTENSION_UNIT pExtension;
        PAUDIO_FEATURE_UNIT pFeature;
        PAUDIO_SELECTOR_UNIT pSelector;
    } u;
    ULONG ulChannels = 0;

    // we walk the stream to discover the number of input channels.
    u.pUnit = GetUnit(pConfigurationDescriptor, ulUnitID);
    while (u.pUnit) {
        switch (u.pUnit->bDescriptorSubtype) {
            case INPUT_TERMINAL:
                ulChannels = u.pInput->bNrChannels;
                return ulChannels;

            case MIXER_UNIT:
                ulChannels = *(u.pSourceMixer->baSourceID + u.pSourceMixer->bNrInPins);
                return ulChannels;

            case SELECTOR_UNIT:
                // NOTE: This assumes all inputs have the same number of channels!
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pSelector->baSourceID[0]);
                break;

            case FEATURE_UNIT:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pFeature->bSourceID);
                break;

            case PROCESSING_UNIT:
                ulChannels = *(u.pProcess->baSourceID + u.pProcess->bNrInPins);
                return ulChannels;

            case EXTENSION_UNIT:
                ulChannels = *(u.pExtension->baSourceID + u.pExtension->bNrInPins);
                return ulChannels;

            default:
                u.pUnit = NULL;
                break;
            }
        }

    return ulChannels;
}


VOID
ConvertInterfaceToDataRange(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PUSBAUDIO_DATARANGE pUSBAudioDataRange
    )
{
    PKSDATARANGE_AUDIO pKsAudioRange = &pUSBAudioDataRange->KsDataRangeAudio;
    PAUDIO_CLASS_STREAM  pAudioDescriptor = NULL;
    PAUDIO_GENERAL_STREAM pGeneralDescriptor;
    ULONG SampleRate;
    ULONG i;

    // Find the general stream descriptor for this interface
    pGeneralDescriptor = (PAUDIO_GENERAL_STREAM)
            GetAudioSpecificInterface( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       AS_GENERAL );

    if ( pGeneralDescriptor) {

       // Find the format-specific descriptor
       pAudioDescriptor = (PAUDIO_CLASS_STREAM)
           USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                  pConfigurationDescriptor->wTotalLength,
                                  (PVOID) ((PUCHAR)pGeneralDescriptor + pGeneralDescriptor->bLength),
                                  USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

    }

    if (!pAudioDescriptor)
        return;

    pUSBAudioDataRange->pAudioDescriptor = pAudioDescriptor;
    pUSBAudioDataRange->ulUsbDataFormat  = (ULONG)pGeneralDescriptor->wFormatTag;

    // Create the KSDATARANGE_AUDIO structure
    pKsAudioRange->DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
    pKsAudioRange->DataRange.Reserved   = 0;
    pKsAudioRange->DataRange.Flags      = 0;
    pKsAudioRange->DataRange.SampleSize = 0;
    pKsAudioRange->DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO; // Everything is Audio.
    pKsAudioRange->DataRange.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    // Map the USB format to a KS sub-format, if possible.
    switch ( pGeneralDescriptor->wFormatTag ) {
        case USBAUDIO_DATA_FORMAT_PCM8:
        case USBAUDIO_DATA_FORMAT_PCM:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;         break;
        case USBAUDIO_DATA_FORMAT_IEEE_FLOAT:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;  break;
        case USBAUDIO_DATA_FORMAT_ALAW:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_ALAW;        break;
        case USBAUDIO_DATA_FORMAT_MULAW:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MULAW;       break;
        case USBAUDIO_DATA_FORMAT_MPEG:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MPEG;        break;
        case USBAUDIO_DATA_FORMAT_AC3:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_AC3_AUDIO;   break;
        default:
            // This USB format does not map to a sub-format!
            pKsAudioRange->DataRange.SubFormat = GUID_NULL;                        break;
    }

    // Fill-in the correct data for the specified WAVE format.
    switch( pGeneralDescriptor->wFormatTag & USBAUDIO_DATA_FORMAT_TYPE_MASK) {
        case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
            // Fill in the audio range information
            pKsAudioRange->MaximumChannels      = pAudioDescriptor->bNumberOfChannels;
            pKsAudioRange->MinimumBitsPerSample = pAudioDescriptor->bSlotSize<<3;
            pKsAudioRange->MaximumBitsPerSample = pAudioDescriptor->bSlotSize<<3;
            pKsAudioRange->MinimumSampleFrequency =
                         pAudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                  256L * pAudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                65536L * pAudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            pKsAudioRange->MaximumSampleFrequency = pKsAudioRange->MinimumSampleFrequency;

            if ( pAudioDescriptor->bSampleFreqType == 0 ) {
                // Continuous range of sampling rates
                pKsAudioRange->MaximumSampleFrequency =
                                pAudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                         256L * pAudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                       65536L * pAudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            }

            if ( pAudioDescriptor->bSampleFreqType > 1 ) {
                // Series of sampling rates
                // We convert this to a range by finding the min and max
                for (i=0; i<pAudioDescriptor->bSampleFreqType; i++) {
                    SampleRate = pAudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                          256L * pAudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                        65536L * pAudioDescriptor->pSampleRate[i].bSampleFreqByte3;

                       if (SampleRate < pKsAudioRange->MinimumSampleFrequency)
                           pKsAudioRange->MinimumSampleFrequency = SampleRate;

                       if (SampleRate > pKsAudioRange->MaximumSampleFrequency)
                           pKsAudioRange->MaximumSampleFrequency = SampleRate;
                }
            }
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
            // NOTE: The Type II format hardcoded to match DShow AC-3
            pKsAudioRange->MaximumChannels = 6;
            pKsAudioRange->MinimumBitsPerSample = 0;
            pKsAudioRange->MaximumBitsPerSample = 0;
            pKsAudioRange->MinimumSampleFrequency = 48000L;
            pKsAudioRange->MaximumSampleFrequency = 48000L;
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            // TODO: Support Type III formats
            break;
        default:
            // This USB format does not map to a WAVE format!
            break;
    }
}

VOID
CountTopologyComponents(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulNumChannels;
    ULONG bmControls;
    ULONG bmMergedControls;
    ULONG i, j;

    // Initialize Values
    *pNumCategories  = 0;
    *pNumNodes       = 0;
    *pNumConnections = 0;
    *pbmCategories   = 0;

    // Starting at the configuration descriptor, find the first control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                    case OUTPUT_TERMINAL:
                        (*pNumNodes)++;
                        (*pNumConnections)++;

                        // Input and Output terminals map the same way for this value.
                        if ( u.pInput->wTerminalType != USB_Streaming) {
                           (*pNumConnections)++;
                        }
                        else if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                            (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                            (*pNumCategories)++;
                        }
                        break;

                    case FEATURE_UNIT:
                        ulNumChannels = CountInputChannels( pConfigurationDescriptor,
                                                            u.pUnit->bUnitID );

                        bmMergedControls = 0;
                        for (i=0; i<=ulNumChannels; i++) {
                            bmControls = 0;
                            for (j=u.pFeature->bControlSize; j>0; j--) {
                                bmControls <<= 8;
                                bmControls |= u.pFeature->bmaControls[i*u.pFeature->bControlSize+j-1];
                            }

                            bmMergedControls |= bmControls;
                        }

                        // Count the nodes and connections
                        while (bmMergedControls) {
                            bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                            (*pNumConnections)++;
                            (*pNumNodes)++;
                        }
                        break;

                    case MIXER_UNIT:
                        // The mixer unit always generates N+1 nodes and 2*N connections
                        (*pNumNodes) += u.pMixer->bNrInPins + 1;
                        (*pNumConnections) += 2*u.pMixer->bNrInPins;
                        break;

                    case SELECTOR_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pSelector->bNrInPins;
                        break;

                    case PROCESSING_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pProcess->bNrInPins;
                        break;

                    case EXTENSION_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pExtension->bNrInPins;
                        break;

                    default:
                        break;
                }

                u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                    u.pUnit = NULL;
                }
            }
        }

        pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    // Now that we have had fun with audio, let's try MIDI
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pMIDIStreamingDescriptor ) {
        if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pMIDIStreamingDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                       pGeneralMIDIStreamDescriptor->wTotalLength,
                                       ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case MIDI_IN_JACK:
                        if ( u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                            if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                                (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                                (*pNumCategories)++;
                            }
                        }
                        break;
                    case MIDI_OUT_JACK:
                        (*pNumConnections) += u.pMIDIOutJack->bNrInputPins;

                        if ( u.pMIDIOutJack->bJackType == JACK_TYPE_EMBEDDED) {
                            if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                                (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                                (*pNumCategories)++;
                            }
                        }
                        break;

                    case MIDI_ELEMENT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pMIDIElement->bNrInputPins +
                            u.pMIDIElement->baSourceConnections[u.pMIDIElement->bNrInputPins].SourceID;
                        break;

                    default:
                        break;
                }

                // Find the next unit.
                u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                    (PVOID) pGeneralMIDIStreamDescriptor,
                                    pGeneralMIDIStreamDescriptor->wTotalLength,
                                    (PUCHAR)u.pUnit + u.pUnit->bLength,
                                    USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            }
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }
}

KSPIN_DATAFLOW
GetDataFlowDirectionForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR  pEndpointDescriptor;
    KSPIN_DATAFLOW KsPinDataFlow = KSPIN_DATAFLOW_IN;

    pInterfaceDescriptor =
            GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    while ( pInterfaceDescriptor &&
          ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
           !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
       pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
    }

    pEndpointDescriptor = GetEndpointDescriptor( pConfigurationDescriptor,
                                                 pInterfaceDescriptor,
                                                 FALSE );

    if ( pEndpointDescriptor &&
       ( pEndpointDescriptor->bEndpointAddress & USB_ENDPOINT_DIRECTION_MASK)) {
        KsPinDataFlow = KSPIN_DATAFLOW_OUT;
    }

    return KsPinDataFlow;
}

KSPIN_DATAFLOW
GetDataFlowDirectionForMIDIInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulPinNumber,
    BOOL fBridgePin )
{
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    KSPIN_DATAFLOW KsPinDataFlow = KSPIN_DATAFLOW_IN;
    ULONG ulMIDIBridgePinCount = 0;
    ULONG ulMIDIStreamingPinCount = 0;

    union {
        PAUDIO_UNIT                 pUnit;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    // Starting at the configuration descriptor, find the first MIDI interface.
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pMIDIStreamingDescriptor ) {
        if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pMIDIStreamingDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                       pGeneralMIDIStreamDescriptor->wTotalLength,
                                       ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case MIDI_IN_JACK:
                    case MIDI_OUT_JACK:
                        if (fBridgePin) {
                            if ( (ulPinNumber == ulMIDIBridgePinCount) &&
                                 ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) ) {
                                return (u.pUnit->bDescriptorSubtype == MIDI_IN_JACK) ? KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
                            }
                        } else {  // Looking for a Streaming Pin
                            if ( (ulPinNumber == ulMIDIStreamingPinCount) &&
                                 ( u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) ) {
                                return (u.pUnit->bDescriptorSubtype == MIDI_IN_JACK) ? KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
                            }
                        }

                        if ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) {
                           ulMIDIBridgePinCount++;
                        } else {
                           ulMIDIStreamingPinCount++;
                        }
                        break;

                    case MIDI_ELEMENT:
                        break;

                    default:
                        break;
                }


                // Find the next unit.
                u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                    (PVOID) pGeneralMIDIStreamDescriptor,
                                    pGeneralMIDIStreamDescriptor->wTotalLength,
                                    (PUCHAR)u.pUnit + u.pUnit->bLength,
                                    USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            }
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    ASSERT(0);  // should only get here if the MIDI interface is not found
    return KsPinDataFlow;
}

PAUDIO_UNIT
GetTerminalUnitForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    ULONG ulTerminalLinkId = 0xFFFFFFFF;
    PAUDIO_UNIT pUnit = NULL;

    PAUDIO_GENERAL_STREAM pGeneralDescriptor =
               (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                                        pConfigurationDescriptor,
                                                        pInterfaceDescriptor,
                                                        AS_GENERAL);

    if ( pGeneralDescriptor ){
        ulTerminalLinkId = (ULONG)pGeneralDescriptor->bTerminalLink;
        pUnit = GetUnit( pConfigurationDescriptor, ulTerminalLinkId );
    }

    return pUnit;
}

PAUDIO_UNIT
GetTerminalUnitForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PAUDIO_UNIT pUnit = NULL;
    BOOLEAN fFound = FALSE;
    ULONG ulBridgePinCount = 0;

    // Starting at the configuration descriptor, find the control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor && !fFound ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( pUnit && !fFound ) {
                switch (pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                        if ( ((PAUDIO_INPUT_TERMINAL)pUnit)->wTerminalType != USB_Streaming) {
                            if ( ulBridgePinCount++ == ulBridgePinNumber ) {
                                fFound = TRUE;
                            }
                        }
                        break;

                    case OUTPUT_TERMINAL:
                        if ( ((PAUDIO_OUTPUT_TERMINAL)pUnit)->wTerminalType != USB_Streaming) {
                            if ( ulBridgePinCount++ == ulBridgePinNumber ) {
                                fFound = TRUE;
                            }
                        }
                        break;

                    default:
                        break;
                }

                if ( !fFound ) {
                    pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
                    if ((PUCHAR)pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength))
                        pUnit = NULL;
                }
            }
        }
        if (!fFound )
            pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return pUnit;
}

BOOL
IsBridgePinDigital(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber)
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;
    BOOL fDigitalOut = FALSE;

    u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber );

    if ( u.pUnit ) {
        if ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) {
            switch ( u.pInput->wTerminalType ) {
                // add new digital types here
                case Digital_audio_interface:
                case SPDIF_interface:
                    fDigitalOut = TRUE;
                    break;
                default:
                    fDigitalOut = FALSE;
                    break;
            }
        }
        else {
            fDigitalOut = FALSE;
        }
    }

    return fDigitalOut;
}

VOID
GetCategoryForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;

    u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber );

    if ( u.pUnit ) {
        if ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) {
            INIT_USB_TERMINAL(pTTypeGUID, u.pInput->wTerminalType );
        }
        else {
            INIT_USB_TERMINAL(pTTypeGUID, u.pOutput->wTerminalType );
        }
    }
}

KSPIN_DATAFLOW
GetDataFlowForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;

    KSPIN_DATAFLOW KsPinDataFlow = 0;

    if ( u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber ) ) {
        KsPinDataFlow = ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) ?
                               KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
    }

    return KsPinDataFlow;
}


LONG
GetPinNumberForStreamingTerminalUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulTerminalNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PAUDIO_GENERAL_STREAM pGeneralStream;
    ULONG ulPinNumber = 0;

    // Find the PinNumber
    pInterfaceDescriptor = GetFirstAudioStreamingInterface(pConfigurationDescriptor, ulPinNumber);
    while (pInterfaceDescriptor) {
        // Find the general stream descriptor for this interface
        pGeneralStream = (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                                pConfigurationDescriptor,
                                                pInterfaceDescriptor,
                                                AS_GENERAL);

        if (pGeneralStream && pGeneralStream->bTerminalLink == ulTerminalNumber)
            // We found the correct stream!
            return ulPinNumber;

        pInterfaceDescriptor =
            GetNextAudioInterface(pConfigurationDescriptor, pInterfaceDescriptor);

        if (!pInterfaceDescriptor) {
            // Move to next pin
            ulPinNumber++;
            pInterfaceDescriptor = GetFirstAudioStreamingInterface(pConfigurationDescriptor, ulPinNumber);
        }
    }

    return (-1L);
}

LONG
GetPinNumberForMIDIJack(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulJackID,
    ULONG pMIDIStreamingPinStartIndex,
    ULONG pBridgePinStartIndex)
{
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    ULONG ulNumBridgePins = 0;
    ULONG ulNumEmbeddedPins = 0;
    union {
        PAUDIO_UNIT                 pUnit;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
    } u;

    // Find the PinNumber
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)
    while (pMIDIStreamingDescriptor) {
        // Find the general stream descriptor for this interface
        pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                                           pConfigurationDescriptor->wTotalLength,
                                                           (PVOID) pMIDIStreamingDescriptor,
                                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        if (!pGeneralMIDIStreamDescriptor) {
            return (-1L);
        }

        u.pUnit = (PAUDIO_UNIT)
            USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                   pGeneralMIDIStreamDescriptor->wTotalLength,
                                   ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        while ( u.pUnit ) {

            if (u.pMIDIInJack->bJackID == ulJackID) {
                if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                    return pMIDIStreamingPinStartIndex + ulNumEmbeddedPins;
                } else {
                    return pBridgePinStartIndex + ulNumBridgePins;
                }
            }

            if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                ulNumEmbeddedPins++;
            } else {
                ulNumBridgePins++;
            }

            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pGeneralMIDIStreamDescriptor,
                                pGeneralMIDIStreamDescriptor->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return (-1L);
}

ULONG
GetChannelConfigForUnit( PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
                         ULONG ulUnitNumber )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL  pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
        PAUDIO_MIXER_UNIT      pMixer;
        PAUDIO_SELECTOR_UNIT   pSelector;
        PAUDIO_FEATURE_UNIT    pFeature;
        PAUDIO_PROCESSING_UNIT pProcess;
        PAUDIO_EXTENSION_UNIT  pExtension;
    } u;
    PAUDIO_CHANNELS pChannelInfo;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels;

    ULONG ulChannelConfig = 0;

    u.pUnit = GetUnit(pConfigurationDescriptor, ulUnitNumber);
    while (u.pUnit) {
        switch (u.pUnit->bDescriptorSubtype) {
            case INPUT_TERMINAL:
                ulChannelConfig = (ULONG)u.pInput->wChannelConfig;
                u.pUnit = NULL;
                break;
            case OUTPUT_TERMINAL:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pOutput->bSourceID);
                break;
            case MIXER_UNIT:
                pMixChannels = (PAUDIO_MIXER_UNIT_CHANNELS)(u.pMixer->baSourceID + u.pMixer->bNrInPins);
                ulChannelConfig = (ULONG)pMixChannels->wChannelConfig;
                u.pUnit = NULL;
                break;
            case SELECTOR_UNIT:
                // NOTE: This assumes all inputs have the same number of channels!
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pSelector->baSourceID[0]);
                break;
            case FEATURE_UNIT:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pFeature->bSourceID);
                break;
            case PROCESSING_UNIT:
            case EXTENSION_UNIT:
                pChannelInfo = (PAUDIO_CHANNELS)(u.pProcess->baSourceID + u.pProcess->bNrInPins);
                ulChannelConfig = (ULONG)pChannelInfo->wChannelConfig;
                u.pUnit = NULL;
                break;
            default:
                u.pUnit = NULL;
                break;
        }
    }

    return ulChannelConfig;
}

UCHAR
GetUnitControlInterface( PHW_DEVICE_EXTENSION pHwDevExt,
                         UCHAR bUnitId )
{
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor = pHwDevExt->pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    UCHAR ucCntrlIfNumber = 0xff;
    PVOID pStartPosition;

    // Starting at the configuration descriptor, find the control interface.
    pStartPosition = pConfigurationDescriptor;
    while ( pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        pStartPosition,
                        -1,        // interface number
                        -1,        //  (Alternate Setting)
                        USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                        -1 ) )    // protocol don't care    (InterfaceProtocol)
    {
        PAUDIO_HEADER_UNIT pHeader;
        PAUDIO_UNIT pUnit;

        ucCntrlIfNumber = pControlInterface->bInterfaceNumber;

        pHeader = (PAUDIO_HEADER_UNIT) GetAudioSpecificInterface(
                                                pConfigurationDescriptor,
                                                pControlInterface,
                                                HEADER_UNIT);

        // Move to the next descriptor
        pUnit = (PAUDIO_UNIT) ((PUCHAR)pHeader + pHeader->bLength);
        while ((pUnit < (PAUDIO_UNIT)((PUCHAR)pHeader + pHeader->wTotalLength)) &&
               (pUnit->bUnitID != bUnitId)){
            pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
        }
        if ( pUnit->bUnitID == bUnitId ) break;

        pStartPosition = (PUCHAR)pControlInterface + pControlInterface->bLength;
    }

    return ucCntrlIfNumber;

}

BOOLEAN
IsSampleRateInRange(
    PVOID pAudioDescriptor,
    ULONG ulSampleRate,
    ULONG ulFormatType )
{

    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDescriptor = pAudioDescriptor;
    PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor = pAudioDescriptor;
    ULONG ulMinSampleRate, ulMaxSampleRate;
    BOOLEAN bInRange = FALSE;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
        // Find the format-specific descriptor
        if (pT1AudioDescriptor->bSampleFreqType == 0) {
            // Continuous range available
            ulMinSampleRate = pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                       256L * pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                     65536L * pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            ulMaxSampleRate = pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                       256L * pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                     65536L * pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            if ( (ulMinSampleRate <= ulSampleRate) && (ulMaxSampleRate >= ulSampleRate) ) {
                bInRange = TRUE;
            }
        }
        else {
            ULONG i;
            for (i=0; i<(ULONG)pT1AudioDescriptor->bSampleFreqType; i++) {
                ulMaxSampleRate = pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                           256L * pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                         65536L * pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte3;
                if ( ulMaxSampleRate == ulSampleRate ) {
                    // We have a match!
                    bInRange = TRUE;
                    break;
                }
            }
        }
    }

    else if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED ) {
        // Find the format-specific descriptor
        if (pT2AudioDescriptor->bSampleFreqType == 0) {
            // Continuous range available
            ulMinSampleRate = pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                       256L * pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                     65536L * pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            ulMaxSampleRate = pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                       256L * pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                     65536L * pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            if ( (ulMinSampleRate <= ulSampleRate) && (ulMaxSampleRate >= ulSampleRate) ) {
                // We have a match!
                bInRange = TRUE;
            }
        }
        else {
            ULONG i;
            for (i=0; i<(ULONG)pT2AudioDescriptor->bSampleFreqType; i++) {
                ulMaxSampleRate = pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                           256L * pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                         65536L * pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte3;
                if ( ulMaxSampleRate == ulSampleRate ) {
                    // We have a match!
                    bInRange = TRUE;
                    break;
                }
            }
        }
    }

    return bInRange;
}

PUSBAUDIO_DATARANGE
GetUsbDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PUSBAUDIO_DATARANGE pUsbDataRange,
    ULONG ulUsbDataRangeCnt )
{
    PUSBAUDIO_DATARANGE pOutUsbDataRange = NULL;
    union {
        PAUDIO_CLASS_STREAM pAudioDescriptor;
        PAUDIO_CLASS_TYPE1_STREAM pT1AudioDescriptor;
        PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor;
    } u1;

    union {
        PWAVEFORMATEX pDataFmtWave;
        PWAVEFORMATPCMEX pDataFmtPcmEx;
    } u2;

    PKSDATARANGE pStreamRange;
    ULONG ulFormatType;
    ULONG fFound = FALSE;
    ULONG i;

    u2.pDataFmtWave = &((PKSDATAFORMAT_WAVEFORMATEX)pFormat)->WaveFormatEx;

    for ( i=0; ((i<ulUsbDataRangeCnt) && !fFound); ) {
        // Verify the Format GUIDS first
        pStreamRange = (PKSDATARANGE)&pUsbDataRange[i].KsDataRangeAudio;
        if ( IsEqualGUID(&pFormat->MajorFormat, &pStreamRange->MajorFormat) &&
             IsEqualGUID(&pFormat->SubFormat,   &pStreamRange->SubFormat)   &&
             IsEqualGUID(&pFormat->Specifier,   &pStreamRange->Specifier) ) {

            u1.pAudioDescriptor = pUsbDataRange[i].pAudioDescriptor;

            // Based on the Data Type check remainder of format paramters
            ulFormatType = pUsbDataRange[i].ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
            switch( ulFormatType ) {
                case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                    if ( u2.pDataFmtWave->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ( (u1.pT1AudioDescriptor->bNumberOfChannels == u2.pDataFmtPcmEx->Format.nChannels      ) &&
                            ((u1.pT1AudioDescriptor->bSlotSize<<3)     == u2.pDataFmtPcmEx->Format.wBitsPerSample ) &&
                             (u1.pT1AudioDescriptor->bBitsPerSample    == u2.pDataFmtPcmEx->Samples.wValidBitsPerSample ) )
                            fFound = TRUE;
                    }
                    else {
                        if ( (u1.pT1AudioDescriptor->bNumberOfChannels == u2.pDataFmtWave->nChannels     ) &&
                             (u1.pT1AudioDescriptor->bBitsPerSample    == u2.pDataFmtWave->wBitsPerSample) )
                            fFound = TRUE;
                    }

                    // If all other paramters match check sample rate
                    if ( fFound ) {
                        fFound = IsSampleRateInRange( u1.pT1AudioDescriptor,
                                                      u2.pDataFmtWave->nSamplesPerSec,
                                                      ulFormatType );
                    }
                    break;
                case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                    fFound = IsSampleRateInRange( u1.pT2AudioDescriptor,
                                                  u2.pDataFmtWave->nSamplesPerSec,
                                                  ulFormatType );
                    break;
                case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                default:
                    break;
            }

        }

        if (!fFound) i++;
    }

    if ( fFound ) {
        pOutUsbDataRange = &pUsbDataRange[i];
    }

    return pOutUsbDataRange;
}

ULONG
GetPinDataRangesFromInterface(
    ULONG ulInterfaceNumber,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PKSDATARANGE_AUDIO *ppKsAudioRange,
    PUSBAUDIO_DATARANGE pAudioDataRange )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    ULONG ulDataRangeCount = 0;
    ULONG i;

    ulDataRangeCount =
        CountFormatsForAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    if ( ulDataRangeCount ) {

        pInterfaceDescriptor =
                GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

        while ( pInterfaceDescriptor &&
              ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
               !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
            pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
        }

        for ( i=0; i<ulDataRangeCount; i++ ) {
            ppKsAudioRange[i] = &pAudioDataRange[i].KsDataRangeAudio;
            ConvertInterfaceToDataRange( pConfigurationDescriptor,
                                         pInterfaceDescriptor,
                                         &pAudioDataRange[i] );

            pAudioDataRange[i].pTerminalUnit =
                GetTerminalUnitForInterface( pConfigurationDescriptor,
                                             pInterfaceDescriptor);

            pAudioDataRange[i].ulChannelConfig =
                GetChannelConfigForUnit( pConfigurationDescriptor,
                                         pAudioDataRange[i].pTerminalUnit->bUnitID );

            pAudioDataRange[i].pInterfaceDescriptor = pInterfaceDescriptor;

            pAudioDataRange[i].pAudioEndpointDescriptor = (PAUDIO_ENDPOINT_DESCRIPTOR)
                GetEndpointDescriptor( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       TRUE );

            pAudioDataRange[i].pEndpointDescriptor =
                GetEndpointDescriptor( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       FALSE );

            // If any of these fail this device has bad descriptors
            ASSERT(pAudioDataRange[i].pTerminalUnit);
            ASSERT(pAudioDataRange[i].pAudioEndpointDescriptor);
            ASSERT(pAudioDataRange[i].pEndpointDescriptor);

            // Check if there is an async endpoint and save the pointer if there is.
            pAudioDataRange[i].pSyncEndpointDescriptor =
                GetSyncEndpointDescriptor( pConfigurationDescriptor,
                                            pInterfaceDescriptor );
            pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
            while ( pInterfaceDescriptor &&
                   ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
                    !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
                pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
            }
        }
    }

    return ulDataRangeCount;
}

VOID
GetContextForMIDIPin
(
    PKSPIN pKsPin,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PMIDI_PIN_CONTEXT pMIDIPinContext
)
{
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioStreamingInterface;
    PAUDIO_HEADER_UNIT pHeader;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    PMIDISTREAMING_ENDPOINT_DESCRIPTOR pMIDIEPDescriptor;
    ULONG i;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulPinCount = 0;
    ULONG ulInterfaceCount = 0;
    ULONG ulEndpointCount = 0;

    pMIDIPinContext->ulEndpointNumber = MAX_ULONG;
    pMIDIPinContext->ulInterfaceNumber = MAX_ULONG;

    //  Starting at the configuration descriptor, find the first audio interface.
    //  We are counting the number of AudioStreaming Pins in this while loop
    pControlInterface = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           -1,                     // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           AUDIO_SUBCLASS_CONTROL, // any subclass (Interface Sub-Class)
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlInterface ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlInterface,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       ((PUCHAR)pHeader + pHeader->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                    case OUTPUT_TERMINAL:
                        ulPinCount++;
                        break;

                    default:
                        break;
                }

                u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                    u.pUnit = NULL;
                }
            }
        }

        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               (PUCHAR)pControlInterface + pControlInterface->bLength,
                               -1,                     // Interface number
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               AUDIO_SUBCLASS_CONTROL, // any subclass (Interface Sub-Class)
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    // Get the first Audio interface
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                pConfigurationDescriptor,
                                -1,        // interface number
                                -1,        //  (Alternate Setting)
                                USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                -1,        // any subclass (Interface Sub-Class)
                                -1 );

    // Loop through the audio device class interfaces
    while (pAudioInterface) {

        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_STREAMING:
                // This subclass is handled with the control class since they have to come together
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found AudioStreaming at %x\n",pAudioInterface));
                break;
            case AUDIO_SUBCLASS_CONTROL:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found AudioControl at %x\n",pAudioInterface));
                ulInterfaceCount++;

                pHeader = (PAUDIO_HEADER_UNIT)
                         GetAudioSpecificInterface( pConfigurationDescriptor,
                                                    pAudioInterface,
                                                    HEADER_UNIT );
                if ( pHeader ) {
                    // Find each interface associated with this header
                    for ( i=0; i<pHeader->bInCollection; i++ ) {
                        pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                    pConfigurationDescriptor,
                                    (PVOID)pConfigurationDescriptor,
                                    (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                    -1,                               // Alternate Setting
                                    USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                    AUDIO_SUBCLASS_STREAMING,         // Audio Streaming (Interface Sub-Class)
                                    -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                        if ( pAudioStreamingInterface ) {
                            ulInterfaceCount++;
                        }
                    }
                }
                break;
            case AUDIO_SUBCLASS_MIDISTREAMING:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found MIDIStreaming at %x\n",pAudioInterface));
                if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                               pGeneralMIDIStreamDescriptor->wTotalLength,
                                               ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case MIDI_IN_JACK:
                            case MIDI_OUT_JACK:

                                if ( (pKsPin->Id == ulPinCount) &&
                                     (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) ) {
                                    // Setting the Interface Number for this pin
                                    pMIDIPinContext->ulInterfaceNumber = ulInterfaceCount;
                                    pMIDIPinContext->ulJackID = u.pMIDIInJack->bJackID;

                                    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] IC=%d JID=%x\n",
                                                                 pMIDIPinContext->ulInterfaceNumber,
                                                                 pMIDIPinContext->ulJackID));

                                    // Found the interface, now find the endpoint number
                                    pMIDIEPDescriptor = (PMIDISTREAMING_ENDPOINT_DESCRIPTOR)
                                        USBD_ParseDescriptors( pConfigurationDescriptor,
                                                               pConfigurationDescriptor->wTotalLength,
                                                               (PUCHAR)pGeneralMIDIStreamDescriptor,
                                                               USB_ENDPOINT_DESCRIPTOR_TYPE | USB_CLASS_AUDIO);
                                    while (pMIDIEPDescriptor) {

                                        // Check all of the jacks connected to this endpoint
                                        for (i=0; i<pMIDIEPDescriptor->bNumEmbMIDIJack;i++) {
                                            if (pMIDIEPDescriptor->baAssocJackID[i] == pMIDIPinContext->ulJackID) {
                                                pMIDIPinContext->ulCableNumber = i;
                                                pMIDIPinContext->ulEndpointNumber = ulEndpointCount;

                                                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] CN=%d EP=%d\n",
                                                                             pMIDIPinContext->ulCableNumber,
                                                                             pMIDIPinContext->ulEndpointNumber));
                                            }
                                        }

                                        ulEndpointCount++;

                                        pMIDIEPDescriptor = (PMIDISTREAMING_ENDPOINT_DESCRIPTOR)
                                            USBD_ParseDescriptors( pConfigurationDescriptor,
                                                                   pConfigurationDescriptor->wTotalLength,
                                                                   (PUCHAR)pMIDIEPDescriptor + pMIDIEPDescriptor->bLength,
                                                                   USB_ENDPOINT_DESCRIPTOR_TYPE | USB_CLASS_AUDIO);
                                    }
                                }

                                if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                                    ulPinCount++;
                                }
                                break;

                            case MIDI_ELEMENT:
                                break;

                            default:
                                break;
                        }

                        //  Found what we are looking for, stop looking
                        if (pMIDIPinContext->ulEndpointNumber != MAX_ULONG) {
                            break;
                        }

                        // Find the next unit.
                        u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                            (PVOID) pGeneralMIDIStreamDescriptor,
                                            pGeneralMIDIStreamDescriptor->wTotalLength,
                                            (PUCHAR)u.pUnit + u.pUnit->bLength,
                                            USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    }
                }

                ulInterfaceCount++;
                break;

            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin]: Invalid SubClass %x\n  ",pAudioInterface->bInterfaceSubClass));
                break;
        }

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Next audio interface at %x\n",pAudioInterface));
    }

    // Check to make sure that we found the correct information
    ASSERT(pMIDIPinContext->ulEndpointNumber != MAX_ULONG);
    ASSERT(pMIDIPinContext->ulInterfaceNumber != MAX_ULONG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\perf.c ===
//---------------------------------------------------------------------------
//
//  Module:   perf.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             12/12/00   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

#define PROC_REG_PATH L"System\\CurrentControlSet\\Services\\Usbaudio"

GUID ControlGuid =
{ 0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69 };

GUID TraceGuid = 
{ 0xd6464a84, 0xa358, 0x4013, 0xa1, 0xe8, 0x6e, 0x2f, 0xb4, 0x8a, 0xab, 0x93 };

ULONG TraceEnable;
TRACEHANDLE LoggerHandle;

NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

typedef struct PERFINFO_AUDIOGLITCH {
    ULONGLONG   cycleCounter;
    ULONG       glitchType;
    LONGLONG   sampleTime;
    LONGLONG   previousTime;
    ULONG_PTR       instanceId;
} PERFINFO_AUDIOGLITCH, *PPERFINFO_AUDIOGLITCH;

typedef struct PERFINFO_WMI_AUDIOGLITCH {
    EVENT_TRACE_HEADER          header;
    PERFINFO_AUDIOGLITCH        data;
} PERFINFO_WMI_AUDIO_GLITCH, *PPERFINFO_WMI_AUDIOGLITCH;

///////////////////////////////////////////////////////////////////////////

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine registers this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);
}

///////////////////////////////////////////////////////////////////////////

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine unregisters this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_DEREGISTER);
}

///////////////////////////////////////////////////////////////////////////

VOID
RegisterWmiGuids (
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG RegInfoSize,
    IN PULONG ReturnSize
    )

/*++

Routine Description:

    This routine registers WMI event tracing streams.

--*/

{
    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR Temp;

    *ReturnSize = 0;
    GuidCount = 1;

    RegistryPathSize = sizeof (PROC_REG_PATH) - sizeof (WCHAR) + sizeof (USHORT);
    SizeNeeded = sizeof (WMIREGINFOW) + GuidCount * sizeof (WMIREGGUIDW) + RegistryPathSize;

    if (SizeNeeded > RegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *ReturnSize = sizeof (ULONG);
        return;
    }

    RtlZeroMemory (WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = WmiRegInfo->WmiRegGuid;
    WmiRegGuidPtr->Guid = ControlGuid;
    WmiRegGuidPtr->Flags |= (WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID);

    Temp = (PUCHAR)(WmiRegGuidPtr + 1);
    WmiRegInfo->RegistryPath = PtrToUlong ((PVOID)(Temp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)Temp) = (USHORT)(sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    Temp += sizeof (USHORT);
    RtlCopyMemory (Temp, PROC_REG_PATH, sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    *ReturnSize = SizeNeeded;
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_SYSTEM_CONTROL calls. It processes
    WMI requests and passes everything else on to KS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    ULONG ReturnSize;
    PWNODE_HEADER Wnode;

    if ((PDEVICE_OBJECT)IrpSp->Parameters.WMI.ProviderId != DeviceObject) {
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    switch (IrpSp->MinorFunction) {

    case IRP_MN_REGINFO:
        RegisterWmiGuids ((PWMIREGINFO)IrpSp->Parameters.WMI.Buffer,
                          IrpSp->Parameters.WMI.BufferSize,
                          &ReturnSize);
        break;
    
    case IRP_MN_ENABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange ((PLONG)&TraceEnable, 1);
        Wnode = (PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer;
        if (IrpSp->Parameters.WMI.BufferSize >= sizeof (WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
        }
        break;

    case IRP_MN_DISABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange ((PLONG)&TraceEnable, 0);
        break;

    case IRP_MN_ENABLE_COLLECTION:
    case IRP_MN_DISABLE_COLLECTION:
        ReturnSize = 0;
        break;

    default:
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = ReturnSize;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

/*++

Routine Description:

    This routine logs a WMI event tracing event with an audio glitch GUID
    and the supplied glitch type.

--*/

{
    PERFINFO_WMI_AUDIO_GLITCH Event;

    if (LoggerHandle == (TRACEHANDLE)NULL || TraceEnable == 0) {
        return;
    }

    RtlZeroMemory (&Event, sizeof (Event));
    Event.header.Size = sizeof (Event);
    Event.header.Flags = WNODE_FLAG_TRACED_GUID;
    Event.header.Guid = TraceGuid;
    Event.data.glitchType = Type;
    Event.data.instanceId = InstanceId;
    Event.data.sampleTime = CurrentTime;
    Event.data.previousTime = PreviousTime;

    ((PWNODE_HEADER)&Event)->HistoricalContext = LoggerHandle;

    IoWMIWriteEvent ((PVOID)&Event);
}

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\perf.h ===
//---------------------------------------------------------------------------
//
//  Module:   perf.d
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             01/02/01   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wmistr.h>
#include <evntrace.h>

extern NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

extern ULONG TraceEnable;

#define PerfInstrumentationEnabled() (TraceEnable != 0)

#define USBAUDIO_SOURCE_GLITCH 4

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );


//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\property.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       property.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "Property.h"

#define DB_SCALE_16BIT 0x100
#define DB_SCALE_8BIT  0x4000

#define MAX_EQ_BANDS 30

#define NEGATIVE_INFINITY 0xFFFF8000

extern ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

#define GET_NODE_INFO_FROM_FILTER(pKsFilter,ulNodeID) \
        &((PTOPOLOGY_NODE_INFO)(pKsFilter)->Descriptor->NodeDescriptors)[(ulNodeID)]

#define MAXPINNAME      256
#define STR_PINNAME     TEXT("%s [%d]")

NTSTATUS
USBAudioRegReadNameValue(
    IN PIRP Irp,
    IN const GUID* Category,
    OUT PVOID NameBuffer
    )
/*++

Routine Description:

    Queries the "Name" key from the specified category GUID. This is used
    by the topology handler to query for the value from the name GUID or
    topology GUID. If the buffer length is sizeof(ULONG), then the size of
    the buffer needed is returned, else the buffer is filled with the name.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Category -
        The GUID to locate the name value for.

    NameBuffer -
        The place in which to put the value.

Return Value:

    Returns STATUS_SUCCESS, else a buffer size or memory error. Always fills
    in the IO_STATUS_BLOCK.Information field of the PIRP.IoStatus element
    within the IRP. It does not set the IO_STATUS_BLOCK.Status field, nor
    complete the IRP however.

--*/
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    HANDLE                          CategoryKey;
    KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;
    WCHAR                           RegistryPath[sizeof(MediaCategories) + 39];
    UNICODE_STRING                  RegistryString;
    UNICODE_STRING                  ValueName;
    ULONG                           BytesReturned;

    //
    // Build the registry key path to the specified category GUID.
    //
    Status = RtlStringFromGUID(Category, &RegistryString);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    wcscpy(RegistryPath, MediaCategories);
    wcscat(RegistryPath, RegistryString.Buffer);
    RtlFreeUnicodeString(&RegistryString);
    RtlInitUnicodeString(&RegistryString, RegistryPath);
    InitializeObjectAttributes(&ObjectAttributes, &RegistryString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    if (!NT_SUCCESS(Status = ZwOpenKey(&CategoryKey, KEY_READ, &ObjectAttributes))) {
        return Status;
    }
    //
    // Read the "Name" value beneath this category key.
    //
    RtlInitUnicodeString(&ValueName, NodeNameValue);
    Status = ZwQueryValueKey(
        CategoryKey,
        &ValueName,
        KeyValuePartialInformation,
        &PartialInfoHeader,
        sizeof(PartialInfoHeader),
        &BytesReturned);
    //
    // Even if the read did not cause an overflow, just take the same
    // code path, as such a thing would not normally happen.
    //
    if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
        ULONG   BufferLength;

        BufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
        //
        // Determine if this is just a query for the length of the
        // buffer needed, or a query for the actual data.
        //
        if (!BufferLength) {
            //
            // Return just the size of the string needed.
            //
            Irp->IoStatus.Information = BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
            Status = STATUS_BUFFER_OVERFLOW;
        } else if (BufferLength < BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            PKEY_VALUE_PARTIAL_INFORMATION  PartialInfoBuffer;

            //
            // Allocate a buffer for the actual size of data needed.
            //
            PartialInfoBuffer = AllocMem( PagedPool, BytesReturned );
            if (PartialInfoBuffer) {
                //
                // Retrieve the actual name.
                //
                Status = ZwQueryValueKey(
                    CategoryKey,
                    &ValueName,
                    KeyValuePartialInformation,
                    PartialInfoBuffer,
                    BytesReturned,
                    &BytesReturned);
                if (NT_SUCCESS(Status)) {
                    //
                    // Make sure that there is always a value.
                    //
                    if (!PartialInfoBuffer->DataLength || (PartialInfoBuffer->Type != REG_SZ)) {
                        Status = STATUS_UNSUCCESSFUL;
                    } else {
                        RtlCopyMemory(
                            NameBuffer,
                            PartialInfoBuffer->Data,
                            PartialInfoBuffer->DataLength);
                        Irp->IoStatus.Information = PartialInfoBuffer->DataLength;
                    }
                }
                FreeMem(PartialInfoBuffer);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    ZwClose(CategoryKey);
    return Status;
}

ULONG
GetPinIndex(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG PinId )
{
    KSPIN_DATAFLOW DataFlow;
    ULONG i,j;
    ULONG DataFlowInIndex = 0;
    ULONG DataFlowOutIndex = 0;
    ULONG ulAudioPinCount;
    ULONG ulAudioStreamingPinCount, ulAudioBridgePinCount;
    ULONG ulMIDIPinCount, ulMIDIBridgePinCount;

    //  Jump past the Audio pins by figuring out where they start
    ulAudioPinCount = CountTerminalUnits(pConfigurationDescriptor,
                                         &ulAudioBridgePinCount,
                                         &ulMIDIPinCount,
                                         &ulMIDIBridgePinCount);

    ulAudioStreamingPinCount = ulAudioPinCount -
                               ulAudioBridgePinCount -
                               ulMIDIPinCount;

    _DbgPrintF(DEBUGLVL_BLAB,("[GetPinIndex] AC:%x, ASC:%x, ABC:%x, MC:%x, MBC:%x\n",
                               ulAudioPinCount,
                               ulAudioStreamingPinCount,
                               ulAudioBridgePinCount,
                               ulMIDIPinCount,
                               ulMIDIBridgePinCount));

    // Test to see if this pin id is in the range of MIDI Streaming pins
    if ( (PinId >= ulAudioPinCount - ulMIDIPinCount) &&
         (PinId < ulAudioPinCount - ulMIDIBridgePinCount) ) {

        for (i=ulAudioPinCount - ulMIDIPinCount,j=0;
             i<ulAudioPinCount - ulMIDIBridgePinCount;
             i++,j++) {
            DataFlow = GetDataFlowDirectionForMIDIInterface( pConfigurationDescriptor, j, FALSE );
            if (i == PinId) {
                if (DataFlow == KSPIN_DATAFLOW_OUT) {
                    return DataFlowOutIndex+1;
                }
                else {
                    return DataFlowInIndex+1;
                }
            }

            if (DataFlow == KSPIN_DATAFLOW_OUT) {
                DataFlowOutIndex++;
            }
            else {
                DataFlowInIndex++;
            }
        }
    }
    else {
        return MAX_ULONG;
    }

    // Shouldn't get here
    ASSERT(0);
    return MAX_ULONG;
}

NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pKsPropPin, PVOID pData )
{
    ULONG BufferLength;
    WCHAR szTemp[MAXPINNAME];
    PWCHAR StringBuffer;
    ULONG StringLength;
    ULONG ulPinIndex;
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;

    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PFILTER_CONTEXT pFilterContext;
    PHW_DEVICE_EXTENSION pHwDevExt;

    if ( NULL == pKsFilter ) {
        TRAP;
        return STATUS_INVALID_PARAMETER;
    }

    pFilterContext = pKsFilter->Context;
    pHwDevExt      = pFilterContext->pHwDevExt;

    ASSERT(pKsFilter);
    ASSERT(pFilterContext);
    ASSERT(pHwDevExt);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] pKsPropPin->PinId %x\n",pKsPropPin->PinId));

    ulPinIndex =
        GetPinIndex( pHwDevExt->pConfigurationDescriptor, pKsPropPin->PinId );
    if (ulPinIndex != MAX_ULONG) {

        BufferLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.OutputBufferLength;

        // Get the Friendly name for this device and append a subscript if there
        // is more than one pin on this device.

        StringBuffer = AllocMem(NonPagedPool, MAXPINNAME);
        if (!StringBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Using DeviceDescription, perhaps the name should be acquired from the FriendlyName
        //  on the device interface, but this seems to work.
        //
        Status = IoGetDeviceProperty(
            pFilterContext->pNextDeviceObject,
            DevicePropertyDeviceDescription,
            MAXPINNAME,
            StringBuffer,
            &StringLength);

        if(!NT_SUCCESS(Status)) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] IoGetDeviceProperty failed (%x)\n", Status));
            FreeMem(StringBuffer);
            return Status;
        }

        swprintf(szTemp, STR_PINNAME, StringBuffer, ulPinIndex);
        StringLength = (wcslen(szTemp) + 1) * sizeof(WCHAR);

        //  Compute actual length adding the pin subscript
        if (!BufferLength) {
            _DbgPrintF(DEBUGLVL_BLAB,("[GetPinName] StringLength: %x\n",StringLength));
            pIrp->IoStatus.Information = StringLength;
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else if (BufferLength < StringLength) {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            BufferLength = BufferLength / sizeof(WCHAR);
            if ( (ulPinIndex < 2) || (ulPinIndex == MAX_ULONG) ) {
                wcsncpy(pData, StringBuffer, min(BufferLength,MAXPINNAME));
                StringLength = (wcslen(pData) + 1) * sizeof(WCHAR);
            }
            else {
                wcsncpy(pData, szTemp, min(BufferLength,MAXPINNAME));
            }
            _DbgPrintF(DEBUGLVL_BLAB,("[GetPinName] String: %ls\n",pData));
            ASSERT(StringLength <= BufferLength * sizeof(WCHAR));
            pIrp->IoStatus.Information = StringLength;
            Status = STATUS_SUCCESS;
        }

        FreeMem(StringBuffer);
    }
    else {
        const KSFILTER_DESCRIPTOR *pKsFilterDescriptor = pKsFilter->Descriptor;
        const KSPIN_DESCRIPTOR_EX *pKsPinDescriptor = pKsFilterDescriptor->PinDescriptors;
        KSPIN_DESCRIPTOR PinDescriptor;
        UINT i;

        for (i=0; i<pKsPropPin->PinId; i++) {
            pKsPinDescriptor =
                (PKSPIN_DESCRIPTOR_EX)(
                    (PUCHAR)pKsPinDescriptor + pKsFilterDescriptor->PinDescriptorSize);
        }

        PinDescriptor = pKsPinDescriptor->PinDescriptor;

        if (PinDescriptor.Name) {
            return USBAudioRegReadNameValue( pIrp, PinDescriptor.Name, pData );
        }
        if (PinDescriptor.Category) {
            return USBAudioRegReadNameValue( pIrp, PinDescriptor.Category, pData );
        }
    }

    return Status;
}

NTSTATUS
GetSetProperty(
    PDEVICE_OBJECT pNextDeviceObject,
    USHORT FunctionClass,
    ULONG  DirectionFlag,
    UCHAR  RequestType,
    USHORT wValueHi,
    USHORT wValueLo,
    USHORT wIndexHi,
    USHORT wIndexLo,
    PVOID  pData,
    ULONG  LengthOfData )
{
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PURB pUrb;

    // Allocate an urb to use
    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
    if ( pUrb ) {
        // Build the request
        UsbBuildVendorRequest( pUrb,
                               FunctionClass,
                               (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                               DirectionFlag, // transferflags == OUT
                               0, // request type reserved bits
                               RequestType,
                               (USHORT) ((wValueHi << 8) | wValueLo),
                               (USHORT) ((wIndexHi << 8) | wIndexLo),
                               pData,
                               NULL,
                               LengthOfData,
                               NULL);

        ntStatus = SubmitUrbToUsbdSynch(pNextDeviceObject, pUrb);

        DbgLog("GSProp", ntStatus, 0, 0, 0);

        FreeMem(pUrb);
    }

    return ntStatus;
}

NTSTATUS
GetSetByte(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType )
{
    NTSTATUS ntStatus;
    PUCHAR pData;

    pData = AllocMem(NonPagedPool, sizeof(UCHAR));
    if (!pData) return STATUS_INSUFFICIENT_RESOURCES;

    if ( !(ucRequestType & CLASS_SPECIFIC_GET_MASK) )
        *pData = (UCHAR)*plData;

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               (ucRequestType & CLASS_SPECIFIC_GET_MASK) ?
                                              USBD_TRANSFER_DIRECTION_IN :
                                              USBD_TRANSFER_DIRECTION_OUT,
                               ucRequestType,
                               (USHORT)pNodeInfo->ulControlType,
                               (USHORT)ulChannel,
                               (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               pData,
                               sizeof(UCHAR) );

    if ((ucRequestType & CLASS_SPECIFIC_GET_MASK ) && NT_SUCCESS( ntStatus ) )
       *plData = (ULONG)(*pData);

    FreeMem(pData);

    return ntStatus;

}

NTSTATUS
GetSetShort(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType )
{
    NTSTATUS ntStatus;
    PUSHORT pData;

    pData = AllocMem(NonPagedPool, sizeof(USHORT));
    if (!pData) return STATUS_INSUFFICIENT_RESOURCES;

    if ( !(ucRequestType & CLASS_SPECIFIC_GET_MASK) )
        *pData = (USHORT)*plData;

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               (ucRequestType & CLASS_SPECIFIC_GET_MASK) ?
                                              USBD_TRANSFER_DIRECTION_IN :
                                              USBD_TRANSFER_DIRECTION_OUT,
                               ucRequestType,
                               (USHORT)pNodeInfo->ulControlType,
                               (USHORT)ulChannel,
                               (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               pData,
                               sizeof(USHORT) );

    if ((ucRequestType & CLASS_SPECIFIC_GET_MASK ) && NT_SUCCESS( ntStatus ) )
       *plData = (ULONG)(*pData);

    FreeMem(pData);

    return ntStatus;

}

NTSTATUS
GetSetDBLevel(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PLONG plData,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    UCHAR ucRequestType )
{
    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );

    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lScaleFactor;
    LONG lData;

    // Determine if this is a request for beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    if ( !(pNodeInfo->ulCacheValid & (1<<ulChannel) ) ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pDbCache += ulChannel;
    DbgLog("GSDbLvl", &pNodeInfo, ulChannel, pDbCache, pDbCache->ulChannelIndex );

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        GetSetFunc   = GetSetByte;
    }
    else {
        lScaleFactor = DB_SCALE_16BIT;
        GetSetFunc   = GetSetShort;
    }

    switch((ULONG)ucRequestType) {
        case GET_CUR:
            *plData = pDbCache->lLastValueSet;
            ntStatus = STATUS_SUCCESS;
            break;
        case SET_CUR:
            if ( *plData == pDbCache->lLastValueSet ) {
                ntStatus = STATUS_SUCCESS;
            }
            else {
                if ( *plData < pDbCache->Range.Bounds.SignedMinimum ) {
                    if ( ulDataBitCount == 16 )
                        lData = NEGATIVE_INFINITY; // Detect volume control to silence
                    else
                        lData = pDbCache->Range.Bounds.SignedMinimum / lScaleFactor;
                }
                else if ( *plData > pDbCache->Range.Bounds.SignedMaximum ) {
                    lData = pDbCache->Range.Bounds.SignedMaximum / lScaleFactor;
                }
                else  {
                    lData = *plData / lScaleFactor;
                }

                ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                          pNodeInfo,
                                          pDbCache->ulChannelIndex,
                                          &lData,
                                          SET_CUR );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = *plData;
                }
            }
            break;
        default:
            ntStatus  = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return ntStatus;
}

NTSTATUS
GetDbLevelRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS (*GetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lData;
    UCHAR ucRequestType;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    GetFunc = ( ulDataBitCount == 8 ) ? GetSetByte : GetSetShort;

    for ( ucRequestType=GET_MIN; ucRequestType<=GET_RES; ucRequestType++ ) {

        ntStatus = (*GetFunc)( pNextDeviceObject,
                               pNodeInfo,
                               ulChannel,
                               &lData,
                               ucRequestType );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetDbLevelRange ERROR: %x\n",ntStatus));
            break;
        }
        else {
            if ( ulDataBitCount == 8 ) {
                lData = (LONG)((CHAR)(lData))  * DB_SCALE_8BIT;
            }
            else {
                lData = (LONG)((SHORT)(lData)) * DB_SCALE_16BIT;
            }

            switch( ucRequestType ) {
                case GET_MIN:
                    pRange->Bounds.SignedMinimum = lData;
                    break;
                case GET_MAX:
                    pRange->Bounds.SignedMaximum = lData;
                    break;
                case GET_RES:
                    pRange->SteppingDelta = lData;
                    break;
            }
        }
    }

    DbgLog("DBRnge", ntStatus, pRange, ucRequestType, pNodeInfo );

    return ntStatus;
}

NTSTATUS
InitializeDbLevelCache(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount )
{
    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus;
    LONG lScaleFactor;
    LONG lData;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        GetSetFunc  = GetSetByte;
    }
    else {
        lScaleFactor = DB_SCALE_16BIT;
        GetSetFunc  = GetSetShort;
    }

    ntStatus = GetDbLevelRange( pNextDeviceObject,
                                pNodeInfo,
                                pDbCache->ulChannelIndex,
                                ulDataBitCount,
                                &pDbCache->Range );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                  pNodeInfo,
                                  pDbCache->ulChannelIndex,
                                  &lData,
                                  GET_CUR );

        if ( NT_SUCCESS(ntStatus) ) {
            if ( pNodeInfo->ulControlType == VOLUME_CONTROL ) {
                pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: pDbCache->lLastValueSet=%d\n",pDbCache->lLastValueSet));
                if ( (pDbCache->lLastValueSet >= pDbCache->Range.Bounds.SignedMaximum) ||
                     (pDbCache->lLastValueSet <= pDbCache->Range.Bounds.SignedMinimum) ) {
                    lData = ( pDbCache->Range.Bounds.SignedMinimum +
                             ( pDbCache->Range.Bounds.SignedMaximum - pDbCache->Range.Bounds.SignedMinimum) / 2 )
                            / lScaleFactor;
                   _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: volume at max (%d) or min (%d), setting to average %d\n",
                                               pDbCache->Range.Bounds.SignedMaximum,
                                               pDbCache->Range.Bounds.SignedMinimum,
                                               lData));
                }
                ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                          pNodeInfo,
                                          pDbCache->ulChannelIndex,
                                          &lData,
                                          SET_CUR );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: setting lastvalue to %d\n",pDbCache->lLastValueSet));
                }
                else {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: error setting volume %d\n",lData));
                }
            }
            else {
                pDbCache->lLastValueSet = (LONG)((CHAR)lData) * lScaleFactor;
            }
        }
    }

    return ntStatus;

}


NTSTATUS
GetSetProcessingUnitValue(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    USHORT usControlSelector,
    PVOID pValue,
    ULONG ulValSize )
{
    ULONG ulDirectionFlag =
        (ucCommand & CLASS_SPECIFIC_GET_MASK) ? USBD_TRANSFER_DIRECTION_IN :
                                                USBD_TRANSFER_DIRECTION_OUT;
    PVOID pVal;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    pVal = AllocMem(NonPagedPool, ulValSize);


    if (pVal) {

        if (!ulDirectionFlag) {
            RtlCopyMemory(pVal, pValue, ulValSize);
        }

        ntStatus = GetSetProperty( pNextDeviceObject,
                                   URB_FUNCTION_CLASS_INTERFACE,
                                   ulDirectionFlag,
                                   ucCommand,
                                   usControlSelector,
                                   (USHORT)0,
                                   (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                                   (USHORT)pNodeInfo->MapNodeToCtrlIF,
                                   pVal,
                                   ulValSize );

        if ( NT_SUCCESS(ntStatus) ) {
            if (ulDirectionFlag)
                RtlCopyMemory(pValue, pVal, ulValSize);
        }

        FreeMem( pVal );

    }

    return ntStatus;
}

NTSTATUS
GetSetProcessingUnitEnable(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    PBOOL pEnable )
{
    NTSTATUS ntStatus;
    UCHAR ucEnable = (UCHAR)*pEnable;

    ntStatus = GetSetProcessingUnitValue( pNextDeviceObject,
                                          pNodeInfo,
                                          ucCommand,
                                          (USHORT)ENABLE_CONTROL,
                                          pEnable,
                                          sizeof(UCHAR) );
    if (NT_SUCCESS(ntStatus)) {
        if (ucCommand == GET_CUR)
            *pEnable = (BOOL)ucEnable;
    }

    return ntStatus;
}

NTSTATUS
GetProcessingUnitRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulControl,
    ULONG ulCntrlSize,
    LONG  lScaleFactor,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    UCHAR ucRequestType;
    LONG lData;

    for ( ucRequestType=GET_MIN; ucRequestType<=GET_RES; ucRequestType++ ) {

        ntStatus = GetSetProcessingUnitValue( pNextDeviceObject,
                                              pNodeInfo,
                                              ucRequestType,
                                              (USHORT)ulControl,
                                              &lData,
                                              ulCntrlSize );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetProcessingUnitRange ERROR: %x\n",ntStatus));
            break;
        }

        if ( ulCntrlSize == sizeof(CHAR) ) {
            lData = (LONG)((CHAR)(lData)) * lScaleFactor;
        }
        else {
            lData = (LONG)((SHORT)(lData)) * lScaleFactor;
        }

        switch (ucRequestType) {
            case GET_MIN:
                pRange->Bounds.SignedMinimum = lData;
                break;
            case GET_MAX:
                pRange->Bounds.SignedMaximum = lData;
                break;
            case GET_RES:
                pRange->SteppingDelta = lData;
                break;
        }
    }

    return ntStatus;
}

// Begin PIN Based Audio Properties
NTSTATUS
GetSampleRate( PKSPIN pKsPin, PULONG pSampleRate )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFormatType = pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
        PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

        *pSampleRate = pT1PinContext->ulOriginalSampleRate;

        return STATUS_SUCCESS;
    }
    else
        return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
SetSampleRate( PKSPIN pKsPin, PULONG pSampleRate )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFormatType = pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pUsbAudioDataRange->pAudioDescriptor;
    BOOLEAN fSRSettable =
        (( pUsbAudioDataRange->pAudioEndpointDescriptor->bmAttributes & ENDPOINT_SAMPLE_FREQ_MASK ) != 0 );
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Hack to fix bug in bmAttributes on Canopus device
    if ( ( !fSRSettable ) &&
            ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) &&
            ( pAudioDescriptor->bSampleFreqType > 1) ) {
         fSRSettable = TRUE;
    }

    else if ( !IsSampleRateInRange( pAudioDescriptor,
                                    *pSampleRate,
                                    ulFormatType ) ) {
         ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( NT_SUCCESS(ntStatus) && fSRSettable ) {
        ntStatus =
            GetSetProperty( pPinContext->pNextDeviceObject,
                            URB_FUNCTION_CLASS_ENDPOINT,
                            USBD_TRANSFER_DIRECTION_OUT,
                            (UCHAR)SET_CUR,
                            SAMPLING_FREQ_CONTROL,
                            0,
                            0,
                            pUsbAudioDataRange->pEndpointDescriptor->bEndpointAddress,
                            pSampleRate,
                            3 ); // 3 byte sample rate value

    }

    if ( NT_SUCCESS(ntStatus) ) {
        if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
                PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("[SetSampleRate] Setting sample rate from %d to %d\n",
                            pT1PinContext->ulCurrentSampleRate, *pSampleRate));

                pT1PinContext->ulOriginalSampleRate = *pSampleRate;
                pT1PinContext->ulCurrentSampleRate  = *pSampleRate;
                pT1PinContext->fSampleRateChanged = TRUE;
            }
            else {
                PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;

                PKSDATAFORMAT_WAVEFORMATEX pFmt = (PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat;
                pCapturePinContext->ulCurrentSampleRate = *pSampleRate;
                pCapturePinContext->ulAvgBytesPerSec    = pCapturePinContext->ulCurrentSampleRate *
                                                          pCapturePinContext->ulBytesPerSample;
            }
        }
    }

    return ntStatus;

}

NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    NTSTATUS ntStatus;

    TRAP;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( pKsProperty->Flags & KSPROPERTY_TYPE_GET ) {
        ntStatus = GetSampleRate( pKsPin, (PULONG)pValue );
    }
    else{
        ntStatus = SetSampleRate( pKsPin, (PULONG)pValue );
    }

    if ( NT_SUCCESS(ntStatus )) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}


NTSTATUS
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    PAUDIO_GENERAL_STREAM pGeneralDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSTIME pLatency = (PKSTIME) pValue;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;
    pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;

    // Find the general descriptor
    pGeneralDescriptor =
        (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                    pPinContext->pHwDevExt->pConfigurationDescriptor,
                                    pUsbAudioDataRange->pInterfaceDescriptor,
                                    AS_GENERAL);
    if ( pGeneralDescriptor ) {

        pLatency->Time = pGeneralDescriptor->bDelay;
        pLatency->Numerator = 10000;
        pLatency->Denominator = 1;

        pIrp->IoStatus.Information = sizeof (KSTIME);
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

NTSTATUS
GetAudioPosition( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PKSAUDIO_POSITION pPosition = pValue;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(pProperty->Flags & KSPROPERTY_TYPE_GET);

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    pPosition->WriteOffset = pPinContext->ullWriteOffset;

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT )
        ntStatus = CaptureBytePosition(pKsPin, pPosition);

    // Otherwise initialize render stream structures based on stream type.
    else {

        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderBytePosition( pPinContext, pPosition );
                break;

            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                // ISSUE-2001/01/12-dsisolak: This is not right. Needs repair...
                pPosition->PlayOffset = pPinContext->ullWriteOffset;
                break;
        }
    }

    DbgLog("GetPos", pPinContext, pPinContext->ullWriteOffset,
                     pPosition->WriteOffset, pPosition->PlayOffset);

    pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);

    return ntStatus;
}


// Begin NODE Based Audio Properties

NTSTATUS
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PKSAUDIO_COPY_PROTECTION pProtect = (PKSAUDIO_COPY_PROTECTION) pData;
    UCHAR RequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;
    ULONG ulData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);

    if (pKsProperty->Flags & KSPROPERTY_TYPE_SET) {
        ulData = ((pProtect->fOriginal && pProtect->fCopyrighted) ? 1 : pProtect->fOriginal ? 2 : 0);
    }

    ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                           pNodeInfo,
                           0,
                           &ulData,
                           RequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        if (pKsProperty->Flags & KSPROPERTY_TYPE_SET) {
            pProtect->fCopyrighted = ulData;
            pProtect->fOriginal = (ulData & 0x01);
        }

        pIrp->IoStatus.Information = sizeof (KSAUDIO_COPY_PROTECTION);
    }

    return ntStatus;
}

NTSTATUS
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    KSAUDIO_CHANNEL_CONFIG *pKsAudioChannelConfig = pData;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);

    // Build the channel config data
    pKsAudioChannelConfig->ActiveSpeakerPositions =
         GetChannelConfigForUnit( pFilterContext->pHwDevExt->pConfigurationDescriptor,
                                  ((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID );

    if (pKsAudioChannelConfig->ActiveSpeakerPositions == 0) {
        ULONG ulNumChannels = CountInputChannels( pFilterContext->pHwDevExt->pConfigurationDescriptor,
                                                  (ULONG)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID);
        if (ulNumChannels == 1)
            pKsAudioChannelConfig->ActiveSpeakerPositions = KSAUDIO_SPEAKER_MONO;
        else
            pKsAudioChannelConfig->ActiveSpeakerPositions = SPEAKER_RESERVED;
    }

    pIrp->IoStatus.Information = sizeof(KSAUDIO_CHANNEL_CONFIG);
    return ntStatus;
}


NTSTATUS
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;

    USHORT UnitNumber;
    USHORT CtrlIf;
    PAUDIO_MIXER_UNIT pMixer;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels;
    PSHORT pUsbMin, pUsbMax, pUsbRes, pUsbCur;
    ULONG nChannels, InputChannels, OutChannels, PinChannels;
    ULONG ChannelIndex, i, siz;
    PKSAUDIO_MIX_CAPS pMixCaps;
    PKSAUDIO_MIXLEVEL pMixLevel;
    PKSAUDIO_MIXCAP_TABLE pMixCapTable = NULL;
    PKSAUDIO_MIXLEVEL pMixLevelTable = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo  = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pHwDevExt  = pFilterContext->pHwDevExt;
    UnitNumber = (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID;
    CtrlIf     = pNodeInfo->MapNodeToCtrlIF;

    if ( pKsProperty->Id == KSPROPERTY_AUDIO_MIX_LEVEL_TABLE )
        pMixLevelTable = pValue;
    else if ( pKsProperty->Id == KSPROPERTY_AUDIO_MIX_LEVEL_CAPS )
        pMixCapTable = pValue;

    // We have to figure out how many output channels we have.
    pMixer = pNodeInfo->pUnit;

    pMixChannels = (PAUDIO_MIXER_UNIT_CHANNELS)(pMixer->baSourceID + pMixer->bNrInPins);

    OutChannels = pMixChannels->bNrChannels;

    // Now we have to figure out how many input channels we have.
    InputChannels = 0;
    for (i=0; i < pMixer->bNrInPins; i++) {
        // For each input pin, we walk the stream to discover the number of input channels.
        nChannels = CountInputChannels( pHwDevExt->pConfigurationDescriptor,
                                        pMixer->baSourceID[i] );
        InputChannels += nChannels;
        if ( i == pNodeInfo->ulPinNumber ) {
            PinChannels = nChannels;
            ChannelIndex = (InputChannels - nChannels) * OutChannels;
        }
    }

    // Calculate the size of the mix level table
    siz = InputChannels * OutChannels * sizeof(SHORT);

    if ( pMixCapTable ) {
        pMixCapTable->InputChannels  = PinChannels;
        pMixCapTable->OutputChannels = OutChannels;

        // If the request is simply for the number of input and output channels fill in structure and
        // return
        if ( pIrp->IoStatus.Information == 2*sizeof(ULONG) ) {
            return ntStatus;
        }
    }

    pUsbMin = AllocMem(NonPagedPool, siz*4); // Min, Max, Res, and Current
    if ( !pUsbMin ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize pointers for these even if we don't use them all
    pUsbMax = (PUSHORT)((PUCHAR)pUsbMin + siz);
    pUsbRes = (PUSHORT)((PUCHAR)pUsbMax + siz);
    pUsbCur = (PUSHORT)((PUCHAR)pUsbRes + siz);

    // If getting mix Caps and only want # of channels
    if ( pMixCapTable ) {

        // Get Min, Max, and Res
        for ( i=GET_MIN; i<GET_RES; i++ ) {
            ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_IN,
                                (UCHAR)i,
                                0,  // We get all the controls at once
                                0,
                                UnitNumber,
                                CtrlIf,
                                (PUCHAR)pUsbMin+(siz*i),
                                siz );

            if ( !NT_SUCCESS(ntStatus) ) {
                FreeMem( pUsbMin );
                return ntStatus;
            }
        }
    }

    // Get/Set the current values
    if ( pMixLevelTable) {

        // Get the minimum values
        ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_MIN,
                               0,  // We get all the controls at once
                               0,
                               UnitNumber,
                               CtrlIf,
                               pUsbMin,
                               siz );

        if ( !NT_SUCCESS(ntStatus) ) {
            FreeMem(pUsbMin);
            return ntStatus;
        }

        ntStatus = GetSetProperty(pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_IN,
                                GET_CUR,
                                0,  // We get all the controls at once
                                0,
                                UnitNumber,
                                CtrlIf,
                                pUsbCur,
                                siz );

        if (!NT_SUCCESS(ntStatus)) {
            FreeMem( pUsbMin );
            return ntStatus;
        }

        if ( pKsProperty->Flags & KSPROPERTY_TYPE_SET ) {
           PUCHAR pCtrlBitmap = pMixChannels->bmControls;
           ULONG bmBytes = ((InputChannels*OutChannels)/8) +
                           (((InputChannels*OutChannels)%8) > 0) - 1;
           ULONG j, k;
            // Map the mix values to the usb structure
            pMixLevel = pMixLevelTable;
            for (i=0; i < PinChannels * OutChannels; i++) {
                if (pMixLevel->Mute)
                    pUsbCur[ChannelIndex + i] = pUsbMin[ChannelIndex + i];
                else
                    pUsbCur[ChannelIndex + i] = (SHORT)(pMixLevel->Level / DB_SCALE_16BIT);
                pMixLevel++;
            }

            k=0;
            for ( i=0; i<InputChannels*OutChannels; i++) {
                j = bmBytes - (i/8);
                if (pCtrlBitmap[j] & 0x80>>(i%8)) {
                    pUsbCur[k++] = pUsbCur[i];
                }
            }

            // Set the mix table
            ntStatus = GetSetProperty(pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_OUT,
                                SET_CUR,
                                (USHORT)0xFF,  // We get all the controls at once
                                (USHORT)0xFF,
                                UnitNumber,
                                CtrlIf,
                                pUsbCur,
                                k*sizeof(SHORT) );

            if (!NT_SUCCESS(ntStatus)) {
                FreeMem( pUsbMin );
                return ntStatus;
            }
        }
    }

    // Map the mix values to our structure.
    if ( pKsProperty->Flags & KSPROPERTY_TYPE_GET ) {
        pMixCaps = pMixCapTable->Capabilities;
        pMixLevel = pMixLevelTable;
        for (i=0; i < PinChannels * OutChannels; i++) {
            if (pMixCapTable) {
                pMixCaps->Minimum = (LONG)((SHORT)pUsbMin[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Maximum = (LONG)((SHORT)pUsbMax[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Reset   = (LONG)((SHORT)pUsbRes[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Mute    = TRUE;
                pMixCaps++;
            }
            else if (pMixLevelTable) {
                pMixLevel->Level = (LONG)((SHORT)pUsbCur[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixLevel->Mute  = (pUsbCur[ChannelIndex+i] == pUsbMin[ChannelIndex+i]);
                pMixLevel++;
            }
        }
    }

    if (pMixCapTable) {
        pIrp->IoStatus.Information = (2*sizeof(ULONG)) +
                    PinChannels * OutChannels * sizeof (KSAUDIO_MIX_CAPS);
    }
    else if (pMixLevelTable) {
        pIrp->IoStatus.Information = PinChannels * OutChannels * sizeof (KSAUDIO_MIXLEVEL);
    }

    FreeMem(pUsbMin);

    return STATUS_SUCCESS;
}

NTSTATUS
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    PAUDIO_SELECTOR_UNIT pSel;
    NTSTATUS ntStatus;
    UCHAR ucData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pSel = pNodeInfo->pUnit;

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_CUR,
                               0,
                               0,
                               (USHORT)pSel->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               &ucData,
                               sizeof(UCHAR) );

    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    *(PULONG)pValue = (ULONG)ucData;

    pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    PAUDIO_SELECTOR_UNIT pSel;
    NTSTATUS ntStatus;
    UCHAR ucData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pSel = pNodeInfo->pUnit;

    // Data is the pin number.
    ucData = *(PUCHAR)pValue;

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_OUT,
                               SET_CUR,
                               0,
                               0,
                               (USHORT) pSel->bUnitID,
                               (USHORT) pNodeInfo->MapNodeToCtrlIF,
                               &ucData,
                               sizeof(UCHAR) );

    pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
GetEqualizerValues(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    USHORT usChannel,
    UCHAR  Command,
    PLONG  EqLevel,
    PULONG EqBands,
    PULONG NumEqBands)
{

    PUCHAR pData;
    // NOTE: The second one is really 31.5 Hz - how should we handle it?
    ULONG BandFreq[] =
        { 25,   32,   40,   50,   63,   80,   100,   125,   160,   200,
          250,  315,  400,  500,  630,  800,  1000,  1250,  1600,  2000,
          2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000 };
    ULONG siz;
    ULONG bmBandsPresent;
    ULONG Band;
    ULONG UsbBand;
    NTSTATUS Status;

    // TODO: Optimize by setting up cache for EQ

    // Allocate space for 30 bands
    siz = MAX_EQ_BANDS * sizeof(UCHAR) + sizeof(ULONG);
    pData = AllocMem(NonPagedPool, siz);
    if ( !pData ) return STATUS_INSUFFICIENT_RESOURCES;

    Status = GetSetProperty( pNextDeviceObject,
                             URB_FUNCTION_CLASS_INTERFACE,
                             USBD_TRANSFER_DIRECTION_IN,
                             Command,
                             GRAPHIC_EQUALIZER_CONTROL,
                             (USHORT)(usChannel + 1),
                             (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                             (USHORT)pNodeInfo->MapNodeToCtrlIF,
                             pData,
                             siz );

      if (NT_SUCCESS(Status)) {

        bmBandsPresent = *((PULONG)pData);
        Band = 0;
        UsbBand = 0;

        if (NumEqBands) *NumEqBands = 0;
        while (bmBandsPresent) {
            if (bmBandsPresent & 1) {
                // Put the data into our structure
                if (EqLevel)
                    EqLevel[Band] = (LONG)((CHAR)pData[sizeof(ULONG)+Band]) * DB_SCALE_8BIT;
                else if (EqBands)
                    EqBands[Band] = BandFreq[UsbBand];
                if (NumEqBands)
                    (*NumEqBands)++;

                Band++;
            }
            bmBandsPresent >>= 1;
            UsbBand++;
        }
      }

    FreeMem(pData);

    return Status;
}

NTSTATUS
SetEqualizerValues(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    USHORT usChannel,
    PULONG pNumBands,
    PLONG  EqLevel )
{
    USHORT UnitNumber = (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID;
    USHORT CtrlIF     = (USHORT)pNodeInfo->MapNodeToCtrlIF;
    ULONG siz, bmBandsPresent, Band, UsbBand;
    NTSTATUS ntStatus;
    PUCHAR pData;

    // Allocate space for 30 bands
    siz = MAX_EQ_BANDS * sizeof(UCHAR) + sizeof(ULONG);
    pData = AllocMem(NonPagedPool, siz);
    if (!pData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Get the bands present
    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_CUR,
                               GRAPHIC_EQUALIZER_CONTROL,
                               (USHORT)(usChannel + 1),
                               UnitNumber,
                               CtrlIF,
                               pData,
                               siz );

    if (!NT_SUCCESS(ntStatus) ) {
        FreeMem(pData);
        return ntStatus;
    }

    bmBandsPresent = *((PULONG)pData);
    Band = 0;
    UsbBand = 0;
    while (bmBandsPresent) {
        if (bmBandsPresent & 1) {
            // Put the data into the usb structure
            pData[sizeof(ULONG) + Band] = (UCHAR) (EqLevel[Band] / DB_SCALE_8BIT);
            Band++;
        }
        bmBandsPresent >>= 1;
        UsbBand++;
    }

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_OUT,
                               SET_CUR,
                               GRAPHIC_EQUALIZER_CONTROL,
                               (USHORT)(usChannel + 1),
                               UnitNumber,
                               CtrlIF,
                               pData,
                               Band + sizeof(ULONG) );

    *pNumBands = Band;

    FreeMem(pData);

    return ntStatus;
}

NTSTATUS
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   (USHORT)pNAC->Channel,
                                   GET_CUR,
                                   NULL,
                                   NULL,
                                   pValue );

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   (USHORT)pNAC->Channel,
                                   GET_CUR,
                                   NULL,
                                   pValue,
                                   &ulNumBands );

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = sizeof(ULONG) * ulNumBands;

    return ntStatus;
}


NTSTATUS
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    if ( pProperty->Flags & KSPROPERTY_TYPE_GET ) {
        ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                       pNodeInfo,
                                       (USHORT)pNAC->Channel,
                                       GET_CUR,
                                       pValue,
                                       NULL,
                                       &ulNumBands );
    }
    else if ( pProperty->Flags & KSPROPERTY_TYPE_SET ) {
        ntStatus = SetEqualizerValues( pFilterContext->pNextDeviceObject,
                                       pNodeInfo,
                                       (USHORT)pNAC->Channel,
                                       &ulNumBands,
                                       pValue );
    }

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = ulNumBands * sizeof(LONG);

    return ntStatus;
}

NTSTATUS
GetEqDbRanges( PDEVICE_OBJECT pNextDeviceObject,
               PTOPOLOGY_NODE_INFO pNodeInfo,
               USHORT usChannel,
               PKSPROPERTY_STEPPING_LONG pEqBandSteps )
{
    ULONG ulNumEqBands;
    PLONG pMinEqLevels;
    PLONG pMaxEqLevels;
    PLONG pResEqLevels;
    NTSTATUS ntStatus;
    ULONG i, j;

    ntStatus = GetEqualizerValues( pNextDeviceObject,
                                   pNodeInfo,
                                   usChannel,
                                   GET_CUR,
                                   NULL,
                                   NULL,
                                   &ulNumEqBands );

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    pMinEqLevels = (PULONG)AllocMem( NonPagedPool, 3*ulNumEqBands*sizeof(LONG) );
    if ( !pMinEqLevels ) return STATUS_INSUFFICIENT_RESOURCES;

    pMaxEqLevels = pMinEqLevels + ulNumEqBands;
    pResEqLevels = pMaxEqLevels + ulNumEqBands;

    for ( i=GET_MIN, j=0; i<=GET_RES; i++, j++ ) {
        ntStatus = GetEqualizerValues( pNextDeviceObject,
                                       pNodeInfo,
                                       usChannel,
                                       (UCHAR)i,
                                       pMinEqLevels + (ulNumEqBands*j),
                                       NULL,
                                       NULL );
        if ( !NT_SUCCESS(ntStatus) ) {
            FreeMem(pMinEqLevels);
            return ntStatus;
        }

    }

    for (i=0; i<ulNumEqBands; i++) {
        pEqBandSteps[i].Bounds.SignedMinimum = pMinEqLevels[i];
        pEqBandSteps[i].Bounds.SignedMaximum = pMaxEqLevels[i];
        pEqBandSteps[i].SteppingDelta        = pResEqLevels[i];
    }

    FreeMem(pMinEqLevels);

    return ntStatus;

}

NTSTATUS
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC pDevSpecNodeProp =
                                    (PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC) pProperty;
    UCHAR  bRequest = (UCHAR)((pDevSpecNodeProp->DevSpecificId & 0xFF000000)>>24);
    UCHAR  bmRequestType = (UCHAR)((pDevSpecNodeProp->DevSpecificId & 0x00FF0000)>>16);
    USHORT wValue = (USHORT)(pDevSpecNodeProp->DevSpecificId & 0xFFFF);
    USHORT wIndex = (USHORT)((pDevSpecNodeProp->DeviceInfo & 0xFFFF0000)>>16);
    USHORT wLength = (USHORT)(pDevSpecNodeProp->DeviceInfo & 0xFFFF);
    ULONG  DirectionFlag;
    USHORT FunctionClass;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (pKsFilter) {
        pFilterContext = pKsFilter->Context;
    }

    if (!pFilterContext) {
        return STATUS_INVALID_PARAMETER;
    }

    DirectionFlag = (bRequest & CLASS_SPECIFIC_GET_MASK) ? USBD_TRANSFER_DIRECTION_IN :
                                                           USBD_TRANSFER_DIRECTION_OUT;

    FunctionClass = (bmRequestType == USB_COMMAND_TO_INTERFACE) ? URB_FUNCTION_CLASS_INTERFACE :
                    (bmRequestType == USB_COMMAND_TO_ENDPOINT)  ? URB_FUNCTION_CLASS_ENDPOINT  :
                    0;

    if ( !FunctionClass ) {
        return STATUS_NOT_SUPPORTED;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("'DevSpecificId: %x\n",pDevSpecNodeProp->DevSpecificId));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'DeviceInfo: %x\n",pDevSpecNodeProp->DeviceInfo));


    _DbgPrintF(DEBUGLVL_VERBOSE,("'FunctionClass: %x\n",FunctionClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'DirectionFlag: %x\n",DirectionFlag));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'bRequest: %x\n",bRequest));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'bmRequestType: %x\n",bmRequestType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wValue: %x\n",wValue));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wIndex: %x\n",wIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wLength: %x\n",wLength));

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               FunctionClass,
                               DirectionFlag,
                               bRequest,
                               (USHORT) ((wValue & 0xFF00)>>8),
                               (USHORT) (wValue & 0xFF),
                               (USHORT) ((wIndex & 0xFF00)>>8),
                               (USHORT) (wIndex & 0xFF),
                               pValue,
                               wLength );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = (ULONG)wLength;
    }

    return ntStatus;
}


NTSTATUS
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    PPROCESS_CTRL_RANGE pPCtrlRange;

    ULONG ulControlType =
          (pProperty->Id == KSPROPERTY_AUDIO_REVERB_LEVEL) ? REVERB_LEVEL_CONTROL :
          (pProperty->Id == KSPROPERTY_AUDIO_CHORUS_LEVEL) ? CHORUS_LEVEL_CONTROL :
                                                             SPACIOUSNESS_CONTROL ;
    ULONG ulData;
    NTSTATUS ntStatus;

//    TRAP;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pProperty)->NodeId);
    pPCtrlCache = (PPROCESS_CTRL_CACHE)(pNodeInfo->pCachedValues);
    pPCtrlRange = (PPROCESS_CTRL_RANGE)(pPCtrlCache+1);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetAudioControlLevel] pNodeInfo %x\n",pNodeInfo));

    if ( pNodeInfo->ulControlType != ulControlType ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( SET_CUR == ucRequestType ) {
        ulData = (*((PULONG)pValue)) / 0x10000L;
    }

    ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                           pNodeInfo,
                           0,
                           &ulData,
                           ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        if ( GET_CUR == ucRequestType ) {
            *((PULONG)pValue) = ulData * 0x10000L;
        }
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}


NTSTATUS
GetSetBoolean( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    ULONG ulChannel = pNAC->Channel;
    PBOOLEAN_CTRL_CACHE pBoolCache;
    UCHAR ucRequestType  = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);
    pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetBoolean] pNodeInfo %x\n",pNodeInfo));

    // Determine if this is a request for beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pBoolCache += ulChannel;
    DbgLog("GSBool", &pNodeInfo, ulChannel, pBoolCache, pBoolCache->ulChannelIndex );

    if ( pNodeInfo->ulCacheValid & (1<<ulChannel)  ) {
        if ( ucRequestType == GET_CUR ) {
            *(PBOOL)pValue = pBoolCache->fLastValueSet;
            ntStatus = STATUS_SUCCESS;
        }
        else if ( pBoolCache->fLastValueSet == *(PBOOL)pValue ){
            ntStatus = STATUS_SUCCESS;
        }
        else {
            ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   pBoolCache->ulChannelIndex,
                                   pValue,
                                   ucRequestType );
        }
    }
    else {
        ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                               pNodeInfo,
                               pBoolCache->ulChannelIndex,
                               pValue,
                               ucRequestType );

        if ( NT_SUCCESS(ntStatus) ) {
            pNodeInfo->ulCacheValid |= (1<<ulChannel) ;
        }
    }

    if ( NT_SUCCESS(ntStatus)) {
        pBoolCache->fLastValueSet = *(PBOOL)pValue;
        pIrp->IoStatus.Information = sizeof(BOOL);
    }

    return ntStatus;
}

NTSTATUS
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetVolumeLevel] pNodeInfo %x\n",pNodeInfo));
//    TRAP;

    ntStatus = GetSetDBLevel( pFilterContext->pNextDeviceObject,
                              pNodeInfo,
                              pValue,
                              pNAC->Channel,
                              16,
                              ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetToneLevel] pNodeInfo %x\n",pNodeInfo));

    ntStatus = GetSetDBLevel( pFilterContext->pNextDeviceObject,
                              pNodeInfo,
                              pValue,
                              pNAC->Channel,
                              8,
                              ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] pNodeInfo %x NodeId %x\n",
                                 pNodeInfo,
                                 pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] ulChannelConfig %x ulNumChannels %x\n",
                                     pNodeInfo->ulChannelConfig,
                                     ulNumChannels));

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                       sizeof(KSPROPERTY_MEMBERSHEADER);
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_BOOL;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);

            pMembers->MembersFlags = 0;
            pMembers->MembersSize  = 0;
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->ulChannelConfig & 1) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }
            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
        }
    }

    return ntStatus;
}

NTSTATUS
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupport] pNodeInfo %x NodeId %x\n",pNodeInfo,pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        if ( pNodeProperty->Property.Id == KSPROPERTY_AUDIO_EQ_LEVEL ) {
            ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                           pNodeInfo,
                                           (USHORT)0xffff, // NOTE: Assuming master channel
                                           GET_CUR,
                                           NULL,
                                           NULL,
                                           &ulNumChannels );
            if ( !NT_SUCCESS( ntStatus ) )
                return ntStatus;
        }

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION)   +
                                       sizeof(KSPROPERTY_MEMBERSHEADER) +
                                       (sizeof(KSPROPERTY_STEPPING_LONG) * ulNumChannels );
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_I4;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);
            PKSPROPERTY_STEPPING_LONG pRange   = (PKSPROPERTY_STEPPING_LONG)(pMembers + 1);

            pMembers->MembersFlags = KSPROPERTY_MEMBER_STEPPEDRANGES;
            pMembers->MembersSize  = sizeof(KSPROPERTY_STEPPING_LONG);
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->ulChannelConfig & 1) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }

            switch ( pNodeProperty->Property.Id ) {
                case KSPROPERTY_AUDIO_VOLUMELEVEL:
                case KSPROPERTY_AUDIO_BASS:
                case KSPROPERTY_AUDIO_MID:
                case KSPROPERTY_AUDIO_TREBLE:
                    {
                        ULONG ulControlType =
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_VOLUMELEVEL) ? VOLUME_CONTROL  :
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_BASS)        ? BASS_CONTROL  :
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_MID )        ? MID_CONTROL   :
                                                                                           TREBLE_CONTROL;
                        PDB_LEVEL_CACHE pDbCache = pNodeInfo->pCachedValues;
                        ULONG ulControlSize = (ulControlType == VOLUME_CONTROL ) ? 16 : 8;
                        ULONG i;

                        for (i=0; i<ulNumChannels; i++) {
                            if (pNodeInfo->ulCacheValid & (1<<i)) { // If we already got this don't do it again
                                RtlCopyMemory(&pRange[i],&pDbCache[i].Range, sizeof(KSPROPERTY_STEPPING_LONG));
                                ntStatus = STATUS_SUCCESS;
                            }
                            else {
                                ntStatus = GetDbLevelRange( pFilterContext->pNextDeviceObject,
                                                            pNodeInfo,
                                                            pDbCache[i].ulChannelIndex,
                                                            ulControlSize,
                                                            &pRange[i] );
                                if ( !NT_SUCCESS(ntStatus) ) {
                                    break;
                                }
                            }
                        }

                        if ( NT_SUCCESS(ntStatus) )
                            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    }
                    break;

                case KSPROPERTY_AUDIO_EQ_LEVEL:
                    ntStatus = GetEqDbRanges( pFilterContext->pNextDeviceObject,
                                              pNodeInfo,
                                              (USHORT)0xffff, //NOTE: Assuming master channel
                                              pRange );
                    pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    break;

                case KSPROPERTY_AUDIO_WIDENESS:
                    // Need a range of spaciousness percentages
                default:
                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
            }
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    UCHAR ucCommand;
    PBOOL pEnable = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo   = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);
    pPCtrlCache = (PPROCESS_CTRL_CACHE)pNodeInfo->pCachedValues;
    ucCommand   = (pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET ) ?
                                        (UCHAR)GET_CUR : (UCHAR)SET_CUR;

    switch ( pNodeInfo->ulNodeType ) {
        case NODE_TYPE_SUPERMIX:
        case NODE_TYPE_PROLOGIC:
        case NODE_TYPE_STEREO_WIDE:
        case NODE_TYPE_REVERB:
        case NODE_TYPE_CHORUS:
            if ( pPCtrlCache ) {
                if ( pPCtrlCache->fEnableBit ) {
                    ntStatus =
                      GetSetProcessingUnitEnable(  pFilterContext->pNextDeviceObject,
                                                   pNodeInfo,
                                                   ucCommand,
                                                   pEnable );

                    if (NT_SUCCESS(ntStatus)) {
                        pPCtrlCache->fEnabled = *pEnable;
                    }
                }
            }
            break;
        default:
            break;
    }

    return ntStatus;
}

//----------------------------------------------------------------------------
//
// Restore node property values after standby
//
//----------------------------------------------------------------------------

VOID
RestoreCachedSettings(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PTOPOLOGY_NODE_INFO pNodeInfo = (PTOPOLOGY_NODE_INFO)pUSBAudioFilterDescriptor->NodeDescriptors;

    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus = STATUS_SUCCESS;

    LONG ScaleFactor;
    LONG lData;

    ULONG ulChannel;
    ULONG ulNodeId;

    _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: pHwDevExt = %x\n", pHwDevExt));

    // Loop through all of the nodes restoring the caches values for all
    for (ulNodeId=0; ulNodeId<pUSBAudioFilterDescriptor->NodeDescriptorsCount; ulNodeId++, pNodeInfo++) {

        _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: Node=%d, pNodeInfo=%x\n",ulNodeId,pNodeInfo));

        switch ( pNodeInfo->ulControlType ) {
            case MUTE_CONTROL :
            case BASS_BOOST_CONTROL :
            case GRAPHIC_EQUALIZER_CONTROL :
            case AUTOMATIC_GAIN_CONTROL :
            case LOUDNESS_CONTROL :
               {
                   PBOOLEAN_CTRL_CACHE pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;
                   for (ulChannel = 0; ulChannel < pNodeInfo->ulChannels; ulChannel++, pBoolCache++) {
                       _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: BoolVal=%d\n",pBoolCache->fLastValueSet));

                       if (!(pNodeInfo->ulCacheValid & (1<<ulChannel))) {
                           continue;
                       }

                       ntStatus = GetSetByte( pHwDevExt->pNextDeviceObject,
                                              pNodeInfo,
                                              pBoolCache->ulChannelIndex,
                                              (PULONG)&pBoolCache->fLastValueSet,
                                              SET_CUR );
                   }
               } break;

            case VOLUME_CONTROL :
            case TREBLE_CONTROL :
            case MID_CONTROL :
            case BASS_CONTROL :
            case DELAY_CONTROL :
               {
                   PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
                   if (pNodeInfo->ulControlType == VOLUME_CONTROL) {
                       ScaleFactor = DB_SCALE_16BIT;
                       GetSetFunc  = GetSetShort;
                   }
                   else {
                       ScaleFactor = DB_SCALE_8BIT;
                       GetSetFunc  = GetSetByte;
                   }

                   for (ulChannel = 0; ulChannel < pNodeInfo->ulChannels; ulChannel++, pDbCache++) {

                       if (!(pNodeInfo->ulCacheValid & (1<<ulChannel))) {
                           continue;
                       }

                       lData = pDbCache->lLastValueSet;

                       if ( lData < pDbCache->Range.Bounds.SignedMinimum ) {
                           if ( ScaleFactor == 16 )
                               lData = NEGATIVE_INFINITY; // Hack to detect volume control to silence
                           else
                               lData = pDbCache->Range.Bounds.SignedMinimum / ScaleFactor;
                       }
                       else if ( lData > pDbCache->Range.Bounds.SignedMaximum ) {
                           lData = pDbCache->Range.Bounds.SignedMaximum / ScaleFactor;
                       }
                       else {
                           lData = lData / ScaleFactor;
                       }

                       _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: SetVal=%d\n",lData));
                       ntStatus = (*GetSetFunc)( pHwDevExt->pNextDeviceObject,
                                                 pNodeInfo,
                                                 pDbCache->ulChannelIndex,
                                                 &lData,
                                                 SET_CUR );
                    }
                } break;

            default :
                break;
        }

        if (!NT_SUCCESS(ntStatus)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: Failed on node %x, ntStatus=%x\n",ulNodeId,ntStatus));
        }
    }
}


//----------------------------------------------------------------------------
//
// Start DRM Propery Handlers
//
//----------------------------------------------------------------------------

NTSTATUS DrmAudioStream_SetContentId
(
    IN PIRP                          pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pData
)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PHW_DEVICE_EXTENSION pHwDevExt;
    DRMRIGHTS DrmRights;
    ULONG ContentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pHwDevExt = pFilterContext->pHwDevExt;

    KsPinAcquireProcessingMutex(pKsPin);

    // Extract content ID and rights
    ContentId = pData->ContentId;
    DrmRights = pData->DrmRights;

    // If device has digital outputs and rights require them disabled,
    //  then we fail since we have no way to disable the digital outputs.
    if (DrmRights.DigitalOutputDisable && pHwDevExt->fDigitalOutput) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmAudioStream_SetContentId] Found a digital endpoint and content has digital disabled\n"));
        ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        ASSERT(pProperty->DrmForwardContentToDeviceObject);

        // Forward content to common class driver PDO
        ntStatus = pProperty->DrmForwardContentToDeviceObject(ContentId,
                                                              pPinContext->pNextDeviceObject,
                                                              pPinContext->hPipeHandle);
        if ( NT_SUCCESS(ntStatus) ) {
            //  Store this in the pin context because we need to reforward if the pipe handle
            //  changes due to a power state change.
            pPinContext->DrmContentId = ContentId;
        }
    }

    KsPinReleaseProcessingMutex(pKsPin);

    return ntStatus;
}

//----------------------------------------------------------------------------
//
// End DRM Property Handlers
//
// Start RT Property Handlers
//
//----------------------------------------------------------------------------

#ifdef RTAUDIO
NTSTATUS RtAudio_GetAudioPositionFunction
(
    IN PIRP                          pIrp,
    IN PKSPROPERTY                   pProperty,
    OUT PRTAUDIOGETPOSITION         *pfnRtAudioGetPosition
)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    ASSERT(pPinContext->pUsbAudioDataRange);

    if (pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor == NULL) {
        *pfnRtAudioGetPosition = RtAudioTypeIGetPlayPosition;
        pIrp->IoStatus.Information = sizeof(*pfnRtAudioGetPosition);
        ntStatus = STATUS_SUCCESS;
    }
    else {
        //DbgPrint("RtAudio not supported on Async audio endpoint.\n");
        *pfnRtAudioGetPosition = NULL;
        pIrp->IoStatus.Information = 0;
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    return ntStatus;
}
#endif

//----------------------------------------------------------------------------
//
// End RT Property Handlers
//
// Start Building Property Sets
//
//----------------------------------------------------------------------------

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo )
{
    ULONG ulNodeType = pNodeInfo->ulNodeType;
    PKSPROPERTY_SET pPropSet = (PKSPROPERTY_SET)&NodePropertySetTable[ulNodeType];

    if ( pPropSet->PropertiesCount ) {
        pNodeInfo->KsAutomationTable.PropertySetsCount = 1;
        pNodeInfo->KsAutomationTable.PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pNodeInfo->KsAutomationTable.PropertySets      = pPropSet;
    }
}

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets )
{
    ULONG ulNumPinPropItems = 1;
    PKSPROPERTY_ITEM pPinProps = pDevPropItems;

    ASSERT(pNumSets);

    *pNumSets = 1; // There always is an Pin property set

    if ( pDevPropItems ) {
        RtlCopyMemory(pDevPropItems++, &PinPropertyItems[KSPROPERTY_PIN_NAME], sizeof(KSPROPERTY_ITEM) );

        if ( pDevPropSet ) {
            pDevPropSet->Set             = &KSPROPSETID_Pin;
            pDevPropSet->PropertiesCount = ulNumPinPropItems;
            pDevPropSet->PropertyItem    = pPinProps;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;
        }
    }

    if (pNumItems) {
        *pNumItems = ulNumPinPropItems;
    }

}

VOID
BuildPinPropertySet( PHW_DEVICE_EXTENSION pHwDevExt,
                     PKSPROPERTY_ITEM pStrmPropItems,
                     PKSPROPERTY_SET pStrmPropSet,
                     PULONG pNumItems,
                     PULONG pNumSets )
{
    ULONG NumAudioProps = 3;
    ULONG NumDrmAudioStreamProps = 1;
#ifdef RTAUDIO
    ULONG NumRtAudioProps = 1;
#else
    ULONG NumRtAudioProps = 0;
#endif
    ULONG NumStreamProps = 1;
    ULONG NumConnectionProps = 1;

    // For now we hardcode this to a known set.
#ifdef RTAUDIO
    *pNumSets = 5;
#else
    *pNumSets = 4;
#endif
    if (pNumItems) *pNumItems = NumAudioProps +
                                NumDrmAudioStreamProps +
                                NumRtAudioProps +
                                NumStreamProps +
                                NumConnectionProps;

    if (pStrmPropItems) {
        PKSPROPERTY_ITEM pAudItms = pStrmPropItems;
        PKSPROPERTY_ITEM pDRMItms = pStrmPropItems + NumAudioProps;
        PKSPROPERTY_ITEM pRtItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps);
        PKSPROPERTY_ITEM pStrmItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps+NumRtAudioProps);
        PKSPROPERTY_ITEM pConnItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps+NumRtAudioProps+NumStreamProps);
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_LATENCY], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_POSITION], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &DrmAudioStreamPropertyItems[KSPROPERTY_DRMAUDIOSTREAM_CONTENTID], sizeof(KSPROPERTY_ITEM) );
#ifdef RTAUDIO
        RtlCopyMemory(pStrmPropItems++, &RtAudioPropertyItems[KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION], sizeof(KSPROPERTY_ITEM) );
#endif
        RtlCopyMemory(pStrmPropItems++, &StreamItm[0], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems,   &ConnectionItm[0], sizeof(KSPROPERTY_ITEM) );

        if (pStrmPropSet) {

            // Audio Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Audio;
            pStrmPropSet->PropertiesCount = NumAudioProps;
            pStrmPropSet->PropertyItem    = pAudItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // DRM Property Set
            pStrmPropSet->Set             = &KSPROPSETID_DrmAudioStream;
            pStrmPropSet->PropertiesCount = NumDrmAudioStreamProps;
            pStrmPropSet->PropertyItem    = pDRMItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

#ifdef RTAUDIO
            // RT Property Set
            pStrmPropSet->Set             = &KSPROPSETID_RtAudio;
            pStrmPropSet->PropertiesCount = NumRtAudioProps;
            pStrmPropSet->PropertyItem    = pRtItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;
#endif

            // Stream Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Stream;
            pStrmPropSet->PropertiesCount = NumStreamProps;
            pStrmPropSet->PropertyItem    = pStrmItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // Connection Properties
            pStrmPropSet->Set             = &KSPROPSETID_Connection;
            pStrmPropSet->PropertiesCount = NumConnectionProps;
            pStrmPropSet->PropertyItem    = pConnItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\pin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       pin.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define USBMIDI_MIN_FRAMECOUNT  1
#define USBMIDI_MAX_FRAMECOUNT  10

NTSTATUS
USBAudioPinValidateDataFormat(
    PKSPIN pKsPin,
    PUSBAUDIO_DATARANGE pUSBAudioRange )
{
    PKSDATARANGE_AUDIO pKsDataRangeAudio = &pUSBAudioRange->KsDataRangeAudio;
    PKSDATAFORMAT pFormat = pKsPin->ConnectionFormat;
    NTSTATUS ntStatus = STATUS_NO_MATCH;
    union {
        PWAVEFORMATEX    pWavFmtEx;
        PWAVEFORMATPCMEX pWavFmtPCMEx;
    } u;

    u.pWavFmtEx = (PWAVEFORMATEX)(pFormat + 1);

    if ( IS_VALID_WAVEFORMATEX_GUID(&pKsDataRangeAudio->DataRange.SubFormat) ) {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pUSBAudioRange->pAudioDescriptor,
                                          u.pWavFmtEx->nSamplesPerSec,
                                          pUSBAudioRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) ){
                    if ( u.pWavFmtEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((u.pWavFmtPCMEx->Samples.wValidBitsPerSample == pUSBAudioRange->pAudioDescriptor->bBitsPerSample) &&
                            (u.pWavFmtPCMEx->dwChannelMask == pUSBAudioRange->ulChannelConfig))
                                ntStatus = STATUS_SUCCESS;
                    }
                    else if ((u.pWavFmtEx->nChannels <= 2) && (u.pWavFmtEx->wBitsPerSample <= 16)) {
                            ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
    }
    // else Type 2
    else {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pUSBAudioRange->pAudioDescriptor,
                                          u.pWavFmtEx->nSamplesPerSec,
                                          pUSBAudioRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) ){
                    ntStatus = STATUS_SUCCESS;
                }
            }
        }
    }

    return ntStatus;

}

NTSTATUS
USBAudioPinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] pin %d\n",pKsPin->Id));

    //  In the case of multiple filters created on a device the pin possible count is maintained on the
    //  device level in order to ensure that too many pins aren't opened on the device
    if ( pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount <
         pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount ) {

        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount++;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed with CurrentCount=%d and PossibleCount=%d\n",
                                   pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount,
                                   pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pPinContext,sizeof(PIN_CONTEXT));

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = pHwDevExt;
    pPinContext->pNextDeviceObject = pFilterContext->pNextDeviceObject;

    // Initialize hSystemStateHandle
    pPinContext->hSystemStateHandle = NULL;

    // Initialize the DRM Content ID
    pPinContext->DrmContentId = 0;

    // Find the Streaming Interface to match the data format of the Pin.
    pUsbAudioDataRange =
        GetUsbDataRangeForFormat( pKsPin->ConnectionFormat,
                                  (PUSBAUDIO_DATARANGE)pKsPin->Descriptor->PinDescriptor.DataRanges[0],
                                  pKsPin->Descriptor->PinDescriptor.DataRangesCount );
    if ( !pUsbAudioDataRange ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Save the USB DataRange Structure selected in the Pin Context
    pPinContext->pUsbAudioDataRange = pUsbAudioDataRange;

    // Get the Max Packet Size for the interface
    pPinContext->ulMaxPacketSize =
             GetMaxPacketSizeForInterface( pHwDevExt->pConfigurationDescriptor,
                                           pUsbAudioDataRange->pInterfaceDescriptor );

    // Rely on USB to fail the Select Interface call if there is not enough bandwidth.
    // This should result in one (and only one) popup from the USB UI component.
    //
    //if ( (LONG)pPinContext->ulMaxPacketSize >
    //                GetAvailableUSBBusBandwidth( pPinContext->pNextDeviceObject ) ) {
    //    return STATUS_INSUFFICIENT_RESOURCES;
    //}

    // Have the hardware select the interface
    ntStatus = SelectStreamingAudioInterface( pUsbAudioDataRange->pInterfaceDescriptor,
                                              pHwDevExt, pKsPin );
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    } else {
        ASSERT(pPinContext->hPipeHandle);
    }

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, NotificationEvent, FALSE );

    // Setup approriate allocator framing for the interface selected.
    ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor, USBAUDIO_POOLTAG );
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, USBAUDIO_POOLTAG );
    }

    //  KsEdit failed above
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Now do format specific initialization
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStreamInit( pKsPin );
        pPinContext->PinType = WaveIn;
    }
    else {
        switch( pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderStreamInit( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIRenderStreamInit( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
        pPinContext->PinType = WaveOut;
    }

    //  Failed to initialize pin
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    }

    return ntStatus;
}

NTSTATUS
USBAudioPinClose(
    IN PKSPIN pKsPin,
    IN PIRP Irp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(Irp);

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt || !pPinContext) {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinClose] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[PinClose] pin %d\n",pKsPin->Id));

    // Now do format specific close
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStreamClose( pKsPin );
    }
    else {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderStreamClose( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIRenderStreamClose( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    ntStatus = SelectZeroBandwidthInterface( pPinContext->pHwDevExt, pKsPin->Id );

    //  Free any existing pipe information
    if (pPinContext->Pipes) {
        FreeMem(pPinContext->Pipes);
    }

    pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;

    return ntStatus;
}

NTSTATUS
USBAudioPinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] pin %d\n",pKsPin->Id));

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStateChange( pKsPin, FromState, ToState );
    }
    else {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIStateChange( pKsPin, FromState, ToState );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIStateChange( pKsPin, FromState, ToState );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        if ( ToState == KSSTATE_RUN ) {
            if (!pPinContext->hSystemStateHandle) {
                // register the system state as busy
                pPinContext->hSystemStateHandle = PoRegisterSystemState( pPinContext->hSystemStateHandle,
                                                                         ES_SYSTEM_REQUIRED | ES_CONTINUOUS );
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PoRegisterSystemState %x\n",pPinContext->hSystemStateHandle));
            }
        }
        else {
            if (pPinContext->hSystemStateHandle) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PoUnregisterSystemState %x\n",pPinContext->hSystemStateHandle));
                PoUnregisterSystemState( pPinContext->hSystemStateHandle );
                pPinContext->hSystemStateHandle = NULL;
            }
        }
    }

    return ntStatus;
}


NTSTATUS
USBAudioPinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
{

    NTSTATUS ntStatus = STATUS_NO_MATCH;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDataFormat] pin %d\n",pKsPin->Id));

    // If the old format is not NULL then the pin has already been created.
    if ( OldFormat ) {
        PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
        ULONG ulFormatType = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;

        // If the pin has already been created make sure no other interface is used
        if ((PUSBAUDIO_DATARANGE)DataRange == pPinContext->pUsbAudioDataRange) {
            ntStatus = USBAudioPinValidateDataFormat(  pKsPin, (PUSBAUDIO_DATARANGE)DataRange );
        }

        if ( NT_SUCCESS(ntStatus) && (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED)) {
            PULONG pSampleRate = AllocMem(NonPagedPool, sizeof(ULONG));
            *pSampleRate =
                ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
            ntStatus = SetSampleRate( pKsPin, pSampleRate );
            FreeMem(pSampleRate);
        }
    }
    // Otherwise simply check if this is a valid format
    else
        ntStatus = USBAudioPinValidateDataFormat(  pKsPin, (PUSBAUDIO_DATARANGE)DataRange );

    return ntStatus;
}

NTSTATUS
USBAudioPinProcess(
    IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    DbgLog("PinProc", pKsPin, pPinContext, 0, 0);

    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIProcessStreamPtr( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIProcessStreamPtr( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                break;
        }
    }
    else
        ntStatus = CaptureProcess( pKsPin );

    return ntStatus;
}

void
USBAudioPinReset( PKSPIN pKsPin )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioPinReset] pin %d\n",pKsPin->Id));
    if (pKsPin->DataFlow == KSPIN_DATAFLOW_OUT) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Reset Capture pin %d\n",pKsPin->Id));
    }

}

NTSTATUS
USBAudioPinDataIntersect(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    ULONG ulPinId = pKsPinProperty->PinId;
    PKSPIN_DESCRIPTOR_EX pKsPinDescriptorEx;
    PUSBAUDIO_DATARANGE pUsbAudioRange;
    NTSTATUS ntStatus = STATUS_NO_MATCH;

    if (!pKsFilter) {
        return ntStatus;
    }

    pKsPinDescriptorEx = (PKSPIN_DESCRIPTOR_EX)&pKsFilter->Descriptor->PinDescriptors[ulPinId];

    pUsbAudioRange =
        FindDataIntersection((PKSDATARANGE_AUDIO)DataRange,
                             (PUSBAUDIO_DATARANGE *)pKsPinDescriptorEx->PinDescriptor.DataRanges,
                             pKsPinDescriptorEx->PinDescriptor.DataRangesCount);

    if ( pUsbAudioRange ) {

        *pDataSize = GetIntersectFormatSize( pUsbAudioRange );

        if ( !DataBufferSize ) {
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else if ( *pDataSize > DataBufferSize ) {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ( *pDataSize <= DataBufferSize ) {
            ConvertDatarangeToFormat( pUsbAudioRange,
                                      (PKSDATAFORMAT)pData );
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

VOID
USBAudioPinWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
}

VOID
USBMIDIOutPinWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;
    LARGE_INTEGER timeout;
    KIRQL irql;

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        // Specify a timeout of 1 second to wait for this call to complete.
        timeout.QuadPart = -10000 * 1000;

        ntStatus = KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &timeout );
        if (ntStatus == STATUS_TIMEOUT) {
             ntStatus = STATUS_IO_TIMEOUT;

            // Perform an abort
            //
            AbortUSBPipe( pPinContext );

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&pPinContext->PinStarvationEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
}

VOID
USBAudioPinReturnFromStandby(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulFormatType = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    NTSTATUS ntStatus;

    // Reselect the interface that was selected before the standby.
    ntStatus =
        SelectStreamingAudioInterface( pPinContext->pUsbAudioDataRange->pInterfaceDescriptor,
                                       pPinContext->pHwDevExt,
                                       pKsPin );

    // For those devices that require it reset the sample rate on the interface
    // if this is a Type I stream.
    if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
        ULONG ulSampleRate = ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
        ntStatus = SetSampleRate( pKsPin, &ulSampleRate );
    }

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
        pPinContext->fUrbError = FALSE;
        pCapturePinContext->fRunning = FALSE;
        pCapturePinContext->fProcessing = FALSE;
        pCapturePinContext->pCaptureBufferInUse = NULL;
        pCapturePinContext->ulIsochBuffer = 0;
        pCapturePinContext->ulIsochBufferOffset = 0;

        InitializeListHead( &pCapturePinContext->UrbErrorQueue );
        InitializeListHead( &pCapturePinContext->FullBufferQueue  );

        if (KSSTATE_RUN == pKsPin->DeviceState) {
            ntStatus = CaptureStartIsocTransfer( pPinContext );
        }
    }

    // Turn on Gate to begin sending data buffers to pin.
    KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );
    KsPinAttemptProcessing( pKsPin, TRUE );

}

VOID
USBAudioPinGoToStandby(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioPinGoToStandby] pKsPin: %x \n",pKsPin));

    // Turn off Gate to stop data buffers to pin.
    DbgLog("SBKsGt1", pKsPin, KsPinGetAndGate(pKsPin), 
                      KsPinGetAndGate(pKsPin)->Count, 0 );

    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    DbgLog("SBKsGt2", pKsPin, KsPinGetAndGate(pKsPin), 
                      KsPinGetAndGate(pKsPin)->Count, 0 );

    // Wait on mutex to ensure that any other processing on the pin is completed.
    KsPinAcquireProcessingMutex( pKsPin );

    // Release the mutex. The gate should hold off any further processing.
    KsPinReleaseProcessingMutex( pKsPin );

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
        pCapturePinContext->fRunning = FALSE;
    }

    // Abort the Pipe to force release of pending irps
    ntStatus = AbortUSBPipe( pPinContext );
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }

    DbgLog("SBAbrtd", pKsPin, pPinContext, 0, 0 );

    // If this is an Async endpoint device make sure no Async Poll
    // requests are still outstanding.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        if ( (pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK)
                == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
            if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
                PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
                KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                if ( pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
                    KeResetEvent( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent );
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                    KeWaitForSingleObject( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL );
                }
                else
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            }
        }
    }

    // Select the Zero Bandwidth interface.
    ntStatus = SelectZeroBandwidthInterface(pPinContext->pHwDevExt, pKsPin->Id);

    DbgLog("SBZbwIf", pKsPin, pPinContext, 0, 0 );

}

NTSTATUS
USBMIDIPinValidateDataFormat(
    PKSPIN pKsPin,
    PUSBAUDIO_DATARANGE pUSBAudioRange )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinValidateDataFormat] pin %d\n",pKsPin->Id));

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
USBMIDIPinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;
    ULONG ulInterfaceNumber;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinCreate] pin %d pKsFilter=%x\n",pKsPin->Id, pKsFilter));

    //  In the case of multiple filters created on a device the pin possible count is maintained on the
    //  device level in order to ensure that too many pins aren't opened on the device
    if ( pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount <
         pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount ) {

        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount++;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed with CurrentCount=%d and PossibleCount=%d\n",
                                   pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount,
                                   pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = pHwDevExt;
    pPinContext->pNextDeviceObject = pFilterContext->pNextDeviceObject;

    // Initialize hSystemStateHandle
    pPinContext->hSystemStateHandle = NULL;

    pPinContext->pMIDIPinContext = AllocMem( NonPagedPool, sizeof(MIDI_PIN_CONTEXT));
    if ( !pPinContext->pMIDIPinContext ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext->pMIDIPinContext, FreeMem);

    // Get the interface number and endpoint number for this MIDI pin
    GetContextForMIDIPin( pKsPin,
                          pHwDevExt->pConfigurationDescriptor,
                          pPinContext->pMIDIPinContext );

    // Get the Max Packet Size for the interface
    ulInterfaceNumber = pPinContext->pMIDIPinContext->ulInterfaceNumber;
    pEndpointDescriptor =
        GetEndpointDescriptor( pHwDevExt->pConfigurationDescriptor,
                               pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor,
                               FALSE);
    pPinContext->ulMaxPacketSize = (ULONG)pEndpointDescriptor->wMaxPacketSize;

    // Have the hardware select the interface
    ntStatus = SelectStreamingMIDIInterface( pHwDevExt, pKsPin );
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Set initial Outstanding Urb Count
    pPinContext->ulOutstandingUrbCount = 0;

    // Zero out Write counter
    pPinContext->ullWriteOffset = 0;

    // Clear the Urb Error Flag
    pPinContext->fUrbError = FALSE;

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, NotificationEvent, FALSE );

    // Setup approriate allocator framing for the interface selected.
    ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor, USBAUDIO_POOLTAG );
    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, USBAUDIO_POOLTAG );
        if ( NT_SUCCESS(ntStatus) ) {

            // Set up allocator
            pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = USBMIDI_MIN_FRAMECOUNT * sizeof(KSMUSICFORMAT);
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = USBMIDI_MAX_FRAMECOUNT * sizeof(KSMUSICFORMAT);
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = sizeof(KSMUSICFORMAT);
        }
    }

    //  KsEdit failed above
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Now initialize data flow specific features
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStreamInit( pKsPin );
        pPinContext->PinType = MidiIn;
    }
    else {
        ntStatus = USBMIDIOutStreamInit( pKsPin );
        pPinContext->PinType = MidiOut;
    }

    //  Failed to initialize MIDI pin
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    }

    return ntStatus;
}

NTSTATUS
USBMIDIPinClose(
    IN PKSPIN pKsPin,
    IN PIRP Irp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(Irp);

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt || !pPinContext) {
        _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinClose] pin %d\n",pKsPin->Id));

    // Now do format specific close
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStreamClose( pKsPin );
    }
    else {
        ntStatus = USBMIDIOutStreamClose( pKsPin );
    }

    pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    return ntStatus;
}

NTSTATUS
USBMIDIPinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinSetDeviceState] pin %d\n",pKsPin->Id));

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStateChange( pKsPin, FromState, ToState );
    }
    else {
        ntStatus = USBMIDIOutStateChange( pKsPin, FromState, ToState );
    }

    if ( ToState == KSSTATE_RUN ) {
        if (!pPinContext->hSystemStateHandle) {
            // register the system state as busy
            pPinContext->hSystemStateHandle = PoRegisterSystemState( pPinContext->hSystemStateHandle,
                                                                     ES_SYSTEM_REQUIRED | ES_CONTINUOUS );
            _DbgPrintF(DEBUGLVL_TERSE,("[PinSetDeviceState] PoRegisterSystemState %x\n",pPinContext->hSystemStateHandle));
        }
    }
    else {
        if (pPinContext->hSystemStateHandle) {
            _DbgPrintF(DEBUGLVL_TERSE,("[PinSetDeviceState] PoUnregisterSystemState %x\n",pPinContext->hSystemStateHandle));
            PoUnregisterSystemState( pPinContext->hSystemStateHandle );
            pPinContext->hSystemStateHandle = NULL;
        }
    }

    return ntStatus;
}


NTSTATUS
USBMIDIPinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinSetDataFormat] pin %d\n",pKsPin->Id));
    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIPinProcess(
    IN PKSPIN pKsPin )
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinProcess] Render pin %d\n",pKsPin->Id));
        ntStatus = USBMIDIOutProcessStreamPtr( pKsPin );
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinProcess] Capture pin %d\n",pKsPin->Id));
        ntStatus = USBMIDIInProcessStreamPtr( pKsPin );
    }

    return ntStatus;
}

void
USBMIDIPinReset( PKSPIN pKsPin )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinReset] pin %d\n",pKsPin->Id));
}

LONGLONG FASTCALL
USBAudioCorrelatedTime(
    IN PKSPIN pKsPin,
    OUT PLONGLONG PhysicalTime )
{
    PPIN_CONTEXT pPinContext;
    PCAPTURE_PIN_CONTEXT pCapturePinContext;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    ULONG ulAvgBytesPerSec;
    KSAUDIO_POSITION KsPosition;

    if (pKsPin) {

        pPinContext = pKsPin->Context;
        if (pPinContext) {

            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {

                pCapturePinContext = pPinContext->pCapturePinContext;
                if (pCapturePinContext) {

                    if (pCapturePinContext->ulCurrentSampleRate) {

                        // Get the current audio byte offset
                        CaptureBytePosition(pKsPin, &KsPosition);

                        // Convert offset to a time offset based on a nanosecond clock
                        *PhysicalTime = ( (KsPosition.PlayOffset /
                                           pCapturePinContext->ulBytesPerSample) * 1000000) /
                                           pCapturePinContext->ulCurrentSampleRate;

                        DbgLog("CapPos", pKsPin, pPinContext,
                               (ULONG)( (*PhysicalTime) >> 32), (ULONG)(*PhysicalTime));
                        return *PhysicalTime;
                    }
                }
            }
            else {
                switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
                    case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                        pT1PinContext = pPinContext->pType1PinContext;
                        if (pT1PinContext) {

                            if (pT1PinContext->ulCurrentSampleRate) {

                                TypeIRenderBytePosition(pPinContext, &KsPosition);

                                // Convert offset to a time offset based on a nanosecond clock
                                *PhysicalTime = ( (KsPosition.WriteOffset /
                                                   pT1PinContext->ulBytesPerSample) * 1000000) /
                                                   pT1PinContext->ulCurrentSampleRate;
                                DbgLog("RendPos", pKsPin, pPinContext, (ULONG)(*PhysicalTime)>>32, (ULONG)(*PhysicalTime));
                                return *PhysicalTime;
                            }
                        }

                        break;
                    case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                    case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                    default:
                        return *PhysicalTime; // not supported
                        break;
                }
            }
        }
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioCorrelatedTime] Invalid pin!\n"));
    return *PhysicalTime;
}

NTSTATUS
USBMIDIPinDataIntersect(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinDataIntersect]\n"));
    return STATUS_NOT_IMPLEMENTED;
}

static
const
KSCLOCK_DISPATCH USBAudioClockDispatch =
{
    NULL, // SetTimer
    NULL, // CancelTimer
    USBAudioCorrelatedTime, // CorrelatedTime
    NULL // Resolution
};

const
KSPIN_DISPATCH
USBAudioPinDispatch =
{
    USBAudioPinCreate,
    USBAudioPinClose,
    USBAudioPinProcess,
    USBAudioPinReset,// Reset
    USBAudioPinSetDataFormat,
    USBAudioPinSetDeviceState,
    NULL, // Connect
    NULL, // Disconnect
    NULL, // &USBAudioClockDispatch, // Clock
    NULL  // Allocator
};

const
KSPIN_DISPATCH
USBMIDIPinDispatch =
{
    USBMIDIPinCreate,
    USBMIDIPinClose,
    USBMIDIPinProcess,
    USBMIDIPinReset,// Reset
    USBMIDIPinSetDataFormat,
    USBMIDIPinSetDeviceState,
    NULL,// Connect
    NULL // Disconnect
};

const
KSDATAFORMAT AudioBridgePinDataFormat[] =
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_AUDIO},
    {STATIC_KSDATAFORMAT_SUBTYPE_ANALOG},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

const
KSDATAFORMAT MIDIBridgePinDataFormat[] =
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_MUSIC},
    {STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

const
KSDATARANGE_MUSIC MIDIStreamingPinDataFormat[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            {STATIC_KSDATAFORMAT_TYPE_MUSIC},
            {STATIC_KSDATAFORMAT_SUBTYPE_MIDI},
            {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
        },
        {STATIC_KSMUSIC_TECHNOLOGY_PORT},
        0,
        0,
        0xFFFF
    }
};

DEFINE_KSPIN_INTERFACE_TABLE(PinInterface) {
   {
    STATICGUIDOF(KSINTERFACESETID_Standard),
    KSINTERFACE_STANDARD_STREAMING,
    0
   }
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMedium) {
    {
     STATICGUIDOF(KSMEDIUMSETID_Standard),
     KSMEDIUM_TYPE_ANYINSTANCE,
     0
    }
};

const
PKSDATAFORMAT pAudioBridgePinFormats = (PKSDATAFORMAT)AudioBridgePinDataFormat;

const
PKSDATAFORMAT pMIDIBridgePinFormats = (PKSDATAFORMAT)MIDIBridgePinDataFormat;

const
PKSDATAFORMAT pMIDIStreamingPinFormats = (PKSDATAFORMAT)MIDIStreamingPinDataFormat;

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED,
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    8,
    sizeof(ULONG) - 1,
    0,
    0
);

NTSTATUS
USBAudioPinBuildDescriptors(
    PKSDEVICE pKsDevice,
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx,
    PULONG pNumPins,
    PULONG pPinDecSize )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSPIN_DESCRIPTOR_EX pPinDescEx;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PPIN_CINSTANCES pPinInstances;
    ULONG ulNumPins, i, j;
    ULONG ulNumStreamPins;
    ULONG ulNumAudioBridgePins = 0;
    ULONG ulNumMIDIPins = 0;
    ULONG ulNumMIDIBridgePins = 0;
    PKSPROPERTY_ITEM pStrmPropItems;
    PKSPROPERTY_SET pStrmPropSet;
    ULONG ulNumPropertyItems;
    ULONG ulNumPropertySets;
    GUID *pTTypeGUID;
    GUID *pMIDIBridgeGUID;
    ULONG ulAudioFormatCount = 0;
    PKSDATARANGE_AUDIO *ppAudioDataRanges;
    PUSBAUDIO_DATARANGE pAudioDataRange;
    PKSDATARANGE_MUSIC *ppMIDIStreamingDataRanges;
    NTSTATUS ntStatus;

    // Determine the number of Pins in the Filter ( Should = # of Terminal Units )
    ulNumPins = CountTerminalUnits( pHwDevExt->pConfigurationDescriptor,
                                    &ulNumAudioBridgePins,
                                    &ulNumMIDIPins,
                                    &ulNumMIDIBridgePins);
    ASSERT(ulNumPins >= ulNumAudioBridgePins + ulNumMIDIPins);
    ulNumStreamPins = ulNumPins - ulNumAudioBridgePins - ulNumMIDIPins;

    // Determine the number of Properties and Property Sets for the Pin.
    BuildPinPropertySet( pHwDevExt,
                         NULL,
                         NULL,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Count the total number of data ranges in the device.
    for ( i=0; i<ulNumStreamPins; i++ ) {
        ulAudioFormatCount +=
            CountFormatsForAudioStreamingInterface( pHwDevExt->pConfigurationDescriptor, i );
    }

    // Allocate all the space we need to describe the Pins in the device.
    *pPinDecSize = sizeof(KSPIN_DESCRIPTOR_EX);
    *pNumPins = ulNumPins;
    pPinDescEx = *ppPinDescEx =
                 AllocMem(NonPagedPool, (ulNumPins *
                                         ( sizeof(KSPIN_DESCRIPTOR_EX) +
                                           sizeof(KSAUTOMATION_TABLE)  +
                                           sizeof(KSALLOCATOR_FRAMING_EX) +
                                           sizeof(PIN_CINSTANCES) )) +
                                        (ulAudioFormatCount *
                                         (  sizeof(PKSDATARANGE_AUDIO)  +
                                            sizeof(USBAUDIO_DATARANGE) )) +
                                        (ulNumPropertySets*sizeof(KSPROPERTY_SET)) +
                                        (ulNumPropertyItems*sizeof(KSPROPERTY_ITEM)) +
                                        (ulNumMIDIPins*sizeof(KSDATARANGE_MUSIC)) +
                                        (ulNumAudioBridgePins*sizeof(GUID)) +
                                        (ulNumMIDIBridgePins*sizeof(GUID)) );
    if ( !pPinDescEx )
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pPinDescEx, FreeMem);

    // Zero out all descriptors to start
    RtlZeroMemory(pPinDescEx, ulNumPins*sizeof(KSPIN_DESCRIPTOR_EX));

    // Set the pointer for the Automation Tables
    pKsAutomationTable = (PKSAUTOMATION_TABLE)(pPinDescEx + ulNumPins);
    RtlZeroMemory(pKsAutomationTable, ulNumPins * sizeof(KSAUTOMATION_TABLE));

    // Set pointers to Pin instance count
    pHwDevExt->pPinInstances = pPinInstances = (PPIN_CINSTANCES)(pKsAutomationTable + ulNumPins);

    // Set pointers to Property Sets for Streaming Pins
    pStrmPropSet   = (PKSPROPERTY_SET)(pPinInstances + ulNumPins);
    pStrmPropItems = (PKSPROPERTY_ITEM)(pStrmPropSet + ulNumPropertySets);

    // Set pointer to Terminal Type GUIDS
    pTTypeGUID = (GUID *)(pStrmPropItems + ulNumPropertyItems);

    // Set Pointers for DataRange pointers and DataRanges for streaming Pins
    ppAudioDataRanges = (PKSDATARANGE_AUDIO *)(pTTypeGUID + ulNumAudioBridgePins);
    pAudioDataRange   = (PUSBAUDIO_DATARANGE)(ppAudioDataRanges + ulAudioFormatCount);

    // Set pointer to Allocator Framing structures for Streaming Pins
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)(pAudioDataRange + ulAudioFormatCount);

    // Set pointer to DataRanges for MIDI Pins
    ppMIDIStreamingDataRanges = (PKSDATARANGE_MUSIC *)(pKsAllocatorFramingEx + ulNumPins);

    // Set pointer to MIDI Bridge GUIDS
    pMIDIBridgeGUID = (GUID *)(ppMIDIStreamingDataRanges + ulNumMIDIPins);

    BuildPinPropertySet( pHwDevExt,
                         pStrmPropItems,
                         pStrmPropSet,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Fill in descriptors for streaming pins first
    for ( i=0; i<(ulNumPins-ulNumAudioBridgePins-ulNumMIDIPins); i++ ) {
        ULONG ulFormatsForPin;
        pPinDescEx[i].Dispatch = &USBAudioPinDispatch;
        pPinDescEx[i].AutomationTable = &pKsAutomationTable[i];


        pKsAutomationTable[i].PropertySetsCount = ulNumPropertySets;
        pKsAutomationTable[i].PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pKsAutomationTable[i].PropertySets      = pStrmPropSet;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces      = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount    = 1;
        pPinDescEx[i].PinDescriptor.Mediums         = PinMedium;

        ulFormatsForPin =
            CountFormatsForAudioStreamingInterface( pHwDevExt->pConfigurationDescriptor, i );

        pPinDescEx[i].PinDescriptor.DataRangesCount = ulFormatsForPin;

        pPinDescEx[i].PinDescriptor.DataRanges = (const PKSDATARANGE *)ppAudioDataRanges;
        GetPinDataRangesFromInterface( i, pHwDevExt->pConfigurationDescriptor,
                                       ppAudioDataRanges, pAudioDataRange );

        ppAudioDataRanges += ulFormatsForPin;
        pAudioDataRange   += ulFormatsForPin;

        pPinDescEx[i].PinDescriptor.DataFlow =
                GetDataFlowDirectionForInterface( pHwDevExt->pConfigurationDescriptor, i);

        if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;
            pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;
            pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER;
        }
        else {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BOTH;
            pPinDescEx[i].PinDescriptor.Category = (GUID*) &PINNAME_CAPTURE;
            pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING | KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY;
        }

        // Set max instances to 1 for all pins.
        pPinDescEx[i].InstancesPossible  = 1;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 1;
        pPinInstances[i].CurrentCount  = 0;

        pPinDescEx[i].IntersectHandler = USBAudioPinDataIntersect;

        // Set up Allocator Framing
        pPinDescEx[i].AllocatorFraming = &AllocatorFraming;

        // Finally set the 0 BW interface for the Pin
        ntStatus = SelectZeroBandwidthInterface( pHwDevExt, i );
        if ( !NT_SUCCESS(ntStatus) ) return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    // Now fill in descriptors for audio bridge pins
    for ( j=0; j<ulNumAudioBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = NULL;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount = 1;
        pPinDescEx[i].PinDescriptor.Mediums = PinMedium;
        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pAudioBridgePinFormats;
        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BRIDGE;
        pPinDescEx[i].PinDescriptor.DataFlow =
                      GetDataFlowForBridgePin( pHwDevExt->pConfigurationDescriptor, j);

        pPinDescEx[i].PinDescriptor.Category = &pTTypeGUID[j];
        GetCategoryForBridgePin( pHwDevExt->pConfigurationDescriptor, j, &pTTypeGUID[j] );
        if (IsBridgePinDigital(pHwDevExt->pConfigurationDescriptor, j)) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioPinBuildDescriptors] Found digital bridge pin (%d)\n",j));
            pHwDevExt->fDigitalOutput = TRUE;
        }

        pPinDescEx[i].InstancesPossible  = 0;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 0;
        pPinInstances[i].CurrentCount  = 0;
    }

    // Now fill in descriptors for MIDI Streaming pins
    for ( j=0; j<ulNumMIDIPins-ulNumMIDIBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = &USBMIDIPinDispatch;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces      = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount    = 1;
        pPinDescEx[i].PinDescriptor.Mediums         = PinMedium;

        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pMIDIStreamingPinFormats;

#if 0
        pPinDescEx[i].PinDescriptor.DataRanges = &ppMIDIStreamingDataRanges;

        // Create the KSDATARANGE_MUSIC structure
        ppMIDIStreamingDataRanges->DataRange.FormatSize = sizeof(KSDATARANGE_MUSIC);
        ppMIDIStreamingDataRanges->DataRange.Reserved   = 0;
        ppMIDIStreamingDataRanges->DataRange.Flags      = 0;
        ppMIDIStreamingDataRanges->DataRange.SampleSize = 0;
        ppMIDIStreamingDataRanges->DataRange.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
        ppMIDIStreamingDataRanges->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
        ppMIDIStreamingDataRanges->DataRange.Specifier = KSDATAFORMAT_SPECIFIER_NONE;
        ppMIDIStreamingDataRanges->Technology = KSMUSIC_TECHNOLOGY_PORT;
        ppMIDIStreamingDataRanges->Channels = 0;
        ppMIDIStreamingDataRanges->Notes = 0;
        ppMIDIStreamingDataRanges->ChannelMask = 0xFFFF;
        ppMIDIStreamingDataRanges++;
#endif

        pPinDescEx[i].PinDescriptor.DataFlow =
            GetDataFlowDirectionForMIDIInterface( pHwDevExt->pConfigurationDescriptor, j, FALSE);

        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;

        if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;
            pPinDescEx[i].PinDescriptor.Category = (GUID*)&KSCATEGORY_WDMAUD_USE_PIN_NAME;
            pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER | KSPIN_FLAG_CRITICAL_PROCESSING;
        }
        else {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BOTH;
            pPinDescEx[i].PinDescriptor.Category = (GUID*)&KSCATEGORY_WDMAUD_USE_PIN_NAME;
            pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING;
        }

        // Set max instances to 1 for all pins.
        pPinDescEx[i].InstancesPossible  = 1;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 1;
        pPinInstances[i].CurrentCount  = 0;

        pPinDescEx[i].IntersectHandler = USBMIDIPinDataIntersect;

        // Set up Allocator Framing
        pPinDescEx[i].AllocatorFraming = &AllocatorFraming;
    }

    // Now fill in descriptors for MIDI bridge pins
    for ( j=0; j<ulNumMIDIBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = NULL;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount = 1;
        pPinDescEx[i].PinDescriptor.Mediums = PinMedium;
        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pMIDIBridgePinFormats;
        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BRIDGE;
        pPinDescEx[i].PinDescriptor.DataFlow =
            GetDataFlowDirectionForMIDIInterface( pHwDevExt->pConfigurationDescriptor, j, TRUE);
        pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;

        pPinDescEx[i].InstancesPossible  = 0;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 0;
        pPinInstances[i].CurrentCount  = 0;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\topology.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       topology.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "nameguid.h"

static GUID USBNODENAME_BassBoost = {STATIC_USBNODENAME_BassBoost};

// Map of Audio properties to nodes
ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

#if DBG
//#define TOPODBG
#endif

#ifdef TOPODBG

#define NUM_CATEGORIES  10
#define NUM_NODETYPES   15

struct {
        CONST GUID *apguidCategory;
        char *CategoryString;
} CategoryLookupTable[NUM_CATEGORIES] = {
    { &KSCATEGORY_AUDIO,              "Audio" },
    { &KSCATEGORY_BRIDGE,             "Bridge" },
    { &KSCATEGORY_RENDER,             "Render" },
    { &KSCATEGORY_CAPTURE,            "Capture"},
    { &KSCATEGORY_MIXER,              "Mixer"  },
    { &KSCATEGORY_DATATRANSFORM,      "Data Transform" },
    { &KSCATEGORY_INTERFACETRANSFORM, "Interface Transform"},
    { &KSCATEGORY_MEDIUMTRANSFORM,    "Medium Transform" },
    { &KSCATEGORY_DATACOMPRESSOR,     "Data Compressor" },
    { &KSCATEGORY_DATADECOMPRESSOR,   "Data Decompressor" }
};

struct {
        CONST GUID *Guid;
        char *String;
} NodeLookupTable[NUM_NODETYPES] = {
    { &KSNODETYPE_DAC,          "DAC" },
    { &KSNODETYPE_ADC,          "ADC" },
    { &KSNODETYPE_SRC,          "SRC" },
    { &KSNODETYPE_SUPERMIX,     "SuperMIX"},
    { &KSNODETYPE_SUM,          "Sum" },
    { &KSNODETYPE_MUTE,         "Mute"},
    { &KSNODETYPE_VOLUME,       "Volume" },
    { &KSNODETYPE_TONE,         "Tone" },
    { &KSNODETYPE_AGC,          "AGC" },
    { &KSNODETYPE_DELAY,        "Delay" },
    { &KSNODETYPE_MUX,          "Mux" },
    { &KSNODETYPE_LOUDNESS,     "Loudness" },
    { &KSNODETYPE_DEV_SPECIFIC, "Device Specific" },
    { &KSNODETYPE_STEREO_WIDE,  "Stereo Extender" },
    { &KSNODETYPE_EQUALIZER,    "Graphic Equalizer" }

};

DbugDumpTopology( PKSFILTER_DESCRIPTOR pFilterDesc )
{
    PTOPOLOGY_NODE_INFO pNodeDescriptors = (PTOPOLOGY_NODE_INFO)pFilterDesc->NodeDescriptors;
    const KSTOPOLOGY_CONNECTION* pConnection = pFilterDesc->Connections;
    ULONG i,j;
    ULONG OldLvl = USBAudioDebugLevel;

    USBAudioDebugLevel = 3;

    for (i=0;i<pFilterDesc->CategoriesCount;i++) {
        for ( j=0;j<NUM_CATEGORIES; j++)
           if ( IsEqualGUID( &pFilterDesc->Categories[i], CategoryLookupTable[j].apguidCategory ) )
               _DbgPrintF(DEBUGLVL_VERBOSE,("Category: %s\n",CategoryLookupTable[j].CategoryString ))
    }

    for (i=0;i<pFilterDesc->NodeDescriptorsCount;i++) {
        for ( j=0;j<NUM_NODETYPES; j++)
           if ( IsEqualGUID( pNodeDescriptors[i].KsNodeDesc.Type, NodeLookupTable[j].Guid ) )
               _DbgPrintF(DEBUGLVL_VERBOSE,("Node[%d]: %s\n",i,NodeLookupTable[j].String ))
    }

    for (i=0;i<pFilterDesc->ConnectionsCount;i++) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("FromNode:%4d FromPin:%4d -->ToNode:%4d ToPin:%4d\n",
                      pConnection->FromNode,
                      pConnection->FromNodePin,
                      pConnection->ToNode,
                      pConnection->ToNodePin ));
        pConnection++;
    }

    USBAudioDebugLevel = OldLvl;

}
#endif


ULONG
ConvertTermTypeToNodeType(
    WORD wTerminalType,
    GUID *TopologyNode,
    GUID *TopologyNodeName,
    UCHAR DescriptorSubtype
    )
{
    ULONG NodeType = NODE_TYPE_NONE;

    if (wTerminalType == USB_Streaming) {
        // All endpoints support SRC
        *TopologyNode = KSNODETYPE_SRC;
        NodeType = NODE_TYPE_SRC;
    }
    else {

        switch (wTerminalType & 0xFF00) {
            case Input_Mask:
                *TopologyNode = KSNODETYPE_ADC;
                NodeType = NODE_TYPE_ADC;
                break;
            case Output_Mask:
                *TopologyNode = KSNODETYPE_DAC;
                NodeType = NODE_TYPE_DAC;
                break;
            case Bidirectional_Mask:
            case External_Mask:
                switch (DescriptorSubtype) {
                    case INPUT_TERMINAL:
                        *TopologyNode = KSNODETYPE_ADC;
                        NodeType = NODE_TYPE_ADC;
                        break;
                    case OUTPUT_TERMINAL:
                        *TopologyNode = KSNODETYPE_DAC;
                        NodeType = NODE_TYPE_DAC;
                        break;
                    default:
                        *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                        NodeType = NODE_TYPE_DEV_SPEC;
                        break;
                }
                break;
            case Embedded_Mask:
                switch (wTerminalType) {
                    case Level_Calibration_Noise_Source:
                    case Equalization_Noise:
                    case Radio_Transmitter:
                        *TopologyNode = KSNODETYPE_DAC;
                        NodeType = NODE_TYPE_DAC;
                        break;
                    case CD_player:
                    case Phonograph:
                    case Video_Disc_Audio:
                    case DVD_Audio:
                    case TV_Tuner_Audio:
                    case Satellite_Receiver_Audio:
                    case Cable_Tuner_Audio:
                    case DSS_Audio:
                    case Radio_Receiver:
                    case Synthesizer:
                        *TopologyNode = KSNODETYPE_ADC;
                        NodeType = NODE_TYPE_ADC;
                        break;
                    default:
                        // TODO: We need to define a "source or sink" node
                        *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                        NodeType = NODE_TYPE_DEV_SPEC;
                        break;
                }
                break;
            default:
                // This node has no corresponding guid.
                *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                NodeType = NODE_TYPE_DEV_SPEC;
                break;
        }
    }

   *TopologyNodeName = *TopologyNode;
    return NodeType;
}

VOID
ProcessMIDIOutJack( PHW_DEVICE_EXTENSION pHwDevExt,
                    PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pConnectionIndex,
                    ULONG pMIDIStreamingPinStartIndex,
                    PULONG pMIDIStreamingPinCurrentIndex,
                    ULONG pBridgePinStartIndex,
                    PULONG pBridgePinCurrentIndex)
{
    ULONG i;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    for ( i=0; i < pMIDIOutJack->bNrInputPins; i++ ) {

        if ( pMIDIOutJack->bJackType == JACK_TYPE_EMBEDDED ) {
            pConnection->ToNodePin = (*pMIDIStreamingPinCurrentIndex)++;
            pConnection->FromNodePin = GetPinNumberForMIDIJack(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pMIDIOutJack->baSourceConnections[i].SourceID,
                                             pMIDIStreamingPinStartIndex,
                                             pBridgePinStartIndex);
        } else {
            pConnection->ToNodePin = (*pBridgePinCurrentIndex)++;
            pConnection->FromNodePin = GetPinNumberForMIDIJack(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pMIDIOutJack->baSourceConnections[i].SourceID,
                                             pMIDIStreamingPinStartIndex,
                                             pBridgePinStartIndex);
        }

        // Make the connection to this node
        pConnection->FromNode  = KSFILTER_NODE;
        pConnection->ToNode    = KSFILTER_NODE;

        pConnection++;
        (*pConnectionIndex)++;
    }
}

VOID
ProcessInputTerminalUnit( PKSDEVICE pKsDevice,
                          PAUDIO_UNIT pUnit,
                          PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                          PKSTOPOLOGY_CONNECTION pConnections,
                          PULONG pNodeIndex,
                          PULONG pConnectionIndex,
                          PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_INPUT_TERMINAL pInput = (PAUDIO_INPUT_TERMINAL)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    pNodeInfo->pUnit = pInput;
    pNodeInfo->ulNodeType =
                 ConvertTermTypeToNodeType( pInput->wTerminalType,
                                            (GUID *)pNodeInfo->KsNodeDesc.Type,
                                            (GUID *)pNodeInfo->KsNodeDesc.Name,
                                            pInput->bDescriptorSubtype );

    // If this is a "real" pin, find FromNodePin.
    if ( pInput->wTerminalType == USB_Streaming ) {
        pConnection->FromNodePin = GetPinNumberForStreamingTerminalUnit(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pInput->bUnitID );
    }
    else {
        // This is an input terminal from the next bridge pin
        pConnection->FromNodePin = (*pBridgePinIndex)++;
    }

    // Make the connection to this node
    pConnection->FromNode  = KSFILTER_NODE;
    pConnection->ToNode    = (*pNodeIndex)++;
    pConnection->ToNodePin = 1;
    (*pConnectionIndex)++;
}

VOID 
ProcessOutputTerminalUnit( PKSDEVICE pKsDevice,
                           PAUDIO_UNIT pUnit,
                           PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                           PKSTOPOLOGY_CONNECTION pConnections,
                           PULONG pNodeIndex,
                           PULONG pConnectionIndex,
                           PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_OUTPUT_TERMINAL pOutput = (PAUDIO_OUTPUT_TERMINAL)pUnit;
                           
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    pNodeInfo->pUnit = pOutput;
    pNodeInfo->ulNodeType =
                 ConvertTermTypeToNodeType( pOutput->wTerminalType,
                                            (GUID *)pNodeInfo->KsNodeDesc.Type,
                                            (GUID *)pNodeInfo->KsNodeDesc.Name,
                                            pOutput->bDescriptorSubtype );

    // Make the connection to this node
    pConnection->FromNode    = pOutput->bSourceID;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = (*pNodeIndex)++;
    pConnection->ToNodePin   = 1;
    pConnection++; (*pConnectionIndex)++;

    // If this is a "real" pin, find ToNodePin.
    if ( pOutput->wTerminalType == USB_Streaming) {
        pConnection->ToNodePin =
            GetPinNumberForStreamingTerminalUnit( pHwDevExt->pConfigurationDescriptor,
                                                  pOutput->bUnitID );
    }
    else { // Not a streaming terminal
        // This is an output terminal to the next bridge pin
        pConnection->ToNodePin = (*pBridgePinIndex)++;
    }

    // Make the connection to the outside world
    pConnection->FromNode    = pOutput->bUnitID;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = KSFILTER_NODE;
    (*pConnectionIndex)++;

}

VOID 
ProcessMixerUnit( PKSDEVICE pKsDevice,
                  PAUDIO_UNIT pUnit,
                  PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                  PKSTOPOLOGY_CONNECTION pConnections,
                  PULONG pNodeIndex,
                  PULONG pConnectionIndex,
                  PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_MIXER_UNIT pMixer = (PAUDIO_MIXER_UNIT)pUnit;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG i;

    // Each input stream has a super-mixer
    for (i=0; i<pMixer->bNrInPins; i++) {
        pNodeInfo->pUnit           = pMixer;
        pNodeInfo->ulPinNumber     = i;
        pNodeInfo->ulNodeType      = NODE_TYPE_SUPERMIX;
        pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUPERMIX;
        pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_SUPERMIX;
        pNodeInfo->MapNodeToCtrlIF =
                               GetUnitControlInterface( pHwDevExt, pMixer->bUnitID );

        pConnection->FromNode    = pMixer->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = *pNodeIndex;
        pConnection->ToNodePin   = 1;
        pNodeInfo++; (*pNodeIndex)++;
        pConnection++; (*pConnectionIndex)++;
    }

    // All the super-mix outputs are summed.
    pNodeInfo->pUnit           = pMixer;
    pNodeInfo->ulNodeType      = NODE_TYPE_SUM;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUM;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUM;
    for (i=0; i<pMixer->bNrInPins; i++) {
        pConnection->FromNode    = (ABSOLUTE_NODE_FLAG | (*pNodeIndex-1-i));
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = *pNodeIndex;
        pConnection->ToNodePin   = 1;
        pConnection++; (*pConnectionIndex)++;
    }
    (*pNodeIndex)++;
}

VOID 
ProcessSelectorUnit( PKSDEVICE pKsDevice,
                     PAUDIO_UNIT pUnit,
                     PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                     PKSTOPOLOGY_CONNECTION pConnections,
                     PULONG pNodeIndex,
                     PULONG pConnectionIndex,
                     PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SELECTOR_UNIT pSelector = (PAUDIO_SELECTOR_UNIT)pUnit;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG i;

    pNodeInfo->pUnit            = pSelector;
    pNodeInfo->KsNodeDesc.Type  = &KSNODETYPE_MUX;
    pNodeInfo->KsNodeDesc.Name  = &KSNODETYPE_MUX;
    pNodeInfo->ulNodeType       = NODE_TYPE_MUX;
    pNodeInfo->MapNodeToCtrlIF  = 
             GetUnitControlInterface( pHwDevExt, pSelector->bUnitID );

    for (i=0; i<pSelector->bNrInPins; i++) {
        pConnection->FromNode = pSelector->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1+i;
        pConnection++; (*pConnectionIndex)++;
    }
    (*pNodeIndex)++;
}

VOID
ProcessFeatureUnit( PKSDEVICE pKsDevice,
                    PAUDIO_UNIT pUnit,
                    PTOPOLOGY_NODE_INFO pNodeInfo,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pNodeIndex,
                    PULONG pConnectionIndex,
                    PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_FEATURE_UNIT pFeature = (PAUDIO_FEATURE_UNIT)pUnit;

    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulNumChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmChannelConfig;
    ULONG ulSourceNode;
    ULONG bmControls;
    ULONG i, j;

    ulNumChannels = CountInputChannels(pHwDevExt->pConfigurationDescriptor, pFeature->bUnitID);

    pChannelCntrls = AllocMem( NonPagedPool, (ulNumChannels+1)*sizeof(ULONG) );
    if ( !pChannelCntrls ) return;

    bmChannelConfig = GetChannelConfigForUnit( pHwDevExt->pConfigurationDescriptor, pFeature->bUnitID);

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    for ( i=0; i<=ulNumChannels; i++ ) {
        bmControls = 0;
        for ( j=pFeature->bControlSize; j>0; j-- ) {
            bmControls <<= 8;
            bmControls |= pFeature->bmaControls[i*pFeature->bControlSize+j-1];
        }

        pChannelCntrls[i] = bmControls;
        ulMergedControls |= bmControls;
    }

    ulSourceNode = pFeature->bSourceID;
    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        // Determine which channels this control is valid for
        ulCurControlChannels = 0;
        pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        for ( i=0; i<=ulNumChannels; i++ ) {

            DbgLog("pChanI0", ulNodeNumber, i, pChannelCntrls[i], ulCurrentControl );

            if (pChannelCntrls[i] & ulCurrentControl) {
                // Determine which Channel pChannelCntrls[i] reflects

                // NEED TO SHIFT bmChannelConfig and ADD 1 for omnipresent master channel
                ULONG ulTmpConfig = (bmChannelConfig<<1)+1;
                ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));

                ulCurControlChannels++;
                DbgLog("pChanI1", i, pChannelCntrls[i], ulCurrentControl, ulCurControlChannels );

                for (j=0; j<i; j++) {
                    ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                    ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                }

                pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
                DbgLog("pChanI2", j, ulTmpConfig, ulCurChannel, pNodeInfo[ulNodeNumber].ulChannelConfig );
            }
        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].MapNodeToCtrlIF =
                               GetUnitControlInterface( pHwDevExt, pFeature->bUnitID );
        pNodeInfo[ulNodeNumber].pUnit = pFeature;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                break;
            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                break;
            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &USBNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                break;
            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                break;
            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                break;
            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                break;
            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;
            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType  = AUTOMATIC_GAIN_CONTROL;
                break;
            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType  = DELAY_CONTROL;
                break;
            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType  = LOUDNESS_CONTROL;
                break;
            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType  = DEV_SPECIFIC_CONTROL;
                break;
        }

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j;
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                    ntStatus = InitializeDbLevelCache( pKsDevice->NextDeviceObject,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }
                }
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

                DbgLog("DBCache", pRngeCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j;
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS NtStatus;
                    ULONG UnMute = 0;

                    NtStatus = GetSetByte( pKsDevice->NextDeviceObject,
                                &pNodeInfo[ulNodeNumber],
                                pBCache->ulChannelIndex,
                                &UnMute,
                                SET_CUR );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;
            case GRAPHIC_EQUALIZER_FLAG:
               // Currently GEQ is not Cached
            default:
                 break;
        }

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }

    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);

}

#define MAX_PROCESS_CONTROLS 6
ULONG ProcessUnitControlsMap[DYN_RANGE_COMP_PROCESS+1][MAX_PROCESS_CONTROLS] =
    { { 0, 0, 0, 0, 0, 0 },       // No 0 Process
      { UD_ENABLE_CONTROL,
        UD_MODE_SELECT_CONTROL },
      { DP_ENABLE_CONTROL,
        DP_MODE_SELECT_CONTROL },
      { ENABLE_CONTROL,
        SPACIOUSNESS_CONTROL },
      { RV_ENABLE_CONTROL,
        0,                        // Reverb Type Control Undefined in spec
        REVERB_LEVEL_CONTROL,
        REVERB_TIME_CONTROL,
        REVERB_FEEDBACK_CONTROL },
      { CH_ENABLE_CONTROL,
        CHORUS_LEVEL_CONTROL,
        CHORUS_RATE_CONTROL,
        CHORUS_DEPTH_CONTROL },
      { DR_ENABLE_CONTROL,
        COMPRESSION_RATE_CONTROL,
        MAXAMPL_CONTROL,
        THRESHOLD_CONTROL,
        ATTACK_TIME,
        RELEASE_TIME } };


VOID
ProcessProcessingUnit( PKSDEVICE pKsDevice,
                       PAUDIO_UNIT pUnit,
                       PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                       PKSTOPOLOGY_CONNECTION pConnections,
                       PULONG pNodeIndex,
                       PULONG pConnectionIndex,
                       PULONG pBridgePinIndex )
{
    PAUDIO_PROCESSING_UNIT pProcessor = (PAUDIO_PROCESSING_UNIT)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    ULONG ulConnectionsCount = *pConnectionIndex;
    PAUDIO_CHANNELS pAudioChannels;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    ULONG ulCacheSize = 0;
    ULONG i, j;

    pNodeInfo->pUnit = pProcessor;
    pNodeInfo->MapNodeToCtrlIF =
                   GetUnitControlInterface( pHwDevExt, pProcessor->bUnitID );

    switch ( pProcessor->wProcessType ) {
        case UP_DOWNMIX_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUPERMIX;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_SUPERMIX;
            pNodeInfo->ulNodeType      = NODE_TYPE_SUPERMIX;
            break;

        case DOLBY_PROLOGIC_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_PROLOGIC_DECODER;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_PROLOGIC_DECODER;
            pNodeInfo->ulNodeType      = NODE_TYPE_PROLOGIC;
            break;

        case STEREO_EXTENDER_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_STEREO_WIDE;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_STEREO_WIDE;
            pNodeInfo->ulNodeType      = NODE_TYPE_STEREO_WIDE;
            pNodeInfo->ulControlType   = SPACIOUSNESS_CONTROL;
            break;

        case REVERBERATION_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_REVERB;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_REVERB;
            pNodeInfo->ulNodeType      = NODE_TYPE_REVERB;
            pNodeInfo->ulControlType   = REVERB_LEVEL_CONTROL;
            break;

        case CHORUS_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_CHORUS;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_CHORUS;
            pNodeInfo->ulNodeType      = NODE_TYPE_CHORUS;
            pNodeInfo->ulControlType   = CHORUS_LEVEL_CONTROL;
            break;

        // TODO: Need to support Compressor Processing Unit correctly.
        //       Using loudness just won't cut it.
        case DYN_RANGE_COMP_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
            pNodeInfo->ulNodeType      = NODE_TYPE_LOUDNESS;
            pNodeInfo->ulControlType   = LOUDNESS_CONTROL;
            break;

        default:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
            pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
            pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;
            break;
    }

    // Determine the size of the cache needed for the controls
    ulCacheSize = sizeof(PROCESS_CTRL_CACHE);
    pAudioChannels = (PAUDIO_CHANNELS)(pProcessor->baSourceID + pProcessor->bNrInPins);
    for (i=0; i<pAudioChannels->bControlSize; i++) {
        for (j=1; j<8; j++) {
            if ( pAudioChannels->bmControls[i] & (1<<j))
                ulCacheSize += sizeof(PROCESS_CTRL_RANGE);
        }
    }

    // Allocate and initialize cache
    pPCtrlCache = (PPROCESS_CTRL_CACHE)AllocMem( NonPagedPool, ulCacheSize );
    if ( pPCtrlCache ) {
        PPROCESS_CTRL_RANGE pPCtrlRange = (PPROCESS_CTRL_RANGE)(pPCtrlCache+1);

        pNodeInfo->ulCacheValid  = FALSE;
        pNodeInfo->pCachedValues = pPCtrlCache;

        pPCtrlCache->fEnableBit = pAudioChannels->bmControls[0] & ENABLE_CONTROL;
        if ( pPCtrlCache->fEnableBit ) {
            GetSetProcessingUnitEnable( pKsDevice->NextDeviceObject,
                                        pNodeInfo,
                                        GET_CUR,
                                        &pPCtrlCache->fEnabled );
        }
        else
            pPCtrlCache->fEnabled = TRUE;

        // Determine data ranges for units which allow values.
        switch(pProcessor->wProcessType) {
            case STEREO_EXTENDER_PROCESS:
            case REVERBERATION_PROCESS:
                if (pAudioChannels->bmControls[0] & 2) {
                    GetProcessingUnitRange( pKsDevice->NextDeviceObject,
                                            pNodeInfo,
                                            pNodeInfo->ulControlType,
                                            sizeof(UCHAR),
                                            (0x10000/100),
                                            &pPCtrlRange->Range );

               } break;
            default:
                 break;
        }

        // Bag the cache for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pPCtrlCache, FreeMem);

    }

    for (i=0; i<pProcessor->bNrInPins; i++) {
        pConnection->FromNode = pProcessor->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1;
        pConnection++; ulConnectionsCount++;
    }

    *pConnectionIndex = ulConnectionsCount;
    (*pNodeIndex)++;

}

VOID

ProcessExtensionUnit( PKSDEVICE pKsDevice,
                      PAUDIO_UNIT pUnit,
                      PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                      PKSTOPOLOGY_CONNECTION pConnections,
                      PULONG pNodeIndex,
                      PULONG pConnectionIndex,
                      PULONG pBridgePinIndex )
{
    PAUDIO_EXTENSION_UNIT pExtension = (PAUDIO_EXTENSION_UNIT)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections  + *pConnectionIndex;
    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG i;

    pNodeInfo->pUnit           = pExtension;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
    pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;

    for (i=0; i<pExtension->bNrInPins; i++) {
        pConnection->FromNode = pExtension->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1;
        pConnection++; ulConnectionsCount++;
    }

    *pConnectionIndex = ulConnectionsCount;
    (*pNodeIndex)++;
}

VOID
ProcessUnknownUnit( PKSDEVICE pKsDevice,
                    PAUDIO_UNIT pUnit,
                    PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pNodeIndex,
                    PULONG pConnectionIndex,
                    PULONG pBridgePinIndex )
{
    return;
}


typedef 
VOID 
(*PUNIT_PROCESS_RTN)( PKSDEVICE pKsDevice,
                      PAUDIO_UNIT pUnit,
                      PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                      PKSTOPOLOGY_CONNECTION pConnections,
                      PULONG pNodeIndex,
                      PULONG pConnectionIndex,
                      PULONG pBridgePinIndex );

PUNIT_PROCESS_RTN
pUnitProcessRtn[MAX_TYPE_UNIT] = {
    ProcessUnknownUnit,
    ProcessUnknownUnit,
    ProcessInputTerminalUnit,
    ProcessOutputTerminalUnit,
    ProcessMixerUnit,
    ProcessSelectorUnit,
    ProcessFeatureUnit,
    ProcessProcessingUnit,
    ProcessExtensionUnit
};

NTSTATUS
BuildUSBAudioFilterTopology( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt   = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pFilterDesc = &pHwDevExt->USBAudioFilterDescriptor;

    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_OUTPUT_TERMINAL      pOutput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcessor;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulNumCategories;
    ULONG ulNumNodes;
    ULONG ulNumConnections;
    ULONG bmCategories;

    GUID* pCategoryGUIDs;
    GUID* pTmpGUIDptr;
    PTOPOLOGY_NODE_INFO pNodeDescriptors;
    PKSTOPOLOGY_CONNECTION pConnections;

    ULONG ulNodeIndex = 0;
    ULONG ulConnectionIndex = 0;
    ULONG ulBridgePinCurrentIndex = 0;
    ULONG ulBridgePinStartIndex = 0;
    ULONG ulMIDIStreamingPinCurrentIndex = 0;
    ULONG ulMIDIStreamingPinStartIndex = 0;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("Building USB Topology\n"));

    // Count Items for Topology Allocation
    CountTopologyComponents( pHwDevExt->pConfigurationDescriptor,
                             &ulNumCategories,
                             &ulNumNodes,
                             &ulNumConnections,
                             &bmCategories );

    ulNumCategories += 1; // Need to add space for KSCATEGORY_AUDIO category

    // Set the Node Descriptor size to be that of the KS descriptor +
    // necessary local information.
    pFilterDesc->NodeDescriptorSize = sizeof(TOPOLOGY_NODE_INFO);

    // Allocate Space for Topology Items
    pCategoryGUIDs =
        AllocMem( NonPagedPool, (ulNumCategories  * sizeof(GUID)) +
                                (ulNumNodes       * ( sizeof(TOPOLOGY_NODE_INFO) +
                                                      sizeof(GUID) +
                                                      sizeof(GUID) ) ) +
                                (ulNumConnections * sizeof(KSTOPOLOGY_CONNECTION)) );
    if ( !pCategoryGUIDs ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the topology for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pCategoryGUIDs, FreeMem);

    // Set the pointers to the different topology components
    pNodeDescriptors = (PTOPOLOGY_NODE_INFO)(pCategoryGUIDs + ulNumCategories);
    pConnections = (PKSTOPOLOGY_CONNECTION)(pNodeDescriptors + ulNumNodes);

    pFilterDesc->Categories      = (const GUID*)pCategoryGUIDs;
    pFilterDesc->NodeDescriptors = (const KSNODE_DESCRIPTOR*)pNodeDescriptors;
    pFilterDesc->Connections     = (const KSTOPOLOGY_CONNECTION*)pConnections;

    // Clear all Node info structures
    RtlZeroMemory(pNodeDescriptors, ulNumNodes * sizeof(TOPOLOGY_NODE_INFO));

    // Initialize Node GUID Pointers
    pTmpGUIDptr = (GUID *)(pConnections + ulNumConnections);
    for ( i=0; i<ulNumNodes; i++ ) {
        pNodeDescriptors[i].KsNodeDesc.Type = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.Name = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.AutomationTable = &pNodeDescriptors[i].KsAutomationTable;
    }

    // Fill in Filter Categories
    i=0;
    pCategoryGUIDs[i++] = KSCATEGORY_AUDIO;
    if ( bmCategories & (1<<INPUT_TERMINAL) )
        pCategoryGUIDs[i++] = KSCATEGORY_RENDER;
    if ( bmCategories & (1<<OUTPUT_TERMINAL) )
        pCategoryGUIDs[i++] = KSCATEGORY_CAPTURE;

    ASSERT (i==ulNumCategories);

    pFilterDesc->CategoriesCount = ulNumCategories;

    // Determine first bridge pin number
    {
        PKSPIN_DESCRIPTOR_EX pPinDescriptors = (PKSPIN_DESCRIPTOR_EX)pFilterDesc->PinDescriptors;
        for ( i=0; i<pFilterDesc->PinDescriptorsCount; i++) {
            if (pPinDescriptors[i].PinDescriptor.Communication == KSPIN_COMMUNICATION_BRIDGE)
                break;
        }
        ulBridgePinCurrentIndex = i;
    }

    // For each Audio Control interface find the associated Units and
    // create topology nodes from them
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                   pHwDevExt->pConfigurationDescriptor,
                                   (PVOID)pHwDevExt->pConfigurationDescriptor,
                                   -1,                     // Interface number
                                   -1,                     // Alternate Setting
                                   USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                   AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                   -1 );

    // Now Process each Audio Unit to form the Topology
    while ( pControlIFDescriptor ) {

        pHeader = (PAUDIO_HEADER_UNIT)
                GetAudioSpecificInterface( pHwDevExt->pConfigurationDescriptor,
                                           pControlIFDescriptor,
                                           HEADER_UNIT );

        if (!pHeader) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        // Find the first unit.
        u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID) pHeader,
                                       pHeader->wTotalLength,
                                       (PUCHAR)pHeader + pHeader->bLength,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        while (u.pUnit) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'Map Unit: 0x%x\n",u.pUnit->bUnitID));

            pUnitProcessRtn[u.pUnit->bDescriptorSubtype]( pKsDevice,
                                                          u.pUnit,
                                                          pNodeDescriptors,
                                                          pConnections,
                                                          &ulNodeIndex,
                                                          &ulConnectionIndex,
                                                          &ulBridgePinCurrentIndex );
            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pHeader,
                                pHeader->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        }

        // Get the next Control Interface (if any)
        pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                   pHwDevExt->pConfigurationDescriptor,
                                   ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                   -1,                     // Interface number
                                   -1,                     // Alternate Setting
                                   USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                   AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                   -1 );

    }

    // Determine first MIDI bridge pin number (we should have used up all of the audio bridge pins by now)
    {
        PKSPIN_DESCRIPTOR_EX pPinDescriptors = (PKSPIN_DESCRIPTOR_EX)pFilterDesc->PinDescriptors;

        // If this is true, no audio streaming pins were found
        if (i == ulBridgePinCurrentIndex) {
            ulMIDIStreamingPinStartIndex = 0;
            ulMIDIStreamingPinCurrentIndex = 0;
            ulBridgePinStartIndex = ulBridgePinCurrentIndex;
        } else {
            ulMIDIStreamingPinStartIndex = ulBridgePinCurrentIndex;
            ulMIDIStreamingPinCurrentIndex = ulBridgePinCurrentIndex;

            for ( i = ulMIDIStreamingPinStartIndex; i<pFilterDesc->PinDescriptorsCount; i++) {
                if (pPinDescriptors[i].PinDescriptor.Communication == KSPIN_COMMUNICATION_BRIDGE) {
                    ulBridgePinStartIndex = i;
                    ulBridgePinCurrentIndex = i;
                    break;
                }
            }
        }
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("ulBridgePinStartIndex  : 0x%x\n",ulBridgePinStartIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulBridgePinCurrentIndex: 0x%x\n",ulBridgePinCurrentIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulMIDIStreamingPinStartIndex: 0x%x\n",ulMIDIStreamingPinStartIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulMIDIStreamingPinCurrentIndex: 0x%x\n",ulMIDIStreamingPinCurrentIndex));

    // Now that we have had fun with audio, let's try MIDI
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pHwDevExt->pConfigurationDescriptor,
                         (PVOID) pHwDevExt->pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while (pMIDIStreamingDescriptor) {
        pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                                  USBD_ParseDescriptors( (PVOID) pHwDevExt->pConfigurationDescriptor,
                                                         pHwDevExt->pConfigurationDescriptor->wTotalLength,
                                                         (PVOID) pMIDIStreamingDescriptor,
                                                         USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        if (!pGeneralMIDIStreamDescriptor) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        u.pUnit = (PAUDIO_UNIT)
            USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                   pGeneralMIDIStreamDescriptor->wTotalLength,
                                   ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        while ( u.pUnit ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'Map Unit: 0x%x\n",u.pUnit->bUnitID));
            switch (u.pUnit->bDescriptorSubtype) {
                case MIDI_IN_JACK:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_IN_JACK %d\n",u.pMIDIInJack->bJackID));
                    if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                        ulMIDIStreamingPinCurrentIndex++;
                    } else {
                        ulBridgePinCurrentIndex++;
                    }
                    break;

                case MIDI_OUT_JACK:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_OUT_JACK %d\n",u.pMIDIOutJack->bJackID));
                    ProcessMIDIOutJack( pHwDevExt,
                                        u.pMIDIOutJack,
                                        pConnections,
                                        &ulConnectionIndex,
                                        ulMIDIStreamingPinStartIndex,
                                        &ulMIDIStreamingPinCurrentIndex,
                                        ulBridgePinStartIndex,
                                        &ulBridgePinCurrentIndex );
                    break;

                case MIDI_ELEMENT:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_ELEMENT %d\n",u.pMIDIElement->bElementID));
                    //ProcessMIDIElement( pHwDevExt,
                    //                    u.pMIDIElement,
                    //                    pNodeDescriptors,
                    //                    pConnections,
                    //                    &ulNodeIndex,
                    //                    &ulConnectionIndex,
                    //                    &ulBridgePinIndex );
                    break;

                default:
                    break;
            }

            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pGeneralMIDIStreamDescriptor,
                                pGeneralMIDIStreamDescriptor->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pHwDevExt->pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    //ASSERT(ulNumConnections == ulConnectionIndex);
    ASSERT(ulNumNodes == ulNodeIndex);

    DbgLog("TopoCnt", ulNumConnections, ulConnectionIndex, ulNumNodes, ulNodeIndex);

    // Set Topology component counts in Filter Descriptor
    pFilterDesc->NodeDescriptorsCount = ulNodeIndex;
    pFilterDesc->ConnectionsCount     = ulConnectionIndex;

    DbgLog("TopoAdr", pFilterDesc->NodeDescriptors, pFilterDesc->Connections, ulConnectionIndex, ulNodeIndex);

    // Fix-up all of the connections to map their node #'s correctly.
    for (i=0; i < ulConnectionIndex; i++) {
        if (pConnections->FromNode != KSFILTER_NODE) {
            if (pConnections->FromNode & ABSOLUTE_NODE_FLAG)
                pConnections->FromNode = (pConnections->FromNode & NODE_MASK);
            else {
                // Find the correct node number for FromNode.
                // Note: if a unit has multiple nodes, the From node is always the last node
                // for that unit.
                for ( ulNodeIndex=ulNumNodes; ulNodeIndex > 0; ulNodeIndex-- ) {
                    if (pConnections->FromNode == (ULONG)
                            ((PAUDIO_UNIT)pNodeDescriptors[ulNodeIndex-1].pUnit)->bUnitID) {
                        pConnections->FromNode = ulNodeIndex-1;
                        break;
                    }
                }
            }
        }

        pConnections++;
    }

    // For each node initialize its automation table for its associated properties.
    for (i=0; i<ulNumNodes; i++) {
        BuildNodePropertySet( &pNodeDescriptors[i] );
    }

    // Stick this here as a convienience
    // Initialize Map of Audio Properties to nodes
    MapFuncsToNodeTypes( MapPropertyToNode );


#ifdef TOPODBG
    DbugDumpTopology( pFilterDesc );
#endif

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\typei.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       typei.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

#define LOW_WATERMARK   5
extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

NTSTATUS
RtAudioTypeIGetPlayPosition(
    IN PFILE_OBJECT PinFileObject,
    OUT PUCHAR *ppPlayPosition,
    OUT PLONG plOffset)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    ULONG ulCurrentFrame;
    PLIST_ENTRY ple;
    PISO_URB_INFO pIsoUrbInfoTemp;
    PUCHAR pPlayPosInUrb = NULL;
    LONG lPlayPosOffset = 0;
    PURB pUrb;
    ULONG ulStartFrame;
    KIRQL Irql;
    NTSTATUS ntStatus;
    ULONG MinFramesAhead=MAX_ULONG;

    //
    //  Get the KSPIN from the file object
    //
    pKsPin = (PKSPIN)KsGetObjectFromFileObject( PinFileObject );
    if (!pKsPin) {
        return STATUS_UNSUCCESSFUL;
    }

    pPinContext = pKsPin->Context;
    pT1PinContext = pPinContext->pType1PinContext;

    //
    // search the pending transfers to see which one is going out now
    //
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );

    //
    //  Get the current frame counter so we know where the hardware is
    //
    ntStatus = GetCurrentUSBFrame( pPinContext, &ulCurrentFrame );

    if (NT_SUCCESS(ntStatus)) {

        for(ple = pT1PinContext->UrbInUseList.Flink;
            ple != &pT1PinContext->UrbInUseList;
            ple = ple->Flink)
        {
            pIsoUrbInfoTemp = (PISO_URB_INFO)ple;
            pUrb = pIsoUrbInfoTemp->pUrb;

            // DbgLog("CHECK", &pT1PinContext->UrbInUseList, pIsoUrbInfoTemp, pUrb, 0);

            //
            // see if this urb is the one that is currently being played
            //
            ulStartFrame = pUrb->UrbIsochronousTransfer.StartFrame;
            if (ulStartFrame != 0) {
                DbgLog("RT1BPos", ulCurrentFrame, ulStartFrame, 0, 0);

                if ( (ulCurrentFrame - ulStartFrame) < pUrb->UrbIsochronousTransfer.NumberOfPackets ) {

                    pPlayPosInUrb=(PUCHAR)pUrb->UrbIsochronousTransfer.TransferBuffer;

                    lPlayPosOffset=(ulCurrentFrame - ulStartFrame);

                    // This measurement is valid.  Make sure we don't lose it
                    // because of any earlier FramesAhead measurements.
                    MinFramesAhead=MAX_ULONG;

                    break;
                }
                else {
                    ULONG FramesAhead;

                    FramesAhead=(ulStartFrame-ulCurrentFrame);

                    if (FramesAhead<MinFramesAhead) {

                        MinFramesAhead=FramesAhead;

                        pPlayPosInUrb=(PUCHAR)pUrb->UrbIsochronousTransfer.TransferBuffer;

                        lPlayPosOffset=-(LONG)FramesAhead;

                    }
                }

            }
            else {
                // Start Frame is not set yet
                _DbgPrintF( DEBUGLVL_TERSE, ("'[RtAudioTypeIGetPlayPosition] Start Frame is not set for pUrb: %x\n", pUrb));
            }
        }

    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);


    // Clear out the closest URB information if it is too far from the
    // current position.  If the closest URB in our list is more than 150ms
    // away from the current position, then we drop the data on the floor.

    // Note that we ALWAYS set the MinFramesAhead to 0xffffffff in the
    // case when we find a position inside an URB - so that this code never
    // clears that position information.

    if (MinFramesAhead!=MAX_ULONG && MinFramesAhead>150) {

        pPlayPosInUrb = NULL;
        lPlayPosOffset = 0;

        _DbgPrintF( DEBUGLVL_TERSE, ("'[RtAudioTypeIGetPlayPosition] Couldn't find matching urb!\n"));

    }


    *ppPlayPosition = pPlayPosInUrb;
    *plOffset      = lPlayPosOffset;

    DbgLog("RtPos", pPlayPosInUrb, lPlayPosOffset, 0, 0);

    return ntStatus;
}

NTSTATUS
TypeIAsyncEPPollCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    PSYNC_ENDPOINT_INFO pSyncEPInfo )
{
    PPIN_CONTEXT pPinContext = pSyncEPInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

    ULONG SRWhole;
    ULONG SRFraction;
    ULONG SampleRate;
    KIRQL Irql;

    SRWhole = (((ULONG)pSyncEPInfo->Buffer[2]<<2) | ((ULONG)pSyncEPInfo->Buffer[1]>>6)) * 1000;
    SRFraction = (((ULONG)pSyncEPInfo->Buffer[1]<<4) | ((ULONG)pSyncEPInfo->Buffer[0]>>4)) & 0x3FF;
    SRFraction = (SRFraction*1000) / 1024;
    SampleRate = SRWhole + SRFraction;

    DbgLog("T1AsECB", SampleRate,
                      (ULONG)pSyncEPInfo->Buffer[2],
                      (ULONG)pSyncEPInfo->Buffer[1],
                      (ULONG)pSyncEPInfo->Buffer[0]);

    if ( SampleRate && ( SampleRate != pT1PinContext->ulCurrentSampleRate )) {
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
        pT1PinContext->ulCurrentSampleRate = SampleRate;
        pT1PinContext->fSampleRateChanged = TRUE;
        KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );
    }

    pSyncEPInfo->ulNextPollFrame = pSyncEPInfo->pUrb->UrbIsochronousTransfer.StartFrame +
                                   pSyncEPInfo->ulRefreshRate;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    pSyncEPInfo->fSyncRequestInProgress = FALSE;
    KeSetEvent( &pSyncEPInfo->SyncPollDoneEvent, 0, FALSE );
    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

VOID
TypeIAsyncEndpointPoll(
    PDEVICE_OBJECT pNextDeviceObject,
    PSYNC_ENDPOINT_INFO pSyncEPInfo )
{
    PURB pUrb = pSyncEPInfo->pUrb;
    PIRP pIrp = pSyncEPInfo->pIrp;
    PIO_STACK_LOCATION nextStack;

    // First Reset the pipe.
    ResetUSBPipe( pNextDeviceObject,
                  pSyncEPInfo->hSyncPipeHandle );

    RtlZeroMemory(pUrb, GET_ISO_URB_SIZE(1));

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)GET_ISO_URB_SIZE(1);
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pSyncEPInfo->hSyncPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP |
                                                   USBD_TRANSFER_DIRECTION_IN;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = 1;

    pUrb->UrbIsochronousTransfer.IsoPacket[0].Offset = 0;

    pUrb->UrbIsochronousTransfer.TransferBuffer       = pSyncEPInfo->Buffer;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = SYNC_ENDPOINT_DATA_SIZE;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pNextDeviceObject->StackSize),
                     pNextDeviceObject->StackSize );

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine( pIrp, TypeIAsyncEPPollCallback, pSyncEPInfo, TRUE, TRUE, TRUE );

    IoCallDriver(pNextDeviceObject, pIrp);

}

NTSTATUS
TypeIRenderBytePosition(
    PPIN_CONTEXT pPinContext,
    PKSAUDIO_POSITION pPosition )
{
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo;
    ULONG ulStartFrame, ulCurrentFrame;
    PLIST_ENTRY ple;
    PURB pUrb;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pPosition->PlayOffset = 0;

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

    if ( pPinContext->fStreamStartedFlag ) {

        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        ntStatus = GetCurrentUSBFrame( pPinContext, &ulCurrentFrame );
        if (NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            DbgLog("T1BPos1", pPinContext, pT1PinContext, ulCurrentFrame, 0);

            for( ple = pT1PinContext->UrbInUseList.Flink;
                 ple != &pT1PinContext->UrbInUseList;
                 ple = ple->Flink) {
                ULONG ulNumPackets;

                pIsoUrbInfo = (PISO_URB_INFO)ple;
                pUrb = pIsoUrbInfo->pUrb;
                ulNumPackets = pUrb->UrbIsochronousTransfer.NumberOfPackets;

                ulStartFrame = pUrb->UrbIsochronousTransfer.StartFrame;

                if (ulStartFrame != 0) {

       	            DbgLog("T1BPos2", ulStartFrame, ulCurrentFrame, ulNumPackets, 0);

                    // Determine if this is the current Frame being rendered.
                    if (( ulCurrentFrame - ulStartFrame ) < ulNumPackets ){
                        PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket = 
                            &pUrb->UrbIsochronousTransfer.IsoPacket[ulCurrentFrame - ulStartFrame];
                        ULONG ulFrameBytes = (( ulCurrentFrame - ulStartFrame ) == (ulNumPackets-1)) ?
                                             pIsoUrbInfo->ulTransferBufferLength-pIsoPacket[0].Offset :
                                             pIsoPacket[1].Offset-pIsoPacket[0].Offset;

         	            DbgLog("StrtFr1", ulStartFrame, ulCurrentFrame, ulNumPackets, ulFrameBytes);
         	            DbgLog("StrtFr2", pUrb, pIsoPacket, 
         	                              pIsoUrbInfo->ulTransferBufferLength, 
         	                              0);
         	            ASSERT((LONG)ulFrameBytes > 0);

                        pPosition->PlayOffset += pIsoPacket[0].Offset;
                        
         	            // If this is the current frame determine if there have been 
         	            // multiple position requests during this frame. If so, "interpolate".
         	            if ( ulCurrentFrame == pPinContext->ulCurrentFrame ){
         	                if ( pPinContext->ulFrameRepeatCount++ < 8 ) {
         	                    pPosition->PlayOffset += pPinContext->ulFrameRepeatCount*
         	                                            (ulFrameBytes>>3);
         	                }
         	                else {
         	                    pPosition->PlayOffset += ulFrameBytes; // Possible repeat here
         	                }
         	            }
         	            else {
         	                pPinContext->ulFrameRepeatCount = 0;
         	                pPinContext->ulCurrentFrame = ulCurrentFrame;
         	            }
         	            break;
                    }
                    else if (( ulCurrentFrame - ulStartFrame ) < 0x7fffffff){
                        // Current position is past this urb.
                        // Add this URB's byte count to total
                        pPosition->PlayOffset += pIsoUrbInfo->ulTransferBufferLength;
                    }
        	    }
        	}

            pPosition->PlayOffset += pPinContext->ullTotalBytesReturned;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        }
    }
    else {
        pPosition->PlayOffset += pPinContext->ullTotalBytesReturned;
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
    }

    return ntStatus;

}

NTSTATUS
TypeI1MsCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMSEC_BUF_INFO p1MsBufInfo )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)p1MsBufInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    KIRQL Irql;

    // Check for errors and Decrement outstanding URB count
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
    if ( p1MsBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        pPinContext->fUrbError = TRUE;
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    pPinContext->ullTotalBytesReturned += p1MsBufInfo->ulTransferBufferLength;
    DbgLog("RetUrb1", p1MsBufInfo->ulTransferBufferLength, pPinContext->ullTotalBytesReturned, 
                      p1MsBufInfo->pUrb, 0 );

    // Remove from the pending list
    RemoveEntryList(&p1MsBufInfo->List);

    // Put 1ms info structure back on queue.
    InsertTailList( &pT1PinContext->MSecBufList, &p1MsBufInfo->List );

    KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

    // release 1ms resource semaphore
    KeReleaseSemaphore( &pT1PinContext->MsecBufferSemaphore, 0, 1, FALSE );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

VOID
TypeIBuild1MsecIsocRequest(
    PMSEC_BUF_INFO p1MsBufInfo )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)p1MsBufInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PURB pUrb = p1MsBufInfo->pUrb;
    PIRP pIrp = p1MsBufInfo->pIrp;
    PIO_STACK_LOCATION nextStack;
    KIRQL Irql;

    RtlZeroMemory(pUrb, GET_ISO_URB_SIZE(1));

    pUrb->UrbIsochronousTransfer.Hdr.Length           = (USHORT)GET_ISO_URB_SIZE(1);
    pUrb->UrbIsochronousTransfer.Hdr.Function         = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle           = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags        = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.NumberOfPackets      = 1;
    pUrb->UrbIsochronousTransfer.TransferBuffer       = p1MsBufInfo->pBuffer;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = p1MsBufInfo->ulTransferBufferLength;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, TypeI1MsCompleteCallback, p1MsBufInfo, TRUE, TRUE, TRUE );

    InterlockedIncrement(&pPinContext->ulOutstandingUrbCount); 

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    InsertTailList( &pT1PinContext->UrbInUseList, &p1MsBufInfo->List );
    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    IoCallDriver(pPinContext->pNextDeviceObject, pIrp);

}

NTSTATUS
TypeICompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo = pKsStreamPtr->Context;
    PURB pUrb = pIsoUrbInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL Irql;
    LOGICAL Glitch = FALSE;
    LARGE_INTEGER currentPC;

    ntStatus = pIrp->IoStatus.Status;

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("UrbErr1", pKsStreamPtr->Pin, pPinContext,
                          pKsStreamPtr, pUrb->UrbIsochronousTransfer.Hdr.Status );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);

    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        DbgLog("UrbErr2", pKsStreamPtr->Pin, pPinContext, pKsStreamPtr, ntStatus );
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        Glitch = TRUE;
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
//    else if ( !pPinContext->fStreamStartedFlag && !pPinContext->fUrbError ) {
//        pPinContext->fStreamStartedFlag = TRUE;
//    }

    pPinContext->ullTotalBytesReturned += pIsoUrbInfo->ulTransferBufferLength;

    DbgLog("RetUrb", pIsoUrbInfo->ulTransferBufferLength, pPinContext->ullTotalBytesReturned, 
                     pUrb, pKsStreamPtr );

    RemoveEntryList(&pIsoUrbInfo->List);

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    FreeMem ( pIsoUrbInfo );

    if (LoggerHandle && TraceEnable) {
        currentPC = KeQueryPerformanceCounter (NULL);

        if (Glitch) {
            if (!pPinContext->GraphJustStarted) {
                if (pPinContext->StarvationDetected==FALSE) {
                    pPinContext->StarvationDetected = TRUE;
                    PerfLogGlitch((ULONG_PTR)pPinContext, TRUE,currentPC.QuadPart,pPinContext->LastStateChangeTimeSample);
                } //if
            }
        }
        else if (pPinContext->StarvationDetected) {    
            pPinContext->StarvationDetected = FALSE;
            PerfLogGlitch((ULONG_PTR)pPinContext, FALSE,currentPC.QuadPart,pPinContext->LastStateChangeTimeSample);
        } //if

        pPinContext->LastStateChangeTimeSample = currentPC.QuadPart;
    } //if

    pPinContext->GraphJustStarted = FALSE;

    // If error, set status code
    if (!NT_SUCCESS (ntStatus)) {
        KsStreamPointerSetStatusCode (pKsStreamPtr, ntStatus);
    }

    // Free Irp
    IoFreeIrp( pIrp );

    // Delete the stream pointer to release the buffer.
    KsStreamPointerDelete( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

NTSTATUS
TypeILockDelayCompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo = pKsStreamPtr->Context;
    PURB pUrb = pIsoUrbInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL Irql;

    ntStatus = pIrp->IoStatus.Status;

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("UrbErr1", pKsStreamPtr->Pin, pPinContext,
                          pKsStreamPtr, pUrb->UrbIsochronousTransfer.Hdr.Status );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    // Free our URB storage
    FreeMem( pIsoUrbInfo );

    // Free Irp
    IoFreeIrp( pIrp );

    // Free the stream pointer and data buffer.
    FreeMem( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}


NTSTATUS
TypeIBuildIsochRequest(
    PKSSTREAM_POINTER pKsStreamPtr,
    PVOID pCompletionRoutine )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
	ULONG ulSampleCount = pKsStreamPtrOffsetIn->Remaining / pT1PinContext->ulBytesPerSample;
    ULONG ulNumberOfPackets = ulSampleCount / pT1PinContext->ulSamplesPerPacket;
	ULONG ulCurrentPacketSize, i = 0;

    ULONG ulUrbSize = GET_ISO_URB_SIZE( ulNumberOfPackets );
    ULONG ulDataOffset = 0;
    PIO_STACK_LOCATION nextStack;
    PISO_URB_INFO pIsoUrbInfo;
    PURB pUrb;
    PIRP pIrp;
    KIRQL Irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT( (pKsStreamPtrOffsetIn->Remaining % pT1PinContext->ulBytesPerSample) == 0 );

    pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
    if ( !pIrp ) {
        if (pCompletionRoutine == TypeILockDelayCompleteCallback) {
            FreeMem( pKsStreamPtr );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pIsoUrbInfo = AllocMem( NonPagedPool, sizeof( ISO_URB_INFO ) + ulUrbSize );
    if (!pIsoUrbInfo) {
        IoFreeIrp(pIrp);
        if (pCompletionRoutine == TypeILockDelayCompleteCallback) {
            FreeMem( pKsStreamPtr );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pIsoUrbInfo->pUrb = pUrb = (PURB)(pIsoUrbInfo + 1);

    pKsStreamPtr->Context = pIsoUrbInfo;
    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)ulUrbSize;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.TransferBuffer  = pKsStreamPtrOffsetIn->Data;

	ulCurrentPacketSize = 
		( ((pT1PinContext->ulLeftoverFraction+pT1PinContext->ulFractionSize) >= MS_PER_SEC) +
        pT1PinContext->ulSamplesPerPacket );

    DbgLog( "BldPreL", ulCurrentPacketSize, ulSampleCount, pKsStreamPtrOffsetIn->Data, 0 );

	while ( ulSampleCount >= ulCurrentPacketSize ) {
        pUrb->UrbIsochronousTransfer.IsoPacket[i++].Offset = ulDataOffset;

        pUrb->UrbIsochronousTransfer.NumberOfPackets++;
        ASSERT( pUrb->UrbIsochronousTransfer.NumberOfPackets <= ulNumberOfPackets );

		pT1PinContext->ulLeftoverFraction += pT1PinContext->ulFractionSize;
		pT1PinContext->ulLeftoverFraction %= MS_PER_SEC;

        DbgLog( "BldLp", ulCurrentPacketSize, ulSampleCount, pKsStreamPtrOffsetIn->Data, ulDataOffset );

        ulDataOffset                    += ulCurrentPacketSize * pT1PinContext->ulBytesPerSample;
		pKsStreamPtrOffsetIn->Remaining -= ulCurrentPacketSize * pT1PinContext->ulBytesPerSample;
		ulSampleCount -= ulCurrentPacketSize;

    	ulCurrentPacketSize = 
	    	( ((pT1PinContext->ulLeftoverFraction+pT1PinContext->ulFractionSize) >= MS_PER_SEC) +
            pT1PinContext->ulSamplesPerPacket );

    }

    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulDataOffset;
    pIsoUrbInfo->ulTransferBufferLength = ulDataOffset;
    pKsStreamPtrOffsetIn->Data += ulDataOffset;

    // Gotta save off the leftovers before submitting this Urb.
    if ( pKsStreamPtrOffsetIn->Remaining ) {
        PMSEC_BUF_INFO pCurrent1MsBuf;

        DbgLog( "BldRemn", pKsStreamPtrOffsetIn->Remaining, pKsStreamPtrOffsetIn->Count,
                           pKsStreamPtrOffsetIn->Data, ulDataOffset);

        KeWaitForSingleObject( &pT1PinContext->MsecBufferSemaphore,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
        if ( !IsListEmpty( &pT1PinContext->MSecBufList )) {
            pCurrent1MsBuf = (PMSEC_BUF_INFO)pT1PinContext->MSecBufList.Flink;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

            pCurrent1MsBuf->ulTransferBufferLength = pKsStreamPtrOffsetIn->Remaining;

            // Copy next partial to next 1ms buffer
            RtlCopyMemory( pCurrent1MsBuf->pBuffer,
                           pKsStreamPtrOffsetIn->Data,
                           pKsStreamPtrOffsetIn->Remaining );

		    pT1PinContext->ulPartialBufferSize = (ulCurrentPacketSize*pT1PinContext->ulBytesPerSample) - 
												 pKsStreamPtrOffsetIn->Remaining;
             DbgLog( "PartBuf", ulCurrentPacketSize, ulSampleCount, 
                                pT1PinContext->ulPartialBufferSize, 0 );
            pT1PinContext->ulLeftoverFraction += pT1PinContext->ulFractionSize;
            pT1PinContext->ulLeftoverFraction %= MS_PER_SEC;
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );
        }

    }

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, pCompletionRoutine, pKsStreamPtr, TRUE, TRUE, TRUE );

    InterlockedIncrement( &pPinContext->ulOutstandingUrbCount );

    // Add Urb to InUse list
    if (pCompletionRoutine == TypeICompleteCallback) {
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
        // DbgLog("ADD", &pT1PinContext->UrbInUseList, pIsoUrbInfo, pUrb, 0);
        InsertTailList( &pT1PinContext->UrbInUseList, &pIsoUrbInfo->List );
        KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);
    }

    ntStatus = IoCallDriver( pPinContext->pNextDeviceObject, pIrp );

    if ( NT_SUCCESS(ntStatus) ) {
        if (pCompletionRoutine == TypeICompleteCallback) {
            KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
            pPinContext->fStreamStartedFlag = TRUE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);
        }
    }
    
    return ntStatus;
}

NTSTATUS
TypeILockDelay( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    ULONG ulLockFrames = 0;
    ULONG ulLockSamples;
    ULONG ulDelayBytes;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Only values 1 and 2 are defined
    ASSERT(pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits < 3);

    // Calculate the size of the delay for the current sample rate.
    switch ( pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits ) {
        case EP_LOCK_DELAY_UNITS_MS:
            // Delay is in milliseconds.
            ulLockFrames  =
                (ULONG)pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay;
            break;

        case EP_LOCK_DELAY_UNITS_SAMPLES:
            // Delay is in samples. Adjust to nearest ms boundry.
            ulLockFrames =
                (ULONG)pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay /
                pT1PinContext->ulSamplesPerPacket;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    // Ensure that at least something is sent down to the device
    if ( ulLockFrames == 0 ) {
        ulLockFrames++;
    }

    if ( NT_SUCCESS(ntStatus) ) {
        PKSSTREAM_POINTER pKsStreamPtr;
        ULONG ulAllocSize;
        // Calculate the number of the samples to fill the frames and
        // create the pseudo queue pointer for the zeroed data buffer.
        ulLockSamples = ulLockFrames * pT1PinContext->ulSamplesPerPacket +
                        (( ulLockFrames * pT1PinContext->ulFractionSize ) / MS_PER_SEC);
        ulDelayBytes  = ulLockSamples * pT1PinContext->ulBytesPerSample;

        DbgLog( "LockD", ulLockFrames, ulLockSamples,
                pT1PinContext->ulCurrentSampleRate,
                pT1PinContext->ulBytesPerSample );

        _DbgPrintF( DEBUGLVL_TERSE,
                  ("[TypeILockDelay] ulLockFrames: %x ulLockSamples: %x DelayBytes %x\n",
                    ulLockFrames, ulLockSamples, ulDelayBytes));

        ulAllocSize = sizeof(KSSTREAM_POINTER) + ulDelayBytes;
        pKsStreamPtr = AllocMem( NonPagedPool, ulAllocSize );
        if ( pKsStreamPtr ) {
            KIRQL Irql;
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
            //
            // NOTE: Resetting the sample rate will cause kmixer and usbaudio to be out of sync
            // w.r.t. their leftover fractions.
            //
            // This might have the side effect of breaking synchronous devices, of which none
            // exist as of today, Feb. 21, 2000.
            //
            //pT1PinContext->fSampleRateChanged = FALSE;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

            RtlZeroMemory( pKsStreamPtr, ulAllocSize );
            pKsStreamPtr->Pin                = pKsPin;
            pKsStreamPtr->OffsetIn.Data      = (PUCHAR)(pKsStreamPtr+1);
            pKsStreamPtr->OffsetIn.Count     = ulDelayBytes;
            pKsStreamPtr->OffsetIn.Remaining = ulDelayBytes;
            ntStatus = TypeIBuildIsochRequest( pKsStreamPtr,
                                               TypeILockDelayCompleteCallback );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_TERSE,("[TypeILockDelay] Status Error: %x\n", ntStatus ));
            }
        }
        else
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
TypeIProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
	PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PMSEC_BUF_INFO pCurrent1MsBuf;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Check for a data error. If error flag set abort the pipe and start again.
    if ( pPinContext->fUrbError ) {
        AbortUSBPipe( pPinContext );
    }

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pT1PinContext->fSampleRateChanged ) {
        pT1PinContext->ulSamplesPerPacket = pT1PinContext->ulCurrentSampleRate / MS_PER_SEC;
        pT1PinContext->ulFractionSize     = pT1PinContext->ulCurrentSampleRate % MS_PER_SEC;
        pT1PinContext->fSampleRateChanged = FALSE;

        DbgLog( "T1CSRCh", pT1PinContext->ulCurrentSampleRate, 
                           pT1PinContext->ulSamplesPerPacket,
                           pT1PinContext->ulFractionSize,
                           pT1PinContext->ulLeftoverFraction );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    if ( pT1PinContext->fLockDelayRequired ) {
        pT1PinContext->fLockDelayRequired = FALSE;
        ntStatus = TypeILockDelay( pKsPin );
    }

    // Get the next Stream pointer from queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[TypeIProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    DbgLog("T1Proc", pKsPin, pPinContext, pKsStreamPtr, pPinContext->fUrbError);

    // Clone Stream pointer to keep queue moving.
    if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {

        // Get a pointer to the data information from the stream pointer
        pKsStreamPtrOffsetIn = &pKsCloneStreamPtr->OffsetIn;

        // Set the write offset for position info
        pPinContext->ullWriteOffset += pKsStreamPtrOffsetIn->Count;

        DbgLog("ByteCnt", pKsStreamPtrOffsetIn->Data, pKsStreamPtrOffsetIn->Count, 0, 0);


        // Copy partial ms data to current 1ms buffer and send if full
        if ( pT1PinContext->ulPartialBufferSize ) {

            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
            pCurrent1MsBuf = (PMSEC_BUF_INFO)RemoveHeadList(&pT1PinContext->MSecBufList);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            RtlCopyMemory( pCurrent1MsBuf->pBuffer + pCurrent1MsBuf->ulTransferBufferLength,
                           pKsStreamPtrOffsetIn->Data,
                           pT1PinContext->ulPartialBufferSize );

            pCurrent1MsBuf->ulTransferBufferLength += pT1PinContext->ulPartialBufferSize;
            TypeIBuild1MsecIsocRequest( pCurrent1MsBuf );

            pKsStreamPtrOffsetIn->Remaining -= pT1PinContext->ulPartialBufferSize;
            pKsStreamPtrOffsetIn->Data      += pT1PinContext->ulPartialBufferSize;

			pT1PinContext->ulPartialBufferSize = 0;

        }

        // Create the URB for the majority of the data
        ntStatus = TypeIBuildIsochRequest( pKsCloneStreamPtr,
                                           TypeICompleteCallback );
         if ( NT_SUCCESS(ntStatus)) ntStatus = STATUS_SUCCESS;

        // If there is a sync endpoint, poll it for feedback
        if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
            ULONG ulCurrentFrame;
            if (NT_SUCCESS( GetCurrentUSBFrame(pPinContext, &ulCurrentFrame)) &&
                (LONG)(ulCurrentFrame-pT1PinContext->SyncEndpointInfo.ulNextPollFrame) >= 0) {

                 KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                 if ( !pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
                     pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress = TRUE;
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                     TypeIAsyncEndpointPoll( pPinContext->pNextDeviceObject,
                                             &pT1PinContext->SyncEndpointInfo );
                 }
                 else
                     KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            }
        }
    }

    // Unlock the stream pointer. This will really only unlock after last clone is deleted.
    KsStreamPointerUnlock( pKsStreamPtr, TRUE );

    return ntStatus;
}

NTSTATUS
TypeIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    switch(NewKsState) {
        case KSSTATE_STOP:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            // Need to reset position counters and stream running flag
            pPinContext->fStreamStartedFlag = FALSE;
            pPinContext->ullWriteOffset = 0;

            pPinContext->ullTotalBytesReturned = 0;
            pPinContext->ulCurrentFrame = 0;
            pPinContext->ulFrameRepeatCount = 0;

            // Reset to original Sample rate
            pT1PinContext->ulCurrentSampleRate = pT1PinContext->ulOriginalSampleRate;
            pT1PinContext->fSampleRateChanged = TRUE;
            pT1PinContext->ulLeftoverFraction  = 0;

            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            pPinContext->StarvationDetected = FALSE;
            break;

        case KSSTATE_ACQUIRE:
            break;

        case KSSTATE_PAUSE:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            // Reset to original Sample rate on Async endpoints
            // Don't do for adaptive endpoints, or else we will have to do a copy
            // which is bad for real-time mixing
            if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
                pT1PinContext->ulCurrentSampleRate = pT1PinContext->ulOriginalSampleRate;
                pT1PinContext->fSampleRateChanged = TRUE;
                pT1PinContext->ulLeftoverFraction  = 0;
            }

            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;

        case KSSTATE_RUN:
            pPinContext->GraphJustStarted = TRUE;
            break;
    }

    return ntStatus;
}

NTSTATUS
TypeIRenderStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    PWAVEFORMATEX pWavFormat;
    PMSEC_BUF_INFO pMsInfo;
    ULONG_PTR pMSBuffers;
    ULONG_PTR pUrbs;
    NTSTATUS ntStatus;
    ULONG NumPages, i;

    // In order to ensure that none of the 1ms buffers cross a page boundary, we
    // are careful to allocate enough space so that we never have to straddle one
    // of the audio buffers across a page boundary.  We also make sure to adjust
    // any that would cross a page boundary, up to the start of the next page.
    // This is to prevent a copy by lower levels of the usb stack, since the UHCD
    // usb hardware cannot deal with a 1ms block that crosses a page boundary.

    // Furthermore, all of the 1ms buffers must be quadword aligned on 64 bit machines.

    // First we calculate how many aligned 1 ms buffers fit in a page.
    i=PAGE_SIZE/(pPinContext->ulMaxPacketSize + sizeof(PVOID)-1);

    if (!i) {
        // If we get here it will be because we finally have USB audio devices
        // that support such high sampling rates and sample sizes that they require a datarate
        // higher than 1 PAGE per ms.  On x86 that would be 4,096,000 bytes per second.
        // That is more than the bandwidth of the USB bus, although it can be supported on USB2.

        // Calculate how many pages per ms we need.
        i=(pPinContext->ulMaxPacketSize + sizeof(PVOID)-1)/PAGE_SIZE;
        if ((pPinContext->ulMaxPacketSize + sizeof(PVOID)-1)%PAGE_SIZE) {
            i++;
        }

        // Now calculate the total number of pages that we need.
        NumPages=NUM_1MSEC_BUFFERS*i;
    }
    else {
        // Now calculate how many pages we need for the 1ms buffers.
        NumPages=NUM_1MSEC_BUFFERS/i;
        if (NUM_1MSEC_BUFFERS%i) {
            NumPages++;
        }
    }

    pPinContext->pType1PinContext=NULL;

    // Allocate space for Type I stream specific information.
    // In order to make sure that the system doesn't shift our allocation and thus
    // invalidate our space calculations and our code for shifting buffers that cross
    // page boundaries, we round this allocation up to an even number of pages.
    pT1PinContext = AllocMem( NonPagedPool, (( NumPages*PAGE_SIZE + sizeof(TYPE1_PIN_CONTEXT) +
                              NUM_1MSEC_BUFFERS * (GET_ISO_URB_SIZE( 1 ) + sizeof(PVOID)-1) +
                              PAGE_SIZE-1)/PAGE_SIZE)*PAGE_SIZE );

    if ( !pT1PinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pMSBuffers = (ULONG_PTR)pT1PinContext;

    // Bag the Type1 context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pT1PinContext, FreeMem);

    // Set pointers for 1 MS buffers and URBs (even though they may not be used)
    pUrbs = pMSBuffers + NumPages*PAGE_SIZE;
    pT1PinContext = pPinContext->pType1PinContext = (PTYPE1_PIN_CONTEXT)((pUrbs + (NUM_1MSEC_BUFFERS * (GET_ISO_URB_SIZE(1) + sizeof(PVOID)-1)))&~(sizeof(PVOID)-1));

    // Fill in 1ms buffer information structures and init the semaphore
    pMsInfo = pT1PinContext->MSBufInfos;
    InitializeListHead(&pT1PinContext->MSecBufList);
    for (i=0; i<NUM_1MSEC_BUFFERS; i++, pMsInfo++) {
        pMsInfo->pContext = pPinContext;
        pMsInfo->pBuffer = (PUCHAR)pMSBuffers;
        pMsInfo->pUrb = (PURB)pUrbs;

        // Calculate the location of the next ms buffer.  If the next buffer crosses 
        // a page boundary then start it at the beginning of the next page.
        pMSBuffers+=pPinContext->ulMaxPacketSize+sizeof(PVOID)-1;
        pMSBuffers&=~(sizeof(PVOID)-1);
        if ((pMSBuffers^(pMSBuffers+pPinContext->ulMaxPacketSize))&~(PAGE_SIZE-1)) {
            pMSBuffers&=~(PAGE_SIZE-1);
            pMSBuffers+=PAGE_SIZE;
        }

        // Calculate the next urb location.
        pUrbs+=GET_ISO_URB_SIZE(1)+sizeof(PVOID)-1;
        pUrbs&=~(sizeof(PVOID)-1);

        pMsInfo->pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pMsInfo->pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        // Bag the irps for easy cleanup.
        KsAddItemToObjectBag(pKsPin->Bag, pMsInfo->pIrp, IoFreeIrp);
        InsertTailList( &pT1PinContext->MSecBufList, &pMsInfo->List );
    }

    // Initialize the semaphore for the 1ms buffer structures
    KeInitializeSemaphore( &pT1PinContext->MsecBufferSemaphore, NUM_1MSEC_BUFFERS, NUM_1MSEC_BUFFERS );

    // Initialize the list head for in use list
    InitializeListHead(&pT1PinContext->UrbInUseList);

    // Initialize Packet size and Leftover counters.
    pWavFormat = &((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx;
    pT1PinContext->ulOriginalSampleRate = pWavFormat->nSamplesPerSec;
    pT1PinContext->ulCurrentSampleRate  = pWavFormat->nSamplesPerSec;
    pT1PinContext->ulBytesPerSample     = ((ULONG)pWavFormat->wBitsPerSample >> 3) *
                                          (ULONG)pWavFormat->nChannels;
    pT1PinContext->ulPartialBufferSize = 0;
    pT1PinContext->fSampleRateChanged  = TRUE;
    pT1PinContext->fLockDelayRequired  = FALSE;
    pT1PinContext->ulLeftoverFraction  = 0;

    // Set the current Sample rate
    ntStatus = SetSampleRate(pKsPin, &pT1PinContext->ulCurrentSampleRate);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    if ( pUsbAudioDataRange->pSyncEndpointDescriptor ) {
        PSYNC_ENDPOINT_INFO pSyncEndpointInfo = &pT1PinContext->SyncEndpointInfo;
        PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR pInterruptEndpointDescriptor = (PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pUsbAudioDataRange->pSyncEndpointDescriptor;

        pSyncEndpointInfo->pUrb = AllocMem( NonPagedPool, GET_ISO_URB_SIZE( 1 ) );
        if ( !pSyncEndpointInfo->pUrb ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KsAddItemToObjectBag(pKsPin->Bag, pSyncEndpointInfo->pUrb, FreeMem);
        pSyncEndpointInfo->pIrp =
            IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pSyncEndpointInfo->pIrp ) {
           return STATUS_INSUFFICIENT_RESOURCES;
        }
        KsAddItemToObjectBag(pKsPin->Bag, pSyncEndpointInfo->pIrp, IoFreeIrp);

        pSyncEndpointInfo->fSyncRequestInProgress = FALSE;
        pSyncEndpointInfo->ulNextPollFrame = 0;
        pSyncEndpointInfo->hSyncPipeHandle = NULL;
        pSyncEndpointInfo->pContext = pPinContext;
        pSyncEndpointInfo->ulRefreshRate = 1<<(ULONG)pInterruptEndpointDescriptor->bRefresh;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("ulRefreshRate: %d\n",pSyncEndpointInfo->ulRefreshRate));

        KeInitializeEvent( &pSyncEndpointInfo->SyncPollDoneEvent,
                           SynchronizationEvent,
                           FALSE );

        ASSERT(pSyncEndpointInfo->ulRefreshRate >= 32); // Make sure refresh is reasonable

        for ( i=0; i<pPinContext->ulNumberOfPipes; i++ ) {
            if ( (ULONG)pPinContext->Pipes[i].EndpointAddress ==
                           (ULONG)pUsbAudioDataRange->pSyncEndpointDescriptor->bEndpointAddress ) {
                pSyncEndpointInfo->hSyncPipeHandle = pPinContext->Pipes[i].PipeHandle;
                break;
            }
        }
        if ( !pSyncEndpointInfo->hSyncPipeHandle ) {
            return STATUS_DEVICE_DATA_ERROR;
        }
    }
    // Need to check for lock delay (Note: If async this is illegal)
    else if (( pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits ) &&
             ( pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay )) {
        pT1PinContext->fLockDelayRequired = TRUE;
    }

    // Set up allocator such that roughly 10 ms of data gets sent in a buffer.
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
                                 (pT1PinContext->ulCurrentSampleRate/100) * pT1PinContext->ulBytesPerSample;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = 
                                 (pT1PinContext->ulCurrentSampleRate/100) * pT1PinContext->ulBytesPerSample;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = pT1PinContext->ulBytesPerSample;

    // Return success
    return STATUS_SUCCESS;
}

NTSTATUS
TypeIRenderStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;

    // Should not be necessary since close should never happen while
    // there are outstanding requests as they have stream pointers attached
    // Still, it couldn't hurt...
    USBAudioPinWaitForStarvation( pKsPin );

    // If this is an Async endpoint device make sure no Async Poll
    // requests are still outstanding.
    if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
        PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
            KeResetEvent( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent );
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            KeWaitForSingleObject( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        else
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\property.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       property.h
//
//--------------------------------------------------------------------------

#ifndef ___PROPERTY_H___
#define ___PROPERTY_H___

/*****************************************************************************

                        Definitions of Properties

*****************************************************************************/
// Declare Handlers for Pin Properties
NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pPin, PVOID pData );

// Declare Handlers for Item Map
NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
//NTSTATUS
//GetSetDynamicRange( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

static const
KSPROPERTY_ITEM PinPropertyItems[]={
    {
     (ULONG) KSPROPERTY_PIN_CINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CTYPES,      // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAFLOW,    // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATARANGES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAINTERSECTION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_INTERFACES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_MEDIUMS,     // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_COMMUNICATION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_GLOBALCINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NECESSARYINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PHYSICALCONNECTION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CATEGORY,    // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NAME,        // PropertyId
     (PFNKSHANDLER) GetPinName,          // pfnGetHandler
     sizeof(KSP_PIN),                    // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CONSTRAINEDDATARANGES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PROPOSEDATAFORMAT,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM AudioPropertyItems[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LATENCY,   // PropertyId
     GetAudioLatency,                    // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_COPY_PROTECTION, // PropertyId
     GetSetCopyProtection,               // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_COPY_PROTECTION),   // MinData
     GetSetCopyProtection,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHANNEL_CONFIG, // PropertyId
     GetChannelConfiguration,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_CHANNEL_CONFIG),    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL, // PropertyId
     GetSetVolumeLevel,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_POSITION,  // PropertyId
     GetAudioPosition,                   // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_RANGE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_DYNAMIC_RANGE),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_QUALITY,   // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_SAMPLING_RATE, // PropertyId
     GetSetSampleRate,                   // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetSampleRate,                   // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOL),                      // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,      // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (BOOL),                      // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS,      // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MID,       // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,    // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DELAY,     // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDE_MODE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDENESS,  // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_REVERB_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHORUS_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DEV_SPECIFIC, // PropertyId
     GetSetDeviceSpecific,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_DEV_SPECIFIC),  // MinProperty
     sizeof (BYTE),                      // MinData
     GetSetDeviceSpecific,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

#ifdef RTAUDIO
// RT Pos
DEFINE_KSPROPERTY_TABLE(RtAudioPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,         // idProperty
        RtAudio_GetAudioPositionFunction,               // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(PRTAUDIOGETPOSITION),                    // cbMinGetDataInput
        NULL,                                           // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};
#endif

// DRM
DEFINE_KSPROPERTY_TABLE(DrmAudioStreamPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSP_DRMAUDIOSTREAM_CONTENTID),           // cbMinGetPropertyInput
        sizeof(KSDRMAUDIOSTREAM_CONTENTID),             // cbMinGetDataInput
        DrmAudioStream_SetContentId,                    // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};

// AC-3 Property set.

static const KSPROPERTY_ITEM AC3PropItm[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ERROR_CONCEALMENT,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ALTERNATE_AUDIO,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_ALTERNATE_AUDIO),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DOWNMIX,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_DOWNMIX),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_BIT_STREAM_MODE,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (ULONG),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DIALOGUE_LEVEL,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_LANGUAGE_CODE,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ROOM_TYPE,   // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM TopologyItm[]={
    {
     (ULONG) KSPROPERTY_TOPOLOGYNODE_ENABLE,  // PropertyId
     GetSetTopologyNodeEnable,           // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     GetSetTopologyNodeEnable,           // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM ConnectionItm[]={
  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(NULL)
};

static const KSPROPERTY_ITEM StreamItm[]={
  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(NULL,NULL)
};


// Property sets for individual node types

static const
KSPROPERTY_ITEM VolumePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL,  // PropertyId
     GetSetVolumeLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MutePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,  // PropertyId
     GetSetBoolean,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupportBoolean,             // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM BassPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM TreblePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MidrangePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MID,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM BassBoostPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM EqualizerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MixerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM AGCPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MuxPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM LoudnessPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
};

static DEFINE_KSPROPERTY_SET_TABLE(NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_NONE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DAC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_ADC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SRC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_SUPERMIX
                           SIZEOF_ARRAY(MixerPropertyItems),
                           (PVOID) MixerPropertyItems,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUX
                           SIZEOF_ARRAY(MuxPropertyItem),
                           (PVOID) MuxPropertyItem,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SUM
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUTE
                           SIZEOF_ARRAY(MutePropertyItem),
                           (PVOID) MutePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_VOLUME
                           SIZEOF_ARRAY(VolumePropertyItem),
                           (PVOID) VolumePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_BASS
                           SIZEOF_ARRAY(BassPropertyItem),
                           (PVOID) BassPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MID
                           SIZEOF_ARRAY(MidrangePropertyItem),
                           (PVOID) MidrangePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_TREBLE
                           SIZEOF_ARRAY(TreblePropertyItem),
                           (PVOID) TreblePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_BASS_BOOST
                           SIZEOF_ARRAY(BassBoostPropertyItem),
                           (PVOID) BassBoostPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_EQUALIZER
                           SIZEOF_ARRAY(EqualizerPropertyItems),
                           (PVOID) EqualizerPropertyItems,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_AGC
                           SIZEOF_ARRAY(AGCPropertyItem),
                           (PVOID) AGCPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_LOUDNESS
                           SIZEOF_ARRAY(LoudnessPropertyItem),
                           (PVOID) LoudnessPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_PROLOGIC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_STEREO_WIDE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_REVERB
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_CHORUS
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DEV_SPEC
                           0,
                           NULL,
                           0, NULL )

};

/*

    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \

*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\usbaudio.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       usbaudio.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

#if DBG
ULONG USBAudioDebugLevel = DEBUGLVL_TERSE;
#endif

const
KSDEVICE_DISPATCH
USBAudioDeviceDispatch =
{
    USBAudioAddDevice,
    USBAudioPnpStart,
    NULL, // Post Start
    USBAudioPnpQueryStop,
    USBAudioPnpCancelStop,
    USBAudioPnpStop,
    USBAudioPnpQueryRemove,
    USBAudioPnpCancelRemove,
    USBAudioPnpRemove,
    USBAudioPnpQueryCapabilities,
    USBAudioSurpriseRemoval,
    USBAudioQueryPower,
    USBAudioSetPower
};

const
KSDEVICE_DESCRIPTOR
USBAudioDeviceDescriptor =
{
    &USBAudioDeviceDispatch,
    0,
    NULL
};


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    NTSTATUS RetValue;

    _DbgPrintF(DEBUGLVL_TERSE,("[DriverEntry]\n\tUSBAudioDeviceDescriptor@%x\n\tUSBAudioDeviceDescriptor->Dispatch@%x\n",
                               &USBAudioDeviceDescriptor,
                               USBAudioDeviceDescriptor.Dispatch));

    RetValue = KsInitializeDriver(
        DriverObject,
        RegistryPathName,
        &USBAudioDeviceDescriptor);

    //
    // Insert a WMI event tracing handler.
    //
    
    PerfSystemControlDispatch = DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL];
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PerfWmiDispatch;

    return RetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       proto.h
//
//--------------------------------------------------------------------------

#ifndef _USBAUDIO_PROTO_H_
#define _USBAUDIO_PROTO_H_

// Device.c

NTSTATUS
USBAudioAddDevice( IN PKSDEVICE Device );

NTSTATUS
USBAudioPnpStart(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources
    );

NTSTATUS
USBAudioPnpQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioPnpQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioPnpQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES Capabilities
    );

void
USBAudioSurpriseRemoval(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioQueryPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action
    );

void
USBAudioSetPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From
    );

NTSTATUS
USBAudioDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBAudioGetUsbBusInterface(
    IN PKSDEVICE pKsDevice
    );

// Filter.c

NTSTATUS
USBAudioCreateFilterContext(
    PKSDEVICE pKsDevice
    );

// Pin.c

NTSTATUS
USBAudioPinBuildDescriptors(
    PKSDEVICE pKsDevice,
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx,
    PULONG pNumPins,
    PULONG pPinDecSize
    );

VOID
USBAudioPinWaitForStarvation(
    PKSPIN pKsPin
    );

VOID
USBMIDIOutPinWaitForStarvation(
    PKSPIN pKsPin
    );

VOID
USBAudioPinReturnFromStandby(
    PKSPIN pKsPin
    );

VOID
USBAudioPinGoToStandby(
    PKSPIN pKsPin );

// Property.c

NTSTATUS
GetSetByte(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType );

NTSTATUS
InitializeDbLevelCache(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount
    );

NTSTATUS
GetSetProcessingUnitEnable(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    PBOOL pEnable
    );

NTSTATUS
GetProcessingUnitRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulControl,
    ULONG ulCntrlSize,
    LONG  lScaleFactor,
    PKSPROPERTY_STEPPING_LONG pRange
    );

NTSTATUS
SetSampleRate(
    PKSPIN pKsPin,
    PULONG pSampleRate
    );

VOID
RestoreCachedSettings(
    PKSDEVICE pKsDevice
    );

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo
    );

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets
    );

VOID
BuildPinPropertySet(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPROPERTY_ITEM pStrmPropItems,
    PKSPROPERTY_SET pStrmPropSet,
    PULONG pNumItems,
    PULONG pNumSets
    );

NTSTATUS
DrmAudioStream_SetContentId(
    IN PIRP pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID pvData
    );

#ifdef RTAUDIO
NTSTATUS RtAudio_GetAudioPositionFunction(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PRTAUDIOGETPOSITION *pfnRtAudioGetPosition
    );
#endif

// Topology.c

NTSTATUS
BuildUSBAudioFilterTopology(
    PKSDEVICE pKsDevice
    );


// Hardware.c

NTSTATUS
USBAudioCancelCompleteSynch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pKevent
    );

NTSTATUS
SubmitUrbToUsbdSynch(
    PDEVICE_OBJECT pNextDeviceObject,
    PURB pUrb
    );

NTSTATUS
StartUSBAudioDevice(
    PKSDEVICE  pKsDevice
    );

NTSTATUS
StopUSBAudioDevice(
    PKSDEVICE pKsDevice
    );

NTSTATUS
SelectStreamingAudioInterface(
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin );

NTSTATUS
SelectStreamingMIDIInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin );

NTSTATUS
SelectZeroBandwidthInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulPinNumber );

NTSTATUS
ResetUSBPipe(
    PDEVICE_OBJECT pNextDeviceObject,
    USBD_PIPE_HANDLE hPipeHandle
    );

NTSTATUS
AbortUSBPipe(
    PPIN_CONTEXT pPinContext
    );

NTSTATUS
GetCurrentUSBFrame(
    IN PPIN_CONTEXT pPinContext,
    OUT PULONG pUSBFrame
    );


// ParseDsc.c
PUSB_INTERFACE_DESCRIPTOR
GetNextAudioInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor );

PUSB_INTERFACE_DESCRIPTOR
GetFirstAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber );

PAUDIO_SPECIFIC
GetAudioSpecificInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    LONG lDescriptorSubtype
    );

PUSB_ENDPOINT_DESCRIPTOR
GetEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    BOOLEAN fGetAudioSpecificEndpoint
    );


ULONG
GetMaxPacketSizeForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor
    );

BOOLEAN
IsZeroBWInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor
    );

ULONG
CountTerminalUnits(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pAudioBridgePinCount,
    PULONG pMIDIPinCount,
    PULONG pMIDIBridgePinCount
    );

ULONG
CountFormatsForAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber
    );

ULONG
CountInputChannels(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitID
    );

VOID
CountTopologyComponents(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories
    );

KSPIN_DATAFLOW
GetDataFlowDirectionForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber
    );

KSPIN_DATAFLOW
GetDataFlowDirectionForMIDIInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulPinNumber,
    BOOL fBridgePin
    );

ULONG
GetPinDataRangesFromInterface(
    ULONG ulInterfaceNumber,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PKSDATARANGE_AUDIO *ppKsAudioRange,
    PUSBAUDIO_DATARANGE pKsAudioRange
    );

BOOL
IsBridgePinDigital(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber);

VOID
GetCategoryForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID
    );

KSPIN_DATAFLOW
GetDataFlowForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber
    );

LONG
GetPinNumberForStreamingTerminalUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulTerminalNumber
    );

LONG
GetPinNumberForMIDIJack(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulJackID,
    ULONG pMIDIStreamingPinStartIndex,
    ULONG pBridgePinStartIndex);

ULONG
GetChannelConfigForUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitNumber
    );

UCHAR
GetUnitControlInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    UCHAR bUnitId
    );

PUSBAUDIO_DATARANGE
GetUsbDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PUSBAUDIO_DATARANGE pUsbDataRange,
    ULONG ulUsbDataRangeCnt
    );

BOOLEAN
IsSampleRateInRange(
    PVOID pAudioDescriptor,
    ULONG ulSampleRate,
    ULONG ulFormatType
    );

VOID
GetContextForMIDIPin
(
    PKSPIN pKsPin,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PMIDI_PIN_CONTEXT pMIDIPinContext
);

// TypeI.c
NTSTATUS
RtAudioTypeIGetPlayPosition(
    IN PFILE_OBJECT PinFileObject,
    OUT PUCHAR *ppPlayPosition,
    OUT PLONG plOffset
    );

NTSTATUS
TypeIRenderBytePosition(
    PPIN_CONTEXT pPinContext,
    PKSAUDIO_POSITION pPosition
    );


NTSTATUS
TypeIRenderStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
TypeIProcessStreamPtr(
    PKSPIN pKsPin
    );


NTSTATUS
TypeIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
TypeIRenderStreamClose(
    PKSPIN pKsPin
    );

// TypeII.c

NTSTATUS
TypeIIRenderStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
TypeIIProcessStreamPtr(
    PKSPIN pKsPin
    );


NTSTATUS
TypeIIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
TypeIIRenderStreamClose(
    PKSPIN pKsPin
    );

// Capture.c

NTSTATUS
CaptureBytePosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition
    );

NTSTATUS
CaptureStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
CaptureProcess(
    PKSPIN pKsPin
    );

NTSTATUS
CaptureStartIsocTransfer(
    PPIN_CONTEXT pPinContext
    );

NTSTATUS
CaptureStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
CaptureStreamClose(
     PKSPIN pKsPin
     );

// Intrsect.c
ULONG
GetIntersectFormatSize(
    PUSBAUDIO_DATARANGE pAudioDataRange
    );

ULONG
ConvertDatarangeToFormat(
    PUSBAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat
    );


PUSBAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PUSBAUDIO_DATARANGE *ppUSBAudioRanges,
    ULONG ulAudioRangeCount
    );

// midiout.c
NTSTATUS
SendBulkMIDIRequest(
    IN PKSSTREAM_POINTER pKsPin,
    PKSMUSICFORMAT MusicHdr,
    PULONG pulBytesConsumed
    );

NTSTATUS
USBMIDIOutProcessStreamPtr(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIOutStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
USBMIDIOutStreamInit(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIOutStreamClose(
    PKSPIN pKsPin
    );

// midiin.c
NTSTATUS
USBMIDIInCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo
    );

NTSTATUS
USBMIDIInFreePipeInfo(
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo
    );

NTSTATUS
USBMIDIInStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
USBMIDIInProcessStreamPtr(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIInStreamInit(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIInStreamClose(
    PKSPIN pKsPin
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\usbaudio.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       usbaudio.h
//
//--------------------------------------------------------------------------

#ifndef _USBAUDIO_H_
#define _USBAUDIO_H_

#define USBAUDIO_POOLTAG 'ABSU'

#define MAX_ULONG  ((ULONG) -1)

static const WCHAR MediaCategories[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\";
static const WCHAR NodeNameValue[] =   L"Name";

//
// Structure forward declarations.
//
typedef struct _MIDI_PIPE_INFORMATION
MIDI_PIPE_INFORMATION, *PMIDI_PIPE_INFORMATION;
typedef struct _HW_DEVICE_EXTENSION
HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


// Cached Values for DB Level Controls
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} DB_LEVEL_CACHE, *PDB_LEVEL_CACHE;

// Structure to Cache channel based Boolean control values
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    BOOL fLastValueSet;
} BOOLEAN_CTRL_CACHE, *PBOOLEAN_CTRL_CACHE;

// Cached Values for Processing Unit Node ranges
typedef struct {
    ULONG ulControlBit;
    ULONG ulControlSelector;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} PROCESS_CTRL_RANGE, *PPROCESS_CTRL_RANGE;

// Cached Values for Processing Unit Node controls
typedef struct {
    BOOL fEnableBit;
    BOOL fEnabled;
    ULONG bmControlBitMap;
} PROCESS_CTRL_CACHE, *PPROCESS_CTRL_CACHE;

// Information about each Topology node
typedef struct _TOPOLOGY_NODE_INFO {
    KSNODE_DESCRIPTOR KsNodeDesc;         // 3 Long Words
    KSAUTOMATION_TABLE KsAutomationTable; // 9 Long Words
    PVOID pUnit;
    UCHAR MapNodeToCtrlIF;
    ULONG ulNodeType;
    ULONG fBypassFlag; // Flag is set if the node can be bypassed.
    union {
        ULONG ulControlType;
        ULONG ulPinNumber;
    };
    ULONG ulChannelConfig;
    ULONG ulChannels;
    ULONG ulCacheValid;
    ULONG ulNumCachedValues;
    PVOID pCachedValues;
} TOPOLOGY_NODE_INFO, *PTOPOLOGY_NODE_INFO;

// DataRange Structures to associate Interfaces with Datarange
typedef struct _USBAUDIO_DATARANGE {

    KSDATARANGE_AUDIO KsDataRangeAudio;

    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;

    PAUDIO_CLASS_STREAM pAudioDescriptor;

    PAUDIO_ENDPOINT_DESCRIPTOR pAudioEndpointDescriptor;

    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;

    PUSB_ENDPOINT_DESCRIPTOR pSyncEndpointDescriptor;

    PAUDIO_UNIT pTerminalUnit;

    ULONG ulChannelConfig;

    ULONG ulUsbDataFormat;

    ULONG ulMaxSampleRate;

} USBAUDIO_DATARANGE, *PUSBAUDIO_DATARANGE;

// SubContext for Type I render pins
typedef struct {
    LIST_ENTRY List;
    ULONG ulTransferBufferLength;
    PURB   pUrb;
} ISO_URB_INFO, *PISO_URB_INFO;

typedef struct {
    ISO_URB_INFO;
    PIRP   pIrp;
    PKSPIN pKsPin;
    PUCHAR pBuffer;
    PVOID  pContext;
} MSEC_BUF_INFO, *PMSEC_BUF_INFO, TYPE2_BUF_INFO, *PTYPE2_BUF_INFO;

#define SYNC_ENDPOINT_DATA_SIZE 3

typedef struct _SYNC_ENDPOINT_INFO {
    PURB pUrb;
    PIRP pIrp;
    PVOID pContext;
    ULONG ulNextPollFrame;
    ULONG ulRefreshRate;
    ULONG fSyncRequestInProgress;
    USBD_PIPE_HANDLE hSyncPipeHandle;
    UCHAR Buffer[SYNC_ENDPOINT_DATA_SIZE];
    UCHAR Rsvd;
    KEVENT SyncPollDoneEvent;
} SYNC_ENDPOINT_INFO, *PSYNC_ENDPOINT_INFO;

#define NUM_1MSEC_BUFFERS 12

typedef struct _TYPE1_PIN_CONTEXT {
    ULONG ulCurrentSampleRate;
    ULONG ulOriginalSampleRate;
    ULONG ulLeftoverFraction;
    ULONG ulSamplesPerPacket;
    ULONG ulBytesPerSample;
    ULONG ulFractionSize;
    ULONG ulPartialBufferSize;
    ULONG fSampleRateChanged;
    ULONG fLockDelayRequired;
    LIST_ENTRY MSecBufList;
    KSEMAPHORE MsecBufferSemaphore;
    MSEC_BUF_INFO MSBufInfos[NUM_1MSEC_BUFFERS];
    LIST_ENTRY UrbInUseList;
    SYNC_ENDPOINT_INFO SyncEndpointInfo;
} TYPE1_PIN_CONTEXT, *PTYPE1_PIN_CONTEXT;

// SubContext for Capture pins
#define CAPTURE_URBS_PER_PIN      8

typedef struct _CAPTURE_DATA_BUFFER_INFO {
    LIST_ENTRY List;
    PKSPIN pKsPin;
    PIRP   pIrp;
    PURB   pUrb;
    PUCHAR pData;
} CAPTURE_DATA_BUFFER_INFO, *PCAPTURE_DATA_BUFFER_INFO;

typedef struct _CAPTURE_PIN_CONTEXT {
    ULONG fRunning;
    ULONG fProcessing;
    ULONG fDataDiscontinuity;
    ULONG ulAvgBytesPerSec;
    ULONG ulCurrentSampleRate;
    ULONG ulBytesPerSample;
    ULONG ulIsochBuffer;
    ULONG ulIsochBufferOffset;
    ULONG ulErrantPackets;
    LIST_ENTRY UrbErrorQueue;
    LIST_ENTRY FullBufferQueue;
    LIST_ENTRY OutstandingUrbQueue;
    PKSWORKER GateOnWorkerObject;
    WORK_QUEUE_ITEM GateOnWorkItem;
    PKSWORKER ResetWorkerObject;
    WORK_QUEUE_ITEM ResetWorkItem;
    PKSWORKER RequeueWorkerObject;
    WORK_QUEUE_ITEM RequeueWorkItem;
    KMUTEX CaptureInitMutex;
    PCAPTURE_DATA_BUFFER_INFO pCaptureBufferInUse;
    CAPTURE_DATA_BUFFER_INFO CaptureDataBufferInfo[CAPTURE_URBS_PER_PIN];
} CAPTURE_PIN_CONTEXT, *PCAPTURE_PIN_CONTEXT;

// SubContext for Type II render pins
#define NUM_T2_BUFFERS  32

typedef struct _TYPE2_PIN_CONTEXT {
    ULONG ulMaxPacketsPerFrame;
    ULONG ulPartialBufferSize;
    LIST_ENTRY Type2BufferList;
    TYPE2_BUF_INFO Type2Buffers[NUM_T2_BUFFERS];
} TYPE2_PIN_CONTEXT, *PTYPE2_PIN_CONTEXT;

#define MAX_NUM_CACHED_MIDI_BYTES 2

typedef struct _MIDIOUT_PIN_CONTEXT {
    ULONG   ulBytesCached;
    KEVENT  PinSaturationEvent;
    BYTE    CachedBytes[MAX_NUM_CACHED_MIDI_BYTES];
    BYTE    bRunningStatus;
} MIDIOUT_PIN_CONTEXT, *PMIDIOUT_PIN_CONTEXT;

typedef union _USBMIDIEVENTPACKET {
    struct {
        BYTE   CodeIndexNumber : 4;
        BYTE   CableNumber : 4;
        BYTE   MIDI_0;
        BYTE   MIDI_1;
        BYTE   MIDI_2;
    } ByteLayout;

    ULONG RawBytes;
} USBMIDIEVENTPACKET, *PUSBMIDIEVENTPACKET;

typedef struct _MIDIIN_URB_BUFFER_INFO {
    LIST_ENTRY  List;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PKSPIN      pKsPin;
    PIRP        pIrp;
    PURB        pUrb;
    PUCHAR      pData;
    ULONGLONG   ullTimeStamp;
} MIDIIN_URB_BUFFER_INFO, *PMIDIIN_URB_BUFFER_INFO;

typedef struct _MIDIIN_USBMIDIEVENT_INFO {
    LIST_ENTRY          List;
    USBMIDIEVENTPACKET  USBMIDIEvent;
    ULONGLONG           ullTimeStamp;
} MIDIIN_USBMIDIEVENT_INFO, *PMIDIIN_USBMIDIEVENT_INFO;

#define MIDIIN_EVENTS_PER_PIN  1024
//#define MIDIIN_EVENTS_PER_PIN  32

typedef struct _MIDIIN_PIN_CONTEXT {
    ULONG fRunning;
    ULONG fProcessing;
    ULONG ulMIDIBytesCopiedToStream;
    ULONGLONG ullStartTime;
    ULONGLONG ullPauseTime;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PKSWORKER GateOnWorkerObject;
    WORK_QUEUE_ITEM GateOnWorkItem;

    LIST_ENTRY USBMIDIEventQueue;
    LIST_ENTRY USBMIDIEmptyEventQueue;
    MIDIIN_USBMIDIEVENT_INFO USBMIDIEventInfo[MIDIIN_EVENTS_PER_PIN];
} MIDIIN_PIN_CONTEXT, *PMIDIIN_PIN_CONTEXT;

typedef struct _MIDI_PIN_CONTEXT {
    ULONG ulJackID;
    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;
    ULONG ulCableNumber;
    union {
        PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext;
        PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    };
} MIDI_PIN_CONTEXT, *PMIDI_PIN_CONTEXT;

typedef enum {
    WaveOut,
    WaveIn,
    MidiOut,
    MidiIn
} PINTYPE;

// Context for each opened pin
typedef struct _PIN_CONTEXT {

    PHW_DEVICE_EXTENSION pHwDevExt;

    PDEVICE_OBJECT pNextDeviceObject;

    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    PINTYPE PinType;

    ULONG ulMaxPacketSize;

    ULONG ulOutstandingUrbCount;

    ULONG fUrbError;

    ULONG ulNumberOfPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;

    // DRM
    ULONG DrmContentId;

    union {
        PTYPE1_PIN_CONTEXT   pType1PinContext;
        PTYPE2_PIN_CONTEXT   pType2PinContext;
        PCAPTURE_PIN_CONTEXT pCapturePinContext;
        PMIDI_PIN_CONTEXT    pMIDIPinContext;
    };

    ULONG fStreamStartedFlag;
    ULONG ulStreamUSBStartFrame;

    ULONGLONG ullWriteOffset;
    ULONGLONG ullTotalBytesReturned;
    ULONG ulCurrentFrame;
    ULONG ulFrameRepeatCount;
    
    KSPIN_LOCK PinSpinLock;

    KEVENT PinStarvationEvent;

    HANDLE hSystemStateHandle;

    BOOLEAN StarvationDetected;
    LONGLONG LastStateChangeTimeSample;
    BOOLEAN GraphJustStarted;

} PIN_CONTEXT, *PPIN_CONTEXT;

typedef struct _MIDIIN_PIN_LISTENTRY {
    LIST_ENTRY  List;
    PKSPIN      pKsPin;
    PVOID       pContext;
} MIDIIN_PIN_LISTENTRY, *PMIDIIN_PIN_LISTENTRY;

#define MIDIIN_URBS_PER_PIPE       256
//#define MIDIIN_URBS_PER_PIPE       32

typedef struct _MIDI_PIPE_INFORMATION {
    PHW_DEVICE_EXTENSION pHwDevExt;
    PDEVICE_OBJECT pNextDeviceObject;

    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;

    BOOL fRunning;
    ULONG ulOutstandingUrbCount;
    KEVENT PipeStarvationEvent;

    ULONG fUrbError;

    ULONG ulNumberOfPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;
    ULONG ulMaxPacketSize;

    PKSWORKER RequeueUrbWorkerObject;
    WORK_QUEUE_ITEM RequeueUrbWorkItem;
    LIST_ENTRY EmptyBufferQueue;
    PMIDIIN_URB_BUFFER_INFO pCaptureBufferInUse;
    MIDIIN_URB_BUFFER_INFO CaptureDataBufferInfo[MIDIIN_URBS_PER_PIPE];

    KSPIN_LOCK PipeSpinLock;
    LIST_ENTRY MIDIInActivePinList;
} MIDI_PIPE_INFORMATION, *PMIDI_PIPE_INFORMATION;

typedef struct _PIN_CINSTANCES
{
    ULONG   PossibleCount;
    ULONG   CurrentCount;
}
PIN_CINSTANCES, *PPIN_CINSTANCES;

// Hardware device extension
typedef struct _HW_DEVICE_EXTENSION {

    ULONG fDeviceStopped;

    PDEVICE_OBJECT pNextDeviceObject;

    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;

    KSFILTER_DESCRIPTOR USBAudioFilterDescriptor;

    PUSBD_INTERFACE_LIST_ENTRY pInterfaceList;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    BOOL fDigitalOutput;

    PUSB_BUS_INTERFACE_USBDI_V0 pBusIf;

    PPIN_CINSTANCES pPinInstances;  // array of pin instances

    ULONG ulInterfaceNumberSelected;
    ULONG ulNumberOfMIDIPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;

    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

// Context for the device filter
typedef struct _FILTER_CONTEXT {

    PHW_DEVICE_EXTENSION pHwDevExt;

    PDEVICE_OBJECT pNextDeviceObject;

} FILTER_CONTEXT, *PFILTER_CONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drivers\usbaudio.2\typeii.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       typeii.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define FRAME_START_NOT_FOUND     0x80000000
#define NUM_AC3_SAMPLERATE_CODES  3
#define NUM_AC3_FRAMESIZE_CODES   38
#define MAX_SYNCFRAME_SIZE        1920<<1

ULONG AC3FrameSizeLookupTable[NUM_AC3_FRAMESIZE_CODES][NUM_AC3_SAMPLERATE_CODES] =
    { {   64,   69,   96 },
      {   64,   70,   96 },
      {   80,   87,  120 },
      {   80,   88,  120 },
      {   96,  104,  144 },
      {   96,  105,  144 },
      {  112,  121,  168 },
      {  112,  122,  168 },
      {  128,  139,  192 },
      {  128,  140,  192 },
      {  160,  174,  240 },
      {  160,  175,  240 },
      {  192,  208,  288 },
      {  192,  209,  288 },
      {  224,  243,  336 },
      {  224,  244,  336 },
      {  256,  278,  384 },
      {  256,  279,  384 },
      {  320,  348,  480 },
      {  320,  349,  480 },
      {  384,  417,  576 },
      {  384,  418,  576 },
      {  448,  487,  672 },
      {  448,  488,  672 },
      {  512,  557,  768 },
      {  512,  558,  768 },
      {  640,  696,  960 },
      {  640,  697,  960 },
      {  768,  835, 1152 },
      {  768,  836, 1152 },
      {  896,  975, 1344 },
      {  896,  976, 1344 },
      { 1024, 1114, 1536 },
      { 1024, 1115, 1536 },
      { 1152, 1253, 1728 },
      { 1152, 1254, 1728 },
      { 1280, 1393, 1920 },
      { 1280, 1394, 1920 } };



static ULONG
AC3FindFrameStart(
    PUCHAR pData,
    ULONG DataUsed,
    ULONG ulCurrentOffset )
{
    ULONG i = ulCurrentOffset;

    while ( i < (DataUsed-1) ) {
        if ( pData[i] == 0x0b ) {
            if ( pData[i+1] == 0x77 )
                return i;
        }
        else if ( pData[i] == 0x77 ) {
            if ( pData[i+1] == 0x0b )
                return i;
        }
        i++;
    }
    return FRAME_START_NOT_FOUND;
}

static ULONG
AC3GetFrameSize( PUCHAR pData )
{
    UCHAR FrameSizeCode;
    ULONG FrameSizeCodeOffset = 4;

    if ( pData[0] == 0x77 ) FrameSizeCodeOffset++;

    FrameSizeCode = pData[FrameSizeCodeOffset];

    DbgLog("T2FrmSi", pData, FrameSizeCode, FrameSizeCodeOffset, 0 );

    ASSERT( ((ULONG)(FrameSizeCode & 0x3F) < NUM_AC3_FRAMESIZE_CODES ) &&
            ((ULONG)((FrameSizeCode & 0xC0)>>6) < NUM_AC3_SAMPLERATE_CODES ) );

    // Sizes are word size double for byte
    return AC3FrameSizeLookupTable[(ULONG)(FrameSizeCode & 0x3F)]
                                  [(ULONG)((FrameSizeCode & 0xC0)>>6)] * 2;
}

ULONG
TypeIIGetFrameSize(
    IN PKSPIN pKsPin,
    PUCHAR pData,
    PUCHAR pBufData,
    ULONG ulPartialBufferSize )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFrameSize = 0;

    switch( pUsbAudioDataRange->ulUsbDataFormat ) {
        case USBAUDIO_DATA_FORMAT_AC3:
            if (ulPartialBufferSize >= 5) { 
                ulFrameSize = AC3GetFrameSize( pBufData );
            }
            else if (ulPartialBufferSize) {
                RtlCopyMemory(pBufData+ulPartialBufferSize, pData, 8-ulPartialBufferSize);
                ulFrameSize = AC3GetFrameSize( pBufData );
            }
            else
                ulFrameSize = AC3GetFrameSize( pData );

            break;
        case USBAUDIO_DATA_FORMAT_MPEG:
        default:
            TRAP;
            break;
    }

    return ulFrameSize;
}

NTSTATUS
TypeIIProcessCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PTYPE2_BUF_INFO pT2BufInfo )
{
    PKSPIN pKsPin = pT2BufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PKSSTREAM_POINTER pKsStreamPtr = pT2BufInfo->pContext;
    PURB pUrb = pT2BufInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL irql;

    ntStatus = pIrp->IoStatus.Status;

    DbgLog("T2PcCbk", pKsPin, pPinContext, pType2PinContext, pT2BufInfo );

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
    }

    if ( pKsStreamPtr ) {
        // If error, set status code
        if (!NT_SUCCESS (ntStatus)) {
            KsStreamPointerSetStatusCode (pKsStreamPtr, ntStatus);
        }

        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pKsStreamPtr );
        pT2BufInfo->pContext = NULL;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    if ( IsListEmpty(&pType2PinContext->Type2BufferList) ) {
        InsertTailList(&pType2PinContext->Type2BufferList, &pT2BufInfo->List);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KsPinAttemptProcessing( pKsPin, FALSE );
    }
    else {
        InsertTailList(&pType2PinContext->Type2BufferList, &pT2BufInfo->List);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
TypeIIBuildIsochRequest(
    PKSPIN pKsPin,
    PTYPE2_BUF_INFO pT2BufInfo,
    ULONG ulCurrentFrameSize)
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    ULONG ulNumberOfPackets = pType2PinContext->ulMaxPacketsPerFrame;
    ULONG ulNumDataPackets  = (ulCurrentFrameSize / pPinContext->ulMaxPacketSize) +
                             ((ulCurrentFrameSize % pPinContext->ulMaxPacketSize) > 0);
    ULONG ulUrbSize = GET_ISO_URB_SIZE(ulNumberOfPackets);
    PIO_STACK_LOCATION nextStack;
    PURB pUrb = pT2BufInfo->pUrb;
    PIRP pIrp = pT2BufInfo->pIrp;
    KIRQL irql;
    ULONG i,j;

    DbgLog("T2BldRq", pKsPin, pPinContext, pType2PinContext, pT2BufInfo );

    RtlZeroMemory(pUrb, ulUrbSize);

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)ulUrbSize;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = ulNumberOfPackets;
    pUrb->UrbIsochronousTransfer.TransferBuffer  = pT2BufInfo->pBuffer;

    // While frame data incomplete fill packets with data
    for (i=0;i<ulNumDataPackets;i++) {
            pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset =
                                          i * pPinContext->ulMaxPacketSize;
    }

    // Complete the Urb with NULL packets as per USB spec.
    for(j=0 ;i<ulNumberOfPackets;i++,j++ ) {
//        pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset = ulCurrentFrameSize+j;
        pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset = ulCurrentFrameSize;
    }

//    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulCurrentFrameSize+j;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulCurrentFrameSize;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine( pIrp, TypeIIProcessCallback, pT2BufInfo, TRUE, TRUE, TRUE ) ;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return IoCallDriver(pPinContext->pNextDeviceObject, pIrp);
}

NTSTATUS
TypeIIProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PTYPE2_BUF_INFO pT2BufInfo;
    PUCHAR pBufData, pData;
    ULONG ulCurrentFrameSize;
    ULONG ulCopySize;
    NTSTATUS ntStatus;
    KIRQL irql;

    DbgLog("T2Proc0", pKsPin, pPinContext, pType2PinContext, 0 );

    // Check for a data error. If error flag set abort the pipe and start again.
    if ( pPinContext->fUrbError ) {
        AbortUSBPipe( pPinContext );
    }

    // Get the next stream pointer from the queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[TypeIIProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    DbgLog("T2Proc1", pKsPin, pPinContext, pType2PinContext, pKsStreamPtr );

    _DbgPrintF(DEBUGLVL_VERBOSE, ("'TypeIIProcess: pKsPin: %x pKsStreamPtr: %x\n",pKsPin,pKsStreamPtr) );

    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
    pData = pKsStreamPtrOffsetIn->Data;

    // ISSUE-2001/01/10-dsisolak Need to make sure this is a data buffer and not a data format change.
    if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM ) {
        if ( !pData ) {
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );
            return STATUS_SUCCESS;
        }
    }
    else if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
        TRAP;
        // Need to change data formats if possible???.
    }


    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

    // While there is data available and data buffers to put it in fill 'em up
    while ( pKsStreamPtr && !IsListEmpty(&pType2PinContext->Type2BufferList ) ) {
        pT2BufInfo = (PTYPE2_BUF_INFO)pType2PinContext->Type2BufferList.Flink;
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        pBufData = pT2BufInfo->pBuffer;

        _DbgPrintF(DEBUGLVL_VERBOSE, ("'pData; %x pBuf %x PartialBufferSize: %d\n",
                              pData, pBufData, pType2PinContext->ulPartialBufferSize) );

        ulCurrentFrameSize = TypeIIGetFrameSize( pKsPin,
                                                 pData,
                                                 pBufData,
                                                 pType2PinContext->ulPartialBufferSize );

        ulCopySize = ulCurrentFrameSize - pType2PinContext->ulPartialBufferSize;
        if ( ulCopySize >= pKsStreamPtrOffsetIn->Remaining )
            ulCopySize = pKsStreamPtrOffsetIn->Remaining;

        RtlCopyMemory( pBufData+pType2PinContext->ulPartialBufferSize,
                       pData,
                       ulCopySize );

        pType2PinContext->ulPartialBufferSize += ulCopySize;

        if ( ulCopySize == pKsStreamPtrOffsetIn->Remaining ) {

            // Clone pointer and discard this one
            if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {
                pT2BufInfo->pContext = pKsCloneStreamPtr;
                // Unlock the stream pointer. This will really only unlock after last clone is deleted.
                KsStreamPointerUnlock( pKsStreamPtr, TRUE );
                pKsStreamPtr =
                   KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
                _DbgPrintF(DEBUGLVL_VERBOSE, ("'TypeIIProcess: pKsStreamPtr: %x\n",pKsStreamPtr) );
                if ( pKsStreamPtr ) {
                    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
                    pData = pKsStreamPtrOffsetIn->Data;
                }
            }
        }
        else {
            // Update remaining count in stream pointer
            KsStreamPointerAdvanceOffsets( pKsStreamPtr, ulCopySize, 0, FALSE );
            pData = pKsStreamPtrOffsetIn->Data;
        }

        // If the frame is complete submit the URB
        if ( pType2PinContext->ulPartialBufferSize == ulCurrentFrameSize ) {
            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
            pT2BufInfo = (PTYPE2_BUF_INFO)RemoveHeadList(&pType2PinContext->Type2BufferList);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            pType2PinContext->ulPartialBufferSize = 0;
            ntStatus = TypeIIBuildIsochRequest(pKsPin, pT2BufInfo, ulCurrentFrameSize);
        }

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    if (pKsStreamPtr) {
        KsStreamPointerUnlock( pKsStreamPtr, FALSE );
        ntStatus = STATUS_PENDING;
    }
    else
        ntStatus = STATUS_SUCCESS;

    return ntStatus;
}

VOID
TypeIIWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PTYPE2_BUF_INFO pT2BufInfo;
    KIRQL irql;

    DbgLog("T2Strv1", pKsPin, pPinContext, pType2PinContext, 0 );

    USBAudioPinWaitForStarvation( pKsPin );

    DbgLog("T2Strv2", pKsPin, pPinContext, pType2PinContext, 0 );

    // Once we've starved make sure there are no outstanding Clone Stream Pointers.
    pT2BufInfo = (PTYPE2_BUF_INFO)pType2PinContext->Type2BufferList.Flink;
    while (pT2BufInfo != (PTYPE2_BUF_INFO)&pType2PinContext->Type2BufferList) {
        if (pT2BufInfo->pContext) {
            KsStreamPointerDelete( (PKSSTREAM_POINTER)pT2BufInfo->pContext );
            pT2BufInfo->pContext = NULL;
            
        }
        pT2BufInfo = (PTYPE2_BUF_INFO)pT2BufInfo->List.Flink;
    }
}

NTSTATUS
TypeIIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;

    DbgLog("T2State", pKsPin, pPinContext, OldKsState, NewKsState );

    switch(NewKsState) {
        case KSSTATE_STOP:
            // Need to wait until outstanding Urbs complete
            TypeIIWaitForStarvation( pKsPin );

            pType2PinContext->ulPartialBufferSize  = 0;
        default:
            break;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
TypeIIRenderStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext;
    PUCHAR pFrameBuffer;
    PURB pUrbs;
    ULONG i;

    ULONG ulMaxPacketsPerFrame = 32; // NOTE: Assuming AC-3 for now
    ULONG ulUrbSize = GET_ISO_URB_SIZE( ulMaxPacketsPerFrame );

    pType2PinContext = pPinContext->pType2PinContext =
            AllocMem( NonPagedPool, sizeof(TYPE2_PIN_CONTEXT) +
                                    (NUM_T2_BUFFERS * ( ulUrbSize +
                                                      ( ulMaxPacketsPerFrame * pPinContext->ulMaxPacketSize ))));
    if ( !pType2PinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the Type2 context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pType2PinContext, FreeMem);

    // Set pointers for URBs and Data Buffers
    pUrbs = (PURB)(pType2PinContext + 1);

    pFrameBuffer = (PUCHAR)pUrbs + ( ulUrbSize * NUM_T2_BUFFERS );

    RtlZeroMemory( pFrameBuffer, NUM_T2_BUFFERS *
                                 pPinContext->ulMaxPacketSize * ulMaxPacketsPerFrame );

    // Initialize Buffer info structure list
    InitializeListHead( &pType2PinContext->Type2BufferList );

    // Save Max Packets Per Frame Value
    pType2PinContext->ulMaxPacketsPerFrame = ulMaxPacketsPerFrame;

    // Initialize Buffer info structures
    for ( i=0; i<NUM_T2_BUFFERS; i++ ) {
        InsertHeadList( &pType2PinContext->Type2BufferList,
                        &pType2PinContext->Type2Buffers[i].List );
        pType2PinContext->Type2Buffers[i].pKsPin   = pKsPin;
        pType2PinContext->Type2Buffers[i].pContext = NULL;
        pType2PinContext->Type2Buffers[i].pBuffer  = &pFrameBuffer[i * pPinContext->ulMaxPacketSize *
                                                                  ulMaxPacketsPerFrame];
        pType2PinContext->Type2Buffers[i].pUrb = (PURB)((PUCHAR)pUrbs + (i*ulUrbSize));
        pType2PinContext->Type2Buffers[i].pIrp =
                  IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pType2PinContext->Type2Buffers[i].pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // Bag the irps for easy cleanup.
        KsAddItemToObjectBag(pKsPin->Bag, pType2PinContext->Type2Buffers[i].pIrp, IoFreeIrp);
    }

    // Initialize misc. info fields
    pType2PinContext->ulPartialBufferSize  = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
TypeIIRenderStreamClose( PKSPIN pKsPin )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\cryptk\bv4.cpp ===
/* Microsoft Corporation (C) 2000 */

#include "crptkPCH.h"
#include "bv4.h"

void bv4_key_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf)
{
    if (pState == NULL)
    {
        return; // Too bad we return void.
    }
    int keyLength = dwLen;
    BYTE *key = buf;
    
    DWORD i;
    
    for (i = 0; i < 256; i++) 
    {
        pState->p_T[i] = (unsigned char)i;
    }
    
    // fill k with the key, repeated as many times as necessary 
    // to fill the entire array;
    DWORD k[256];  // contains only 8-bit values zero-extended to 32 bits.
    int keyPos = 0;
    for (i = 0; i < 256; i++) 
    {
        if (keyPos >= keyLength) 
        {
            keyPos = 0;
        }
        k[i] = key[keyPos++];
    }
    
    DWORD j = 0;
    for (i = 0; i < 256; i++) 
    {
        j = (j + pState->p_T[i] + k[i]) & 0xff;
        DWORD tmp = pState->p_T[i];
        pState->p_T[i] = pState->p_T[j];
        pState->p_T[j] = (unsigned char)tmp;
    }
    
    // treat alpha and beta as one contiguous array of 33 4-byte blocks.
    // see "Applied Cryptography", 1996, by Bruce Schneier, p. 397.
    
    i = 0;
    j = 0;
    for (int m = 0; m < 33; m++) 
    {
        DWORD nextDword = 0;
        // gather up the next 4 bytes of keys into one DWORD
        for (int n = 0; n < 4; n++) 
        {
          i = (i+1) & 0xff;
          DWORD ti = pState->p_T[i];
          j = (j+ti) & 0xff;
          // swap T[i] and T[j];
          DWORD tj = pState->p_T[j];
          pState->p_T[i] = (unsigned char)tj;
          pState->p_T[j] = (unsigned char)ti;
          DWORD t = (ti+tj) & 0xff;
          DWORD kk = pState->p_T[t];
          nextDword |= kk << (n*8);
        }
        if (m == 0) 
        {
            pState->p_alpha = nextDword;
        } 
        else 
        {
            pState->p_beta[m-1] = nextDword;
        }
    }
    
    // keep the final state as the state we need for the new algorithm.
    // T has already been updated.
    pState->p_R = (unsigned char)i;
    pState->p_S = (unsigned char)j;
}

// cipher: generate a stream of 32-bit keys and xor them with the
// contents of buffer.   This can be used to encrypt/decrypt 
// a stream of data.
void bv4_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf)
{
    if (pState == NULL)
    {
        return; // Too bad we return void.
    }
    DWORD *buffer = (DWORD *)buf;
    DWORD bufferLength = dwLen / sizeof(DWORD);
    
    DWORD *last = buffer + bufferLength;

    // load field values into local variables
    // the following change on every iteration of the loop
    DWORD r = pState->p_R;
    DWORD s = pState->p_S;
    DWORD alpha = pState->p_alpha;


    // the following are loop invariant
    unsigned char *t = pState->p_T;
    DWORD *beta = pState->p_beta;

    for (last = buffer + bufferLength; buffer < last; buffer++) 
    {
      r = (r+1) & 0xff;
      DWORD tr = t[r];
      s = (s+tr) & 0xff;
      DWORD ts = t[s];
      t[r] = (unsigned char)ts;
      t[s] = (unsigned char)tr;
      DWORD tmp = (ts+tr) & 0xff;
      DWORD randPad = alpha * t[tmp];
      *buffer = randPad^(*buffer);
      alpha = alpha + beta[s & 0x1f];
    }

    // update the field values from the local variables
    pState->p_R = (unsigned char)r;
    pState->p_S = (unsigned char)s;
    pState->p_alpha = alpha;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\cryptk\crptkpch.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	cryptk.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "crptkPCH.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\cryptk\crptkpch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_cryptkPCH_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_)
#define AFX_cryptkPCH_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN		
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _KBLD
	#include "DRMKMain/drmkPCH.h"
#else
	#include "KRMProxy/krmpPCH.h"
#endif


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmk\audclass.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    audclass.cpp

Abstract:

    This module contains audio class code.

Author:

      Paul England (pengland) from the AUDIO.sys ks2 sample code

	  Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
DRMAudioIntersectHandlerInPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

/*++ 

  DRMK Routine description
  In-pin intersection handler accepts any WAVE_FORMAT_DRM format.  The output pin format
  is modified to correspond to the input pin DRM-encapsulated format.
  
--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMAudioIntersectHandler - IN]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Descriptor data range must be WAVEFORMATEX or DSOUND
    //
    ASSERT(IsEqualGUIDAligned(DescriptorDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
	   IsEqualGUIDAligned(DescriptorDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND      ));
	   
    PKSDATARANGE_AUDIO descriptorDataRange = PKSDATARANGE_AUDIO(DescriptorDataRange);

    //
    // Caller data range may be wildcard or WAVEFORMATEX or DSOUND
    //
    PKSDATARANGE_AUDIO callerDataRange;
    if (IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // WAVEFORMATEX or DSOUND.  Validate the specifier ranges.
        //
        ASSERT(IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
	       IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND      ));

        callerDataRange = PKSDATARANGE_AUDIO(CallerDataRange);

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_NO_MATCH"));
            return STATUS_NO_MATCH;
        }
    }

    SIZE_T cbDataFormat;
    if (!callerDataRange || IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        cbDataFormat = sizeof(KSDATAFORMAT_WAVEFORMATEX) + sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX);
    } else {
        ASSERT(IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_DSOUND));
        cbDataFormat = sizeof(KSDATAFORMAT_DSOUND) + sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX);
    }

    if (BufferSize == 0) {
        // Size query - return the size.
        *DataSize = (ULONG)cbDataFormat;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_BUFFER_OVERFLOW"));
        return STATUS_BUFFER_OVERFLOW;
    }

    PKSDATAFORMAT dataFormat = PKSDATAFORMAT(Data);
    ASSERT(dataFormat);

    if (BufferSize < cbDataFormat) {
        // Buffer is too small.
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_BUFFER_TOO_SMALL"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Gotta build the format.
    //
    *DataSize = (ULONG)cbDataFormat;

    RtlZeroMemory(dataFormat, cbDataFormat);

    PDRMWAVEFORMAT drmFormat;
    if (!callerDataRange || IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        drmFormat = (PDRMWAVEFORMAT)&PKSDATAFORMAT_WAVEFORMATEX(dataFormat)->WaveFormatEx;
    } else {
    	// Note dataFormat->BufferDesc.Flags and Control are memset to 0 above
        drmFormat = (PDRMWAVEFORMAT)&PKSDATAFORMAT_DSOUND(dataFormat)->BufferDesc.WaveFormatEx;
    }
    
    // First let's fill out the wfxSecure format based on the data intersection
    // Without more info, all we can do is propose PCM as the secure format
    drmFormat->wfxSecure.wFormatTag = WAVE_FORMAT_PCM;
    if (callerDataRange) {
        drmFormat->wfxSecure.nChannels      = (USHORT) min(callerDataRange->MaximumChannels,descriptorDataRange->MaximumChannels);
        drmFormat->wfxSecure.nSamplesPerSec = min(callerDataRange->MaximumSampleFrequency,descriptorDataRange->MaximumSampleFrequency);
        drmFormat->wfxSecure.wBitsPerSample = (USHORT) min(callerDataRange->MaximumBitsPerSample,descriptorDataRange->MaximumBitsPerSample);
    } else {
        drmFormat->wfxSecure.nChannels      = (USHORT) descriptorDataRange->MaximumChannels;
        drmFormat->wfxSecure.nSamplesPerSec = descriptorDataRange->MaximumSampleFrequency;
        drmFormat->wfxSecure.wBitsPerSample = (USHORT) descriptorDataRange->MaximumBitsPerSample;
    }
    drmFormat->wfxSecure.nBlockAlign     = (drmFormat->wfxSecure.wBitsPerSample * drmFormat->wfxSecure.nChannels) / 8;
    drmFormat->wfxSecure.nAvgBytesPerSec = drmFormat->wfxSecure.nBlockAlign * drmFormat->wfxSecure.nSamplesPerSec;
    drmFormat->wfxSecure.cbSize          = 0;

    // Now fill out the drm waveformat.  If we someday frame the scrambled data, then
    // we should update this to reflect the framing
    drmFormat->wfx.wFormatTag      = WAVE_FORMAT_DRM;
    drmFormat->wfx.nChannels       = drmFormat->wfxSecure.nChannels;
    drmFormat->wfx.nSamplesPerSec  = drmFormat->wfxSecure.nSamplesPerSec;
    drmFormat->wfx.wBitsPerSample  = drmFormat->wfxSecure.wBitsPerSample;
    drmFormat->wfx.nBlockAlign     = drmFormat->wfxSecure.nBlockAlign;
    drmFormat->wfx.nAvgBytesPerSec = drmFormat->wfxSecure.nAvgBytesPerSec;
    drmFormat->wfx.cbSize          = sizeof(*drmFormat) - sizeof(WAVEFORMATEX);

    // Now finish off some of the fields in the base KSDATAFORMAT_WAVE structure
    // Note all the guids are in the descriptor's data range.
    RtlCopyMemory(dataFormat,DescriptorDataRange,sizeof(*dataFormat));
    dataFormat->FormatSize = (ULONG)cbDataFormat;
    dataFormat->SampleSize = drmFormat->wfx.nBlockAlign;

   _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler(in)]  DONE OK\n"));
    return STATUS_SUCCESS;
}
//-------------------------------------------------------------------------------------
// OUT
NTSTATUS
DRMAudioIntersectHandlerOutPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

/*++ 

  DRMK Routine description
  Out-pin intersection handler specifies the exact encapsulated data format passed to the 
  input pin.
  
--*/
{

    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMAudioIntersectHandler]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    // Must negotiate InPin before OutPin
    PKSFILTER filter = (PKSFILTER) Filter;
    FilterInstance* instance=(FilterInstance*) filter->Context;
    if (!KsFilterGetFirstChildPin(filter,PIN_ID_INPUT)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT Must connect IN before OUT]  -  STATUS_NO_MATCH"));
        return STATUS_NO_MATCH;
    };

    //
    // If we edited the output data range properly, then KS should not
    // ask us to intersect a specifier that doesn't match our required
    // output format specifier
    //
    ASSERT(IsEqualGUIDAligned(DescriptorDataRange->Specifier,instance->OutDataFormat->Specifier));
    PKSDATARANGE_AUDIO descriptorDataRange = PKSDATARANGE_AUDIO(DescriptorDataRange);

    //
    // Caller data range may be wildcard or WAVEFORMATEX or DSOUND
    //
    PKSDATARANGE_AUDIO callerDataRange;
    if (IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // Not a wild card, so KS should not ask us to intersect a specifier that
        // does not match our required output format specifier (is this true)?
        //
        ASSERT(IsEqualGUIDAligned(CallerDataRange->Specifier,instance->OutDataFormat->Specifier));

        callerDataRange = PKSDATARANGE_AUDIO(CallerDataRange);

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_NO_MATCH"));
            return STATUS_NO_MATCH;
        }
    }

    if (BufferSize == 0) {
        // Size query - return the size.
        *DataSize = instance->OutDataFormat->FormatSize;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_BUFFER_OVERFLOW"));
        return STATUS_BUFFER_OVERFLOW;
    }

    PKSDATAFORMAT dataFormat = (PKSDATAFORMAT)Data;
    ASSERT(dataFormat);

    if (BufferSize < instance->OutDataFormat->FormatSize) {
        // Buffer is too small.
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_BUFFER_TOO_SMALL"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Input PinCreate builds the required output format in the filter-context, derived from the
    // secure audio format that it encapsulated in the DRMWAVEFORMAT.  Just copy it.
    *DataSize = instance->OutDataFormat->FormatSize;
    RtlCopyMemory(dataFormat, instance->OutDataFormat, instance->OutDataFormat->FormatSize);

   _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler(out)]  DONE OK\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmk\drmfilter.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    DRMFilter.cpp

Abstract:

    This module contains a DRM format translation filter.

Author:
    Paul England (pengland) from ks2 sample code by Dale Sather
    Frank Yerrace


--*/

#include "private.h"
#include "../DRMKMain/KGlobs.h"
#include "../DRMKMain/KList.h"
#include "../DRMKMain/StreamMgr.h"
#include "../DRMKMain/AudioDescrambler.h"
#include "../DRMKMain/KRMStubs.h"


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

typedef struct _POSITIONRANGE {
    ULONGLONG Start;
    ULONGLONG End;
} POSITIONRANGE, *PPOSITIONRANGE;

#define DEFAULT_DRM_FRAME_SIZE     1024

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

BOOLEAN
DRMKsGeneratePositionEvent(
    IN PVOID Context,
    IN PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:
    This routine is a callback from KsGenerateEvents.  Given the position
    range (passed as the context) this routine determines whether the specified
    position event should be signaled.

Arguments:
    Context -
    
    EventEntry -
    
Return Value:
    BOOLEAN
--*/
{
    PPOSITIONRANGE positionRange = (PPOSITIONRANGE)Context;
    PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY eventEntry = (PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY)EventEntry;
    return (eventEntry->Position >= positionRange->Start && eventEntry->Position <= positionRange->End);
}


NTSTATUS DRMInputPinAddLoopedStreamingPositionEvent(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

Arguments:
    
Return Value:
    NTSTATUS
--*/
{
    PLOOPEDSTREAMING_POSITION_EVENT_DATA eventData = (PLOOPEDSTREAMING_POSITION_EVENT_DATA)EventData;
    PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY eventEntry = (PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY)EventEntry;
    PKSPIN Pin = KsGetPinFromIrp(Irp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    eventEntry->Position = eventData->Position;
    KsPinAddEvent(Pin, EventEntry);
    return STATUS_SUCCESS;
}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

NTSTATUS
SetDataRangeFromDataFormat(
    IN FilterInstance* myInstance,
    IN PKSPIN_DESCRIPTOR OutputPinDescriptor,
    IN PKSDATAFORMAT InDataFormat,
    IN PWAVEFORMATEX OutDataFormat
)
/*++

Routine Description:
    This routine modifies the OutputPinDescriptor and myInstance->OutDataFormat
    based on the connection format.

Arguments:
    myInstance -
        Current Filter Instance. Its OutDataFormat and OutWfx will be modified.
    OutputPinDescriptor  -
        Output Pin Descritor. Its DataRanges will be modified.
    InDataFormat -
        InputPin connection format.
    OutDataFormat -
        New output pin connection format. 
        
Return Value:
    STATUS_SUCCESS.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(myInstance);
    ASSERT(OutputPinDescriptor);
    ASSERT(InDataFormat);
    ASSERT(OutDataFormat);

    //
    // Modify the OutputPinDescriptor 
    // 
    GUID& outFormatSpecifierGuid=OutputPinDescriptor->DataRanges[0]->Specifier;
    GUID& outSubFormatGuid=OutputPinDescriptor->DataRanges[0]->SubFormat;

    outFormatSpecifierGuid = InDataFormat->Specifier;

    if (OutDataFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE) 
    {
        PWAVEFORMATEXTENSIBLE wfex = (PWAVEFORMATEXTENSIBLE) OutDataFormat;
        outSubFormatGuid = wfex->SubFormat;
    } 
    else 
    {
        INIT_WAVEFORMATEX_GUID(&outSubFormatGuid, OutDataFormat->wFormatTag);
    }

    PKSDATARANGE_AUDIO DataRange =
        reinterpret_cast<PKSDATARANGE_AUDIO>(OutputPinDescriptor->DataRanges[0]);
    
    DataRange->MaximumChannels = OutDataFormat->nChannels;
    DataRange->MinimumBitsPerSample = 
        DataRange->MaximumBitsPerSample = OutDataFormat->wBitsPerSample;
    DataRange->MinimumSampleFrequency = 
        DataRange->MaximumSampleFrequency = OutDataFormat->nSamplesPerSec;

    //
    // Now we build the required output KSDATAFORMAT structure
    //
    if (IsEqualGUIDAligned(outFormatSpecifierGuid, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) 
    {
        SIZE_T cbOutDataFormatWf = 
            sizeof(KSDATAFORMAT_WAVEFORMATEX) + OutDataFormat->cbSize;
        PKSDATAFORMAT_WAVEFORMATEX OutDataFormatWf = 
            (PKSDATAFORMAT_WAVEFORMATEX) new BYTE[cbOutDataFormatWf];
        if (OutDataFormatWf) {
            RtlZeroMemory(OutDataFormatWf,cbOutDataFormatWf);
            OutDataFormatWf->DataFormat.FormatSize = (ULONG)cbOutDataFormatWf;
            OutDataFormatWf->DataFormat.SampleSize = OutDataFormat->nBlockAlign;
            OutDataFormatWf->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            OutDataFormatWf->DataFormat.SubFormat = outSubFormatGuid;
            OutDataFormatWf->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

            RtlCopyMemory(
                &OutDataFormatWf->WaveFormatEx, 
                OutDataFormat, 
                sizeof(*OutDataFormat) + OutDataFormat->cbSize);
            myInstance->OutDataFormat = (PKSDATAFORMAT) OutDataFormatWf;
            myInstance->OutWfx = &OutDataFormatWf->WaveFormatEx;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    } 
    else 
    {
        ASSERT(IsEqualGUIDAligned(outFormatSpecifierGuid, KSDATAFORMAT_SPECIFIER_DSOUND));
        PKSDATAFORMAT_DSOUND InDataFormatDs = 
            (PKSDATAFORMAT_DSOUND) InDataFormat;
        SIZE_T cbOutDataFormatDs = 
            sizeof(KSDATAFORMAT_DSOUND) + OutDataFormat->cbSize;
        PKSDATAFORMAT_DSOUND OutDataFormatDs = 
            (PKSDATAFORMAT_DSOUND) new BYTE[cbOutDataFormatDs];
        if (OutDataFormatDs) 
        {
            RtlZeroMemory(OutDataFormatDs,cbOutDataFormatDs);
            OutDataFormatDs->DataFormat.FormatSize = (ULONG)cbOutDataFormatDs;
            OutDataFormatDs->DataFormat.SampleSize = OutDataFormat->nBlockAlign;
            OutDataFormatDs->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            OutDataFormatDs->DataFormat.SubFormat = outSubFormatGuid;
            OutDataFormatDs->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;
            OutDataFormatDs->BufferDesc.Flags = InDataFormatDs->BufferDesc.Flags;
            OutDataFormatDs->BufferDesc.Control = InDataFormatDs->BufferDesc.Control;

            RtlCopyMemory(
                &OutDataFormatDs->BufferDesc.WaveFormatEx, 
                OutDataFormat, 
                sizeof(*OutDataFormat) + OutDataFormat->cbSize);
            myInstance->OutDataFormat = (PKSDATAFORMAT)OutDataFormatDs;
            myInstance->OutWfx = &OutDataFormatDs->BufferDesc.WaveFormatEx;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
} // SetDataRangeFromDataFormat


NTSTATUS
DRMOutputPinCreate(
    IN PKSPIN OutputPin,
    IN PIRP Irp
)
/*++

Routine Description:
    This routine is called when an output pin is created.

Arguments:
    Pin -
        Contains a pointer to the pin structure.
    Irp -
        Contains a pointer to the create IRP.
Return Value:
    STATUS_SUCCESS.

KRM-Specific
	Must connect inPin before outPin.
	Called on outPin connection.  Generally connection refused (STATUS_NO_MATCH) if outPin
	is attempted before inPin.  This is because outPin format is determined by the encapsulated inPin
	format.
	You can disconnect and reconnect the outPin if the inPin remains connected.  If you disconnect the
	inPin you must reconnect the outPin.
  

--*/
{

    PAGED_CODE();
    NTSTATUS ntStatus;
    
    PKSFILTER Filter=KsPinGetParentFilter(OutputPin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    //
    // Creating an output pin.  Confirm there is already an input pin.
    //
    PKSPIN InputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_INPUT);
    if (!InputPin)
    {
        return STATUS_NO_MATCH;
    }

    //
    // Note that the input pin is created first. DrmInputPinCreate 
    // routine sets myInstance->frameSize. If frameSize is 0, something
    // must be wrong.
    //
    if (myInstance->frameSize == 0) 
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    OutputPinInstance* myPin=new OutputPinInstance;
    if (!myPin) return STATUS_INSUFFICIENT_RESOURCES;
    RtlZeroMemory(myPin,sizeof(*myPin));
    OutputPin->Context = const_cast<PVOID>(reinterpret_cast<const void *>(myPin));

    //
    // Set the output compression of the output pin.
    //
    ntStatus = KsEdit(OutputPin,&OutputPin->Descriptor,POOLTAG);
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = KsEdit(OutputPin,&OutputPin->Descriptor->AllocatorFraming,POOLTAG);
        if (NT_SUCCESS(ntStatus)) {
            //
            // Edit the allocator max outstanding frames to have at least 200ms of data
            //
            PWAVEFORMATEX waveformat = NULL;
    
            if (IsEqualGUIDAligned(OutputPin->ConnectionFormat->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
            {
                PKSDATAFORMAT_WAVEFORMATEX format = reinterpret_cast<PKSDATAFORMAT_WAVEFORMATEX>(OutputPin->ConnectionFormat);
                waveformat = reinterpret_cast<PWAVEFORMATEX>(&format->WaveFormatEx);
            }
            else if (IsEqualGUIDAligned(OutputPin->ConnectionFormat->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
            {
                PKSDATAFORMAT_DSOUND format = reinterpret_cast<PKSDATAFORMAT_DSOUND>(InputPin->ConnectionFormat);
                waveformat = reinterpret_cast<PWAVEFORMATEX>(&format->BufferDesc.WaveFormatEx);
            }
            else
            {
                //
                // This should never happen, because the filter only supports 
                // the above two specifiers and KS should reject the rest of
                // the specifiers before calling PinCreate function.
                //
                _DbgPrintF(DEBUGLVL_TERSE,("[DRMOutputPinCreate: Unexpected Specifier Pin=%X]", OutputPin));
                ASSERT(FALSE);
            }

            // If waveformat is null, we will not edit the FrameCount.
            if (waveformat)
            {
                // This calculates the number of outstanding frames to have
                // at least 200 ms of data.
                ULONG Frames = 
                    ((waveformat->nAvgBytesPerSec + (myInstance->frameSize * 5 - 1)) / (myInstance->frameSize * 5));

                _DbgPrintF(DEBUGLVL_TERSE,("[DRMOutputPinCreate: nAvgBytesPerSec=%d, Frames=%d]", waveformat->nAvgBytesPerSec, Frames));

                PKS_FRAMING_ITEM frameitem = 
                    const_cast<PKS_FRAMING_ITEM>(&OutputPin->Descriptor->AllocatorFraming->FramingItem[0]);
                frameitem->Frames = Frames;
                frameitem->FramingRange.Range.MinFrameSize = 
                    frameitem->FramingRange.Range.MaxFrameSize = 
                        myInstance->frameSize;
            }
          
            // Notify StreamMgr of the output pin (downstream) component
            PFILE_OBJECT nextComponentFileObject = KsPinGetConnectedPinFileObject(OutputPin);
            PDEVICE_OBJECT nextComponentDeviceObject = KsPinGetConnectedPinDeviceObject(OutputPin);
            
            ASSERT(nextComponentFileObject && nextComponentDeviceObject);
            ASSERT(TheStreamMgr);
            
            if(myInstance->StreamId!=0) 
            {
                ntStatus = TheStreamMgr->setRecipient(
                    myInstance->StreamId, 
                    nextComponentFileObject, 
                    nextComponentDeviceObject);
            }
        }
    }

    // If there's been a failure, we rely on KS to free
    // allocations done due to KS Edit.

    if (!NT_SUCCESS(ntStatus))
    {
        delete myPin;
    }

    return ntStatus;
}

NTSTATUS
DRMInputPinCreate(
   IN PKSPIN InputPin,
   IN PIRP Irp
)
/*++

Routine Description:
    This routine is called when an input pin is created.

Arguments:
    Pin -
        Contains a pointer to the pin structure.
    Irp -
        Contains a pointer to the create IRP.
Return Value:
    STATUS_SUCCESS.

KRM-Specific
	Must connect inPin before outPin.
	Called on inPin connection.  Generally connection refused (STATUS_NO_MATCH) if outPin
	is attempted before inPin.  This is because outPin format is determined by the encapsulated inPin
	format.
	You can disconnect and reconnect the outPin if the inPin remains connected.  If you disconnect the
	inPin you must reconnect the outPin.
  

--*/
{
    PAGED_CODE();
    PDRMWAVEFORMAT drmFormat;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSPIN_DESCRIPTOR OutputPinDescriptor;
    
    PKSFILTER Filter=KsPinGetParentFilter(InputPin);
    ASSERT(Filter);
    if (!Filter) 
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    //
    // Creating an input pin.  Confirm that there is no output pin yet.
    //
    if (NULL != KsFilterGetFirstChildPin(Filter, PIN_ID_OUTPUT)) 
    {
        return STATUS_NO_MATCH;
    }
    
    //
    // Create Input pin context.
    //
    InputPinInstance* myPin = new InputPinInstance;
    if (!myPin) 
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(myPin,sizeof(*myPin));
    InputPin->Context = const_cast<PVOID>(reinterpret_cast<const void *>(myPin));

    //
    // Prepare to edit some aspects of the pin descriptors.
    // Specifically change OutputPinDescriptor to reflect InputPin
    // connection format.
    // To do that, we edit DataRanges of the OutputPin in Filter Descriptor.
    //
    ntStatus = KsEdit(Filter,&Filter->Descriptor,POOLTAG);
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = KsEditSized(
            Filter,
            &Filter->Descriptor->PinDescriptors,
            2 * sizeof(KSPIN_DESCRIPTOR_EX),
            2 * sizeof(KSPIN_DESCRIPTOR_EX),
            POOLTAG);
        if (NT_SUCCESS(ntStatus))
        {
            OutputPinDescriptor = const_cast<PKSPIN_DESCRIPTOR>
                (&Filter->Descriptor->PinDescriptors[PIN_ID_OUTPUT].PinDescriptor);

            //
            // Interpret connection format
            //
            if (IsEqualGUIDAligned(KSDATAFORMAT_SPECIFIER_DSOUND, 
                InputPin->ConnectionFormat->Specifier))
            {
                PKSDATAFORMAT_DSOUND dsformat = 
                    reinterpret_cast<PKSDATAFORMAT_DSOUND>(InputPin->ConnectionFormat);
                drmFormat = (PDRMWAVEFORMAT)&dsformat->BufferDesc.WaveFormatEx;
                _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinCreate: KSDATAFORMAT_SPECIFIER_DSOUND]"));
            } 
            else 
            {
                PKSDATAFORMAT_WAVEFORMATEX format = 
                    reinterpret_cast<PKSDATAFORMAT_WAVEFORMATEX>(InputPin->ConnectionFormat);
                drmFormat = reinterpret_cast<PDRMWAVEFORMAT>(&format->WaveFormatEx);
                _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinCreate: KSDATAFORMAT_SPECIFIER_WFX]"));                
            }

            ASSERT(WAVE_FORMAT_DRM == drmFormat->wfx.wFormatTag);

            //
            // Validate size of the drmFormat
            //
            if (drmFormat->wfx.cbSize >= (sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX))) 
            {
                PWAVEFORMATEX outFormat = &drmFormat->wfxSecure;
        
                // Save the stream Info in the filter context
                myInstance->StreamId=drmFormat->ulContentId;
                myInstance->frameSize=drmFormat->wfx.nBlockAlign;
                
                // Log error to stream to indicate it needs authentication
                TheStreamMgr->logErrorToStream(myInstance->StreamId, DRM_AUTHREQUIRED);
                
                /*
                Fix up the output pin descriptor datarange to limit it as much
                as possible according to the input format, as follows:
        
                The output datarange format specifier should be unchanged
        
                The output datarange subtype should be the appropriate subtype
                according to the output format's wFormatTag as follows:
        
                if wfxSecure.wFormatTag == WAVE_FORMAT_EXTENSIBLE then
                    SubType = WAVEFORMATEXTENSIBLE.SubType
                else
                    SubType = INIT_WAVEFORMATEX_GUID(Guid, wFormatTag)
        
                The output datarange max channels should be set to the number of input channels
        
                The output datarange bits per sample should be limited to the input bits per channel
        
                The output dataramge frequency should be limited to the input frequency
                */
        
                // Edit it to have one KSDATARANGE entry
                OutputPinDescriptor->DataRangesCount = 1;
                ntStatus = KsEditSized(
                    Filter,
                    &OutputPinDescriptor->DataRanges,
                    1 * sizeof(PKSDATARANGE),
                    1 * sizeof(PKSDATARANGE),
                    POOLTAG);
                if (NT_SUCCESS(ntStatus)) 
                {
                    ntStatus = KsEditSized(
                        Filter,
                        &OutputPinDescriptor->DataRanges[0],
                        sizeof(KSDATARANGE_AUDIO),
                        sizeof(KSDATARANGE_AUDIO),
                        POOLTAG);
                    if (NT_SUCCESS(ntStatus))
                    {
                        ntStatus = SetDataRangeFromDataFormat(
                            myInstance,
                            OutputPinDescriptor,
                            InputPin->ConnectionFormat,
                            outFormat);

                        if (!NT_SUCCESS(ntStatus)) 
                        {
                            KsDiscard(Filter,OutputPinDescriptor->DataRanges[0]);
                        }
                    }

                    if (!NT_SUCCESS(ntStatus)) 
                    {
                        KsDiscard(Filter,OutputPinDescriptor->DataRanges);                    
                    }
                }
            } 
            else 
            {
                // Invalid DRMWAVEFORMAT structure
                ntStatus = STATUS_NO_MATCH;
            }

            if (!NT_SUCCESS(ntStatus)) 
            {
                KsDiscard(Filter,Filter->Descriptor->PinDescriptors);                
            }
        }

        //
        // Set input pin framing requirements.
        //
        if (NT_SUCCESS(ntStatus)) 
        {
            ntStatus = KsEdit(InputPin, &InputPin->Descriptor, POOLTAG);
            if (NT_SUCCESS(ntStatus)) 
            {
                ntStatus = KsEdit(InputPin, &InputPin->Descriptor->AllocatorFraming, POOLTAG);
                if (NT_SUCCESS(ntStatus)) 
                {
                    PKS_FRAMING_ITEM frameitem = 
                        const_cast<PKS_FRAMING_ITEM>(&InputPin->Descriptor->AllocatorFraming->FramingItem[0]);

                    frameitem->FramingRange.Range.MinFrameSize = 
                        frameitem->FramingRange.Range.MaxFrameSize = 
                            myInstance->frameSize;
                }
            }

            //
            // KS will clean InputPin->ObjectBag when closing the pin.
            // So do not bother to call KsDiscard.
            //
        }

        if (!NT_SUCCESS(ntStatus)) 
        {
            Filter->Descriptor = &DrmFilterDescriptor;
            KsDiscard(Filter,Filter->Descriptor);            
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        delete myPin;
        myPin = NULL;
    }

    _DbgPrintF(DEBUGLVL_BLAB,("[DrmInputPinCreate Done]"));

    return ntStatus;
}


NTSTATUS
DRMOutputPinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a pin is closed.

Arguments:

    Pin -
        Contains a pointer to the pin structure.

    Irp -
        Contains a pointer to the close IRP.

Return Value:

    STATUS_SUCCESS.

KRM-Specific
	Pin-close order is not specified, but disconnecting the inPin disables further outPin 
	connections until the inPin is reconnected.
  
--*/

{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: Pin Close]"));

    PKSFILTER Filter=KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    // Disconnecting the OutputPin
    ASSERT(Pin->Context);
    delete Pin->Context;
    Pin->Context = NULL;

    ASSERT(TheStreamMgr);
    if(myInstance->StreamId!=0) TheStreamMgr->clearRecipient(myInstance->StreamId);

    return STATUS_SUCCESS;
}

NTSTATUS
DRMInputPinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a pin is closed.

Arguments:

    Pin -
        Contains a pointer to the pin structure.

    Irp -
        Contains a pointer to the close IRP.

Return Value:

    STATUS_SUCCESS.

KRM-Specific
	Pin-close order is not specified, but disconnecting the inPin disables further outPin 
	connections until the inPin is reconnected.
  
--*/

{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: Pin Close]"));

    // Disconnecting the InputPin
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    
    InputPinInstance* inputPin = (InputPinInstance*)Pin->Context;
    
    PKSFILTER filter = KsPinGetParentFilter(Pin);
    ASSERT(filter);
    if (!filter) return STATUS_INVALID_PARAMETER;
    
    FilterInstance* myInstance=(FilterInstance*) filter->Context;

    // Tell the DRM framework that there is no valid downstream component
    ASSERT(TheStreamMgr);
    if(myInstance->StreamId!=0) TheStreamMgr->clearRecipient(myInstance->StreamId);

    const KSPIN_DESCRIPTOR * outputPinDescriptor =
        &filter->Descriptor->PinDescriptors[PIN_ID_OUTPUT].PinDescriptor;

    //
    // Restore filter descriptor.
    //
    filter->Descriptor = &DrmFilterDescriptor;
    KsDiscard(filter, outputPinDescriptor->DataRanges[0]);
    KsDiscard(filter, outputPinDescriptor->DataRanges);
    KsDiscard(filter, filter->Descriptor->PinDescriptors);
    KsDiscard(filter, filter->Descriptor);

    ASSERT(Pin->Context);
    delete Pin->Context;
    Pin->Context = NULL;

    ASSERT(myInstance->OutDataFormat);
    delete myInstance->OutDataFormat;
    myInstance->OutDataFormat = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS 
KsResetState
(
    PKSPIN                  Pin, 
    KSRESET                 ResetValue
)
{
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;
    PFILE_OBJECT        pFileObject;
    ULONG               BytesReturned ;

    pFileObject = KsPinGetConnectedPinFileObject(Pin);
    
	ASSERT( pFileObject );

	if (pFileObject) {
	    Status = KsSynchronousIoControlDevice (
	                   pFileObject,
	                   KernelMode,
	                   IOCTL_KS_RESET_STATE,
	                   &ResetValue,
	                   sizeof (ResetValue),
	                   &ResetValue,
	                   sizeof (ResetValue),
	                   &BytesReturned ) ;
   	}

   	return Status;
}

VOID
DRMFilterReset(
    IN PKSFILTER Filter
    )
{
    PKSPIN InputPin = KsFilterGetFirstChildPin(Filter, PIN_ID_INPUT);
    PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter, PIN_ID_OUTPUT);
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;

    KsFilterAcquireControl(Filter);

    if (InputPin) {
	    InputPinInstance* myInputPin = (InputPinInstance*)InputPin->Context;
	    myInputPin->BasePosition = 0;
    }

	// Now we reset the pin below us.
	if (OutputPin) {
  		OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
		Status = KsResetState(OutputPin, KSRESET_BEGIN);
		if ( NT_SUCCESS(Status) ) {
			Status = KsResetState(OutputPin, KSRESET_END);
		}
	    myOutputPin->BytesWritten = 0;

	    if (!NT_SUCCESS(Status)) {
		    _DbgPrintF(DEBUGLVL_TERSE,("[DRMFilterReset: Reset could not be propagated]"));
	    }
    }
    
    KsFilterReleaseControl(Filter);
}

NTSTATUS
DRMPinGetPosition(
    IN PIRP                  pIrp,
    IN PKSPROPERTY           pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pPosition-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    NTSTATUS ntstatus;
    KSPROPERTY Property;
    PIKSCONTROL pIKsControl;

    // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinGetPosition]"));

    PKSPIN Pin = KsGetPinFromIrp(pIrp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    ASSERT(PIN_ID_INPUT == Pin->Id);
    
    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    KsFilterAcquireControl(Filter);
    
    PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_OUTPUT);
    if (OutputPin) {
        InputPinInstance*  myPin       = (InputPinInstance*)Pin->Context;
        OutputPinInstance* myOutputPin = (OutputPinInstance*)OutputPin->Context;
        FilterInstance*    myFilter    = (FilterInstance*)Filter->Context;
        
        Property.Set = KSPROPSETID_Audio;
        Property.Id = KSPROPERTY_AUDIO_POSITION;
        Property.Flags = KSPROPERTY_TYPE_GET;
    
        ntstatus = KsPinGetConnectedPinInterface(OutputPin,&IID_IKsControl,(PVOID*)&pIKsControl);
        if (NT_SUCCESS(ntstatus))
        {
            KSAUDIO_POSITION Position;
            ULONG cbReturned;
            
            ntstatus = pIKsControl->KsProperty(&Property, sizeof(Property),
                                             &Position, sizeof(Position),
                                             &cbReturned);
            if (NT_SUCCESS(ntstatus))
            {
                ULONGLONG cbSent = myOutputPin->BytesWritten;
                if (cbSent < Position.PlayOffset || cbSent < Position.WriteOffset) {
                    _DbgPrintF(DEBUGLVL_TERSE,("[DRMPinGetPosition:dp=%d,dw=%d]", (int)cbSent - (int)Position.PlayOffset, (int)cbSent - (int)Position.WriteOffset));
                }
    
                if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id)
                {
                if (myPin->PendingSetPosition) {
                    pPosition->PlayOffset = myPin->SetPosition;
                    pPosition->WriteOffset = myPin->SetPosition;
                } else {
                    LONGLONG StreamPosition;
                    // Compute play position from downstream play position,
                    // rounding down to a frame start.
                    StreamPosition = max((LONGLONG)(Position.PlayOffset - myPin->BasePosition), 0);
                    StreamPosition -= StreamPosition % myFilter->frameSize;
                    pPosition->PlayOffset = (StreamPosition + myPin->StartPosition) % max(myPin->Loop.BytesAvailable,1);
                    pPosition->WriteOffset = myPin->OffsetPosition;
                    // _DbgPrintF(DEBUGLVL_TERSE,("[DRMPinGP:r=%d,b=%d,s=%d,a=%d,p=%d]", (int)Position.PlayOffset, (int)myPin->BasePosition, (int)myPin->StartPosition, (int)myPin->Loop.BytesAvailable, (int)pPosition->PlayOffset));
                }
                } else {
                    ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
                    ASSERT(0 == myPin->BasePosition);
                    pPosition->PlayOffset = Position.PlayOffset;
                    pPosition->WriteOffset = myPin->OffsetPosition;
                }
    
                pIrp->IoStatus.Information = sizeof(*pPosition);
            }
    
            pIKsControl->Release();
        }
    } else {
    
        // No output pin connected
        pPosition->PlayOffset = 0;
        pPosition->WriteOffset = 0;
        ntstatus = STATUS_SUCCESS;
    }
    
    KsFilterReleaseControl(Filter);
    
     // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinGetPosition:p=%d,w=%d", (int)pPosition->PlayOffset, (int)pPosition->WriteOffset));
    return ntstatus;
}

NTSTATUS DRMPinSetPosition
(
    IN PIRP                  pIrp,
    IN PKSPROPERTY           pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pPosition-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    NTSTATUS ntstatus;
    
    PKSPIN Pin = KsGetPinFromIrp(pIrp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    ASSERT(PIN_ID_INPUT == Pin->Id);
    
    // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinSetPosition p=%d]", (int)pPosition->PlayOffset));

    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    if (KSINTERFACE_STANDARD_LOOPED_STREAMING != Pin->ConnectionInterface.Id) return STATUS_INVALID_DEVICE_REQUEST;
    
    KsFilterAcquireControl(Filter);
    
    InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;
    FilterInstance* myFilter = (FilterInstance*)Filter->Context;
    
    // TODO: How much should we validate the position here?
    
    // If not a frame aligned position, fail.
    if (0 == (pPosition->PlayOffset % myFilter->frameSize)) {
        myInputPin->SetPosition = pPosition->PlayOffset;
        myInputPin->PendingSetPosition = TRUE;
        
        if (KSSTATE_RUN != Pin->DeviceState) {
            myInputPin->OffsetPosition = myInputPin->SetPosition;
            myInputPin->StartPosition = myInputPin->SetPosition;
        
            PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_OUTPUT);
            if (OutputPin) {
                OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
                myInputPin->BasePosition = myOutputPin->BytesWritten;
            } else {
                myInputPin->BasePosition = 0;
            }
        }
        ntstatus = STATUS_SUCCESS;
    } else {
        _DbgPrintF(DEBUGLVL_ERROR,("[DRMPinSetPosition: PlayOffset not frame aligned]"));
        ntstatus = STATUS_INVALID_PARAMETER;
    }
    
    KsFilterReleaseControl(Filter);
    
    return ntstatus;
}


VOID DRMPreProcess
(
    PKSFILTER Filter, 
    PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
)
/*++

Routine Description:

    This routine is called from DRMProcess before processing any data

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    none

KRM-Specific
--*/
{
    // Input pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_INPUT].Count);
    PKSPROCESSPIN Process = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    PKSPIN Pin = Process->Pin;

    if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id) {
        InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;

        // If Data or BytesAvailable changed, start at the beginning of the frame.
        if (myInputPin->Loop.Data != Process->Data || myInputPin->Loop.BytesAvailable != Process->BytesAvailable) {
            myInputPin->OffsetPosition = 0;
            myInputPin->StartPosition = 0;
            
            ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
            PKSPIN OutputPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0]->Pin;
            ASSERT(OutputPin);
            
            OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
            myInputPin->BasePosition = myOutputPin->BytesWritten;
        }

        if (myInputPin->PendingSetPosition) {
            // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPreProcess: PendingSetPosition p=%d]", (int)myInputPin->SetPosition));
            ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
            PKSPIN OutputPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0]->Pin;
            ASSERT(OutputPin);
            
            OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
            myInputPin->PendingSetPosition = FALSE;
            if (myInputPin->SetPosition >= Process->BytesAvailable) {
                myInputPin->SetPosition = 0;
            }
            myInputPin->OffsetPosition = myInputPin->SetPosition;
            myInputPin->StartPosition = myInputPin->SetPosition;
            myInputPin->BasePosition = myOutputPin->BytesWritten;
        }

        // Stash away Data and BytesAvailable
        myInputPin->Loop.Data = Process->Data;
        myInputPin->Loop.BytesAvailable = Process->BytesAvailable;

        // Looping should be handled in DRMPostProcess
        ASSERT(myInputPin->OffsetPosition < myInputPin->Loop.BytesAvailable);

        if (Process->Data && Process->BytesAvailable) {
            // Get the current pointer and size
            Process->Data = ((PBYTE) myInputPin->Loop.Data + myInputPin->OffsetPosition);
            Process->BytesAvailable = (ULONG)(myInputPin->Loop.BytesAvailable - myInputPin->OffsetPosition);
        }
    }
}

VOID DRMPostProcess
(
    PKSFILTER Filter, 
    PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
)
/*++

Routine Description:

    This routine is called from DRMProcess after processing any data

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    none

KRM-Specific
--*/
{
    PKSPROCESSPIN Process;
    PKSPIN Pin;
    
    // Input pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_INPUT].Count);
    Process = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    Pin = Process->Pin;

    InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;
    
    // Process events
    POSITIONRANGE PositionRange;
    PositionRange.Start = myInputPin->OffsetPosition,
    PositionRange.End   = myInputPin->OffsetPosition+Process->BytesUsed-1;
    KsPinGenerateEvents(Pin,
                        &KSEVENTSETID_LoopedStreaming,
                        KSEVENT_LOOPEDSTREAMING_POSITION,
                        0, NULL,
                        DRMKsGeneratePositionEvent,
                        &PositionRange);
    
    if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id) {
        myInputPin->OffsetPosition += Process->BytesUsed;
        
        // Loop or terminate if necessary
        ASSERT(myInputPin->OffsetPosition <= myInputPin->Loop.BytesAvailable);
        if ((myInputPin->OffsetPosition) >= myInputPin->Loop.BytesAvailable) {
            myInputPin->OffsetPosition = 0;
            if (Process->StreamPointer && (Process->StreamPointer->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA)) {
                // Loop
                Process->BytesUsed = 0;
            } else {
                // Terminate this frame
                Process->BytesUsed = myInputPin->Loop.BytesAvailable;
            }
        } else {
            Process->BytesUsed = 0;
        }

        // Fix the data and size pointers back to their originals.
        Process->Data = myInputPin->Loop.Data;
        Process->BytesAvailable = myInputPin->Loop.BytesAvailable;
    } else {
        ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
        myInputPin->OffsetPosition += Process->BytesUsed;
    }

    // Output pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
    Process = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0];
    Pin = Process->Pin;

    ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
    OutputPinInstance* myOutputPin = (OutputPinInstance*) Pin->Context;
    myOutputPin->BytesWritten += Process->BytesUsed;
}


NTSTATUS
DRMProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING.

KRM-Specific
	This routine is called to process (decrypt) an audio data block.  We forward this
	request to the DRMK framework.
  
	--*/

{
    PAGED_CODE();
	
    PKSPROCESSPIN inPin = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    PKSPROCESSPIN outPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0];

    FilterInstance* instance=(FilterInstance*) Filter->Context;

    DRMPreProcess(Filter, ProcessPinsIndex);

    //
    // Determine how much data we can process this time.
    //
    ULONG inByteCount = inPin->BytesAvailable;
    ULONG outByteCount = outPin->BytesAvailable;
    ULONG bytesToProcess=min(inByteCount, outByteCount);

    if (0 == bytesToProcess) {
	_DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: STATUS_PENDING]"));
        return STATUS_PENDING;
    }

    //
    // Call the transform function to process the data.
    //
    if(instance->StreamId==0){
        // StreamId==0 is not encrypted.  It is used to represent DRM-bundled 
        // plainext audio.
        memcpy(outPin->Data, inPin->Data, bytesToProcess);
        inPin->BytesUsed=bytesToProcess;
        outPin->BytesUsed=bytesToProcess;
    } else {
       	// else is a proper encrypted stream
        DRM_STATUS stat;
        stat=DescrambleBlock(instance->OutWfx, instance->StreamId, 
                        (BYTE*) outPin->Data, outPin->BytesAvailable, &outPin->BytesUsed, 
                        (BYTE*) inPin->Data, bytesToProcess, &inPin->BytesUsed, 
                        instance->initKey, &instance->streamKey, 
                        instance->frameSize);
        
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE, ("DescrambleBlock error - bad BufSize (in, out)=(%d, %d)\n",
                    inPin->BytesAvailable, outPin->BytesAvailable));
            return STATUS_PENDING;              
            //
            // ISSUE: 04/24/2002 ALPERS
            // alpers returning pending would cause the graph to stall.
            // read the message from wmessmer below.
            // STATUS_PENDING is an indication that this processing loop 
            // should be discontinued and that the filter should not be called 
            // back based on existing conditions until another triggering event 
            // happens (frame arrival that would normally trigger processing 
            // or a call to KsFilterAttemptProcessing).
            // If every pin has a queued frame and the flags are left as 
            // default (only call processing when new frame arrives into 
            // previously "empty" queue), returning STATUS_PENDING will stop 
            // processing until the filter manually calls 
            // KsFilterAttemptProcessing or the graph stops and starts again.
            //
        };
        if(instance->initKey)instance->initKey=false;
    };

    // debugging
    /*
    counter++;
    if(counter%10==1  && counter <200){
        _DbgPrintF("Processed: stat==%x, in, out, (%d %d) , (%d %d)]\n", stat,
	           inPin->BytesAvailable, inPin->BytesUsed,
		   outPin->BytesAvailable, outPin->BytesUsed 
		  );
    };
    */

    DRMPostProcess(Filter, ProcessPinsIndex);

    return STATUS_SUCCESS;
}

/*++

Routine Description:
	Called when filter is created.  Local filter context is a FilterInstance.  This structure
	will hold the streamId, the audio format, etc.
	As well as this, the KRM framework is notified of the new filter instance.  KRM 
  
--*/
NTSTATUS
DRMFilterCreate(
    IN PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate::X]"));
    FilterInstance* newInstance=new FilterInstance;
    if (!newInstance){
		_DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate] - out of memory(1)"));
		return STATUS_INSUFFICIENT_RESOURCES;
	};

    RtlZeroMemory(newInstance,sizeof(*newInstance));
    Filter->Context = const_cast<PVOID>(reinterpret_cast<const void *>(newInstance));

	newInstance->initKey=true;
	newInstance->decryptorRunning=false;
	newInstance->frameSize=0;

    NTSTATUS stat = KRMStubs::InitializeConnection(Irp);
	if(stat==STATUS_INSUFFICIENT_RESOURCES){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate] - out of memory(2)"));
		delete newInstance;
		Filter->Context=NULL;
		return stat;
	};
	
    return STATUS_SUCCESS;
};

/*++

Routine Description:
	Called when filter is destroyed.  Local state is removed, and KRM is notified that the filter has
	been destroyed so that it can clean up too.
  
--*/
NTSTATUS
DRMFilterClose(
    IN PKSFILTER Filter,
    IN PIRP Irp
    ){
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterClose]"));
    // tell TheStreamMgr that the stream is dead
    DWORD StreamId=((FilterInstance*)(Filter->Context))->StreamId;
    ASSERT(TheStreamMgr);
    // if(StreamId!=0)TheStreamMgr->destroyStream(StreamId);

    delete (FilterInstance*) Filter->Context;
    KRMStubs::CleanupConnection(Irp);
    return STATUS_SUCCESS;
};

typedef struct {
    KSPROPERTY Property;
    DWORD inSize;
    DWORD outSize;
} SACPROPERTY, *PSACPROPERTY;

NTSTATUS
DrmFilterGetSAC(
    IN PIRP                  pIrp,
    IN BYTE*                 InBuf,
    IN OUT BYTE*             OutBuf
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pSAC-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("DrmFilterGetSAC: %x, %x", InBuf, OutBuf));

    PSACPROPERTY property = (PSACPROPERTY) InBuf;

    DWORD inSize = property->inSize;
    DWORD outSize = property->outSize;

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(pIrp);
    DWORD inSizeIrp=irpStack->Parameters.DeviceIoControl.InputBufferLength;
    DWORD outSizeIrp=irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pIrp->IoStatus.Information = 0;

    //
    // SECURITY NOTE:
    // Ks guarantess that the inSizeIrp is at least sizeof(SACPROPERTY) because
    // of DrmFilterPropertySet definition. So the subtraction cannot underflow.
    //
    if (inSizeIrp - sizeof(property) < inSize) 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Invalid InputSize inSize: %d ", inSize));
        return STATUS_INVALID_PARAMETER;
    }

    if (outSizeIrp < outSize) 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Invalid OutputSize outSize: %d ", outSize));
        return STATUS_INVALID_PARAMETER;
    }

    DWORD* inComm=(DWORD*) (property+1);
    BYTE* ioBuf= (BYTE*)(property + 1);

    _DbgPrintF(DEBUGLVL_VERBOSE,("inSize, outSize %d, %d ", inSize, outSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("inSizeIrp, outSizeIrp %d, %d ", inSizeIrp, outSizeIrp));
    _DbgPrintF(DEBUGLVL_VERBOSE,("---InCommand %x, %x, %x ", inComm[0], inComm[1], inComm[2]));

    if(outSize>inSize){
        memcpy(OutBuf, ioBuf, inSize);
        ioBuf=OutBuf;
    };

    NTSTATUS ntStatus=TheKrmStubs->processCommandBuffer(ioBuf, inSize, outSize, pIrp);

    // Note - kernel processing code expects a shared IO buffer.  This is counter to the
    // KS view of the world, so we use the input buffer or the output buffer (whichever 
    // is larger

    memcpy(OutBuf, ioBuf, pIrp->IoStatus.Information);

    return ntStatus;
}

//
// The following constants make up the pin descriptor.
//
const
KSDATARANGE_AUDIO 
PinDataRangesStream[] =
{
    // in-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DRM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // in-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DRM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // out-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // out-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    }
};

const
PKSDATARANGE 
DataRangeIn[] =
{
    PKSDATARANGE(&PinDataRangesStream[0]),
    PKSDATARANGE(&PinDataRangesStream[1])
};

const
PKSDATARANGE 
DataRangeOut[] =
{
    PKSDATARANGE(&PinDataRangesStream[2]),
    PKSDATARANGE(&PinDataRangesStream[3])
                                            
};

//
// For input, our only requirement is that we get 1024 byte frames
//
DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFramingInput, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    0,      // Max outstanding frames
    1023,   //
    DEFAULT_DRM_FRAME_SIZE,   //
    DEFAULT_DRM_FRAME_SIZE    //
);

//
// We don't want too much buffering because it will increase the delta
// between dsound play/write positions.  At the same time we don't want
// less buffering than kmixer will have on its output (80ms).  So we'll
// go with 200ms of buffer on the output.
//
// We use a static structure tuned for 44.1KHz 16-bit stereo data but
// edit the allocator on output pin creation to adjust for whatever the
// data format is.
//
DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFramingOutput, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    36,     // Max outstanding frames
    1023,   //
    DEFAULT_DRM_FRAME_SIZE,   //
    DEFAULT_DRM_FRAME_SIZE    //
);


const
KSPIN_DISPATCH
OutputPinDispatch =
{
    DRMOutputPinCreate,
    DRMOutputPinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL // Disconnect
};

const
KSPIN_DISPATCH
InputPinDispatch =
{
    DRMInputPinCreate,
    DRMInputPinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL // Disconnect
};

const
KSPIN_INTERFACE
InputPinInterfaces[] =
{
    {
	STATICGUIDOF(KSINTERFACESETID_Standard),
	KSINTERFACE_STANDARD_STREAMING
    }, 
    {
	STATICGUIDOF(KSINTERFACESETID_Standard),
	KSINTERFACE_STANDARD_LOOPED_STREAMING
    }
} ;

DEFINE_KSPROPERTY_TABLE(InputPinPropertiesAudio) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_POSITION,                       // idProperty
	DRMPinGetPosition,                               // pfnGetHandler
	sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
	sizeof(KSAUDIO_POSITION),                        // cbMinGetDataInput
	DRMPinSetPosition,                               // pfnSetHandler
	0,                                               // Values
	0,                                               // RelationsCount
	NULL,                                            // Relations
	NULL,                                            // SupportHandler
	0                                                // SerializedSize
    )
};

DEFINE_KSPROPERTY_SET_TABLE(InputPinPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,
	SIZEOF_ARRAY(InputPinPropertiesAudio),
	InputPinPropertiesAudio,
	0,
	NULL
    )
};

DEFINE_KSEVENT_TABLE(InputPinEventsLoopedStreaming) {
    DEFINE_KSEVENT_ITEM(
	KSEVENT_LOOPEDSTREAMING_POSITION,
	sizeof(LOOPEDSTREAMING_POSITION_EVENT_DATA),
	sizeof(DRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY) - sizeof(KSEVENT_ENTRY),
        DRMInputPinAddLoopedStreamingPositionEvent,
        NULL, // DRMInputPinRemoveLoopedStreamingPositionEvent,
	NULL  // DRMInputPinSupportLoopedStreamingPositionEvent
    )
};

DEFINE_KSEVENT_SET_TABLE(InputPinEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_LoopedStreaming,
	SIZEOF_ARRAY(InputPinEventsLoopedStreaming),
	InputPinEventsLoopedStreaming
    )
};

DEFINE_KSAUTOMATION_TABLE(InputPinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(InputPinPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS(InputPinEventSets)
};

const
KSPIN_DESCRIPTOR_EX
PinDescriptors[] =
{
    {   
        // OUTPUT Pin (Id 0, PIN_ID_OUTPUT)
	&OutputPinDispatch,
        NULL,//Automation
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRangeOut),
            DataRangeOut,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Category
            NULL,//Name
            0
        },
        0,  // KSPIN_FLAGS_*
        1,
        1,
        &AllocatorFramingOutput,
        DRMAudioIntersectHandlerOutPin
    },
    {   
        // INPUT Pin (Id 1, PIN_ID_INPUT)
	&InputPinDispatch,
        &InputPinAutomation,//Automation
        {
	     SIZEOF_ARRAY(InputPinInterfaces),
	     &InputPinInterfaces[0],
             DEFINE_KSPIN_DEFAULT_MEDIUMS,
             SIZEOF_ARRAY(DataRangeIn),
             DataRangeIn,
             KSPIN_DATAFLOW_IN,
             KSPIN_COMMUNICATION_BOTH,
             NULL,//Category
             NULL,//Name
             0
        },
	KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,   // KSPIN_FLAGS_*
        1,
        1,
        &AllocatorFramingInput,
        DRMAudioIntersectHandlerInPin
    }
};

//
// The list of categories for the filter.
//
const
GUID
Categories[] =
{
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM),
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_DRM_DESCRAMBLE)
};

//
// This type of definition is required because the compiler will not otherwise
// put these GUIDs in a paged segment.
//
const
GUID
NodeType = {STATICGUIDOF(KSNODETYPE_DRM_DESCRAMBLE)};

//
// The list of node descriptors.
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType,NULL)
};

//
// The filter dispatch table.
//
const
KSFILTER_DISPATCH
FilterDispatch =
{
    DRMFilterCreate, 
    DRMFilterClose, 
    DRMProcess,
    (PFNKSFILTERVOID) DRMFilterReset  // Reset
};

DEFINE_KSPROPERTY_TABLE(DrmFilterPropertiesDrmAudioStream) {
    DEFINE_KSPROPERTY_ITEM(
        1,  // Should define a constant in a header             // idProperty
	DrmFilterGetSAC,                                 // pfnGetHandler
	sizeof(SACPROPERTY),                             // cbMinGetPropertyInput
	sizeof(LONG),                                    // cbMinGetDataInput
	NULL,                                            // pfnSetHandler
	0,                                               // Values
	0,                                               // RelationsCount
	NULL,                                            // Relations
	NULL,                                            // SupportHandler
	0                                                // SerializedSize
    )
};

DEFINE_KSPROPERTY_SET_TABLE(DrmFilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_DrmAudioStream,
	SIZEOF_ARRAY(DrmFilterPropertiesDrmAudioStream),
	DrmFilterPropertiesDrmAudioStream,
	0,
	NULL
    )
};

DEFINE_KSAUTOMATION_TABLE(DrmFilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(DrmFilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

#define STATIC_REFERENCE_ID \
	0xabd61e00, 0x9350, 0x47e2, 0xa6, 0x32, 0x44, 0x38, 0xb9, 0xc, 0x66, 0x41  
DEFINE_GUIDSTRUCT("ABD61E00-9350-47e2-A632-4438B90C6641", REFERENCE_ID);

#define REFERENCE_ID DEFINE_GUIDNAMED(REFERENCE_ID)

DEFINE_KSFILTER_DESCRIPTOR(DrmFilterDescriptor)
{   
    &FilterDispatch,
    &DrmFilterAutomation, //AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &REFERENCE_ID,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES(Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,
    NULL // ComponentId
};

extern "C" void DrmGetFilterDescriptor(const KSFILTER_DESCRIPTOR **ppDescriptor)
{
    *ppDescriptor = &DrmFilterDescriptor;
    return;
}

//****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmk\initguid.cpp ===
#define INITGUID
#include "guiddef.h"
#include "inc/punknown.h"
#include "inc/KrmCommStructs.h"
#include "ks.h"
#include "drmk.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\cryptk\cbc64ws4.cpp ===
#include "crptkPCH.h"
//-----------------------------------------------------------------------------
//
// File:   CBC64WS4.cpp
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

/*

chain-sum MAC scheme 4.5: multiply-&-swap rounds plus sum (reversible -- reversal code included)

6/15/98 mj
8/22/98 mj
8/31/98 mj
9/21/98 mj
2/4/99 mj

*/


#include "cbckey.h"




#ifndef SHCLASS
#define SHCLASS
#endif



//
// C version
//

#define WORDSWAP(d) \
	((d >> 16) + (d << 16))

// pairwise independent function and summing step
#define C_STEP(L1, L2, L3, L4, L5, L6) \
	t += *Data++; \
	t *= L1; \
	t = WORDSWAP(t); \
	t *= L2; \
	t = WORDSWAP(t); \
	t *= L3; \
	t = WORDSWAP(t); \
	t *= L4; \
	t = WORDSWAP(t); \
	t *= L5; \
	t += L6; \
	sum += t;

// MAC function
// returns half of 64-bit MAC, and places other half in *pKey2
UINT32 CBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key)
{
	UINT32 sum = 0, t = 0;
	while (NumDWORDBlocks > 0) {
		C_STEP(key.a1, key.b1, key.c1, key.d1, key.e1, key.f1);
		C_STEP(key.a2, key.b2, key.c2, key.d2, key.e2, key.f2);
		NumDWORDBlocks -= 2;
	}
	*pKey2 = t;
	return sum;
}




//
// inverse MAC
//

// compute gcd(a, b) = x*a + y*b
static void egcd(UINT64 a, UINT64 b, __int64 &gcd, __int64 &x, __int64 &y)
{
	if (b == 0) {
		gcd = a; x = 1; y = 1;
	}
	else {
		egcd(b, a % b, gcd, x, y);
		__int64 t = y;
		y = x - y*(a/b);
		x = t;
	}
}

// invert n mod 2^32
UINT32 inv32(UINT32 n)
{
	__int64 gcd, in, x;
	__int64 modulus = (__int64)1<<32;
	egcd(modulus, n, gcd, x, in);
	while (in < 0)
		in += modulus;
	return (UINT32) in;
}





// step to reverse action of multiply-&-swap rounds
#define INV_STEP_C(iL1, iL2, iL3, iL4, iL5) \
	tmp *= iL5; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL4; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL3; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL2; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL1;

// inverse MAC function
// decrypts last two blocks of Data
// (replaces 64-bit ciphertext Data[NumDWORDBlocks - 1] and Data[NumDWORDBlocks - 2] with
// plaintext, and returns the plaintext in the return value and *pKey2 -- change as required)
UINT32 InvCBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key,
		  CBCKey ikey )
{
	UINT32 yn, yn1, yn2, xn, xn1;

	UINT32 sum32, tmp;


	// Invert last two blocks (sum and 32-bit MAC).  This requires the encrypted last two
	// blocks and the (NumDWORDBlocks-2) plaintext blocks.
	sum32 = CBC64WS4_asm(Data, NumDWORDBlocks - 2, &yn2, key) + Data[NumDWORDBlocks - 1];



	yn = Data[NumDWORDBlocks - 1];
	yn1 = Data[NumDWORDBlocks - 2] - sum32;

	// last word
	tmp = yn - key.f2;
	INV_STEP_C(ikey.a2, ikey.b2, ikey.c2, ikey.d2, ikey.e2);
	xn = tmp - yn1;

	// next-to-last word
	tmp = yn1 - key.f1;
	INV_STEP_C(ikey.a1, ikey.b1, ikey.c1, ikey.d1, ikey.e1);
	xn1 = tmp - yn2;

	Data[NumDWORDBlocks - 2] = *pKey2 = (UINT32) xn1;
	Data[NumDWORDBlocks - 1] = (UINT32) xn;
	return (UINT32) xn;
}

void CBC64InitState( CBCState *cbcstate ) {
  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
}


void CBC64Init( CBCKey *cbckey, CBCState *cbcstate, BYTE *pKey ) {
  UINT32 *p;

  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
  p = (UINT32 *)pKey;
  cbckey->a1 = *p++ | 0x00000001;
  cbckey->b1 = *p++ | 0x00000001;
  cbckey->c1 = *p++ | 0x00000001;
  cbckey->d1 = *p++ | 0x00000001;
  cbckey->e1 = *p++ | 0x00000001;
  cbckey->f1 = *p++ | 0x00000001;
  cbckey->a2 = *p++ | 0x00000001;
  cbckey->b2 = *p++ | 0x00000001;
  cbckey->c2 = *p++ | 0x00000001;
  cbckey->d2 = *p++ | 0x00000001;
  cbckey->e2 = *p++ | 0x00000001;
  cbckey->f2 = *p++ | 0x00000001;
}

void CBC64InvKey( CBCKey *cbckey, CBCKey *cbcInvKey ) {
  cbcInvKey->a1 = inv32( cbckey->a1 );
  cbcInvKey->a2 = inv32( cbckey->a2 );
  cbcInvKey->b1 = inv32( cbckey->b1 );
  cbcInvKey->b2 = inv32( cbckey->b2 );
  cbcInvKey->c1 = inv32( cbckey->c1 );
  cbcInvKey->c2 = inv32( cbckey->c2 );
  cbcInvKey->d1 = inv32( cbckey->d1 );
  cbcInvKey->d2 = inv32( cbckey->d2 );
  cbcInvKey->e1 = inv32( cbckey->e1 );
  cbcInvKey->e2 = inv32( cbckey->e2 );
  cbcInvKey->f1 = inv32( cbckey->f1 );
  cbcInvKey->f2 = inv32( cbckey->f2 );
}


// pairwise independent function and summing step
#define MP_C_STEP(Data,L1, L2, L3, L4, L5, L6) \
	t += *Data++; \
	t *= L1; \
	t = WORDSWAP(t); \
	t *= L2; \
	t = WORDSWAP(t); \
	t *= L3; \
	t = WORDSWAP(t); \
	t *= L4; \
	t = WORDSWAP(t); \
	t *= L5; \
	t += L6; \
	sum += t;




void CBC64Update( CBCKey *key, CBCState *cbcstate,DWORD dwLen, BYTE *pData )
{
	DWORD i, copylen=0, tmp;
	DWORD *p;
	UINT32 sum,t;

	sum = cbcstate->sum; t = cbcstate->t;
	if ( cbcstate->dwBufLen > 0 ) {
		copylen = min( dwLen, 8 - cbcstate->dwBufLen );
		for ( i=0; i<copylen; i++ )
			cbcstate->buf[ cbcstate->dwBufLen + i ] = pData[i];
		cbcstate->dwBufLen += copylen;
		if ( cbcstate->dwBufLen == 8 ) {
			p = (DWORD *)cbcstate->buf;
			MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1 );
			MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2 );
			cbcstate->dwBufLen = 0;
			}
	}

	tmp = (dwLen - copylen) / 8;
	p = (DWORD *)(pData + copylen);

#ifndef WIN32
#define ARMBUG
#endif

#ifndef ARMBUG
	while (tmp > 0) {
		MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1);
		MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2);
		tmp--;
	}
#else
DWORD AllignedDWORD( DWORD * );
DWORD *q;
	while (tmp > 0) {
		q = (DWORD *)cbcstate->buf;
		*q = AllignedDWORD( p++ );
		MP_C_STEP( q, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1);
		*q = AllignedDWORD( p++ );
		MP_C_STEP( q, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2);
		tmp--;
	}

#endif

	tmp = copylen + ((dwLen-copylen) / 8) * 8;
	if ( tmp < dwLen ) {
		for ( i=tmp; i<dwLen; i++ )
			cbcstate->buf[ i - tmp ] = pData[i];
		cbcstate->dwBufLen = dwLen - tmp;
	}

	cbcstate->sum = sum; cbcstate->t = t;
}



UINT32 CBC64Finalize( CBCKey *key, CBCState *cbcstate, UINT32 *pKey2 ) {
	DWORD i, *p;
	UINT32 sum,t;

	if ( cbcstate->dwBufLen > 0 ) {
		for ( i=cbcstate->dwBufLen; i<8; i++ )
			cbcstate->buf[ i ] = 0;
		sum = cbcstate->sum; t = cbcstate->t;
		p = (DWORD *)cbcstate->buf;
		MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1 );
		MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2 );
		cbcstate->dwBufLen = 0;
		cbcstate->sum = sum; cbcstate->t = t;
	}

	*pKey2 = cbcstate->t;
	return cbcstate->sum;
}



UINT32 CBC64Invert( CBCKey *key, CBCKey *ikey, UINT32 MacA1, UINT32 MacA2,
		UINT32 MacB1, UINT32 MacB2, UINT32 *pInvKey2 )
{
        UINT32 tmp;
	UINT32 yn, yn1, xn, xn1;

	MacA1 += MacB2;
	yn = MacB2;
	yn1 = MacB1 - MacA1;

	// last word
	tmp = yn - key->f2;
	INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
	xn = tmp - yn1;

	// next-to-last word
	tmp = yn1 - key->f1;
	INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
	xn1 = tmp - MacA2;

	*pInvKey2 = (UINT32) xn1;
	return (UINT32) xn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmk\device.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    device.cpp

Abstract:

    This module contains the device implementation for audio.sys.

Author:


	Paul England (pengland) from a sample source filter by
    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#define DEFINE_FILTER_DESCRIPTORS_ARRAY
#include "private.h"
#include "../DRMKMain/KGlobs.h"
#include "../DRMKMain/KRMStubs.h"

//-----------------------------------------------------------------------------
extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPathName)
{
    return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
// DllInitialize and DllUnload
//
EXTERN_C NTSTATUS DllInitialize(PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    _DbgPrintF(DEBUGLVL_VERBOSE,("DRMK:DllInitialize"));
    ntStatus=InitializeDriver();
    return ntStatus;
}

EXTERN_C NTSTATUS DllUnload(void)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("DRMK:DllUnload"));
    CleanupDriver();
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmk\private.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    private.h

Abstract:

    This module contains private definitions for DRMK.sys

Author:

      Paul England (PEngland) from sample code by 
	  Dale Sather  (DaleSat) 31-Jul-1998

--*/

extern "C" {
	#include <wdm.h>
}
#include <unknown.h>
#include <ks.h>

#include <windef.h>
#include <stdio.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include "ksmedia.h"
#include <unknown.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "KDRM:"
#endif
#include <ksdebug.h>

#define POOLTAG '2mrD'

#include "inc/KrmCommStructs.h"
#include "inc/DrmErrs.h"
#include <drmk.h>

#pragma code_seg("PAGE")

#define PIN_ID_OUTPUT 0
#define PIN_ID_INPUT  1

// 
struct FilterInstance{
	DWORD StreamId;					// StreamId (known elsewhere as ContentId) is unique-per-stream
	PKSDATAFORMAT OutDataFormat;	// Output KS data format
	PWAVEFORMATEX OutWfx;			// Pointer to the waveformatex embedded somewhere within *OutDataFormat
	STREAMKEY streamKey;			// initially set to the value obtained from StreamManager
	bool initKey;					// has the streamKey been initted?
	bool decryptorRunning;			// has the Descrambler seen the start frame?
	DWORD frameSize;				// size of frame (calculated from OutWfx by Descrambler)
};

struct InputPinInstance
{
    // For LOOPED_STREAMING pins:
    //  the frame's original loop pointer and size
    struct {
	PVOID Data;
	ULONG BytesAvailable;
    } Loop;
    //  the output pin's position when the frame was started or
    //  its position last set
    ULONGLONG BasePosition;
    //  the position within the frame when it was started or
    //  its position last set
    ULONGLONG StartPosition;
    //  the next copy-from position within the frame
    ULONGLONG OffsetPosition;
    //  the position last set, and a flag indicating that this
    //  position needs to be set by the Process function
    ULONGLONG SetPosition;
    BOOL      PendingSetPosition;
};

struct OutputPinInstance
{
    // count of bytes written to the output
    ULONGLONG BytesWritten;
};

typedef struct {
    KSEVENT_ENTRY EventEntry;
    ULONGLONG Position;
} DRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY, *PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY;

NTSTATUS
DRMAudioIntersectHandlerInPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );

NTSTATUS
DRMAudioIntersectHandlerOutPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );


//
// DRMFilter.cpp
//
extern
const
KSFILTER_DESCRIPTOR 
DrmFilterDescriptor;

//
// Filters table.
//

#ifdef DEFINE_FILTER_DESCRIPTORS_ARRAY

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{   
	&DrmFilterDescriptor

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkaud\device.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    device.cpp

Abstract:

    This module contains the device implementation for audio.sys.

Author:


    Frank Yerrace (FrankYe) 18-Sep-2000
    Dale Sather  (DaleSat) 31-Jul-1998

--*/
#include "private.h"

//
// Filters table.
//
const KSFILTER_DESCRIPTOR* FilterDescriptors[] =
{   
	NULL    // Placeholder for DRM fitler descriptor
};

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

NTSTATUS 
__stdcall
DriverEntry
(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
)
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmkAud:DriverEntry]"));
    const KSFILTER_DESCRIPTOR * pDrmFilterDescriptor;
    DrmGetFilterDescriptor(&pDrmFilterDescriptor);
    FilterDescriptors[0] = pDrmFilterDescriptor;
    return KsInitializeDriver(DriverObject, RegistryPathName, &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkaud\private.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    private.h

Abstract:

    This module contains private definitions for DRMK.sys

Author:
    Frank Yerrace (FrankYe) 18-Sep-2000
    Dale Sather  (DaleSat) 31-Jul-1998

--*/

extern "C" {
#include <wdm.h>
}
#include <unknown.h>
#include <ks.h>

#include <windef.h>
#include <stdio.h>
#include <windef.h>
#include <unknown.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "DRMKAUD:"
#endif
#include <ksdebug.h>

#define POOLTAG 'AMRD'

#pragma code_seg("PAGE")

EXTERN_C void DrmGetFilterDescriptor(const KSFILTER_DESCRIPTOR ** ppDrmFitlerDescriptor);
EXTERN_C NTSTATUS __stdcall DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPathName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\drmkpch.h ===
#if !defined(AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_)
#define AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern "C"{
	#include <wdm.h>
};
#include "MyNew.h"
#include <unknown.h>
#include <ksdebug.h>
#include <ks.h>
#include <ksmedia.h>
#define NOBITMAP
#include <mmreg.h>

#include "KGlobs.h"
#include "../inc/DrmErrs.h"
#include "KrmCommStructs.h"
#include "KGlobs.h"
#include "drmk.h"


#if (DBG)
#define STR_MODULENAME "DRMKMain:"
#endif

#pragma code_seg("PAGE")

#endif // !defined(AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\audiodescrambler.h ===
#ifndef AudioDescrambler_h
#define AudioDescrambler_h

// Descramble/decrypt a block of audio data.
DRM_STATUS DescrambleBlock(WAVEFORMATEX* Wfx, DWORD StreamId, 			   // wfx of embedded audio
				BYTE* Dest, DWORD DestSize, DWORD* DestUsed,   // as you might expect
				BYTE* Src, DWORD SrcSize, DWORD* SrcUsed,	   // as you might expect
				BOOL InitKey,								// set to init the streamKek from 
				STREAMKEY* streamKey, 						// the streamManager
				DWORD FrameSize							// frameSize.  If zero, the frameSize is calculated
				);											// based on the Wfx and FrameSize is set (ie do this
															// once.)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\authstubs.cpp ===
#include "drmkPCH.h"
#include "KList.h"
#include "StreamMgr.h"
#include "iohelp.h"

//-------------------------------------------------------------------------------------------------
//	Package implements the DRMK authentication stubs.  Routines are called to notify DRMK of downstream
//	components and to notify DRMK of the creation and destruction of composite streams.  ContentId
//	in this file is called StreamId elsewhere.
//-------------------------------------------------------------------------------------------------
static NTSTATUS GetDeviceObjectDispatchTable(IN DWORD ContentId, IN _DEVICE_OBJECT* pDevO, IN BOOL fCheckAttached);
static NTSTATUS GetFileObjectDispatchTable(IN DWORD ContentId, IN PFILE_OBJECT pF);
//-------------------------------------------------------------------------------------------------
/*
	Routine called by a splitter component.  Any stream with ContentId==0 is considered unprotected.
*/
NTSTATUS DrmCreateContentMixed(IN PULONG paContentId,
			       IN ULONG cContentId,
			       OUT PULONG pMixedContentId)
{
	KCritical s(TheStreamMgr->getCritMgr());
	if((NULL==paContentId && !(cContentId!=0)) || NULL==pMixedContentId){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmCreateContentMixed"));
		TheStreamMgr->logErrorToStream(0, STATUS_INVALID_PARAMETER);
		return STATUS_INVALID_PARAMETER;
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("DrmCreateMixed for N streams, N= %d", cContentId));
	DRM_STATUS stat = TheStreamMgr->createCompositeStream(pMixedContentId, paContentId, cContentId);
    if(stat==DRM_OK){
		return STATUS_SUCCESS;
	}
	// only error is out-of-memory  
	TheStreamMgr->setFatalError(STATUS_INSUFFICIENT_RESOURCES);
	return STATUS_INSUFFICIENT_RESOURCES;
}
//------------------------------IO-------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream COM object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToInterface(ULONG ContentId, PUNKNOWN pUnknown, ULONG NumMethods)
{

	
    NTSTATUS Status;
    PDRMAUDIOSTREAM DrmAudioStream;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToInterface"));

    if(NULL == pUnknown){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToInterface"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    };

    Status = pUnknown->QueryInterface(IID_IDrmAudioStream, (PVOID*)&DrmAudioStream);
    if (!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("QI Failed for StreamId= %x (Status=%d, %x)", ContentId, Status, Status));
        TheStreamMgr->logErrorToStream(ContentId, Status);
        return Status;		
    };
	
    // ReferenceAquirer calls Release() when it goes out of scope
    ReferenceAquirer<PDRMAUDIOSTREAM> aq(DrmAudioStream);

    // rights are most permissive.  If ContentId!=0, we query the mixed stream that compose
    // this stream to restrict the rights.
    DRMRIGHTS DrmRights={FALSE, FALSE, FALSE};
    
    if(ContentId!=0){
        KCritical s(TheStreamMgr->getCritMgr());
        _DbgPrintF(DEBUGLVL_VERBOSE,("Adding %d methods", NumMethods));
        // get the pointer to the vtbl
        PVOID* vtbl= *((PVOID**) pUnknown);
        // and add NumMethods of from the vtbl
        for(ULONG j=0;j<NumMethods;j++){
            _DbgPrintF(DEBUGLVL_VERBOSE,("ADDING = %x", vtbl[j]));
            if (vtbl[j]) {
                Status = TheStreamMgr->addProvingFunction(ContentId, vtbl[j]);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            if(!NT_SUCCESS(Status)){
                _DbgPrintF(DEBUGLVL_VERBOSE,("addProveFunc Failed for StreamId= %x", ContentId));
                TheStreamMgr->logErrorToStream(ContentId, Status);
                return Status;		
            };
        };
        Status=TheStreamMgr->getRights(ContentId, &DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("getRights failed for StreamId= %x", ContentId));
            TheStreamMgr->logErrorToStream(ContentId, Status);
            return Status;		
        };
    };

    _DbgPrintF(DEBUGLVL_VERBOSE,("About to SetContentId "));
    Status = DrmAudioStream->SetContentId(ContentId, &DrmRights);

    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("SetContentId failed for StreamId= %x (Status=%d, %x)", ContentId, Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };
    return STATUS_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream FILE object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToFileObject(IN ULONG ContentId,
				       IN PFILE_OBJECT FileObject)
{
    KSP_DRMAUDIOSTREAM_CONTENTID Property;
    KSDRMAUDIOSTREAM_CONTENTID PropertyValue;
    ULONG cbReturned;
    NTSTATUS Status;

    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToFileObject"));
    
    if (FileObject)
    {
        KCritical s(TheStreamMgr->getCritMgr());
    
        if (0 != ContentId) {
            NTSTATUS stat=GetFileObjectDispatchTable(ContentId, FileObject);
        }
    
        Property.Property.Set   = KSPROPSETID_DrmAudioStream;
        Property.Property.Id    = KSPROPERTY_DRMAUDIOSTREAM_CONTENTID;
        Property.Property.Flags = KSPROPERTY_TYPE_SET;
        
        Property.Context = FileObject;
        
        Property.DrmAddContentHandlers =           DrmAddContentHandlers;
        Property.DrmCreateContentMixed =           DrmCreateContentMixed;
        Property.DrmDestroyContent     =           DrmDestroyContent;
        Property.DrmForwardContentToDeviceObject = DrmForwardContentToDeviceObject;
        Property.DrmForwardContentToFileObject =   DrmForwardContentToFileObject;
        Property.DrmForwardContentToInterface =    DrmForwardContentToInterface;
        Property.DrmGetContentRights =             DrmGetContentRights;
        
    
        PropertyValue.ContentId = ContentId;
        Status = TheStreamMgr->getRights(ContentId, &PropertyValue.DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad getRights for StreamId= %x", ContentId));
            return Status;		
        };
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToFileObject"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    Status = KsSynchronousIoControlDevice(FileObject, KernelMode, IOCTL_KS_PROPERTY,
                                            &Property, sizeof(Property),
                                            &PropertyValue, sizeof(PropertyValue),
                                            &cbReturned);
    
    // TBD: translate STATUS_PROPSET_NOT_FOUND to something better
    
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad IoControl(1b) for StreamId= %x on driver.  Device with load address [%x] does not support DRM property,(Status=%d, %x)", 
                ContentId, IoGetRelatedDeviceObject(FileObject)->DriverObject->DriverStart,Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };		

    //This may be confusing.  We're logging an error here to indicate
    //that DrmForwardContentToFileObject was called.  This error will
    //later be propagated up to krmproxy and used to adjust the security
    //level of the drivers, since DrmForwardContentToFileObject opens a
    //security hole.  We return success from the function after logging
    //because we want driver walking to continue from this point, not
    //fail, since this is not a fatal error.
    //This error code can be overwritten later by another call to
    //logErrorToStream, but it will be overwritten either with a fatal
    //error or with DRM_BADDRMLEVEL again.
    TheStreamMgr->logErrorToStream(ContentId, DRM_BADDRMLEVEL);
    
    return STATUS_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream DEVICE object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToDeviceObject(IN ULONG ContentId,
				         IN PVOID Reserved,
				         IN PCDRMFORWARD DrmForward)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToDeviceObject"));

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVOID Context;
    NTSTATUS Status;

    KSP_DRMAUDIOSTREAM_CONTENTID Property;
    KSDRMAUDIOSTREAM_CONTENTID PropertyValue;

    Status = STATUS_SUCCESS;

    if (NULL != Reserved) {
    	//
    	// This is an older driver which passes the DeviceObject as the
    	// second param and the Context as the third param.
    	//
    	DeviceObject = (PDEVICE_OBJECT)Reserved;
    	FileObject = NULL;
    	Context = (PVOID)DrmForward;
    } else {
    	if (0 != DrmForward->Flags) {
    	    Status = STATUS_INVALID_PARAMETER;
            TheStreamMgr->logErrorToStream(ContentId, Status);
    	} else {
            DeviceObject = DrmForward->DeviceObject;
            FileObject = DrmForward->FileObject;
            Context = DrmForward->Context;
    	}
    }

    if (!NT_SUCCESS(Status)) return Status;
    	
    if (DeviceObject)
    {
        KCritical s(TheStreamMgr->getCritMgr());

        if (0 != ContentId) {
            NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, DeviceObject, FALSE);
        }
    
        Property.Property.Set   = KSPROPSETID_DrmAudioStream;
        Property.Property.Id    = KSPROPERTY_DRMAUDIOSTREAM_CONTENTID;
        Property.Property.Flags = KSPROPERTY_TYPE_SET;
        
        Property.Context = Context;
        
        Property.DrmAddContentHandlers =           DrmAddContentHandlers;
        Property.DrmCreateContentMixed =           DrmCreateContentMixed;
        Property.DrmDestroyContent     =           DrmDestroyContent;
        Property.DrmForwardContentToDeviceObject = DrmForwardContentToDeviceObject;
        Property.DrmForwardContentToFileObject =   DrmForwardContentToFileObject;
        Property.DrmForwardContentToInterface =    DrmForwardContentToInterface;
        Property.DrmGetContentRights =             DrmGetContentRights;
    
        PropertyValue.ContentId = ContentId;
        Status = TheStreamMgr->getRights(ContentId, &PropertyValue.DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad getRights for StreamId= %x", ContentId));
            return Status;		
        };
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToFileObject"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }
    
    KEVENT Event;
    PIRP Irp;
    IO_STATUS_BLOCK IoStatusBlock;
    
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    Irp = IoBuildDeviceIoControlRequest(
        IOCTL_KS_PROPERTY,
        DeviceObject,
        &Property,
        sizeof(Property),
        &PropertyValue,
        sizeof(PropertyValue),
        FALSE,
        &Event,
        &IoStatusBlock);
    if (Irp) {
        //
        // Originating in kernel, no need to probe buffers, etc.
        //
        Irp->RequestorMode = KernelMode;

        //
        // Set the file object in the next stack location
        //
        IoGetNextIrpStackLocation(Irp)->FileObject = FileObject;
    
        //
        Status = IoCallDriver(DeviceObject, Irp);
        if (Status == STATUS_PENDING) {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
                                                                                
    // TBD: translate STATUS_PROPSET_NOT_FOUND to something better
    
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad IoControl for StreamId(2)= %x (Status=%d, %x)", ContentId, Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };		

    return STATUS_SUCCESS;
}

//--------------------------------------------------------------------------
NTSTATUS DrmDestroyContent(IN ULONG ContentId)
{
    KCritical s(TheStreamMgr->getCritMgr());
    _DbgPrintF(DEBUGLVL_VERBOSE,("DestroyStream for StreamId= %x", ContentId));
    NTSTATUS stat = TheStreamMgr->destroyStream(ContentId);
    if (!NT_SUCCESS(stat)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad destroyStream for StreamId= %d", ContentId));
        // not sure if we should flag this as fatal (we sure can't log it to any stream)
        // TheStreamMgr->logErrorToStream(0, Status);
        return stat;		
    };		
    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------
NTSTATUS DrmGetContentRights(IN DWORD ContentId, OUT DRMRIGHTS* DrmRights){
    KCritical s(TheStreamMgr->getCritMgr());
    NTSTATUS Status=TheStreamMgr->getRights(ContentId, DrmRights);
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("getRights failed for StreamId= %x", ContentId));
        return Status;		
    };
    return Status;
};

//---------------------------------------------------------------------------
NTSTATUS DrmAddContentHandlers(IN ULONG ContentId, IN PVOID* paHandlers, IN ULONG NumHandlers)
{
    KCritical s(TheStreamMgr->getCritMgr());
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (0 != ContentId) {
        for (i = 0; i < NumHandlers && NT_SUCCESS(Status); i++) {
            if (paHandlers[i]) {
                Status = TheStreamMgr->addProvingFunction(ContentId, paHandlers[i]);
                if(!NT_SUCCESS(Status)){
                    _DbgPrintF(DEBUGLVL_VERBOSE,("addProveFunc Failed for StreamId= %x", ContentId));
                    TheStreamMgr->logErrorToStream(ContentId, Status);
                };
            }
        }
    }
    
    return Status;
}

//---------------------------------------------------------------------------
static NTSTATUS GetFileObjectDispatchTable(IN DWORD ContentId, IN PFILE_OBJECT pF){
    if(pF==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid FILE_OBJECT on stream %x", ContentId));
        return STATUS_INVALID_PARAMETER;		
    };
    PDEVICE_OBJECT pDevO=pF->DeviceObject;
    if(pDevO==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid DEVICE_OBJECT for stream %x on PFILE_OBJECT = %x", ContentId, pF));
        return STATUS_INVALID_PARAMETER;		
    };
    NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, pDevO, TRUE);
    if(!NT_SUCCESS(stat)){
        return stat;
    };
    return stat;
};
//---------------------------------------------------------------------------
static NTSTATUS GetDeviceObjectDispatchTable(IN DWORD ContentId, IN _DEVICE_OBJECT* pDevO, BOOL fCheckAttached){
    _DRIVER_OBJECT* pDriverObject=pDevO->DriverObject;
    if(pDriverObject==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid PDRIVER_OBJECT for stream %x", ContentId));
        return STATUS_INVALID_PARAMETER;		
    };

    // collect the dispatch table.
    for(DWORD j=0;j<IRP_MJ_MAXIMUM_FUNCTION;j++){
        PDRIVER_DISPATCH pDisp=pDriverObject->MajorFunction[j];			
        if(pDisp==NULL)continue;
        // _DbgPrintF(DEBUGLVL_VERBOSE,("DISPATCH (%3d) devO =%10x, func=%10x", j, pDevO, pDisp));
        	
        DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, pDisp);
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
            return STATUS_INSUFFICIENT_RESOURCES;
        };
    };
    // collect the other driver entry points 
	
    const DWORD numMiscEntries=4;
    PVOID miscEntry[numMiscEntries];
    miscEntry[0]=pDriverObject->DriverExtension->AddDevice;
    miscEntry[1]=pDriverObject->DriverUnload;
    miscEntry[2]=pDriverObject->DriverStartIo;
    miscEntry[3]=pDriverObject->DriverInit;
    for(j=0;j<numMiscEntries;j++){
        if(NULL!=miscEntry[j]){
            DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, miscEntry[j]);
            if(stat!=DRM_OK){
                _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
                return STATUS_INSUFFICIENT_RESOURCES;
            };
        };
    };
	
    // collect the fastIo dispatch points (if they are present)
    FAST_IO_DISPATCH* pFastIo=pDriverObject->FastIoDispatch;
    if(NULL!=pFastIo){
        ULONG numFastIo=(pFastIo->SizeOfFastIoDispatch - sizeof(pFastIo->SizeOfFastIoDispatch)) / sizeof(PVOID);
        if(numFastIo!=0){
            _DbgPrintF(DEBUGLVL_VERBOSE,("FASTIO DISPATCH: Num=", numFastIo));

            // Collect the FastIo entries.  wdm.h makes has some strict requirements on 
            // editing this structure, which means that we can pick up the entries as if
            // they were in a real array.

            PVOID* fastIoTable= (PVOID*)&(pFastIo->FastIoCheckIfPossible);
            for(ULONG j=0;j<numFastIo;j++){
                PVOID fastIoEntry= *(fastIoTable+j);
                if(NULL!=fastIoEntry){
                    DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, fastIoEntry);
                    if(stat!=DRM_OK){
                        _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
                        return STATUS_INSUFFICIENT_RESOURCES;
                    };
                };
            };
        };
    };
	
    // now traverse the driver stack (if there is one)
    if (fCheckAttached) {
        _DEVICE_OBJECT* pNextDevice=pDevO->AttachedDevice;
        if(NULL == pNextDevice)return STATUS_SUCCESS;
        NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, pNextDevice, fCheckAttached);
        if(!NT_SUCCESS(stat)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Failed to add dispatch entries from attached device on stream=%x ", ContentId));
            return stat;		
        };
    }

    // Verifier and Acpi are special case filter drivers.  Instead of modifying them
    // to handle DRM, we assume that it blindly "forwards" everything to the next
    // lower driver
    if (NT_SUCCESS(IoDeviceIsVerifier(pDevO)) || NT_SUCCESS(IoDeviceIsAcpi(pDevO)))
    {
    	PDEVICE_OBJECT LowerDeviceObject = IoGetLowerDeviceObject(pDevO);
        _DbgPrintF(DEBUGLVL_TERSE,("Detected Verifier or Acpi on DO %p, checked lower DO", pDevO));
    	if (LowerDeviceObject)
    	{
    	    NTSTATUS status = GetDeviceObjectDispatchTable(ContentId, LowerDeviceObject, FALSE);
    	    ObDereferenceObject(LowerDeviceObject);
    	    if (!NT_SUCCESS(status)) return status;
    	}
    	else
    	{
    	   return STATUS_INVALID_DEVICE_REQUEST;
    	}
    }


    return STATUS_SUCCESS;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\audiodescrambler.cpp ===
#include "drmkPCH.h"
#include "CryptoHelpers.h"
#include "KList.h"
#include "../DRMKMain/StreamMgr.h"
#include "AudioDescrambler.h"
//------------------------------------------------------------------------------
// When doing noise addition, we only decryptt the low bits.  These constants define
// the number of bits encrypted.  
// If you change this, change the contants in DRMKMain, too.
WORD mask16=(WORD) 0x3FFF;
char mask8=(char) 0x7F;
//------------------------------------------------------------------------------
DRM_STATUS DescrambleBlock(WAVEFORMATEX* Wfx, DWORD StreamId, 
							BYTE* Dest, DWORD DestSize, DWORD* DestUsed,
							BYTE* Src, DWORD SrcSize, DWORD* SrcUsed,
							BOOL InitKey, STREAMKEY* streamKey, 
							DWORD FrameSize){
	if(StreamId==0){
		// StreamId==0 is a dummy debugging stream that is unencrypted
		DWORD NumBytes=min(SrcSize, DestSize);
		memcpy(Dest, Src, NumBytes);
		*SrcUsed=NumBytes;
		*DestUsed=NumBytes;
		return DRM_OK;
	};

	*SrcUsed=0;
	*DestUsed=0;
	DWORD blockLen=min(SrcSize, DestSize);
	blockLen=blockLen/FrameSize*FrameSize;
	if(blockLen==0){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Not enough data"));
		return DRM_DATALENGTH;
	};
	static bool firstTime=true;
	if(firstTime){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Descramble: streamId=%d, isPCM=%d, (bits=%d, mono=%d), FrameSize=%d\n",
		StreamId, Wfx->wFormatTag, (int) Wfx->wBitsPerSample, (int) Wfx->nChannels, FrameSize));
		firstTime=false;
	};
	
	if(InitKey){
            if(TheStreamMgr!=NULL){
                STREAMKEY* theStreamKey;
                DRM_STATUS stat=TheStreamMgr->getKey(StreamId, theStreamKey);
                // note, we keep a local copy.  If you call an encryption fucntion on this
                // key, state in streamManager will NOT be updated.
                if(stat!=KRM_OK){
                    _DbgPrintF(DEBUGLVL_VERBOSE,("Can't get key for stream: %x", StreamId));
                    return stat;
                };
                *streamKey= *theStreamKey;
            } else {
                _DbgPrintF(DEBUGLVL_VERBOSE,("TheStreamMgr not initted"));
                return KRM_SYSERR;
            };
	};	
	
	DWORD bitsPerSample=Wfx->wBitsPerSample;
	DWORD numChannels=Wfx->nChannels;
	bool isPcm=(Wfx->wFormatTag==WAVE_FORMAT_PCM);
	
	// for non-pcm, we scramble al but the msb in each byte.
	DWORD effectiveBitsPerSample=bitsPerSample;
	if(!isPcm)effectiveBitsPerSample=8;
	
	// We deal with data in FrameSize lumps
	DWORD numLumps=blockLen/FrameSize;
	for(DWORD k=0;k<numLumps;k++){
		
		BYTE* inData=Src+k*FrameSize;
		BYTE* outData=Dest+k*FrameSize;
		memcpy(outData, inData,  FrameSize);

		// If the frame is all zeros, pass it unscrambled (the audio system inserts
		// blank frames.  These will not necessarily have been scrambled.  we take 
		// a frame of zeros as a special case and do not unscramble).  
		DWORD* inBuffer=reinterpret_cast<DWORD*> (inData);
		DWORD numDwordsPerFrame=FrameSize/4;
		bool isBlankFrame=true;
		for(DWORD kk=0;kk<numDwordsPerFrame;kk++){
			if(inBuffer[kk]!=0){
				isBlankFrame=false;
				break;
			};
		};
		if(isBlankFrame){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Blank buffer"));
			continue;
		};

		// we seed the packet sample key with some MSBs from the data stream
		// (these are not encrypted).  We take bits from the first 64 samples.
		// We could tune this for speed/security.
		int samplesForSeed=64;
		__int64 seed=0;
		if(effectiveBitsPerSample==8){
			// grab MSBs
			for(int j=0;j<samplesForSeed; j++){
				BYTE c=inData[j] & ~mask8;
				c >>= 7;
				seed = (seed << 1) + c;
			};
		} else {
			for(int j=0;j<samplesForSeed; j++){
				WORD& w= (WORD&) *((WORD*) &inData[j*2]);
				WORD m=w & ~mask16;
				
				m >>= 14;
				seed = (seed << 1) + m;
			};
		};
		// MAC the seed using the main stream key.  Generate the packet key from the mac.
		// (user mode performs identical operations to generate the scrmabling key)
		CBCKey macKey;
		CBCState macState;
		DRM_STATUS stat=CryptoHelpers::InitMac(macKey, macState, (BYTE*) streamKey, sizeof(STREAMKEY));
		DRMDIGEST mac;
		stat=CryptoHelpers::Mac(macKey, (BYTE*) &seed, sizeof(seed), mac);
		STREAMKEY packetKey;
		bv4_key_C(&packetKey, sizeof(mac),(BYTE*) &mac);
		
		// If there has been a fatal error (usually out-of-memory somewhere)
		// we do not descramble (an alternative would be to return silence).
		if(TheStreamMgr->getFatalError()==DRM_OK){
			// We have already copied the inBlock to the outBlock, now we can decrypt it
			CryptoHelpers::Xcrypt(packetKey, outData, FrameSize);
			// We know about noise addition on 8 and 16 bit PCM audio.  Other
			// audio formats get treated like 8 bit audio.
			DWORD numSamples=FrameSize/(effectiveBitsPerSample/8);
			if(effectiveBitsPerSample==16){
				WORD* in=(WORD*) inData;
				WORD* out=(WORD*) outData;
				for(DWORD j=0;j<numSamples;j++){
					out[j]=(out[j] & mask16) | (in[j] & ~mask16);
				};
			} 
			if(effectiveBitsPerSample==8){
				char* in=(char*) inData;
				char* out=(char*) outData;
				for(DWORD j=0;j<numSamples;j++){
					out[j]=(out[j] & mask8) | (in[j] & ~mask8);
				};
			};
		};
	}; // of loop over blocks

	*SrcUsed=blockLen; 
	*DestUsed=blockLen;

	return DRM_OK;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\encraption.h ===
/*++

Copyright (C) Microsoft Corporation, 2002 - 2002

Module Name:

    encraption.h

Abstract:

    This module contains simple obfuscation algorithm to hide communication
    keys.

Author:
    Carsten Hansen
    Alper Selcuk


--*/


#ifndef _ENCRAPTION_H
#define _ENCRAPTION_H

//=============================================================================
//
// This routine clears the given key. The encryption/decryption method is 
// developed by CarstenH.
//
NTSTATUS __forceinline ClearKey(
    const BYTE *PrivKey, 
    BYTE *ClearKey,
    ULONG KeySize, 
    ULONG MagicNumber2)
{
    const char * pszName = "Microsoft Corporation";

    /* Convert the obfuscated key to clear */
    BYTE *clearDRMKPriv;

    clearDRMKPriv = (BYTE *) ExAllocatePool(PagedPool, KeySize);
    if (NULL == clearDRMKPriv) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    /* Permute bytes */
    int k = 1;
    clearDRMKPriv[0] = PrivKey[0];
    do {
        int l = k * MagicNumber2 % (KeySize - 1);
        clearDRMKPriv[k] = PrivKey[l];
        if (l == 1)
            break;
        k = l;
    } while (1);
    clearDRMKPriv[KeySize - 1] = PrivKey[KeySize - 1];

    /* Swap nibbles */
    DWORD * pdw = (DWORD *) clearDRMKPriv;
    DWORD * qdw = (DWORD *) (clearDRMKPriv + KeySize);
    DWORD granularity = 4;
    for (; pdw < qdw; ++ pdw)
    {
        DWORD temp = 0xF0F0F0F0;
        temp &= *pdw;
        *pdw ^= temp;
        temp ^= (*pdw << granularity);
        *pdw |= (*pdw << granularity);
        *pdw ^= (temp >> granularity);
    }

    /* XOR with "Microsoft" */
    ULONG len = strlen(pszName);
    for (ULONG i = 0, j = 0; i < KeySize; ++i)
    {
        clearDRMKPriv[i] ^= pszName[j];
        ++j;
        if (j > len)
            j = 0;
    }

    RtlCopyMemory(ClearKey, clearDRMKPriv, KeySize);

    RtlZeroMemory(clearDRMKPriv, KeySize);
    ExFreePool(clearDRMKPriv);

    return STATUS_SUCCESS;
}

/* Obfuscation algorithm.
	{
		// XOR with "Microsoft" 
		int len = strlen(pszName);
		for (int i = 0, j = 0; i < sizeof(objDRMKPriv); ++i)
		{
			objDRMKPriv[i] = DRMKpriv[i] ^ pszName[j];
			++j;
			if (j > len)
				j = 0;
		}

		// Swap nibbles 
		DWORD * pdw = (DWORD *) objDRMKPriv;
		DWORD * qdw = (DWORD *) (objDRMKPriv + sizeof(objDRMKPriv));
		DWORD granularity = 4;
		for (; pdw < qdw; ++ pdw)
		{
			DWORD temp = 0xF0F0F0F0;
			temp &= *pdw;
			*pdw ^= temp;
			temp ^= (*pdw << granularity);
			*pdw |= (*pdw << granularity);
			*pdw ^= (temp >> granularity);
		}

		// Permute bytes
		int k = 1;
		BYTE temp = objDRMKPriv[k];
		do {
			int l = k * MAGIC_NUMBER_1 % (sizeof(objDRMKPriv) - 1);
			if (l == 1)
				break;
			objDRMKPriv[k] = objDRMKPriv[l];
			k = l;
		} while (1);
		objDRMKPriv[k] = temp;
	}
*/

/* Clean Key and Cert
static const BYTE DRMKpriv[20] = {
        0x80, 0x0B, 0x97, 0x30, 0x7A, 0xFB, 0x1B, 0x3B, 
        0xB7, 0xB2, 0x0F, 0x44, 0x63, 0xD8, 0xA5, 0x2D, 
        0xD5, 0xBC, 0x3D, 0x75};
static const BYTE DRMKCert[104] = {
        0x00, 0x01, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
        0x46, 0xB1, 0x18, 0x76, 0x66, 0xBE, 0x91, 0xEC,
        0xBD, 0x06, 0x50, 0x72, 0x1B, 0x8C, 0xD3, 0x55,
        0xD2, 0x1A, 0xB7, 0x60, 0x6C, 0x65, 0xDD, 0xE4,
        0x54, 0xCE, 0xFD, 0xEB, 0x4A, 0x9F, 0x0A, 0x5A,
        0xD1, 0x44, 0xB2, 0x32, 0xB9, 0xA0, 0x84, 0x67,
        0x55, 0xD7, 0xFE, 0x45, 0xD5, 0x16, 0x36, 0x7B,
        0xEC, 0x3C, 0xFF, 0x7D, 0x4C, 0x09, 0x9A, 0x7B,
        0xB4, 0x6C, 0xEF, 0x2B, 0xC5, 0xF8, 0xA3, 0xC4,
        0xE2, 0x57, 0xC5, 0x87, 0xA6, 0x75, 0x85, 0xFE,
        0xE2, 0x34, 0xA3, 0x30, 0xAE, 0x4D, 0xDB, 0x23,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\handlemgr.cpp ===
#include "drmkPCH.h"
#include "CBCKey.h"
#include "KList.h"
#include "HandleMgr.h"
//------------------------------------------------------------------------------
HandleMgr* TheHandleMgr=NULL;
//------------------------------------------------------------------------------
HandleMgr::HandleMgr(){
	KCritical c(critMgr);
	TheHandleMgr=this;
	return;
};
//------------------------------------------------------------------------------
HandleMgr::~HandleMgr(){
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		delete cs;
	};
	return;
};
//------------------------------------------------------------------------------
bool HandleMgr::newHandle(PVOID HandleRef, OUT ConnectStruct*& TheConnect){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Handle already exists"));
			return false;
		};
	};
	TheConnect=new ConnectStruct;
	if(TheConnect==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	memset(TheConnect, 0, sizeof(*TheConnect));
	TheConnect->handleRef=HandleRef;
	TheConnect->secureStreamStarted=false;
	bool ok=connects.addTail(TheConnect);
	if(!ok){
		delete TheConnect;
		return false;
	};
	return true;
};
//------------------------------------------------------------------------------
bool HandleMgr::deleteHandle(PVOID HandleRef){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		POS oldP=p;
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef){
			ConnectStruct* cs1=connects.getAt(oldP);
			delete cs1;
			connects.removeAt(oldP);
			return true;
		};
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("Handle does not exist"));
	return false;
};
//------------------------------------------------------------------------------
ConnectStruct* HandleMgr::getConnection(PVOID HandleRef){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef)return cs;
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("Handle does not exist"));
	return NULL;
};
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\handlemgr.h ===
#ifndef HandleMgr_h
#define HandleMgr_h
// This class manages an impedance mismatch between IOCT processing and KS stream 
// processing.  Specifically, filters are passed KSPIN and IRP state, and keep 
// per-filter instance data in parent filter "context."  This information is unavailable
// to IOCT processing.  However, the stream encryption and communication keys are
// needed in both.
// The common structure available in both worls is the FILE_HANDLE.  This class contains
// a list of FILE_HANDLES that can be used to map between worlds.
// This is only used and referenced on IOCTL processing and for filter creation and 
// destruction.

// todo - efficiency
//-----------------------------------------------------------------------------
struct ConnectStruct{
	PVOID handleRef;			// the FILE_HANDLE
	STREAMKEY serverKey;			// stream key for SAC in kernel
	CBCKey serverCBCKey;			// MAC key in kernel
	CBCState serverCBCState;		// MAC state
	bool secureStreamStarted;		// whether we're running encrypted
	DWORD streamId;					// StreamId
};
//-----------------------------------------------------------------------------
class HandleMgr{
public:
	HandleMgr();
	~HandleMgr();
	bool newHandle(PVOID HandleRef, OUT ConnectStruct*& TheConnect);
	bool deleteHandle(PVOID HandleRef);
	ConnectStruct* getConnection(PVOID HandleRef);
protected:
	KList<ConnectStruct*> connects;
	KCritMgr critMgr;			
};
extern HandleMgr* TheHandleMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\iohelp.c ===
/* iohelp.c
 * Copyright (c) 2001 Microsoft Corporation
 */

#include <ntddk.h>
#include <ntimage.h>
#include <ntldr.h>


/*++

IoGetLowerDeviceObject

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose next device object needs
                    to be obtained.

ReturnValue:

    NULL if driver is unloaded or marked for unload or if there is no attached deviceobject.
    Otherwise a referenced pointer to the deviceobject is returned.

Notes:

--*/
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
);

/*++

IoDeviceIsVerifier

Routine Description:

    This routine checks whether the device object is the Verifier.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose to be checked
    
ReturnValue:

    TRUE if the device object is Verifier

Notes:

    This function simply checks whether the driver name is \Driver\Verifier

--*/
NTSTATUS IoDeviceIsVerifier(PDEVICE_OBJECT DeviceObject)
{
    
    UNICODE_STRING DriverName;
    const PCWSTR strDriverName = L"\\Driver\\Verifier";

    RtlInitUnicodeString(&DriverName, strDriverName);
    if (RtlEqualUnicodeString(&DriverName, &DeviceObject->DriverObject->DriverName, TRUE)) return STATUS_SUCCESS;

    return STATUS_NOT_SUPPORTED;
}


/*++

IoDeviceIsAcpi

Routine Description:

    This routine checks whether the device object is the Acpi.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose to be checked
    
ReturnValue:

    TRUE if the device object is Acpi

Notes:

--*/
NTSTATUS IoDeviceIsAcpi(PDEVICE_OBJECT DeviceObject)
{
    UNICODE_STRING Name;
    PKLDR_DATA_TABLE_ENTRY Section;
    const PCWSTR strDriverName = L"\\Driver\\Acpi";
    const PCWSTR strDllName = L"acpi.sys";

    RtlInitUnicodeString(&Name, strDriverName);
    if (RtlEqualUnicodeString(&Name, &DeviceObject->DriverObject->DriverName, TRUE)) return STATUS_SUCCESS;

    RtlInitUnicodeString(&Name, strDllName);
    Section = DeviceObject->DriverObject->DriverSection;
    if (RtlEqualUnicodeString(&Name, &Section->BaseDllName, TRUE)) return STATUS_SUCCESS;

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\kglobs.h ===
#ifndef kglobs_h
#define kglobs_h

// KRM global useful classes

//-------------------------------------------------------------------------------------------------
// Encapsulated a mutex.  Best used as a class member
class KCritMgr{
friend class KCritical;
public:
	KCritMgr();
	~KCritMgr();
	bool isOK(){return allocatedOK;};
protected:
	PKMUTEX	myMutex;
	bool allocatedOK;
};
//-------------------------------------------------------------------------------------------------
// Encapsulated the acuisition and release of a mutex in conjunction with KCritMgr.  
// Best used as an automatic
class KCritical{
public:
	KCritical(const KCritMgr& critMgr);
	~KCritical();
protected:
	PKMUTEX hisMutex;
};
//-------------------------------------------------------------------------------------------------
// to 'Release' a COM interface on context destruction (a sort of 'smart pointer'.)  
// Best used as an automatic
template<class T>
class ReferenceAquirer{
public:
	ReferenceAquirer(T& t):myT(t){return;};
	~ReferenceAquirer(){myT->Release();};
protected:
	T& myT;
};


//#undef _DbgPrintF
//#define _DbgPrintF(lvl, strings) DbgPrint(STR_MODULENAME);DbgPrint##strings;DbgPrint("\n");

//-------------------------------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\klist.cpp ===
//------------------------------------------------------------------------------
template<class T>
KList<T>::KList(){
	count=0;
	head=NULL;
	tail=NULL;
	return;
};
//------------------------------------------------------------------------------
template<class T>
KList<T>::~KList(){
	empty();
	return;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::empty(){
	Node* n=head;
	while(n!=NULL){
		Node* nextN=n->next;
		delete n;
		n=nextN;
	};
	head=NULL;
	tail=NULL;
	count=0;
};
//------------------------------------------------------------------------------
template<class T>
bool KList<T>::addTail(const T& t){
	Node* n=new Node;
	if(n==NULL){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("KList: out of memory]"));
		return false;
	};
	n->next=n->last=NULL;
	n->Obj=t;
	if(tail!=NULL){
		ASSERT(tail->next==NULL);
		n->last=tail;
		tail->next=n;
		tail=n;
	} else {
		head=n;
		tail=n;
	};
	count++;
	return true;;
};
//------------------------------------------------------------------------------
template<class T>
bool KList<T>::addHead(const T& t){
	Node* n=new Node;
	if(n==NULL){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("KList: out of memory]"));
		return false;
	};
	n->next=n->last=NULL;
	n->Obj=t;
	if(head!=NULL){
		assert(head->last==NULL);
		n->next=head;
		head->last=n;
		head=n;
	} else {
		head=n;
		tail=n;
	};
	count++;
	return true;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getHead() const {
	ASSERT(count!=0);
	return head->Obj;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getTail() const {
	ASSERT(count!=0);
	return tail->Obj;
};
//------------------------------------------------------------------------------
template<class T>
POS KList<T>::getHeadPosition() const{
	return (POS) head;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getAt(POS& P){
	ASSERT(count!=0);
	return ((Node*)P)->Obj;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getNext(POS& P){
	ASSERT(count!=0);
	T& ret=((Node*)P)->Obj;
	P = (POS)((Node*)P)->next;
	return ret;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeHead(){
	ASSERT(count>=1);
	Node* oldHead=head;
	head=head->next;
	head->last=NULL;
	delete oldHead;
	count--;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeTail(){
	ASSERT(count>=1);
	Node* oldTail=tail;
	tail=tail->last;
	tail->next=NULL;
	delete oldTail;
	count--;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeAt(POS& P){
	ASSERT(count>=1);
	Node* theNode= (Node*)P;
	Node* lastNode=theNode->last;
	Node* nextNode=theNode->next;
	delete theNode;
	if(head==theNode){head=nextNode;if(nextNode!=NULL)nextNode->last=NULL;}
	if(tail==theNode){tail=lastNode;if(lastNode!=NULL)lastNode->next=NULL;};
	if(lastNode!=NULL)lastNode->next=nextNode;
	if(nextNode!=NULL)nextNode->last=lastNode;
	count--;
	return;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\iohelp.h ===
/* iohelp.h
 * Copyright (c) 2001 Microsoft Corporation
 */

EXTERN_C
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );

EXTERN_C
NTSTATUS
IoDeviceIsVerifier(
    PDEVICE_OBJECT DeviceObject
    );

EXTERN_C
NTSTATUS
IoDeviceIsAcpi(
    PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\kglobs.cpp ===
#include "drmkPCH.h"
#include "KGlobs.h"
//-----------------------------------------------------------------------------
KCritMgr::KCritMgr(){
    myMutex=(PKMUTEX)ExAllocatePoolWithTag(NonPagedPool, sizeof(KMUTEX), 'kmrD');
    if(myMutex==NULL){
        allocatedOK=false;
        _DbgPrintF(DEBUGLVL_VERBOSE,("Allocation failed in KCritMgr"));
        return;
    } else { 
        allocatedOK=true;
    };
    KeInitializeMutex(myMutex, 0);	
    return;
};
//-----------------------------------------------------------------------------
KCritMgr::~KCritMgr(){
    if(myMutex!=NULL)ExFreePool(myMutex);
    return;
};
//-----------------------------------------------------------------------------
KCritical::KCritical(const KCritMgr& critMgr){
    hisMutex =critMgr.myMutex;
    NTSTATUS stat=KeWaitForMutexObject(hisMutex, Executive, KernelMode, FALSE, NULL);
};
//-----------------------------------------------------------------------------
KCritical::~KCritical(){
    KeReleaseMutex(hisMutex, FALSE);
};
//-----------------------------------------------------------------------------
void * _cdecl operator new(size_t S){
    return ExAllocatePoolWithTag(PagedPool, S, 'kmrD');
};
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\klist.h ===
#ifndef KList_h
#define KList_h

typedef void* POS;
template <class T>
class KList{
public:
	KList();
	~KList();
	void empty();
	bool addTail(const T& t);
	bool addHead(const T& t);
	T& getTail() const;
	T& getHead() const;
	POS getHeadPosition() const;
	T& getAt(POS& P);
	T& getNext(POS& P);
	void removeHead();
	void removeTail();
	void removeAt(POS& P);
	int getCount() const {return count;};
protected:
	struct Node{
		T Obj;
		Node* last;
		Node* next;
	};
	Node* head;
	Node* tail;
	int count;

};
#include "KList.cpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\krmstubs.h ===
#ifndef KRMStubs_h
#define KRMStubs_h

class KRMStubs{
public:
	KRMStubs();
	~KRMStubs();
	// Main entry point for DRM IOCTLs
	NTSTATUS processIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
	NTSTATUS processCommandBuffer(IN BYTE* InBuf, IN DWORD InLen, IN DWORD OutBufSize, IN OUT PIRP Irp);

	NTSTATUS initStream(BYTE* encText, struct ConnectStruct* Conn);
	static NTSTATUS InitializeConnection(PIRP Pirp);
	static NTSTATUS CleanupConnection(PIRP Pirp);
protected:
	NTSTATUS preSend(class SBuffer& Msg, struct ConnectStruct* Conn);
	NTSTATUS postReceive(BYTE* Data, DWORD DatLen, struct ConnectStruct* Conn);
	KCritMgr critMgr;			
};

NTSTATUS InitializeDriver();
NTSTATUS CleanupDriver();


extern KRMStubs* TheKrmStubs;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\mynew.h ===
#ifndef mynew_h
#define mynew_h

#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_


/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'3mrD');

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    if (pVoid) 
    {
        ExFreePool(pVoid);
    }
}


#endif //!_NEW_DELETE_OPERATORS_



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\krmstubs.cpp ===
#include "drmkPCH.h"

#include "KList.h"
#include "StreamMgr.h"
#include "SBuffer.h"
#include "CryptoHelpers.h"
#include "HandleMgr.h"
#include "KRMStubs.h"
#include "encraption.h"

//------------------------------------------------------------------------------
// 
// These are not the actual keys. The encraption algorithm in encraption.h
// is used to get clear keys.
//
static const BYTE DRMKpriv[20] = {

        0xDC, 0xC4, 0x26, 0xB2, 0x4F, 0x11, 0x24, 0x8A,
        0x51, 0xAC, 0x88, 0xF5, 0x47, 0x4B, 0xD5, 0x8C,
        0x3C, 0x45, 0x29, 0xA1};
static const BYTE DRMKCert[104] = {
        0xD4, 0x3F, 0xC8, 0x44, 0xCD, 0x86, 0x41, 0xE9,
        0x7C, 0x23, 0x36, 0xAD, 0xC3, 0x22, 0x4F, 0x27,
        0xC6, 0x1B, 0x5B, 0x9C, 0x75, 0x2A, 0x86, 0x32,
        0x7E, 0x37, 0x24, 0x8D, 0x2B, 0x51, 0xF6, 0x6A,
        0x31, 0x69, 0xA3, 0x66, 0xA8, 0x30, 0xC9, 0x4A,
        0x23, 0xCC, 0x30, 0xD8, 0x19, 0x19, 0x7B, 0x9A,
        0xF6, 0x32, 0xB5, 0xD8, 0x4C, 0x37, 0x1A, 0x91,
        0x13, 0x71, 0xF6, 0x63, 0x41, 0x1B, 0x1A, 0x06,
        0x57, 0xEC, 0x7A, 0xF8, 0x47, 0x41, 0xEF, 0x5E,
        0xB9, 0x02, 0xE9, 0xE9, 0xA1, 0x52, 0x34, 0xC4,
        0xCD, 0x7F, 0xDE, 0xF6, 0x09, 0x27, 0xE8, 0xB6,
        0x27, 0xF0, 0x93, 0xD8, 0xE2, 0x07, 0xD2, 0xD1,
        0x64, 0x8B, 0xF6, 0xD7, 0x57, 0x2C, 0xB2, 0x37};
//------------------------------------------------------------------------------
const DWORD KrmVersionNumber=100;
//------------------------------------------------------------------------------
KRMStubs* TheKrmStubs=NULL;
//------------------------------------------------------------------------------
DRM_STATUS GetKernelDigest(
    BYTE *startAddress, 
    ULONG len,
    DRMDIGEST *pDigest
)
{
    BYTE* seed = (BYTE*) "a3fs9F7012341234KS84Wd04j=c50asj4*4dlcj5-q8m;ldhgfddd";
    CBCKey key;
    CBCState state;
    CBC64Init(&key, &state, seed);
    CBC64Update(&key, &state, len/16*16, startAddress);
    pDigest->w1=CBC64Finalize(&key, &state, (UINT32*) &pDigest->w2);

    return DRM_OK;
} // GetKernelDigest

//------------------------------------------------------------------------------
KRMStubs::KRMStubs(){
	ASSERT(TheKrmStubs==NULL);
	TheKrmStubs=this;	
	return;
};
//------------------------------------------------------------------------------
KRMStubs::~KRMStubs(){
	return;
};
//------------------------------------------------------------------------------
// Main entry point for KRM IOCTL processing.  KRMINIT1 and KRMINIT2 are 
// plaintext commands, after this, the command block and the reply
// are digested and encrypted.
NTSTATUS KRMStubs::processIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp){

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    DWORD comm;
    DWORD inSize=irpStack->Parameters.DeviceIoControl.InputBufferLength;
    DWORD outSize=irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    DWORD bufSize=inSize>outSize?inSize:outSize;

    if(!critMgr.isOK()){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
        return STATUS_INSUFFICIENT_RESOURCES;
    };

    _DbgPrintF(DEBUGLVL_VERBOSE,("inSize, outSize %d, %d\n", inSize, outSize));

    for(DWORD j=0;j<inSize;j++){
        _DbgPrintF(DEBUGLVL_VERBOSE,("%x ", (DWORD) *(((BYTE*) Irp->AssociatedIrp.SystemBuffer)+j)));
    };

    return processCommandBuffer((BYTE* ) Irp->AssociatedIrp.SystemBuffer, inSize, outSize, Irp);
};	
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::processCommandBuffer(IN BYTE* InBuf, IN DWORD InLen, IN DWORD OutBufSize, IN OUT PIRP Irp){

    _DbgPrintF(DEBUGLVL_VERBOSE,("Process command buffer (command size= %d)", InLen));

    DWORD bufSize=InLen>OutBufSize?InLen:OutBufSize;

    //
    // We must have at least communication code + terminator input space.
    //
    if (bufSize < 2 * sizeof(DWORD)) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Input buffer too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT file=irpStack->FileObject;
    ConnectStruct* connection=TheHandleMgr->getConnection(file);
    if(connection==NULL) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Connection does not exist %d\n", file));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    };

    bool secureStreamWillStart=false;

    if(connection->secureStreamStarted) {
        if (STATUS_SUCCESS != postReceive(InBuf, InLen, connection)) {
            _DbgPrintF(DEBUGLVL_TERSE, ("PostReceive error"));
            return STATUS_BAD_DESCRIPTOR_FORMAT;
        }
    }

    SBuffer s(InBuf, bufSize);
    DWORD comm;
    s >> comm;
    if (KRM_OK != s.getLastError()) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Bad communication code"));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    //
    // if secure communication is not established reject all requests except
    // the initialization calls.
    //
    if (!connection->secureStreamStarted &&
        (_KRMINIT1 != comm && _KRMINIT2 != comm)) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Bad communication pattern"));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    DRM_STATUS stat;
    switch(comm){
        case _GETKERNELDIGEST:
        {
            //
            // ISSUE: 04/05/2002 ALPERS.
            // Note that this handler is not 64 bit compatible. Just follows
            // the rest of the property handler.
            //
            DWORD startAddress, len;
            DRMDIGEST newDigest = { 0, 0 };                

            s >> startAddress >> len;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            //
            // Make sure the output buffer can hold len bytes.
            //
            if (KRM_SUCCESS(stat)) {
                if (s.getLen() < sizeof(stat) + sizeof(newDigest) + sizeof(DWORD) + 64) {
                    stat = KRM_BUFSIZE;
                    _DbgPrintF(DEBUGLVL_TERSE, ("_GETKERNELDIGEST - invalid output buffer size"));                
                }
            }

            if (KRM_SUCCESS(stat)) {
                //
                // ISSUE: 04/05/2002 ALPERS
                // (SECURITY NOTE: Potential DOS attack)
                // Note that startAddress and Len are coming from user mode 
                // and there is no validation.
                // This IOCTL can only be send through the secure IOCTL 
                // interface. In order to attack here, the attacker has to
                // figure out the secure IOCTL channel.
                // There is one level of defense.
                //
                // TODO: As a second line of defense, DRMK can collect the 
                // same module information and compare the given address
                // to its list.
                //
                // The reason we get the KernelAddress from UserMode is 
                // because of the relocation code in UserMode. The code reads
                // the driver image from disk, parses PE format and finds 
                // the section that contains the provingFunction.
                // startAddress is the beginning of the section that 
                // contains provingFunction.
                //
                stat = GetKernelDigest((BYTE *) ULongToPtr(startAddress), len, &newDigest);
            }

            s.reset();
            s << stat << newDigest.w1 << newDigest.w2;

            break;
        }
        //-----------------
        case _KRMINIT1:
        {
            // return the version number and the cert
            DWORD drmVersionNumber;
            CERT krmCert;

            s >> drmVersionNumber;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }
            
            if (KRM_SUCCESS(stat)) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("Doing KRMINIT1, for DRM version %d", drmVersionNumber));
                NTSTATUS Status = 
                    ClearKey(DRMKCert, (BYTE *) &krmCert, sizeof(DRMKCert), 5);
                if (NT_SUCCESS(Status)) {
                    s.reset();
                    s << (DWORD) KRM_OK << KrmVersionNumber;
                    s.append((BYTE*) &krmCert, sizeof(krmCert));
                    stat = s.getLastError();
                }
                else {
                    stat = KRM_SYSERR;
                }
            }
        
            if (!KRM_SUCCESS(stat)) {
                s.reset();
                s << stat;
            }
            
            break;
        };
        //-----------------
        case _KRMINIT2:
        {
            DWORD datLen;
            s >> datLen;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                DWORD bufLenShouldBe=PK_ENC_CIPHERTEXT_LEN;
                if (bufLenShouldBe == datLen) {
                    unsigned int pos;
                    stat = s.getGetPosAndAdvance(&pos, datLen);
                    if (KRM_SUCCESS(stat)) {
                        BYTE* cipherText=s.getBuf()+pos;
                        stat=initStream(cipherText, connection);
                        if (stat != DRM_OK) {
                            _DbgPrintF(DEBUGLVL_TERSE, ("BAD InitString"));
                        };
                    }
                } 
                else {
                    _DbgPrintF(DEBUGLVL_TERSE, ("KRMINIT2 - bad string"));
                    stat = KRM_SYSERR;
                };
            }
            
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            s.reset();
            s << stat;

            if (KRM_SUCCESS(stat)) {
                secureStreamWillStart=true;
            }

            break;
        };
        //-----------------
        case _CREATESTREAM:
        {
            KCritical sect(critMgr);
            DWORD handle;
            DRMRIGHTS rights; 
            STREAMKEY key;
            DWORD streamId = 0;
            
            s >> handle >> &rights >> &key;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            //
            // The input buffer is much bigger than output buffer.
            // Therefore we are sure that SBuffer has enough space
            // for the output buffer.
            //
            
            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->createStream(ULongToPtr(handle), &streamId, &rights, &key);
            }

            if (KRM_SUCCESS(stat)) {
                connection->streamId = streamId;
            }

            s.reset();
            s << stat << streamId;
            
            break;
        };
        //-----------------
        case _DESTROYSTREAM:
        {
            KCritical sect(critMgr);
            DWORD streamId;
            s >> streamId; 
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }
            
            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->destroyStream(streamId);
            }
            
            s.reset();
            s << stat;
            break;
        };
        //-----------------
        case _DESTROYSTREAMSBYHANDLE:
        {
            KCritical sect(critMgr);
            DWORD handle;
            s >> handle;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->destroyAllStreamsByHandle(ULongToHandle(handle));
            }

            s.reset();
            s << stat;
            break;
        };
        //-----------------
        case _WALKDRIVERS:
        {
            KCritical sect(critMgr);
            DWORD StreamId, MaxDrivers, len;
            s >> StreamId >> MaxDrivers;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            // check buffer size.
            if (KRM_SUCCESS(stat)) {
                len = sizeof(DWORD) * MaxDrivers;
                if ((s.getLen() < len + 64) || (len > len + 64)) {
                    stat = KRM_BUFSIZE;
                    _DbgPrintF(DEBUGLVL_TERSE,("_WALKDRIVERS : Invalid buffer size"));
                }
            }

            s.reset();
            if (KRM_SUCCESS(stat)) {
                if (MaxDrivers==0) {
                    // just check that the stream is good
                    DWORD errorCode;

                    stat = TheStreamMgr->getStreamErrorCode(StreamId, errorCode);
                    if (KRM_SUCCESS(stat)) {
                        stat = errorCode;
                    }
                    
                    if (KRM_SUCCESS(stat)) {
                        ULONG numDrivers;
                        stat = TheStreamMgr->walkDrivers(StreamId, NULL, numDrivers, 0);
                        if (KRM_SUCCESS(stat)) {
                            stat=TheStreamMgr->getStreamErrorCode(StreamId, errorCode);
                            if (KRM_SUCCESS(stat)) {
                                stat = errorCode;
                            }
                        }
                    }

                    //
                    // Due to difficulties in maintaining security in the presence of Verifier
                    // we return an error if Verifier is detected.
                    //
                    if (KRM_SUCCESS(stat)) {
                        ULONG VerifierFlags;
                        if (NT_SUCCESS(MmIsVerifierEnabled(&VerifierFlags))) {
                            stat = DRM_VERIFIERENABLED;
                        }
                    }
                    
                    s << stat << (DWORD) 0;
                }
                else {
                    // do a full authentication run
                    PVOID* drivers = new PVOID[MaxDrivers];
                    if (drivers!=NULL) {
                        DWORD numDrivers = 0;
                        stat = TheStreamMgr->walkDrivers(StreamId, drivers, numDrivers, MaxDrivers);

                        // Due to difficulties in maintaining security in the presence of Verifier
                        // we return an error if Verifier is detected.
                        if (KRM_SUCCESS(stat)) {
                            ULONG VerifierFlags;
                            if (NT_SUCCESS(MmIsVerifierEnabled(&VerifierFlags))) {
                                stat = DRM_VERIFIERENABLED;
                            }
                        }
                        
                        s << stat << numDrivers;

                        //
                        // We checked the buffer size upfront. This should not
                        // fail during stream operations.
                        //
                        if ((stat==DRM_OK) || 
                            (stat==DRM_BADDRMLEVEL) || 
                            (stat==DRM_VERIFIERENABLED)) {
                            // todo - perhaps a block copy
                            for (DWORD j = 0; j < numDrivers; j++) {
                                s << drivers[j];
                                ASSERT(KRM_SUCCESS(s.getLastError()));
                            };
                        } 

                        delete[] drivers;
                    } 
                    else {
                        // allocation failed
                        s << (DWORD) DRM_OUTOFMEMORY << (DWORD) 0;
                    };
                };
            }
            else {
                s << stat << (DWORD) 0;
            }
            break;
        }
        //-----------------
        default:
        {
            s.reset();
            s << KRM_BADIOCTL;
            break;
        };
    };

    term(s);
    //
    // We are ignoring if we cannot put the terminator here.
    // KRMProxy does not care anyway.
    //

    if (connection->secureStreamStarted) {
        //
        // ignore the return value. In case of failure we will have crap
        // in SBuffer. And we will return it to user mode.
        // 
        preSend(s, connection); 
    }
    if (secureStreamWillStart) {
        connection->secureStreamStarted = true;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("Returning %d bytes", s.getPutPos()));
    Irp->IoStatus.Information=s.getPutPos();

    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::initStream(BYTE* encText, ConnectStruct* Conn){
    PRIVKEY myPrivKey;
    NTSTATUS Status;

    Status = ClearKey(DRMKpriv, myPrivKey.x, sizeof(DRMKpriv), 2);
    if (NT_SUCCESS(Status)) {
        //
        // ISSUE: 04/24/2002 ALPERS
        // CDRMPKCrypto allocates memory in its constructor. If the memory
        // allocation fails, all functions in that object return error codes.
        // Yet we are not checking the error code from PKdecrypt.
        //
        CDRMPKCrypto decryptor;
        BYTE decryptedText[PK_ENC_PLAINTEXT_LEN];
        decryptor.PKdecrypt(&myPrivKey, encText, decryptedText);
        bv4_key_C(&Conn->serverKey, sizeof(decryptedText),decryptedText );
        CryptoHelpers::InitMac(Conn->serverCBCKey, Conn->serverCBCState, decryptedText, sizeof(decryptedText));
    }
    return Status;
};
//------------------------------------------------------------------------------
NTSTATUS InitializeDriver(){
    NTSTATUS DriverInitializeStatus;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("Initializing Driver"));
    
    // Note - these dynamic allocations are 'global objects' that offer services to 
    // the DRMK driver.
    // The services are referenced through the global pointers:
    //  TheStreamManager, TheTGBuilder, TheKrmStubs, and TheHandleMgr 
    void* temp=NULL;
    temp=new StreamMgr;
    if (temp) temp = new KRMStubs;
    if (temp) temp = new HandleMgr;
    if (temp) {
        DriverInitializeStatus = STATUS_SUCCESS;
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("operator::new failed in DRMK:InitializeDriver"));
        DriverInitializeStatus = STATUS_INSUFFICIENT_RESOURCES;
        CleanupDriver();
    }
    
    return DriverInitializeStatus;
};

//------------------------------------------------------------------------------
NTSTATUS CleanupDriver(){
    _DbgPrintF(DEBUGLVL_VERBOSE,("Cleaning up Driver"));
    delete TheStreamMgr;TheStreamMgr=NULL;
    delete TheKrmStubs;TheKrmStubs=NULL;
    delete TheHandleMgr;TheHandleMgr=NULL;
    return STATUS_SUCCESS;
};

//------------------------------------------------------------------------------
NTSTATUS KRMStubs::InitializeConnection(PIRP Pirp){
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Pirp);
    PFILE_OBJECT file=irpStack->FileObject;
    _DbgPrintF(DEBUGLVL_VERBOSE,("InititializeConnection %d", file));
    ConnectStruct* conn;
    bool ok=TheHandleMgr->newHandle(file, conn);
    if(!ok){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
        return STATUS_INSUFFICIENT_RESOURCES;
    };
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::CleanupConnection(PIRP Pirp){
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Pirp);
    PFILE_OBJECT file=irpStack->FileObject;
    _DbgPrintF(DEBUGLVL_VERBOSE,("CleanupConnection %x", file));
    ConnectStruct* conn=TheHandleMgr->getConnection(file);
    if(conn==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Connection does not exist "));
        return STATUS_INVALID_PARAMETER_1;
    };
    TheStreamMgr->destroyStream(conn->streamId);
    TheHandleMgr->deleteHandle(file);
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
// see twin function in KComm
NTSTATUS KRMStubs::preSend(class SBuffer& Msg, ConnectStruct* Conn){
    // first digest
    DRMDIGEST digest;
    DRM_STATUS stat=CryptoHelpers::Mac(Conn->serverCBCKey, Msg.getBuf(), Msg.getPutPos(), digest);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad MAC"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    Msg << &digest;
    stat = Msg.getLastError();
    if (KRM_OK == stat) {
        // then encrypt msg + digest
        stat=CryptoHelpers::Xcrypt(Conn->serverKey, Msg.getBuf(), Msg.getPutPos());
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad XCrypt"));
            return STATUS_DRIVER_INTERNAL_ERROR;
        };
    }
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
// see twin function in KComm
NTSTATUS KRMStubs::postReceive(BYTE* Data, DWORD DatLen,  ConnectStruct* Conn){
    _DbgPrintF(DEBUGLVL_VERBOSE,("PostReceive on %d", DatLen));
    // decrypt
    DRM_STATUS stat=CryptoHelpers::Xcrypt(Conn->serverKey, Data, DatLen);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad XCrypt(2)"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    // check digest
    DRMDIGEST digest;
    if (DatLen <= sizeof(DRMDIGEST)) return STATUS_INVALID_PARAMETER;
        stat=CryptoHelpers::Mac(Conn->serverCBCKey, Data, DatLen-sizeof(DRMDIGEST), digest);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad MAC(2)"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    DRMDIGEST* msgDigest=(DRMDIGEST*) (Data+DatLen-sizeof(DRMDIGEST));
    int match=memcmp(&digest, msgDigest, sizeof(DRMDIGEST));
    if(match==0)return STATUS_SUCCESS;
    memset(Data, 0, DatLen);
    _DbgPrintF(DEBUGLVL_VERBOSE,("MAC does not match(2)"));
    return STATUS_DRIVER_INTERNAL_ERROR;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\bv4.h ===
#ifndef bv4_h
#define bv4_h
#ifdef __cplusplus
extern "C" {
#endif

#define RC4_TABLESIZE 256
#define BV4_Y_TABLESIZE 32

typedef struct BV4_KEYSTRUCT
{
  unsigned char p_T[RC4_TABLESIZE];		
  unsigned char p_R, p_S;		
  DWORD p_alpha;				
  DWORD p_beta[BV4_Y_TABLESIZE];
} BV4_KEYSTRUCT;

void bv4_key_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf);
void bv4_C(BV4_KEYSTRUCT *pState, DWORD dwLen,unsigned char *buf);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\vroot.cpp ===
#include "drmkPCH.h"
#include <winerror.h>
#include "VRoot.h"
//------------------------------------------------------------------------------
VRoot::VRoot(){
	outPinType=IsUndefined;
	outPinUnk=NULL;
	outPinFileObject=NULL;
	outPinDeviceObject=NULL;
};
//------------------------------------------------------------------------------
DRM_STATUS VRoot::initiateValidation(PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject, DWORD StreamId){
	// validate myself - kick off by forwarding to myself
	outPinFileObject=OutPinFileObject;
	outPinDeviceObject = OutPinDeviceObject;
	outPinType=IsFileObject;
	myStreamId=StreamId;
	IUnknown* myUnk=static_cast<IUnknown*>(this);

	// numMethods is 3 (IUnknown) + 1 (IDrmAudioStream)
	ULONG numComMethods=3 + 1;
	NTSTATUS stat = DrmForwardContentToInterface(StreamId, myUnk, numComMethods);
	if(!NT_SUCCESS(stat)){
		_DbgPrintF(DEBUGLVL_VERBOSE,("DrmForwardContentToInterface(FILE_OBJECT) error on stream %d (Status=%d, %x)", StreamId, stat, stat));
		return stat;
	};
	// In the process of the above ForwardContent call weexpect some callbacks into 
	// StreamMgr telling us about DispatchTable and COM fucntions that will touch premium content
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS VRoot::initiateValidation(IUnknown* OutPin, DWORD StreamId){
	myStreamId=StreamId;
	outPinUnk=OutPin;
	outPinType=IsCOM;
	IUnknown* myUnk=static_cast<IUnknown*>(this);
	
	NTSTATUS stat = DrmForwardContentToInterface(StreamId, myUnk, 4);
	if(!NT_SUCCESS(stat)){
		_DbgPrintF(DEBUGLVL_VERBOSE,("DrmForwardContentToInterface(INTERFACE) error on stream %d (Status=%d, %x)", StreamId, stat, stat));
		return stat;
	};
	// In the process of the above ForwardContent call weexpect some callbacks into 
	// StreamMgr telling us about DispatchTable and COM fucntions that will touch premium content
	return DRM_OK;
};
//------------------------------------------------------------------------------
STDMETHODIMP VRoot::QueryInterface(REFIID iid, void ** ppInt){
	if(iid==IID_IUnknown){
		*ppInt=static_cast<void*> (this);
		AddRef();
		return S_OK;
	};
	if(iid==IID_IDrmAudioStream){
		*ppInt = static_cast<void*> (this);
		AddRef();
		return S_OK;
	};
	*ppInt=NULL;
	return E_NOINTERFACE;
};
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) VRoot::AddRef(void){
	return 0;
};
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) VRoot::Release(void){
	return 0;
};
//------------------------------------------------------------------------------
NTSTATUS __stdcall VRoot::SetContentId(IN ULONG ContentId, IN PCDRMRIGHTS DrmRights){

	DWORD theStreamId=  ContentId;
	_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot for %d on behest of %d", myStreamId, theStreamId));
	if(outPinType==IsCOM){
		if(outPinUnk==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot:: OutInterface not set for for stream %x", ContentId));
			return STATUS_INVALID_PARAMETER;
		}

		NTSTATUS stat = DrmForwardContentToInterface(theStreamId, outPinUnk, 4);
		return stat;
	};
	if(outPinType==IsFileObject){
		if(outPinFileObject==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot:: out FILE_OBJECT not set for for stream %x", ContentId));
			return STATUS_INVALID_PARAMETER;
		}
		DRMFORWARD DrmForward;
		RtlZeroMemory(&DrmForward, sizeof(DrmForward));
		DrmForward.Flags = 0;
		DrmForward.DeviceObject = outPinDeviceObject;
		DrmForward.FileObject = outPinFileObject;
		DrmForward.Context = outPinFileObject;
		DRM_STATUS stat=DrmForwardContentToDeviceObject(theStreamId, NULL, &DrmForward);
		return stat;
	};	
	// should not get here
	_DbgPrintF(DEBUGLVL_ERROR,("DRMK: No output pin set"));
	return STATUS_INVALID_PARAMETER;

};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\vroot.h ===
#ifndef VRoot_h
#define VRoot_h

// KS "Validation Root"
// Functions called to kick off the graph validation process, and provide
// the proving and validation functions for DRMK itself.

class VRoot: public IDrmAudioStream{
public:
	VRoot();
	DRM_STATUS initiateValidation(PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject, DWORD StreamId);
	DRM_STATUS initiateValidation(IUnknown* OutPin, DWORD StreamId);
	static NTSTATUS MyProvingFunction(PVOID AudioObject, PVOID DrmContext);
	NTSTATUS provingFunction(PVOID DrmContext);
	//  IUnknown
	STDMETHODIMP QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	IMP_IDrmAudioStream;
protected:
	DWORD myStreamId;
	
	// OutPin is FILE_OBJECT or IUnknown
	enum OutPinType{IsUndefined, IsFileObject, IsCOM};
	PFILE_OBJECT outPinFileObject;
	PDEVICE_OBJECT outPinDeviceObject;
	IUnknown* outPinUnk;
	OutPinType outPinType;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\streammgr.h ===
#ifndef StreamMgr_h
#define StreamMgr_h

// Handles DRM streams.  Each protected audio stream has a streamId generated
// by this class.  Each stream has rights information provided by DRM.  This 
// class is responsible for mapping DRM rights to kernel rights, streamId 
// lifetime managment and construction of composite streamIds required by
// mixers.
// Composite streams start 0x80000000.  Primary streams start at 0x0.  Simple
// streams can be tagged with the handle held by the process that created them.

// bug todo - primary and composite should be maps, not lists (probably)


#define INVALID_POS	0xffffffff

class StreamMgr{
public:
	StreamMgr();
	~StreamMgr();
	// these are called by DRM when streams are explicitly created and destroyed
	DRM_STATUS createStream(HANDLE Handle, DWORD* StreamId, const DRMRIGHTS* RightsStruct, IN STREAMKEY* Key);
	DRM_STATUS destroyStream(DWORD StreamId);
	// this is called when the KRM-handle is closed (by whatever means)
	DRM_STATUS destroyAllStreamsByHandle(HANDLE Handle);
	// This is called by the KS2 graph when a mixer is encountered
	DRM_STATUS createCompositeStream(OUT DWORD* StreamId, IN DWORD* StreamInArray, DWORD NumStreams);
	DRM_STATUS destroyCompositeStream(IN DWORD CompositeStreamId);
	// get a key for a primary stream
	DRM_STATUS getKey(IN DWORD StreamId, OUT STREAMKEY*& Key);
	// query rights for primary or composite streams
	DRM_STATUS getRights(DWORD StreamId,DRMRIGHTS* Rights);
	// notify of new proving function associated with a stream.
	DRM_STATUS addProvingFunction(DWORD StreamId,PVOID Func);
	// initiate driver graph walk 
	DRM_STATUS walkDrivers(DWORD StreamId, PVOID* ProveFuncList, DWORD& NumDrivers, DWORD MaxDrivers);
	// allow drmk filter to inform StreamMgr of output pin (several forms) 
	DRM_STATUS setRecipient(IN DWORD StreamId, IN PFILE_OBJECT OutPinFileObject, IN PDEVICE_OBJECT OutPinDeviceObject);
	DRM_STATUS setRecipient(IN DWORD StreamId, IN IUnknown* OutPin);
	DRM_STATUS clearRecipient(IN DWORD StreamId);
	
	// authentication errors can be 'logged to a stream'
	void logErrorToStream(IN DWORD StreamId, DWORD ErrorCode);
	// Query error-status of (primary) streams
	DRM_STATUS getStreamErrorCode(IN DWORD StreamId, OUT DWORD& ErrorCode);
	DRM_STATUS clearStreamError(IN DWORD StreamId);

	// fatal errors (e.g. memory starvation) should switch off all stream.
	void setFatalError(DWORD ErrorCode);
	NTSTATUS getFatalError();

	KCritMgr& getCritMgr(){return critMgr;};

protected:
	enum OutPinType{IsUndefined, IsInterface, IsHandle};
	// Describes a primary stream
	struct StreamInfo{
		DWORD StreamId;
		HANDLE Handle;
		STREAMKEY Key;		
		DRMRIGHTS Rights;
		KList<PVOID> proveFuncs;
		BOOL newProveFuncs;
		OutPinType OutType;
		PFILE_OBJECT OutPinFileObject;
		PDEVICE_OBJECT OutPinDeviceObject;
		PUNKNOWN OutInt;
		BYTE* drmFormat;
		bool streamWalked;
		DRM_STATUS streamStatus;
	};
	// describes a composite stream
	struct CompositeStreamInfo{
		DWORD StreamId;
		KList<DWORD> parents;
	};
	//-----------
	bool addStream(StreamInfo& NewInfo);
	POS getStreamPos(DWORD StreamId);
	void deleteStreamAt(bool primary,POS pos);
	bool isPrimaryStream(DWORD StreamId);
	StreamInfo* getPrimaryStream(DWORD StreamId);
	CompositeStreamInfo* getCompositeStream(DWORD StreamId);
	DRM_STATUS getRightsWorker(DWORD StreamId, DRMRIGHTS* Rights);
	void logErrorToStreamWorker(IN DWORD StreamId, DWORD ErrorCode);

	//-----------
	DWORD nextStreamId;
	DWORD nextCompositeId;
	KList<StreamInfo*> primary;
	KList<CompositeStreamInfo*> composite;
	KCritMgr critMgr;
	volatile NTSTATUS criticalErrorCode;
};


extern StreamMgr* TheStreamMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\cbckey.h ===
//-----------------------------------------------------------------------------
//
// File:   cbckey.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------


#ifndef __CBCMAC_H__
#define __CBCMAC_H__

// #define _TEST_MAC to compile code in a "default" environment
#ifndef _TEST_MAC
#define _TEST_MAC
#endif

#ifdef _TEST_MAC
#define SHCLASS
#endif


typedef struct _CBCKey {
    UINT32 a1, b1, c1, d1, e1, f1, a2, b2, c2, d2, e2, f2;
} CBCKey;

UINT32 CBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key );

UINT32 InvCBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key,
		  CBCKey ikey );

UINT32 inv32(UINT32 n);

typedef struct {
  UINT32 sum,t;
  BYTE buf[8];
  DWORD dwBufLen;
} CBCState;

void CBC64Init( CBCKey *cbckey, CBCState *cbcstate, BYTE *pKey );
void CBC64InitState( CBCState *cbcstate );
void CBC64InvKey( CBCKey *cbcKey, CBCKey *cbcInvKey );
void CBC64Update( CBCKey *key, CBCState *cbcstate,DWORD dwLen, BYTE *pData );
UINT32 CBC64Finalize( CBCKey *key, CBCState *cbcstate, UINT32 *pKey2 );
UINT32 CBC64Invert( CBCKey *key, CBCKey *ikey, UINT32 MacA1, UINT32 MacA2,
		UINT32 MacB1, UINT32 MacB2, UINT32 *pInvKey2 );









#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\drmkmain\streammgr.cpp ===
#include "drmkPCH.h"
#include "KList.h"
#include "VRoot.h"
#include "StreamMgr.h"
//------------------------------------------------------------------------------
StreamMgr* TheStreamMgr=NULL;
// 'secondary root - lowest secondary stream ID
#define SEC_ROOT 0x80000000
//------------------------------------------------------------------------------
StreamMgr::StreamMgr(){
	TheStreamMgr=this;
	nextStreamId=1;
	nextCompositeId=SEC_ROOT+1;
	criticalErrorCode=STATUS_SUCCESS;
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		criticalErrorCode=STATUS_INSUFFICIENT_RESOURCES;
	};
	return;
};
//------------------------------------------------------------------------------
StreamMgr::~StreamMgr(){
    {
        KCritical s(critMgr);
        POS p=primary.getHeadPosition();
        while(p!=NULL){
            StreamInfo* info=primary.getNext(p);
            delete info;
        };
        p=composite.getHeadPosition();
        while(p!=NULL){
            CompositeStreamInfo* info=composite.getNext(p);
            delete info;
        };
    };
    return;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::createStream(HANDLE Handle, DWORD* StreamId, 
                                   const DRMRIGHTS* RightsStruct, IN STREAMKEY* Key){
	
	*StreamId = 0xFFFFffff;
	StreamInfo* newInfo=new StreamInfo;
	if(newInfo==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};

	newInfo->StreamId=nextStreamId++;
	newInfo->Handle=Handle;
	newInfo->Key= *Key;
	newInfo->Rights= *RightsStruct;
	newInfo->drmFormat=NULL;
	newInfo->streamStatus=DRM_OK;
	newInfo->streamWalked=false;
	newInfo->newProveFuncs=false;
	
	newInfo->OutType=IsUndefined;
	newInfo->OutInt=NULL;
	newInfo->OutPinFileObject=NULL;
	newInfo->OutPinDeviceObject=NULL;
	bool ok=addStream(*newInfo);
	if(!ok){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		delete newInfo;
		return DRM_OUTOFMEMORY;		
	};
	*StreamId= newInfo->StreamId;
	return KRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::destroyStream(DWORD StreamId){
    KCritical s(critMgr);
    if(StreamId==0){
        return KRM_OK;
    };
    POS pos=getStreamPos(StreamId);
    if(pos==NULL)return KRM_BADSTREAM;
    bool primary=StreamId<SEC_ROOT;
    deleteStreamAt(primary, pos);
    return KRM_OK;
};
//------------------------------------------------------------------------------
// The 'handle' allows streams to be collected into a group and deleted together.
// It is mostly for debugging
DRM_STATUS StreamMgr::destroyAllStreamsByHandle(HANDLE Handle){
    KCritical s(critMgr);
    POS p=primary.getHeadPosition();
    while(p!=NULL){
            POS oldP=p;
            StreamInfo* stream=primary.getNext(p);
            if(stream->Handle==Handle){
                    delete stream;
                    primary.removeAt(oldP);
            };
    };
    return KRM_OK;
};
//------------------------------------------------------------------------------
// Called by a filter to instuct StreamMgr that a mixed stream is being created.
DRM_STATUS StreamMgr::createCompositeStream(OUT DWORD* StreamId, IN DWORD* StreamInArray, DWORD NumStreams){
	KCritical s(critMgr);
	CompositeStreamInfo* newStream=new CompositeStreamInfo;;
	if(newStream==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};
	for(DWORD j=0;j<NumStreams;j++){
		if(StreamInArray[j]==0)continue;
		bool ok=newStream->parents.addTail(StreamInArray[j]);
		if(!ok){
			delete newStream;
			_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
			return DRM_OUTOFMEMORY;		
		};
	};
	newStream->StreamId=nextCompositeId++;
	bool ok=composite.addTail(newStream);
	if(!ok){
		delete newStream;
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};
	*StreamId=newStream->StreamId;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::destroyCompositeStream(IN DWORD CompositeStreamId){
	bool primary=(CompositeStreamId<SEC_ROOT);
	ASSERT(!primary);
	if(primary)return KRM_BADSTREAM;
	return destroyStream(CompositeStreamId);
};
//------------------------------------------------------------------------------
// get the data encryption key for a stream.
DRM_STATUS StreamMgr::getKey(IN DWORD StreamId, OUT STREAMKEY*& Key){
	KCritical s(critMgr);
	Key=NULL;
	if(StreamId>=SEC_ROOT)return KRM_NOTPRIMARY;
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return KRM_BADSTREAM;
	Key=&(primary.getAt(pos)->Key);
	return KRM_OK;
};
//------------------------------------------------------------------------------
bool StreamMgr::addStream(StreamInfo& NewInfo){
	KCritical s(critMgr);
	return primary.addTail(&NewInfo);
};
//------------------------------------------------------------------------------
POS StreamMgr::getStreamPos(DWORD StreamId){
	KCritical s(critMgr);
	if(StreamId<SEC_ROOT){
		POS p=primary.getHeadPosition();
		while(p!=NULL){
			POS oldPos=p;
			if(primary.getNext(p)->StreamId==StreamId)return oldPos;
		};
		return NULL;
	} else {
		POS p=composite.getHeadPosition();
		while(p!=NULL){
			POS oldPos=p;
			if(composite.getNext(p)->StreamId==StreamId)return oldPos;
		};
		return NULL;
	};
};
//------------------------------------------------------------------------------
void StreamMgr::deleteStreamAt(bool Primary,POS pos){
	KCritical s(critMgr);
	if(Primary){
		StreamInfo* it=primary.getAt(pos);
		primary.removeAt(pos);
		delete it;
	} else {
		CompositeStreamInfo* it=composite.getAt(pos);
		composite.removeAt(pos);
		delete it;
	};
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::getRights(DWORD StreamId,DRMRIGHTS* Rights){
	KCritical s(critMgr);
    DEFINE_DRMRIGHTS_DEFAULT(DrmRightsDefault);
    *Rights = DrmRightsDefault;
	return getRightsWorker(StreamId, Rights);
};
//------------------------------------------------------------------------------
bool StreamMgr::isPrimaryStream(DWORD StreamId){
	return StreamId<SEC_ROOT;
};
//------------------------------------------------------------------------------
// called recursively from the getRights parent
DRM_STATUS StreamMgr::getRightsWorker(DWORD StreamId, DRMRIGHTS* Rights){
	if(isPrimaryStream(StreamId)){
		if(StreamId==0){
			// stream is unprotected - no further restrictions
			return DRM_OK;
		};
		// else a protected primary stream
		POS p=getStreamPos(StreamId);
		if(p==NULL){
			// if the primary stream has gone, then it does not care about
			// the stream rights.   We do not flag an error
			_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (getRightsWorker) %x", StreamId));
			return KRM_OK;
		};
		StreamInfo* s=primary.getAt(p);
		// set rights to most restrictive of current stream and current settings
		if(s->Rights.CopyProtect)Rights->CopyProtect=TRUE;
		if(s->Rights.DigitalOutputDisable)Rights->DigitalOutputDisable=TRUE;
		return DRM_OK;
	} else {
		// For composite streams, any of the parent streams can reduce the 
		// current settings.  We descend to the primary parents thru recursion.
		// Note, for this to work, we must have 'monotonic rights' - there should
		// be no case where two components disagree on 'more restrictive'
		POS pos=getStreamPos(StreamId);
		if(pos==NULL){
			_DbgPrintF(DEBUGLVL_BLAB,("Bad secondary stream"));
			Rights->CopyProtect=TRUE;
			Rights->DigitalOutputDisable=TRUE;
			return KRM_BADSTREAM;
		};
		CompositeStreamInfo* thisComp=composite.getAt(pos);
		
		POS p=thisComp->parents.getHeadPosition();
		while(p!=NULL){
			DWORD streamId=thisComp->parents.getNext(p);
			if(streamId==0)continue;	// unprotected - no change to rights
			// else allow the parent stream (and its parents) to 
			// further restrict rights
			DRM_STATUS stat=getRightsWorker(streamId, Rights);
			if(stat!=DRM_OK)return stat;
		};
	};
	return DRM_OK;
};
//------------------------------------------------------------------------------
// Proving function is only of interest to parent stream.  We recurse up the
// stream parentage to all parents and add the proving fucntion to their lists.
DRM_STATUS StreamMgr::addProvingFunction(DWORD StreamId,PVOID Func){
	KCritical s(critMgr);
	
	if(isPrimaryStream(StreamId)){
		StreamInfo* si=getPrimaryStream(StreamId);
		if(si==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Bad primary stream (addProveFunc) %x", StreamId));
			return DRM_BADPARAM;
		};
		// check to see if we already have this provinFunc
		POS p=si->proveFuncs.getHeadPosition();
		while(p!=NULL){
			PVOID addr=si->proveFuncs.getNext(p);	
			if(addr==Func)return DRM_OK;
		};
		// if not, add it...
		bool ok=si->proveFuncs.addTail(Func);
		if(!ok){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
			return DRM_OUTOFMEMORY;		
		};
		si->newProveFuncs = TRUE;
		return DRM_OK;
	}; 
	// else is secondary...recurse to root.
	CompositeStreamInfo* comp=getCompositeStream(StreamId);
	if(comp==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Bad streamId %x", StreamId));
		return DRM_BADPARAM;
	};
	POS p=comp->parents.getHeadPosition();
	while(p!=NULL){
		DWORD parentId=comp->parents.getNext(p);
		addProvingFunction(parentId, Func);
	};
	return DRM_OK;
};
//------------------------------------------------------------------------------
StreamMgr::StreamInfo* StreamMgr::getPrimaryStream(DWORD StreamId){
	KCritical s(critMgr);
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return NULL;
	return primary.getAt(pos);
};
//------------------------------------------------------------------------------
StreamMgr::CompositeStreamInfo* StreamMgr::getCompositeStream(DWORD StreamId){
	KCritical s(critMgr);
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return NULL;
	return composite.getAt(pos);
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::walkDrivers(DWORD StreamId, PVOID* ProveFuncList, DWORD& NumDrivers, DWORD MaxDrivers)
{
    DRM_STATUS stat;
    VRoot root;
    PFILE_OBJECT OutPinFileObject;
    PDEVICE_OBJECT OutPinDeviceObject;
    PUNKNOWN OutInt;

    OutPinFileObject = NULL;
    OutPinDeviceObject = NULL;
    OutInt = NULL;

    {
    	KCritical s(critMgr);
        StreamInfo* stream;

    	stream=getPrimaryStream(StreamId);
    	if(stream==NULL)return KRM_BADSTREAM;
    	if (0 != MaxDrivers) stream->proveFuncs.empty();
    	stream->newProveFuncs=false;
    	stream->streamStatus=DRM_OK;
    	if(stream->OutType==IsUndefined){
            NumDrivers=0;
            // no output stream.
            _DbgPrintF(DEBUGLVL_VERBOSE,("No registered output module for stream %x", StreamId));
            return KRM_BADSTREAM;
    	};

        //
        // We must reference the downstream object or interface before
        // releasing the StreamMgr mutex (i.e., before KCritical s goes out of
        // scope).  Otherwise the downstream object/interface might be
        // destroyed after we release the StreamMgr mutex but before we
        // initiate validation on the downstream object/interface.
        //

        if ((stream->OutType == IsHandle) && stream->OutPinFileObject && stream->OutPinDeviceObject)
        {
            OutPinFileObject = stream->OutPinFileObject;
            OutPinDeviceObject = stream->OutPinDeviceObject;
        }
        else if ((stream->OutType == IsInterface) && stream->OutInt)
        {
            OutInt = stream->OutInt;
        }

        if (OutPinFileObject) ObReferenceObject(OutPinFileObject);
        if (OutInt) OutInt->AddRef();
    }

    if (OutPinFileObject) stat = root.initiateValidation(OutPinFileObject, OutPinDeviceObject, StreamId);
    if (OutInt) stat = root.initiateValidation(OutInt, StreamId);

    if (OutPinFileObject) ObDereferenceObject(OutPinFileObject);
    if (OutInt) OutInt->Release();

    {
        KCritical s(critMgr);
        StreamInfo* stream;
        
        // If STATUS_NOT_IMPLEMENTED, see if stream had DRM_RIGHTSNOTSUPPORTED logged as an error
        if (STATUS_NOT_IMPLEMENTED == stat) {
            DWORD errorStream;
            if (DRM_OK == TheStreamMgr->getStreamErrorCode(StreamId, errorStream)) {
                if (DRM_RIGHTSNOTSUPPORTED == errorStream) {
                    stat = errorStream;
                }
            }
        }


        //Check to see if the stream had DRM_BADDRMLEVEL set.  This return
        //code indicates that one or more drivers called
        //DrmForwardContentToFileObject, but otherwise no fatal errors
        //occurred.  This should be treated as a success with the return
        //code propagated to the caller.
        {
            DWORD errorStream;
            if (DRM_OK == TheStreamMgr->getStreamErrorCode(StreamId, errorStream)) {
                if (DRM_BADDRMLEVEL == errorStream) {
                    stat = errorStream;
                }
            }
        }

               
        // Although it would probably be due to a user-mode bug, we should not
        // assume that stream is still valid.  Let's get the stream once again
        // from the StreamId
        stream=getPrimaryStream(StreamId);
        if(stream==NULL)return KRM_BADSTREAM;

        // pass out the array of ProveFuncs	(there might've been an error, but we pass out what we can)
        POS p=stream->proveFuncs.getHeadPosition();
        DWORD count=0;
        while(p!=NULL){
            PVOID pf=stream->proveFuncs.getNext(p);
            if(count<MaxDrivers){
            	ProveFuncList[count]=pf;
            };
            count++;
        };
        NumDrivers=count;
        // if there was an error on the walk, return that too.
        if((stat!=DRM_OK) && (DRM_BADDRMLEVEL!=stat)){
        	// bug - todo - return some useful information
        	_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot::initiateValidation(streeamId=%d)  returned  (%d, %x)", StreamId, stat, stat));
        	NumDrivers=0;
        	return stat;
        };

        // if checking stack and new funcs were added
        if ((0 == MaxDrivers) && (stream->newProveFuncs))
        	return DRM_AUTHREQUIRED;

        // and finally, inform if there was insufficient buffer space.

        if((0 == MaxDrivers) || (count<MaxDrivers))
        	return (DRM_OK == stat) ? KRM_OK : stat;
        else 
        	return KRM_BUFSIZE;
    }
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::setRecipient(DWORD StreamId, PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutPinFileObject=OutPinFileObject;
	stream->OutPinDeviceObject=OutPinDeviceObject;
	stream->OutType=IsHandle;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::setRecipient(DWORD StreamId, PUNKNOWN OutInt){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutInt=OutInt;
	stream->OutType=IsInterface;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::clearRecipient(IN DWORD StreamId){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutType=IsUndefined;
    stream->OutPinFileObject = NULL;
    stream->OutPinDeviceObject = NULL;
    stream->OutInt = NULL;
	return DRM_OK;
};
//------------------------------------------------------------------------------
void StreamMgr::logErrorToStream(IN DWORD StreamId, DWORD ErrorCode){
	KCritical s(critMgr);
	logErrorToStreamWorker(StreamId, ErrorCode);
	return;
};
//------------------------------------------------------------------------------
void StreamMgr::logErrorToStreamWorker(IN DWORD StreamId, DWORD ErrorCode){
	// don't allow an error to be cancelled too easily
	if(ErrorCode==0)return;
	if(isPrimaryStream(StreamId)){
		StreamInfo* info=getPrimaryStream(StreamId);
		if(info==NULL){
			_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (logErrorToStreamWorker) %x", StreamId));
			// if a primary stream does not exist, this is not considered
			// to be sufficient to set the panic flag.
			return;
		};
		info->streamStatus=ErrorCode;
		return;
	};
	CompositeStreamInfo* comp=getCompositeStream(StreamId);
	ASSERT(comp!=NULL);
	if(comp==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Bad streamId %x", StreamId));
		// if the secondary stream does not exist, we do not know what streams
		// are affected by the error, so the only safe thing is to panic.
		setFatalError(KRM_BADSTREAM);
		return;
	};
	// log the error with all of the streams parents, recursing back to the
	// primary streams.
	POS p=comp->parents.getHeadPosition();
	while(p!=NULL){
		DWORD parentId=comp->parents.getNext(p);
		logErrorToStreamWorker(parentId, ErrorCode);
	};
	return;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::getStreamErrorCode(IN DWORD StreamId, OUT DWORD& ErrorCode){
	KCritical s(critMgr);
	StreamInfo* info=getPrimaryStream(StreamId);
	ErrorCode=DRM_AUTHFAILURE;
	if(info==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream(getStreamErrorCode) %x", StreamId));
		return KRM_BADSTREAM;
	};
	ErrorCode=info->streamStatus;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::clearStreamError(IN DWORD StreamId){
	KCritical s(critMgr);
	StreamInfo* info=getPrimaryStream(StreamId);
	if(info==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (clearStreamError) %x", StreamId));
		return KRM_BADSTREAM;
	};
	info->streamStatus=DRM_OK;
	return DRM_OK;
};
//------------------------------------------------------------------------------
void StreamMgr::setFatalError(DWORD ErrorCode){
	if(criticalErrorCode!=STATUS_SUCCESS) return;
	criticalErrorCode=ErrorCode;
};
//------------------------------------------------------------------------------
NTSTATUS StreamMgr::getFatalError(){
	return criticalErrorCode;
};

//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\cryptohelpers.h ===
#ifndef CryptoHelpers_h
#define CryptoHelpers_h

#include "CBCKey.h"
class CryptoHelpers{
public:
	static DRM_STATUS InitMac(CBCKey& macKey, CBCState& macState,BYTE* Data, DWORD DatSize);
	static DRM_STATUS Mac(CBCKey& Key, BYTE* Data, DWORD DatLen, OUT DRMDIGEST& Digest);
	static DRM_STATUS Xcrypt(STREAMKEY& Key, BYTE* Data, DWORD DatLen);

protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\punknown.h ===
/*****************************************************************************
 * punknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (C) Microsoft Corporation, 1996 - 1999
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif


DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x46);

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\drmerrs.h ===
#ifndef drmerrs_h
#define drmerrs_h
 
typedef long DRM_STATUS;

// bug - don't know how to assign this
#define DRM_ERROR_ROOT                  0x80000000

// DRM-generated errors 
#define DRM_OK                          0
#define DRM_SYSERR                      DRM_ERROR_ROOT + 100	 // bad - assert-like error
#define DRM_KRM_NOT_RUNNING             DRM_ERROR_ROOT + 101
#define DRM_KRM_COMMS                   DRM_ERROR_ROOT + 102
#define DRM_FILENOTFOUND                DRM_ERROR_ROOT + 103
#define DRM_FILEERR                     DRM_ERROR_ROOT + 104
#define DRM_BADFILE                     DRM_ERROR_ROOT + 105
#define DRM_BADTYPE                     DRM_ERROR_ROOT + 106
#define DRM_DEVENUMERATE                DRM_ERROR_ROOT + 107
#define DRM_DEVDETAIL                   DRM_ERROR_ROOT + 108
#define DRM_KRMNOTFOUND                 DRM_ERROR_ROOT + 109
#define DRM_NOTTRUSTED                  DRM_ERROR_ROOT + 110
#define DRM_FILENOTINCAT                DRM_ERROR_ROOT + 111
#define DRM_BADHANDLE                   DRM_ERROR_ROOT + 112
#define DRM_AUTHFAILURE                 DRM_ERROR_ROOT + 113
#define DRM_BADDRIVER                   DRM_ERROR_ROOT + 114
#define DRM_BADPARAM                    DRM_ERROR_ROOT + 115
#define DRM_BADKRMCERTSIG               DRM_ERROR_ROOT + 116
#define DRM_BADKRMCERT                  DRM_ERROR_ROOT + 117
#define DRM_OUTOFMEMORY                 DRM_ERROR_ROOT + 118
#define DRM_BADLIBRARY                  DRM_ERROR_ROOT + 119
#define DRM_MISSINGLIBRARY              DRM_ERROR_ROOT + 120
#define DRM_MISSINGDLL                  DRM_ERROR_ROOT + 122
#define DRM_BADPROVINGFUNCTION          DRM_ERROR_ROOT + 123
#define DRM_DATALENGTH                  DRM_ERROR_ROOT + 124
#define DRM_BUFSIZE                     DRM_ERROR_ROOT + 125
#define DRM_AUTHREQUIRED                DRM_ERROR_ROOT + 126
#define DRM_BADDRMLEVEL                 DRM_ERROR_ROOT + 127
#define DRM_NODRMATTRIB                 DRM_ERROR_ROOT + 128
#define DRM_RIGHTSNOTSUPPORTED          DRM_ERROR_ROOT + 129
#define DRM_VERIFIERENABLED             DRM_ERROR_ROOT + 130

// KRM-DRM comms
#define KRM_OK                          0
#define KRM_BADIOCTL                    DRM_ERROR_ROOT + 200
#define KRM_BUFSIZE                     DRM_ERROR_ROOT + 201
#define KRM_BADALIGNMENT                DRM_ERROR_ROOT + 202
#define KRM_BADADDRESS                  DRM_ERROR_ROOT + 203
#define KRM_OUTOFHANDLES                DRM_ERROR_ROOT + 204
#define KRM_BADSTREAM                   DRM_ERROR_ROOT + 205
#define KRM_SYSERR                      DRM_ERROR_ROOT + 206    // bad - assert-like error
#define DRM_BADKRMVERSION               DRM_ERROR_ROOT + 207
#define KRM_BADTERMINATOR               DRM_ERROR_ROOT + 208

// mist KRM errors
#define KRM_NOTPRIMARY                  DRM_ERROR_ROOT + 300

// macros
#define KRM_SUCCESS(x) (KRM_OK == x)

// DRM Errors that will be propaged to users
#define DRM_INVALIDPROVING              DRM_ERROR_ROOT + 1000   // Proving function is not in text seg
#define DRM_BADIMAGE                    DRM_ERROR_ROOT + 1001   // Image digest does not match PE file

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\sbuffer.h ===
#ifndef SBuffer_h
#define SBuffer_h

#include "KrmCommStructs.h"

class SBuffer{
friend DRM_STATUS checkTerm(SBuffer& S);
public:
    SBuffer(BYTE* Buf, unsigned int Len);   // caller supplied;
    void reset();                           // reset get/put pointer
    ~SBuffer();

    // Insertion operators
    SBuffer& operator << (const DWORD Val);
    SBuffer& operator << (const PVOID Ptr);
    SBuffer& operator << (const PDRMRIGHTS R);
    SBuffer& operator << (const PSTREAMKEY S);
    SBuffer& operator << (const PCERT C);
    SBuffer& operator << (const PDRMDIGEST D);

    // Extraction operators
    SBuffer& operator >> (DWORD& Val);
    SBuffer& operator >> (PDRMRIGHTS R);
    SBuffer& operator >> (PSTREAMKEY S);
    SBuffer& operator >> (PCERT C);

    // buffer access
    BYTE* getBuf(){return buf;};
    unsigned int getPutPos(){return putPos;};
    unsigned int getLen(){return len;};
    DRM_STATUS getGetPosAndAdvance(unsigned int *pos, unsigned int Len);
    DRM_STATUS getPutPosAndAdvance(unsigned int *pos, unsigned int Len);
    DRM_STATUS append(BYTE* Data, DWORD datLen);

    // error return
    DRM_STATUS getLastError(){return lasterror;};

protected:
    void err(const char* Msg, DRM_STATUS err);

    DRM_STATUS lasterror;
    unsigned int len;
    unsigned int getPos, putPos;
    BYTE* buf;
};

// sentinels
DRM_STATUS term(SBuffer& S);
DRM_STATUS checkTerm(SBuffer& S);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\ukshared\cryptohelpers.cpp ===
#include "uksPCH.h"
#include "DrmErrs.h"
#include "CBCKey.h"
#include "KrmCommStructs.h"
#include "CryptoHelpers.h"
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::InitMac(CBCKey& macKey, CBCState& macState,BYTE* Data, DWORD DatSize){
	STREAMKEY myKey;
	bv4_key_C(&myKey, DatSize, Data);
	BYTE buf[64];
	memset(buf, 0, sizeof(buf));
	bv4_C(&myKey, 64, buf);
	CBC64Init(&macKey, &macState, buf);
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::Mac(CBCKey& Key, BYTE* Data, DWORD DatLen, OUT DRMDIGEST& Digest){
	CBCState state;
	CBC64InitState(&state);
	CBC64Update(&Key, &state, DatLen, Data);
	Digest.w1=CBC64Finalize(&Key, &state, &Digest.w2);
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::Xcrypt(STREAMKEY& Key, BYTE* Data, DWORD DatLen){
	bv4_C(&Key, DatLen, Data);
	return DRM_OK;
};
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\krmcommstructs.h ===
#ifndef krmcommsstructs_h
#define krmcommsstructs_h

#include "BV4.h"
#include "pkcrypto.h"

// symmetric stream key
typedef  BV4_KEYSTRUCT STREAMKEY, *PSTREAMKEY;

// DRM message and file digest
typedef struct DRMDIGESTtag{
    UINT32 w1;
    UINT32 w2;
} DRMDIGEST, *PDRMDIGEST;

// Connection structure (to build test graphs)
struct Conn{
    DWORD src;
    DWORD dest;
};

//----------------ECC cert section -----------------------
#define VERSION_LEN          4
#define DATE_LEN             4
#define RIGHTS_LEN           4
#define APPSEC_LEN           4
#define SER_NUM_LEN          4
#define ISSUER_LEN           4
#define SUBJ_LEN             4
#define INT_LEN              4

#define USER_MODE_X
typedef struct CERTDATAtag{
    PUBKEY pk;
    BYTE expiryDate[DATE_LEN];
    BYTE serialNumber[SER_NUM_LEN];
    BYTE issuer[ISSUER_LEN];
    BYTE subject[SUBJ_LEN];
} CERTDATA, *PCERTDATA;


typedef struct CERTtag{
    BYTE certVersion[VERSION_LEN];
    BYTE datalen[INT_LEN];
    BYTE sign[PK_ENC_SIGNATURE_LEN];
    CERTDATA cd;
} CERT, *PCERT;

typedef struct __DrmHandleTag {void* P;} *__DrmHandle;
typedef struct __StreamHandleTag {void* P;} *__StreamHandle;

// These "typed handles" are references to a KRM connection and a stream respectively
typedef __DrmHandle DRMHANDLE, *PDRMHANDLE;
typedef __StreamHandle STREAMHANDLE, *PSTREAMHANDLE;

// Definitions for driver authentication failures and callbacks
enum AuthFailureEnum {AuthOK, AuthNoCert, AuthNoDRMBit, AuthTampered, AuthCantParse, AuthBadProvingFunc, AuthBadImage};
typedef struct AUTHSTRUCTtag{
    char path[MAX_PATH];
    enum AuthFailureEnum type;
} AUTHSTRUCT , *PAUTHSTRUCT;
typedef void (*AuthFail)(DWORD StreamId, AUTHSTRUCT* Comp, DWORD NumComponents, PVOID Context);


// KRM operation ordinals
#define _KRMINIT                    1
#define _GETKERNELDATA              2 // not used.
#define _CREATESTREAM               3
#define _DESTROYSTREAM              4
#define _DESTROYSTREAMSBYHANDLE     5
#define _WALKDRIVERS                6
#define _KRMINIT1                   7
#define _KRMINIT2                   8
#define _DENUM                      9 // not used.
#define _GETKERNELDIGEST            12

typedef NTSTATUS DRM_STATUS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\inc\pkcrypto.h ===
//-----------------------------------------------------------------------------
//
// File:   pkcrypto.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//  public key crypto library
//
// Author:	marcuspe
//
//-----------------------------------------------------------------------------

#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__


/*
#ifdef USER_MODE
#include <wtypes.h>
#else
#define S_OK 0
#define E_FAIL 1
#define E_INVALIDARG 2
#define CHAR_BIT 8
#endif
*/

#define LNGQDW 5

/*
typedef struct {
	DWORD y[2*LNGQDW];
} PUBKEY;

typedef struct {
	DWORD x[LNGQDW];
} PRIVKEY;
*/

#define PK_ENC_PUBLIC_KEY_LEN	(2 * LNGQDW * sizeof(DWORD))
#define PK_ENC_PRIVATE_KEY_LEN	(    LNGQDW * sizeof(DWORD))
#define PK_ENC_PLAINTEXT_LEN	((LNGQDW-1) * sizeof(DWORD))
#define PK_ENC_CIPHERTEXT_LEN	(4 * LNGQDW * sizeof(DWORD))
#define PK_ENC_SIGNATURE_LEN	(2 * LNGQDW * sizeof(DWORD))


typedef struct {
	BYTE y[ PK_ENC_PUBLIC_KEY_LEN ];
} PUBKEY;

typedef struct {
	BYTE x[ PK_ENC_PRIVATE_KEY_LEN ];
} PRIVKEY;



class CDRMPKCrypto {
private:
	char *pkd;
public:
	CDRMPKCrypto();
	~CDRMPKCrypto();
	HRESULT PKinit();
	HRESULT PKencrypt( PUBKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKdecrypt( PRIVKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKsign( PRIVKEY *privkey, BYTE  *buffer, DWORD lbuf, BYTE *sign );
	BOOL PKverify( PUBKEY *pubkey, BYTE *buffer, DWORD lbuf, BYTE *sign );
	HRESULT PKGenKeyPair( PUBKEY *pPub, PRIVKEY *pPriv );
};

extern "C" {
  extern void random_bytes(BYTE*, DWORD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\ukshared\ukspch.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	UKShared.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "uksPCH.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\ukshared\sbuffer.cpp ===
#include "uksPCH.h"

extern "C" {
#include <wdm.h>
}
#include <ks.h>

#include "inc/KrmCommStructs.h"
#include "SBuffer.h"

//------------------------------------------------------------------------------
SBuffer::SBuffer(BYTE* BufX, unsigned int Len){
    buf=BufX;
    getPos=0;
    putPos=0;
    len=Len;
    lasterror=KRM_OK;
};
//------------------------------------------------------------------------------
SBuffer::~SBuffer(){
    buf=NULL;
};
//------------------------------------------------------------------------------
void SBuffer::reset(){
    getPos=0;
    putPos=0;
    lasterror=KRM_OK;    
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::append(BYTE* Data, DWORD datLen){
    unsigned int p;

    if (KRM_OK == getPutPosAndAdvance(&p,datLen)) {
        memcpy(buf+p, Data, datLen);
    }
    return lasterror;
};
//------------------------------------------------------------------------------
void SBuffer::err(const char* Msg, DRM_STATUS err){
    lasterror = err;
#ifdef DBG
    DbgPrint("DRMK:");DbgPrint((char*) Msg);DbgPrint("\n");
#endif
	ASSERT(FALSE);
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::getGetPosAndAdvance(unsigned int *pos, unsigned int Len) {
    if (KRM_OK == lasterror) {
        if (Len > len-getPos) {
            err("pop overflow", KRM_BUFSIZE);
        }
        else {
            *pos=getPos;
            getPos+=Len;
        }
    }
    
    return lasterror;
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::getPutPosAndAdvance(unsigned int *pos, unsigned int Len) {
    if (KRM_OK == lasterror) {
        if (Len > len-putPos) {
            err("push overflow", KRM_BUFSIZE);
        }
        else {
            *pos=putPos;
            putPos+=Len;
        }
    }
    
    return lasterror;
};
//------------------------------------------------------------------------------
#define INSERT(_TYPE, _OBJADDR)                                         \
    if (KRM_OK == lasterror) {                                          \
        unsigned int _size=sizeof(_TYPE);                               \
        if (_size > len-putPos) {                                       \
            err("push overflow",KRM_BUFSIZE);                           \
        }                                                               \
        else {                                                          \
            memcpy(buf+putPos, _OBJADDR, _size);                        \
            putPos+=_size;                                              \
        }                                                               \
    }                                                                   \
    return *this;                                                           
//------------------------------------------------------------------------------
#define EXTRACT(_TYPE, _OBJADDR)                                        \
    if (KRM_OK == lasterror) {                                          \
        unsigned int _size = sizeof(_TYPE);                             \
        if(_size > len-getPos) {                                        \
            err("pop overflow",KRM_BUFSIZE);                            \
        }                                                               \
        else {                                                          \
            memcpy(_OBJADDR, buf+getPos, _size);                        \
            getPos += _size;                                            \
        }                                                               \
    }                                                                   \
    return *this;                                                       
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (const DWORD Val) {
    INSERT(DWORD, &Val);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (const PVOID Ptr) {
    INSERT(DWORD, &Ptr);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PDRMRIGHTS R) {
    INSERT(DRMRIGHTS, R);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PSTREAMKEY S) {
    INSERT(STREAMKEY, S);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PCERT C) {
    INSERT(CERT, C);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PDRMDIGEST D) {
    INSERT(DRMDIGEST, D);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (DWORD& Val) {
    EXTRACT(DWORD, &Val);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (DRMRIGHTS* R) {
    EXTRACT(DRMRIGHTS, R);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (PSTREAMKEY S) {
    EXTRACT(STREAMKEY, S);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (PCERT C) {
    EXTRACT(CERT, C);
};
//------------------------------------------------------------------------------
DRM_STATUS term(SBuffer& S) {
    if (KRM_OK == S.getLastError()) {
        S << 0xFFFFffff;
    }

    return S.getLastError();
};
//------------------------------------------------------------------------------
DRM_STATUS checkTerm(SBuffer& S) {
    if (KRM_OK == S.getLastError()) {
        DWORD Val = 0;
        S >> Val;

        if (KRM_OK == S.getLastError()) {
            if (Val != 0xFFFFffff) {
                S.err("Bad terminator", KRM_BADTERMINATOR);
            }
        }

        ASSERT(Val==0xFFFFffff);
    }

    return S.getLastError();;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\drm\krm\ukshared\ukspch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_)
#define AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN		
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _KBLD
	#include "DRMKMain/drmkPCH.h"
#else
	#include "KRMProxy/krmpPCH.h"
#endif



// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

extern "C" {
#include <wdm.h>
} // extern "C"

#include <windef.h>
#include <stdio.h>
#include <winerror.h>
#include <memory.h>
#include <stddef.h>
#include <limits.h>
#include <stdlib.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <unknown.h>
#include <kcom.h>

#include "debug.h"
#include "filter.h"
#include "device.h"

//---------------------------------------------------------------------------

#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INITDATA", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define LOCKED_BSS 	bss_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS	bss_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\debug.h ===
//---------------------------------------------------------------------------
//
//  Module:   debug.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#ifdef DEBUG
#define STR_MODULENAME "'gfx: "
#endif

#if defined(DEBUG) && defined(_X86_)
#define Trap()	{_asm {_emit 0xcc}}
#else
#define Trap()
#endif

#define AssertAligned(p)	ASSERT((PtrToUlong(p) & 7) == 0)

#ifdef DEBUG

extern "C" int GFXTraceLevel;

#define DPF(n,sz) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n") : 0)
#define DPF1(n,sz,a) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a) : 0)
#define DPF2(n,sz,a,b) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b) : 0)
#define DPF3(n,sz,a,b,c) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c) : 0)
#define DPF4(n,sz,a,b,c,d) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d) : 0)
#define DPF5(n,sz,a,b,c,d,e) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d, e) : 0)
#define DPF6(n,sz,a,b,c,d,e,f) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d, e, f) : 0)
#define DPF7(n,sz,a,b,c,d,e,f,g) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d, e, f, g) : 0)
#define DPF8(n,sz,a,b,c,d,e,f,g,h) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d, e, f, g, h) : 0)
#define DPF9(n,sz,a,b,c,d,e,f,g, h, i) (n <= GFXTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a, b, c, d, e, f, g, h, i) : 0)

#else 

#define DPF(n,sz)
#define DPF1(n,sz,a)
#define DPF2(n,sz,a,b)
#define DPF3(n,sz,a,b,c)
#define DPF4(n,sz,a,b,c,d)
#define DPF5(n,sz,a,b,c,d,e)
#define DPF6(n,sz,a,b,c,d,e,f)
#define DPF7(n,sz,a,b,c,d,e,f,g)
#define DPF8(n,sz,a,b,c,d,e,f,g,h)
#define DPF9(n,sz,a,b,c,d,e,f,g,h,i)

#define	AssertKernelProcess

#endif

#ifdef DEBUG
#define Assert(p) \
    (p)->m_Signature.DebugAssert()

#define DefineSignature(s) \
    class CSignature \
    { \
    public: \
	CSignature() \
	{ \
	   m_dwSignature = s; \
	}; \
	~CSignature() \
	{ \
	   m_dwSignature = 0x44414544; \
	}; \
	VOID DebugAssert() \
	{ \
	    ASSERT(m_dwSignature == s); \
	}; \
    private: \
	ULONG m_dwSignature; \
    } m_Signature;

#define DestroySignature() \
    m_Signature.~CSignature()

#else
#define Assert(p)
#define DefineSignature(s)
#define DestroySignature()
#endif

//---------------------------------------------------------------------------
//  End of File: debug.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\device.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   device.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

int GFXTraceLevel = 5;

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptorTable)
{   
    &FilterDescriptor
};

const KSDEVICE_DESCRIPTOR DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptorTable),
    FilterDescriptorTable
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPathName
    )
{
    DPF(5, "DriverEntry");
    return(KsInitializeDriver(
      pDriverObject,
      pRegistryPathName,
      &DeviceDescriptor));
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\filter.h ===
//---------------------------------------------------------------------------
//
//  Module:   		filter.h
//
//  Description:	Filter Instance
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CFilterContext
{
private:
    BOOL    fEnabled;
public:
    CFilterContext()
    {
	fEnabled = TRUE;
    }
    ~CFilterContext()
    {
    }
    //
    // The dispatch functions are implemented as static members of the client
    // class.  This gives them access to private member variables even though
    // they don't have an implied 'this' argument.
    //
    // Create and Close are used to construct and destruct, respectively the
    // client CFilterContext object.  Process gets called by the ks when there 
    // is work to be done. 
    //
    static
    NTSTATUS
    Create(
        IN OUT PKSFILTER pFilter,
        IN PIRP pIrp
    );
    static
    NTSTATUS
    Close(
        IN OUT PKSFILTER pFilter,
        IN PIRP pIrp
    );
    static
    NTSTATUS
    Process(
        IN PKSFILTER pFilter,
        IN PKSPROCESSPIN_INDEXENTRY pProcessPinsIndex
    );
    static
    NTSTATUS
    PropertyChannelSwap(
	IN PIRP pIrp,
	IN PKSPROPERTY pProperty,
	IN OUT PVOID pData
    );
    static
    NTSTATUS
    PropertyFilterState(
        IN PIRP pIrp,
        IN PKSPROPERTY pProperty,
        OUT PVOID pData
    );
    NTSTATUS
    ChannelSwap(
	IN PVOID pDestination,
	IN PVOID pSource,
	IN ULONG ulByteCount
    );
    DefineSignature(0x494c4946);

} FILTER_CONTEXT, *PFILTER_CONTEXT;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern const KSFILTER_DESCRIPTOR FilterDescriptor;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
PropertyAudioPosition(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
);

NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
);

NTSTATUS
PropertyDataFormat(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PVOID pVoid
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\filter.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   filter.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "msgfx.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

const KSDATARANGE_AUDIO PinDataRanges[] = 
{
    {
        {
            sizeof(PinDataRanges[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        2,
        16,
        16,
        100,
        100000
    }
};

const PKSDATARANGE DataRanges[] =
{
    PKSDATARANGE(&PinDataRanges[0])
};

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED,
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    3,
    (PAGE_SIZE-1),
    (2*PAGE_SIZE),
    (2*PAGE_SIZE)
);

DEFINE_KSPROPERTY_TABLE(AudioPinPropertyTable) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_POSITION,
        PropertyAudioPosition,
        sizeof(KSPROPERTY),
        sizeof(KSAUDIO_POSITION),
        PropertyAudioPosition,
        NULL,
        0,
        NULL,
        NULL,
        0)
};

DEFINE_KSPROPERTY_TABLE(ConnectionPropertyTable) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_DATAFORMAT,
        PropertyDataFormat,
        sizeof(KSPROPERTY),
        0,
        PropertyDataFormat,
        NULL,
        0,
        NULL,
        NULL,
        0)
};

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySetTable) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(AudioPinPropertyTable),
        AudioPinPropertyTable,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(ConnectionPropertyTable),
        ConnectionPropertyTable,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(PinAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(PinPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

const KSPIN_DESCRIPTOR_EX PinDescriptors[]=
{
    {
        NULL,					// Dispatch
        &PinAutomationTable,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRanges),
            DataRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,				// GUID *Category
            NULL,				// GUID *Name
	    0,					// ConstrainedDataRangesCount
        },
        0,					// Flags
        1,					// InstancesPossible
        1,					// InstancesNecessary
        &AllocatorFraming,
        IntersectHandler
    },
    {
        NULL,					// Dispatch
        &PinAutomationTable,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRanges),
            DataRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,				// GUID *Category
            NULL,				// GUID *Name
	    0,					// ConstrainedDataRangesCount
        },
        0,					// Flags
        1,					// InstancesPossible
        1,					// InstancesNecessary
        &AllocatorFraming,
        IntersectHandler
    }
};

//---------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(AudioNodePropertyTable) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP,
        CFilterContext::PropertyChannelSwap,
        sizeof(KSP_NODE),
        sizeof(ULONG),
        CFilterContext::PropertyChannelSwap,
        NULL,
        0,
        NULL,
        NULL,
        sizeof(ULONG))   // Serialized size
};

DEFINE_KSPROPERTY_SET_TABLE(NodePropertySetTable) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_MsGfxSample,
        SIZEOF_ARRAY(AudioNodePropertyTable),
        AudioNodePropertyTable,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(NodeAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(NodePropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

const KSNODE_DESCRIPTOR NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(
        &NodeAutomationTable,
	// ISSUE-2000/11/07-FrankYe Should not use KSNODETYPE_DELAY
        &KSNODETYPE_DELAY,			// GUID *Type
        NULL)					// GUID *Name
};

//---------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(FilterPropertyTable_MsGfxSample) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP,
        CFilterContext::PropertyChannelSwap,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        CFilterContext::PropertyChannelSwap,
        NULL,
        0,
        NULL,
        NULL,
        sizeof(ULONG))   // Serialized size
};

DEFINE_KSPROPERTY_TABLE(FilterPropertyTable_Audio) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_FILTER_STATE,
        CFilterContext::PropertyFilterState,
        sizeof(KSPROPERTY),
        0,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0)
};

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySetTable) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_MsGfxSample,
        SIZEOF_ARRAY(FilterPropertyTable_MsGfxSample),
        FilterPropertyTable_MsGfxSample,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(FilterPropertyTable_Audio),
        FilterPropertyTable_Audio,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(FilterAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(FilterPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//---------------------------------------------------------------------------

const GUID Categories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM)
};

const KSFILTER_DISPATCH FilterDispatch =
{
    CFilterContext::Create,
    CFilterContext::Close,
    CFilterContext::Process,
    NULL				// Reset
};


#define STATIC_KSNAME_MsGfx \
    0x9b365890, 0x165f, 0x11d0, 0xa1, 0x9f, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_MsGfx);
#define KSNAME_MsGfx DEFINE_GUIDNAMED(KSNAME_MsGfx)

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptor)
{
    &FilterDispatch,
    &FilterAutomationTable,		// AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,
    0,					// Flags
    &KSNAME_MsGfx,         // Reference ID
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES(Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,
    NULL				// ComponentId
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CFilterContext::Create(
    IN OUT PKSFILTER pFilter,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine is called when a  filter is created.  It instantiates the
    client filter object and attaches it to the  filter structure.

Arguments:

    pFilter -
        Contains a pointer to the  filter structure.

    pIrp -
        Contains a pointer to the create request.

Return Value:

    STATUS_SUCCESS or, if the filter could not be instantiated, 
    STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_CONTEXT pFilterContext;

    ASSERT(!pFilter->Context);

    //
    // Create an instance of the client filter object.
    //
    pFilterContext = new(PagedPool, 'fxfg') FILTER_CONTEXT;
    if(pFilterContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    //
    // Attach it to the filter structure.
    //
    pFilter->Context = (PVOID)pFilterContext;
    DPF1(5, "Create: FC %08x", pFilterContext);
exit:
    return(Status);
}

NTSTATUS
CFilterContext::Close(
    IN PKSFILTER pFilter,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine is called when a  filter is closed.  It deletes the
    client filter object attached it to the  filter structure.

Arguments:

    pFilter -
        Contains a pointer to the  filter structure.

    pIrp -
        Contains a pointer to the close request.

Return Value:

    STATUS_SUCCESS.

--*/

{
    DPF1(5, "Close: FC %08x", pFilter->Context);
    Assert(((PFILTER_CONTEXT)pFilter->Context));
    delete (PFILTER_CONTEXT)pFilter->Context;
    return(STATUS_SUCCESS);
}

NTSTATUS
CFilterContext::Process(
    IN PKSFILTER pFilter,
    IN PKSPROCESSPIN_INDEXENTRY pProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    pFilter -
        Contains a pointer to the  filter structure.

    pProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING.

--*/

{
    PKSPROCESSPIN inPin, outPin;
    NTSTATUS Status;
    ULONG byteCount;

    inPin = pProcessPinsIndex[1].Pins[0];
    outPin = pProcessPinsIndex[0].Pins[0];

    //
    // Find out how much data we have to process
    //
    byteCount = min(inPin->BytesAvailable, outPin->BytesAvailable);

    //
    // Do our processing
    //
    Status = ((PFILTER_CONTEXT)pFilter->Context)->ChannelSwap(
      outPin->Data,
      inPin->Data,
      byteCount);

    //
    // Report back how much data we processed
    //
    inPin->BytesUsed = outPin->BytesUsed = byteCount;
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CFilterContext::PropertyFilterState(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PVOID pData
)
/*++

Routine Description:

    Returns the property sets that comprise the persistable filter settings

Arguments:

    pIrp -
        Irp which asked us to do the get

    pProperty -
        Property structure

    pData -
        Pointer to return data

--*/

{
    NTSTATUS Status;

    GUID StatePropertySets[] = {
        STATIC_KSPROPSETID_MsGfxSample
    };

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(pIrp);
    ULONG cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (0 == cbData) {
        pIrp->IoStatus.Information = sizeof(StatePropertySets);
        Status = STATUS_BUFFER_OVERFLOW;
    } else if (cbData < sizeof(StatePropertySets)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(pData, StatePropertySets, sizeof(StatePropertySets));
        pIrp->IoStatus.Information = sizeof(StatePropertySets);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

//---------------------------------------------------------------------------

NTSTATUS
CFilterContext::PropertyChannelSwap(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
/*++

Routine Description:

    Gets/Sets the Channel Swap boolean

Arguments:

    pIrp -
        Irp which asked us to do the get/set

    pProperty -
        Property structure

    pData -
        Pointer to return data OR pointer to new value of the boolean

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_CONTEXT pFilterContext;
    PBOOL pChannelSwap;

    // ISSUE-2000/11/07-FrankYe Describe how to handle this
    //    as a node property

    //
    // Get hold of our FilterContext via pIrp
    //
    pFilterContext = (PFILTER_CONTEXT)(KsGetFilterFromIrp(pIrp)->Context);

    //
    // Assert that we have a valid filter context
    //
    Assert(pFilterContext);

    //
    // Get the Data pointer into a friendlier var
    //
    pChannelSwap = (PBOOL)pData;

    if (pProperty->Flags & KSPROPERTY_TYPE_GET) {
        //
        // Get channel swap state
        //
        *pChannelSwap = pFilterContext->fEnabled;
    }
    else if (pProperty->Flags & KSPROPERTY_TYPE_SET) {
        //
        // Set Channel swap state
        //
        pFilterContext->fEnabled = *pChannelSwap;
    }
    else {
        //
        // We support only Get & Set
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }
    return(Status);
}

NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN pin;
    NTSTATUS status;

    DPF(90, "[IntersectHandler]");

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Find a pin instance if there is one.  Try the supplied pin type first.
    // If there is no pin, we fail to force the graph builder to try the
    // other filter.  We need to acquire control because we will be looking
    // at other pins.
    //
    pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId);
    if (! pin) {
        pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId ^ 1);
    }

    if (! pin) {
        status = STATUS_NO_MATCH;
    } else {
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if ((!IsEqualGUIDAligned( 
                CallerDataRange->SubFormat,
                pin->ConnectionFormat->SubFormat ) &&
             !IsEqualGUIDAligned( 
                CallerDataRange->SubFormat,
                KSDATAFORMAT_SUBTYPE_WILDCARD )) || 
            (!IsEqualGUIDAligned(  
                CallerDataRange->Specifier, 
                pin->ConnectionFormat->Specifier ) &&
             !IsEqualGUIDAligned( 
                CallerDataRange->Specifier,
                KSDATAFORMAT_SPECIFIER_WILDCARD ))) {
            DPF(5, "range does not match current format");
            status = STATUS_NO_MATCH;
        } else {
            //
            // Validate return buffer size, if the request is only for the
            // size of the resultant structure, return it now.
            //    
            if (!BufferSize) {
                *DataSize = pin->ConnectionFormat->FormatSize;
                status = STATUS_BUFFER_OVERFLOW;
            } else if (BufferSize < pin->ConnectionFormat->FormatSize) {
                status =  STATUS_BUFFER_TOO_SMALL;
            } else {
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory( Data, pin->ConnectionFormat, *DataSize );
                status = STATUS_SUCCESS;
            }
        }
    } 

    return status;
}

NTSTATUS
PropertyAudioPosition(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    Gets/Sets the audio position of the audio stream
    (Relies on the next filter's audio position)

    pIrp -
        Irp which asked us to do the get/set

    pProperty -
        Ks Property structure

    pData -
        Pointer to buffer where position value needs to be filled OR
        Pointer to buffer which has the new positions

--*/

{
    PFILE_OBJECT pFileObject;
    ULONG BytesReturned;
    PKSFILTER pFilter;
    PKSPIN pOtherPin;
    NTSTATUS Status;
    PKSPIN pPin;

    pPin = KsGetPinFromIrp(pIrp);
    pFilter = KsPinGetParentFilter(pPin);
    pOtherPin = KsFilterGetFirstChildPin(pFilter, (pPin->Id ^ 1));
    if(pOtherPin == NULL) {
        pOtherPin = KsFilterGetFirstChildPin(pFilter, pPin->Id);
        if (pOtherPin == pPin) {
            pOtherPin = KsPinGetNextSiblingPin(pOtherPin);
        }
    }
    pFileObject = KsPinGetConnectedPinFileObject(pOtherPin);

    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pProperty,
      sizeof (KSPROPERTY),
      pPosition,
      sizeof (KSAUDIO_POSITION),
      &BytesReturned);

    pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);
    return(Status);
}

NTSTATUS
PropertyDataFormat(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PVOID pVoid
)
{
    //
    // ISSUE - 10/03/2000 - mohans :: Call thru to the next driver to change the data format
    //                                instead of failing the call
    //
    return(STATUS_INVALID_PARAMETER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\device.h ===
//---------------------------------------------------------------------------
//
//  Module:   		device.h
//
//  Description:	Device Initialization code
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data Structures
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT	    pDriverObject,
    IN PUNICODE_STRING	    pRegistryPathName
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\msgfx.h ===
#define STATIC_KSPROPSETID_MsGfxSample\
    0xec1699d5, 0x2845, 0x4ca2, 0xbe, 0x7d, 0x8c, 0xe4, 0x62, 0xfd, 0xac, 0x2b
DEFINE_GUIDSTRUCT("EC1699D5-2845-4ca2-BE7D-8CE462FDAC2B", KSPROPSETID_MsGfxSample);
#define KSPROPSETID_MsGfxSample DEFINE_GUIDNAMED(KSPROPSETID_MsGfxSample)

typedef enum {
    KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP = 1
} KSPROPERTY_MSGFXSAMPLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\intersec.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   intersec.cpp
//
//  Description:
//
//	Pin data intersection handler
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

NTSTATUS
KsAudioIntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Descriptor data range must be WAVEFORMATEX.
    //
    ASSERT(IsEqualGUIDAligned(DescriptorDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX));
    PKSDATARANGE_AUDIO descriptorDataRange =
        PKSDATARANGE_AUDIO(DescriptorDataRange);

    //
    // Caller data range may be wildcard or WAVEFORMATEX.
    //
    PKSDATARANGE_AUDIO callerDataRange;
    if (IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // WAVEFORMATEX.  Validate the specifier ranges.
        //
        ASSERT(IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX));

        callerDataRange = PKSDATARANGE_AUDIO(CallerDataRange);

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            return STATUS_NO_MATCH;
        }
    }

    PKSDATAFORMAT_WAVEFORMATEX dataFormat =
        PKSDATAFORMAT_WAVEFORMATEX(Data);

    if (BufferSize == 0) {
        //
        // Size query - return the size.
        //
        *DataSize = sizeof(*dataFormat);
        return STATUS_BUFFER_OVERFLOW;
    }

    ASSERT(dataFormat);

    if (BufferSize < sizeof(*dataFormat)) {
        //
        // Buffer is too small.
        //
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Gotta build the format.
    //
    *DataSize = sizeof(*dataFormat);

    //
    // All the guids are in the descriptor's data range.
    //
    RtlCopyMemory(
        &dataFormat->DataFormat,
        DescriptorDataRange,
        sizeof(dataFormat->DataFormat));

    dataFormat->WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;

    if (callerDataRange) {
        dataFormat->WaveFormatEx.nChannels = (USHORT)
            min(callerDataRange->MaximumChannels,descriptorDataRange->MaximumChannels);
        dataFormat->WaveFormatEx.nSamplesPerSec =
            min(callerDataRange->MaximumSampleFrequency,descriptorDataRange->MaximumSampleFrequency);
        dataFormat->WaveFormatEx.wBitsPerSample = (USHORT)
            min(callerDataRange->MaximumBitsPerSample,descriptorDataRange->MaximumBitsPerSample);
    } else {
        dataFormat->WaveFormatEx.nChannels = (USHORT)
            descriptorDataRange->MaximumChannels;
        dataFormat->WaveFormatEx.nSamplesPerSec =
            descriptorDataRange->MaximumSampleFrequency;
        dataFormat->WaveFormatEx.wBitsPerSample = (USHORT)
            descriptorDataRange->MaximumBitsPerSample;
    }

    dataFormat->WaveFormatEx.nBlockAlign =
        (dataFormat->WaveFormatEx.wBitsPerSample * dataFormat->WaveFormatEx.nChannels) / 8;
    dataFormat->WaveFormatEx.nAvgBytesPerSec = 
        dataFormat->WaveFormatEx.nBlockAlign * dataFormat->WaveFormatEx.nSamplesPerSec;
    dataFormat->WaveFormatEx.cbSize = 0;
        
    dataFormat->DataFormat.FormatSize = sizeof(*dataFormat);
    dataFormat->DataFormat.SampleSize = dataFormat->WaveFormatEx.nBlockAlign;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\gfx\process.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   process.cpp
//
//  Description:
//
//	Contains the actual process code of the GFX
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CFilterContext::ChannelSwap(
    IN PVOID pDestination,
    IN PVOID pSource,
    IN ULONG ulByteCount
)
/*++

Routine Description:

    if DoSwapping is true swap the Left & Right Channels of the stereo stream
    else just copy the data over as it is

Arguments:

    DoSwapping -
        Boolean which says whether channel swapping needs to be done or not.

    Destination -
        Destination pointer where the swapped data goes to

    Source -
        Source pointer from where the stereo pair has to be swapped

    ulByteCount -
        number of BYTES available for copying/swapping

--*/

{
    PSHORT destSamples, sourceSamples;
    ULONG i, numSamples;

    PAGED_CODE();

    //
    // Assert that we have the correct block alignment
    //
    ASSERT(!(ulByteCount%4));

    if (fEnabled) {

        //
        // Swapping is enabled. So swap Left & Right Channels
        //

        //
        // number of total samples across channels
        //
        numSamples = ulByteCount/2;

        //
        // get pointers into friendlier vars
        //
        destSamples = (PSHORT)pDestination;
        sourceSamples = (PSHORT)pSource;

        //
        // loop through & swap
        //
        for (i = 0; i < numSamples; i+=2) {
            destSamples[i] = sourceSamples[i+1];
            destSamples[i+1] = sourceSamples[i];
        }
    }
    else {
        //
        // no swap required
        // so just do mem copy
        //
        RtlCopyMemory(pDestination, pSource, ulByteCount);
    }
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\clock.c ===
//---------------------------------------------------------------------------
//
//  Module:   clock.c
//
//  Description:
//
//      KS Clock support routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//  Original   2/5/98     S.Mohanraj  Added Clock support
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

DEFINE_KSDISPATCH_TABLE(
        MxClockDispatchTable,
        MxClockDispatchIoControl,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        MxClockDispatchClose,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchFastIoDeviceControlFailure,
        KsDispatchFastReadFailure,
        KsDispatchFastWriteFailure
) ;

DEFINE_KSPROPERTY_CLOCKSET( 
    MxClockPropertyHandlers,
    MxGetTime,
    MxGetPhysicalTime,
    MxGetCorrelatedTime,
    MxGetCorrelatedPhysicalTime,
    MxGetResolution,
    MxGetState,
    MxGetFunctionTable );

DEFINE_KSPROPERTY_SET_TABLE( MxClockPropertyTable )
{
    DEFINE_KSPROPERTY_SET( 
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY( MxClockPropertyHandlers ),
        MxClockPropertyHandlers,
        0, 
        NULL)
};

DEFINE_KSEVENT_TABLE( MxClockEventHandlers ) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof( KSEVENT_TIME_INTERVAL ),
        sizeof( ULONGLONG ) + sizeof( ULONGLONG ),
        (PFNKSADDEVENT) MxAddClockEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof( KSEVENT_TIME_MARK ),
        sizeof( ULONGLONG ),
        (PFNKSADDEVENT) MxAddClockEvent,
        NULL,
        NULL)
};

DEFINE_KSEVENT_SET_TABLE( MxClockEventTable )
{
    DEFINE_KSEVENT_SET( 
        &KSEVENTSETID_Clock, 
        SIZEOF_ARRAY( MxClockEventHandlers ),
        MxClockEventHandlers)
};

NTSTATUS
MxClockDispatchCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS                Status ;
    PKSCLOCK_CREATE         pClockCreate ;
    PFILE_OBJECT            ParentObject ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    
    ParentObject = pIrpStack->FileObject->RelatedFileObject ;
    pMixerSink = ParentObject->FsContext ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

    if ( pMixerSink->pClock ) {
        // We do not support multiple clock creates.
        Status = STATUS_DEVICE_BUSY ;
        goto exit ;
    }
    
    Status = KsValidateClockCreateRequest(pIrp, &pClockCreate) ;
    if ( NT_SUCCESS(Status) ) {
        pClock = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(CLOCK_INSTANCE),
                                      'XIMK') ;
                                      
        if ( pClock ) {
            KsAllocateObjectHeader(&pClock->Header.ObjectHeader,
                                   0,
                                   NULL,
                                   pIrp,
                                   &MxClockDispatchTable) ;
                                   
            pClock->pMixerSink = pMixerSink ;
            pClock->pFilterInstance =
                 ((PMIXER_INSTHDR)pMixerSink)->pFilterFileObject->FsContext ;
            pClock->Header.PinId = ((PMIXER_INSTHDR)pMixerSink)->PinId ;
            KeInitializeSpinLock(&pClock->EventLock) ;
            InitializeListHead(&pClock->EventQueue) ;
            pMixerSink->pClock = pClock ;
            pIrpStack->FileObject->FsContext = pClock ;
            pClock->PhysicalTime = 0 ;
            pClock->pFileObject = pIrpStack->FileObject ;
            ObReferenceObject(ParentObject) ;
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
        }
    }
exit:    
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS
MxClockDispatchClose(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS                Status ;
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;
                               
    pMixerSink->pClock = NULL ;
    KsFreeEventList( pIrpStack->FileObject,
                     &pClock->EventQueue,
                     KSEVENTS_SPINLOCK,
                     &pClock->EventLock );
    KsFreeObjectHeader(pClock->Header.ObjectHeader) ;
    ExFreePool(pClock) ;
    ObDereferenceObject(pIrpStack->FileObject->RelatedFileObject) ;
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    Status = STATUS_SUCCESS ;
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS
MxClockDispatchIoControl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS            Status ;
    PIO_STACK_LOCATION  pIrpStack ;
    PCLOCK_INSTANCE     pClock ;
    
    PAGED_CODE();

    ASSERT( pDeviceObject );
    ASSERT( pIrp );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler( pIrp, 
                                        SIZEOF_ARRAY( MxClockPropertyTable ),
                                        (PKSPROPERTY_SET) MxClockPropertyTable );
            break;

        case IOCTL_KS_ENABLE_EVENT:
            Status = KsEnableEvent( pIrp, 
                                    SIZEOF_ARRAY( MxClockEventTable ), 
                                    (PKSEVENT_SET) MxClockEventTable, 
                                    NULL, 
                                    KSEVENTS_NONE,
                                    NULL);
            break;

        case IOCTL_KS_DISABLE_EVENT:
            Status = KsDisableEvent( pIrp, 
                                     &pClock->EventQueue,
                                     KSEVENTS_SPINLOCK,
                                     &pClock->EventLock );
            break;

        default:
            return KsDefaultDeviceIoCompletion( pDeviceObject, pIrp );

    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
MxGetTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PULONGLONG      pTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    *pTime = MxFastGetTime(pIrpStack->FileObject) ;

    pIrp->IoStatus.Information = sizeof(ULONGLONG) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetPhysicalTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PULONGLONG      pPhysicalTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    *pPhysicalTime = MxFastGetPhysicalTime(pIrpStack->FileObject) ;

    pIrp->IoStatus.Information = sizeof(ULONGLONG) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetCorrelatedTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSCORRELATED_TIME  pCorrelatedTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pCorrelatedTime->Time =
                MxFastGetCorrelatedTime(pIrpStack->FileObject,
                                        &pCorrelatedTime->SystemTime) ;

    pIrp->IoStatus.Information = sizeof(KSCORRELATED_TIME) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetCorrelatedPhysicalTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSCORRELATED_TIME  pCorrelatedPhysicalTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pCorrelatedPhysicalTime->Time =
                MxFastGetCorrelatedPhysicalTime(pIrpStack->FileObject,
                                      &pCorrelatedPhysicalTime->SystemTime) ;

    pIrp->IoStatus.Information = sizeof(KSCORRELATED_TIME) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetResolution
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSRESOLUTION   pResolution
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    
    PAGED_CODE() ;
    
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = pIrpStack->FileObject->RelatedFileObject->FsContext ;
    //
    // Setup pFilterInstance for accessing MIXBUFFERDURATION
    //
    pFilterInstance = (PFILTER_INSTANCE)pMixerSink->Header.pFilterFileObject->FsContext ;

    pResolution->Granularity = MxConvertBytesToTime(pMixerSink, 1) ;

    pResolution->Error =
                ((_100NS_UNITS_PER_SECOND / 1000) * MIXBUFFERDURATION) / 2 ;

    pIrp->IoStatus.Information = sizeof(KSRESOLUTION) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetState
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSSTATE        pState
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    PAGED_CODE() ;
    
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = pIrpStack->FileObject->RelatedFileObject->FsContext ;
    
    *pState = pMixerSink->SinkState ;
    
    pIrp->IoStatus.Information = sizeof(KSSTATE) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetFunctionTable
(
    PIRP                    pIrp,
    PKSPROPERTY             pProperty,
    PKSCLOCK_FUNCTIONTABLE  pClockFunctionTable
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pClockFunctionTable->GetTime = MxFastGetTime ;
    pClockFunctionTable->GetPhysicalTime = MxFastGetPhysicalTime ;
    pClockFunctionTable->GetCorrelatedTime = MxFastGetCorrelatedTime ;
    pClockFunctionTable->GetCorrelatedPhysicalTime =
                                MxFastGetCorrelatedPhysicalTime ;
    
    pIrp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE) ;
    return(STATUS_SUCCESS) ;
}

LONGLONG
FASTCALL
MxFastGetTime
(
    PFILE_OBJECT    pFileObject
)
{
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PCLOCK_INSTANCE         pClock ;

    pClock = pFileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;

    return (MxConvertBytesToTime(pMixerSink, pMixerSink->WriteOffset)) ;
    
}

LONGLONG
FASTCALL
MxFastGetPhysicalTime
(
    PFILE_OBJECT    pFileObject
)
{
    PCLOCK_INSTANCE         pClock ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    pClock = pFileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;

    return (MxConvertBytesToTime(pMixerSink, pClock->PhysicalTime)) ;
}

LONGLONG
FASTCALL
MxFastGetCorrelatedTime
(
    PFILE_OBJECT    pFileObject,
    PLONGLONG       pSystemTime
)
{
    LARGE_INTEGER   Time, Frequency ;

    Time = KeQueryPerformanceCounter(&Frequency) ;
    //
    //  Convert ticks to 100ns units.
    //
    *pSystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);

    return (MxFastGetTime(pFileObject)) ;
}

LONGLONG
FASTCALL
MxFastGetCorrelatedPhysicalTime
(
    PFILE_OBJECT    pFileObject,
    PLONGLONG       pSystemTime
)
{
    LARGE_INTEGER   Time, Frequency ;

    Time = KeQueryPerformanceCounter(&Frequency) ;
    //
    //  Convert ticks to 100ns units.
    //
    *pSystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);
                   
    return (MxFastGetPhysicalTime(pFileObject)) ;
}

MxUpdatePhysicalTime 
(

    PCLOCK_INSTANCE pClock,
    ULONGLONG       Increment           // in Bytes
)
{
    ULONG fool;
    fool = (ULONG) (pClock->PhysicalTime += Increment);  
    // keep it in bytes till we need to convert it (in the Get function)
    return fool;
}

LONGLONG
MxConvertBytesToTime
(
    PMIXER_SINK_INSTANCE    pMixerSink,
    ULONGLONG               Bytes
)
{
    LONGLONG    Time ;
    
	Time = (_100NS_UNITS_PER_SECOND /
            (pMixerSink->BytesPerSample) * Bytes) /
            pMixerSink->WaveFormatEx.nSamplesPerSec ;
    return (Time) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS
MxAddClockEvent
(
    PIRP                    pIrp,
    PKSEVENT_TIME_INTERVAL  pEventTime,
    PKSEVENT_ENTRY          EventEntry
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PKSINTERVAL             Interval;
    KIRQL                   irqlOld ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

    //
    // Space for the interval is located at the end of the basic 
    // event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an 
    // interval. In both cases the first LONGLONG is present and saved.
    //
    // Note, KS_CLOCK_POSITION_MARK is a single-shot event
    Interval->TimeBase = pEventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
        Interval->Interval = pEventTime->Interval;
    }

    KeAcquireSpinLock( &pClock->EventLock, &irqlOld );
    InsertHeadList( &pClock->EventQueue, &EventEntry->ListEntry );
    KeReleaseSpinLock( &pClock->EventLock, irqlOld );
    
    if (pMixerSink->SinkState == KSSTATE_RUN) {
        // If this event is passed signal immediately.
        MxGenerateClockEvents( pMixerSink->pClock ) ;
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    return ( STATUS_SUCCESS ) ;
}

MxGenerateClockEvents
(
    PCLOCK_INSTANCE    pClock
)
{
    LONGLONG                Time;
    PLIST_ENTRY             ListEntry;
    KIRQL                   irqlOld ;
    PKSEVENT_ENTRY          EventEntry;
    PKSINTERVAL             Interval;
    LONGLONG                Intervals;

    Time = MxFastGetTime( pClock->pFileObject );

    KeAcquireSpinLock( &pClock->EventLock, &irqlOld );

    for(ListEntry = pClock->EventQueue.Flink; 
            ListEntry != &pClock->EventQueue;) {

        EventEntry = 
            (PKSEVENT_ENTRY)
                CONTAINING_RECORD( ListEntry, KSEVENT_ENTRY, ListEntry );
                
        //
        // Pre-inc, KsGenerateEvent() can remove this item from the list.
        //    
        ListEntry = ListEntry->Flink;
        //
        // The event-specific data was added onto the end of the entry.
        //
        Interval = (PKSINTERVAL)(EventEntry + 1);
        //
        // Time for this event to go off.
        //
        if (Interval->TimeBase <= Time) {
            _DbgPrintF(
                DEBUGLVL_VERBOSE, ("Generating event for time: %ld at time: %ld",
                Interval->TimeBase, Time) );
            if (EventEntry->EventItem->EventId != 
                    KSEVENT_CLOCK_INTERVAL_MARK) {
                //
                // A single-shot should only go off once, so make
                // it a value which will never be reached again.
                //
                Interval->TimeBase = 0x7fffffffffffffff;
                
            } else {
                //
                // An interval timer should only go off once per time,
                // so update it to the next timeout.
                //
                Intervals = 
                    (Time - Interval->TimeBase + Interval->Interval - 1) / Interval->Interval;
                Interval->TimeBase += Intervals * Interval->Interval;
            } 

            KsGenerateEvent( EventEntry );
        }
    }

    KeReleaseSpinLock( &pClock->EventLock, irqlOld );
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\dbg.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#ifdef DEBUG

extern  PFILTER_INSTANCE    gpFilterInstance ;

VOID
DebugCommand(
) ;
VOID
DebugDotCommand(
) ;
VOID
InitializeDebug(
);
VOID
UninitializeDebug(
);
VOID __cdecl
dprintf(
    PSZ pszFmt,
    ...
);
CHAR 
DebugGetCommandChar(
);
VOID
DumpSink
(
    PMIXER_SINK_INSTANCE    pMixerSink
);
VOID
DumpSinkPinStatistics
(
    VOID
);
VOID
DumpSinkPins
(
    VOID
);
VOID
DumpActiveSinkPins
(
    VOID
);
VOID
DumpSourcePinStatistics
(
    VOID
);

VOID
DebugCommand(
)
{
    CHAR c;
    while((c = DebugGetCommandChar()) != '\0') {
	    switch(c) {
	     case 'N':
            DumpSinkPinStatistics();
            break;
	     case 'P':
		    DumpSinkPins();
		    break;
	     case 'S':
		    DumpSourcePinStatistics();
		    break;
	     case 'A':
		    DumpActiveSinkPins();
		    break;
		 case '?':
		    dprintf(".X[N|P|A|S]\n");
		    dprintf("N - sink pin statistics\n");
		    dprintf("P - sink pin structures\n");
		    dprintf("A - active sink pin structures\n");
		    dprintf("S - source pin statistics\n");
		    return;
	     default:
		    if(c >= '0' && c <= '9') {
		    }
		    break;
	    }
    }
}

VOID
DebugDotCommand(
)
{
    DebugCommand();
    __asm xor eax, eax
    __asm retf
}

VOID
InitializeDebug(
)
{
    static char *pszHelp = ".K - Dump System Audio Driver data structures\n";
	
    __asm {
	_emit 0xcd
	_emit 0x20
	_emit 0xc1
	_emit 0x00
	_emit 0x01
	_emit 0x00
	jz exitlab

	mov bl, 'X'
	mov esi, offset DebugDotCommand
	mov edi, pszHelp
	mov eax, 0x70	// DS_RegisterDotCommand
	int 41h
exitlab:
    }
}

VOID
UninitializeDebug(
)
{
    __asm {
	_emit 0xcd
	_emit 0x20
	_emit 0xc1
	_emit 0x00
	_emit 0x01
	_emit 0x00
	jz exitlab

	mov bl, 'X'
	mov eax, 0x72 	// DS_DeRegisterDotCommand
	int 41h
exitlab:
    }
}

VOID __cdecl
dprintf(
    PSZ pszFmt,
    ULONG Arg1,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [Arg1]
    __asm mov eax, 0x73
    __asm int 41h
}

CHAR 
DebugGetCommandChar(
)
{
    __asm mov ax, 0x77		// get command char
    __asm mov bl, 1		// get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}


VOID
DumpSink
(
    PMIXER_SINK_INSTANCE    pMixerSink
)
{
    PSZ psz = "?";

    switch(pMixerSink->InterfaceId) {
        case KSINTERFACE_STANDARD_STREAMING:
	   psz = "STREAMING";
	   break;
        case KSINTERFACE_STANDARD_LOOPED_STREAMING:
	   psz = "LOOPED_STREAMING";
	   break;
	case KSINTERFACE_MEDIA_WAVE_QUEUED:
	   psz = "WAVE_QUEUED";
	   break;
    }
    dprintf("Sink[%x](%d-%d)::%d-ch, %d-bit, %d rate i: %s\n",
                (ULONG)pMixerSink,
                pMixerSink->SinkState,
                pMixerSink->SinkStatus,
                pMixerSink->WaveFormatEx.nChannels,
                pMixerSink->WaveFormatEx.wBitsPerSample,
                pMixerSink->WaveFormatEx.nSamplesPerSec,
		psz) ;
}


VOID
DumpSinkPinStatistics
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->SourceConnectionList.Flink ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_INSTHDR, 
                                                                NextInstance) ;
        dprintf("Number of pins = %d\n", pMixerSource->nSinkPins) ;
        dprintf("Number of Active pins = %d\n", gpFilterInstance->ActivePins) ;
        dprintf("Number of Paused pins = %d\n", gpFilterInstance->PausedPins) ;
    }
}

VOID
DumpSinkPins
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->SinkConnectionList.Flink ;
        while ( ple != &gpFilterInstance->SinkConnectionList ) {
        
            pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_INSTHDR, 
                                                                NextInstance) ;
            DumpSink(pMixerSink) ;
            ple = pMixerSink->Header.NextInstance.Flink ;
        }
    }
}
VOID
DumpActiveSinkPins
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &gpFilterInstance->ActiveSinkList ) {
        
            pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_SINK_INSTANCE, 
                                                                ActiveQueue) ;
            DumpSink(pMixerSink) ;
            ple = pMixerSink->ActiveQueue.Flink ;
        }
    }
}
VOID
DumpSourcePinStatistics
(
    VOID
)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;       Copyright (c) 1988-2000, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       This file defines the current memory model being used.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86               8086/8088 processor
;   -DI286              80286 processor
;   -DI386              80386 processor with 32-bit code/data segment
;
;   -Dmem_S             Small memory model   (near code, near data)
;   -Dmem_M             Medium memory model  (far code, near data)
;   -Dmem_C             Compact memory model (near code, fat data)
;   -Dmem_L             Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP     SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu                         86, 286, or 386
;   sizeC                       code distance; 1 = far code, 0 = near code
;   sizeD                       data distance; 1 = far data, 0 = near data
;   mmodel                      english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE         size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE  size of float, double, long double
;   NPSIZE, FPSIZE              size of near/far pointers
;   CPSIZE, DPSIZE              size of code/data pointers
;   ISHIFT, LSHIFT              bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx,         expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ                       jump when rcx is zero
;   CBI                         convert byte to int (al to rax)
;   CAXDX                       convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL      zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES                  load data pointer with ES or DS
;   PDS, PES                    segment overrides when pointer loaded as above
;   PCS, PSS                    segment override to get at code/stack segment
;   LFPDS, LFPES                load far pointer with ES or DS
;   FPDS, FPES                  segment overrides when pointer loaded as above
;   CPTR                        data type of code pointer
;   CPDIST                      distance of code (near/far)
;   DNPTR, DFPTR                define near/far pointer
;   DCPTR, DDPTR                define code/data pointer
;   DCPTR?, DDPTR?              define uninitialized code/data pointer
;   CPWORD, DPWORD              data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD         data type of int, long, short
;   DINT, DLONG, DSHORT         define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE   define float, double, long double
; Offsets:
;   codeoffset, dataoffset      offsets from code and data segments
; API calls:
;   APIDIST                     distance of API calls (near/far)
;   APIEXT ApiName              extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg                     define/declare code segment
;   error <msg>                 stop assembly with message
;   display <msg>               display a message, unless QUIET defined
;   savelist [<reg> ...]        init list of regs to be save by 'proc uses'
;   _if cond <instruction>      assemble instruction only if cond is TRUE
;   _ife cond <instruction>     assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>   assemble instruction only if symbol defined
;   _ifnd symbol <instruction>  assemble instruction only if symbol not defined
;
;   lab  LabelName              assembles to "LabelName:" If DEBUG is defined
;                               LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)   assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat   defines a static variable of type *
;   global* Name, InitialValue, Repeat   defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}      defines a label of type *
;
;   PUSH16  SegmentReg          pushes 16 bits in a use32 segment
;   JMPFAR16  label             will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>   -    Output message and generate error

error   MACRO   msg
if2                     ;; only on pass 2 can we generate errors
        %out    **********************************************************
        %out    *** E r r o r  --  msg
        %out    **********************************************************
        .err
endif
        ENDM

; display msg   -    Output message unless QUIET defined

display MACRO   msg
ifndef QUIET            ;; only when quiet flag not set
if1                     ;; and on pass 1, then display message
        %out msg
endif
endif
        ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;                                              push  ds
;                                          endif

_if     MACRO   cond,text
    if  cond
        text
    endif
        ENDM

_ife    MACRO   cond,text
    ife cond
        text
    endif
        ENDM

_ifd    MACRO   cond,text
    ifdef   cond
        text
    endif
        ENDM

_ifnd   MACRO   cond,text
    ifndef  cond
        text
    endif
        ENDM

; set windows flag to 0

        ?WIN    equ     0       ; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
        ; Medium model
        sizeC   equ     1
        sizeD   equ     0
        mmodel  equ     <Medium>
elseifdef  mem_C
        ; Compact model
        sizeC   equ     0
        sizeD   equ     1
        mmodel  equ     <Compact>
elseifdef  mem_L
        ; Large model
        sizeC   equ     1
        sizeD   equ     1
        mmodel  equ     <Large>
else
        ; Small model - default
        sizeC   equ     0
        sizeD   equ     0
        mmodel  equ     <Small>
endif

; Process processor arguments

ifdef   _WIN32
        display <Processor:             486/586>
        cpu equ 586
        .586
elseifdef   I286
        display <Processor:             80286>
        cpu equ 286
        .286
elseifdef   I386
        display <Processor:             80386>
        cpu equ 386
        .386
else
        display <Processor:             8086/8088>
        cpu equ 86
        .8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
        error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
        error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
        error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%       display <Memory model:          mmodel>
%       .model  mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef   I386
        ; ensure that MASM recognizes 'FLAT'
        assume  gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>    ; convert byte to int (al to rax)
    CAXDX equ <cdq>              ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>    ; zero extend al
    ZXBL  equ <movzx ebx, bl>    ; zero extend bl
    ZXCL  equ <movzx ecx, cl>    ; zero extend cl
    ZXDL  equ <movzx edx, dl>    ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>              ; convert byte to int (al to rax)
    CAXDX equ <cwd>              ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>       ; zero extend al
    ZXBL  equ <xor bh, bh>       ; zero extend bl
    ZXCL  equ <xor ch, ch>       ; zero extend cl
    ZXDL  equ <xor dh, dh>       ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>              ; large code model or non-386
else
 IF 1   ;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <>                 ; 386 small code model
 ENDIF  ;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>             ; SS != DS
else
    PSS   equ <>                ; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset  equ <offset FLAT:>
    dataoffset  equ <offset FLAT:>
else
    codeoffset  equ <offset @code:>
    dataoffset  equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386       ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>            ; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>          ; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword>         ; code pointers are dwords
    DPWORD  equ <dword>         ; data pointers are dwords

    APIDIST equ <near>          ; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:near
endm

else    ;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    if sizeC
        DCPTR   equ <dd>       ; 16 bit segment and 16 bit offset
        DCPTR?  equ <dd>
        CPSIZE  equ 4
        CPDIST  equ <far>      ; code pointers are far
        CPTR    equ <far ptr>
        CPWORD  equ <dword>    ; code pointers are dwords
    else
        DCPTR   equ <dw>       ; 16 bit offset only
        DCPTR?  equ <dw>
        CPSIZE  equ 2
        CPDIST  equ <near>     ; code pointers are near
        CPTR    equ <near ptr>
        CPWORD  equ <word>     ; code pointers are words
    endif

    if sizeD
        DDPTR   equ <dd>
        DDPTR?  equ <dd>
        DPSIZE  equ 4
        DPWORD  equ <dword>    ; data pointers are dwords
    else
        DDPTR   equ <dw>
        DDPTR?  equ <dw>
        DPSIZE  equ 2
        DPWORD  equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>           ; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:far
endm

endif   ; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ    4       ; float
DBLSIZE  equ    8       ; double
LDBLSIZE equ    10      ; long double

DFLOAT   equ    <dd>
DDOUBLE  equ    <dq>
DLDOUBLE equ    <dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;       reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;       reglist = text string of registers that can be passed to the 'uses'
;       option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
        local   ws, listsize
        ws      catstr  < >             ; whitespace char

        IFNDEF  I386
         rbx equ <>                     ; 8086/286 don't save rbx
        ENDIF

        IFNB        <reg4>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
        ELSEIFNB    <reg3>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws
        ELSEIFNB    <reg2>
         reglist     catstr  reg1, ws, reg2, ws,       ws
        ELSEIFNB    <reg1>
         reglist     catstr  reg1, ws,       ws,       ws
        ELSE
         reglist     catstr  <>
        ENDIF

        listsize sizestr reglist        ; size of register list

        IF      listsize LE 3           ; if list is only the 3 ws chars...
         reglist catstr  <>
        ENDIF

        IFNDEF  I386
         rbx equ <bx>                   ; restore rbx
        ENDIF

        ENDM    ; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;       .code _TEXT     ; for large code models
;       .code           ; for small code models
;       assume  cs:FLAT ; for 386
;       assume  ds:FLAT ; for 386
;       assume  es:FLAT ; for 386
;       assume  ss:FLAT ; for 386
;

codeseg MACRO

if      sizeC
        .code _TEXT
else
        .code
endif

ifdef   I386
        assume  ds:FLAT
        assume  es:FLAT
        assume  ss:FLAT
endif

        ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab     macro name
ifdef   DEBUG
    public  pascal name     ;; define label public for Symdeb
endif
name:
        endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


        irp     x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x    equ   <j&x short>
        endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*      globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType        ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public  name
ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeGlobal  T, dt                   ; globalT
    MakeGlobal  Q, dq                   ; globalQ
    MakeGlobal  D, dd                   ; globalD
    MakeGlobal  W, dw                   ; globalW
    MakeGlobal  B, db                   ; globalB

%   MakeGlobal  I, <DINT>               ; globalI

%   MakeGlobal  DP, <DDPTR>             ; globalDP
%   MakeGlobal  CP, <DCPTR>             ; globalCP
%   MakeGlobal  FP, <DFPTR>             ; globalFP
%   MakeGlobal  NP, <DNPTR>             ; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*      staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType        ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name                     ;; make statics public if DEBUG
endif

ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeStatic  T, dt                   ; staticT
    MakeStatic  Q, dq                   ; staticQ
    MakeStatic  D, dd                   ; staticD
    MakeStatic  W, dw                   ; staticW
    MakeStatic  B, db                   ; staticB

%   MakeStatic  I, <DINT>               ; staticI

%   MakeStatic  DP, <DDPTR>             ; staticDP
%   MakeStatic  CP, <DCPTR>             ; staticCP
%   MakeStatic  FP, <DFPTR>             ; staticFP
%   MakeStatic  NP, <DNPTR>             ; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*      labelI   Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic    macro   name, option    ;; decides if a label should be
ifidni  <option>, <PUBLIC>              ;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
        public  pascal name     ;; make public if DEBUG
    endif
endif
                endm


MakeLabel   macro suffix, LabelType     ;; makes all of the label* macros

%@CatStr(<label>,<suffix>)      macro   name, option
        __MakePublic    <name>,<option>
name    label   &LabelType
        endm

        endm


        MakeLabel   T, tbyte    ; make labelT
        MakeLabel   Q, qword    ; make labelQ
        MakeLabel   D, dword    ; make labelD
        MakeLabel   W, word     ; make labelW
        MakeLabel   B, byte     ; make labelB

        MakeLabel   P, proc     ; make labelP
        MakeLabel   FP, far     ; make labelFP
        MakeLabel   NP, near    ; make labelNP

%       MakeLabel   I, IWORD    ; make labelI


labelDP macro   name, option                ;; labelDP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeD
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeD
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm

labelCP macro   name, option                ;; labelCP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeC
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeC
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16  macro   SegReg

ifdef I386
        nop
        db      66h         ; operand size over-ride
endif   ; I386

        push    SegReg
        endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro  label

ifndef I386
        error  <JMPFAR16 can only be used in a use32 code segment>
endif   ;I386

        nop
        db      66h         ;; operand size over-ride
        db      0eah        ;; jmp far immediate op code
        dw      offset label
        dw      seg label
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wdm.h>

#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <ksmediap.h>
#include <ksdebug.h>
#include <swenum.h>
#include <math.h>

#include "modeflag.h"
#include "rsiir.h"
#include "slocal.h"
#include "rfcvec.h"
#include "rfiir.h"
#include "flocal.h"
#include "fpconv.h"
#include "private.h"

#ifdef REALTIME_THREAD
#include "rt.h"
VOID RtMix(PVOID Context, ThreadStats *Statistics);
#endif

#if DBG
#define INVALID_POINTER (PVOID)(-1)
#else
#define INVALID_POINTER NULL
#endif

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")

#ifdef REALTIME_THREAD
#define PAGEABLE_CODE     code_seg(".text", "CODE")
#define PAGEABLE_DATA     data_seg(".data", "DATA")
#else
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#endif

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\dxcrt.c ===
//---------------------------------------------------------------------------
//
//  Module:   dxcrt.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <math.h>

double _stdcall pow2( double x )
{
    return pow(2.0,x);
}

double _stdcall fylog2x( double y, double x )
{
    return( y*log(x)/log(2.0) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\fir.h ===
//---------------------------------------------------------------------------
//
//  Module:   fir.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//===========================================================================
//===========================================================================

#define FILTER_SIZE_NONE        320
#define FILTER_SIZE_LOW			320
#define FILTER_SIZE_BASIC		3360
#define FILTER_SIZE_ADVANCED	9600

FLOAT	DuplicatingFilter[] ;
FLOAT	LowQualityFilter[] ;
FLOAT	BasicFilter[] ;
FLOAT	AdvancedFilter[] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\filter.c ===
//---------------------------------------------------------------------------
//
//  Module:   filter.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

GUID KMIXERPROPSETID_Perf = {0x3EDFD090L, 0x070C, 0x11D3, 0xAE, 0xF1, 0x00, 0x60, 0x08, 0x1E, 0xBB, 0x9A};
typedef enum {
    KMIXERPERF_TUNABLEPARAMS,
    KMIXERPERF_STATS
} KMIXERPERF_ITEMS;


NTSTATUS
AllocatorDispatchCreatePin(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static const WCHAR PinTypeName[] = KSSTRING_Pin ;
static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;

BOOL    fLogToFile = FALSE;
extern ULONG gFixedSamplingRate;


DEFINE_KSCREATE_DISPATCH_TABLE ( CreateHandlers )
{
    DEFINE_KSCREATE_ITEM (PinDispatchCreate, PinTypeName, 0),
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreatePin, AllocatorTypeName, 0)
};

KSDISPATCH_TABLE FilterDispatchTable =
{
    FilterDispatchIoControl,
    NULL,
    KsDispatchInvalidDeviceRequest,
    NULL,
    FilterDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

DEFINE_KSPROPERTY_PINSET(
    FilterPropertyHandlers,
    PinPropertyHandler,
    PinInstances,
    FilterPinIntersection
) ;

DEFINE_KSPROPERTY_TABLE(FilterConnectionHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_STATE,                // PropertyId
        NULL,                                       // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( ULONG ),                            // MinSetDataOutput
        FilterStateHandler,                         // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    )
} ;

DEFINE_KSPROPERTY_TOPOLOGYSET(
        TopologyPropertyHandlers,
        FilterTopologyHandler
);

DEFINE_KSPROPERTY_TABLE(FilterAudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_CPU_RESOURCES,             // PropertyId
        MxGetCpuResources,                          // GetHandler
        sizeof( KSNODEPROPERTY ),                   // MinSetPropertyInput
        sizeof( ULONG ),                            // MinSetDataOutput
        NULL,                                       // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SURROUND_ENCODE,                // idProperty
       MxGetSurroundEncode,                             // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOL),                                    // cbMinGetDataInput
       MxSetSurroundEncode,                             // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

} ;

DEFINE_KSPROPERTY_TABLE(PerfPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KMIXERPERF_TUNABLEPARAMS,                   // PropertyId
        MxGetTunableParams,                         // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( TUNABLEPARAMS ),                    // MinSetDataOutput
        MxSetTunableParams,                         // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KMIXERPERF_STATS,                           // PropertyId
        MxGetPerfStats,                             // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( PERFSTATS ),                        // MinSetDataOutput
        NULL,                                       // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    )
} ;

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Pin,                            // Set
       SIZEOF_ARRAY( FilterPropertyHandlers ),      // PropertiesCount
       FilterPropertyHandlers,                      // PropertyItem
       0,                                           // FastIoCount
       NULL                                         // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Connection,                     // Set
       SIZEOF_ARRAY( FilterConnectionHandlers ),    // PropertiesCount
       FilterConnectionHandlers,                    // PropertyItem
       0,                                           // FastIoCount
       NULL                                         // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Topology,                      // Set
        SIZEOF_ARRAY(TopologyPropertyHandlers),     // PropertiesCount
        TopologyPropertyHandlers,                   // PropertyItem
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,                         // Set
        SIZEOF_ARRAY(FilterAudioPropertyHandlers),  // PropertiesCount
        FilterAudioPropertyHandlers,                // PropertyItem
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KMIXERPROPSETID_Perf,
        SIZEOF_ARRAY(PerfPropertyHandlers),
        PerfPropertyHandlers,
        0,
        NULL
    )
} ;

KSPIN_INTERFACE PinInterfaces[] =
{
    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_STREAMING
    },
    {
        STATICGUIDOF(KSINTERFACESETID_Media),
        KSINTERFACE_MEDIA_WAVE_QUEUED
    },
    {
    STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_LOOPED_STREAMING
    }
} ;

KSPIN_MEDIUM PinMediums[] =
{
    {
        STATICGUIDOF(KSMEDIUMSETID_Standard),
        KSMEDIUM_STANDARD_DEVIO
    }
} ;

KSDATARANGE_AUDIO FilterDigitalAudioFormats[] =
{
    {   // 0
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 1
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 2
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        32,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 3
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 4
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND),
        },
        (ULONG) -1L,
        32,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    }
};

PKSDATARANGE SinkDataFormats[] =
{   // These are listed in order of kmixer's preference, which is highest to lowest quality.
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 2 ],  // IEEE Float, WAVEFORMAT specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 0 ],  // PCM, WAVEFORMAT specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 4 ],  // IEEE Float, DSOUND specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 1 ]   // PCM, DSOUND specifier
} ;

PKSDATARANGE SourceDataFormats[] =
{   // These are listed in order of kmixer's preference, which is highest to lowest quality.
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 2 ],  // IEEE Float
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 3 ]   // PCM, WAVEFORMAT specifier
} ;

const KSPIN_CINSTANCES gPinInstances[] =
{
    // Indeterminate number of possible connections.

    {
    1,          // cPossible
    0           // cCurrent
    },

    {
    (ULONG)-1,  // cPossible
    0           // cCurrent
    },

    // Source pin, flow=in
    {
    1,          // cPossible
    0           // cCurrent
    },

    // Sink pin, flow=out
    {
    1,          // cPossible
    0           // cCurrent
    },
} ;

KSPIN_DESCRIPTOR PinDescs[] =
{
    // mixer source
    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    1,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_OUT,
    KSPIN_COMMUNICATION_SOURCE
    ),

    // mixer sink

    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    3,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SinkDataFormats ),
    SinkDataFormats,
    KSPIN_DATAFLOW_IN,
    KSPIN_COMMUNICATION_SINK
    ),

    // mixer source
    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    1,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_IN,
    KSPIN_COMMUNICATION_SOURCE
    ),

    // mixer sink

    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    2,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_OUT,
    KSPIN_COMMUNICATION_SINK
    )
} ;


#pragma LOCKED_DATA

PFILTER_INSTANCE    gpFilterInstance = NULL; // only for debug purpose
LIST_ENTRY  gleFilterList;  // only for debug purposes
extern DWORD    PreferredQuality;

extern ULONG gNumCompletionsWhileStarved ;
extern ULONG gNumMixBuffersAdded;
extern ULONG gNumSilenceSamplesInserted;
//
// kmixer tuner variables
//
ULONG      gMaxNumMixBuffers = DEFAULT_MAXNUMMIXBUFFERS ;
ULONG      gMinNumMixBuffers = DEFAULT_MINNUMMIXBUFFERS ;
ULONG      gMixBufferDuration = DEFAULT_MIXBUFFERDURATION ;
ULONG      gStartNumMixBuffers = DEFAULT_STARTNUMMIXBUFFERS ;
ULONG      gPreferredQuality = DEFAULT_PREFERREDQUALITY ;
ULONG      gDisableMmx = DEFAULT_DISABLEMMX ;
ULONG      gMaxOutputBits = DEFAULT_MAXOUTPUTBITS ;
ULONG      gMaxDsoundInChannels = DEFAULT_MAXDSOUNDINCHANNELS ;
ULONG      gMaxOutChannels = DEFAULT_MAXOUTCHANNELS ;
ULONG      gMaxInChannels = DEFAULT_MAXINCHANNELS ;
ULONG      gMaxFloatChannels = DEFAULT_MAXFLOATCHANNELS ;
ULONG      gLogToFile = DEFAULT_LOGTOFILE ;
ULONG      gFixedSamplingRate = DEFAULT_FIXEDSAMPLINGRATE ;
ULONG      gEnableShortHrtf = DEFAULT_ENABLESHORTHRTF ;
ULONG      gBuildPartialMdls = DEFAULT_BUILDPARTIALMDLS ;

#ifdef REALTIME_THREAD
ULONG      gDisableRealTime = FALSE;
#endif
#ifdef PRIVATE_THREAD
KPRIORITY  gWorkerThreadPriority = 24 ;
#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
OpenRegistryKey(
    PWSTR pwstr,
    PHANDLE pHandle
)
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pwstr);

    InitializeObjectAttributes( &ObjectAttributes, &UnicodeDeviceString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    return(ZwOpenKey( pHandle, GENERIC_READ | GENERIC_WRITE, &ObjectAttributes));
}

NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PWSTR pwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    RtlInitUnicodeString(&ustrValueName, pwstrValueName);
    Status = ZwQueryValueKey( hkey, &ustrValueName, KeyValueFullInformation, NULL, 0, &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW && Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = ExAllocatePoolWithTag(PagedPool, cbValue, 0x58494d4b);  // 'KMIX'
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    RtlZeroMemory(*ppkvfi, cbValue);

    Status = ZwQueryValueKey( hkey, &ustrValueName, KeyValueFullInformation, *ppkvfi, cbValue, &cbValue);

exit:
    return(Status);
}

ULONG
GetUlongFromRegistry(
    PWSTR pwstrRegistryValue,
    ULONG DefaultValue
)
{
    PULONG      pulValue ;
    ULONG       ulValue ;
    NTSTATUS    Status ;

    Status = QueryRegistryValueEx(RTL_REGISTRY_ABSOLUTE,
                         REGSTR_PATH_MULTIMEDIA_KMIXER,
                         pwstrRegistryValue,
                         REG_DWORD,
                         &pulValue,
                         &DefaultValue,
                         sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        ulValue = *((PDWORD)pulValue);
        ExFreePool(pulValue);
    }
    else {
        ulValue = DefaultValue;
    }
    return ( ulValue ) ;
}

NTSTATUS
QueryRegistryValueEx(
    ULONG Hive,
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG uValueType,
    PVOID *ppValue,
    PVOID pDefaultData,
    ULONG DefaultDataLength
)
{
    PRTL_QUERY_REGISTRY_TABLE pRegistryValueTable = NULL;
    UNICODE_STRING usString;
    DWORD dwValue;
    NTSTATUS Status = STATUS_SUCCESS;
    usString.Buffer = NULL;

    pRegistryValueTable = ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(RTL_QUERY_REGISTRY_TABLE)*2),
                            'XIMK');

    if(!pRegistryValueTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(pRegistryValueTable, (sizeof(RTL_QUERY_REGISTRY_TABLE)*2));

    pRegistryValueTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    pRegistryValueTable[0].Name = pwstrRegistryValue;
    pRegistryValueTable[0].DefaultType = uValueType;
    pRegistryValueTable[0].DefaultLength = DefaultDataLength;
    pRegistryValueTable[0].DefaultData = pDefaultData;

    switch (uValueType) {
        case REG_SZ:
            pRegistryValueTable[0].EntryContext = &usString;
            break;
        case REG_DWORD:
            pRegistryValueTable[0].EntryContext = &dwValue;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }

    Status = RtlQueryRegistryValues(
      Hive,
      pwstrRegistryPath,
      pRegistryValueTable,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    switch (uValueType) {
        case REG_SZ:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        usString.Length + sizeof(UNICODE_NULL),
                        'XIMK');
            if(!(*ppValue)) {
                RtlFreeUnicodeString(&usString);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            memcpy(*ppValue, usString.Buffer, usString.Length);
            ((PWCHAR)*ppValue)[usString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            RtlFreeUnicodeString(&usString);
            break;

        case REG_DWORD:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(DWORD),
                        'XIMK');
            if(!(*ppValue)) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            *((DWORD *)(*ppValue)) = dwValue;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }
exit:
    if (pRegistryValueTable) {
        ExFreePool(pRegistryValueTable);
    }
    return(Status);
}

VOID GetMixerSettingsFromRegistry()
{
    gMixBufferDuration = GetUlongFromRegistry( REGSTR_VAL_MIXBUFFERDURATION,
                                               DEFAULT_MIXBUFFERDURATION ) ;
    gMinNumMixBuffers = GetUlongFromRegistry( REGSTR_VAL_MINNUMMIXBUFFERS,
                                              DEFAULT_MINNUMMIXBUFFERS ) ;
    gMaxNumMixBuffers = GetUlongFromRegistry( REGSTR_VAL_MAXNUMMIXBUFFERS,
                                              DEFAULT_MAXNUMMIXBUFFERS ) ;
    gStartNumMixBuffers = GetUlongFromRegistry( REGSTR_VAL_STARTNUMMIXBUFFERS,
                                                DEFAULT_STARTNUMMIXBUFFERS ) ;
    gDisableMmx = GetUlongFromRegistry( REGSTR_VAL_DISABLEMMX,
                                        DEFAULT_DISABLEMMX ) ;
    gMaxOutputBits = GetUlongFromRegistry( REGSTR_VAL_MAXOUTPUTBITS,
                                           DEFAULT_MAXOUTPUTBITS ) ;
    gMaxInChannels = GetUlongFromRegistry( REGSTR_VAL_MAXINCHANNELS,
                                           DEFAULT_MAXINCHANNELS ) ;
    gMaxDsoundInChannels = GetUlongFromRegistry( REGSTR_VAL_MAXDSOUNDINCHANNELS,
                                                 DEFAULT_MAXDSOUNDINCHANNELS ) ;
    gMaxFloatChannels = GetUlongFromRegistry( REGSTR_VAL_MAXFLOATCHANNELS,
                                              DEFAULT_MAXFLOATCHANNELS ) ;
    gMaxOutChannels = GetUlongFromRegistry( REGSTR_VAL_MAXOUTCHANNELS,
                                            DEFAULT_MAXOUTCHANNELS ) ;
    gLogToFile = GetUlongFromRegistry( REGSTR_VAL_LOGTOFILE,
                                       DEFAULT_LOGTOFILE ) ;
    if (gLogToFile) {
        gFixedSamplingRate = TRUE ;
    }
    else {
        gFixedSamplingRate = GetUlongFromRegistry( REGSTR_VAL_FIXEDSAMPLINGRATE,
                                                   DEFAULT_FIXEDSAMPLINGRATE ) ;
    }

    gEnableShortHrtf = GetUlongFromRegistry( REGSTR_VAL_ENABLESHORTHRTF,
                                             DEFAULT_ENABLESHORTHRTF ) ;
    gBuildPartialMdls = GetUlongFromRegistry( REGSTR_VAL_BUILDPARTIALMDLS,
                                              DEFAULT_BUILDPARTIALMDLS ) ;
    gPreferredQuality = GetUlongFromRegistry( REGSTR_VAL_DEFAULTSRCQUALITY,
                                              DEFAULT_PREFERREDQUALITY );

#ifdef REALTIME_THREAD
    gDisableRealTime = GetUlongFromRegistry( REGSTR_VAL_REALTIMETHREAD,
                                             FALSE );
#endif

#ifdef PRIVATE_THREAD
    gWorkerThreadPriority = GetUlongFromRegistry( REGSTR_VAL_PRIVATETHREADPRI, 24 ) ;
#endif

    if ( (gMinNumMixBuffers == 0) ||
         (gMaxNumMixBuffers == 0) ||
         (gStartNumMixBuffers == 0) ||
         (gMixBufferDuration == 0) ) {
        gMixBufferDuration = DEFAULT_MIXBUFFERDURATION ;
        gMinNumMixBuffers = DEFAULT_MINNUMMIXBUFFERS ;
        gMaxNumMixBuffers = DEFAULT_MAXNUMMIXBUFFERS ;
        gStartNumMixBuffers = DEFAULT_STARTNUMMIXBUFFERS ;
    }

    if ( gMinNumMixBuffers > gMaxNumMixBuffers ) {
        gMaxNumMixBuffers = gMinNumMixBuffers ;
    }

    if ( gStartNumMixBuffers < gMinNumMixBuffers ) {
        gStartNumMixBuffers = gMinNumMixBuffers ;
    }

    if ( gPreferredQuality > KSAUDIO_QUALITY_ADVANCED) {
        gPreferredQuality = DEFAULT_PREFERREDQUALITY ;
    }

    if ( (gMaxOutputBits > 32) ||
         (gMaxOutputBits % 8) ||
         (gMaxOutputBits == 0) ) {
        gMaxOutputBits = DEFAULT_MAXOUTPUTBITS ;
    }

    if (gMaxDsoundInChannels == 0) {
        gMaxDsoundInChannels = DEFAULT_MAXDSOUNDINCHANNELS ;
    }

    if (gMaxOutChannels == 0) {
        gMaxOutChannels = DEFAULT_MAXOUTCHANNELS ;
    }

    if (gMaxInChannels == 0) {
        gMaxInChannels = DEFAULT_MAXINCHANNELS ;
    }

    if (gMaxFloatChannels == 0) {
        gMaxFloatChannels = DEFAULT_MAXFLOATCHANNELS ;
    }
}

NTSTATUS FilterDispatchGlobalCreate
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
   NTSTATUS            Status = STATUS_SUCCESS ;
   PFILTER_INSTANCE    pFilterInstance = NULL ;
   PIO_STACK_LOCATION  pIrpStack;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

   pFilterInstance = (PFILTER_INSTANCE) ExAllocatePoolWithTag( NonPagedPool,
                                            sizeof( FILTER_INSTANCE ), 'XIMK' );
   if (!pFilterInstance) {
       Status = STATUS_INSUFFICIENT_RESOURCES;
       goto exit;
   }
   RtlZeroMemory( pFilterInstance, sizeof( FILTER_INSTANCE ) );

   // Initialize CloseEvent to non-signalled state
   KeInitializeEvent ( &pFilterInstance->CloseEvent,
                       SynchronizationEvent,
                       FALSE ) ;
   KeInitializeSpinLock ( &pFilterInstance->MixSpinLock ) ;
   KeInitializeSpinLock ( &pFilterInstance->SinkSpinLock ) ;

   Status = KsAllocateObjectHeader ( &pFilterInstance->ObjectHeader,
                                     SIZEOF_ARRAY ( CreateHandlers ),
                                     (PKSOBJECT_CREATE_ITEM) CreateHandlers,
                                     pIrp,
                                     (PKSDISPATCH_TABLE)&FilterDispatchTable ) ;
   if (!NT_SUCCESS( Status )) {
       goto exit;
   }


   Status = KsReferenceSoftwareBusObject(
               ((PSOFTWARE_INSTANCE)pdo->DeviceExtension)->DeviceHeader );

   if (!NT_SUCCESS( Status )) {
       goto exit;
   }

   pFilterInstance->MixBufferDuration = gMixBufferDuration ;
   pFilterInstance->MinNumMixBuffers = gMinNumMixBuffers ;
   pFilterInstance->MaxNumMixBuffers = gMaxNumMixBuffers ;
   pFilterInstance->StartNumMixBuffers = gStartNumMixBuffers ;

   InitializeListHead ( &pFilterInstance->SinkConnectionList ) ;
   InitializeListHead ( &pFilterInstance->ActiveSinkList ) ;
   InitializeListHead ( &pFilterInstance->SourceConnectionList ) ;
   InitializeListHead ( &pFilterInstance->DeadQueue ) ;
   InitializeListHead ( &pFilterInstance->AgingQueue ) ;

   KeInitializeSpinLock ( &pFilterInstance->AgingDeadSpinLock );

   KeInitializeMutex ( &pFilterInstance->ControlMutex, 1 ) ;

   pFilterInstance->CurrentNumMixBuffers = STARTNUMMIXBUFFERS ;
   pFilterInstance->PresentationTime.Numerator = 1 ;
   pFilterInstance->PresentationTime.Denominator = 1 ;
#ifdef SURROUND_ENCODE
#ifdef SURROUND_VOLUME_HACK
   pFilterInstance->fSurroundEncode = TRUE;
#else
   pFilterInstance->fSurroundEncode = FALSE;
#endif
#endif

   FilterDigitalAudioFormats[3].MaximumBitsPerSample = gMaxOutputBits ;
   FilterDigitalAudioFormats[0].MaximumChannels = gMaxInChannels ;
   FilterDigitalAudioFormats[1].MaximumChannels = gMaxDsoundInChannels ;
   FilterDigitalAudioFormats[2].MaximumChannels = gMaxFloatChannels ;
   FilterDigitalAudioFormats[3].MaximumChannels = gMaxOutChannels ;
   FilterDigitalAudioFormats[4].MaximumChannels = min(gMaxFloatChannels, gMaxDsoundInChannels);
   fLogToFile = gLogToFile;

   pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
   pIrpStack->FileObject->FsContext = pFilterInstance;
   pFilterInstance->FileObject = pIrpStack->FileObject ;

#ifdef PRIVATE_THREAD
   pFilterInstance->WorkerThreadPriority = gWorkerThreadPriority ;
   //
   // Initialize the Trigger event for the Worker thread
   //
   KeInitializeEvent( &pFilterInstance->WorkerThreadEvent,
                      SynchronizationEvent,
                      FALSE ) ;

   //
   // Create the Worker thread
   //
   Status = PsCreateSystemThread( &pFilterInstance->WorkerThreadHandle,
                                  (ACCESS_MASK) 0L,
                                  NULL,
                                  NULL,
                                  NULL,
                                  MxPrivateWorkerThread,
                                  pFilterInstance ) ;
   //
   // Get the Worker thread object pointer
   //
   if ( NT_SUCCESS(Status) ) {
       //
       // On successful thread creation
       //
       Status = ObReferenceObjectByHandle( pFilterInstance->WorkerThreadHandle,
                                          GENERIC_READ | GENERIC_WRITE,
                                          NULL,
                                          KernelMode,
                                          &pFilterInstance->WorkerThreadObject,
                                          NULL ) ;
       //
       // We do not need the thread handle any more
       //
       ZwClose( pFilterInstance->WorkerThreadHandle ) ;

       if ( !NT_SUCCESS(Status) ) {
           //
           // If Obref failed
           // Kill the worker thread by setting the event & Exit flag
           //
           // Note: we do not have to deref the object, since it is not ref'd in the failure case.
           pFilterInstance->WorkerThreadExit = TRUE ;
           KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
       }
   }

   if ( !NT_SUCCESS(Status) ) {
       goto exit ;
   }
#endif

   RtlCopyMemory(pFilterInstance->LocalPinInstances, gPinInstances, sizeof( gPinInstances ) );

   InsertTailList ( &gleFilterList, &pFilterInstance->NextInstance ) ;
   gpFilterInstance = pFilterInstance ;

exit:
   if(!NT_SUCCESS(Status) && pFilterInstance != NULL) {
      if ( pFilterInstance->ObjectHeader ) {
          KsFreeObjectHeader ( pFilterInstance->ObjectHeader ) ;
      }
      ExFreePool( pFilterInstance );
   }

   if (NT_SUCCESS(Status)) {
       PerfRegisterProvider (pdo);
   }

   pIrp->IoStatus.Information = 0;
   pIrp->IoStatus.Status = Status;
   IoCompleteRequest( pIrp, 0 );
   return Status;
}

NTSTATUS FilterDispatchClose
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
   PIO_STACK_LOCATION  pIrpStack;
   PFILTER_INSTANCE    pFilterInstance ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

   PerfUnregisterProvider (pdo);

   pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
   pFilterInstance = pIrpStack->FileObject->FsContext ;

#ifdef REALTIME_THREAD
    ASSERT ( pFilterInstance->RealTimeThread == NULL );
#endif

#ifdef PRIVATE_THREAD
   pFilterInstance->WorkerThreadExit = TRUE ;
   KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
   KeWaitForSingleObject( pFilterInstance->WorkerThreadObject,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL ) ;

   ObDereferenceObject( pFilterInstance->WorkerThreadObject ) ;
#endif

   KsFreeObjectHeader ( pFilterInstance->ObjectHeader ) ;

   RemoveEntryList ( &pFilterInstance->NextInstance ) ;

   ExFreePool( pFilterInstance );

   gpFilterInstance = NULL ;

   KsDereferenceSoftwareBusObject(((PSOFTWARE_INSTANCE)pdo->DeviceExtension)->DeviceHeader );

   pIrp->IoStatus.Information = 0;
   pIrp->IoStatus.Status = STATUS_SUCCESS;
   IoCompleteRequest( pIrp, 0 );

   return STATUS_SUCCESS;
}

NTSTATUS FilterDispatchIoControl
(
   IN PDEVICE_OBJECT pDeviceObject,
   IN PIRP           pIrp
)
{
    NTSTATUS                     Status;
    PIO_STACK_LOCATION           pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {

        case IOCTL_KS_PROPERTY:
            Status =
                KsPropertyHandler( pIrp, SIZEOF_ARRAY(FilterPropertySet),
                                   (PKSPROPERTY_SET) FilterPropertySet );
            break ;

        default:
            return KsDefaultDeviceIoCompletion(pDeviceObject, pIrp);
    }

    if (STATUS_PENDING == Status)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("PinDispatchIoControl: synchronous function returned STATUS_PENDING") );
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS PinPropertyHandler
(
   IN PIRP         pIrp,
   IN PKSPROPERTY  pProperty,
   IN OUT PVOID    pvData
)
{
   return KsPinPropertyHandler( pIrp,
                                pProperty,
                                pvData,
                                SIZEOF_ARRAY( PinDescs ),
                                PinDescs );
}

NTSTATUS
AllocatorDispatchCreatePin(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Forwards the allocator creation request to the default allocator.

Arguments:

    DeviceObject -
        Pointer to the device object

    Irp -
        Pointer to the I/O request packet

Return:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    NTSTATUS Status;
    Status = KsCreateDefaultAllocator(Irp);
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS PinInstances
(
    IN PIRP                 pIrp,
    IN PKSP_PIN             pPin,
    OUT PKSPIN_CINSTANCES   pCInstances
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;

    if ( ( pPin->PinId < MAXNUM_PIN_TYPES ) ) {
        *pCInstances = pFilterInstance->LocalPinInstances[ pPin->PinId  ];
    }
    else {
        return STATUS_INVALID_PARAMETER;
    }

    pIrp->IoStatus.Information = sizeof( KSPIN_CINSTANCES );

    return STATUS_SUCCESS;

} // PinXxxInstances()


NTSTATUS FilterStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE DeviceState
)
{
        return ( STATUS_SUCCESS ) ;
}

VOID
WaveFormatFromAudioRange (
    PKSDATARANGE_AUDIO  pDataRangeAudio,
    WAVEFORMATEX *      pWavFormatEx)
{
    if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
        pWavFormatEx->wFormatTag =
          EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat);
    }
    else {
        pWavFormatEx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    }
    pWavFormatEx->nChannels = (WORD)pDataRangeAudio->MaximumChannels;
    pWavFormatEx->nSamplesPerSec = pDataRangeAudio->MaximumSampleFrequency;
    pWavFormatEx->wBitsPerSample = (WORD)pDataRangeAudio->MaximumBitsPerSample;
    pWavFormatEx->nBlockAlign =
      (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
    pWavFormatEx->nAvgBytesPerSec =
      pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
    pWavFormatEx->cbSize = 0;
}

VOID
LimitAudioRangeToWave (
    PWAVEFORMATEX       pWaveFormatEx,
    PKSDATARANGE_AUDIO  pDataRangeAudio)
{
    if(pDataRangeAudio->MinimumSampleFrequency <=
       pWaveFormatEx->nSamplesPerSec &&
       pDataRangeAudio->MaximumSampleFrequency >=
       pWaveFormatEx->nSamplesPerSec) {
        pDataRangeAudio->MaximumSampleFrequency = pWaveFormatEx->nSamplesPerSec;
    }
    if(pDataRangeAudio->MinimumBitsPerSample <=
       pWaveFormatEx->wBitsPerSample &&
       pDataRangeAudio->MaximumBitsPerSample >=
       pWaveFormatEx->wBitsPerSample) {
        pDataRangeAudio->MaximumBitsPerSample = pWaveFormatEx->wBitsPerSample;
    }
    if(pDataRangeAudio->MaximumChannels == MAXULONG) {
    pDataRangeAudio->MaximumChannels = pWaveFormatEx->nChannels;
    }
}

VOID
LimitAudioRange (PKSDATARANGE_AUDIO  pDataRangeAudio)
{
    WAVEFORMATEX WaveFormatEx;

    // Default values
    WaveFormatEx.nSamplesPerSec = 44100;
    WaveFormatEx.wBitsPerSample = 16;
    WaveFormatEx.nChannels = 2;

    LimitAudioRangeToWave(&WaveFormatEx, pDataRangeAudio);
}

BOOL DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
)
{
    // Pick up pDataRange1 values by default.
    *pDataRangeIntersection = *pDataRange1;

    if(IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
       IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->MajorFormat = pDataRange2->MajorFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->MajorFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
       IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->SubFormat = pDataRange2->SubFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->SubFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
       IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->Specifier = pDataRange2->Specifier;
    }
    else if(!IsEqualGUID(
      &pDataRange2->Specifier,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    pDataRangeIntersection->Reserved = 0; // Must be zero
    return(TRUE);
}


BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
)
{
    if(pDataRangeAudio1->MaximumChannels <
       pDataRangeAudio2->MaximumChannels) {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio1->MaximumChannels;
    }
    else {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio2->MaximumChannels;
    }

    if(pDataRangeAudio1->MaximumSampleFrequency <
       pDataRangeAudio2->MaximumSampleFrequency) {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio1->MaximumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio2->MaximumSampleFrequency;
    }
    if(pDataRangeAudio1->MinimumSampleFrequency >
       pDataRangeAudio2->MinimumSampleFrequency) {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio1->MinimumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio2->MinimumSampleFrequency;
    }
    if(pDataRangeAudioIntersection->MaximumSampleFrequency <
       pDataRangeAudioIntersection->MinimumSampleFrequency ) {
        return(FALSE);
    }

    if(pDataRangeAudio1->MaximumBitsPerSample <
       pDataRangeAudio2->MaximumBitsPerSample) {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio1->MaximumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio2->MaximumBitsPerSample;
    }
    if(pDataRangeAudio1->MinimumBitsPerSample >
       pDataRangeAudio2->MinimumBitsPerSample) {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio1->MinimumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio2->MinimumBitsPerSample;
    }
    if(pDataRangeAudioIntersection->MaximumBitsPerSample <
       pDataRangeAudioIntersection->MinimumBitsPerSample ) {
        return(FALSE);
    }
    return(TRUE);
}

NTSTATUS
DefaultIntersectHandler(
    IN PKSDATARANGE     DataRange,
    IN PKSDATARANGE     pDataRangePin,
    IN ULONG            OutputBufferLength,
    OUT PVOID           Data,
    OUT PULONG          pDataLength
    )
{
    KSDATARANGE_AUDIO   DataRangeAudioIntersection;
    ULONG               ExpectedBufferLength;
    PWAVEFORMATEX       pWaveFormatEx;
    BOOL                bDSoundFormat = FALSE;

    // Check for generic match on the specific ranges, allowing wildcards.
    if (!DataIntersectionRange(pDataRangePin,
                               DataRange,
                               &DataRangeAudioIntersection.DataRange)) {
        return STATUS_NO_MATCH;
    }

    // Check for format matches that the default handler can deal with.
    if (IsEqualGUID(
       &pDataRangePin->Specifier,
       &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
    {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)Data)->WaveFormatEx);
        ExpectedBufferLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else if (IsEqualGUID(
       &pDataRangePin->Specifier,
       &KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        bDSoundFormat = TRUE;
        pWaveFormatEx =
          &(((KSDATAFORMAT_DSOUND *)Data)->BufferDesc.WaveFormatEx);
        ExpectedBufferLength = sizeof(KSDATAFORMAT_DSOUND);
    }
    else
    {
        return STATUS_NO_MATCH;
    }

    // GUIDs match, so check for valid intersection of audio ranges.
    if (!DataIntersectionAudio((PKSDATARANGE_AUDIO)pDataRangePin,
                               (PKSDATARANGE_AUDIO)DataRange,
                               &DataRangeAudioIntersection)) {
        return STATUS_NO_MATCH;
    }

    // Have a match!
    // Determine whether the data format itself is to be returned, or just
    // the size of the data format so that the client can allocate memory
    // for the full range.

    if (!OutputBufferLength) {
        *pDataLength = ExpectedBufferLength;
        return STATUS_BUFFER_OVERFLOW;
    } else if (OutputBufferLength < ExpectedBufferLength) {
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        // Because maximums in ranges are generally random, limit maximums.
        LimitAudioRange(&DataRangeAudioIntersection);

        // Get WAV format from intersected and limited maximums.
        WaveFormatFromAudioRange(&DataRangeAudioIntersection, pWaveFormatEx);

        // Copy across DATARANGE/DATAFORMAT_x part of match, and adjust fields.
        *(PKSDATARANGE)Data = DataRangeAudioIntersection.DataRange;
        ((PKSDATAFORMAT)Data)->FormatSize = ExpectedBufferLength;

        // Fill in DSOUND specific fields, if any.
        if (bDSoundFormat) {
            ((PKSDATAFORMAT_DSOUND)Data)->BufferDesc.Flags = 0;
            ((PKSDATAFORMAT_DSOUND)Data)->BufferDesc.Control = 0;
        }
        *pDataLength = ExpectedBufferLength;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    )
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    NTSTATUS            Status = STATUS_NO_MATCH;
    ULONG               OutputBufferLength;
    PKSDATARANGE        pDataRangePin;
    UINT                i;
    ULONG               DataLength = 0;

    // The underlying pin does not support data intersection.
    // Do the data intersection on its behalf for the pin formats that SYSAUDIO understands.
    //
    // All the major/sub/specifier checking has been done by the handler, but may include wildcards.
    //
    pIrpStack = IoGetCurrentIrpStackLocation( Irp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
    for (i = 0; i < PinDescs[Pin->PinId].DataRangesCount; i++) {
        pDataRangePin = PinDescs[Pin->PinId].DataRanges[i];
        Status = DefaultIntersectHandler (DataRange,
                                          pDataRangePin,
                                          OutputBufferLength,
                                          Data,
                                          &DataLength);
        if(Status == STATUS_NO_MATCH) {
            continue;
        }
        Irp->IoStatus.Information = DataLength;
        break;
    }
    return Status;
}



NTSTATUS
FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    pIrp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    return KsPinDataIntersection(
        pIrp,
        Pin,
        Data,
        SIZEOF_ARRAY(PinDescs), //cPins,
        PinDescs,
        IntersectHandler);
}

NTSTATUS
MxGetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
)
{
    pTunableParams->MinNumMixBuffers = gMinNumMixBuffers ;
    pTunableParams->MaxNumMixBuffers = gMaxNumMixBuffers ;
    pTunableParams->StartNumMixBuffers = gStartNumMixBuffers ;
    pTunableParams->MixBufferDuration = gMixBufferDuration ;
    pTunableParams->PreferredQuality = gPreferredQuality ;
    pTunableParams->DisableMmx = gDisableMmx ;
    pTunableParams->MaxOutputBits = gMaxOutputBits ;
    pTunableParams->MaxDsoundInChannels = gMaxDsoundInChannels ;
    pTunableParams->MaxOutChannels = gMaxOutChannels ;
    pTunableParams->MaxInChannels = gMaxInChannels ;
    pTunableParams->MaxFloatChannels = gMaxFloatChannels ;
    pTunableParams->LogToFile = gLogToFile ;
    pTunableParams->FixedSamplingRate = gFixedSamplingRate ;
    pTunableParams->EnableShortHrtf = gEnableShortHrtf ;
    pTunableParams->BuildPartialMdls = gBuildPartialMdls ;
#ifdef PRIVATE_THREAD
    pTunableParams->WorkerThreadPriority = gWorkerThreadPriority ;
#else
    pTunableParams->WorkerThreadPriority = -1 ;
#endif

    pIrp->IoStatus.Information = sizeof (TUNABLEPARAMS);
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxSetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
)
{
    //
    // If there are other filter instances do not set any variables
    //
    if ( gleFilterList.Flink != gleFilterList.Blink ) {
        return ( STATUS_DEVICE_NOT_READY ) ;
    }

    //
    // do some parameter validations [min<= max, start >= min etc]
    //
    if ( (pTunableParams->MinNumMixBuffers > pTunableParams->MaxNumMixBuffers) ||
         (pTunableParams->MinNumMixBuffers > pTunableParams->StartNumMixBuffers) ||
         (pTunableParams->StartNumMixBuffers > pTunableParams->MaxNumMixBuffers) ||
         (pTunableParams->MinNumMixBuffers == 0) ||
         (pTunableParams->MixBufferDuration == 0) ||
         (pTunableParams->PreferredQuality > KSAUDIO_QUALITY_ADVANCED) ||
         (pTunableParams->MaxOutputBits > 32) ||
         (pTunableParams->MaxOutputBits % 8) ||
         (pTunableParams->MaxOutputBits == 0) ||
         (pTunableParams->MaxDsoundInChannels == 0) ||
         (pTunableParams->MaxOutChannels == 0) ||
         (pTunableParams->MaxInChannels == 0) ||
         (pTunableParams->MaxFloatChannels == 0)
#ifdef PRIVATE_THREAD
         || (pTunableParams->WorkerThreadPriority > 31)
#endif
        ) {
        return (STATUS_INVALID_PARAMETER) ;
    }

    gMinNumMixBuffers = pTunableParams->MinNumMixBuffers ;
    gMaxNumMixBuffers = pTunableParams->MaxNumMixBuffers ;
    gStartNumMixBuffers = pTunableParams->StartNumMixBuffers ;
    gMixBufferDuration = pTunableParams->MixBufferDuration ;

    gPreferredQuality = pTunableParams->PreferredQuality ;
    gDisableMmx = pTunableParams->DisableMmx ;
    gMaxOutputBits = pTunableParams->MaxOutputBits ;
    gMaxDsoundInChannels = pTunableParams->MaxDsoundInChannels ;
    gMaxOutChannels = pTunableParams->MaxOutChannels ;
    gMaxInChannels = pTunableParams->MaxInChannels ;
    gMaxFloatChannels = pTunableParams->MaxFloatChannels ;
    gLogToFile = pTunableParams->LogToFile ;
    gFixedSamplingRate = pTunableParams->FixedSamplingRate ;
    gEnableShortHrtf = pTunableParams->EnableShortHrtf ;
    gBuildPartialMdls = pTunableParams->BuildPartialMdls ;
#ifdef PRIVATE_THREAD
    gWorkerThreadPriority = pTunableParams->WorkerThreadPriority ;
#endif

    pIrp->IoStatus.Information = sizeof (TUNABLEPARAMS);
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxGetPerfStats
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PPERFSTATS pPerfStats
)
{
    pPerfStats->NumMixBuffersAdded = gNumMixBuffersAdded ;
    pPerfStats->NumCompletionsWhileStarved = gNumCompletionsWhileStarved ;
    pPerfStats->NumSilenceSamplesInserted = gNumSilenceSamplesInserted ;

    pIrp->IoStatus.Information = sizeof (PERFSTATS);
    return ( STATUS_SUCCESS ) ;
}

//---------------------------------------------------------------------------
//  End of File: filter.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\flocal.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.h

Abstract:

    This is the header for the floating point, HRTF 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOATLOCALIZER_HEADER)
#define FLOATLOCALIZER_HEADER
#pragma once

// Project-specific INCLUDEs
#include "vmaxhead.h"

#define DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS  60

typedef struct _FLOAT_LOCALIZER 
{
    PRFIIR Iir[efilterCount];
    PFLOAT FilterOut[efilterCount];
    PFLOAT OverlapBuffer[efilterCount];
    UINT   PreviousNumSamples;
    BOOL   SwapChannels;
    BOOL   ZeroAzimuth;
    PFLOAT TempFloatBuffer;
    UINT   FilterOverlapLength;
    UINT   FilterMuteLength;
    BOOL   FirstUpdate;
    UINT   OutputOverlapLength;
    BOOL   CrossFadeOutput;
} FLOAT_LOCALIZER, *PFLOAT_LOCALIZER;

// ---------------------------------------------------------------------------
// Floating-point localizer

NTSTATUS FloatLocalizerCreate(PFLOAT_LOCALIZER*);
VOID FloatLocalizerDestroy(PFLOAT_LOCALIZER);
    
VOID FloatLocalizerLocalize(PMIXER_SINK_INSTANCE, PFLOAT, PFLOAT, UINT, BOOL);
NTSTATUS FloatLocalizerInitData(PFLOAT_LOCALIZER, KSDS3D_HRTF_FILTER_METHOD, UINT, KSDS3D_HRTF_FILTER_QUALITY, UINT, UINT, UINT);
VOID FloatLocalizerFreeBufferMemory(PFLOAT_LOCALIZER);
NTSTATUS FloatLocalizerUpdateCoeffs(PFLOAT_LOCALIZER, UINT, PFLOAT, UINT, PFLOAT, BOOL, BOOL, BOOL);
VOID FloatLocalizerFilterOverlap(PFLOAT_LOCALIZER, UINT, PFLOAT, PFLOAT, UINT);
NTSTATUS FloatLocalizerSetTransitionBufferLength(PFLOAT_LOCALIZER, UINT, UINT);
NTSTATUS FloatLocalizerSetOverlapLength(PFLOAT_LOCALIZER, UINT);


// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

//#if !defined(DEBUG)
//#include "flocal.inl"
//#endif

#endif

// End of FLOATLOCALIZER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\device.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
#define NO_REMAPPING_ALLOC

#include "common.h"
#include <ksguid.h>
#include "perf.h"

#ifdef TIME_BOMB
#include "..\..\timebomb\timebomb.c"
#endif

const WCHAR FilterTypeName[] = KSSTRING_Filter;

extern LIST_ENTRY  gleFilterList;

VOID
InitializeDebug(
);

VOID
UninitializeDebug(
);

KSDISPATCH_TABLE PinDispatchTable =
{
    PinDispatchIoControl,
    NULL,
    PinDispatchWrite,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

static const WCHAR DeviceTypeName[] = L"GLOBAL";

DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems)
{
    DEFINE_KSCREATE_ITEM(
        FilterDispatchGlobalCreate,
        &FilterTypeName,
        NULL),

    DEFINE_KSCREATE_ITEM(
        FilterDispatchGlobalCreate,
        &DeviceTypeName,
	    NULL)
};

#ifdef USE_CAREFUL_ALLOCATIONS
LIST_ENTRY  gleMemoryHead;
ULONG   cbMemoryUsage = 0;
#endif

extern ULONG    gDisableMmx ;
#ifdef _X86_
extern  ULONG   gfMmxPresent ;
#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch(pIrpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // Mark the device as not disableable.
            //
            pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            break;
    }
    return(KsDefaultDispatchPnp(pDeviceObject, pIrp));
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
#ifdef DEBUG
    UninitializeDebug();
#endif
}

NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   usRegistryPathName
)
{
    KFLOATING_SAVE       FloatSave;
    NTSTATUS             Status;
    PIO_ERROR_LOG_PACKET ErrorLogEntry;

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

#ifdef USE_CAREFUL_ALLOCATIONS
    InitializeListHead ( &gleMemoryHead ) ;
#endif

    PerfSystemControlDispatch = KsDefaultForwardIrp;

    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PerfWmiDispatch;
    DriverObject->DriverUnload = DriverUnload;
    DriverObject->DriverExtension->AddDevice = AddDevice;

    Status = SaveFloatState(&FloatSave);
    if (!NT_SUCCESS(Status)) {
        // The floating point processor is unusable.
        ErrorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry( DriverObject, (UCHAR) (ERROR_LOG_MAXIMUM_SIZE) );

        if (ErrorLogEntry == NULL) {
            return Status;
        }

        RtlZeroMemory(ErrorLogEntry, sizeof(IO_ERROR_LOG_PACKET));
        ErrorLogEntry->ErrorCode = IO_ERR_INTERNAL_ERROR;
        ErrorLogEntry->FinalStatus = Status;

        IoWriteErrorLogEntry( ErrorLogEntry );

        return Status;
    }
    RestoreFloatState(&FloatSave);

    //
    // Get all tunable parameters from registry into global vars
    //
    GetMixerSettingsFromRegistry() ;

    //
    // Set MmxPresent Flag
    //
#ifdef _X86_
    if ( gDisableMmx ) {
        gfMmxPresent = 0 ;
    }
    else {
        gfMmxPresent = IsMmxPresent() ;
    }
#endif

    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_WRITE);

#ifdef DEBUG
    InitializeDebug();
#endif

    InitializeListHead ( &gleFilterList ) ;

    return STATUS_SUCCESS;

}

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   pdo
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    PSOFTWARE_INSTANCE  pSoftwareInstance;
    UNICODE_STRING      usDeviceName;
    PDEVICE_OBJECT      fdo = NULL;

    //
    // The Software Bus Enumerator expects to establish links 
    // using this device name.
    //

    _DbgPrintF( DEBUGLVL_VERBOSE, ("AddDevice") );

    RtlInitUnicodeString( &usDeviceName, STR_DEVICENAME );
        
    Status = IoCreateDevice( 
      DriverObject, 
      sizeof( SOFTWARE_INSTANCE ),
      NULL,
      FILE_DEVICE_KS,
      0,
      FALSE,
      &fdo );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("failed to create FDO: %08x", Status) );
        goto exit;
    }

    pSoftwareInstance = (PSOFTWARE_INSTANCE) fdo->DeviceExtension;

    Status = KsAllocateDeviceHeader(
      &pSoftwareInstance->DeviceHeader,
      SIZEOF_ARRAY( CreateItems ),
      (PKSOBJECT_CREATE_ITEM)CreateItems );
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("failed to create header: %08x", Status) );
        goto exit;
    }
    
    KsSetDevicePnpAndBaseObject(
      pSoftwareInstance->DeviceHeader,
      IoAttachDeviceToDeviceStack(fdo, pdo ),
      fdo );

    fdo->Flags |= DO_DIRECT_IO ;
    fdo->Flags |= DO_POWER_PAGABLE ;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
exit:
    if(!NT_SUCCESS(Status) && fdo != NULL) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("removing fdo") );
        IoDeleteDevice( fdo );
    }

    return Status;
}

#ifdef USE_CAREFUL_ALLOCATIONS
PVOID 
AllocMem(
    IN POOL_TYPE PoolType,
    IN ULONG size,
    IN ULONG Tag
)
{
    PVOID pp;
    ASSERT(size != 0);
    size += sizeof(ULONG) + sizeof(LIST_ENTRY);
#ifdef REALTIME_THREAD
    pp = ExAllocatePoolWithTag(NonPagedPool, size, Tag);
#else
    pp = ExAllocatePoolWithTag(PoolType, size, Tag);
#endif
   if(pp == NULL) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("AllocMem Failed") ) ;
    } else {
	    RtlZeroMemory(pp, size);
	    cbMemoryUsage += size;
	    *((PULONG)(pp)) = size;
	    pp = ((PULONG)(pp)) + 1;
	    InsertHeadList(&gleMemoryHead, ((PLIST_ENTRY)(pp)));
	    pp = ((PLIST_ENTRY)(pp)) + 1;
    }

    return pp;
}

//
// Ignores NULL input pointers.
//

VOID 
FreeMem(
    IN PVOID p
)
{
    if(p != NULL) {
	    PLIST_ENTRY ple = ((PLIST_ENTRY)p) - 1;
	    PULONG pul = ((PULONG)ple) - 1;
	    RemoveEntryList(ple);
	    cbMemoryUsage -= *pul;
	    ple->Flink = NULL;
	    ple->Blink = NULL;
	    ExFreePool(pul);
    }
}

VOID
ValidateAccess(
    PVOID p
)
{
    BOOL   fValid;
    PLIST_ENTRY ple;
    PULONG pul;
        
    ple = gleMemoryHead.Flink ;
    fValid = FALSE;
    while ( ple != &gleMemoryHead ) {
        pul = ((PULONG)ple) - 1;
        if ((ULONG)((PBYTE)p - (PBYTE)pul) < (*pul)) {
            fValid = TRUE;
        }
        ple = ple->Flink ;
    }
    ASSERT(fValid);
}
#else
#ifdef REALTIME_THREAD
PVOID 
AllocMem(
    IN POOL_TYPE PoolType,
    IN ULONG size,
    IN ULONG Tag
)
{
#ifdef DEBUG

    if (RtThread()) {
        DbgBreakPoint();
    }

#endif
    return ExAllocatePoolWithTag(NonPagedPool, size, Tag);
}
#endif
#endif


#ifdef REALTIME_THREAD


NTSTATUS
MxWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{

    return KeWaitForSingleObject(Object, WaitReason, WaitMode, Alertable, Timeout);
    
}


LONG
MxReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{

    return KeReleaseMutex(Mutex, Wait);

}



NTSTATUS
RtWaitForSingleObject (
    PFILTER_INSTANCE pFilterInstance,
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS status;

    status = KeWaitForSingleObject(Object, WaitReason, WaitMode, Alertable, Timeout);
    if (pFilterInstance->RealTimeThread && Object == (PVOID)(&pFilterInstance->ControlMutex)) {

        KIRQL OldIrql;
        PVOID Address;

        Address=_ReturnAddress();

        // Spew to the NT Kern buffer so we can figure out who is holding off the
        // mix and why.

        //DbgPrint("'RtWait: %p\r\n", Address);

        // We must pause the rt mix, too.
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
        pFilterInstance->fPauseMix++;
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    }
    
    return status;

}



LONG
RtReleaseMutex (
    PFILTER_INSTANCE pFilterInstance,
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{

    if (pFilterInstance->RealTimeThread && Mutex == (PRKMUTEX)(&pFilterInstance->ControlMutex)) {

        KIRQL OldIrql;
        PVOID Address;

        Address=_ReturnAddress();

        // Spew to the NT Kern buffer so we can figure out who is holding off the
        // mix and why.

        //DbgPrint("'RtRelease: %p\r\n", Address);

        // We must resume the rt mix, too
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
        pFilterInstance->fPauseMix--;
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    }

    return KeReleaseMutex(Mutex, Wait);

}


#endif

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\flocal.inl ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.inl

Abstract:

    This is the in-line functions 
    for the floating point, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOATLOCALIZER_INLINE)
#define FLOATLOCALIZER_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

/*
#if !defined(DEBUG)
#define INLINE __forceinline
#else
#define INLINE
#endif

// ---------------------------------------------------------------------------
// Constants

const enum EFilterMethod CeFloatFilterMethodInit(tagCanonical);

// ---------------------------------------------------------------------------
// Floating-point localizer

// Default constructor
INLINE FloatLocalizer::FloatLocalizer()
{
	STATUS status;
	InitData(CeFloatFilterMethodInit, &status);
	ASSERT(status == STATUS_OK);
}

// "Partial" constructor
INLINE FloatLocalizer::FloatLocalizer(const EFilterMethod CeFilterMethod, STATUS* const CpStatus)
{
	ASSERT(CeFilterMethod >= 0 && CeFilterMethod < efiltermethodCount);
	CHECK_POINTER(CpStatus);

	InitData(CeFilterMethod, CpStatus);
}
*/

#endif

// End of FLOATLOCALIZER.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\fpconv.c ===
//
//    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//

#define SIGN_MASK           0x8000000
#define EXP_MASK            0x7F80000
#define SIGNIFICAND_MASK    0x007FFFF

#include "common.h"

LONG FpUpper
(
    FLOAT Value
)
{
    LONG Upper;

    Upper = (LONG)Value;

    return Upper;
}

ULONG FpLower
(
    FLOAT Value
)
{
    LONG  LongTemp;
    ULONG Lower;
    FLOAT FloatTemp;

    LongTemp = FpUpper(Value);
    FloatTemp = Value - LongTemp;
    Lower = (ULONG)(FloatTemp * 1000.0f);

    return Lower;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\filt3d.c ===
//--------------------------------------------------------------------------;
//
//  File: filter.c
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//	3D filter functions called by the mixer.  This code is built in ring 3
// 	and ring 0.
//
//  History:
//	07/09/96    DannyMi	created 
//
//--------------------------------------------------------------------------;

#include "common.h"

// use the lightning-quick neato Itd3dFilterSampleAsm or the dog slow Itd3dFilterSampleC?
#ifdef _X86_
#define Itd3dFilterSample Itd3dFilterSampleC
#else
#define Itd3dFilterSample Itd3dFilterSampleC
#endif



// don't ask
BYTE _fltused;


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

// This is the 3D mixing code.  Grace gives us a sample that it was going to
// play, and we return a different number (that sample with 3D effects) which
// Grace will use instead.

// We cache a whole bunch of samples that she has sent us, because we are
// premixing some sound that may get thrown away, and we need be able to back
// up and find out what samples we were given BEFORE the point we rewind to.
// We also need to know some of the 3D parameters we were using at the point
// we rewind to, because if we don't revert to using the same parameters as
// we were the first time through, you will hear that as an audible glitch.

// But we are saving a sample cache of 10K samples or so, and to save the 3D
// state for each sample would take about 1Meg per 3D sound!  There's no way
// we can afford to do that.  So we save our state every 128 samples, and have
// a private agreement with Grace that she will always rewind us on 128 sample
// boundaries.

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//
// Here is a simple float to long conversion that has unpredictable rounding
//
__forceinline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef _X86_
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}


// We will need to remember at least cSamples in our cache, because that is
// how much we may be asked to rewind.  The actual cache size we use must be
// a power of 2 for the math to work in FirNextSample
//
NTSTATUS Itd3dFilterPrepare(PITDCONTEXT pItd, int cSamples)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterPrepare: this 3D channel needs a %d sample cache", cSamples));

    // we already have a cache big enough
    if (pItd->cSampleCache && pItd->cSampleCache >= cSamples) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Our current cache of %d is big enough", pItd->cSampleCache));
	    return STATUS_SUCCESS;
    }

    if (pItd->pSampleCache)
    {
    	ExFreePool(pItd->pSampleCache);
        pItd->pSampleCache = NULL;
    }

    // !!! is this necessary?
    // find the next higher power of 2
    pItd->cSampleCache = 1;
    cSamples -= 1;
    while (cSamples >= 1) {
	    cSamples >>= 1;
    	pItd->cSampleCache <<= 1;
    }

    // if we're not at least this big, we can't do our left-right delay and low
    // pass filter
    if (pItd->cSampleCache < CACHE_MINSIZE)
    	pItd->cSampleCache = CACHE_MINSIZE;

    pItd->pSampleCache = (PLONG) ExAllocatePoolWithTag( PagedPool, pItd->cSampleCache * sizeof(LONG), 'XIMK' );
    if (pItd->pSampleCache == NULL) {
	    _DbgPrintF(DEBUGLVL_VERBOSE, ("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
	    pItd->cSampleCache = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // We need 1/128th as many entries for saving our state
    pItd->cStateCache = pItd->cSampleCache / MIXER_REWINDGRANULARITY + 1;
    pItd->pStateCache = (PFIRSTATE) ExAllocatePoolWithTag( PagedPool, pItd->cStateCache * sizeof(FIRSTATE), 'XIMK' );
    if (pItd->pStateCache == NULL) {
    	_DbgPrintF(DEBUGLVL_VERBOSE, ("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
    	pItd->cStateCache = 0;
    	pItd->cSampleCache = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("Using a %d sample and %d state cache", pItd->cSampleCache, pItd->cStateCache));

    return STATUS_SUCCESS;
}


// free our cache stuff
//
void Itd3dFilterUnprepare(PITDCONTEXT pItd)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterUnprepare:"));
    if (pItd->pSampleCache)
    {
    	ExFreePool(pItd->pSampleCache);
        pItd->pSampleCache = NULL;
    }
    if (pItd->pStateCache)
    {
    	ExFreePool(pItd->pStateCache);
        pItd->pStateCache = NULL;
    }
    pItd->cSampleCache = 0;
    pItd->cStateCache = 0;
}

// clear our filter of cached samples - we're starting to play
//
void Itd3dFilterClear(PITDCONTEXT pItd)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterClear:"));

	RtlZeroMemory(pItd->pSampleCache, pItd->cSampleCache * sizeof(LONG));
	RtlZeroMemory(pItd->pStateCache, pItd->cStateCache * sizeof(FIRSTATE));
    pItd->iCurSample = 0;

    // clearing is a time to save our first state information.
    // !!! is this right?
    pItd->pStateCache[0].LastDryAttenuation = pItd->LastDryAttenuation;
    pItd->pStateCache[0].LastWetAttenuation = pItd->LastWetAttenuation;
#ifdef SMOOTH_ITD
    pItd->pStateCache[0].iLastDelay = pItd->iLastDelay;
#endif
    if (pItd->cStateCache > 1)
        pItd->iCurState = 1;	// next time we save it'll be at location 1
    pItd->iStateTick = 0;	// have seen no samples since saving

    return;
}

// Before we mix 1000 (or so) 3D samples, we call this function to prepare
// to mix the next batch.  The only thing it has to worry about is our
// volume smoothing.
// We are currently using Last***Attenuation and want to get to
// Total***Attenuation. Instead of figuring out sample by sample how much
// closer to move each sample (too expensive) we figure out right now how
// much we will move closer and do that for every sample in this batch.  But
// the danger of extracting that test to this level is that maybe we will
// go too far and actually overshoot Total***Attenation, causing possible
// clipping, or oscillating if we later try to correct it, and over-correct.
// If we are going to overshoot, we will recalculate how much to move each    
// sample such that we will end up at our target at the end of this batch of
// samples. (Or you can compile it to be lazy and give up when it's close).
void Itd3dFilterChunkUpdate(PITDCONTEXT pItd, int cSamples)
{
    D3DVALUE attRatio, c, w, d;

    // Due to rounding error, we'll take forever to get exactly to where
    // we want to be, so close counts.  If we don't snap ourselves to where
    // we want to be, we could clip.
    d = pItd->TotalDryAttenuation - pItd->LastDryAttenuation;
    w = pItd->TotalWetAttenuation - pItd->LastWetAttenuation;
    if (d && d > -.0001f && d < .0001f) {
    	pItd->LastDryAttenuation = pItd->TotalDryAttenuation;
    }
    if (w && w > -.0001f && w < .0001f) {
	    pItd->LastWetAttenuation = pItd->TotalWetAttenuation;
    }

    // Dry attenuation wants to be higher than it is
    if (pItd->TotalDryAttenuation > pItd->LastDryAttenuation) {
    	// or we may never get anywhere
    	if (pItd->LastDryAttenuation == 0.f)
    	    pItd->LastDryAttenuation = .0001f; // small enough not to click
    	// after gaining in volume throughout this entire range of samples
    	// we will end up going too high!
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalDryAttenuation / pItd->LastDryAttenuation;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
         // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
    		attRatio);
    	    pItd->VolSmoothScaleDry = (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
         // we will never get to our real destination
    	    pItd->VolSmoothScaleDry = 1.f;
    	    pItd->TotalDryAttenuation = pItd->LastDryAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleDry = pItd->VolSmoothScale;
    	}

        // Dry attenuation wants to be less than it is
    } else if (pItd->TotalDryAttenuation < pItd->LastDryAttenuation) {

    	// after lowering the volume throughout this entire range of samples
    	// we will end up going too low!  going down from Last to Total is
    	// the same as going up from Total to Last
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalDryAttenuation ?
			pItd->LastDryAttenuation / pItd->TotalDryAttenuation :
 		999999;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
							attRatio);
    	    pItd->VolSmoothScaleDry = 1.f / (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleDry = 1.f;
    	    pItd->TotalDryAttenuation = pItd->LastDryAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleDry = pItd->VolSmoothScaleRecip;
    	}
    } else {
    	// We're already where we want to be
    	pItd->VolSmoothScaleDry = 1.f;
    }
	

    // Wet attenuation wants to be higher than it is
    if (pItd->TotalWetAttenuation > pItd->LastWetAttenuation) {
    	// or we may never get anywhere
    	if (pItd->LastWetAttenuation == 0.f)
    	    pItd->LastWetAttenuation = .0001f; // small enough not to click
    	// after gaining in volume throughout this entire range of samples
    	// we will end up going too high!
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalWetAttenuation / pItd->LastWetAttenuation;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
            							attRatio);
    	    pItd->VolSmoothScaleWet = (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleWet = 1.f;
    	    pItd->TotalWetAttenuation = pItd->LastWetAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleWet = pItd->VolSmoothScale;
    	}

        // Wet attenuation wants to be lower than it is
    } else if (pItd->TotalWetAttenuation < pItd->LastWetAttenuation) {

    	// after lowering the volume throughout this entire range of samples
        	// we will end up going too low!  going down from Last to Total is
        	// the same as going up from Total to Last
         	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalWetAttenuation ?
    			pItd->LastWetAttenuation / pItd->TotalWetAttenuation :
    			999999;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
    							attRatio);
    	    pItd->VolSmoothScaleWet = 1.f / (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleWet = 1.f;
    	    pItd->TotalWetAttenuation = pItd->LastWetAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleWet = pItd->VolSmoothScaleRecip;
    	}
    } else {
        	// We're already where we want to be
    	pItd->VolSmoothScaleWet = 1.f;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\fpconv.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    fpconv.h

Abstract:

    This is the header for the FLOAT conversion routines 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOAT_HEADER)
#define FLOAT_HEADER
#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern LONG FpUpper(FLOAT);
extern ULONG FpLower(FLOAT);

#ifdef __cplusplus
}
#endif // __cplusplus


#endif

// End of FPCONV.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\flocal.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.c

Abstract:

    This module implements floating point, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

// Project-specific INCLUDEs
#include "common.h"

// ---------------------------------------------------------------------------
// Constants

#define CoeffsInit 0.0f


// ---------------------------------------------------------------------------
// Floating-point localizer

// "Regular" constructor
NTSTATUS FloatLocalizerCreate
(
    PFLOAT_LOCALIZER*  Localizer
) 
{
    NTSTATUS Status = STATUS_SUCCESS;

    *Localizer = ExAllocatePoolWithTag
                 ( 
                     PagedPool, 
                     sizeof(FLOAT_LOCALIZER), 
                     'XIMK' 
                 );

    if(*Localizer)
    {
        RtlZeroMemory( *Localizer, sizeof(FLOAT_LOCALIZER) );
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

// Destructor
VOID FloatLocalizerDestroy
(
    PFLOAT_LOCALIZER Localizer
)
{
    UINT Filter;

    if (Localizer) { 
        // Free resources
        if (Localizer->TempFloatBuffer) {
            ExFreePool(Localizer->TempFloatBuffer);
            Localizer->TempFloatBuffer = NULL;
        }
        FloatLocalizerFreeBufferMemory(Localizer);
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if (Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RfIirDestroy(Localizer->Iir[Filter]);
            Localizer->Iir[Filter] = NULL;
        }

        ExFreePool(Localizer);
    }

}

// Localize
VOID FloatLocalizerLocalize
(
    PMIXER_SINK_INSTANCE    pMixerSink,
    PFLOAT              InData, 
    PFLOAT              OutData, 
    UINT                NumSamples,
    BOOL                MixOutput
)
{
    PFLOAT_LOCALIZER    Localizer;
    UINT        Filter;
    PFLOAT      OutLeft;
    PFLOAT      OutRight;
    FLOAT       FilterLeft;
    FLOAT       FilterRight;
    FLOAT       Sum;
    FLOAT       Difference;
    UINT        ChannelOffset;
    FLOAT       FilterOut;
    UINT        st;
    UINT        OutputOverlapLength;
    FLOAT       NumOverlapSamplesFactor;
    EChannel    eLeft;
    EChannel    eRight;
    FLOAT       CrossFadeFactor;
    FLOAT       InverseCrossFadeFactor;
    FLOAT       TempSum;
    FLOAT       TempDifference;
#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
    PFILTER_INSTANCE    pFilterInstance ;
#endif

    ASSERT(InData);
    ASSERT(OutData);
    ASSERT(NumSamples > 0);

    Localizer = pMixerSink->pFloatLocalizer;

    // Mute if Localizer is bad
    if(!Localizer) {
        for (st=0; st<2*NumSamples; ++st) {
            OutData[st] = 0.0f;
        }
        return;
    }
#ifndef REALTIME_THREAD
    // Reallocate (dynamically grow) memory, if necessary
    if (NumSamples > Localizer->PreviousNumSamples 
        || !Localizer->FilterOut[tagDelta]
        || !Localizer->FilterOut[tagSigma] ) {
        
        Localizer->PreviousNumSamples = NumSamples;
        FloatLocalizerFreeBufferMemory(Localizer);

        Localizer->FilterOut[tagSigma] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(FLOAT), 
                'XIMK'
            );


        Localizer->FilterOut[tagDelta] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(FLOAT), 
                'XIMK'
            );

        if(!Localizer->FilterOut[tagDelta] ||
           !Localizer->FilterOut[tagSigma] ) {

            if (Localizer->FilterOut[tagDelta] ) {
                ExFreePool(Localizer->FilterOut[tagDelta]);
                Localizer->FilterOut[tagDelta] = NULL; 
            }    

            if (Localizer->FilterOut[tagSigma] ) {
                ExFreePool(Localizer->FilterOut[tagSigma]);
                Localizer->FilterOut[tagSigma] = NULL; 
            }


            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0.0f;
            }

            return;
        }

    }
#else
        if(NumSamples > Localizer->PreviousNumSamples ||
           !Localizer->FilterOut[tagDelta] ||
           !Localizer->FilterOut[tagSigma] ) {

            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0.0f;
            }

            return;
        }
#endif

    // Perform floating-point filtering
    for (Filter=0; Filter<efilterCount; ++Filter) {
        ASSERT(Localizer->Iir[Filter]);
        FloatLocalizerFilterOverlap
        (
            Localizer, 
            Filter,
            InData, 
            Localizer->FilterOut[Filter], 
            NumSamples
        );
    }

    // Calculate overlap length
    if (Localizer->CrossFadeOutput) {
        // Calculate overlap length
        if (Localizer->OutputOverlapLength > NumSamples)
            OutputOverlapLength = NumSamples;
        else
            OutputOverlapLength = Localizer->OutputOverlapLength;
        NumOverlapSamplesFactor = 1.0f / (FLOAT)(OutputOverlapLength - 1);
    }
                                                                             
    // Process both (sigma and delta) filters
    // Swap channels if azimuth is negative
    if (TRUE == Localizer->SwapChannels) {
        eLeft  = tagRight;
        eRight = tagLeft;
    } else {
        eLeft  = tagLeft;
        eRight = tagRight;
    }

    
    // Non-zero angle: Process delta filter
    OutLeft = &OutData[eLeft];
    OutRight = &OutData[eRight];

    for (st=0; st<NumSamples; ++st) {
        // Calculate sum and difference
        ChannelOffset = (st * echannelCount);
        FilterLeft = *(Localizer->FilterOut[tagLeft] + st);
        FilterRight = *(Localizer->FilterOut[tagRight] + st);

        Sum = FilterRight + FilterLeft;
        Difference = FilterRight - FilterLeft;

#if DETECT_HRTF_SATURATION
        // Saturate sum to maximum
        if (Sum > MaxSaturation) {
            Sum = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded maximum saturation value\n")
            );
        }
        
        // Saturate sum to minimum
        if (Sum < MinSaturation) {
            Sum = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded minimum saturation value\n")
            );
        }

        // Saturate difference to maximum
        if (Difference > MaxSaturation) {
            Difference = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded maximum saturation value\n")
            );
        }
        
        // Saturate difference to minimum
        if (Difference < MinSaturation) {
            Difference = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded minimum saturation value\n")
            );
        }
#endif // DETECT_HRTF_SATURATION

        // Check for zero azimuth transition
        if (Localizer->CrossFadeOutput && st<OutputOverlapLength) {
            // Cross-fade left/right channel switch transition
            // Calculate cross-fade factor
            CrossFadeFactor = (FLOAT)(st * NumOverlapSamplesFactor);
            ASSERT(CrossFadeFactor >= 0.0f && CrossFadeFactor <= 1.0f);
            InverseCrossFadeFactor = 1.0f - CrossFadeFactor;
            ASSERT(InverseCrossFadeFactor >= 0.0f && InverseCrossFadeFactor <= 1.0f);

            // Calculate cross-faded sample
            TempDifference = Difference;
            TempSum = Sum;
            Difference = TempSum * InverseCrossFadeFactor + TempDifference * CrossFadeFactor;
            Sum = TempDifference * InverseCrossFadeFactor + TempSum * CrossFadeFactor;

        }

        // Assign sum and difference
        if (!MixOutput) {
            OutLeft[ChannelOffset] = Difference;
            OutRight[ChannelOffset] = Sum;
        } else {
            OutLeft[ChannelOffset] += Difference;
            OutRight[ChannelOffset] += Sum;
        }
    }

    Localizer->CrossFadeOutput = FALSE;  // Make sure we don't cross fade output a second time

#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;
    FileIoRoutine (pFilterInstance,
                   OutData,
                   2*NumSamples*sizeof(FLOAT));
#endif

}

// Initialize data
NTSTATUS FloatLocalizerInitData
(
    PFLOAT_LOCALIZER            Localizer,
    KSDS3D_HRTF_FILTER_METHOD   FilterMethod,
    UINT                        MaxSize,
    KSDS3D_HRTF_FILTER_QUALITY  Quality,
    UINT                        FilterMuteLength,
    UINT                        FilterOverlapLength,
    UINT                        OutputOverlapLength
)
{
    UINT        Filter;
    NTSTATUS    Status;

    ASSERT(FilterMethod >= 0 && FilterMethod < KSDS3D_FILTER_METHOD_COUNT);

    FloatLocalizerFreeBufferMemory(Localizer);
        
    Localizer->PreviousNumSamples = 0;
    Localizer->FirstUpdate = TRUE;
    Localizer->OutputOverlapLength = OutputOverlapLength;

    Status = FloatLocalizerSetTransitionBufferLength
             ( 
                 Localizer, 
                 FilterMuteLength,
                 FilterOverlapLength 
             ); 
        

    if(NT_SUCCESS(Status))
    {
        for (Filter=0; Filter<efilterCount && NT_SUCCESS(Status); ++Filter) {
            // Check for filter method
            switch (FilterMethod) {
                case DIRECT_FORM:
                    if(Localizer->Iir[Filter])
                        RfIirDestroy((Localizer->Iir[Filter]));
                        
                    // Direct form is supported
                    Status = RfIirCreate(&(Localizer->Iir[Filter]));
                    if (NT_SUCCESS(Status)) {
                        Status = RfIirInitData(Localizer->Iir[Filter], MaxSize, MaxSize, Quality);
                    } 
                break;
    
                default:
                    // All others are not supported
                    Localizer->Iir[Filter] = NULL;
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT(0);
                break;
            }
    
            Localizer->FilterOut[Filter] = NULL;
        }
    }

    // If failure, free other memory.
    if (!NT_SUCCESS(Status)) {
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if(Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RfIirDestroy(Localizer->Iir[Filter]);
            Localizer->Iir[Filter] = NULL;
        }
    }

    return Status;
}

// Update Filter Coefficients 
NTSTATUS FloatLocalizerUpdateCoeffs
(
    PFLOAT_LOCALIZER    Localizer,
    UINT                NumSigmaCoeffs,
    PFLOAT              pSigmaCoeffs,
    UINT                NumDeltaCoeffs,
    PFLOAT              pDeltaCoeffs,
    BOOL                SwapChannels,
    BOOL                ZeroAzimuth,
    BOOL                CrossFadeOutput
)
{
    BOOL        UpdateFlag;
    NTSTATUS    Status = STATUS_SUCCESS;
    FLOAT       Zero = 0.0f;

    Localizer->SwapChannels = SwapChannels;
    Localizer->ZeroAzimuth = ZeroAzimuth;
    Localizer->CrossFadeOutput = CrossFadeOutput;

    if(!Localizer->FirstUpdate)
    {
        UpdateFlag = TRUE;
    }
    else
    {
        UpdateFlag = FALSE;
        Localizer->FirstUpdate = FALSE;
    }

    Status = RfIirSetCoeffs(Localizer->Iir[tagSigma], pSigmaCoeffs, NumSigmaCoeffs,UpdateFlag);
    if (NT_SUCCESS(Status)) {
        if (!ZeroAzimuth) {
            Status = RfIirSetCoeffs(Localizer->Iir[tagDelta], pDeltaCoeffs, NumDeltaCoeffs,UpdateFlag);
        } else {
            Status = RfIirSetCoeffs(Localizer->Iir[tagDelta], &Zero, 1,UpdateFlag);
        }
    }

    return Status;
}


// Free buffer memory
VOID FloatLocalizerFreeBufferMemory
(
    PFLOAT_LOCALIZER Localizer
)
{
    UINT Filter;

    for (Filter=0; Filter<efilterCount; ++Filter) {
        if (Localizer->FilterOut[Filter]) {
            ExFreePool(Localizer->FilterOut[Filter]);
            Localizer->FilterOut[Filter] = NULL;
        }
    }
}

// Set transition buffer length
NTSTATUS FloatLocalizerSetTransitionBufferLength
(
    PFLOAT_LOCALIZER Localizer,
    UINT MuteLength,
    UINT OverlapLength
)
{
    NTSTATUS Status;

    ASSERT(OverlapLength > 0);
    ASSERT(MuteLength > 0);
    ASSERT(OverlapLength > MuteLength);
    
    Status = FloatLocalizerSetOverlapLength(Localizer,OverlapLength);
    if(NT_SUCCESS(Status)) {
        Localizer->FilterMuteLength = MuteLength;
    }

    return(Status);
}

// Set overlap buffer length
NTSTATUS FloatLocalizerSetOverlapLength
(
    PFLOAT_LOCALIZER Localizer,
    UINT OverlapLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFLOAT SigmaOverlapBuffer;
    PFLOAT DeltaOverlapBuffer;

    ASSERT(OverlapLength > 0);

    // Grow overlap buffer if necessary
    if (!Localizer->OverlapBuffer[tagSigma] ||
        !Localizer->OverlapBuffer[tagDelta] ||
        OverlapLength > Localizer->OutputOverlapLength) {

        SigmaOverlapBuffer = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                OverlapLength*sizeof(FLOAT), 
                'XIMK'
            );

        if(!SigmaOverlapBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if(NT_SUCCESS(Status)) {
            DeltaOverlapBuffer = 
                ExAllocatePoolWithTag
                (
                    PagedPool, 
                    OverlapLength*sizeof(FLOAT), 
                    'XIMK'
                );

            if(!DeltaOverlapBuffer) {
                ExFreePool(SigmaOverlapBuffer);
                SigmaOverlapBuffer = NULL;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if(NT_SUCCESS(Status)) {
            if(Localizer->OverlapBuffer[tagSigma]) {
                ExFreePool(Localizer->OverlapBuffer[tagSigma]);
            }
            Localizer->OverlapBuffer[tagSigma] = SigmaOverlapBuffer;

            if(Localizer->OverlapBuffer[tagDelta]) {
                ExFreePool(Localizer->OverlapBuffer[tagDelta]);
            }
            Localizer->OverlapBuffer[tagDelta] = DeltaOverlapBuffer;

            Localizer->FilterOverlapLength = OverlapLength;
        }

    }

    ASSERT(Localizer->OverlapBuffer[tagSigma]);
    ASSERT(Localizer->OverlapBuffer[tagDelta]);

    return(Status);

} 

// Filter a block of samples
VOID FloatLocalizerFilterOverlap
(
    PFLOAT_LOCALIZER Localizer,
    UINT   Filter,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT NumSamples
)
{
    FLOAT_IIR_STATE IirStateNew;
    PRFIIR Iir;
    UINT NumOverlapSamples;
    PFLOAT OverlapBuffer;
    UINT Old;
    UINT ui;
    FLOAT NumOverlapSamplesFactor;
    UINT FilterMuteLength;
    UINT Lap;
    UINT Dat;
    UINT st;
    FLOAT CrossFadeFactor;

    ASSERT(InData);
    ASSERT(OutData);

    Iir = Localizer->Iir[Filter];
    OverlapBuffer = Localizer->OverlapBuffer[Filter];

    ASSERT(Iir);
    ASSERT(OverlapBuffer);

    // Process overlap, if necessary
    if (TRUE == Iir->DoOverlap) {
        // Save current (i.e. new) filter state (with the new coefficients), 
        // don't copy circular vector because it's all zeros anyway
        RfIirGetAllState(Iir, &IirStateNew, FALSE);

        // Reset old filter state, including circular vector
        RfIirSetState(Iir, Iir->IirStateOld, TRUE);

        // Determine size of overlap buffer
        if (NumSamples >= Localizer->FilterOverlapLength)
            NumOverlapSamples = Localizer->FilterOverlapLength;            
        else
            NumOverlapSamples = NumSamples;
        
        // Filter overlap buffer
        Iir->FunctionFilter(Iir, InData, OverlapBuffer, NumOverlapSamples);

        // Initialize the filter's tap delay line
        RfIirInitTapDelayLine(&IirStateNew, InData[0]);
        
        // Set back to current (i.e. new) filter state 
        // with circular vector because we initialize it explicitly
        RfIirSetState(Iir, &IirStateNew, TRUE);

    }

    // Filter "real" data
    Iir->FunctionFilter(Iir, InData, OutData, NumSamples);

    // Process overlap buffer
    if (Iir->DoOverlap == TRUE) {
        // Clamp length down
        ASSERT(Localizer->FilterMuteLength > 0);
        ASSERT(Localizer->FilterMuteLength < Localizer->FilterOverlapLength);

        if (Localizer->FilterMuteLength > NumOverlapSamples)
            FilterMuteLength = NumOverlapSamples;
        else
            FilterMuteLength = Localizer->FilterMuteLength;

        // Copy data from old filter for transient mute length
        RtlCopyBytes(OutData, OverlapBuffer, FilterMuteLength*sizeof(FLOAT));
        
        if (NumOverlapSamples > FilterMuteLength) {
            // Cross-fade into new filter data for rest of buffer
            NumOverlapSamplesFactor = 1.0f / 
                    (FLOAT)(NumOverlapSamples - FilterMuteLength - 1);
            for (st=FilterMuteLength; st<NumOverlapSamples; ++st) {
                CrossFadeFactor = (FLOAT)((st - FilterMuteLength) 
                                  * NumOverlapSamplesFactor);
                ASSERT(CrossFadeFactor >= 0.0f && CrossFadeFactor <= 1.0f);
                OutData[st] = CrossFadeFactor * OutData[st] 
                            + (1.0f - CrossFadeFactor) * OverlapBuffer[st];
            }
        }

        // Reset overlap flag
        Iir->DoOverlap = FALSE;
    }
 
}

// End of FLOATLOCALIZER.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\fyl2x.asm ===
title	fylog2x	 - Danny's cheapo y*log2(x)
;*** 
;fylog2x.asm - compute y * log2(x)
;
;	Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
;
;Purpose:
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

fylog2x	proto stdcall, y:qword, x:qword

	public	fylog2x
fylog2x	proc stdcall, y:qword, x:qword

	fld	y
	fld	x
	fyl2x
	ret
fylog2x	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\modeflag.h ===
//---------------------------------------------------------------------------
//
//  Module:   modeflag.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define H_8_BITS	0
#define H_16_BITS  	1
#define H_MONO     	0
#define H_STEREO   	2
#define H_UNSIGNED	0 
#define H_SIGNED	4
#define H_ORDER_LR	0
#define H_ORDER_RL	8
#define H_NO_FILTER	0
#define H_FILTER	16
#define H_BASEMASK	31
#define H_NO_LOOP	0
#define H_LOOP		256
#define H_BUILD_MONO	256
#define H_BUILD_STEREO  32
#define H_NO_RESAMPLE	0
#define H_RESAMPLE	64
#define H_NO_SCALE	0
#define H_SCALE		128
#define H_NO_CLIP	0
#define H_CLIP		32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\iir3d.c ===
//---------------------------------------------------------------------------
//
//  Module:   iir3d.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#define SQRT2    0.707f

ULONG __forceinline
StageMonoIir3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    UINT		i;
    UINT		j;
    PFLOAT		pTempFloatBuffer;
    PLONG		pTempLongBuffer;
    LONG		temp;
    FLOAT		floatTemp;

    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    
    if (fFloat) {

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 1") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        if (FLOAT_COEFF == CurSink->CoeffFormat) {
            FloatLocalizerLocalize
            (
                CurSink, 
                pFloatInput, 
                pFloatBuffer, 
                SampleCount,
                fMixOutput
            );
        } else {

            for(i=0; i<SampleCount; i++)
            {
                pInputBuffer[i] = ConvertFloatToLong(pFloatInput[i]);
#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 2") );
               IsValidShortData(pInputInput[i],TRUE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 1") );
                }
        
                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 1") );
                }
#endif
            }

            if (fMixOutput) {

                if (!CurSink->pShortLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid ShortLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        floatTemp = (FLOAT)(SQRT2*pFloatBuffer[i]);
                        pFloatBuffer[j++] = floatTemp;
                        pFloatBuffer[j++] = floatTemp;
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if (!CurSink->pShortLocalizer->TempLongBuffer ||
                    SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {

                    if (CurSink->pShortLocalizer->TempLongBuffer) {
                        ExFreePool(CurSink->pShortLocalizer->TempLongBuffer);
                        CurSink->pShortLocalizer->TempLongBuffer = NULL;
                    }
                    CurSink->pShortLocalizer->TempLongBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(LONG), 'XIMK');
                    if (!CurSink->pShortLocalizer->TempLongBuffer) {
                        // Couldn't allocate the buffer. Mute the output. 
                        j = 0;
                        for(i=0; i<SampleCount; i++)
                        {
                            floatTemp = (FLOAT)(SQRT2*pInputBuffer[i]);
                            pFloatBuffer[j++] = floatTemp;
                            pFloatBuffer[j++] = floatTemp;
                        }
                        return SampleCount;
                    }
            	}
#else
                if (!CurSink->pShortLocalizer->TempLongBuffer ||
                    SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        floatTemp = (FLOAT)(SQRT2*pInputBuffer[i]);
                        pFloatBuffer[j++] = floatTemp;
                        pFloatBuffer[j++] = floatTemp;
                    }
                    return SampleCount;
            	}
#endif

                pTempLongBuffer = CurSink->pShortLocalizer->TempLongBuffer;
                
                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pTempLongBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] += (FLOAT)(pTempLongBuffer[i]);
                }

            } else {

                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pOutputBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] = (FLOAT)(pOutputBuffer[i]);
                }
            }
        }
    } else {

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 3") );
        for(i=0; i<SampleCount; i++) {
            IsValidShortData(pInputInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        if (FLOAT_COEFF == CurSink->CoeffFormat) {
		i = 0;
#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Done
    
                    mov     esi, pInputBuffer 
                    mov     edi, pFloatInput
                Start:
                    fild    DWORD PTR [esi+ecx*4-64]
                    fstp    DWORD PTR [edi+ecx*4-64]
                    fild    DWORD PTR [esi+ecx*4-60]
                    fstp    DWORD PTR [edi+ecx*4-60]
                    fild    DWORD PTR [esi+ecx*4-56]
                    fstp    DWORD PTR [edi+ecx*4-56]
                    fild    DWORD PTR [esi+ecx*4-52]
                    fstp    DWORD PTR [edi+ecx*4-52]
                    fild    DWORD PTR [esi+ecx*4-48]
                    fstp    DWORD PTR [edi+ecx*4-48]
                    fild    DWORD PTR [esi+ecx*4-44]
                    fstp    DWORD PTR [edi+ecx*4-44]
                    fild    DWORD PTR [esi+ecx*4-40]
                    fstp    DWORD PTR [edi+ecx*4-40]
                    fild    DWORD PTR [esi+ecx*4-36]
                    fstp    DWORD PTR [edi+ecx*4-36]
                    fild    DWORD PTR [esi+ecx*4-32]
                    fstp    DWORD PTR [edi+ecx*4-32]
                    fild    DWORD PTR [esi+ecx*4-28]
                    fstp    DWORD PTR [edi+ecx*4-28]
                    fild    DWORD PTR [esi+ecx*4-24]
                    fstp    DWORD PTR [edi+ecx*4-24]
                    fild    DWORD PTR [esi+ecx*4-20]
                    fstp    DWORD PTR [edi+ecx*4-20]
                    fild    DWORD PTR [esi+ecx*4-16]
                    fstp    DWORD PTR [edi+ecx*4-16]
                    fild    DWORD PTR [esi+ecx*4-12]
                    fstp    DWORD PTR [edi+ecx*4-12]
                    fild    DWORD PTR [esi+ecx*4- 8]
                    fstp    DWORD PTR [edi+ecx*4- 8]
                    fild    DWORD PTR [esi+ecx*4- 4]
                    fstp    DWORD PTR [edi+ecx*4- 4]
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Start
                Done:
                    mov     i, ecx 
                }
#else
            for (i = 16; i < SampleCount; i += 16)
            {
                pFloatInput[i-16] = (FLOAT)(pInputBuffer[i-16]);
                pFloatInput[i-15] = (FLOAT)(pInputBuffer[i-15]);
                pFloatInput[i-14] = (FLOAT)(pInputBuffer[i-14]);
                pFloatInput[i-13] = (FLOAT)(pInputBuffer[i-13]);
                pFloatInput[i-12] = (FLOAT)(pInputBuffer[i-12]);
                pFloatInput[i-11] = (FLOAT)(pInputBuffer[i-11]);
                pFloatInput[i-10] = (FLOAT)(pInputBuffer[i-10]);
                pFloatInput[i- 9] = (FLOAT)(pInputBuffer[i- 9]);
                pFloatInput[i- 8] = (FLOAT)(pInputBuffer[i- 8]);
                pFloatInput[i- 7] = (FLOAT)(pInputBuffer[i- 7]);
                pFloatInput[i- 6] = (FLOAT)(pInputBuffer[i- 6]);
                pFloatInput[i- 5] = (FLOAT)(pInputBuffer[i- 5]);
                pFloatInput[i- 4] = (FLOAT)(pInputBuffer[i- 4]);
                pFloatInput[i- 3] = (FLOAT)(pInputBuffer[i- 3]);
                pFloatInput[i- 2] = (FLOAT)(pInputBuffer[i- 2]);
                pFloatInput[i- 1] = (FLOAT)(pInputBuffer[i- 1]);
            }
#endif

            i -= 16;
#endif
            for(; i<SampleCount; i++)
            {
                pFloatInput[i] = (FLOAT)(pInputBuffer[i]);
            }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 4") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

            if (fMixOutput) {

                if (!CurSink->pFloatLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        temp = (LONG)(SQRT2*pInputBuffer[i]);
                        pOutputBuffer[j++] = temp;
                        pOutputBuffer[j++] = temp;
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if (!CurSink->pFloatLocalizer->TempFloatBuffer ||
                    SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {

                    if (CurSink->pFloatLocalizer->TempFloatBuffer) {
                        ExFreePool(CurSink->pFloatLocalizer->TempFloatBuffer);
                        CurSink->pFloatLocalizer->TempFloatBuffer = NULL;
                    }
                    CurSink->pFloatLocalizer->TempFloatBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(FLOAT), 'XIMK');
                    if (!CurSink->pFloatLocalizer->TempFloatBuffer) {
                        // Couldn't allocate the buffer. Mute the output. 
                        j = 0;
                        for(i=0; i<SampleCount; i++)
                        {
                            temp = (LONG)(SQRT2*pInputBuffer[i]);
                            pOutputBuffer[j++] = temp;
                            pOutputBuffer[j++] = temp;
                        }
                        return SampleCount;
                    }
            	}
#else
                if (!CurSink->pFloatLocalizer->TempFloatBuffer ||
                    SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        temp = (LONG)(SQRT2*pInputBuffer[i]);
                        pOutputBuffer[j++] = temp;
                        pOutputBuffer[j++] = temp;
                    }
                    return SampleCount;
            	}

#endif

                pTempFloatBuffer = CurSink->pFloatLocalizer->TempFloatBuffer;
                
                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pTempFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                i = 0   ;
                j = 2 * SampleCount;
#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Donex
    
                    mov     esi, pTempFloatBuffer 
                    mov     edi, pOutputBuffer
                Startx:
                    mov     eax, DWORD PTR [edi+ecx*4-64]
                    fld     DWORD PTR [esi+ecx*4-64]
                    fistp   DWORD PTR [edi+ecx*4-64]

                    mov     ebx, DWORD PTR [edi+ecx*4-60]
                    add     DWORD PTR [edi+ecx*4-64], eax
                    fld     DWORD PTR [esi+ecx*4-60]
                    fistp   DWORD PTR [edi+ecx*4-60]

                    mov     eax, DWORD PTR [edi+ecx*4-56]
                    add     DWORD PTR [edi+ecx*4-60], ebx
                    fld     DWORD PTR [esi+ecx*4-56]
                    fistp   DWORD PTR [edi+ecx*4-56]

                    mov     ebx, DWORD PTR [edi+ecx*4-52]
                    add     DWORD PTR [edi+ecx*4-56], eax
                    fld     DWORD PTR [esi+ecx*4-52]
                    fistp   DWORD PTR [edi+ecx*4-52]

                    mov     eax, DWORD PTR [edi+ecx*4-48]
                    add     DWORD PTR [edi+ecx*4-52], ebx
                    fld     DWORD PTR [esi+ecx*4-48]
                    fistp   DWORD PTR [edi+ecx*4-48]

                    mov     ebx, DWORD PTR [edi+ecx*4-44]
                    add     DWORD PTR [edi+ecx*4-48], eax
                    fld     DWORD PTR [esi+ecx*4-44]
                    fistp   DWORD PTR [edi+ecx*4-44]

                    mov     eax, DWORD PTR [edi+ecx*4-40]
                    add     DWORD PTR [edi+ecx*4-44], ebx
                    fld     DWORD PTR [esi+ecx*4-40]
                    fistp   DWORD PTR [edi+ecx*4-40]

                    mov     ebx, DWORD PTR [edi+ecx*4-36]
                    add     DWORD PTR [edi+ecx*4-40], eax
                    fld     DWORD PTR [esi+ecx*4-36]
                    fistp   DWORD PTR [edi+ecx*4-36]

                    mov     eax, DWORD PTR [edi+ecx*4-32]
                    add     DWORD PTR [edi+ecx*4-36], ebx
                    fld     DWORD PTR [esi+ecx*4-32]
                    fistp   DWORD PTR [edi+ecx*4-32]

                    mov     ebx, DWORD PTR [edi+ecx*4-28]
                    add     DWORD PTR [edi+ecx*4-32], eax
                    fld     DWORD PTR [esi+ecx*4-28]
                    fistp   DWORD PTR [edi+ecx*4-28]

                    mov     eax, DWORD PTR [edi+ecx*4-24]
                    add     DWORD PTR [edi+ecx*4-28], ebx
                    fld     DWORD PTR [esi+ecx*4-24]
                    fistp   DWORD PTR [edi+ecx*4-24]

                    mov     ebx, DWORD PTR [edi+ecx*4-20]
                    add     DWORD PTR [edi+ecx*4-24], eax
                    fld     DWORD PTR [esi+ecx*4-20]
                    fistp   DWORD PTR [edi+ecx*4-20]

                    mov     eax, DWORD PTR [edi+ecx*4-16]
                    add     DWORD PTR [edi+ecx*4-20], ebx
                    fld     DWORD PTR [esi+ecx*4-16]
                    fistp   DWORD PTR [edi+ecx*4-16]

                    mov     ebx, DWORD PTR [edi+ecx*4-12]
                    add     DWORD PTR [edi+ecx*4-16], eax
                    fld     DWORD PTR [esi+ecx*4-12]
                    fistp   DWORD PTR [edi+ecx*4-12]

                    mov     eax, DWORD PTR [edi+ecx*4- 8]
                    add     DWORD PTR [edi+ecx*4-12], ebx
                    fld     DWORD PTR [esi+ecx*4- 8]
                    fistp   DWORD PTR [edi+ecx*4- 8]

                    mov     ebx, DWORD PTR [edi+ecx*4-4]
                    add     DWORD PTR [edi+ecx*4- 8], eax
                    fld     DWORD PTR [esi+ecx*4- 4]
                    fistp   DWORD PTR [edi+ecx*4- 4]

                    add     DWORD PTR [edi+ecx*4- 4], ebx
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Startx
                Donex:
                    mov     i, ecx 
                }
#else
#define CFL ConvertFloatToLong

                for (i = 16; i < j; i += 16)
                {
                    pOutputBuffer[i-16] += CFL(pTempFloatBuffer[i-16]);
                    pOutputBuffer[i-15] += CFL(pTempFloatBuffer[i-15]);
                    pOutputBuffer[i-14] += CFL(pTempFloatBuffer[i-14]);
                    pOutputBuffer[i-13] += CFL(pTempFloatBuffer[i-13]);
                    pOutputBuffer[i-12] += CFL(pTempFloatBuffer[i-12]);
                    pOutputBuffer[i-11] += CFL(pTempFloatBuffer[i-11]);
                    pOutputBuffer[i-10] += CFL(pTempFloatBuffer[i-10]);
                    pOutputBuffer[i- 9] += CFL(pTempFloatBuffer[i- 9]);
                    pOutputBuffer[i- 8] += CFL(pTempFloatBuffer[i- 8]);
                    pOutputBuffer[i- 7] += CFL(pTempFloatBuffer[i- 7]);
                    pOutputBuffer[i- 6] += CFL(pTempFloatBuffer[i- 6]);
                    pOutputBuffer[i- 5] += CFL(pTempFloatBuffer[i- 5]);
                    pOutputBuffer[i- 4] += CFL(pTempFloatBuffer[i- 4]);
                    pOutputBuffer[i- 3] += CFL(pTempFloatBuffer[i- 3]);
                    pOutputBuffer[i- 2] += CFL(pTempFloatBuffer[i- 2]);
                    pOutputBuffer[i- 1] += CFL(pTempFloatBuffer[i- 1]);
                }
#undef CFL
#endif
                i -= 16;
#endif
                for(; i<j; i++)
                {
                    pOutputBuffer[i] += ConvertFloatToLong(pTempFloatBuffer[i]);
                }

            } else {

                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                i = 0;
                j = 2 * SampleCount;

#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Doney
    
                    mov     esi, pFloatBuffer 
                    mov     edi, pOutputBuffer
                Starty:
                    fld     DWORD PTR [esi+ecx*4-64]
                    fistp   DWORD PTR [edi+ecx*4-64]
                    fld     DWORD PTR [esi+ecx*4-60]
                    fistp   DWORD PTR [edi+ecx*4-60]
                    fld     DWORD PTR [esi+ecx*4-56]
                    fistp   DWORD PTR [edi+ecx*4-56]
                    fld     DWORD PTR [esi+ecx*4-52]
                    fistp   DWORD PTR [edi+ecx*4-52]
                    fld     DWORD PTR [esi+ecx*4-48]
                    fistp   DWORD PTR [edi+ecx*4-48]
                    fld     DWORD PTR [esi+ecx*4-44]
                    fistp   DWORD PTR [edi+ecx*4-44]
                    fld     DWORD PTR [esi+ecx*4-40]
                    fistp   DWORD PTR [edi+ecx*4-40]
                    fld     DWORD PTR [esi+ecx*4-36]
                    fistp   DWORD PTR [edi+ecx*4-36]
                    fld     DWORD PTR [esi+ecx*4-32]
                    fistp   DWORD PTR [edi+ecx*4-32]
                    fld     DWORD PTR [esi+ecx*4-28]
                    fistp   DWORD PTR [edi+ecx*4-28]
                    fld     DWORD PTR [esi+ecx*4-24]
                    fistp   DWORD PTR [edi+ecx*4-24]
                    fld     DWORD PTR [esi+ecx*4-20]
                    fistp   DWORD PTR [edi+ecx*4-20]
                    fld     DWORD PTR [esi+ecx*4-16]
                    fistp   DWORD PTR [edi+ecx*4-16]
                    fld     DWORD PTR [esi+ecx*4-12]
                    fistp   DWORD PTR [edi+ecx*4-12]
                    fld     DWORD PTR [esi+ecx*4- 8]
                    fistp   DWORD PTR [edi+ecx*4- 8]
                    fld     DWORD PTR [esi+ecx*4- 4]
                    fistp   DWORD PTR [edi+ecx*4- 4]
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Starty
                Doney:
                    mov     i, ecx 
                }
#else
#define CFL ConvertFloatToLong
                for (i = 16; i < j; i += 16)
                {
                    pOutputBuffer[i-16] = CFL(pFloatBuffer[i-16]);
                    pOutputBuffer[i-15] = CFL(pFloatBuffer[i-15]);
                    pOutputBuffer[i-14] = CFL(pFloatBuffer[i-14]);
                    pOutputBuffer[i-13] = CFL(pFloatBuffer[i-13]);
                    pOutputBuffer[i-12] = CFL(pFloatBuffer[i-12]);
                    pOutputBuffer[i-11] = CFL(pFloatBuffer[i-11]);
                    pOutputBuffer[i-10] = CFL(pFloatBuffer[i-10]);
                    pOutputBuffer[i- 9] = CFL(pFloatBuffer[i- 9]);
                    pOutputBuffer[i- 8] = CFL(pFloatBuffer[i- 8]);
                    pOutputBuffer[i- 7] = CFL(pFloatBuffer[i- 7]);
                    pOutputBuffer[i- 6] = CFL(pFloatBuffer[i- 6]);
                    pOutputBuffer[i- 5] = CFL(pFloatBuffer[i- 5]);
                    pOutputBuffer[i- 4] = CFL(pFloatBuffer[i- 4]);
                    pOutputBuffer[i- 3] = CFL(pFloatBuffer[i- 3]);
                    pOutputBuffer[i- 2] = CFL(pFloatBuffer[i- 2]);
                    pOutputBuffer[i- 1] = CFL(pFloatBuffer[i- 1]);
                }

#undef CFL
#endif
                i -= 16;
#endif
                for(; i<j; i++)
                {
                    pOutputBuffer[i] = ConvertFloatToLong(pFloatBuffer[i]);
                }
            }

        } else {

            ShortLocalizerLocalize
            (
                CurSink->pShortLocalizer, 
                pInputBuffer, 
                pOutputBuffer, 
                SampleCount,
                fMixOutput
            );

        }

    }

    return SampleCount;
}

ULONG StageMonoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoIir3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageMonoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoIir3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageMonoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoIir3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageMonoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoIir3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
} 

ULONG __forceinline
StageStereoIir3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG	samp;
    PFLOAT	pFloatSample;
    PLONG	pLongSample;
    UINT	i;
    UINT	j;
    PFLOAT	pTempFloatBuffer;
    PLONG	pTempLongBuffer;

    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    
    if (fFloat) {

        // Average the stereo input samples
        pFloatSample = pFloatInput;
        for ( samp=0; samp<SampleCount; samp++ ) {
            // Filter the left and right channels
            *pFloatSample = (*(pFloatInput) + *(pFloatInput+1))*(0.5f);
            pFloatInput += 2;
            pFloatSample++;
        }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 1") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        pFloatInput = CurStage->pInputBuffer;

        if (FLOAT_COEFF == CurSink->CoeffFormat) {

            FloatLocalizerLocalize
            (
                CurSink, 
                pFloatInput, 
                pFloatBuffer, 
                SampleCount,
                fMixOutput
            );
        } else {
            for(i=0; i<SampleCount; i++)
            {
                pInputBuffer[i] = ConvertFloatToLong(pFloatInput[i]);

#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 2") );
               IsValidShortData(pInputBuffer[i],TRUE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 2") );
                }
        
                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 2") );
                }
#endif
            }

            if (fMixOutput) {

                if (!CurSink->pShortLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pFloatBuffer[j++] = pFloatInput[i];
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if(!CurSink->pShortLocalizer->TempLongBuffer ||
                   SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {

                    if (CurSink->pShortLocalizer->TempLongBuffer) {
                        ExFreePool(CurSink->pShortLocalizer->TempLongBuffer);
                        CurSink->pShortLocalizer->TempLongBuffer = NULL;
                    }
                    CurSink->pShortLocalizer->TempLongBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(LONG), 'XIMK');
                    if (!CurSink->pShortLocalizer->TempLongBuffer) {
                        // Couldn't allocate the buffer. Copy the output. 
                        j = 0;
                        for(i=0; i<2*SampleCount; i++)
                        {
                            pFloatBuffer[j++] = pFloatInput[i];
                        }
                        return SampleCount;
                    }
            	}
#else
                if(!CurSink->pShortLocalizer->TempLongBuffer ||
                   SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Copy the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pFloatBuffer[j++] = pFloatInput[i];
                    }
                    return SampleCount;
            	}
#endif
                pTempLongBuffer = CurSink->pShortLocalizer->TempLongBuffer;
                
                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pTempLongBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] += (FLOAT)(pTempLongBuffer[i]);
                }

            } else {

                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pOutputBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] = (FLOAT)(pOutputBuffer[i]);
                }
            }

        }

    } else {

        // Average the stereo input samples
        pLongSample = pInputBuffer;
        for ( samp=0; samp<SampleCount; samp++ ) {
            // Filter the left and right channels
            // The compiler will optimize out the /2 to the correct shift.
            *pLongSample = (SHORT)((*(pInputBuffer) + *(pInputBuffer+1))/2);
            pInputBuffer += 2;
            pLongSample++;
        }

        pInputBuffer = CurStage->pInputBuffer;

#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 3") );
               for(i=0; i<SampleCount; i++) {
                   IsValidShortData(pInputBuffer[i],TRUE);
               }
#endif // DBG  and VERIFY_HRTF_PROCESSING


        if (FLOAT_COEFF == CurSink->CoeffFormat) {
            for(i=0; i<SampleCount; i++)
            {
#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 3") );
                }

                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 3") );
                }
#endif
                pFloatInput[i] = (FLOAT)(pInputBuffer[i]);
            }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 4") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

            if (fMixOutput) {

                if (!CurSink->pFloatLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pOutputBuffer[j++] = pInputBuffer[i];
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if(!CurSink->pFloatLocalizer->TempFloatBuffer ||
                   SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {

                    if (CurSink->pFloatLocalizer->TempFloatBuffer) {
                        ExFreePool(CurSink->pFloatLocalizer->TempFloatBuffer);
                        CurSink->pFloatLocalizer->TempFloatBuffer = NULL;
                    }
                    CurSink->pFloatLocalizer->TempFloatBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(FLOAT), 'XIMK');
                    if (!CurSink->pFloatLocalizer->TempFloatBuffer) {
                        // Couldn't allocate the buffer. Copy the output. 
                        j = 0;
                        for(i=0; i<2*SampleCount; i++)
                        {
                            pOutputBuffer[j++] = pInputBuffer[i];
                        }
                        return SampleCount;
                    }
            	}
#else
                if(!CurSink->pFloatLocalizer->TempFloatBuffer ||
                   SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Copy the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pOutputBuffer[j++] = pInputBuffer[i];
                    }
                    return SampleCount;
            	}
#endif

                pTempFloatBuffer = CurSink->pFloatLocalizer->TempFloatBuffer;
                
                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pTempFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pOutputBuffer[i] += ConvertFloatToLong(pTempFloatBuffer[i]);
                }

            } else {

                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pOutputBuffer[i] = ConvertFloatToLong(pFloatBuffer[i]);
                }
            }

        } else {

            ShortLocalizerLocalize
            (
                CurSink->pShortLocalizer, 
                pInputBuffer, 
                pOutputBuffer, 
                SampleCount,
                fMixOutput
            );

        }
    }

    return SampleCount;
}

ULONG StageStereoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoIir3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageStereoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoIir3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageStereoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoIir3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageStereoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoIir3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\mix.c ===
/* MIX.C
 *
 * This file is a port of mix.asm.  All functionality should idealy be
 * identical.
 *
 * Revision History:
 *
 * 9/30/95   angusm   Initial Version
 *    Copyright (c) 1995-2000 Microsoft Corporation. All Rights Reserved.
 */

/* The following is m4 code */

/*  










 
 */

/*  */




#define NODSOUNDSERVICETABLE

#include "common.h"
#include <limits.h>

#define DIVIDEBY2(x)		( (x) >>  1 )
#define DIVIDEBY256(x)		( (x) >>  8 )
#define DIVIDEBY2POW16(x)	( (x) >> 16 )
#define DIVIDEBY2POW17(x)	( (x) >> 17 )

// do we want to profile the 3D mixer?
#ifdef DEBUG
//#define PENTIUM
#ifdef PENTIUM
extern "C" LONG glNum;
extern "C" DWORDLONG gdwlTot;
LONG glNum;
DWORDLONG gdwlTot;
#endif
#endif

#ifdef PENTIUM
#pragma warning(disable:4035)
DWORDLONG __forceinline GetPentiumCounter(void)
{
   _asm  _emit 0x0F
   _asm  _emit 0x31
}
#endif

// use the lightning-quick neato Itd3dFilterSampleAsm or the dog slow Itd3dFilterSampleC?
#ifdef _X86_
#define Itd3dFilterSample Itd3dFilterSampleAsm
#else
#define Itd3dFilterSample Itd3dFilterSampleC
#endif

//
// Here is a simple float to long conversion that rounds according to the 
// current rounding setting
//
__forceinline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef _X86_
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}


// Morph a sample from this buffer to add all the cool 3D effects
// !!! Make this function as efficient as humanly possible.  It could
// be called a million times a second! (no, I'm not kidding)
//
// This function takes a filter state, and a sample value, and based on the
// filter state returns a different sample that should be used instead
//
// This function keeps a running total of all samples we've seen, 
// So, if we've been passed 5, 10, 2, 8, 3 we remember
// 5, 15, 17, 25, 28, in a circular buffer, remembering the last 64 numbers
// or so.
// 
// We might want to delay everything by a few samples, to simulate the sound
// taking longer to get to one ear than the other.
// So let's say we're delaying 1 sample, we will subtract 25-17 to get 8
// and use 8 as the current sample instead of 3. (that's the sample we were
// passed 1 sample ago)
//
// Now we need the average of the past 32 samples to use as a muffled sample
// (averaging samples produces a low-pass filter effect).  So pretending we
// still have a delay of 1 sample and that we're only averaging 2 samples
// (for the sake of this simple example) we take ((25 - 15) / 2) to get 5 as
// our "wet" sample (what our "dry" sample, 8, sounds like muffled, which is
// just the average of 2 + 8) In real life we average 32 samples, not 2.
// 
// OK, the number this function is supposed to return is just
// TotalDryAttenuation * sample(8) + TotalWetAttenuation * wetsample(5)
//
// But you get audible clicks and ugly artifacts if you change the
// Total***Attenuation in between calling the Filter() function.  So to avoid
// this, we will use variables Last***Attenuation, to mean the number we used
// last time Filter() was called.  If this time, the Total***Attenuation 
// number is bigger, we will take Last***Attenuation * 1.000125 as the value
// to use this time, and keep using slightly bigger numbers every time we
// are called, to move smoothly to the new Total***Attenuation number.
// Similarily, if we are smaller this time, we multiply the old one by
// .999875 each time to slowly get down to the new number.
//
// Oh, and every 128 samples, we remember what the current value of
// Last***Attenuation is, so that if 128 samples from now the mixer goes back
// in time and says "pretend I never gave you those last 128 numbers" we can
// go back to the way things were back then as if we never saw the last 128
// numbers.
//
// That's all there is to know!
//
__forceinline SHORT Itd3dFilterSampleC(PITDCONTEXT pfir, SHORT sample)
{
    SHORT wetsample;     
    LONG  lTotal, lDelay;
    UINT uiDelay;
    register int cSamples = pfir->cSampleCache - 1;

    // !!! We will fault if pfir->pSampleCache == NULL or cSampleCache == 0

    // remember this sample by keeping a running total (to make averaging quick)
    // cSamples will be 1 less than a power of 2
    pfir->pSampleCache[pfir->iCurSample] = pfir->pSampleCache[
		(pfir->iCurSample - 1) & cSamples] + sample;

    // Delay the signal by iDelay samples as one localization cue.
    uiDelay = (UINT)pfir->iCurSample - pfir->iDelay;

// !!! There are audible artifacts when changing the number of samples we 
// delay by, but changing very slowly does NOT help.
#ifdef SMOOTH_ITD
    // smoothly change the amount we delay by to avoid clicking.  Every 64
    // samples we will delay 1 more sample closer to the amount we want to
    // delay.
    if (pfir->iDelay > pfir->iLastDelay >> 6)
	pfir->iLastDelay++;
    else if (pfir->iDelay < pfir->iLastDelay >> 6)
	pfir->iLastDelay--;
    uiDelay = (UINT)pfir->iCurSample - (pfir->iLastDelay >> 6);
#endif

    // Don't worry about overflow, we'll be off by 4 Gig, which is 0
    lDelay = pfir->pSampleCache[uiDelay & cSamples];
    sample = (SHORT)(lDelay - pfir->pSampleCache[(uiDelay - 1) & cSamples]);

    // apply a cheezy low pass filter to the last few samples to get what this
    // sample sounds like wet
    lTotal = (lDelay - pfir->pSampleCache[(uiDelay - LOWPASS_SIZE) & cSamples]);
    wetsample = (SHORT)(lTotal >> FILTER_SHIFT);
	    
    // Next time, this is the current sample
    pfir->iCurSample = (pfir->iCurSample + 1) & cSamples;

    // attenuate however we decided we should be attenuating
    // If it's not the same as last time, move smoothly toward the new number
    // by a fixed number of dB, (say, 6dB every 1/8 second)
    // !!! Will this algorithm sound best?
    // !!! save time - cheat by adding not multiplying?
#if 1
    // Take all the "if"s out of this function, and precompute ahead of time
    pfir->LastDryAttenuation *= pfir->VolSmoothScaleDry;
    pfir->LastWetAttenuation *= pfir->VolSmoothScaleWet;
#else
    if (pfir->TotalDryAttenuation > pfir->LastDryAttenuation) {
	if (pfir->LastDryAttenuation == 0.f)
	    // or we'll never get anywhere
	    pfir->LastDryAttenuation = .0001f;	// small enough not to click
	pfir->LastDryAttenuation = pfir->LastDryAttenuation *
							pfir->VolSmoothScale;
	if (pfir->LastDryAttenuation > pfir->TotalDryAttenuation)
	    pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    } else if (pfir->TotalDryAttenuation < pfir->LastDryAttenuation) {
	pfir->LastDryAttenuation = pfir->LastDryAttenuation *
						pfir->VolSmoothScaleRecip;
	if (pfir->LastDryAttenuation < pfir->TotalDryAttenuation)
	    pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    }
    if (pfir->TotalWetAttenuation > pfir->LastWetAttenuation) {
	if (pfir->LastWetAttenuation == 0.f)
	    // or we'll never get anywhere
	    pfir->LastWetAttenuation = .0001f;	// small enough not to click
	pfir->LastWetAttenuation = pfir->LastWetAttenuation *
							pfir->VolSmoothScale;
	if (pfir->LastWetAttenuation > pfir->TotalWetAttenuation)
	    pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    } else if (pfir->TotalWetAttenuation < pfir->LastWetAttenuation) {
	pfir->LastWetAttenuation = pfir->LastWetAttenuation *
						pfir->VolSmoothScaleRecip;
	if (pfir->LastWetAttenuation < pfir->TotalWetAttenuation)
	    pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    }
#endif
    
    // Now here's what we will hear... some dry, some wet
    sample = (SHORT)FloatToLongRX(sample * pfir->LastDryAttenuation
				  + wetsample * pfir->LastWetAttenuation);

    // time to save our state yet? We save it every 128 samples in case we
    // have to rewind.
    pfir->iStateTick++;
    if (pfir->iStateTick == MIXER_REWINDGRANULARITY) {
	pfir->iStateTick = 0;
	pfir->pStateCache[pfir->iCurState].LastDryAttenuation =
						pfir->LastDryAttenuation;
	pfir->pStateCache[pfir->iCurState].LastWetAttenuation =
						pfir->LastWetAttenuation;
#ifdef SMOOTH_ITD
	pfir->pStateCache[pfir->iCurState].iLastDelay = pfir->iLastDelay;
#endif
	pfir->iCurState = pfir->iCurState + 1;
	if (pfir->iCurState == pfir->cStateCache)
	    pfir->iCurState = 0;
    }

    return sample;
}

// Remove inline for NT5 compile
#ifdef WIN95
__forceinline SHORT Itd3dFilterSampleAsm(PITDCONTEXT pfir, SHORT sample)
#else
SHORT Itd3dFilterSampleAsm(PITDCONTEXT pfir, SHORT sample)
#endif
{

    LONG  drysample, wetsample;

// This constant is used for address generation in the hand ASM optimized
// section of code that is saving the cache states.  If FIRSTATE is ever
// changed, either change this constant, or use the C version of this block
// of code.  (NOTE:  The only valid values for SIZEOFFIRSTATE are 2, 4, 8.
// All others will not compile)
#define SIZEOFFIRSTATE 8
//ASSERT(SIZEOFFIRSTATE == sizeof(FIRSTATE));

// Several of the float ASM instructions assume that the floating point
// variables are "float".  i.e. If they are changed to "double", or 
// "extended", the ASM code will need to change.

    wetsample = (LONG)sample;
    
#ifdef _X86_
    _asm
    {
        mov         esi, pfir								// Get pointer to data structure
        mov         ecx, DWORD PTR sample		// Get input sample value

        // Check if we need to perform scaling on the Dry attenuator.

// !!! 1 clock AGI penalty on esi

        mov         edi, [esi]pfir.cSampleCache             // Get cSampleCache
        mov         ebx, [esi]pfir.iCurSample               // Get current index to cached running totals

        dec         edi													// Calculate cCamples
        mov         edx, [esi]pfir.pSampleCache	// Get pointer to cached running totals

        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        // !!! AGI penalty

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfir.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // eax is now available for use in floating point scaling section


        // Scale the Dry attenuator up by a smoothing scale factor

        fld         [esi]pfir.LastDryAttenuation                    // Push Last Dry to the top of the FP stack
        fmul        [esi]pfir.VolSmoothScaleDry

	// do some non-fp stuff to wait for the fmul to finish

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

	// OK, it's probably done now

        fstp        [esi]pfir.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfir.LastWetAttenuation                    // Push Last Wet to the top of the FP stack
        fmul        [esi]pfir.VolSmoothScaleWet

	// do some non-fp stuff to wait for the fmul to finish

        mov         [esi]pfir.iCurSample, ecx               // Save iCurSample for next pass thru
        mov         ecx, LOWPASS_SIZE			    // Get filter size to use for getting filter index

	// OK, it's probably done now

        fstp        [esi]pfir.LastWetAttenuation                    // Save new Last Wet


	// Now, go ahead and trash esi

        lea         esi, [eax-1]                            // uiDelay - 1
        sub         eax, ecx                                // low_pass_index = uiDelay - LOWPASS_SIZE

        and         esi, edi                                // Account for array wrapping on uiDelay - 1
        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         edi, pfir                               // Get pointer to data structure
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        mov         esi, [edx+esi*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         ecx, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, esi                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, ecx                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [edi]pfir.iStateTick               // Get counter to determine when to save state

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
        // floating point multiply unit can only accept instructions every other clock cycle
    	fmul	    [edi]pfir.LastDryAttenuation            // Multiply dry portion by dry attenuator

    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [edi]pfir.LastWetAttenuation            // Multiply wet portion by wet attenuator

        mov         esi, [edi]pfir.pStateCache              // Get address of the cache array
        mov         edx, [edi]pfir.iCurState                // Get current index into cache array

        mov         eax, [edi]pfir.LastDryAttenuation       // Get dry attenuation so we can save it in cache
        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?

        // There is a 3 cycle latency before results of a floating point multiply can be used, so we need
        // 2 cycles of integer instructions between the last multiply and this floating point add.
    	faddp	    ST(1), ST(0)

        mov         ecx, [edi]pfir.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [edi]pfir.cStateCache              // Get state cache array size

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [edi]pfir.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
        mov         [edi]pfir.iStateTick, ebx               // Save new tick counter



        // There is a 3 cycle latency before results of a floating point add can be used, so we need
        // 2 cycles of integer instructions between the add this floating point integer store.

        fistp       wetsample

    }
#endif
    
    // Now here's what we will hear... some dry, some wet
    return ((SHORT) wetsample);

}

#ifdef _X86_ // {
// This constant is used for address generation in the hand ASM optimized
// section of code that is saving the cache states.  If FIRSTATE is ever
// changed, either change this constant, or use the C version of this block
// of code.  (NOTE:  The only valid values for SIZEOFFIRSTATE are 2, 4, 8.
// All others will not compile)
#define SIZEOFFIRSTATE 8

void Mix3DMono(PMIXER_SINK_INSTANCE CurSink, PLONG pInputBuffer, PLONG pOutputBuffer, ULONG SampleCount)
{
    LONG  drysample, wetsample;
	PITDCONTEXT pfirLeft = CurSink->pItdContextLeft, pfirRight = CurSink->pItdContextRight;
	LONG  cSampleCacheLeft, cSampleCacheRight;

	
	cSampleCacheLeft  = pfirLeft ->cSampleCache - 1;
	cSampleCacheRight = pfirRight->cSampleCache - 1;

	if (SampleCount)
    _asm
    {
        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

LoopLab:
        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheLeft             // Get cSampleCache
        mov         ebx, [esi]pfirLeft.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirLeft.pSampleCache	// Get pointer to cached running totals
		mov			ecx, DWORD PTR [ecx]			// Get input sample value

        sal         ecx, 16						// Start sign extension of sample
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        fld         [esi]pfirLeft.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirLeft.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirLeft.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirLeft.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirLeft.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        fmul        [esi]pfirLeft.VolSmoothScaleWet

        mov         [esi]pfirLeft.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fstp        [esi]pfirLeft.LastWetAttenuation                    // Save new Last Wet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirLeft.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirLeft.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirLeft.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirLeft.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirLeft.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirLeft.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirLeft.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirLeft.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [esi]pfirLeft.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirLeft.iStateTick, ebx               // Save new tick counter
		mov		eax, pInputBuffer

		mov		ecx, pOutputBuffer
		add		eax, 4

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

// Right

		add			[ecx], edi
        mov         esi, pfirRight								// Get pointer to data structure

		mov			ecx, [eax-4]						// Get input sample value
		mov			pInputBuffer, eax

        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheRight             // Get cSampleCache
        mov         ebx, [esi]pfirRight.iCurSample               // Get current index to cached running totals

        fld         [esi]pfirRight.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        mov         edx, [esi]pfirRight.pSampleCache	// Get pointer to cached running totals
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirRight.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirRight.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        fstp        [esi]pfirRight.LastDryAttenuation                    // Save new Last Dry

        fld         [esi]pfirRight.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fmul        [esi]pfirRight.VolSmoothScaleWet

        // Scale the Wet attenuator up by a smoothing scale factor

        mov         [esi]pfirRight.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fstp        [esi]pfirRight.LastWetAttenuation                    // Save new Last Wet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirRight.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirRight.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirRight.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          XDontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirRight.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirRight.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirRight.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirRight.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirRight.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          XDontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
XDontResetStateCacheIndex:

        mov         [esi]pfirRight.iCurState, edx                // Save new state cache index
        mov         ebx, 0

XDontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirRight.iStateTick, ebx               // Save new tick counter
		mov		ecx, pOutputBuffer

		mov		eax, SampleCount

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

		add	[ecx+4], edi
		add		ecx, 8

		dec		eax
        mov         esi, pfirLeft								// Get pointer to data structure

		mov		DWORD PTR pOutputBuffer, ecx
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

		mov		SampleCount, eax
		jne		LoopLab
		}
}


void Copy3DMono(PMIXER_SINK_INSTANCE CurSink, PLONG pInputBuffer, PLONG pOutputBuffer, ULONG SampleCount)
{
    LONG  drysample, wetsample;
	PITDCONTEXT pfirLeft = CurSink->pItdContextLeft, pfirRight = CurSink->pItdContextRight;
	LONG  cSampleCacheLeft, cSampleCacheRight;

	
	cSampleCacheLeft  = pfirLeft ->cSampleCache - 1;
	cSampleCacheRight = pfirRight->cSampleCache - 1;

	if (SampleCount)
    _asm
    {
        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

LoopLab:
        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheLeft             // Get cSampleCache
        mov         ebx, [esi]pfirLeft.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirLeft.pSampleCache	// Get pointer to cached running totals
		mov			ecx, DWORD PTR [ecx]			// Get input sample value

        sal         ecx, 16						// Start sign extension of sample
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        fld         [esi]pfirLeft.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirLeft.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirLeft.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirLeft.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirLeft.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        mov         [esi]pfirLeft.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        fmul        [esi]pfirLeft.VolSmoothScaleWet

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        fstp        [esi]pfirLeft.LastWetAttenuation                    // Save new Last Wet

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirLeft.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirLeft.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirLeft.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirLeft.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirLeft.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirLeft.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirLeft.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirLeft.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [esi]pfirLeft.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirLeft.iStateTick, ebx               // Save new tick counter
		mov		eax, pInputBuffer

		mov		ecx, pOutputBuffer
		add		eax, 4

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

// Right

		mov			[ecx], edi
		mov			ecx, [eax-4]						// Get input sample value

		mov			pInputBuffer, eax
        mov         esi, pfirRight								// Get pointer to data structure

        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheRight             // Get cSampleCache
        mov         ebx, [esi]pfirRight.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirRight.pSampleCache	// Get pointer to cached running totals
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        fld         [esi]pfirRight.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirRight.iDelay	// Get delay to use for wet sample

        fmul        [esi]pfirRight.VolSmoothScaleDry

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirRight.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirRight.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        mov         [esi]pfirRight.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fmul        [esi]pfirRight.VolSmoothScaleWet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        fstp        [esi]pfirRight.LastWetAttenuation                    // Save new Last Wet

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirRight.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirRight.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirRight.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          XDontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirRight.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirRight.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirRight.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirRight.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirRight.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          XDontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
XDontResetStateCacheIndex:

        mov         [esi]pfirRight.iCurState, edx                // Save new state cache index
        mov         ebx, 0

XDontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirRight.iStateTick, ebx               // Save new tick counter
		mov		ecx, pOutputBuffer

		mov		eax, SampleCount

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

		mov	[ecx+4], edi
		add		ecx, 8

		dec		eax
		mov		DWORD PTR pOutputBuffer, ecx

        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

		mov		SampleCount, eax
		jne		LoopLab
		}
}
#endif // }

ULONG __forceinline
StageMonoItd3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG samp;
    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
//    SHORT      sampleValue;
    
    // Run the 3D algorithm
    Itd3dFilterChunkUpdate( CurSink->pItdContextLeft, SampleCount );
    Itd3dFilterChunkUpdate( CurSink->pItdContextRight, SampleCount );


    if (fFloat) {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pFloatInput[samp];
                pFloatBuffer[0] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pFloatInput[samp]);
                pFloatBuffer[1] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pFloatInput[samp]);
                pFloatBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pFloatInput[samp];
                pFloatBuffer[0] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pFloatInput[samp]);
                pFloatBuffer[1] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pFloatInput[samp]);
                pFloatBuffer += 2;
            }
        }
    } else {
        if (fMixOutput) {
#ifdef _X86_
			Mix3DMono(CurSink, pInputBuffer, pOutputBuffer, SampleCount);
#else
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pInputBuffer[samp];
                pOutputBuffer[0] += (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pInputBuffer[samp]);
                pOutputBuffer[1] += (LONG)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pInputBuffer[samp]);
                pOutputBuffer += 2;
            }
#endif            
        } else {
#ifdef _X86_
			Copy3DMono(CurSink, pInputBuffer, pOutputBuffer, SampleCount);
#else
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pInputBuffer[samp];
                pOutputBuffer[0] = (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pInputBuffer[samp]);
                pOutputBuffer[1] = (LONG)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pInputBuffer[samp]);
                pOutputBuffer += 2;
            }
#endif
        }
    }

    return SampleCount;
}

ULONG StageMonoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoItd3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageMonoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoItd3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageMonoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoItd3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageMonoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoItd3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
} 

ULONG __forceinline
StageStereoItd3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG samp;
    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    SHORT      sampleValue;
    
    // Run the 3D algorithm
    Itd3dFilterChunkUpdate( CurSink->pItdContextLeft, SampleCount );
    Itd3dFilterChunkUpdate( CurSink->pItdContextRight, SampleCount );

    if (fFloat) {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2((LONG)(*(pFloatInput) + *(pFloatInput+1)));
                pFloatInput += 2;
                pFloatBuffer[0] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pFloatBuffer[1] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pFloatBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2((LONG)(*(pFloatInput) + *(pFloatInput+1)));
                pFloatInput += 2;
                pFloatBuffer[0] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pFloatBuffer[1] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pFloatBuffer += 2;
            }
        }
    } else {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2(*(pInputBuffer) + *(pInputBuffer+1));
                pInputBuffer += 2;
                pOutputBuffer[0] += (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pOutputBuffer[1] += (LONG)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pOutputBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2(*(pInputBuffer) + *(pInputBuffer+1));
                pInputBuffer += 2;
                pOutputBuffer[0] = (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pOutputBuffer[1] = (LONG)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue);
                pOutputBuffer += 2;
            }
        }
    }

    return SampleCount;
}

ULONG StageStereoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoItd3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageStereoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoItd3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageStereoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoItd3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageStereoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoItd3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

/* m4 Macros for generation of DMACopy and Merge functions. */







/*  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\mmx.c ===
//---------------------------------------------------------------------------
//
//  Module:   mmx.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"

#ifdef _X86_

#define GTW_MIX		// Turn on the MMX stuff...
#define GTW_REORDER	// Turn on loop unrolling to lessen register contention.
//#define GTW_CONVERT	// Turn on the MMX stuff for the convert functions.

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2

ULONG   gfMmxPresent = 0 ;

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

BOOL
IsMmxPresent(VOID)
{
    BOOL    MmxAvailable = 0;
    _asm {
        push    ebx
        pushfd                      // Store original EFLAGS on stack
        pop     eax                 // Get original EFLAGS in EAX
        mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
        xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
        push    eax                 // Save new EFLAGS value on stack
        popfd                       // Replace current EFLAGS value
        pushfd                      // Store new EFLAGS on stack
        pop     eax                 // Get new EFLAGS in EAX
        xor     eax, ecx            // Can we toggle ID bit?
        jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
        mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
        CPU_ID                      // Get family/model/stepping/features
        and    edx, 0x00800000L     // Check if mmx technology available
        mov MmxAvailable, edx
Done:
        pop     ebx
    }
    return (MmxAvailable);
}

ULONG MmxConvertMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PBYTE  pIn8 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.

    if (SampleCount == 0) {
        return 0;
    }

#ifdef GTW_CONVERT // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
        // No Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 0x800080		// 0, 0, 128, 128
	movd		mm5, edx	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	sub	eax, 128
	shl	eax, 8
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+8], eax
	mov	DWORD PTR [edi+ebx*8+12], eax
	xor	eax, eax
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1

	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	punpckhdq	mm2, mm2

	punpckldq	mm3, mm3
	jge		DoMMX0

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	movq		QWORD PTR [edi+ebx*8],    mm1
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+8],  mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]

	sub	eax, 128

	shl	eax, 8

	mov	DWORD PTR [edi+ebx*8], eax
	mov	DWORD PTR [edi+ebx*8+4], eax
	xor	eax, eax
	dec	ebx
	jge	LastSamples
Done:
        }
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
        // Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	edx, edx
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples1

	sub	ebx, 3

	pxor		mm0, mm0
	mov	eax, 0x800080		// 0, 0, 128, 128
	movd		mm5, eax	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, lRVol // Use lower 16 bits
	mov	eax, lLVol
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX1

	add	ebx, 3

FirstSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8

	sar	edx, 15

	shl	ecx, 8
	mov	DWORD PTR [edi+ebx*8], edx

	sar	ecx, 15
	xor	edx, edx

	dec	ebx
	mov	DWORD PTR [edi+ebx*8+12], ecx

	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples1

	sub	ebx, 3

DoMMX1:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...
	pmulhw		mm3, mm6

	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpckhwd	mm4, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	punpcklwd	mm3, mm3

	psrad		mm2, 15
	sub		ebx, 4

	psrad		mm3, 15
	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm3, 15

	movq		QWORD PTR [edi+ebx*8+8],  mm2
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX1
#endif

	emms
	add	ebx, 4
	je	Done1

	dec	ebx
	xor	edx, edx
	
LastSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8

	sar	edx, 15

	shl	ecx, 8

	sar	ecx, 15

	mov	DWORD PTR [edi+ebx*8], edx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], ecx
	jge	LastSamples1
Done1:
        }
    }

#else // }
    ConvertMonoToStereo8(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxQuickMixMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PBYTE  pIn8 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.

#ifdef GTW_MIX // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (SampleCount == 0) {
        return 0;
    }
    
    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 0x800080		// 0, 0, 128, 128
	movd		mm5, edx	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psubw		mm1, mm5

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*8+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*8+8+32]
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	jge		DoMMX0

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpckhdq	mm4, mm4

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckldq	mm3, mm3

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]

	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	jge	LastSamples
Done:
        }
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	edx, edx
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples1

	sub	ebx, 3

	pxor		mm0, mm0
	mov	eax, 0x800080		// 0, 0, 128, 128
	movd		mm5, eax	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, DWORD PTR lRVol // Use lower 16 bits
	mov	eax, DWORD PTR lLVol
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX1

	add	ebx, 3

FirstSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 15

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 15
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples1

	sub	ebx, 3

DoMMX1:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32],  mm2
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	psrad		mm4, 15
	
	sub		ebx, 4
	jge		DoMMX10

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.

	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	paddd		mm1, QWORD PTR [edi+ebx*8]
	psrad		mm3, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm4, 15
	
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX1
#endif

	emms
	add	ebx, 4
	je	Done1

	dec	ebx
	xor	edx, edx
	
LastSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 15

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 15
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	LastSamples1
Done1:
        }
    }

#else // }
    QuickMixMonoToStereo8(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxConvertMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.
    if (SampleCount == 0) {
        return 0;
    }

#ifdef GTW_CONVERT // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
       _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], ecx
	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	jmp	DoMMX00

DoMMX0:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psrad		mm1, 16

	movq		mm2, mm1
	psrad		mm3, 16

DoMMX00:
	sub		ebx, 8
	punpckldq	mm1, mm1

	punpckhdq	mm2, mm2
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	punpckldq	mm3, mm3

	punpckhdq	mm4, mm4
	jge		DoMMX0

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	movq		QWORD PTR [edi+ebx*4],    mm1
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+8],  mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	movsx	eax, WORD PTR [esi+ebx]

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], eax

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	LastSamples
Done:
	}
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples1

	mov	eax, lRVol				// Use lower 16 bits
	mov	ecx, lLVol
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX1

	add	ebx, 6

FirstSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples1

	sub	ebx, 6

DoMMX1:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		mm3, mm1			// Mono samples

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	punpcklwd	mm1, mm1

	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	psrad		mm3, 15

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 15
	punpckhwd	mm4, mm3

	psrad		mm2, 15

	punpcklwd	mm3, mm3
	movq		QWORD PTR [edi+ebx*4],    mm1

	psrad		mm3, 15
	movq		QWORD PTR [edi+ebx*4+8],  mm2

	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX1
#endif

	emms
	add	ebx, 8
	je	Done1

	sub	ebx, 2
	
LastSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], edx

        sub	ebx, 2
	jge	LastSamples1
Done1:
	}
    }

#else // }
    ConvertMonoToStereo16(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxQuickMixMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.
#ifdef GTW_MIX // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (SampleCount == 0) {
        return 0;
    }

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
       _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:
        or      ebx, ebx
        jz      Done
	movsx	ecx, WORD PTR [esi+ebx]
	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], ecx
	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	jmp	DoMMX00

DoMMX0:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	punpckhwd	mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	psrad		mm1, 16

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psrad		mm3, 16

DoMMX00:
	movq		mm2, mm1
	sub		ebx, 8

	punpckldq	mm1, mm1

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	punpckldq	mm3, mm3

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	punpckhdq	mm4, mm4

	jge		DoMMX0

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	punpckldq	mm1, mm1

	punpckhdq	mm2, mm2
	paddd		mm1, QWORD PTR [edi+ebx*4]

	movq		mm4, mm3
	paddd		mm2, QWORD PTR [edi+ebx*4+8]

	punpckldq	mm3, mm3
	movq		QWORD PTR [edi+ebx*4],    mm1

	punpckhdq	mm4, mm4
	paddd		mm3, QWORD PTR [edi+ebx*4+16]

	paddd		mm4, QWORD PTR [edi+ebx*4+24]

	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	movsx	eax, WORD PTR [esi+ebx]

	mov	ecx, DWORD PTR[edi+ebx*4]
	mov	edx, DWORD PTR[edi+ebx*4+4]

	add	ecx, eax
	add	edx, eax

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], ecx

	mov	DWORD PTR [edi+ebx*4+12], edx
	jge	LastSamples
Done:
	}
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples1

	mov	eax, lRVol				// Use lower 16 bits
	mov	ecx, lLVol
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX1

	add	ebx, 6

FirstSamples1:
        or      ebx, ebx
        jz      Done1
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples1

	sub	ebx, 6

DoMMX1:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		mm3, mm1			// Mono samples

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	paddd		mm1, QWORD PTR [edi+ebx*4]
	psrad		mm3, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	psrad		mm4, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX1
#endif

	emms
	add	ebx, 8
	je	Done1

	sub	ebx, 2
	
LastSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	LastSamples1
Done1:
	}
    }

#else // }
    QuickMixMonoToStereo16(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

NTSTATUS MmxPeg32to16
(
        PLONG  pMixBuffer,
        PSHORT  pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
	if (SampleCount) {
    	_asm {
        	mov	ebx, SampleCount
        	mov	esi, pMixBuffer
        	mov	edi, pWriteBuffer

        	mov	ecx, ebx
        	lea	esi, [esi+ebx*4]
        	lea	edi, [edi+ebx*2]

        	neg	ebx
        	cmp	ecx, 7
        	jl	Last

        	lea	eax, [edi+ebx*2]
        	test	eax, 7
        	jz	DoMMX

        	test eax, 1
        	jnz Last

Start:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	inc	ebx

        	packssdw	mm1, mm1
        	lea	eax, [edi+ebx*2]

        	movd		ecx, mm1
        	test	eax, 7

        	mov	WORD PTR [edi+ebx*2-2], cx
        	jnz	Start

DoMMX:
        	add	ebx, 4

DoMMX0:
        	movq		mm1, [esi+ebx*4-16]
        	movq		mm2, [esi+ebx*4+8-16]

        	packssdw	mm1, mm2

        	movq		[edi+ebx*2-8], mm1

        	add	ebx, 4
        	jle	DoMMX0

        	sub	ebx, 4
        	jz	Done
Last:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	inc	ebx
        	packssdw	mm1, mm1
        	movd		ecx, mm1

        	mov	WORD PTR [edi+ebx*2-2], cx
        	jl	Last

Done:	
        	emms
    	}
	}
	return STATUS_SUCCESS;
}

NTSTATUS MmxPeg32to8
(
        PLONG  pMixBuffer,
        PBYTE   pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
	if (SampleCount) {
    	_asm {
        	mov	ecx, 0x8000

        	movd		mm5, ecx
        	punpckldq	mm5, mm5	// 32768, 32768

        	mov	ecx, 0x80

        	movd		mm6, ecx
        	punpcklwd	mm6, mm6
        	punpckldq	mm6, mm6

        	mov	ebx, SampleCount
        	mov	esi, pMixBuffer
        	mov	edi, pWriteBuffer

        	mov	ecx, ebx
        	lea	esi, [esi+ebx*4]
        	add	edi, ebx		// lea	edi, [edi+ebx*1]

        	neg	ebx
        	cmp	ecx, 15
        	jl	Last

        	lea	eax, [edi+ebx*1]
        	test	eax, 7
        	jz	DoMMX

Start:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx

        	packssdw	mm1, mm1
        	lea	eax, [edi+ebx*1]

        	punpcklwd	mm1, mm1

        	psrad		mm1, 16
        	inc	ebx

        	paddd		mm1, mm5
        	test	eax, 7

        	psrad		mm1, 8

        	movd		ecx, mm1

        	mov	BYTE PTR [edi+ebx*1-1], cl
        	jnz	Start

DoMMX:
        	add	ebx, 8

        	movq		mm1, [esi+ebx*4-32]
        	movq		mm2, [esi+ebx*4+8-32]
        	jmp	Top00
Top0:
        	movq		mm7, [esi+ebx*4-32]
        	packuswb	mm1, mm3	// Saturation is NO-OP here.

        	movq		[edi+ebx*1-16], mm1

        	movq		mm2, [esi+ebx*4+8-32]
        	movq		mm1, mm7
Top00:
        	movq		mm3, [esi+ebx*4+16-32]
        	packssdw	mm1, mm2	// Clip.

        	movq		mm4, [esi+ebx*4+24-32]
        	psraw		mm1, 8

        	packssdw	mm3, mm4
        	add	ebx, 8

        	psraw		mm3, 8
        	paddw		mm1, mm6

        	paddw		mm3, mm6
        	jle	Top0

        	packuswb	mm1, mm3	// Saturation is NO-OP here.
        	sub	ebx, 8

        	movq		[edi+ebx*1-8], mm1
        	jz	Done

Last:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	packssdw	mm1, mm1
        	punpcklwd	mm1, mm1
        	psrad		mm1, 16
        	inc	ebx
        	paddd		mm1, mm5
        	psrad		mm1, 8
        	movd		ecx, mm1

        	mov	BYTE PTR [edi+ebx*1-1], cl
        	jl	Last

Done:	
        	emms
    	}
	}
	return STATUS_SUCCESS;
}

DWORD
MmxSrcMix_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
	
    dwFrac = fp->dwFrac;

    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
      	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    // Note that the exact number of times through the loop can be calculated...

    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

    Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    // End note.

    	movq		mm1, QWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

    	movq		mm2, QWORD PTR [esi+8]
    	movd		mm5, ebp

    	psubd		mm2, mm1
    	punpcklwd	mm5, mm5

    	packssdw	mm2, mm2	// Use the 2 lowest words.
    	add	edi, 8			// plBuild += 2

    	movq		mm3, mm2
    	pmullw		mm2, mm5

    	movq		mm6, QWORD PTR [edi-8]
    	pmulhw		mm3, mm5

    	mov	ebp, DWORD PTR [esp+12]	// dwStep
    	paddd		mm1, mm6

    	add	eax, ebp		// dwFraction += dwStep
    	punpcklwd	mm2, mm3

    	mov	ecx, eax
    	psrad		mm2, 12

    	mov	ebp, eax
    	shr	ecx, 12

    	paddd		mm1, mm2
    	movq		QWORD PTR [edi-8], mm1

    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd

    	jb	Top
Exit:
    	emms
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}
	
    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
}

DWORD
MmxSrc_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
	
    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

    dwFrac = fp->dwFrac;

    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
      	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    // Note that the exact number of times through the loop can be calculated...

    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

    Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    // End note.

    	movq		mm1, QWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

    	movq		mm2, QWORD PTR [esi+8]
    	movd		mm5, ebp

    	psubd		mm2, mm1
    	punpcklwd	mm5, mm5

    	packssdw	mm2, mm2	// Use the 2 lowest words.
    	add	edi, 8			// plBuild += 2

    	movq		mm3, mm2
    	pmullw		mm2, mm5

    	movq		mm6, QWORD PTR [edi-8]
    	pmulhw		mm3, mm5

    	mov	ebp, DWORD PTR [esp+12]	// dwStep
#if 0
    	paddd		mm1, mm6		// Not actually needed...ZeroBuffer32 above.
#endif

    	add	eax, ebp		// dwFraction += dwStep
    	punpcklwd	mm2, mm3

    	mov	ecx, eax
    	psrad		mm2, 12

    	mov	ebp, eax
    	shr	ecx, 12

    	paddd		mm1, mm2
    	movq		QWORD PTR [edi-8], mm1

    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd

    	jb	Top
Exit:
    	emms
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}
	
    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
}

// WARNING!!! The code below seems to have a bug that produces pops.
ULONG
MmxConvert16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    UNALIGNED PBYTE	pIn8 = CurStage->pInputBuffer;
    ULONG   nChannels = CurStage->nOutputChannels;
    LARGE_INTEGER    Multiplier = {1, 1};
    
    samplesleft = SampleCount;
    if (SampleCount == 0) {
        return 0;
    }
    _asm {
        mov eax, SampleCount
        mov ebx, nChannels
        
        imul eax, ebx
        
        mov esi, pIn16
        mov edi, pOutputBuffer

        movq mm3, Multiplier                // 0, 1, 0, 1
        lea esi, [esi+eax*2]

        lea edi, [edi+eax*4]
        neg eax

        add eax, 8
        jns DoneWithEights

        // Do eight at a time
        movq mm0, qword ptr [esi+eax*2-16]  // x3, x2, x1, x0
        
        movq mm1, mm0                       // x3, x2, x1, x0
        
        movq mm4, qword ptr [esi+eax*2-8]   // x7, x6, x5, x4
        psrad mm0, 16                       // x3, x1

        pmaddwd mm1, mm3                    // 
        movq mm5, mm4
        
        psrad mm4, 16
        pmaddwd mm5, mm3

        movq mm2, mm1
        punpckldq mm1, mm0

        movq [edi+eax*4-32], mm1
        punpckhdq mm2, mm0

        movq [edi+eax*4-24], mm2
        movq mm6, mm5
        
        movq mm0, qword ptr [esi+eax*2]
        punpckldq mm5, mm4

        movq [edi+eax*4-16], mm5
        punpckhdq mm6, mm4

        add eax, 8
        jns DoneWithEights
Loop8:
        movq [edi+eax*4-40], mm6
        movq mm1, mm0
        
        movq mm4, qword ptr [esi+eax*2-8]
        psrad mm0, 16

        pmaddwd mm1, mm3
        movq mm5, mm4
        
        psrad mm4, 16
        pmaddwd mm5, mm3

        movq mm2, mm1
        punpckldq mm1, mm0

        movq [edi+eax*4-32], mm1
        punpckhdq mm2, mm0

        movq [edi+eax*4-24], mm2
        movq mm6, mm5
        
        movq mm0, qword ptr [esi+eax*2]
        punpckldq mm5, mm4

        movq [edi+eax*4-16], mm5
        punpckhdq mm6, mm4

        add eax, 8
        js Loop8

DoneWithEights:            
        movq [edi+eax*4-40], mm6
        sub eax, 8

Loop1:
        movsx ebx, word ptr [esi+eax*2]
        
        mov [edi+eax*4], ebx

        inc eax
        jnz Loop1
        
        emms
    }

    return samplesleft;
}

#define MMX32_START_MAC_SEQUENCE() _asm { mov esi, pTemp }; \
                _asm { mov edi, pCoeff }; \
                _asm { movq mm0, [esi+16] }; \
                _asm { pxor mm7, mm7 }; \
                _asm { movq mm2, [esi+8] }; \
                _asm { movq mm1, mm0 }; \
                _asm { pmaddwd mm0, [edi] }; \
                _asm { movq mm3, mm2 }; \
                _asm { pmaddwd mm1, [edi+9600*2] }; \
                _asm { movq mm4, [esi] }; \
                _asm { pmaddwd mm2, [edi+8] }; \
                _asm { movq mm5, mm4 }; \
                _asm { pmaddwd mm3, [edi+8+9600*2] }; \
                _asm { movq mm6, mm0 };

#define MMX32_MAC(a) _asm { movq mm0, [esi-a*24+16] }; \
                _asm { paddd mm7, mm1 }; \
                _asm { pmaddwd mm4, [edi+a*24-8] }; \
                _asm { movq mm1, mm0 }; \
                _asm { pmaddwd mm5, [edi+a*24-8+9600*2] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { movq mm2, [esi-a*24+8] }; \
                _asm { paddd mm7, mm3 }; \
                _asm { pmaddwd mm0, [edi+a*24] }; \
                _asm { movq mm3, mm2 }; \
                _asm { pmaddwd mm1, [edi+a*24+9600*2] }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm4, [esi-a*24] }; \
                _asm { paddd mm7, mm5 }; \
                _asm { pmaddwd mm2, [edi+a*24+8] }; \
                _asm { movq mm5, mm4 }; \
                _asm { pmaddwd mm3, [edi+a*24+8+9600*2] }; \
                _asm { paddd mm6, mm0 };

#define MMX32_END_MAC_SEQUENCE(a) _asm { pmaddwd mm4, [edi+a*24-8] }; \
                _asm { paddd mm7, mm1 }; \
                _asm { pmaddwd mm5, [edi+a*24-8+9600*2] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { paddd mm7, mm3 }; \
                _asm { paddd mm6, mm4 }; \
                _asm { paddd mm7, mm5 }; \
                _asm { movq mm0, mm6 }; \
                _asm { punpckhdq mm6, mm6 }; \
                _asm { paddd mm0, mm6 }; \
                _asm { psrad mm0, 8 }; \
                _asm { movq mm1, mm7 }; \
                _asm { punpckhdq mm7, mm7 }; \
                _asm { paddd mm1, mm7 }; \
                _asm { psrad mm1, 15 }; \
                _asm { paddd mm0, mm1 }; \
                _asm { movd eax, mm0 }; \
                _asm { mov edx, pOut }; \
                _asm { mov ecx, k }; \
                _asm { mov ebx, [edx+ecx*4-4] }; \
                _asm { add eax, ebx }; \
                _asm { mov [edx+ecx*4-4], eax };

#define MMX_START_MAC_SEQUENCE() _asm { mov esi, pTemp }; \
                _asm { mov edi, pCoeff }; \
                _asm { movq mm0, [esi+16] }; \
                _asm { pmaddwd mm0, [edi] }; \
                _asm { movq mm2, [esi+8] }; \
                _asm { pmaddwd mm2, [edi+8] }; \
                _asm { movq mm4, [esi] }; \
                _asm { movq mm6, mm0 }; \
                _asm { pmaddwd mm4, [edi+16] };

#define MMX_MAC(a) _asm { movq mm0, [esi-a*24+16] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { movq mm2, [esi-a*24+8] }; \
                _asm { pmaddwd mm0, [edi+a*24] }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm4, [esi-a*24] }; \
                _asm { pmaddwd mm2, [edi+a*24+8] }; \
                _asm { paddd mm6, mm0 }; \
                _asm { pmaddwd mm4, [edi+a*24+16] };

#define MMX_END_MAC_SEQUENCE() _asm { paddd mm6, mm2 }; \
                _asm { mov edx, pOut }; \
                _asm { mov ecx, k }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm0, mm6 }; \
                _asm { punpckhdq mm6, mm6 }; \
                _asm { paddd mm0, mm6 }; \
                _asm { psrad mm0, 15 }; \
                _asm { movd eax, mm0 }; \
                _asm { mov ebx, [edx+ecx*4-4] }; \
                _asm { add eax, ebx }; \
                _asm { mov [edx+ecx*4-4], eax };

#define XMMX_GTW
//#define XMMX_P4			// P4 code not faster...
#ifdef XMMX_P4
#define XMMX_MAC()	\
					_asm { movq		mm0, [esi-1*24+16] }; \
					\
					_asm { movdqu	xmm6, [esi - 16] }; \
					_asm { movdqu	xmm5, [edi + 32] } ; \
					_asm { paddd	mm6, mm2 }; \
					_asm { pmaddwd	xmm6, xmm5 }; \
					\
					_asm { movdqu	xmm4, [esi - 32] }; \
					_asm { movdqu	xmm5, [edi + 48] } ; \
					_asm { movdqu	xmm0, [esi - 48] }; \
					_asm { pmaddwd	xmm4, xmm5 }; \
					\
					_asm { movdqu	xmm5, [edi + 64] } ; \
					_asm { pmaddwd	mm0, [edi+1*24] }; \
					_asm { movdqu	xmm2, [esi - 64] }; \
					_asm { pmaddwd	xmm0, xmm5 }; \
					_asm { movdqu	xmm5, [edi + 80] } ; \
					_asm { paddd	xmm6, xmm4 }; \
					\
					_asm { pmaddwd	xmm2, xmm5 }; \
					_asm { movdqu	xmm4, [esi - 80] }; \
					_asm { movdqu	xmm5, [edi + 96] } ; \
					_asm { paddd	xmm6, xmm0 }; \
					_asm { pmaddwd	xmm4, xmm5 }; \
					_asm { paddd	xmm6, xmm2 }; \
					_asm { paddd	mm6, mm4 }; \
					\
					_asm { paddd	xmm6, xmm4 }; \
					_asm { paddd	mm6, mm0 }; \
					\
					_asm { movdqu		xmm2, xmm6 }; \
					_asm { punpckhqdq	xmm6, xmm6 }; \
					_asm { movq			mm4, [esi-4*24] }; \
					_asm { paddd			xmm2, xmm6 }; \
					_asm { pmaddwd		mm4, [edi+4*24+16] }; \
					_asm { movdq2q		mm2,  xmm2 }; 
#else
#define XMMX_MAC()	\
					_asm { movq mm0, [esi-1*24+16] }; \
					_asm { paddd mm6, mm2 }; \
					_asm { movq mm2, [esi-1*24+8] }; 		/* -16 */ \
					_asm { pmaddwd mm0, [edi+1*24] }; \
					_asm { movq mm1, [esi-1*24] }; \
					\
					_asm { pmaddwd mm2, [edi+1*24+8] }; 	/* +32 */ \
					_asm { movq mm3, [esi-2*24+16] }; 		/* -32 */ \
					_asm { paddd mm6, mm4 }; \
					\
					_asm { pmaddwd mm1, [edi+1*24+16] }; \
					_asm { movq mm5, [esi-2*24+8] }; \
					_asm { paddd mm6, mm0 }; \
					\
					_asm { pmaddwd mm3, [edi+2*24] }; 		/* +48 */ \
					_asm { movq mm4, [esi-2*24] }; 			/* -48 */ \
					_asm { paddd mm6, mm2 }; \
					\
					_asm { pmaddwd mm5, [edi+2*24+8] }; \
					_asm { movq mm0, [esi-3*24+16] }; \
					_asm { paddd mm6, mm1 }; \
						\
					_asm { pmaddwd mm4, [edi+2*24+16] };	/* +64 */ \
					_asm { movq mm7, [esi-3*24+8] }; 		/* -64 */ \
					_asm { paddd mm6, mm3 }; \
					\
					_asm { pmaddwd mm0, [edi+3*24] }; \
					_asm { movq mm1, [esi-3*24] }; \
					_asm { paddd mm6, mm5 }; \
					\
					_asm { pmaddwd mm7, [edi+3*24+8] }; 	/* +80 */ \
					_asm { movq mm3, [esi-4*24+16] }; 		/* -80 */ \
					_asm { paddd mm6, mm4 }; \
					\
					_asm { pmaddwd mm1, [edi+3*24+16] }; \
					_asm { movq mm2, [esi-4*24+8] }; \
					_asm { paddd mm6, mm0 }; \
					\
					_asm { pmaddwd mm3, [edi+4*24] }; 		/* +96 */ \
					_asm { movq mm4, [esi-4*24] }; \
					_asm { paddd mm6, mm7 }; \
					\
					_asm { pmaddwd mm2, [edi+4*24+8] }; \
					_asm { paddd mm6, mm1 }; \
					\
					_asm { pmaddwd mm4, [edi+4*24+16] }; \
					_asm { paddd mm6, mm3 }; 
#endif

                
DWORD MmxSrcMix_Filtered
(
    PMIXER_OPERATION    CurStage,
    ULONG               nSamples,
    ULONG               nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, k;
	PLONG	pTemp32 ;
	PSHORT  pTemp, pCoeffStart ;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    ULONG   nSizeOfChannel = fp->csHistory;
    ULONG   nChannels = fp->nChannels;
    extern ULONG   FilterSizeFromQuality[];
    LONG    ElevenL = 11*L;
	DWORD   nCoefficients = FilterSizeFromQuality[fp->Quality];
	DWORD   j = fp->nOutCycle;
    PSHORT  pHistory = (PSHORT)CurStage->pInputBuffer;
	PSHORT  pCoeff = (PSHORT)fp->pCoeff + fp->CoeffIndex;
	PSHORT  pCoeffEnd = (PSHORT)fp->pCoeff + fp->nCoeffUsed;
	PSHORT  pHistoryStart = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
	LONG    Rounder[2] = { 0x4000L, 0L };

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */

    // Change the input buffer to int16
    pTemp32 = (PLONG) CurStage->pInputBuffer;
    pTemp = (PSHORT) CurStage->pInputBuffer;
    if (nSamples) {
        _asm {
            mov esi, pTemp32
            mov edi, pTemp

            mov ecx, nSamples
            mov edx, nChannels

            imul ecx, edx

            lea esi, [esi+ecx*4]
            lea edi, [edi+ecx*2]
            
            neg ecx

    ConvertLoop:
            movq mm0, [esi+ecx*4]

            movq mm1, [esi+ecx*4+8]

            packssdw mm0, mm1

            movq [edi+ecx*2], mm0

            add ecx, 4
            js ConvertLoop
        }
    }

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)

	for (i=0; i < nOutputSamples; i++) {
        while (j >= L) {
            // Take the next nChannels of input
            pTemp = pHistoryStart + nSizeOfChannel;
            pHistoryStart++;
            for (k=0; k<nChannels; k++) {
                *(pTemp) = pHistory[k];
                pTemp += nSizeOfChannel;
            }
    		j -= L;
            pHistory += nChannels;
    	}
    	
        pCoeffStart = pCoeff;
        pTemp = pHistoryStart + fp->nSizeOfHistory - 12;
        _asm {
            mov eax, j
            mov edx, nCoefficients

            sub eax, edx
            mov ebx, L

            mov esi, pTemp
            mov ecx, ElevenL                    // 11*L

            add eax, ecx                        // j-nCoefficients+11*L
            add ebx, ecx                        // 12*L

            mov edi, nSizeOfChannel
            push eax                            // j-nCoefficients+11*L

            shl edi, 1                          // nSizeOfChannel * sizeof(SHORT)
            mov ecx, nChannels

            push edi                            // 2*nSizeOfChannel
            push ebx                            // 12*L

            shl ebx, 2                          // 48*L
            mov edi, pCoeffStart

ChannelLoop:
            // Start the MAC sequence by doing the first 12 multiplies.
            movq mm6, [esi+16]

            pmaddwd mm6, [edi]

            movq mm2, [esi+8]

            pmaddwd mm2, [edi+8]

            movq mm4, [esi]

            pmaddwd mm4, [edi+16]

            add eax, ebx                        // j-nCoefficients+59*L
            jns SmallLoop

BigLoop:        
        }

#ifdef XMMX_GTW
		XMMX_MAC();
#else
        MMX_MAC(1);
        MMX_MAC(2);
        MMX_MAC(3);
        MMX_MAC(4);
#endif

        _asm {
            sub esi, 24*4
            add edi, 24*4

            add eax, ebx                        // +48*L
            js BigLoop

SmallLoop:
            sub eax, ebx                        // -48*L
            mov edx, [esp]                      // 12*L

            add eax, edx                        // +12*L
            jns OneLoop

Loop1:
        }

        MMX_MAC(1);

        _asm {
            sub esi, 24
            add edi, 24

            add eax, edx                        // +12*L
            js Loop1

OneLoop:
            sub eax, edx                        // -12*L
            mov edx, L

            shl edx, 2                          // 4*L

            add eax, edx                        // +4*L
            jns LoopDone

Loop2:
            paddd mm6, mm4
            
            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

            add eax, edx
            js Loop2

LoopDone:
            // Decide whether to do one last set of 4 MAC's
            sub eax, edx
            mov edx, L

            add eax, edx
            jns NoFinal

            paddd mm6, mm4

            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

NoFinal:
            paddd mm6, mm2
            add edi, 24

            mov pCoeff, edi
            mov edi, pOut

            paddd mm6, mm4
            mov esi, pTemp

            movq mm0, mm6
            punpckhdq mm6, mm6

            paddd mm0, mm6
            mov eax, [esp+4]                // 2*nSizeOfChannel

//            paddd mm0, Rounder
            
            psrad mm0, 15
            sub esi, eax

            mov edx, [edi+ecx*4-4]
            mov pTemp, esi

            movd eax, mm0

            add eax, edx

            mov [edi+ecx*4-4], eax
            dec ecx

            mov edi, pCoeffStart
            mov eax, [esp+8]                // j-nCoefficients+11*L
            
            jnz ChannelLoop

            add esp, 12
            
        }
        
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = (PSHORT)fp->pCoeff;
		}
		
		pOut += nChannels;
        j += M;
	}

    nSamples -= (pHistoryStart + fp->nSizeOfHistory - (PSHORT)CurStage->pInputBuffer);
    while (j >= L && nSamples) {
        // Take the next nChannels of input
        pTemp = pHistoryStart + nSizeOfChannel;
        pHistoryStart++;
        for (k=0; k<nChannels; k++) {
            *(pTemp) = pHistory[k];
            pTemp += nSizeOfChannel;
        }
		j -= L;
        pHistory += nChannels;
    	nSamples--;
    }
    	
    // Copy last samples to history
    pTemp = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory = pHistoryStart;
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - (PSHORT)fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

    _asm { emms }

	return (nOutputSamples);
}

DWORD MmxSrc_Filtered
(
    PMIXER_OPERATION    CurStage,
    ULONG               nSamples,
    ULONG               nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, k;
	PLONG	pTemp32 ;
	PSHORT  pTemp, pCoeffStart ;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    ULONG   nSizeOfChannel = fp->csHistory;
    ULONG   nChannels = fp->nChannels;
    extern ULONG   FilterSizeFromQuality[];
    LONG    ElevenL = 11*L;
	DWORD   nCoefficients = FilterSizeFromQuality[fp->Quality];
	DWORD   j = fp->nOutCycle;
    PSHORT  pHistory = (PSHORT)CurStage->pInputBuffer;
	PSHORT  pCoeff = (PSHORT)fp->pCoeff + fp->CoeffIndex;
	PSHORT  pCoeffEnd = (PSHORT)fp->pCoeff + fp->nCoeffUsed;
	PSHORT  pHistoryStart = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
	LONG    Rounder[2] = { 0x4000L, 0L };

    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */

    // Change the input buffer to int16
    pTemp32 = (PLONG) CurStage->pInputBuffer;
    pTemp = (PSHORT) CurStage->pInputBuffer;

    if (nSamples) {
        _asm {
            mov esi, pTemp32
            mov edi, pTemp

            mov ecx, nSamples
            mov edx, nChannels

            imul ecx, edx

            lea esi, [esi+ecx*4]
            lea edi, [edi+ecx*2]
            
            neg ecx

    ConvertLoop:
            movq mm0, [esi+ecx*4]

            movq mm1, [esi+ecx*4+8]

            packssdw mm0, mm1

            movq [edi+ecx*2], mm0

            add ecx, 4
            js ConvertLoop
        }
    }

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)

	for (i=0; i < nOutputSamples; i++) {
        while (j >= L) {
            // Take the next nChannels of input
            pTemp = pHistoryStart + nSizeOfChannel;
            pHistoryStart++;
            for (k=0; k<nChannels; k++) {
                *(pTemp) = pHistory[k];
                pTemp += nSizeOfChannel;
            }
    		j -= L;
            pHistory += nChannels;
    	}
    	
        pCoeffStart = pCoeff;
        pTemp = pHistoryStart + fp->nSizeOfHistory - 12;
        _asm {
            mov eax, j
            mov edx, nCoefficients

            sub eax, edx
            mov ebx, L

            mov esi, pTemp
            mov ecx, ElevenL                    // 11*L

            add eax, ecx                        // j-nCoefficients+11*L
            add ebx, ecx                        // 12*L

            mov edi, nSizeOfChannel
            push eax                            // j-nCoefficients+11*L

            shl edi, 1                          // nSizeOfChannel * sizeof(SHORT)
            mov ecx, nChannels

            push edi                            // 2*nSizeOfChannel
            push ebx                            // 12*L

            shl ebx, 2                          // 48*L
            mov edi, pCoeffStart

ChannelLoop:
            // Start the MAC sequence by doing the first 12 multiplies.
            movq mm6, [esi+16]

            pmaddwd mm6, [edi]

            movq mm2, [esi+8]

            pmaddwd mm2, [edi+8]

            movq mm4, [esi]

            pmaddwd mm4, [edi+16]

            add eax, ebx                        // j-nCoefficients+59*L
            jns SmallLoop

BigLoop:        
        }

#ifdef XMMX_GTW
		XMMX_MAC();
#else
        MMX_MAC(1);
        MMX_MAC(2);
        MMX_MAC(3);
        MMX_MAC(4);
#endif

        _asm {
            sub esi, 24*4
            add edi, 24*4

            add eax, ebx                        // +48*L
            js BigLoop

SmallLoop:
            sub eax, ebx                        // -48*L
            mov edx, [esp]                      // 12*L

            add eax, edx                        // +12*L
            jns OneLoop

Loop1:
        }

        MMX_MAC(1);

        _asm {
            sub esi, 24
            add edi, 24

            add eax, edx                        // +12*L
            js Loop1

OneLoop:
            sub eax, edx                        // -12*L
            mov edx, L

            shl edx, 2                          // 4*L

            add eax, edx                        // +4*L
            jns LoopDone

Loop2:
            paddd mm6, mm4
            
            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

            add eax, edx
            js Loop2

LoopDone:
            // Decide whether to do one last set of 4 MAC's
            sub eax, edx
            mov edx, L

            add eax, edx
            jns NoFinal

            paddd mm6, mm4

            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

NoFinal:
            paddd mm6, mm2
            add edi, 24

            mov pCoeff, edi
            mov edi, pOut

            paddd mm6, mm4
            mov esi, pTemp

            movq mm0, mm6
            punpckhdq mm6, mm6

            paddd mm0, mm6
            mov eax, [esp+4]                // 2*nSizeOfChannel

//            paddd mm0, Rounder
            
            psrad mm0, 15
            sub esi, eax

            mov edx, [edi+ecx*4-4]
            movd eax, mm0
#if 0
            add	eax, edx			// Not actually needed...ZeroBuffer32 above.
#endif

            mov pTemp, esi
            mov [edi+ecx*4-4], eax
            dec ecx
            mov edi, pCoeffStart

            mov eax, [esp+8]                // j-nCoefficients+11*L
            jnz ChannelLoop

            add esp, 12
            
        }
        
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = (PSHORT)fp->pCoeff;
		}
		
		pOut += nChannels;
        j += M;
	}

    nSamples -= (pHistoryStart + fp->nSizeOfHistory - (PSHORT)CurStage->pInputBuffer);
    while (j >= L && nSamples) {
        // Take the next nChannels of input
        pTemp = pHistoryStart + nSizeOfChannel;
        pHistoryStart++;
        for (k=0; k<nChannels; k++) {
            *(pTemp) = pHistory[k];
            pTemp += nSizeOfChannel;
        }
		j -= L;
        pHistory += nChannels;
    	nSamples--;
    }
    	
    // Copy last samples to history
    pTemp = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory = pHistoryStart;
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - (PSHORT)fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

    _asm { emms }

	return (nOutputSamples);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\modeflag.inc ===
H_8_BITS        equ 0
H_16_BITS       equ 1
H_MONO          equ 0
H_STEREO        equ 2
H_UNSIGNED      equ 0
H_SIGNED        equ 4
H_ORDER_LR      equ 0
H_ORDER_RL      equ 8
H_NO_FILTER	equ 0
H_FILTER	equ 16
H_BASEMASK	equ 31
H_NO_LOOP       equ 0
H_LOOP          equ 256
H_BUILD_MONO    equ 0
H_BUILD_STEREO  equ 32
H_NO_RESAMPLE   equ 0
H_RESAMPLE      equ 64
H_NO_SCALE      equ 0
H_SCALE         equ 128
H_NO_CLIP       equ 0
H_CLIP          equ 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\perf.h ===
//---------------------------------------------------------------------------
//
//  Module:   perf.d
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             01/02/01   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wmistr.h>
#include <evntrace.h>

extern NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

extern ULONG TraceEnable;

#define PerfInstrumentationEnabled() (TraceEnable != 0)

#define KMIXER_SOURCE_GLITCH 2

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\perf.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    perf.c

Abstract:

Author:

    ArthurZ

Environment:

    Kernel Mode

--*/



#include "common.h"
#include "perf.h"



#define PROC_REG_PATH L"System\\CurrentControlSet\\Services\\Kmixer"



typedef struct PERFINFO_AUDIOGLITCH {
    ULONGLONG   cycleCounter;
    ULONG       glitchType;
    LONGLONG    sampleTime;
    LONGLONG    previousTime;
    ULONG_PTR       instanceId;
} PERFINFO_AUDIOGLITCH, *PPERFINFO_AUDIOGLITCH;

typedef struct PERFINFO_WMI_AUDIOGLITCH {
    EVENT_TRACE_HEADER          header;
    PERFINFO_AUDIOGLITCH        data;
} PERFINFO_WMI_AUDIO_GLITCH, *PPERFINFO_WMI_AUDIOGLITCH;



GUID ControlGuid =
{ 0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69 };

GUID TraceGuid = 
{ 0xe5a43a19, 0x6de0, 0x44f8, 0xb0, 0xd7, 0x77, 0x2d, 0xbd, 0xe4, 0x6c, 0xc0 };

ULONG TraceEnable;
TRACEHANDLE LoggerHandle;
ULONG InstanceCount=0;


NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine registers this component as a WMI event tracing provider.

Arguments:

    DeviceObject - supplies the device object we are registering with WMI

Return Value:

    None.

--*/

{    
    if (InterlockedIncrement (&InstanceCount)==1) {
        IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);
    } //if
}



VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine unregisters this component as a WMI event tracing provider.

Arguments:

    DeviceObject - supplies the device object we are uregistering with WMI

Return Value:

    None.

--*/

{
    if (InterlockedDecrement (&InstanceCount)==0) {
        IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_DEREGISTER);
    } //if
}



VOID
RegisterWmiGuids (
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG RegInfoSize,
    IN PULONG ReturnSize
    )

/*++

Routine Description:

    This routine registers WMI event tracing streams.

--*/

{
    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR Temp;

    *ReturnSize = 0;
    GuidCount = 1;

    RegistryPathSize = sizeof (PROC_REG_PATH) - sizeof (WCHAR) + sizeof (USHORT);
    SizeNeeded = sizeof (WMIREGINFOW) + GuidCount * sizeof (WMIREGGUIDW) + RegistryPathSize;

    if (SizeNeeded > RegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *ReturnSize = sizeof (ULONG);
        return;
    }

    RtlZeroMemory (WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = WmiRegInfo->WmiRegGuid;
    WmiRegGuidPtr->Guid = ControlGuid;
    WmiRegGuidPtr->Flags |= (WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID);

    Temp = (PUCHAR)(WmiRegGuidPtr + 1);
    WmiRegInfo->RegistryPath = PtrToUlong ((PVOID)(Temp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)Temp) = (USHORT)(sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    Temp += sizeof (USHORT);
    RtlCopyMemory (Temp, PROC_REG_PATH, sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    *ReturnSize = SizeNeeded;
}



NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_SYSTEM_CONTROL calls. It processes
    WMI requests and passes everything else on to KS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    ULONG ReturnSize;
    PWNODE_HEADER Wnode;

    if ((PDEVICE_OBJECT)IrpSp->Parameters.WMI.ProviderId != DeviceObject) {
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_REGINFO:
        RegisterWmiGuids (IrpSp->Parameters.WMI.Buffer,
                          IrpSp->Parameters.WMI.BufferSize,
                          &ReturnSize);
        break;
    
    case IRP_MN_ENABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange (&TraceEnable, 1);
        Wnode = (PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer;
        if (IrpSp->Parameters.WMI.BufferSize >= sizeof (WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
        }
        break;

    case IRP_MN_DISABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange (&TraceEnable, 0);
        break;

    case IRP_MN_ENABLE_COLLECTION:
    case IRP_MN_DISABLE_COLLECTION:
        ReturnSize = 0;
        break;

    default:
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = ReturnSize;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

/*++

Routine Description:

    This routine logs a WMI event tracing event with an audio glitch GUID
    and the supplied glitch type.

--*/

{
   PERFINFO_WMI_AUDIO_GLITCH Event;

    if (LoggerHandle == (TRACEHANDLE)NULL || TraceEnable == 0) {
        return;
    }

    RtlZeroMemory (&Event, sizeof (Event));
    Event.header.Size = sizeof (Event);
    Event.header.Flags = WNODE_FLAG_TRACED_GUID;
    Event.header.Guid = TraceGuid;
    Event.data.glitchType = Type;
    Event.data.instanceId = InstanceId;
    Event.data.sampleTime = CurrentTime;
    Event.data.previousTime = PreviousTime;

    ((PWNODE_HEADER)&Event)->HistoricalContext = LoggerHandle;

    IoWMIWriteEvent ((PVOID)&Event);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\filters\kmixer\pins.c ===
//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"
#include "topology.h"
#include <unknown.h>
#include <drmk.h>
#include "perf.h"

#ifdef _X86_

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

LONGLONG __forceinline ReadCycleCounter(VOID)
{

    __asm {
        rdtsc
    }
}

#endif


#define     ZDbgPrint
#define     IO_AUD_INCREMENT       IO_NO_INCREMENT

#ifdef VERIFY_CAPTURE_DATA
ULONG ZeroSampleCount = 0;
#endif

#pragma LOCKED_DATA
#ifdef PERF_COUNT
ULONG gNumBuffersAdded = 0, gSinkStarved = 0, gMaxMixed = 0, WorstTicksPerWorkItem = 0;
BOOL	fStarved = FALSE;

#endif

ULONG gNumCompletionsWhileStarved = 0;
ULONG gNumMixBuffersAdded = 0;
ULONG gNumSilenceSamplesInserted = 0;
ULONG gIoCallDriverFailedCount = 0;

#pragma PAGEABLE_DATA

NTSTATUS
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    );

//===========================================================================
//===========================================================================

extern ULONG FilterSizeFromQuality[];
extern PFNStage ConvertFunction[];
extern PFNStage SrcFunction[];
extern PFNStage MmxConvertFunction[];
extern PFNStage MmxSrcFunction[];
extern BOOL fLogToFile;

extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

#ifdef LOG_TO_FILE
BYTE WaveHeader[] = {
    (BYTE) 0x52,(BYTE) 0x49,(BYTE) 0x46,(BYTE) 0x46,(BYTE) 0xf0,(BYTE) 0x7a,(BYTE) 0x01,(BYTE) 0x00,(BYTE) 0x57,(BYTE) 0x41,
    (BYTE) 0x56, (BYTE) 0x45, (BYTE) 0x66, (BYTE) 0x6d, (BYTE) 0x74, (BYTE) 0x20, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x00,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x02, (BYTE) 0x00, (BYTE) 0x22, (BYTE) 0x56, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x88, (BYTE) 0x58,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x04, (BYTE) 0x00, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x64, (BYTE) 0x61, (BYTE) 0x74, (BYTE) 0x61,
    (BYTE) 0x9c, (BYTE) 0x7a, (BYTE) 0x01, (BYTE) 0x04
};
#endif

#ifdef INTEGER_DITHER
ULONG Dither[DITHER_LENGTH] = {
  0x97607148,  0x88802242,  0x26577010,  0x72830083,  0x74557662,
  0x80745045,  0x84593113,  0x78265614,  0x71556441,  0x83341379,
  0x36030607,  0x94559055,  0x38197485,  0x97100034,  0x12308421,
  0x22535579,  0x22723188,  0x15934819,  0x79437052,  0x76216268,
  0x84277182,  0x24303903,  0x95559678,  0x85762244,  0x28075492,
  0x71061946,  0x34584071,  0x30182983,  0x37511702,  0x78086760,
  0x31128029,  0x33337902,  0x93008582,  0x13866352,  0x95423804,
  0x87911478,  0x52328720,  0x14893955,  0x54374102,  0x52763358,
  0x75637160,  0x64658006,  0x95686164,  0x27549469,  0x75854882,
  0x25050333,  0x12433981,  0x31849903,  0x57961230,  0x49809833,
  0x25444441,  0x41837551,  0x34178601,  0x18965704,  0x91970478,
  0x81985719,  0x32952180,  0x33292439,  0x97324106,  0x24361291,
  0x34634383,  0x20404594,  0x26788850,  0x85622742,  0x11582986,
  0x42435235,  0x99096700,  0x30978084,  0x90840333,  0x35032225,
  0x24343909,  0x15789398,  0x97161824,  0x18285150,  0x75227011,
  0x31320100,  0x87189446,  0x86442387,  0x30578470,  0x70623404,
  0x33354624,  0x97315616,  0x47388409,  0x52981236,  0x72295763,
  0x96608282,  0x68476917,  0x71378315,  0x67356973,  0x66079831,
  0x89957320,  0x85182872,  0x24144000,  0x14132635,  0x29084241,
  0x42497294,  0x41545920,  0x25129260,  0x58571020,  0x50004610,
  0x46823098,  0x29435594,  0x77598411,  0x81399102,  0x32061533,
  0x87753620,  0x88381911,  0x89078649,  0x36578263,  0x14134236,
  0x83925333,  0x88163688,  0x96095774,  0x27796221,  0x56959520,
  0x28024628,  0x69566411,  0x14962521,  0x98257203,  0x96963476,
  0x23701696,  0x52154279,  0x43928803,  0x48917033,  0x15934888,
  0x59283064,  0x73022728,  0x81671426,  0x27561822,  0x43285824,
  0x47957834,  0x43275472,  0x28629072,  0x37805488,  0x83645857,
  0x45419704,  0x11695641,  0x29363360,  0x56999535,  0x10347663,
  0x82193115,  0x40880100,  0x68790521,  0x95578515,  0x27113504,
  0x26483464,  0x99074283,  0x94079495,  0x19878194,  0x66077379,
  0x44103864,  0x93291022,  0x21547004,  0x99066759,  0x76158444,
  0x35844020,  0x54282568,  0x28194381,  0x63980115,  0x32223133,
  0x96172670,  0x56286233,  0x48030528,  0x63399984,  0x23932267,
  0x10568868,  0x99615669,  0x25502835,  0x34288738,  0x61094535,
  0x19956509,  0x10131644,  0x43512696,  0x64409236,  0x67879202,
  0x70911777,  0x25461827,  0x53287932,  0x71788571,  0x43357027,
  0x27933551,  0x93491471,  0x67737436,  0x33238512,  0x12558402,
  0x98981004,  0x34477313,  0x90305386,  0x97856412,  0x47483320,
  0x19442109,  0x27327416,  0x44818868,  0x79299831,  0x44413140,
  0x92247673,  0x34116637,  0x73563600,  0x21837990,  0x32956492,
  0x79242407,  0x82845592,  0x52116046,  0x99028305,  0x66529372,
  0x83018495,  0x39358082,  0x41491716,  0x98805087,  0x92457293,
  0x63790634,  0x41788816,  0x97164638,  0x33557250,  0x58964831,
  0x35101286,  0x42696088,  0x82029735,  0x68500044,  0x27739917,
  0x76818846,  0x52474762,  0x42252471,  0x76944760,  0x55090141,
  0x35059412,  0x37102037,  0x93558220,  0x79803162,  0x40913115,
  0x51082370,  0x47551270,  0x95644944,  0x30350637,  0x55178802,
  0x39436788,  0x96482748,  0x46895094,  0x16289649,  0x51046467,
  0x64037110,  0x46964184,  0x35309790,  0x80340875,  0x23091948,
  0x71128403,  0x79954082,  0x36392145,  0x46113752,  0x49707956,
  0x34653566,  0x45363008,  0x94199486,  0x93955167,  0x82628835,
  0x72202569,  0x71038958,  0x74144891,  0x18269859,  0x35963774,
  0x71298712,  0x91537835,  0x63137485,  0x92996973,  0x71778978,
  0x89724595,  0x91171931,  0x28639264,  0x33309183,  0x63547374,
  0x18726381,  0x44735938,  0x47511205,  0x19988380,  0x26316922,
  0x14683136,  0x19749139,  0x36285712,  0x18955700,  0x84323730,
  0x47465796,  0x44723664,  0x58997654,  0x33346203,  0x88041670,
  0x87124286,  0x78500813,  0x45025258,  0x63069629,  0x45325314,
  0x66829165,  0x45463159,  0x24150662,  0x93922405,  0x30927937,
  0x72904092,  0x11331287,  0x59165860,  0x76820905,  0x48483077,
  0x97361437,  0x65412401,  0x69241889,  0x71563578,  0x23953636,
  0x63068271,  0x57292244,  0x92020916,  0x87128511,  0x74846789,
  0x29444009,  0x25893852,  0x56394350,  0x72942257,  0x24390006,
  0x17770358,  0x63460260,  0x75987973,  0x64188966,  0x43057902,
  0x54338162,  0x97802540,  0x27397702,  0x37068400,  0x46249947,
  0x32306081,  0x70617479,  0x61647959,  0x38810599,  0x49492222,
  0x75242009,  0x14215033,  0x80131149,  0x51993779,  0x50479560,
  0x50701936,  0x25226850,  0x50798672,  0x36862637,  0x78382841,
  0x14995185,  0x24699721,  0x94509075,  0x38782332,  0x76567755,
  0x42031411,  0x46087513,  0x32916273,  0x62843117,  0x96612198,
  0x71767473,  0x30237418,  0x67216399,  0x43152062,  0x13376039,
  0x29241139,  0x31955321,  0x43131264,  0x20327523,  0x53284412,
  0x52829154,  0x54742679,  0x57514336,  0x11170352,  0x66459233,
  0x84072243,  0x72123010,  0x22585944,  0x39040124,  0x69127011,
  0x64027861,  0x14742222,  0x45750488,  0x77381699,  0x12414841,
  0x30097740,  0x32380236,  0x79935781,  0x74847777,  0x17188998,
  0x57698286,  0x26991481,  0x44188062,  0x71060026,  0x20807518,
  0x93968025,  0x21464266,  0x78404156,  0x49971999,  0x40573550,
  0x88558175,  0x29223597,  0x52030548,  0x87558096,  0x44361632,
  0x41167896,  0x73824048,  0x69409591,  0x56286895,  0x15313061,
  0x96787724,  0x44463441,  0x85461275,  0x88130952,  0x54107991,
  0x63435160,  0x57192077,  0x33535785,  0x78841123,  0x82555820,
  0x20695837,  0x14481952,  0x99095161,  0x24450532,  0x61774579,
  0x69745141,  0x52358575,  0x67795090,  0x66726106,  0x86797950,
  0x21260947,  0x38952118,  0x72075916,  0x37593516,  0x93990304,
  0x34346457,  0x56713160,  0x20970551,  0x43841616,  0x14578981,
  0x73804485,  0x43717914,  0x32485834,  0x16824126,  0x22592387,
  0x38577522,  0x34051594,  0x77734308,  0x85223777,  0x34821034,
  0x23294467,  0x19968361,  0x59836520,  0x74603771,  0x39715323,
  0x78706714,  0x52848182,  0x32271208,  0x32944359,  0x29931693,
  0x38780186,  0x36726640,  0x63358155,  0x35778715,  0x58766355,
  0x42331618,  0x28356048,  0x65147880,  0x46204810,  0x88500489,
  0x90462418,  0x95887278,  0x56566917,  0x28120835,  0x89588062,
  0x94997750,  0x29987106,  0x24636681,  0x46768937,  0x10824657,
  0x55476368,  0x74527283,  0x44578902,  0x27611972,  0x63929983,
  0x62175293,  0x66644861,  0x22928591,  0x88190439,  0x15669597,
  0x82242049,  0x30040752,  0x23721318,  0x40772135,  0x34880979,
  0x83757164,  0x52712469,  0x16340602,  0x43652944,  0x18923057,
  0x58527803,  0x28098971,  0x19367986,  0x12280228,  0x80383175,
  0x20705644,  0x33421503,  0x90483512,  0x17573901,  0x93879776,
  0x17643093,  0x82387186,  0x91077900,  0x95243993,  0x66764120,
  0x66039500,  0x57388132,  0x76440255,  0x66726820,  0x30862726,
  0x79916878,  0x31945772,  0x75880193,  0x68158175,  0x57632432,
  0x28828626,  0x94282456,  0x17029173,  0x53629203,  0x45899913,
  0x69133098,  0x36869178,  0x98121807,  0x10658577,  0x34882364,
  0x61824444,  0x74133683,  0x45147578,  0x20902681,  0x15559180,
  0x89970684,  0x31495695,  0x93218737,  0x76769468,  0x16886443,
  0x17341361,  0x86593427,  0x88395472,  0x68161709,  0x35364155,
  0x28341439,  0x49987523,  0x41391299,  0x95112883,  0x74574764,
  0x50620622,  0x68787337,  0x41735227,  0x51963833,  0x18886674,
  0x32891889,  0x91529145,  0x67633505,  0x39494462,  0x88899760,
  0x35425420,  0x30459817,  0x49190734,  0x31908065,  0x69447122,
  0x85743116,  0x96887278,  0x20517694,  0x90421652,  0x89811931,
  0x76300231,  0x34787318,  0x19528017,  0x65913642,  0x30492611,
  0x99370869,  0x38932885,  0x45292165,  0x13000339,  0x59669199,
  0x42983310,  0x88117975,  0x25953796,  0x35418769,  0x95753969,
  0x58877707,  0x12006447,  0x33329928,  0x64524827,  0x76285663,
  0x81903061,  0x68657266,  0x34282065,  0x70554633,  0x28849052,
  0x45552199,  0x76121692,  0x79150359,  0x81692318,  0x33403924,
  0x93755077,  0x84434691,  0x70749862,  0x81053949,  0x35077956,
  0x43573272,  0x58320201,  0x57318893,  0x48433628,  0x39639129,
  0x47217251,  0x93908859,  0x36418023,  0x92925962,  0x43529693,
  0x65875780,  0x65501994,  0x65734440,  0x71103319,  0x61765954,
  0x90478824,  0x64305543,  0x65577799,  0x56787767,  0x60686213,
  0x62706137,  0x20171961,  0x77169859,  0x72953988,  0x53597919,
  0x88983555,  0x12678645,  0x34714736,  0x46487359,  0x10110526,
  0x26312436,  0x30309148,  0x86126696,  0x43121954,  0x39484752,
  0x45905324,  0x81786259,  0x87546266,  0x58429807,  0x65364997,
  0x83666271,  0x60457111,  0x38168704,  0x40196574,  0x53707036,
  0x87928282,  0x64860294,  0x43847393,  0x83583419,  0x37541228,
  0x81084194,  0x61267503,  0x87783612,  0x40343776,  0x97165511,
  0x48821692,  0x94184830,  0x39854775,  0x10287104,  0x66266428,
  0x39184425,  0x13001603,  0x46563351,  0x14642635,  0x63849985,
  0x98010418,  0x47804121,  0x16333676,  0x31478425,  0x86326626,
  0x93619559,  0x12040031,  0x66696738,  0x43536448,  0x50480933,
  0x39439800,  0x99995428,  0x98348208,  0x88816349,  0x12883849,
  0x86160595,  0x91978618,  0x98736897,  0x49862335,  0x27167908,
  0x37244680,  0x20509154,  0x78933974,  0x66809467,  0x56357831,
  0x81769359,  0x43007719,  0x84844029,  0x40893951,  0x28607451,
  0x40754327,  0x38590847,  0x80016191,  0x12091312,  0x43863381,
  0x19122020,  0x65983651,  0x46562337,  0x50796566,  0x58302912,
  0x86442841,  0x15153383,  0x59223981,  0x92899911,  0x18299021,
  0x76436086,  0x18004300,  0x91152498,  0x73312843,  0x18179810,
  0x19705346,  0x41185803,  0x95317826,  0x83889185,  0x79021585,
  0x25809035,  0x70923979,  0x15883559,  0x54330348,  0x21751466,
  0x45812852,  0x85682270,  0x77658342,  0x29292862,  0x27050028,
  0x63649824,  0x84805019,  0x97898566,  0x97285382,  0x38685518,
  0x81640176,  0x26128203,  0x98912745,  0x50842431,  0x29918818,
  0x59808077,  0x23567727,  0x99113353,  0x37449940,  0x52115631,
  0x98456893,  0x97923160,  0x75078434,  0x33085200,  0x93862031,
  0x92868826,  0x10966949,  0x17056825,  0x45325574,  0x78820226,
  0x76430424,  0x42189278,  0x54621434,  0x45947261,  0x91077602,
  0x98914710,  0x24071053,  0x67772399,  0x74646441,  0x41502570,
  0x84686337,  0x83924035,  0x71220585,  0x24604166,  0x66206618,
  0x46312128,  0x13844653,  0x81291837,  0x82418183,  0x66447287,
  0x95429640,  0x55969466,  0x10972704,  0x46590615,  0x72562529,
  0x85910616,  0x11105056,  0x54551729,  0x71268338,  0x24868938,
  0x13125348,  0x85760789,  0x17753038,  0x69369586,  0x43771895,
  0x46384351,  0x28958170,  0x91486491,  0x61382463,  0x83532738,
  0x65391617,  0x38360331,  0x98277616,  0x55396287,  0x35252013,
  0x53410742,  0x26131485,  0x35284472,  0x67120468,  0x76431339,
  0x15977335,  0x55663154,  0x56865309,  0x17507797,  0x21282490,
  0x55462964,  0x15421202,  0x68692851,  0x30502339,  0x42208905,
  0x92041704,  0x35689361,  0x93939327,  0x15389680,  0x38661709,
  0x54346541,  0x78680662,  0x11655746,  0x81792925,  0x21915900,
  0x54248018,  0x71188007,  0x86291884,  0x22597711,  0x29758290,
  0x80505305,  0x76845098,  0x94449111,  0x71893198,  0x18276017,
  0x56177734,  0x41049540,  0x47423770,  0x95884773,  0x94019581,
  0x85779233,  0x27124323,  0x67112746,  0x32641826,  0x72114044,
  0x53060870,  0x70782077,  0x42947932,  0x46802985,  0x95629292,
  0x72513982,  0x52683071,  0x85039207,  0x70484224,  0x98918123,
  0x17446188,  0x49225428,  0x18391756,  0x96666667,  0x30498163,
  0x42563922,  0x53451747,  0x80956694,  0x81408897,  0x67717096,
  0x49451951,  0x52918471,  0x52454820,  0x31456112,  0x89960877,
  0x57315053,  0x85898414,  0x70960998,  0x17963152,  0x52439128,
  0x46750722,  0x98410926,  0x54823020,  0x95555927,  0x81049641,
  0x42968594,  0x84847020,  0x86339491,  0x35679945,  0x48575488,
  0x17661226,  0x54671317,  0x69540488,  0x85868225,  0x58095866,
  0x81303244,  0x39921181,  0x72698240,  0x54969992,  0x63458922,
  0x71913336,  0x55563533,  0x44047901,  0x61176559,  0x58597190,
  0x52276205,  0x35805623,  0x95229591,  0x94729962,  0x30930078,
  0x56794366,  0x56270239,  0x53862260,  0x96480095,  0x98549789,
  0x26393707,  0x23908631,  0x35655292,  0x67290303,  0x96443874,
  0x57304952,  0x55729911,  0x84530280,  0x64985191,  0x57576264,
  0x10671562,  0x86473664,  0x99567827,  0x42151908,  0x53210697,
  0x19973374,  0x94297788,  0x40676464,  0x46564061,  0x43826979,
  0x73131992,  0x19091801,  0x78056074,  0x77238290,  0x67342656,
  0x16455228,  0x29501560,  0x74820692,  0x86610557,  0x56184913,
  0x34894618,  0x79144197,  0x23233791,  0x41581808,  0x11540264,
  0x40973599,  0x74991225,  0x14977159,  0x36775380,  0x57479102,
  0x41336047,  0x93127691,  0x25722227,  0x79118708,  0x81356780,
  0x59514116,  0x93657167,  0x43807790,  0x35602775,  0x24767307,
  0x58861709,  0x97285922,  0x36584525,  0x98636620,  0x63159310,
  0x51247307,  0x81050823,  0x39753848,  0x11097678,  0x13906772,
  0x70340721,  0x80123527,  0x20607134,  0x48580254,  0x12405713,
  0x18721435,  0x70357650,  0x49011752,  0x58436315,  0x19922613,
  0x12704890,  0x43958424,  0x12889501,  0x49499693,  0x68468101,
  0x24817827,  0x67648773,  0x52193742,  0x84752265,  0x22165883,
  0x41791239,  0x53718628,  0x16416092,  0x96661173,  0x70447567,
  0x43288981,  0x50339468,  0x94965542,  0x59819917,  0x27442014,
  0x26009510,  0x20748540,  0x15814699,  0x81838593,  0x96356851,
  0x76070554,  0x78482991,  0x75592105,  0x19377665,  0x64036744,
  0x28699122,  0x78155526,  0x32840650,  0x13677443,  0x89637916,
  0x22158426,  0x92807118,  0x37933901,  0x13030645,  0x85026978,
  0x72540068,  0x92361723,  0x17530259,  0x37039140
};
#else
FLOAT Dither[DITHER_LENGTH] = {
  9.7607148e-001f,  8.8802242e-001f,  2.6577010e-001f,  7.2830083e-001f,  7.4557662e-001f,
  8.0745045e-001f,  8.4593113e-002f,  7.8265614e-001f,  7.1556441e-001f,  8.3341379e-001f,
  3.6030607e-001f,  9.4559055e-001f,  3.8197485e-001f,  9.7100034e-001f,  1.2308421e-001f,
  2.2535579e-001f,  2.2723188e-001f,  1.5934819e-001f,  7.9437052e-001f,  7.6216268e-002f,
  8.4277182e-001f,  2.4303903e-001f,  9.5559678e-001f,  8.5762244e-001f,  2.8075492e-001f,
  7.1061946e-001f,  3.4584071e-001f,  3.0182983e-001f,  3.7511702e-001f,  7.8086760e-001f,
  3.1128029e-002f,  3.3337902e-001f,  9.3008582e-002f,  1.3866352e-001f,  9.5423804e-002f,
  8.7911478e-001f,  5.2328720e-001f,  1.4893955e-001f,  5.4374102e-001f,  5.2763358e-001f,
  7.5637160e-001f,  6.4658006e-001f,  9.5686164e-001f,  2.7549469e-001f,  7.5854882e-001f,
  2.5050333e-001f,  1.2433981e-002f,  3.1849903e-001f,  5.7961230e-001f,  4.9809833e-001f,
  2.5444441e-001f,  4.1837551e-001f,  3.4178601e-001f,  1.8965704e-001f,  9.1970478e-001f,
  8.1985719e-001f,  3.2952180e-001f,  3.3292439e-001f,  9.7324106e-001f,  2.4361291e-001f,
  3.4634383e-001f,  2.0404594e-001f,  2.6788850e-001f,  8.5622742e-001f,  1.1582986e-001f,
  4.2435235e-001f,  9.9096700e-001f,  3.0978084e-002f,  9.0840333e-001f,  3.5032225e-001f,
  2.4343909e-001f,  1.5789398e-001f,  9.7161824e-002f,  1.8285150e-001f,  7.5227011e-002f,
  3.1320100e-002f,  8.7189446e-001f,  8.6442387e-001f,  3.0578470e-001f,  7.0623404e-001f,
  3.3354624e-001f,  9.7315616e-001f,  4.7388409e-001f,  5.2981236e-001f,  7.2295763e-001f,
  9.6608282e-001f,  6.8476917e-001f,  7.1378315e-001f,  6.7356973e-001f,  6.6079831e-001f,
  8.9957320e-001f,  8.5182872e-001f,  2.4144000e-001f,  1.4132635e-001f,  2.9084241e-001f,
  4.2497294e-001f,  4.1545920e-001f,  2.5129260e-001f,  5.8571020e-001f,  5.0004610e-001f,
  4.6823098e-001f,  2.9435594e-001f,  7.7598411e-001f,  8.1399102e-001f,  3.2061533e-001f,
  8.7753620e-001f,  8.8381911e-001f,  8.9078649e-001f,  3.6578263e-001f,  1.4134236e-001f,
  8.3925333e-001f,  8.8163688e-001f,  9.6095774e-001f,  2.7796221e-001f,  5.6959520e-002f,
  2.8024628e-001f,  6.9566411e-001f,  1.4962521e-001f,  9.8257203e-001f,  9.6963476e-001f,
  2.3701696e-001f,  5.2154279e-001f,  4.3928803e-001f,  4.8917033e-001f,  1.5934888e-001f,
  5.9283064e-001f,  7.3022728e-001f,  8.1671426e-001f,  2.7561822e-001f,  4.3285824e-001f,
  4.7957834e-002f,  4.3275472e-001f,  2.8629072e-001f,  3.7805488e-001f,  8.3645857e-001f,
  4.5419704e-003f,  1.1695641e-001f,  2.9363360e-002f,  5.6999535e-001f,  1.0347663e-001f,
  8.2193115e-001f,  4.0880100e-001f,  6.8790521e-001f,  9.5578515e-001f,  2.7113504e-001f,
  2.6483464e-001f,  9.9074283e-002f,  9.4079495e-001f,  1.9878194e-001f,  6.6077379e-001f,
  4.4103864e-001f,  9.3291022e-001f,  2.1547004e-002f,  9.9066759e-001f,  7.6158444e-001f,
  3.5844020e-001f,  5.4282568e-001f,  2.8194381e-001f,  6.3980115e-001f,  3.2223133e-001f,
  9.6172670e-001f,  5.6286233e-001f,  4.8030528e-001f,  6.3399984e-001f,  2.3932267e-003f,
  1.0568868e-001f,  9.9615669e-001f,  2.5502835e-001f,  3.4288738e-001f,  6.1094535e-001f,
  1.9956509e-001f,  1.0131644e-001f,  4.3512696e-001f,  6.4409236e-001f,  6.7879202e-001f,
  7.0911777e-001f,  2.5461827e-001f,  5.3287932e-001f,  7.1788571e-001f,  4.3357027e-001f,
  2.7933551e-001f,  9.3491471e-001f,  6.7737436e-001f,  3.3238512e-001f,  1.2558402e-003f,
  9.8981004e-002f,  3.4477313e-001f,  9.0305386e-001f,  9.7856412e-001f,  4.7483320e-001f,
  1.9442109e-001f,  2.7327416e-001f,  4.4818868e-001f,  7.9299831e-001f,  4.4413140e-001f,
  9.2247673e-001f,  3.4116637e-001f,  7.3563600e-001f,  2.1837990e-001f,  3.2956492e-001f,
  7.9242407e-001f,  8.2845592e-001f,  5.2116046e-001f,  9.9028305e-001f,  6.6529372e-001f,
  8.3018495e-001f,  3.9358082e-002f,  4.1491716e-001f,  9.8805087e-001f,  9.2457293e-001f,
  6.3790634e-001f,  4.1788816e-001f,  9.7164638e-001f,  3.3557250e-001f,  5.8964831e-001f,
  3.5101286e-001f,  4.2696088e-001f,  8.2029735e-001f,  6.8500044e-001f,  2.7739917e-002f,
  7.6818846e-001f,  5.2474762e-001f,  4.2252471e-002f,  7.6944760e-001f,  5.5090141e-001f,
  3.5059412e-001f,  3.7102037e-001f,  9.3558220e-001f,  7.9803162e-001f,  4.0913115e-001f,
  5.1082370e-001f,  4.7551270e-001f,  9.5644944e-001f,  3.0350637e-001f,  5.5178802e-001f,
  3.9436788e-001f,  9.6482748e-001f,  4.6895094e-001f,  1.6289649e-002f,  5.1046467e-002f,
  6.4037110e-002f,  4.6964184e-001f,  3.5309790e-001f,  8.0340875e-002f,  2.3091948e-001f,
  7.1128403e-001f,  7.9954082e-001f,  3.6392145e-001f,  4.6113752e-001f,  4.9707956e-001f,
  3.4653566e-002f,  4.5363008e-001f,  9.4199486e-001f,  9.3955167e-002f,  8.2628835e-001f,
  7.2202569e-001f,  7.1038958e-001f,  7.4144891e-002f,  1.8269859e-001f,  3.5963774e-001f,
  7.1298712e-001f,  9.1537835e-001f,  6.3137485e-001f,  9.2996973e-001f,  7.1778978e-001f,
  8.9724595e-002f,  9.1171931e-001f,  2.8639264e-001f,  3.3309183e-001f,  6.3547374e-001f,
  1.8726381e-001f,  4.4735938e-001f,  4.7511205e-002f,  1.9988380e-003f,  2.6316922e-001f,
  1.4683136e-001f,  1.9749139e-001f,  3.6285712e-002f,  1.8955700e-001f,  8.4323730e-001f,
  4.7465796e-001f,  4.4723664e-001f,  5.8997654e-001f,  3.3346203e-001f,  8.8041670e-001f,
  8.7124286e-001f,  7.8500813e-001f,  4.5025258e-001f,  6.3069629e-001f,  4.5325314e-001f,
  6.6829165e-001f,  4.5463159e-002f,  2.4150662e-001f,  9.3922405e-001f,  3.0927937e-001f,
  7.2904092e-001f,  1.1331287e-001f,  5.9165860e-001f,  7.6820905e-001f,  4.8483077e-001f,
  9.7361437e-001f,  6.5412401e-001f,  6.9241889e-001f,  7.1563578e-001f,  2.3953636e-001f,
  6.3068271e-001f,  5.7292244e-001f,  9.2020916e-001f,  8.7128511e-001f,  7.4846789e-001f,
  2.9444009e-001f,  2.5893852e-001f,  5.6394350e-001f,  7.2942257e-001f,  2.4390006e-001f,
  1.7770358e-001f,  6.3460260e-001f,  7.5987973e-001f,  6.4188966e-001f,  4.3057902e-001f,
  5.4338162e-002f,  9.7802540e-001f,  2.7397702e-001f,  3.7068400e-001f,  4.6249947e-001f,
  3.2306081e-001f,  7.0617479e-001f,  6.1647959e-001f,  3.8810599e-002f,  4.9492222e-001f,
  7.5242009e-001f,  1.4215033e-001f,  8.0131149e-001f,  5.1993779e-001f,  5.0479560e-001f,
  5.0701936e-001f,  2.5226850e-001f,  5.0798672e-001f,  3.6862637e-001f,  7.8382841e-001f,
  1.4995185e-001f,  2.4699721e-001f,  9.4509075e-001f,  3.8782332e-001f,  7.6567755e-001f,
  4.2031411e-001f,  4.6087513e-001f,  3.2916273e-001f,  6.2843117e-001f,  9.6612198e-001f,
  7.1767473e-002f,  3.0237418e-001f,  6.7216399e-001f,  4.3152062e-001f,  1.3376039e-001f,
  2.9241139e-001f,  3.1955321e-001f,  4.3131264e-001f,  2.0327523e-002f,  5.3284412e-001f,
  5.2829154e-001f,  5.4742679e-001f,  5.7514336e-001f,  1.1170352e-001f,  6.6459233e-001f,
  8.4072243e-001f,  7.2123010e-001f,  2.2585944e-001f,  3.9040124e-001f,  6.9127011e-001f,
  6.4027861e-001f,  1.4742222e-001f,  4.5750488e-001f,  7.7381