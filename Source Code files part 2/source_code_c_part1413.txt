ct",
                 NULL
                 ));

    _ResponseHeaders.FreeHeaders();
    FreeResponseBuffer();
    ResetResponseVariables();
    _ResponseHeaders.Initialize();
    SetState(HttpRequestStateOpen);
    ResetEndOfFile();
    _ResponseFilterList.ClearList();
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _dwQuerySetCookieHeader = 0;
    if (m_pSecurityInfo) {
        m_pSecurityInfo->Release();
    }
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ResetObject(
    IN BOOL bForce,
    IN BOOL bFreeRequestHeaders
    )

/*++

Routine Description:

    This method is called when we we are clearing out a partially completed
    transaction, mainly for when we have determined that an if-modified-since
    request, or a response that has not invalidated the cache entry can be
    retrieved from cache (this is a speed issue)

    Abort the connection and clear out the response headers and response
    buffer; clear the response variables (all done by AbortConnection()).

    If bFreeRequestHeaders, clear out the request headers.

    Reinitialize the response headers. We do not reset the object state, but we
    do reset the end-of-file status

Arguments:

    bForce              - TRUE if connection is forced closed

    bFreeRequestHeaders - TRUE if request headers should be freed

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResetObject",
                 "%B, %B",
                 bForce,
                 bFreeRequestHeaders
                 ));

    DWORD error;

    error = AbortConnection(bForce);
    if (error == ERROR_SUCCESS) {
        if (bFreeRequestHeaders) {
            _RequestHeaders.FreeHeaders();
        }
        _ResponseHeaders.Initialize();
        ResetEndOfFile();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    SetAuthenticated    -

Return Value:

    None.

--*/

{
    if (!_Socket)
    {
        INET_ASSERT(FALSE);
    }
    else
    {
        _Socket->SetAuthenticated();
    }
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    IsAuthenticated -

Return Value:

    BOOL

--*/

{
    return (_Socket ? _Socket->IsAuthenticated() : FALSE);
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::SetObjectName(
    LPSTR lpszObjectName,
    LPSTR lpszExtension,
    URLGEN_FUNC * procProtocolUrl
    )
{
    DWORD   dwLen, dwError;
    INTERNET_SCHEME schemeType;

    //
    // if there is already an object name, then free it. We are replacing it
    //

    //
    // BUGBUG - make _CacheUrlString an ICSTRING
    //

    FreeURL();

    //
    // get protocol specific url
    //

    if (procProtocolUrl) {

        //
        // if we are going via proxy AND this is an FTP object AND the user name
        // consists of <username>@<servername> then <servername> is the real
        // server name, and _HostName is the name of the proxy
        //

        //
        // BUGBUG - this is a bit of a hack(!)
        //
        // Note: FTP support has been removed (ssulzer, 3/2000).
        //

        LPSTR target = _HostName.StringAddress();

        schemeType = GetSchemeType();

        // make the scheme type https if necessary

        schemeType = (((schemeType == INTERNET_SCHEME_DEFAULT)||
                      (schemeType == INTERNET_SCHEME_HTTP)) &&
                      (GetOpenFlags() & WINHTTP_FLAG_SECURE))?
                      INTERNET_SCHEME_HTTPS: schemeType;

        LPSTR lpszNewUrl = NULL;

        dwError = (*procProtocolUrl)(schemeType,
                                     target,
                                     NULL,
                                     lpszObjectName,
                                     lpszExtension,
                                     _HostPort,
                                     &lpszNewUrl,
                                     &dwLen
                                     );

        if (dwError == ERROR_SUCCESS) {

            if (!SetURLPtr (&lpszNewUrl)) {
                FREE_MEMORY (lpszNewUrl);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {

        DEBUG_PRINT(HANDLE,
                    INFO,
                    ("Url: %s\n",
                    _CacheUrlName
                    ));

    }
    return dwError;
}


//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::GetUserAndPass
    (BOOL fProxy, LPSTR *pszUser, LPSTR *pszPass)
{
    DWORD dwUser, dwPass;
    
    if (fProxy)
    {
        dwUser = WINHTTP_OPTION_PROXY_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK;
    }
    else
    {
        dwUser = WINHTTP_OPTION_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PASSWORD & WINHTTP_OPTION_MASK;
    }
    
    *pszUser = _xsProp[dwUser].GetPtr();
    *pszPass = _xsProp[dwPass].GetPtr();
    if (*pszUser && *pszPass)
        return TRUE;
    else        
    {
        *pszUser = NULL;
        *pszPass = NULL;
        return FALSE;
    }
}

//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURL (LPSTR lpszUrl)
{
    LPSTR lpszNew;

    // Make an undecorated copy of the URL.

    lpszNew = NewString(lpszUrl);
    if (!lpszNew)
        return FALSE;

    // Clear any previous cache key and record the new one.
    FreeURL();
    INET_ASSERT (lpszNew);
    _CacheUrlName = lpszNew;
    return TRUE;
}

//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURLPtr(LPSTR* ppszUrl)
{
    // Swap in the new URL as the cache key.
    FreeURL();
    _CacheUrlName = *ppszUrl;
    *ppszUrl = NULL;
    return TRUE;
}

//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfoWithScheme(
    IN INTERNET_SCHEME tScheme,
    IN BOOL bDoResolution,
    IN OPTIONAL BOOL fNtlm
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name for which this object was created and an optional scheme
    type

Arguments:

    tScheme         - scheme type we want SERVER_INFO for

    bDoResolution   - TRUE if we are to resolve the host name if creating a new
                      SERVER_INFO object

    fNtlm           - TRUE if we are tunnelling for NTLM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%s (%d), %B, %B",
                 InternetMapScheme(tScheme),
                 tScheme,
                 bDoResolution,
                 fNtlm
                 ));


    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

//dprintf("getting server info for %q (current = %q)\n", hostName, GetHostName());

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);

    DWORD error = lpParent->GetServerInfo(GetHostName(),
                                INTERNET_SERVICE_HTTP,
                                bDoResolution,
                                &_ServerInfo
                                );
    DEBUG_LEAVE(error);

    return error;
}


//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfo(
    IN LPSTR lpszServerName,
    IN DWORD dwServerNameLength
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name in the parameters

Arguments:

    lpszServerName      - name of server

    dwServerNameLength  - length of lpszServerName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%q, %d",
                 lpszServerName,
                 dwServerNameLength
                 ));

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    int copyLength = (int)min(sizeof(hostName) - 1, dwServerNameLength);

    memcpy(hostName, lpszServerName, copyLength);
    hostName[copyLength] = '\0';

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);
    DWORD error = lpParent->GetServerInfo(hostName,
                                INTERNET_SERVICE_HTTP,
                                FALSE,
                                &_ServerInfo
                                );

    DEBUG_LEAVE(error);

    return error;
}

//=============================================================================
VOID HTTP_REQUEST_HANDLE_OBJECT::SetOriginServer(
    IN CServerInfo * pServerInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pServerInfo -

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer",
                 "%#x{%q}",
                 pServerInfo,
                 pServerInfo ? pServerInfo->GetHostName() : ""
                 ));

    if (_OriginServer == NULL) {
        _OriginServer = pServerInfo;
        if (pServerInfo != NULL) {
            pServerInfo->Reference();
        }
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ScheduleWorkItem()
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ScheduleWorkItem",
                 NULL
                 ));

    CFsm *pFsm = NULL;
    DWORD dwError = ERROR_SUCCESS;
        
    _FsmWorkItemList.DequeueHead(&pFsm);
    if (pFsm)
    {
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("Queueing work item %#x with %d blocked async work items remaining\n",
                    pFsm,
                    _FsmWorkItemList.GetCount()
                    ));

        pFsm->SetThreadInfo(InternetGetThreadInfo());
        pFsm->SetPushPop(TRUE);
        pFsm->Push();
        dwError = pFsm->QueueWorkItem();
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\chunkflt.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    chunkflt.cxx

Abstract:

    Contains a filter for encoding and decoding chunked transfers.

    Contents:
        FILTER_LIST::Insert
        FILTER_LIST::RemoveAll
        FILTER_LIST::Decode
        ChunkFilter::Reset
        ChunkFilter::Decode
        ChunkFilter::Encode
        ChunkFilter::RegisterContext
        ChunkFilter::UnregisterContext

Revision History:

    Created 13-Feb-2001

--*/

#include <wininetp.h>

// Global lookup table to map 0x0 - 0x7f bytes for obtaining mapping to its
// token value.  All values above 0x7f are considered to be data.
const BYTE g_bChunkTokenTable[] =
{
    /* 0x00 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_LF,    CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_CR,    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x10 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x20 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x30 */
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_COLON, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x40 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x50 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x60 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x70 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA
};

// Look-up table to map a token in a given state to the next state
const CHUNK_DECODE_STATE g_eMapChunkTokenToNextState[CHUNK_DECODE_STATE_LAST+1][CHUNK_TOKEN_LAST+1] =
{
/*
    |---------DIGIT----------|-------------CR-------------|-------------LF------------|----------COLON----------|-----------DATA----------|
*/
    // CHUNK_DECODE_STATE_START
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,     CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,

    // CHUNK_DECODE_STATE_SIZE
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_SIZE_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_DATA,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_EXT
    CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_DATA
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_DATA,  CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_DATA_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FOOTER_NAME
    CHUNK_DECODE_STATE_FOOTER_NAME, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FOOTER_NAME,
    
    // CHUNK_DECODE_STATE_FOOTER_VALUE
    CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE,
    
    // CHUNK_DECODE_STATE_FINAL_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_FINISHED, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_ERROR
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FINISHED -- force client to reset before reuse
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR
};

// Helper macros

// Where to next?
#define MAP_CHUNK_TOKEN_TO_NEXT_STATE(eCurState, chToken) \
    (g_eMapChunkTokenToNextState[(eCurState)][(chToken)])
    
// Given a byte, what does it represent w/regards to chunked responses
#define GET_CHUNK_TOKEN(ch)  ((ch) & 0x80 ? CHUNK_TOKEN_DATA : g_bChunkTokenTable[ch])

// Should only be used with digit tokens.
// Expects byte in range 0x30-0x39 (digits), 0x41-0x46 (uppercase hex),
// or 0x61-0x66 (lowercase hex)
#define GET_VALUE_FROM_ASCII_HEX(ch)  ((ch) - ((ch) & 0xf0) + (((ch) & 0x40) ? 9 : 0))


HRESULT ChunkFilter::Reset(DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Reset",
                 "%#x",
                 dwContext
                 ));
   
    if (dwContext)
        (reinterpret_cast<ChunkDecodeContext *>(dwContext))->Reset();

    DEBUG_LEAVE(TRUE);

    return S_OK;
}

HRESULT
ChunkFilter::Decode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Decode downloaded chunked data based on the inputted context and
    its current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        Success - S_OK

        Failure - E_FAIL

--*/
{
    HRESULT hResult = S_OK;
    LPBYTE pCurrentLoc = pInBuffer;
    LPBYTE pStartOfChunk = pInBuffer;
    ChunkDecodeContext * pCtx = reinterpret_cast<ChunkDecodeContext *>(dwContext);
    CHUNK_DECODE_STATE ePreviousState; 
    BYTE chToken;

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Decode",
                 "%x, [%x, %.10q], %u, %x, %u, %x, %x",
                 dwContext,
                 pInBuffer,
                 *pInBuffer,
                 dwInBufSize,
                 ppOutBuffer,
                 pdwOutBufSize,
                 pdwBytesRead,
                 pdwBytesWritten
                 ));

    if (!dwContext)
    {
        hResult = E_INVALIDARG;
        goto quit;
    }
    else if (!pdwBytesRead || !pdwBytesWritten || !pInBuffer ||
        (ppOutBuffer && !pdwOutBufSize))
    {
        hResult = E_POINTER;
        goto quit;
    }

    *pdwBytesRead  = 0;
    *pdwBytesWritten = 0;
    
    while (*pdwBytesRead < dwInBufSize &&
           pCtx->GetState() != CHUNK_DECODE_STATE_ERROR)
    {
        chToken = GET_CHUNK_TOKEN(*pCurrentLoc);
        ePreviousState = pCtx->GetState();

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode: %q, %q, %u/%u\n",
                    InternetMapChunkState(ePreviousState),
                    InternetMapChunkToken((CHUNK_TOKEN_VALUE)chToken),
                    *pdwBytesRead,
                    dwInBufSize
                    ));
        
        INET_ASSERT(pCurrentLoc < pInBuffer + dwInBufSize);

        switch (pCtx->GetState())
        {
            case CHUNK_DECODE_STATE_START:
                pCtx->Reset();
                pCtx->SetState(CHUNK_DECODE_STATE_SIZE);

                // fall through
                    
            case CHUNK_DECODE_STATE_SIZE:
            {
                if (chToken == CHUNK_TOKEN_DIGIT)
                {
                    if (pCtx->m_dwParsedSize & 0xF0000000)
                    {
                        // Don't allow overflow if by some chance
                        // the server is trying to send a chunk over
                        // 4 gigs worth in size.
                        pCtx->SetState(CHUNK_DECODE_STATE_ERROR);
                        break;
                    }
                            
                    pCtx->m_dwParsedSize <<= 4;
                    pCtx->m_dwParsedSize  += GET_VALUE_FROM_ASCII_HEX(*pCurrentLoc);
                }
                else
                {
                    pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                            CHUNK_DECODE_STATE_SIZE,
                            chToken));
                }
                break;
            }
            case CHUNK_DECODE_STATE_SIZE_CRLF:
                // Handle the zero case which can take us to the footer or final CRLF
                // If it's the final CRLF, then this should be the end of the data.
                if (pCtx->m_dwParsedSize == 0 && chToken == CHUNK_TOKEN_LF)
                {
                    pCtx->SetState(CHUNK_DECODE_STATE_FOOTER_NAME);
                }
                else
                {
                    pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                            CHUNK_DECODE_STATE_SIZE_CRLF,
                            chToken));
                }
                break;
            case CHUNK_DECODE_STATE_DATA:
            {
                INET_ASSERT(pCtx->m_dwParsedSize);
                    
                // account for EOB
                if (pCurrentLoc + pCtx->m_dwParsedSize < pInBuffer + dwInBufSize)
                {
                    const DWORD dwParsedSize = pCtx->m_dwParsedSize;

                    // Move or skip the parsed size and crlf, if needed.
                    // The start of the chunk could be equal this time if
                    // spread across multiple decode calls.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwParsedSize);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.
                    pCurrentLoc += dwParsedSize - 1;
                    *pdwBytesRead += dwParsedSize - 1;
                    *pdwBytesWritten += dwParsedSize;
                    pStartOfChunk += dwParsedSize;
                    pCtx->m_dwParsedSize = 0;

                    // Should be CRLF terminated
                    pCtx->SetState(CHUNK_DECODE_STATE_DATA_CRLF);
                }
                else 
                {
                    const DWORD dwSlice = dwInBufSize - (DWORD)(pCurrentLoc - pInBuffer);

                    // We're reaching the end of the buffer before
                    // the end of the chunk.  Update the parsed
                    // size remaining, so it will be carried over
                    // to the next call.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        // Skip over preceding size info.
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwSlice);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.  Offset should never be bigger than DWORD since
                    // since that's the biggest chunk we can handle.
                    *pdwBytesWritten += dwSlice;
                    pCtx->m_dwParsedSize -= dwSlice;
                    *pdwBytesRead += dwSlice - 1;
                    pCurrentLoc = pInBuffer + dwInBufSize - 1;
                }
                break;
            }
            
            // All remaining states simply parse over the value and
            // change state, depending on the token.
            default:
            {
                pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                        ePreviousState,
                        chToken));
                break;
            }
        }
        (*pdwBytesRead)++;
        pCurrentLoc++;
    }

    if (pCtx->GetState() == CHUNK_DECODE_STATE_ERROR)
    {
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode entered error state\n"
                    ));
        hResult = E_FAIL;
    }
    
quit:
    DEBUG_LEAVE(hResult == S_OK ? TRUE : FALSE);
    
    return hResult;
}

HRESULT
ChunkFilter::Encode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Chunk data for uploading based on the inputted context and current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        E_NOTIMPL - currently no chunked upload support

--*/
{
    // We don't support chunked uploads...yet
    return E_NOTIMPL;
}


HRESULT
ChunkFilter::RegisterContext(OUT DWORD_PTR *pdwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::RegisterContext",
                 "%#x",
                 pdwContext
                 ));

    HRESULT hr = S_OK;

    if (!pdwContext || IsBadWritePtr(pdwContext, sizeof(DWORD_PTR)))
    {
        hr = E_POINTER;
        goto quit;
    }

    *pdwContext = (DWORD_PTR) New ChunkDecodeContext;

    if (!*pdwContext)
    {
        hr = E_OUTOFMEMORY;
    }

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);

    return hr;
}

HRESULT
ChunkFilter::UnregisterContext(IN DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::UnregisterContext",
                 "%#x",
                 dwContext
                 ));

    HRESULT hr = S_OK;
    
    if (!dwContext)
    {
        hr = E_INVALIDARG;
        goto quit;
    }
    
    delete reinterpret_cast<ChunkDecodeContext *>(dwContext);

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);
    return hr;
}


// Always inserts as the beginning of the list
BOOL
FILTER_LIST::Insert(IN BaseFilter *pFilter, IN DWORD_PTR dwContext)
{
    LPFILTER_LIST_ENTRY pNewEntry;
    pNewEntry = New FILTER_LIST_ENTRY;
        
    if (pNewEntry != NULL)
    {
        pNewEntry->pFilter = pFilter;
        pNewEntry->dwContext = dwContext;
        pNewEntry->pNext = _pFilterEntry;
        _pFilterEntry = pNewEntry;
        _uFilterCount++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


VOID
FILTER_LIST::ClearList()
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    while (pEntry)
    {
        pEntry->pFilter->UnregisterContext(pEntry->dwContext);
        pEntry = pEntry->pNext;
        delete _pFilterEntry;
        _pFilterEntry = pEntry;
    }
    _uFilterCount = 0;
}


DWORD
FILTER_LIST::Decode(
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    HRESULT hr = S_OK;
    DWORD dwBytesRead = 0;
    DWORD dwBytesWritten = 0;
    LPBYTE pLocalInBuffer = pInBuffer;
    DWORD dwLocalInBufSize = dwInBufSize;

    *pdwBytesRead = 0;
    *pdwBytesWritten = 0;
      
    // Loop through filters which should be in the proper order
    while (pEntry)
    {
        dwBytesRead = 0;
        dwBytesWritten = 0;
        // At a minimum, we're guaranteed the decode method parses
        // the input buffer until one of the following is met:
        //
        // - Input buffer is fully parsed and processed
        // - Output buffer is filled up
        // - Decoder reaches a finished state
        // - Error occurs while processing input data
        //
        // Currently, only 1, 3, and 4 are possible since chunked
        // transfers are decoded in place.  We also don't need
        // to loop since chunked decoding is always fully done
        // in the first pass.
        do
        {
            pLocalInBuffer = pLocalInBuffer + dwBytesRead;
            dwLocalInBufSize = dwLocalInBufSize - dwBytesRead;
            dwBytesWritten = 0;
            dwBytesRead = 0;
            hr =  pEntry->pFilter->Decode(pEntry->dwContext,
                                          pLocalInBuffer,
                                          dwLocalInBufSize,
                                          ppOutBuffer,
                                          pdwOutBufSize,
                                          &dwBytesRead,
                                          &dwBytesWritten
                                          );

            *pdwBytesWritten += dwBytesWritten;
            *pdwBytesRead += dwBytesRead;
              
            if (hr == S_OK && dwBytesRead < dwLocalInBufSize)
            {
                // Given the current requirements we shouldn't be here
                // if there's still input buffer data to process.
                RIP(FALSE);
                hr = E_FAIL;
                goto quit;
            }
        } while  (hr == S_OK &&
                  dwLocalInBufSize > 0 &&
                  dwBytesRead < dwLocalInBufSize);
        pEntry = pEntry->pNext;
    }
    INET_ASSERT(hr != S_OK || dwBytesRead == dwLocalInBufSize);
quit:
    switch (hr)
    {
        case S_OK:
            return ERROR_SUCCESS;

        case E_OUTOFMEMORY:
            return ERROR_NOT_ENOUGH_MEMORY;

        default:
            return ERROR_WINHTTP_INTERNAL_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\add.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    add.cxx

Abstract:

    This file contains the implementation of the HttpAddRequestHeadersA API.

    The following functions are exported by this module:

        HttpAddRequestHeadersA
        WinHttpAddRequestHeaders

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpAddRequestHeadersA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private manifests
//

#define VALID_ADD_FLAGS (HTTP_ADDREQ_FLAG_ADD_IF_NEW \
                        | HTTP_ADDREQ_FLAG_ADD \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA \
                        | HTTP_ADDREQ_FLAG_REPLACE \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON \
                        )

//
// functions
//


INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle

Arguments:

    hRequest        - An open HTTP request handle returned by HttpOpenRequest()

    lpszHeaders     - The headers to append to the request. Each header must be
                      terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is -1L
                      then lpszHeaders is assumed to be zero terminated (ASCIIZ)

    dwModifiers     - flags controlling operation. Can be one or more of:

                        HTTP_ADDREQ_FLAG_ADD_IF_NEW
                            - add the header, but only if it does not already
                              exist. Index must be zero

                        HTTP_ADDREQ_FLAG_ADD
                            - if HTTP_ADDREQ_FLAG_REPLACE is set, but the header
                              is not found and this flag is set then the header
                              is added, so long as there is a valid header-value

                        HTTP_ADDREQ_FLAG_COALESCE
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
                            - concatenate headers of same name. E.g. if we
                              already have "Accept: text/html" then adding
                              "Accept: text/*" will create
                              "Accept: text/html, text/*"

                        HTTP_ADDREQ_FLAG_REPLACE
                            - replaces the named header. Only one header can be
                              supplied. If header-value is empty then the header
                              is removed

Return Value:

    Success - TRUE
                The header was appended successfully

    Failure - FALSE
                The operation failed. Error status is available by calling
                GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersA",
                     "%#x, %.80q, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD error;
    HINTERNET hRequestMapped = NULL;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    INET_ASSERT(!(
    (lpszHeaders == NULL)
    || (*lpszHeaders == '\0')
    || (dwHeadersLength == 0)
    || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS))) );

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // BUGBUG - we should determine whether the app is trying to give us a bogus
    //          header, and whether the header conforms to the format:
    //
    //                          "<header>[:[ <value>]]"
    //

    if (dwHeadersLength == (DWORD)-1) 
    {
        dwHeadersLength = (DWORD)lstrlen(lpszHeaders);
    }
        
    if (error == ERROR_SUCCESS) {
        error = wHttpAddRequestHeaders(hRequestMapped,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwModifiers
                                       );
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return error == ERROR_SUCCESS;
}


INTERNETAPI
BOOL
WINAPI
WinHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    lpszHeaders - The headers to append to the request. Each header must be
        terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is
        -1L, then lpszHeaders is assumed to be zero terminated (ASCIIZ).

    dwModifiers     -

Return Value:

    TRUE - The header was appended successfully.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpAddRequestHeaders",
                     "%#x, %.80wq, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!lpszHeaders 
        || *lpszHeaders==L'\0' 
        || !dwHeadersLength
        || ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, -1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        MEMORYPACKET mpHeaders;
        ALLOC_MB(lpszHeaders, (dwHeadersLength==-1L ? 0 : dwHeadersLength), mpHeaders);
        if (mpHeaders.psStr)
        {
            UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
            fResult = HttpAddRequestHeadersA(hRequest, mpHeaders.psStr, mpHeaders.dwSize, dwModifiers);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Worker function to append additional header(s) to an HTTP request handle

Arguents:

    hRequest        - handle of HTTP request

    lpszHeaders     - pointer to buffer containing one or more headers

    dwHeadersLength - length of lpszHeaders. Cannot be -1 at this stage

    dwModifiers     - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The header string(s) was bad after all

                  ERROR_WINHTTP_INCORRECT_HANDLE_STATE
                    We can't add headers to this object at this time

                  ERROR_HTTP_HEADER_NOT_FOUND
                    We were asked to replace a header, but couldn't find it

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    We were asked to add a header, only if one of the same name
                    doesn't already exist. It does

--*/

{
    //
    // dwHeadersLength cannot be -1 or 0 at this stage. Nor can lpszHeaders be
    // NULL
    //

    INET_ASSERT(lpszHeaders != NULL);
    INET_ASSERT(dwHeadersLength != (DWORD)-1);
    INET_ASSERT(dwHeadersLength != 0);

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "wHttpAddRequestHeaders",
                 "%#x, %#x [%.80q], %d, %#x",
                 hRequest,
                 lpszHeaders,
                 lpszHeaders,
                 dwHeadersLength,
                 dwModifiers
                 ));

    //
    // get the underlying object and check that we can add headers
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    DWORD error;

    if (!IS_VALID_HTTP_STATE(pRequest, ADD, TRUE)) {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    DWORD offset;
    LPSTR header;

    offset = 0;
    header = (LPSTR)lpszHeaders;

    do {

        //
        // first time: ignore any empty strings; subsequent time: clean off any
        // trailing line termination
        //

        while ((offset < dwHeadersLength)
        && ((lpszHeaders[offset] == '\r') || (lpszHeaders[offset] == '\n'))) {
            ++offset;
        }
        if (offset == dwHeadersLength) {

            //
            // even if app tried adding empty line(s), we return success
            //

            error = ERROR_SUCCESS;
            break;
        }

        DWORD length;
        DWORD nameLength;
        DWORD valueLength;
        LPSTR value;
        BOOL done;

        nameLength = 0;
        valueLength = 0;
        value = NULL;

        //
        // break the header into header-name, header-value pairs. Exclude CR-LF
        // from the header-value (if present)
        //

        for (length = 0, header = (LPSTR)&lpszHeaders[offset];
            offset < dwHeadersLength;
            ++length, ++offset) {

            char ch = header[length];

            if ((ch == '\r') || (ch == '\n')) {

                //
                // end of this particular header
                //

                break;
            } else if (ch == ':') {
                if (nameLength == 0) {

                    //
                    // found end of header name
                    //

                    nameLength = length;
                    value = &header[length];
                }
            }
        }
        if (length == 0) {

            //
            // empty string
            //

            continue;
        } else if (nameLength == 0) {

            //
            // entry consists of just header-name (e.g. "Accept[\r\n]")
            //

            nameLength = length;
        } else {

            //
            // find the start of the header-value
            //

            valueLength = (DWORD) (header + length - value);

            //
            // N.B. We are allowing any mixture of ':' and ' ' between header
            // name and value, but this is probably not a big deal...
            //

            while ((*value == ':') || (*value == ' ') && (valueLength != 0)) {
                ++value;
                --valueLength;
            }
        }
        if (dwModifiers
            & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW)) {

            //
            // replace or remove the header
            //

            error = pRequest->ReplaceRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else if (valueLength != 0) {

            //
            // add a single, unterminated header string to the request headers.
            // Since these headers came from the app, we don't trust it to get
            // the header termination right (number & type of line terminators)
            // so we add it ourselves
            //

            error = pRequest->AddRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else {

            //
            // BUGBUG - we are adding headers, but the header-value is not
            //          present. This is a somewhat tricky situation because we
            //          we may have already added some headers, resulting in
            //          the app not really knowing which headers were good and
            //          which failed; additionally, one or more of the headers
            //          may have been added, increasing the apps confusion. The
            //          best way to handle this (if necessary) is to check the
            //          header name/value pairs w.r.t. the dwModifiers flags.
            //          HOWEVER, even then we can get into a state down here
            //          where we add a couple of headers, then fail...
            //

            error = ERROR_INVALID_PARAMETER;
        }
    } while (error == ERROR_SUCCESS);

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\cookie.cxx ===
//---------------------------------------------------------------------------
//
// COOKIE.CXX
//
//     Cookie Jar
//
//     This file implements cookies as defined by Navigator 4 behavior and the
//     specification at http://www.netscape.com/newsref/std/cookie_spec.html.
//     If Navigator 4 and the specification are not in agreement, we try to
//     match the Navigator 4 behavior.
//
//     The following describes some interesting aspects of cookie behavior.
//
// SYNTAX
//
//    Syntax for cookie is
//
//          [[name]=] value [; options]
//
//    The name is everything before "=" with leading and  trailing whitespace
//    removed.  The value is everything after "=" and before ";" with leading
//    and trailing whitespace removed.  The name and value can contain spaces,
//    quotes or any other character except ";" and "=".  The name and equal
//    sign are optional.
//
//    Example:  =foo  ->  name: <blank> value: foo
//              foo   ->  name: <blank> value: foo
//              foo=  ->  name: foo     value: <blank>
//              ;     ->  name: <blank> value: <blank>
//
// ORDER
//
//    Cookies with a more specific path are sent before cookies with
//    a less specific path mapping.  The domain does not contibute
//    to the ordering of cookies.
//
//    If the path length of two cookies are equal, then the cookies
//    are ordered by time of creation.  Navigator maintains this
//    ordering across domain and path boundaries.  IE maintains this
//    ordering for a specific domain and path. It is difficult to match
//    the Navigator behavior and there are no known bugs because of
//    this difference.
//
// MATCHING
//
//    Path matches are done at the character level.  Any
//    directory structure in the path is ignored.
//
//    Navigator matches domains at the character level and ignores
//    the structure of the domain name.
//
//    Previous versions of IE tossed the leading "." on a domain name.
//    With out this information, character by character compares are
//    can produce incorrect results.  For backwards compatibilty with
//    old cookie we continue to match on a component by component basis.
//
//    Some examples of the difference are:
//
//       Cookie domain   Document domain  Navigator match  IE match
//       .foo.com        foo.com          no               yes
//       bar.x.com       foobar.x.com     yes              no
//
// ACCEPTING COOKIES
//
//    A cookie is rejected if the path specified in the set cookie
//    header is not a prefix of document's path.
//
//    Navigator rejects a cookie if the domain specified in the
//    set cookie header does not contain at least two periods
//    or the domain is not a suffix of the document's domain.
//    The suffix match is done on a character by character basis.
//
//    Navigator ignores all the stuff in the specification about
//    three period matching and the seven special top level domains.
//
//    IE rejects a cookie if the domain specified by the cookie
//    header does not contain at least one embedded period or the
//    domain is not a suffix of the documents domain.
//
//    Cookies are accepted if the path specified in the set cookie
//    header is a prefix of the document's path and the domain
//    specified in the set cookie header.
//
//    The difference in behavior is a result of the matching rules
//    described in the previous section.
//
//---------------------------------------------------------------------------

#include <wininetp.h>
#include "httpp.h"

#include "cookiejar.h"

#define CCH_COOKIE_MAX  (5 * 1024)

static char s_achEmpty[] = "";

// Hard-coded list of special domains. If any of these are present between the 
// second-to-last and last dot we will require 2 embedded dots.
// The domain strings are reversed to make the compares easier

static const char *s_pachSpecialDomains[] = 
    {"MOC", "UDE", "TEN", "GRO", "VOG", "LIM", "TNI" };  


struct CookieInfo {

   char *pchRDomain;
   char *pchPath;
   char *pchName;
   char *pchValue;
   unsigned long dwFlags;
   FILETIME ftExpiration;
};

//---------------------------------------------------------------------------
//
// String utilities
//
//---------------------------------------------------------------------------

static BOOL
IsZero(FILETIME *pft)
{
    return pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0;
}

static char *
StrnDup(const char *pch, int cch)
{
    char *pchAlloc = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cch + 1);
    if (!pchAlloc)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memcpy(pchAlloc, pch, cch);
    pchAlloc[cch] = 0;

    return pchAlloc;
}

static BOOL
IsPathMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0;
}

static BOOL
IsDomainMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0 && (*pchStr == 0 || *pchStr == '.');
}

static BOOL
IsPathLegal(const char *pchHeader, const char *pchDocument)
{
    return TRUE;

    /*

    We attempted to implement the specification here.
    It looks like Navigator does not reject cookies
    based on the path attribute.  We now consider
    all path attributes to be legal.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    if (*pchDocument == 0)
    {
        while (*pchHeader && *pchHeader != '/' && *pchHeader != '\\')
        {
            pchHeader += 1;
        }
    }

    return *pchHeader == 0;
    */
}

extern PTSTR GlobalSpecialDomains;
extern PTSTR *GlobalSDOffsets;

static BOOL
IsVerySpecialDomain(const char *pch, int nTopLevel, int nSecond)
{
    if (!GlobalSpecialDomains)
    {
        HKEY hk;
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0"),
                                        0,
                                        KEY_READ,
                                        &hk))
        {
            DWORD dwType, dwSize;

            if ((ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, NULL, &dwSize))
                && (REG_SZ==dwType))
            {
                GlobalSpecialDomains = New TCHAR[dwSize];
                if (GlobalSpecialDomains
                    && (ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, (LPBYTE)GlobalSpecialDomains, &dwSize)))
                {

                    // We're going to scan a string stored in the registry to gather the domains we should
                    // allow. Format:
                    // [domain] [domain] [domain]
                    // The delimiter is a space character.
                    
                    PTSTR psz = GlobalSpecialDomains;
                    DWORD dwDomains = 0;
                    BOOL fWord = FALSE;
                    while (*psz)
                    {
                        if (*psz==TEXT(' '))
                        {
                            if (fWord)
                            {
                                fWord = FALSE;
                                dwDomains++;
                            }
                        }
                        else
                        {
                            fWord = TRUE;
                        }
                        psz++;
                    }
                    if (fWord)
                    {
                        dwDomains++;
                    }
                    GlobalSDOffsets = (PTSTR*)New PTSTR[dwDomains+1];
                    if (GlobalSDOffsets)
                    {
                        psz = GlobalSpecialDomains;
                        for (DWORD dw = 0; dw < dwDomains; dw++)
                        {
                            INET_ASSERT(*psz);

                            while (*psz==TEXT(' '))
                                psz++;

                            INET_ASSERT(*psz);
                            GlobalSDOffsets[dw] = psz;

                            while (*psz && *psz!=TEXT(' '))
                            {
                                psz++;
                            }
                            *psz = TEXT('\0');
                        }
                        GlobalSDOffsets[dwDomains] = NULL;
                    }
                }
            }
            RegCloseKey(hk);
        }
    }

    // WARNING: The following lines of code make it possible for cookies to be set for *.uk,
    // (for example) if "ku." is in the registry
    BOOL fRet = FALSE;
    if (GlobalSDOffsets)
    {
        for (DWORD i = 0; GlobalSDOffsets[i]; i++)
        {
            if (!StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel)
                || !StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel+nSecond+1))
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


static BOOL
IsSpecialDomain(const char *pch, int nCount)
{
    // Currently all the special strings are exactly 3 characters long.
    if (pch == NULL || nCount != 3)
        return FALSE;

    for (int i = 0 ; i < ARRAY_ELEMENTS(s_pachSpecialDomains) ; i++ )
    {
        if (StrCmpNIC(pch, s_pachSpecialDomains[i], nCount) == 0)
            return TRUE;
    }

    return FALSE;
}

static BOOL
IsDomainLegal(const char *pchHeader, const char *pchDocument)
{
    const char *pchCurrent = pchHeader;
    int nSegment = 0;
    int dwCharCount = 0;
    int rgcch[2] = { 0, 0 };  // How many characters between dots

    // Must have at least one period in name.
    // and contains nothing but '.' is illegal 

    int dwSegmentLength = 0;
    const char * pchSecondPart = NULL; // for a domain string such as 
    for (; *pchCurrent; pchCurrent++)
    {
        if (*pchCurrent == '.')
        {
            if (nSegment < 2)
            {
                // Remember how many characters we have between the last two dots
                // For example if domain header is .microsoft.com
                // rgcch[0] should be 3 for "com"
                // rgcch[1] should be 9 for "microsoft"
                rgcch[nSegment] = dwSegmentLength;

                if (nSegment == 1)
                {
                    pchSecondPart = pchCurrent - dwSegmentLength;
                }
            }
            dwSegmentLength = 0;
            nSegment += 1;
        }
        else
        {
            dwSegmentLength++;
        }
        dwCharCount++;
    }

    // The code below depends on the leading dot being removed from the domain header.
    // The parse code does that, but an assert here just in case something changes in the 
    // parse code.
    INET_ASSERT(*(pchCurrent - 1) != '.');

    // Remember the count of the characters between the begining of the header and 
    // the first dot. So for domain=abc.com this will set rgch[1] = 3. 
    // Note that this assumes that if domain=.abc.com the leading dot has been stripped
    // out in the parse code. See assert above.
    if (nSegment < 2 )
    {
        rgcch[nSegment] = dwSegmentLength;
        if (nSegment==1)
        {
            pchSecondPart = pchCurrent - dwSegmentLength;
        }
    }

    // If the domain name is of the form abc.xx.yy where the number of characters between the last two dots is less than 
    // 2 we require a minimum of two embedded dots. This is so you are not allowed to set cookies readable by all of .co.nz for 
    // example. However this rule is not sufficient and we special case things like .edu.nz as well. 

    int cEmbeddedDotsNeeded = 1;

    if (rgcch[0] <= 2)
    {
        if ((rgcch[1] <= 2 && !IsVerySpecialDomain(pchHeader, rgcch[0], rgcch[1]))
            || (pchSecondPart && IsSpecialDomain(pchSecondPart, rgcch[1])))
            cEmbeddedDotsNeeded = 2;
    }

    if (nSegment < cEmbeddedDotsNeeded || dwCharCount == nSegment)
        return FALSE;

    // Mismatch between header and document not allowed.
    // Must match full components of domain name.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    return *pchHeader == 0 && (*pchDocument == 0 || *pchDocument == '.' );
}


void
LowerCaseString(char *pch)
{
    for (; *pch; pch++)
    {
        if (*pch >= 'A' && *pch <= 'Z')
            *pch += 'a' - 'A';
    }
}

static void
ReverseString(char *pchFront)
{
    char *pchBack;
    char  ch;
    int   cch;

    cch = strlen(pchFront);

    pchBack = pchFront + cch - 1;

    cch = cch / 2;
    while (--cch >= 0)
    {
        ch = tolower(*pchFront);
        *pchFront = tolower(*pchBack);
        *pchBack = ch;

        pchFront += 1;
        pchBack -= 1;
    }
}

static BOOL
PathAndRDomainFromURL(const char *pchURL, char **ppchRDomain, char **ppchPath, BOOL *pfSecure, BOOL bStrip = TRUE)
{
    char *pchDomainBuf;
    char *pchRDomain = NULL;
    char *pchPathBuf;
    char *pchPath = NULL;
    char *pchExtra;
    DWORD cchDomain;
    DWORD cchPath;
    DWORD cchExtra;
    BOOL  fSuccess = FALSE;
    DWORD dwError;
    INTERNET_SCHEME ustScheme;

    dwError = CrackUrl((char *)pchURL,
             0,
             FALSE,
             &ustScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Lenth
             &pchDomainBuf,
             &cchDomain,
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             &pchPathBuf,
             &cchPath,
             &pchExtra,     //  Extra
             &cchExtra,     //  Extra Length
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        goto Cleanup;
    }

    if ( ustScheme != INTERNET_SCHEME_HTTP &&
         ustScheme != INTERNET_SCHEME_HTTPS &&
         ustScheme != INTERNET_SCHEME_UNKNOWN)
    {
        //
        // known scheme should be supported
        // e.g. 3rd party pluggable protocol should be able to
        // call cookie api to setup cookies...
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    *pfSecure = ustScheme == INTERNET_SCHEME_HTTPS;

    if(bStrip)
    {
        while (cchPath > 0)
        {
            if (pchPathBuf[cchPath - 1] == '/' || pchPathBuf[cchPath - 1] == '\\')
            {
                break;
            }
        cchPath -= 1;
        }
    }

    pchRDomain = StrnDup(pchDomainBuf, cchDomain);
    if (!pchRDomain)
        goto Cleanup;

    LowerCaseString(pchRDomain);
    ReverseString(pchRDomain);

    pchPath = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchPath + 2);
    if (!pchPath)
        goto Cleanup;

    if (*pchPathBuf != '/')
    {
        *pchPath = '/';
        memcpy(pchPath + 1, pchPathBuf, cchPath);
        pchPath[cchPath + 1] = TEXT('\0');
    }
    else
    {
        memcpy(pchPath, pchPathBuf, cchPath);
        pchPath[cchPath] = TEXT('\0');
    }

    fSuccess = TRUE;

Cleanup:
    if (!fSuccess)
    {
        if (pchRDomain)
            FREE_MEMORY(pchRDomain);
        if (pchPath)
            FREE_MEMORY(pchPath);
    }
    else
    {
        *ppchRDomain = pchRDomain;
        *ppchPath = pchPath;
    }

    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieBase implementation
//
//---------------------------------------------------------------------------

void *
CCookieBase::operator new(size_t cb, size_t cbExtra)
{
    void *pv = ALLOCATE_MEMORY(LMEM_FIXED, cb + cbExtra);
    if (!pv)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memset(pv, 0, cb);
    return pv;
}

inline void
CCookieBase::operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

//---------------------------------------------------------------------------
//
// CCookie implementation
//
//---------------------------------------------------------------------------

CCookie *
CCookie::Construct(const char *pchName)
{
    CCookie *pCookie = new(strlen(pchName) + 1) CCookie();
    if (!pCookie)
        return NULL;

    pCookie->_pchName = (char *)(pCookie + 1);
    pCookie->_pchValue = s_achEmpty;
    strcpy(pCookie->_pchName, pchName);

    pCookie->_dwFlags = COOKIE_SESSION;

    return pCookie;
}

CCookie::~CCookie()
{
    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);
}

BOOL
CCookie::SetValue(const char *pchValue)
{
    int   cchValue;

    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);

    if (!pchValue || !*pchValue)
    {
        _pchValue = s_achEmpty;
    }
    else
    {
        cchValue = strlen(pchValue) + 1;
        _pchValue = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchValue);
        if (!_pchValue)
        {
            _pchValue = s_achEmpty;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        memcpy(_pchValue, pchValue, cchValue);
    }
    return TRUE;
}

BOOL
CCookie::CanSend(BOOL fSecure)
{
    return (fSecure || !(_dwFlags & COOKIE_SECURE));
}

BOOL CCookie::PurgeAll(void *)
{
    return TRUE;
}


static BOOL
WriteString(HANDLE hFile, const char *pch)
{
    DWORD cb;
    return pch && *pch ? WriteFile(hFile, pch, strlen(pch), &cb, NULL) : TRUE;
}

static BOOL
WriteStringLF(HANDLE hFile, const char *pch)
{
    DWORD cb;

    if (!WriteString(hFile, pch)) return FALSE;
    return WriteFile(hFile, "\n", 1, &cb, NULL);
}


//---------------------------------------------------------------------------
//
// CCookieLocation implementation
//
//---------------------------------------------------------------------------

CCookieLocation *
CCookieLocation::Construct(const char *pchRDomain, const char *pchPath)
{
    int cchPath = strlen(pchPath);

    CCookieLocation *pLocation = new(strlen(pchRDomain) + cchPath + 2) CCookieLocation();
    if (!pLocation)
        return NULL;

    pLocation->_cchPath = cchPath;
    pLocation->_pchPath = (char *)(pLocation + 1);
    pLocation->_pchRDomain = pLocation->_pchPath + cchPath + 1;

    strcpy(pLocation->_pchRDomain, pchRDomain);
    strcpy(pLocation->_pchPath, pchPath);

    return pLocation;
}

CCookieLocation::~CCookieLocation()
{
    Purge(CCookie::PurgeAll, NULL);
}

CCookie *
CCookieLocation::GetCookie(const char *pchName, BOOL fCreate)
{
    CCookie *pCookie;

    CCookie **ppCookie = &_pCookieKids;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (strcmp(pchName, pCookie->_pchName) == 0)
            return pCookie;
        ppCookie = &pCookie->_pCookieNext;
    }

    if (!fCreate)
        return NULL;

    pCookie = CCookie::Construct(pchName);
    if (!pCookie)
        return NULL;

    //
    // Insert cookie at end of list to match Navigator's behavior.
    //

    pCookie->_pCookieNext = NULL;
    *ppCookie = pCookie;

    return pCookie;
}

void
CCookieLocation::Purge(BOOL (CCookie::*pfnPurge)(void *), void *pv)
{
    CCookie **ppCookie = &_pCookieKids;
    CCookie *pCookie;

    while ((pCookie = *ppCookie) != NULL)
    {
        if ((pCookie->*pfnPurge)(pv))
        {
            *ppCookie = pCookie->_pCookieNext;
            delete pCookie;
        }
        else
        {
            ppCookie = &pCookie->_pCookieNext;
        }
    }
}

static char *
ScanString(char *pch, char **pchStr)
{
    *pchStr = pch;

    for (; *pch; *pch++)
    {
        if (*pch == '\n')
        {
            *pch = 0;
            pch += 1;
            break;
        }
    }

    return pch;
}

static char *
ScanNumber(char *pch, DWORD *pdw)
{
    DWORD dw = 0;
    char *pchJunk;

    for (; *pch >= '0' && *pch <= '9'; *pch++)
    {
        dw = (dw * 10) + *pch - '0';
    }

    *pdw = dw;

    return ScanString(pch, &pchJunk);
}


BOOL
CCookieLocation::IsMatch(const char *pchRDomain, const char *pchPath)
{
    return IsDomainMatch(_pchRDomain, pchRDomain) &&
        IsPathMatch(_pchPath, pchPath);
}


//---------------------------------------------------------------------------
//
// CCookieJar implementation
//
//---------------------------------------------------------------------------


CCookieJar *
CCookieJar::Construct()
{
    return new(0) CCookieJar();
}

CCookieJar::CCookieJar()
{
    _csCookieJar.Init();
}

CCookieJar::~CCookieJar()
{
    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation *pLocation = _apLocation[i];
        while (pLocation)
        {
            CCookieLocation *pLocationT = pLocation->_pLocationNext;
            delete pLocation;
            pLocation = pLocationT;
        }
    }
}

CCookieLocation **
CCookieJar::GetBucket(const char *pchRDomain)
{
    int ch;
    int cPeriod = 0;
    unsigned int hash = 0;

    for (; (ch = *pchRDomain) != 0; pchRDomain++)
    {
        if (ch == '.')
        {
            cPeriod += 1;
            if (cPeriod >= 2)
                break;
        }
        hash = (hash * 29) + ch;
    }

    hash = hash % ARRAY_ELEMENTS(_apLocation);

    return &_apLocation[hash];
}

CCookieLocation *
CCookieJar::GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate)
{
    int cchPath = strlen(pchPath);
    CCookieLocation *pLocation = NULL;
    CCookieLocation **ppLocation = GetBucket(pchRDomain);

    // To support sending more specific cookies before less specific,
    // we keep list sorted by path length.

    while ((pLocation = *ppLocation) != NULL)
    {
        if (pLocation->_cchPath < cchPath)
            break;

        if (strcmp(pLocation->_pchPath, pchPath) == 0 &&
            strcmp(pLocation->_pchRDomain, pchRDomain) == 0)
            return pLocation;

        ppLocation = &pLocation->_pLocationNext;
    }

    if (!fCreate)
        goto Cleanup;

    pLocation = CCookieLocation::Construct(pchRDomain, pchPath);
    if (!pLocation)
        goto Cleanup;

    pLocation->_pLocationNext = *ppLocation;
    *ppLocation = pLocation;

Cleanup:
    return pLocation;
}

void 
CCookieJar::expireCookies(CCookieLocation *pLocation, FILETIME *pftNow) {

   FILETIME ftCurrent;

   if (pftNow==NULL)
      GetSystemTimeAsFileTime(&ftCurrent);
   else
      ftCurrent = *pftNow;

   CCookie **previous = & pLocation->_pCookieKids;

   CCookie *pCookie = pLocation->_pCookieKids;

   while (pCookie) 
   {
      /* Session cookies do not expire so we only check persistent cookies */
      if ((pCookie->_dwFlags & COOKIE_SESSION) == 0)
      {

         /* "CompareFileTime" macro returns {+1, 0, -1} similar to "strcmp" */
         int cmpresult = CompareFileTime(ftCurrent, pCookie->_ftExpiry);

         if (cmpresult==1) /* Cookie has expired: remove from linked list & delete */
         { 
            *previous = pCookie->_pCookieNext;
            delete pCookie;
            pCookie = *previous;
            continue;
         }
      }

      /* Otherwise cookie is still valid: advance to next node */
      previous = & (pCookie->_pCookieNext);
      pCookie = pCookie->_pCookieNext;
   }   
}



CCookieLocation*
CCookieJar::GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime)  {

   for (CCookieLocation *pLocation = pLast ? pLast->_pLocationNext : *GetBucket(pchRDomain);
        pLocation;
        pLocation = pLocation->_pLocationNext)
   {
      if (pLocation->IsMatch(pchRDomain, pchPath))
      {
         /* Found matching cookies...
            Before returning linked list to the user, check expiration 
            times, deleting cookies which are no longer valid */
         expireCookies(pLocation, ftCurrentTime);
         return pLocation;
      }
   }

   /* Reaching this point means no matching cookies were found */
   return NULL;
}

void
CCookieJar::Purge()
{
    // NOT IMPLEMENTED
}


struct PARSE
{
    char *pchBuffer;
    char *pchToken;
    BOOL fEqualFound;
};

static char *
SkipWS(char *pch)
{
    while (*pch == ' ' || *pch == '\t')
        pch += 1;

    return pch;
}

static BOOL
ParseToken(PARSE *pParse, BOOL fBreakOnSpecialTokens, BOOL fBreakOnEqual)
{
    char ch;
    char *pch;
    char *pchEndToken;

    pParse->fEqualFound = FALSE;

    pch = SkipWS(pParse->pchBuffer);
    if (*pch == 0)
    {
        pParse->pchToken = pch;
        return FALSE;
    }

    pParse->pchToken = pch;
    pchEndToken = pch;

    while ((ch = *pch) != 0)
    {
        pch += 1;
        if (ch == ';')
        {
            break;
        }
        else if (fBreakOnEqual && ch == '=')
        {
            pParse->fEqualFound = TRUE;
            break;
        }
        else if (ch == ' ' || ch == '\t')
        {
            if (fBreakOnSpecialTokens)
            {
                if ((strnicmp(pch, "expires", sizeof("expires") - 1) == 0) ||
                    (strnicmp(pch, "path", sizeof("path") - 1) == 0) ||
                    (strnicmp(pch, "domain", sizeof("domain") - 1) == 0) ||
                    (strnicmp(pch, "secure", sizeof("secure") - 1) == 0))
                {
                    break;
                }
            }
        }
        else
        {
            pchEndToken = pch;
        }
    }

    *pchEndToken = 0;
    pParse->pchBuffer = pch;
    return TRUE;
}


static void
ParseHeader(
    char *pchHeader,
    CookieInfo *pCookie
   )
{
   char **ppchName = & (pCookie->pchName);
   char **ppchValue = & (pCookie->pchValue);
   char **ppchPath = & (pCookie->pchPath);
   char **ppchRDomain = & (pCookie->pchRDomain);

   PARSE parse;

    parse.pchBuffer = pchHeader;

    *ppchName = NULL;
    *ppchValue = NULL;
    *ppchPath = NULL;
    *ppchRDomain = NULL;
    pCookie->dwFlags = COOKIE_SESSION;

    // If only one of name or value is specified, Navigator
    // uses name=<blank> and value as what ever was specified.
    // Example:  =foo  ->  name: <blank> value: foo
    //           foo   ->  name: <blank> value: foo
    //           foo=  ->  name: foo     value: <blank>

    if (ParseToken(&parse, FALSE, TRUE))
    {
        *ppchName = parse.pchToken;
        if (parse.fEqualFound)
        {
            if (ParseToken(&parse, FALSE, FALSE))
            {
                *ppchValue = parse.pchToken;
            }
            else
            {
                *ppchValue = s_achEmpty;
            }
        }
        else
        {
            *ppchValue = *ppchName;
            *ppchName = s_achEmpty;
        }
    }

    while (ParseToken(&parse, FALSE, TRUE))
    {
        if (stricmp(parse.pchToken, "expires") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                // WinHttpX treats persistent cookies as session cookies with expiration
                if (FParseHttpDate(& pCookie->ftExpiration, parse.pchToken)) 
                {
                   // Don't make the cookie persistent if the parsing fails
                   pCookie->dwFlags &= ~COOKIE_SESSION;
                }
            }
        }
        else if (stricmp(parse.pchToken, "domain") == 0)
        {
            if (parse.fEqualFound )
            {
                if( ParseToken(&parse, TRUE, FALSE))
                {
                    // Previous versions of IE tossed the leading
                    // "." on domain names.  We continue this behavior
                    // to maintain compatiblity with old cookie files.
                    // See comments at the top of this file for more
                    // information.

                    if (*parse.pchToken == '.') parse.pchToken += 1;
                    ReverseString(parse.pchToken);
                    *ppchRDomain = parse.pchToken;
                }
                else
                {
                    *ppchRDomain = parse.pchToken;
                }
            }
        }
        else if (stricmp(parse.pchToken, "path") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                *ppchPath = parse.pchToken;
            }
            else
            {
                *ppchPath = s_achEmpty;
            }
        }
        else if (stricmp(parse.pchToken, "secure") == 0)
        {
            pCookie->dwFlags |= COOKIE_SECURE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else
        {
            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
    }

    if (!*ppchName)
    {
        *ppchName = *ppchValue = s_achEmpty;
    }
}

// free's an INTERNET_COOKIE structure
static VOID
DestroyInternetCookie(INTERNET_COOKIE *pic)
{
    if ( pic != NULL ) 
    {
        if ( pic->pszDomain ) {
            FREE_MEMORY(pic->pszDomain);
        }
        if ( pic->pszPath ) {
            FREE_MEMORY(pic->pszPath);
        }
        if ( pic->pszName ) {
            FREE_MEMORY(pic->pszName);
        }
        if ( pic->pszData ) {
            FREE_MEMORY(pic->pszData);
        }
        if ( pic->pszUrl ) {
            FREE_MEMORY(pic->pszUrl);
        }
        if( pic->pftExpires ) {
            delete pic->pftExpires; 
            pic->pftExpires = NULL;
        }

        FREE_MEMORY(pic);
    }
}

// allocate's an INTERNET_COOKIE structure
static INTERNET_COOKIE *
MakeInternetCookie(
    const char *pchURL,
    char *pchRDomain,
    char *pchPath,
    char *pchName,
    char *pchValue,
    DWORD dwFlags,
    FILETIME ftExpire
    )
{
    INTERNET_COOKIE *pic = NULL;

    pic = (INTERNET_COOKIE *) ALLOCATE_MEMORY(LMEM_ZEROINIT, sizeof(INTERNET_COOKIE));

    if ( pic == NULL ) {
        return NULL;
    }
    
    pic->cbSize = sizeof(INTERNET_COOKIE);

    pic->pszDomain = pchRDomain ? NewString(pchRDomain) : NULL;
    if (pic->pszDomain) {
        ReverseString(pic->pszDomain);
    }
    pic->pszPath = pchPath ? NewString(pchPath) : NULL;
    pic->pszName = pchName ? NewString(pchName) : NULL;
    pic->pszData = pchValue ? NewString(pchValue) : NULL;
    pic->pszUrl = pchURL ? NewString(pchURL) : NULL;

#if COOKIE_SECURE != INTERNET_COOKIE_IS_SECURE
#error MakeInternetCookie depends on cookie flags to remain the same
#endif 
    pic->dwFlags = dwFlags;

    if( dwFlags & COOKIE_SESSION )
    {
        pic->pftExpires = NULL;
    }
    else
    {
        pic->pftExpires = New FILETIME;
        if( pic->pftExpires )
        {
            memcpy(pic->pftExpires, &ftExpire, sizeof(FILETIME));
        }
    }
    
    return pic;
}


DWORD
CCookieJar::SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags = 0)
{
    char *pchDocumentRDomain = NULL;
    char *pchDocumentPath = NULL;
    BOOL  fDocumentSecure;
    BOOL  fDelete;
    DWORD dwRet = SET_COOKIE_FAIL;
    CCookieLocation *pLocation;

    CookieInfo cookieStats;

    ParseHeader(pchHeader, &cookieStats);

    char *pchName = cookieStats.pchName;
    char *pchValue = cookieStats.pchValue;
    char *pchHeaderPath = cookieStats.pchPath;
    char *pchHeaderRDomain = cookieStats.pchRDomain;
    DWORD dwFlagsFromParse = cookieStats.dwFlags;
       
    // merge flags given with those found by the parser.
    dwFlags |= dwFlagsFromParse;

    if (!PathAndRDomainFromURL(pchURL, &pchDocumentRDomain, &pchDocumentPath, &fDocumentSecure))
        goto Cleanup;

    //
    // Verify domain and path
    //

    if ((pchHeaderRDomain && !IsDomainLegal(pchHeaderRDomain, pchDocumentRDomain)) ||
        (pchHeaderPath && !IsPathLegal(pchHeaderPath, pchDocumentPath)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (!pchHeaderRDomain)
        pchHeaderRDomain = pchDocumentRDomain;

    if (!pchHeaderPath)
        pchHeaderPath = pchDocumentPath;

    // We need to discard any extra info (i.e. query strings and fragments)
    // from the url.
    if (pchHeaderPath)
    {
        PTSTR psz = pchHeaderPath;
        while (*psz)
        {
            if (*psz==TEXT('?') || *psz==TEXT('#'))
            {
                *psz = TEXT('\0');
                break;
            }
            psz++;
        }
    }

    //   WinHttpX treats persistent cookies as session cookies, subject
    //   to the expiration rules
    //   Also it does not implement zone policies set by URLMON
    //
    //   Finally, we can add the cookie!
    //

    {
        if (_csCookieJar.Lock())
        {
            pLocation = GetLocation(pchHeaderRDomain, pchHeaderPath, TRUE);

            if (pLocation)
            {
                CCookie *pCookie;

                pCookie = pLocation->GetCookie(pchName, TRUE);
                if (!pCookie)
                    goto Cleanup;

                //
                // If the cookie's value or flags have changed, update it.
                //
                if (strcmp(pchValue, pCookie->_pchValue) || dwFlags != pCookie->_dwFlags)
                {
                    pCookie->_dwFlags = dwFlags;
                    pCookie->_ftExpiry = cookieStats.ftExpiration;
                    pCookie->SetValue(pchValue);
                }
            }
            _csCookieJar.Unlock();
        }
    }

    dwRet = SET_COOKIE_SUCCESS;

Cleanup:

    if (pchDocumentRDomain)
        FREE_MEMORY(pchDocumentRDomain);
    if (pchDocumentPath)
        FREE_MEMORY(pchDocumentPath);

    return dwRet;
}


//---------------------------------------------------------------------------
//
// External APIs
//
//---------------------------------------------------------------------------


CCookieJar *
CreateCookieJar()
{
    return CCookieJar::Construct();
}

void
CloseCookieJar(CCookieJar * CookieJar)
{
    if (CookieJar)
    {
        delete CookieJar;
    }
}

#ifndef WININET_SERVER_CORE
void
PurgeCookieJar()
{
}
#endif


//
//  rambling comments, delete before checkin...
//
// returns struc, and pending, error
//  on subsequent attempts passes back, with index, or index incremented
// perhaps can store index in fsm, and the rest in UI 
//  need to handle multi dlgs, perhaps via checking added Cookie.
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ExtractSetCookieHeaders(LPDWORD lpdwHeaderIndex)
{
    char *pchHeader = NULL;
    DWORD cbHeader;
    DWORD iQuery = 0;
    int   cCookies = 0;
    DWORD error = ERROR_WINHTTP_HEADER_NOT_FOUND;
    const DWORD cbHeaderInit = CCH_COOKIE_MAX * sizeof(char) - 1;

    pchHeader = New char[CCH_COOKIE_MAX];

    if (pchHeader == NULL || !_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpdwHeaderIndex);

    cbHeader = cbHeaderInit;

    iQuery = *lpdwHeaderIndex;

    while (QueryResponseHeader(HTTP_QUERY_SET_COOKIE,
            pchHeader,
            &cbHeader,
            0,
            &iQuery) == ERROR_SUCCESS)
    {
        pchHeader[cbHeader] = 0;

        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;
        DWORD dwRet = pcj->SetCookie(this, GetURL(), pchHeader);

        if (dwRet == SET_COOKIE_SUCCESS)
        {
            cCookies += 1;
            *lpdwHeaderIndex = iQuery;
            error = ERROR_SUCCESS;
        } 
        else if (dwRet == SET_COOKIE_PENDING) 
        {
            error = ERROR_IO_PENDING;

            INET_ASSERT(iQuery != 0);
            *lpdwHeaderIndex = iQuery - 1; // back up and retry this cookie

            break;
        }

        cbHeader = cbHeaderInit;
    }

    _ResponseHeaders.UnlockHeaders();

Cleanup:
    if (pchHeader)
        delete [] pchHeader;

    return error;
}

int
HTTP_REQUEST_HANDLE_OBJECT::CreateCookieHeaderIfNeeded(VOID)
{
    int     cCookie = 0;
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure;
    DWORD   cch;
    int     cchName;
    int     cchValue;
    char *  pchHeader = NULL;
    char *  pchHeaderStart = NULL;

    pchHeaderStart = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX * sizeof(char));
    if (pchHeaderStart == NULL)
        goto Cleanup;
    
    // remove cookie header if it exists
    // BUGBUG - we are overriding the app. Original cookie code has this.  Don't know why.

    ReplaceRequestHeader(HTTP_QUERY_COOKIE, NULL, 0, 0, 0);

    if (!PathAndRDomainFromURL(GetURL(), &pchRDomain, &pchPath, &fSecure, FALSE))
        goto Cleanup;

    fSecure = GetOpenFlags() & WINHTTP_FLAG_SECURE;

    if (LockHeaders())
    {
        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;

        if (pcj->_csCookieJar.Lock())
        {
            FILETIME ftNow;
            GetSystemTimeAsFileTime(&ftNow);

            CCookieLocation *pLocation = pcj->GetCookies(pchRDomain, pchPath, NULL, &ftNow);

            while (pLocation) 
            {
               for (CCookie *pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
               {
                   if (pCookie->CanSend(fSecure))
                   {
                       pchHeader = pchHeaderStart;

                       cch = 0;
                       cch += cchName = strlen(pCookie->_pchName);
                       cch += cchValue = strlen(pCookie->_pchValue);
                       if (cchName) cch += 1; // for equal sign

                       if (cch < CCH_COOKIE_MAX)
                       {
                          if (cchName > 0)
                          {
                             memcpy(pchHeader, pCookie->_pchName, cchName);
                             pchHeader += cchName;
                             *pchHeader++ = '=';
                          }

                          if (cchValue > 0)
                          {
                             memcpy(pchHeader, pCookie->_pchValue, cchValue);
                             pchHeader += cchValue;
                          }

                          cCookie += 1;

                          AddRequestHeader(HTTP_QUERY_COOKIE,
                                           pchHeaderStart,
                                           cch,
                                           0, 
                                           HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON);
                       }
                   }  // if (CanSend)
               } // for (pCookie)

               pLocation = pcj->GetCookies(pchRDomain, pchPath, pLocation, &ftNow);
            } // while (pLocation)
            pcj->_csCookieJar.Unlock();
        } // if pcj->_csCookieJar.Lock()
        UnlockHeaders();
    }

Cleanup:

    if (pchHeaderStart)
        FREE_MEMORY(pchHeaderStart);
    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

    return cCookie;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\hdrbuf.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

#include <wininetp.h>

#define DATE_AND_TIME_STRING_BUFFER_LENGTH  128

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    )
{
    DWORD i;
    for (i=0; i < cListLen; ++i) {
       if (!lpHeader->Strnicmp(lpBase, lplpList[i], strlen(lplpList[i]))) {
          return (TRUE);
       }
    }
    return(FALSE);
}


DWORD
FASTCALL
CalculateHashNoCase(
    IN LPCSTR lpszString,
    IN DWORD dwStringLength
    )

/*++

Routine Description:

    Calculate a case-insensitive hash number given a string. Assumes input is
    7-bit ASCII

Arguments:

    lpszString      - string to hash

    dwStringLength  - length of lpszString, or -1 if we need to calculate

Return Value:

    DWORD - a generated hash value

--*/

{
    DWORD dwHash = HEADER_HASH_SEED;

    while (dwStringLength != 0) {
        CHAR ch = *lpszString;

        if ((ch >= 'A') && (ch <= 'Z')) {
            ch = MAKE_LOWER(ch);
        }
        dwHash += (DWORD)(dwHash << 5) + ch; /*+ *pszName++;*/

        ++lpszString;
        --dwStringLength;
    }
    return dwHash;
}

//
// methods
//



DWORD
HTTP_HEADERS::AllocateHeaders(
    IN DWORD dwNumberOfHeaders
    )

/*++

Routine Description:

    Allocates or grows the array of header pointers (HEADER_STRING objects)

Arguments:

    dwNumberOfHeaders   - number of additional header slots to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AllocateHeaders",
                 "%d",
                 dwNumberOfHeaders
                 ));

    PERF_ENTER(AllocateHeaders);

    //
    // we really need to be able to realloc an array of HEADER_STRING objects
    // (see below)
    //

    DWORD error;
    DWORD slots = _TotalSlots;


    if ( (_TotalSlots + dwNumberOfHeaders) >  (INVALID_HEADER_INDEX-1))
    {
        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    _lpHeaders = (HEADER_STRING *)ResizeBuffer((HLOCAL)_lpHeaders,
                                               (_TotalSlots + dwNumberOfHeaders)
                                                    * sizeof(HEADER_STRING),
                                               FALSE // not moveable
                                               );
    if (_lpHeaders != NULL) {
        _NextOpenSlot = _TotalSlots;
        _TotalSlots += dwNumberOfHeaders;
        _FreeSlots += dwNumberOfHeaders;

        //
        // this is slightly ugly, but it seems there's no easy C++ way to
        // do this - we need to be able to realloc() an array of objects
        // created by new(), but so far, it can't be done
        //

        for (; slots < _TotalSlots; ++slots) {
            _lpHeaders[slots].Clear();
        }
        error = ERROR_SUCCESS;
    } else {

        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    INET_ASSERT(_FreeSlots <= _TotalSlots);

    PERF_LEAVE(AllocateHeaders);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::FreeHeaders(
    VOID
    )

/*++

Routine Description:

    Free the headers strings and the headers array

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "FreeHeaders",
                 NULL
                 ));

    if (!LockHeaders())
    {
        goto quit;
    }

    //
    // free up each individual entry (free string buffers)
    //

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        _lpHeaders[i] = (LPSTR)NULL;
    }

    //
    // followed by the array itself
    //

    if (_lpHeaders) {
        _lpHeaders = (HEADER_STRING *)FREE_MEMORY((HLOCAL)_lpHeaders);

        INET_ASSERT(_lpHeaders == NULL);
    }

    _TotalSlots = 0;
    _FreeSlots = 0;
    _HeadersLength = 0;
    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    UnlockHeaders();

quit:
    DEBUG_LEAVE(0);
}


DWORD
HTTP_HEADERS::CopyHeaders(
    IN OUT LPSTR * lpBuffer,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer            - pointer to pointer to buffer where headers are
                          written. We update the pointer

    lpszObjectName      - optional object name

    dwObjectNameLength  - optional object name length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory while trying to synchronize src data access

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyHeaders",
                 "%#x, %#x [%q], %d",
                 lpBuffer,
                 lpszObjectName,
                 lpszObjectName,
                 dwObjectNameLength
                 ));

    DWORD dwError = ERROR_SUCCESS;
    if (!LockHeaders())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    DWORD i = 0;

    if (lpszObjectName != NULL) {
        memcpy(*lpBuffer, _lpszVerb, _dwVerbLength);
        *lpBuffer += _dwVerbLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, lpszObjectName, dwObjectNameLength);
        *lpBuffer += dwObjectNameLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, _lpszVersion, _dwVersionLength);
        *lpBuffer += _dwVersionLength;
        *(*lpBuffer)++ = '\r';
        *(*lpBuffer)++ = '\n';
        i = 1;
    }
    for (; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {
            _lpHeaders[i].CopyTo(*lpBuffer);
            *lpBuffer += _lpHeaders[i].StringLength();
            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';
        }
    }

    UnlockHeaders();

quit:
    DEBUG_LEAVE(dwError);

    return dwError;
}


HEADER_STRING *
FASTCALL
HTTP_HEADERS::FindFreeSlot(
    DWORD* piSlot
    )

/*++

Routine Description:

    Finds the next free slot in the headers list, or adds some new slots

    N.B. This function MUST be called with the headers already locked

Arguments:

    piSlot: returns index of slot found

Return Value:

    HEADER_STRING *  - pointer to next free slot

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "FindFreeSlot",
                 NULL
                 ));

    PERF_ENTER(FindFreeSlot);

    DWORD i;
    DWORD error;
    HEADER_STRING * header = NULL;

    //
    // if there are no free slots, allocate some more
    //

    if (_FreeSlots == 0) {
        i = _TotalSlots;
        error = AllocateHeaders(HEADERS_INCREMENT);
    } else {
        i = 0;
        error = ERROR_SUCCESS;
        if (!_lpHeaders[_NextOpenSlot].HaveString())
        {
            --_FreeSlots;
            header = &_lpHeaders[_NextOpenSlot];
            *piSlot = _NextOpenSlot;
            _NextOpenSlot = (_NextOpenSlot == (_TotalSlots-1)) ? (_TotalSlots-1) : _NextOpenSlot++;
            goto quit;
        }
    }
    if (error == ERROR_SUCCESS) {
        for (; i < _TotalSlots; ++i) {
            if (!_lpHeaders[i].HaveString()) {
                --_FreeSlots;
                header = &_lpHeaders[i];
                *piSlot = i;
                _NextOpenSlot = (i == (_TotalSlots-1)) ? (_TotalSlots-1) : (i+1);
                break;
            }
        }
        if (header == NULL) {

            //
            // we would have just allocated extra slots if we didn't have
            // any, so we shouldn't be here
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }

quit:
    _Error = error;

    PERF_LEAVE(FindFreeSlot);

    DEBUG_LEAVE(header);

    return header;
}


VOID
HTTP_HEADERS::ShrinkHeader(
    IN LPBYTE pbBase,
    IN DWORD  iSlot,
    IN DWORD  dwOldQueryIndex,
    IN DWORD  dwNewQueryIndex,
    IN DWORD  cbNewSize
    )

/*++

Routine Description:

    Low level function that does a surgical replace of one header with another.
    This code updates internal structures such as bKnownHeaders and the stored
    hash value for the new Header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    None.

--*/

{
    HEADER_STRING* pHeader = _lpHeaders + iSlot;

    INET_ASSERT(_bKnownHeaders[dwOldQueryIndex] == (BYTE) iSlot ||
                dwNewQueryIndex == dwOldQueryIndex );

    //
    // Swap in the new header.  Update Length, Hash, and its cached position
    //  in the known header array.
    //

    _bKnownHeaders[dwOldQueryIndex] = INVALID_HEADER_INDEX;
    _bKnownHeaders[dwNewQueryIndex] = (BYTE) iSlot;

    pHeader->SetLength (cbNewSize);
    pHeader->SetHash (GlobalKnownHeaders[dwNewQueryIndex].HashVal);
}

DWORD
inline
HTTP_HEADERS::SlowFind(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwIndex,
    IN DWORD dwHash,
    OUT DWORD *lpdwQueryIndex,
    OUT BYTE  **lplpbPrevIndex
    )

/*++

Routine Description:

    Finds the next occurance of lpszHeaderName in the header array, uses
    a cached table of well known headers to accerlate the search if the
    string is a known header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{

    //
    // Now see if this is a known header passed in as a string,
    //   If it is, we save ourselves the loop, and just map it right in to a known header
    //

    DWORD dwKnownQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    *lpdwQueryIndex = INVALID_HEADER_SLOT;

    if ( dwKnownQueryIndex != 0 )
    {
        dwKnownQueryIndex--;

        if ( ((int)dwHeaderNameLength >= GlobalKnownHeaders[dwKnownQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[dwKnownQueryIndex].Text,
                      GlobalKnownHeaders[dwKnownQueryIndex].Length) == 0)
        {
            *lpdwQueryIndex = dwKnownQueryIndex;

            INET_ASSERT((int)(dwHeaderNameLength) == GlobalKnownHeaders[dwKnownQueryIndex].Length);

            if ( lplpbPrevIndex )
            {
                return FastNukeFind(
                        dwKnownQueryIndex,
                        dwIndex,
                        lplpbPrevIndex
                        );
            }
            else
            {
                return FastFind(
                        dwKnownQueryIndex,
                        dwIndex
                        );
            }
        }
    }

    //
    // Otherwise we painfully enumerate the whole array of headers
    //

    for (DWORD i = 0; i < _TotalSlots; ++i)
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[i];

        if (!pString->HaveString()) {
            continue;
        }

        if (pString->HashStrnicmp(lpBase,
                                  lpszHeaderName,
                                  dwHeaderNameLength,
                                  dwHash) == 0)
        {

            //
            // if we haven't reached the required index yet, continue
            //

            if (dwIndex != 0) {
                --dwIndex;
                continue;
            }

            return i; // found index/slot
        }
    }

    return INVALID_HEADER_SLOT; // not found
}


DWORD
inline
HTTP_HEADERS::FastFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    DWORD dwSlot;

    dwSlot = _bKnownHeaders[dwQueryIndex];

    while ( (dwIndex > 0) && (dwSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[dwSlot];
        dwSlot  = pString->GetNextKnownIndex();

        dwIndex--;
    }

    if ( dwSlot >= INVALID_HEADER_INDEX)
    {
        return INVALID_HEADER_SLOT;
    }

    return dwSlot; // found it.
}


DWORD
inline
HTTP_HEADERS::FastNukeFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex,
    OUT BYTE **lplpbPrevIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.
    Also provides a ptr to ptr to the slot which directs us to the one found.
    This is needed for deletion purposes.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    BYTE *lpbSlot;

    *lplpbPrevIndex = lpbSlot = &_bKnownHeaders[dwQueryIndex];
    dwIndex++;

    while ( (dwIndex > 0) && (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[*lpbSlot];
        *lplpbPrevIndex = lpbSlot;
        lpbSlot  = pString->GetNextKnownIndexPtr();

        dwIndex--;
    }

    if ( **lplpbPrevIndex >= INVALID_HEADER_INDEX ||
         dwIndex > 0 )
    {
        return INVALID_HEADER_SLOT;
    }

    return ((DWORD) **lplpbPrevIndex); // found it.
}

VOID
HTTP_HEADERS::RemoveAllByIndex(
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Removes all Known Headers found in the header array.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

Return Value:

    None.

--*/


{
    BYTE bSlot;
    BYTE bPrevSlot;

    bSlot = bPrevSlot  = _bKnownHeaders[dwQueryIndex];

    while (bSlot < INVALID_HEADER_INDEX)
    {
        HEADER_STRING * pString;

        bPrevSlot   = bSlot;
        pString     = &_lpHeaders[bSlot];
        bSlot       = (BYTE) pString->GetNextKnownIndex();

        RemoveHeader(bPrevSlot, dwQueryIndex, &_bKnownHeaders[dwQueryIndex]);
    }

    _bKnownHeaders[dwQueryIndex] = INVALID_HEADER_INDEX;

    return;
}


BOOL
inline
HTTP_HEADERS::HeaderMatch(
    IN DWORD dwHash,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    OUT DWORD *lpdwQueryIndex
    )

/*++

Routine Description:

    Looks up a Known HTTP header string using its Hash value and
     string contained the name of the header.

Arguments:

    dwHash              - Hash value of header name string

    lpszHeaderName      - name of header we are matching

    dwHeaderNameLength  - length of header name string

    lpdwQueryIndex      - If found, this is the HTTP_QUERY_* based index to the header.

Return Value:

    BOOL
        Success - The string and hash matched againsted a known header

        Failure - There is no known header for that hash & string pair.

--*/

{
    *lpdwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    if ( *lpdwQueryIndex != 0 )
    {
        (*lpdwQueryIndex)--;

        if ( ((int)dwHeaderNameLength == GlobalKnownHeaders[*lpdwQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[*lpdwQueryIndex].Text,
                      GlobalKnownHeaders[*lpdwQueryIndex].Length) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BYTE
inline
HTTP_HEADERS::FastAdd(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwSlot
    )
/*++

Routine Description:

    Rapidly adds a known string to the header array, this function
     is used to matain coherency of the _bKnownHeaders which
     contained indexed offsets into the header array for known headers.

    Note that this function is used instead of latter listed below
     in order to maintain proper order in headers received.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

    dwSlot - Slot in which this header is being added.

Return Value:

    None.

--*/


{
    BYTE *lpbSlot;

    lpbSlot = &_bKnownHeaders[dwQueryIndex];

    while ( (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString  = &_lpHeaders[*lpbSlot];
        lpbSlot  = pString->GetNextKnownIndexPtr();
    }

    INET_ASSERT(*lpbSlot == INVALID_HEADER_INDEX);

    *lpbSlot = (BYTE) dwSlot;
    return INVALID_HEADER_INDEX;
}


//BYTE
//inline
//HTTP_HEADERS::FastAdd(
//    IN DWORD  dwQueryIndex,
//    IN DWORD  dwSlot
//    )
//{
//    BYTE bOldSlot;
//
//    bOldSlot = _bKnownHeaders[dwQueryIndex];
//    _bKnownHeaders[dwQueryIndex] = (BYTE) dwSlot;
//
//    return bOldSlot;
//}




DWORD
HTTP_HEADERS::AddHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    lpszHeaderName      - pointer to name of header to add, e.g. "Accept:"

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(*lpszHeaderName != '\0');
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    //
    // we may have been handed a header with a trailing colon. We don't care
    // for such nasty imagery
    //

    if (lpszHeaderName[dwHeaderNameLength - 1] == ':') {
        --dwHeaderNameLength;
    }

    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    DWORD i = 0;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = SlowFind(
                    NULL,
                    lpszHeaderName,
                    dwHeaderNameLength,
                    dwIndex,
                    dwHash,
                    &dwQueryIndex,
                    NULL
                    );

        if (dwSlot != ((DWORD) -1))
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }
    else
    {

        //
        // Check to verify that the header we're adding is a known header,
        //   If its a known header we use dwQueryIndex to update the known header array
        //   otherwise, IF ITS NOT, we make sure to set dwQueryIndex to INVALID_...
        //

        if (! HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwQueryIndex) )
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }

        /*
        // Perhaps this more efficent ???
        dwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

        if ( dwQueryIndex != 0 )
        {
            dwQueryIndex--;

            if ( ((int)dwHeaderNameLength < GlobalKnownHeaders[dwQueryIndex].Length) ||
                 strnicmp(lpszHeaderName,
                          GlobalKnownHeaders[dwQueryIndex].Text,
                          GlobalKnownHeaders[dwQueryIndex].Length) != 0)
            {
                dwQueryIndex = INVALID_HEADER_SLOT;
            }
        }
        else
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }
        */
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);

        if ( dwQueryIndex != INVALID_HEADER_SLOT )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));
        }

        error = ERROR_SUCCESS;
    }

Cleanup:
    UnlockHeaders();

quit:
    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::AddHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    INET_ASSERT(dwQueryIndex <= HTTP_QUERY_MAX);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD i = 0;
    LPSTR lpszHeaderName;
    DWORD dwHeaderNameLength;
    DWORD dwHash;

    dwHash             = GlobalKnownHeaders[dwQueryIndex].HashVal;
    lpszHeaderName     = GlobalKnownHeaders[dwQueryIndex].Text;
    dwHeaderNameLength = GlobalKnownHeaders[dwQueryIndex].Length;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = FastFind(
                    dwQueryIndex,
                    dwIndex
                    );

        if (dwSlot != INVALID_HEADER_SLOT)
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);
        freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));

        error = ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderName      - pointer to the header name

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to the header value

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderName[dwHeaderNameLength - 1] != ':');

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);
    DWORD dwSlot;
    DWORD dwQueryIndex;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                NULL,
                lpszHeaderName,
                dwHeaderNameLength,
                dwIndex,
                dwHash,
                &dwQueryIndex,
                &pbPrevByte
                );

    if ( dwSlot != ((DWORD) -1))
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            if ( dwQueryIndex != ((DWORD) -1) )
            {
                error = AddHeader(dwQueryIndex,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }
            else
            {
                error = AddHeader(lpszHeaderName,
                                  dwHeaderNameLength,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }


        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        if ( dwQueryIndex != ((DWORD) -1) )
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        }
        else
        {
            error = AddHeader(lpszHeaderName,
                              dwHeaderNameLength,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );

        }
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderValue     - pointer to the header value

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = FastNukeFind(
                dwQueryIndex,
                dwIndex,
                &pbPrevByte
                );

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        error = AddHeader(dwQueryIndex,
                          lpszHeaderValue,
                          dwHeaderValueLength,
                          0,
                          dwFlags
                          );
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Finds a request or response header

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FindHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));


    PERF_ENTER(FindHeader);



    INET_ASSERT(lpdwIndex != NULL);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    HEADER_STRING * pString;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                lpBase,
                lpszHeaderName,
                dwHeaderNameLength,
                *lpdwIndex,
                dwHash,
                &dwQueryIndex,
                NULL
                );

    if ( dwSlot != ((DWORD) -1) )
    {
        pString = &_lpHeaders[dwSlot];

        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        stringLen = pString->StringLength();

        INET_ASSERT(stringLen > dwHeaderNameLength);

        //
        // get a pointer to the value string
        //

        value = pString->StringAddress(lpBase) + dwHeaderNameLength;
        stringLen -= dwHeaderNameLength;

        //
        // the input string could be a substring of a different header
        //

        //INET_ASSERT(*value != ':');

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        do {
            ++value;
            --stringLen;
        } while ((stringLen > 0) && (*value == ' '));

        //
        // get the data in the format requested by the app
        //

        LPVOID lpData;
        DWORD dwDataSize;
        DWORD dwRequiredSize;
        SYSTEMTIME systemTime;
        DWORD number;

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME) {

            char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

            if (stringLen < sizeof(buf)) {

                //
                // value probably does not point at a zero-terminated string
                // which HttpDateToSystemTime() expects, so we make a copy
                // and terminate it
                //

                memcpy((LPVOID)buf, (LPVOID)value, stringLen);
                buf[stringLen] = '\0';
                if (HttpDateToSystemTime(buf, &systemTime)) {
                    lpData = (LPVOID)&systemTime;
                    dwRequiredSize = dwDataSize = sizeof(systemTime);
                } else {

                    //
                    // couldn't convert date/time. Presume header must be bogus
                    //

                    error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                    DEBUG_PRINT(HTTP,
                                ERROR,
                                ("cannot convert %.40q to SYSTEMTIME\n",
                                value
                                ));

                }
            } else {

                //
                // we would break the date/time buffer!
                //

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
            if (isdigit(*value)) {
                number = 0;
                for (int i = 0;
                    (stringLen > 0) && isdigit(value[i]);
                    ++i, --stringLen) {

                    number = number * 10 + (DWORD)(value[i] - '0');
                }
                lpData = (LPVOID)&number;
                dwRequiredSize = dwDataSize = sizeof(number);
            } else {

                //
                // not a numeric field. Request must be bogus for this header
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.20q to NUMBER\n",
                            value
                            ));

            }
        } else {
            lpData = (LPVOID)value;
            dwDataSize = stringLen;
            dwRequiredSize = dwDataSize + 1;
        }

        //
        // if error == ERROR_SUCCESS then we can attempt to copy the data
        //

        if (error == ERROR_SUCCESS) {
            if (*lpdwBufferLength < dwRequiredSize) {
                *lpdwBufferLength = dwRequiredSize;
                error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy(lpBuffer, lpData, dwDataSize);
                *lpdwBufferLength = dwDataSize;

                //
                // if dwRequiredSize > dwDataSize, then this is a variable-
                // length item (i.e. a STRING!) so we add a terminating '\0'
                //

                if (dwRequiredSize > dwDataSize) {

                    INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                    ((LPSTR)lpBuffer)[dwDataSize] = '\0';
                }

                //
                // successfully retrieved the requested header - bump the
                // index
                //

                ++*lpdwIndex;
            }
        }
    }

    UnlockHeaders();

quit:
    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )
/*++

Routine Description:

    Finds a request or response header, based on index to the header name we are searching for.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/
{

    DWORD error;
    LPSTR lpData;
    DWORD dwDataSize = 0;
    DWORD dwRequiredSize;
    SYSTEMTIME systemTime;
    DWORD number;

    error = FastFindHeader(
                lpBase,
                dwQueryIndex,
                (LPVOID *)&lpData,
                &dwDataSize,
                *lpdwIndex
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    //
    // get the data in the format requested by the app
    //

    if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

        if (dwDataSize < sizeof(buf))
        {

            //
            // value probably does not point at a zero-terminated string
            // which HttpDateToSystemTime() expects, so we make a copy
            // and terminate it
            //

            memcpy((LPVOID)buf, (LPVOID)lpData, dwDataSize);
            buf[dwDataSize] = '\0';
            if (HttpDateToSystemTime(buf, &systemTime)) {
                lpData = (LPSTR)&systemTime;
                dwRequiredSize = dwDataSize = sizeof(systemTime);
            } else {

                //
                // couldn't convert date/time. Presume header must be bogus
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.40q to SYSTEMTIME\n",
                            lpData
                            ));

            }
        }
        else
        {

            //
            // we would break the date/time buffer!
            //

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }
    else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER)
    {
        if (isdigit(*lpData)) {
            number = 0;
            for (int i = 0;
                (dwDataSize > 0) && isdigit(lpData[i]);
                ++i, --dwDataSize) {

                number = number * 10 + (DWORD)(lpData[i] - '0');
            }
            lpData = (LPSTR)&number;
            dwRequiredSize = dwDataSize = sizeof(number);
        } else {

            //
            // not a numeric field. Request must be bogus for this header
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("cannot convert %.20q to NUMBER\n",
                        lpData
                        ));

        }
    }
    else
    {
        dwRequiredSize = dwDataSize + 1;
    }

    //
    // if error == ERROR_SUCCESS then we can attempt to copy the data
    //

    if (error == ERROR_SUCCESS)
    {
        if (*lpdwBufferLength < dwRequiredSize)
        {
            *lpdwBufferLength = dwRequiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memcpy(lpBuffer, lpData, dwDataSize);
            *lpdwBufferLength = dwDataSize;

            //
            // if dwRequiredSize > dwDataSize, then this is a variable-
            // length item (i.e. a STRING!) so we add a terminating '\0'
            //

            if (dwRequiredSize > dwDataSize)
            {
                INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                ((LPSTR)lpBuffer)[dwDataSize] = '\0';
            }

            //
            // successfully retrieved the requested header - bump the
            // index
            //

            ++*lpdwIndex;
        }
    }
quit:

    return error;
}



DWORD
HTTP_HEADERS::FastFindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    OUT LPVOID *lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Finds a request or response header slightly quicker than its higher level
     cousin, FindHeader.   Unlike FindHeader this function simply returns
     a pointer and length, and does not copy header data.


    lpBase              - base address of strings

    dwQueryIndex        - a index into a array known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lplpBuffer          - pointer to pointer of the actual header to be returned in.

    lpdwBufferLength    - OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

    dwIndex             - a index of which header we're asking for, as there can be multiple headers
                          under the same name.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FastFindHeader",
                 "%q, %#x, %#x [%#x], %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwIndex
                 ));

    PERF_ENTER(FindHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    HEADER_STRING * curHeader;
    DWORD dwSlot;

    dwSlot = FastFind(dwQueryIndex, dwIndex);

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        curHeader = GetSlot(dwSlot);

        //
        // get a pointer to the value string
        //

        value     = curHeader->StringAddress(lpBase) + (GlobalKnownHeaders[dwQueryIndex].Length+1);
        stringLen = curHeader->StringLength() - (GlobalKnownHeaders[dwQueryIndex].Length+1);

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        while ((stringLen > 0) && (*value == ' '))
        {
            ++value;
            --stringLen;
        }

        //
        // get the data in the format requested by the app
        //

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        *lplpBuffer = (LPVOID)value;
        *lpdwBufferLength = stringLen;
    }

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::QueryRawHeaders(
    IN LPSTR lpBase,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock
--*/

{
    PERF_ENTER(QueryRawHeaders);

    DWORD error = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            DWORD length;

            length = _lpHeaders[i].StringLength();

            requiredLength += length + (bCrLfTerminated ? 2 : 1);
            if (*lpdwBufferLength > requiredLength) {
                _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                lpszBuffer += length;
                if (bCrLfTerminated) {
                    *lpszBuffer++ = '\r';
                    *lpszBuffer++ = '\n';
                } else {
                    *lpszBuffer++ = '\0';
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    UnlockHeaders();

    ++requiredLength;

    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
    }
    *lpdwBufferLength = requiredLength;

quit:
    PERF_LEAVE(QueryRawHeaders);

    return error;
}


DWORD
HTTP_HEADERS::QueryFilteredRawHeaders(
    IN LPSTR lpBase,
    IN LPSTR *lplpFilterList,
    IN DWORD cListElements,
    IN BOOL  fExclude,
    IN BOOL  fSkipVerb,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error = ERROR_NOT_SUPPORTED;

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;
    BOOL fCopy;

    DWORD i = fSkipVerb ? 1 : 0;
    for (; i < _TotalSlots; ++i) {
       if (_lpHeaders[i].HaveString()) {
          fCopy = TRUE;
          if (lplpFilterList
             && FMatchList(lplpFilterList, cListElements, _lpHeaders+i, lpBase)) {
             fCopy = fExclude?FALSE:TRUE;
          }
          if (fCopy) {
              DWORD length;

              length = _lpHeaders[i].StringLength();
              requiredLength += length + (bCrLfTerminated ? 2 : 1);
              if (*lpdwBufferLength > requiredLength) {
                    _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                   lpszBuffer += length;
                   if (bCrLfTerminated) {
                       *lpszBuffer++ = '\r';
                       *lpszBuffer++ = '\n';
                    } else {
                       *lpszBuffer++ = '\0';
                   }
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    ++requiredLength;


    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
HTTP_HEADERS::AddRequest(
    IN LPSTR lpszVerb,
    IN LPSTR lpszObject,
    IN LPSTR lpszVersion
    )

/*++

Routine Description:

    Builds the request line from its constituent parts. The request line is the
    first (0th) header in the request headers

    Assumes:    1. This is the one-and-only call to this method
                2. lpszObject must already be escaped if necessary

Arguments:

    lpszVerb    - pointer to HTTP verb, e.g. "GET"

    lpszObject  - pointer to HTTP object name, e.g. "/users/albert/~emc2.htm".

    lpszVersion - pointer to HTTP version string, e.g. "HTTP/1.0"

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    PERF_ENTER(AddRequest);

    //
    // there must not be a header when this method is called
    //

    INET_ASSERT(_HeadersLength == 0);

    DWORD error = ERROR_SUCCESS;
    int verbLen = lstrlen(lpszVerb);
    int objectLen = lstrlen(lpszObject);
    int versionLen = lstrlen(lpszVersion);
    int len = verbLen       // "GET"
            + 1             //     ' '
            + objectLen     //        "/users/albert/~emc2.htm"
            + 1             //                                 ' '
            + versionLen    //                                    "HTTP/1.0"
            + 1             //                                              '\0'
            ;

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!request.HaveString());

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    request.CreateStringBuffer((LPVOID)lpszVerb, verbLen, len);
    if (request.IsError()) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {
        request += ' ';
        request.Strncat((LPVOID)lpszObject, objectLen);
        request += ' ';
        request.Strncat((LPVOID)lpszVersion, versionLen);

        _HeadersLength = len - 1 + (sizeof("\r\n") - 1);

        //
        // we have used the first free slot in the headers array
        //

        --_FreeSlots;

        //
        // update the component variables in case of a ModifyRequest()
        //

        _lpszVerb = request.StringAddress();
        _dwVerbLength = verbLen;
        _lpszObjectName = _lpszVerb + verbLen + 1;
        _dwObjectNameLength = objectLen;
        _lpszVersion = _lpszObjectName + objectLen + 1;
        _dwVersionLength = versionLen;
        SetRequestVersion();
        error = request.IsError() ? ::GetLastError() : ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddRequest);

    return error;
}


DWORD
HTTP_HEADERS::ModifyRequest(
    IN HTTP_METHOD_TYPE tMethod,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength,
    IN LPSTR lpszVersion OPTIONAL,
    IN DWORD dwVersionLength
    )

/*++

Routine Description:

    Updates the request line. Used in redirection

Arguments:

    tMethod             - type of new method

    lpszObjectName      - pointer to new object name

    dwObjectNameLength  - length of new object name

    lpszVersion         - optional pointer to version string

    dwVersionLength     - length of lpszVersion string if present

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ModifyRequest",
                 "%s, %q, %d, %q, %d",
                 MapHttpMethodType(tMethod),
                 lpszObjectName,
                 dwObjectNameLength,
                 lpszVersion,
                 dwVersionLength
                 ));

    PERF_ENTER(ModifyRequest);

    INET_ASSERT(lpszObjectName != NULL);
    INET_ASSERT(dwObjectNameLength != 0);

    //
    // there must already be a header when this method is called
    //

    INET_ASSERT(_HeadersLength != 0);

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    //
    // BUGBUG [arthurbi] using two HEADER_STRINGs here causes an extra
    //  ReAlloc when use the Copy operator between the two.
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    HEADER_STRING newRequest;
    LPCSTR lpcszVerb;
    DWORD verbLength;
    DWORD error = ERROR_SUCCESS;
    DWORD length;

    //
    // there must already be a request line
    //

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    //
    // get the verb/method to use.
    //

    if (tMethod == HTTP_METHOD_TYPE_UNKNOWN) {

        //
        // the method is unknown, read the old one out of the string
        //  and save off, basically we're reusing the previous one.
        //

        lpcszVerb = request.StringAddress();

        for (DWORD i = 0; i < request.StringLength(); i++) {
            if (lpcszVerb[i] == ' ') {
                break;
            }
        }

        INET_ASSERT((i > 0) && (i < (DWORD)request.StringLength()));

        verbLength = (DWORD)i;
    } else {

        //
        // its one of the normal kind, just map it.
        //

        verbLength = MapHttpMethodType(tMethod, &lpcszVerb);
    }
    if (lpszVersion == NULL) {
        lpszVersion = _lpszVersion;
        dwVersionLength = _dwVersionLength;
    }

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    //
    // calculate the new length from the component lengths we originally set
    // in AddRequest(), and the new object name
    //

    length = verbLength + 1 + dwObjectNameLength + 1 + dwVersionLength + 1;

    //
    // create a new request line
    //

    newRequest.CreateStringBuffer((LPVOID)lpcszVerb, verbLength, length);
    if (newRequest.IsError()) {
        error = GetLastError();
    } else {
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszObjectName, dwObjectNameLength);
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszVersion, dwVersionLength);

        //
        // remove the current request line length from the header buffer
        // aggregate
        //

        _HeadersLength -= request.StringLength();

        //
        // make the current request line the new one
        //

        request = newRequest.StringAddress();

        //
        // and update the address and length variables (version length is the
        // only thing that stays the same)
        //

        if (!request.IsError()) {
            _lpszVerb = request.StringAddress();
            _dwVerbLength = verbLength;
            _lpszObjectName = _lpszVerb + verbLength + 1;
            _dwObjectNameLength = dwObjectNameLength;
            _lpszVersion = _lpszObjectName + dwObjectNameLength + 1;
            _dwVersionLength = dwVersionLength;
            SetRequestVersion();

        //
        // and the new request line length to the aggregate header length
        //

            _HeadersLength += request.StringLength();
        } else {
            error = GetLastError();
        }
    }

quit:

    PERF_LEAVE(ModifyRequest);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::SetRequestVersion(
    VOID
    )

/*++

Routine Description:

    Set _RequestVersionMajor and _RequestVersionMinor based on the HTTP
    version string

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::SetRequestVersion",
                 NULL
                 ));

    INET_ASSERT(_lpszVersion != NULL);

    _RequestVersionMajor = 0;
    _RequestVersionMinor = 0;
    if (strncmp(_lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR pNum = _lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMajor);
        while (!isdigit(*pNum) && (*pNum != '\0')) {
            ++pNum;
        }
        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMinor);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("request version = %d.%d\n",
                    _RequestVersionMajor,
                    _RequestVersionMinor
                    ));

    } else {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("\"HTTP/\" not found in %q\n",
                    _lpszVersion
                    ));

    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\httpp.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httpp.h

Abstract:

    Private master include file for the HTTP API project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

//
//  Local include files.
//

#include "proc.h"
#include "headers.h"

extern
BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\cookiejar.h ===
#ifndef _COOKIE_JAR_H_
#define _COOKIE_JAR_H_

#include <wininetp.h>
#include "httpp.h"

//---------------------------------------------------------------------------
//
// CCookieBase
//
// Provides operator new which allocates extra memory
// after object and initializes the memory to zero.
//
//---------------------------------------------------------------------------

class CCookieBase
{
public:

    void * operator new(size_t cb, size_t cbExtra);
    void operator delete(void *pv);
};

//---------------------------------------------------------------------------
//
// CCookie
//
// Holds a single cookie value.
//
//---------------------------------------------------------------------------


class CCookie : public CCookieBase
{
public:

    ~CCookie();
    static CCookie *Construct(const char *pchName);

    BOOL            SetValue(const char *pchValue);
    BOOL            CanSend(BOOL fSecure);
    BOOL            IsPersistent() { return (_dwFlags & COOKIE_SESSION) == 0; }

    BOOL            PurgeAll(void *);

    DWORD           _dwFlags;
    CCookie *       _pCookieNext;
    char *          _pchName;
    char *          _pchValue;
    FILETIME        _ftExpiry;
};

//---------------------------------------------------------------------------
//
// CCookieLocation
//
// Holds all cookies for a given domain and path.
//
//---------------------------------------------------------------------------

class CCookieLocation : public CCookieBase
{
public:

    ~CCookieLocation();
    static CCookieLocation *Construct(const char *pchRDomain, const char *pchPath);

    CCookie *       GetCookie(const char *pchName, BOOL fCreate);
    BOOL            ReadCacheFile();
    BOOL            ReadCacheFileIfNeeded();
    void            Purge(BOOL (CCookie::*)(void *), void *);
    BOOL            IsMatch(const char *pchRDomain, const char *pchPath);

    FILETIME        _ftCacheFileLastModified;
    CCookie *       _pCookieKids;
    CCookieLocation*_pLocationNext;
    char *          _pchRDomain;
    char *          _pchPath;
    int             _cchPath;
    BYTE            _fReadFromCacheFileNeeded;
};


//---------------------------------------------------------------------------
//
// CCookieJar
//
// Maintains fixed size hash table of cookie location objects.
//
//---------------------------------------------------------------------------
enum SET_COOKIE_RESULT
{
    SET_COOKIE_FAIL     = 0,
    SET_COOKIE_SUCCESS  = 1,
    SET_COOKIE_DISALLOW = 2,
    SET_COOKIE_PENDING  = 3
};

class CCookieJar : public CCookieBase
{
public:

    static CCookieJar * Construct();

     CCookieJar();
    ~CCookieJar();

    DWORD             SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags);
    CCookieLocation*  GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime);

    void              Purge();
    CCookieLocation** GetBucket(const char *pchRDomain);
    CCookieLocation * GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate);
    void              Serialize(HANDLE hCookieFile);

    enum { htsize=32 };
    CCookieLocation * _apLocation[htsize];

    CCritSec          _csCookieJar;

private:
   void serializeCookie(const CCookie *pCookie, HANDLE hCookieFile, const char *pchDomain, const char *pchPath);
   void expireCookies(CCookieLocation *pLocation, FILETIME *ftRefTime);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\headers.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Contents:

        HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer
        HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader
        HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText
        HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName
        HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders
        MapHttpMethodType
        CreateEscapedUrlPath
        (CalculateHashNoCase)
Author:

    Richard L Firth (rfirth) 20-Dec-1995

Revision History:

    20-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

VOID
HTTP_REQUEST_HANDLE_OBJECT::ReplaceStatusHeader(
    IN LPCSTR lpszStatus
    )
/*
Description:
    Replace the status line in a header (eg. "200 OK") with the specified text.
Arguments:
    lpszStatus	- Status text (eg. "200 OK")
Return Value:
    None
*/
{
    LockHeaders();
    
    //INET_ASSERT (!_CacheWriteInProgress);
    
    LPSTR pszHeader = _ResponseHeaders.GetHeaderPointer(_ResponseBuffer, 0);
    
    INET_ASSERT(pszHeader);
    
    LPSTR pszStatus = StrChr (pszHeader, ' ');
    SKIPWS(pszStatus);
    
    INET_ASSERT (!memcmp(pszStatus, "206", 3));
    
    memcpy(pszStatus, lpszStatus, lstrlen(lpszStatus)+1);
    _ResponseHeaders.ShrinkHeader(_ResponseBuffer, 0,
        HTTP_QUERY_STATUS_TEXT, HTTP_QUERY_STATUS_TEXT,
        (DWORD) (pszStatus - pszHeader) + lstrlen(lpszStatus));
    
    UnlockHeaders();
}


LPSTR
HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer(
    OUT LPDWORD lpdwRequestLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN BOOL bExtraCrLf,
    IN DWORD dwMaxPacketLength,
    OUT LPBOOL lpbCombinedData
    )

/*++

Routine Description:

    Creates a request buffer from the HTTP request and headers

Arguments:

    lpdwRequestLength   - pointer to returned buffer length

    lpOptional          - pointer to optional data

    dwOptionalLength    - length of optional data

    bExtraCrLf          - TRUE if we need to add additional CR-LF to buffer

    dwMaxPacketLength   - maximum length of buffer

    lpbCombinedData     - output TRUE if data successfully combined into one

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer",
                 "%#x, %#x, %d, %B, %d, %#x",
                 lpdwRequestLength,
                 lpOptional,
                 dwOptionalLength,
                 bExtraCrLf,
                 dwMaxPacketLength,
                 lpbCombinedData
                 ));

    PERF_ENTER(CreateRequestBuffer);

    LPSTR requestBuffer = NULL;

    *lpbCombinedData = FALSE;

    if (!_RequestHeaders.LockHeaders())
    {
        goto quit;
    }

    DWORD headersLength;
    DWORD requestLength;
    DWORD optionalLength;
    HEADER_STRING * pRequest = _RequestHeaders.GetFirstHeader();
    HEADER_STRING & request = *pRequest;
/*
    WCHAR wszUrl[1024];
    LPWSTR pwszUrl = NULL;
    BYTE utf8Url[2048];
    LPBYTE pbUrl = NULL;
*/
    LPSTR pszObject = _RequestHeaders.ObjectName();
    DWORD dwObjectLength = _RequestHeaders.ObjectNameLength();

    if (pRequest == NULL) {
        goto Cleanup;
    }

    INET_ASSERT(request.HaveString());

    headersLength = _RequestHeaders.HeadersLength();
    requestLength = headersLength + (sizeof("\r\n") - 1);

/*------------------------------------------------------------------
    GlobalEnableUtf8Encoding = FALSE;
    if (GlobalEnableUtf8Encoding
        && StringContainsHighAnsi(pszObject, dwObjectLength)) {

        pwszUrl = wszUrl;

        DWORD arrayElements = ARRAY_ELEMENTS(wszUrl);

        if (dwObjectLength > ARRAY_ELEMENTS(wszUrl)) {
            arrayElements = dwObjectLength;
            pwszUrl = (LPWSTR)ALLOCATE_FIXED_MEMORY(arrayElements * sizeof(*pwszUrl));
            if (pwszUrl == NULL) {
                goto utf8_cleanup;
            }
        }



        PFNINETMULTIBYTETOUNICODE pfnMBToUnicode;
        pfnMBToUnicode = GetInetMultiByteToUnicode( );
        if (pfnMBToUnicode == NULL) {
            goto utf8_cleanup;
        }

        HRESULT hr;
        DWORD dwMode;
        INT nMBChars;
        INT nWChars;

        nMBChars = dwObjectLength;
        nWChars = arrayElements;
        dwMode = 0;

        hr = pfnMBToUnicode(&dwMode,
                                GetCodePage(),
                                pszObject,
                                &nMBChars,
                                pwszUrl,
                                &nWChars
                               );
        if (hr != S_OK || nWChars == 0) {
            goto utf8_cleanup;
        }

        DWORD nBytes;

        nBytes = CountUnicodeToUtf8(pwszUrl, (DWORD)nWChars, TRUE);
        pbUrl = utf8Url;
        if (nBytes > ARRAY_ELEMENTS(utf8Url)) {
            pbUrl = (LPBYTE)ALLOCATE_FIXED_MEMORY(nBytes);
            if (pbUrl == NULL) {
                goto utf8_cleanup;
            }
        }

        DWORD error;

        error = ConvertUnicodeToUtf8(pwszUrl,
                                     (DWORD)nWChars,
                                     pbUrl,
                                     nBytes,
                                     TRUE
                                     );

        INET_ASSERT(error == ERROR_SUCCESS);

        if (error != ERROR_SUCCESS) {
            goto utf8_cleanup;
        }

        requestLength = requestLength - dwObjectLength + nBytes;
        headersLength = headersLength - dwObjectLength + nBytes;
        pszObject = (LPSTR)pbUrl;
        dwObjectLength = nBytes;
        goto after_utf8;

utf8_cleanup:

        if ((pwszUrl != wszUrl) && (pwszUrl != NULL)) {
            FREE_MEMORY(pwszUrl);
        }
        pwszUrl = NULL;
        if ((pbUrl != utf8Url) && (pbUrl != NULL)) {
            FREE_MEMORY(pbUrl);
        }
        pbUrl = NULL;
        pszObject = NULL;
        dwObjectLength = 0;
    }

after_utf8:
------------------------------------------------------------------*/

    optionalLength = (DWORD)(dwOptionalLength + (bExtraCrLf ? (sizeof("\r\n") - 1) : 0));
    if (requestLength + optionalLength <= dwMaxPacketLength) {
        requestLength += optionalLength;
    } else {
        optionalLength = 0;
        bExtraCrLf = FALSE;
    }

    requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    if (requestBuffer != NULL) {
        if (optionalLength != 0) {
            *lpbCombinedData = TRUE;
        }
    } else if (optionalLength != 0) {
        requestLength = headersLength + (sizeof("\r\n") - 1);
        optionalLength = 0;
        bExtraCrLf = FALSE;
        requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    }
    if (requestBuffer != NULL) {

        LPSTR buffer = requestBuffer;

        //
        // copy the headers. Remember: header 0 is the request
        //

        if (ERROR_SUCCESS != _RequestHeaders.CopyHeaders(&buffer, pszObject, dwObjectLength))
        {
            ResizeBuffer(requestBuffer, 0, FALSE);
            requestBuffer = buffer = NULL;
            goto Cleanup;
        }

        //
        // terminate the request
        //

        *buffer++ = '\r';
        *buffer++ = '\n';

        if (optionalLength != 0) {
            if (dwOptionalLength != 0) {
                memcpy(buffer, lpOptional, dwOptionalLength);
                buffer += dwOptionalLength;
            }
            if (bExtraCrLf) {
                *buffer++ = '\r';
                *buffer++ = '\n';
            }
        }

        INET_ASSERT((SIZE_T)(buffer-requestBuffer) == requestLength);

        *lpdwRequestLength = requestLength;

    }

Cleanup:

    _RequestHeaders.UnlockHeaders();

    DEBUG_PRINT(HTTP,
                INFO,
                ("request length = %d, combined = %B\n",
                *lpdwRequestLength,
                *lpbCombinedData
                ));

/*
    if ((pbUrl != NULL) && (pbUrl != utf8Url)) {
        FREE_MEMORY(pbUrl);
    }
    if ((pwszUrl != NULL) && (pwszUrl != wszUrl)) {
        FREE_MEMORY(pwszUrl);
    }
*/

quit:
    PERF_LEAVE(CreateRequestBuffer);

    DEBUG_LEAVE(requestBuffer);

    return requestBuffer;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results
                    
                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN DWORD dwQueryIndex,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results
                    
                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%u, %#x [%#x], %#x, %#x [%d]",
                 dwQueryIndex,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       dwQueryIndex,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader(
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )

/*++

Routine Description:

    Adds a created response header to the response header array. Unlike normal
    response headers, this will be a pointer to an actual string, not an offset
    into the response buffer.

    Even if the address of the response buffer changes, created response headers
    will remain fixed

    N.B. The header MUST NOT have a CR-LF terminator
    N.B.-2 This function must be called under the header lock.

Arguments:

    dwHeaderIndex   - index into header value we are actually creating

    lpszHeader      - pointer to created (internal) header to add

    dwHeaderLength  - length of response header, or -1 if ASCIIZ

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddInternalResponseHeader",
                 "%u [%q], %q, %d",
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text,
                 lpszHeader,
                 dwHeaderLength
                 ));

    DWORD error;

    if (dwHeaderLength == (DWORD)-1) {
        dwHeaderLength = lstrlen(lpszHeader);
    }

    INET_ASSERT((lpszHeader[dwHeaderLength - 1] != '\r')
                && (lpszHeader[dwHeaderLength - 1] != '\n'));

    //
    // find the next slot for this header
    //

    HEADER_STRING * freeHeader;

    //
    // if we already have all the headers (the 'empty' header is the last one
    // in the array) then change the last header to be the one we are adding
    // and add a new empty header, else just add this one
    //

    DWORD iSlot;
    freeHeader = _ResponseHeaders.FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        error = _ResponseHeaders.GetError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {

        HEADER_STRING * lastHeader;

        lastHeader = _ResponseHeaders.GetEmptyHeader();
        if (lastHeader != NULL) {

            //
            // make copy of last header - its an offset string
            //

            *freeHeader = *lastHeader;

            //
            // use what was last header as free header
            //

            freeHeader = lastHeader;
        }
        freeHeader->MakeCopy(lpszHeader, dwHeaderLength);
        freeHeader->SetNextKnownIndex(_ResponseHeaders.FastAdd(dwHeaderIndex, iSlot));
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders(
    IN OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Given the next chunk of the response, updates the response headers. The
    buffer pointer, buffer length and number of bytes received values are all
    maintained in this object (_ResponseBuffer, _ResponseBufferLength and
    _BytesReceived, resp.)

Arguments:

    lpbEof  - IN: TRUE if we have reached the end of the response
              OUT: TRUE if we have reached the end of the response or the end
                   of the headers

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders",
                 "%#x [%.*q], %d, %d, %#x [%B]",
                 _ResponseBuffer + _ResponseScanned,
                 min(_ResponseBufferLength + 1, 80),
                 _ResponseBuffer + _ResponseScanned,
                 _ResponseBufferLength,
                 _BytesReceived,
                 lpbEof,
                 *lpbEof
                 ));

    PERF_ENTER(UpdateResponseHeaders);

    LPSTR lpszBuffer = (LPSTR)_ResponseBuffer + _ResponseScanned;
    DWORD dwBytesReceived = _BytesReceived - _ResponseScanned;
    DWORD error = ERROR_SUCCESS;
    BOOL  success = TRUE;
    HEADER_STRING * statusLine;

    //
    // lock down the response headers for the duration of this request. The only
    // way another thread is going to wait on this lock is if the reference on
    // the HTTP request object goes to zero, which *shouldn't* happen
    //

    if (!_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // if we don't yet know whether we have a HTTP/1.0 (or greater) or HTTP/0.9
    // response yet, then try to find out.
    //
    // Only responses greater than HTTP/0.9 start with the "HTTP/#.#" string
    //

    if (!IsDownLevel() && !IsUpLevel()) {

        if ((dwBytesReceived < sizeof("Secure-HTTP/")) && !*lpbEof) {
            goto done;
        }

#define MAKE_VERSION_ENTRY(string)  string, sizeof(string) - 1

        static struct {
            LPSTR Version;
            DWORD Length;
        } KnownVersionsStrings[] = {
            MAKE_VERSION_ENTRY("HTTP/"),
            MAKE_VERSION_ENTRY("S-HTTP/"),
            MAKE_VERSION_ENTRY("SHTTP/"),
            MAKE_VERSION_ENTRY("Secure-HTTP/"),

            //
            // allow for servers generating slightly off-the-wall responses
            //

            MAKE_VERSION_ENTRY("HTTP ")
        };

#define NUM_HTTP_VERSIONS   ARRAY_ELEMENTS(KnownVersionsStrings)

        //
        // We know this is the start of a HTTP response, but there may be some
        // noise at the start from bad HTML authoring, or bad content-length on
        // the previous response on a keep-alive connection. We will try to sync
        // up to the HTTP header (we will only look for this - I have never seen
        // any of the others, and I doubt its worth the increased complexity and
        // processing time)
        //

        LPSTR lpszBuf;
        DWORD bytesLeft;
        BOOL bFoundStart;

        lpszBuf = lpszBuffer;
        bytesLeft = dwBytesReceived;
        bFoundStart = FALSE;

        do {
            while ((bytesLeft > 0) && (*lpszBuf != 'H') && (*lpszBuf != 'h')) {
                ++lpszBuf;
                --bytesLeft;
                ++_ResponseScanned;
            }
            if (bytesLeft == 0) {
                break;
            }

            //
            // scan for the known version strings
            //

            for (int i = 0; i < NUM_HTTP_VERSIONS; ++i) {

                LPSTR version = KnownVersionsStrings[i].Version;
                DWORD length = KnownVersionsStrings[i].Length;

                if ((bytesLeft >= length)

                //
                // try the most common case as a direct comparison. memcmp()
                // should expand to cmpsd && cmpsb on x86 (most common platform
                // and one on which we are most interested in improving perf)
                //

                && (((i == 0)
                    && (memcmp(lpszBuf, "HTTP/", sizeof("HTTP/") - 1) == 0))
                    //&& (lpszBuf[0] == 'H')
                    //&& (lpszBuf[1] == 'T')
                    //&& (lpszBuf[2] == 'T')
                    //&& (lpszBuf[3] == 'P')
                    //&& (lpszBuf[4] == '/'))

                //
                //  "Clients should be tolerant in parsing the Status-Line"
                //  quote from HTTP/1.1 spec, therefore we perform a
                //  case-insensitive string comparison here
                //

                || (_strnicmp(lpszBuf, version, length) == 0))) {

                    //
                    // it starts with one of the recognized protocol version strings.
                    // We assume its not a down-level server, although it could be,
                    // sending back a plain text document that has e.g. "HTTP/1.0..."
                    // at its start
                    //
                    // According to the HTTP "spec", though, it is mentioned that 0.9
                    // servers typically only return HTML, hence we shouldn't see
                    // even a 0.9 response start with non-HTML data
                    //

                    SetUpLevel(TRUE);

                    //
                    // we have start of this response
                    //

                    lpszBuffer = lpszBuf;
                    bFoundStart = TRUE;
                    break;
                }
            }

            //
            // if we didn't find the start of the HTTP response then search again
            //

            if (!bFoundStart) {
                ++lpszBuf;
                --bytesLeft;
                ++_ResponseScanned;
            }
        } while (!bFoundStart && (bytesLeft > 0));

        //
        // if we didn't find a recognizable HTTP 1.x response then we assume its
        // a down-level response
        //

        if (!IsUpLevel()) {

            //
            // if we didn't find the start of a valid HTTP response and we have
            // not filled the response buffer or hit the end of the connection
            // then quit so we can get the next packet
            //

            if ((_BytesReceived < _ResponseBufferLength) && !IsEof()) {

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("Didn't find start of response. Try again\n"
                            ));

//dprintf("*** didn't find start of response. Try again\n");
                goto done;
            }

            //
            // this may be a real down-level server, or it may be the response
            // from an FTP or gopher server via a proxy, in which case there
            // will be no headers. We will add some default headers to make
            // life easier for higher level software
            //

            AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                      "HTTP/1.0 200 OK",
                                      sizeof("HTTP/1.0 200 OK") - 1
                                      );
            _StatusCode = HTTP_STATUS_OK;
            //SetDownLevel(TRUE);

            //
            // we're now ready for the app to start reading data out
            //

            SetData(TRUE);

            //
            // down-level server: we're done
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Server is down-level\n"
                        ));

            goto done;
        }
    }

    //
    // this stuff's only for uplevel responses, sorry
    //

    INET_ASSERT(IsUpLevel());

    //
    // Note: at this point we can't store pointers into the response buffer
    // because it might move during a subsequent reallocation. We have to
    // maintain offsets into the buffer and convert to pointers when we come to
    // read the data out of the buffer (when the response is complete, or at
    // least we've finished receiving headers)
    //

    //
    // if we haven't checked the response yet, then the first thing to
    // get is the status line
    //

    statusLine = GetStatusLine();

    if (statusLine == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (!statusLine->HaveString())
    {
        int majorVersion = 0;
        int minorVersion = 0;
        BOOL fSupportsHttp1_1;

        _StatusCode = 0;

        //
        // find the status line
        //

        success = _ResponseHeaders.ParseStatusLine(
            (LPSTR)_ResponseBuffer,
            _BytesReceived,
            IsEof(),
            &_ResponseScanned,
            &_StatusCode,
            (LPDWORD)&majorVersion,
            (LPDWORD)&minorVersion
            );

        if ( !success )
        {
            error = ERROR_SUCCESS;
            goto Cleanup;
        }


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Version = %d.%d\n",
                    majorVersion,
                    minorVersion
                    ));

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_StatusCode = %d\n",
                    _StatusCode
                    ));

        fSupportsHttp1_1 = FALSE;

        if ( majorVersion > 1 )
        {
            //
            // for higher version servers, the 1.1 spec dictates
            //  that we return the highest version the client
            //  supports, and in our case that is 1.1.
            //

            fSupportsHttp1_1 = TRUE;
        }
        else if ( majorVersion == 1 )
        {
            if ( minorVersion >= 1 )
            {
                fSupportsHttp1_1 = TRUE;
            }
        } else if ((majorVersion < 0) || (minorVersion < 0)) {
            error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            goto Cleanup;
        }

        SetResponseHttp1_1(fSupportsHttp1_1);

        //
        // record the server HTTP version in the server info object
        //

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo != NULL) {
            if (fSupportsHttp1_1) {
                pServerInfo->SetHttp1_1();

                //
                // Set the max connections per HTTP 1.1 server.
                //
                pServerInfo->SetNewLimit(GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_SERVER));
            } else {
                pServerInfo->SetHttp1_0();

                //
                // Set the max connections per HTTP 1.0 server.
                //
                pServerInfo->SetNewLimit(GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER));
            }
        }

        if (_StatusCode == 0) {

            //
            // BUGBUG [arthurbi] malformed header, should we really just accept it?
            //      what if we get indeterminate garbage?
            //


            INET_ASSERT(FALSE);

            AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                          "HTTP/1.0 200 OK",
                          sizeof("HTTP/1.0 200 OK") - 1
                          );
            _StatusCode = HTTP_STATUS_OK;
            error = ERROR_SUCCESS;

            goto Cleanup;
        }
    }

    //
    // continue scanning headers here until we have tested all the current
    // buffer, or we have found the start of the data
    //

    BOOL fFoundEndOfHeaders;

    error = _ResponseHeaders.ParseHeaders(
                (LPSTR)_ResponseBuffer,
                _BytesReceived,
                IsEof(),
                &_ResponseScanned,
                &success,
                &fFoundEndOfHeaders
                );

    if ( error != ERROR_SUCCESS )
    {
        goto Cleanup;
    }


    if ( fFoundEndOfHeaders )
    {
        //
        // we found the end of the headers
        //

        SetEof(TRUE);

        //
        // and the start of the data
        //

        SetData(TRUE);
        _DataOffset = _ResponseScanned;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of headers. _DataOffset = %d\n",
                    _DataOffset
                    ));

    }

done:

    //
    // if we have reached the end of the headers then we communicate this fact
    // to the caller
    //

    if (IsData() || IsEof()) {
        error = CheckWellKnownHeaders();
        if (ERROR_SUCCESS != error)
        {
            goto Cleanup;
        }
        *lpbEof = TRUE;

        /*

        Set connection persistency based on these rules:

        persistent = (1.0Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.1Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.0Request && Con: K-A && 1.1Response && Con: K-A)
                     || (1.1Request && !Con: Close && 1.1Response && !Con: Close)

        therefore,

        persistent = 1.1Request && 1.1Response
                        ? (!Con: Close in request || response)
                        : Con: K-A in request && response

        */

        if (IsRequestHttp1_1() && IsResponseHttp1_1()) {

            BOOL bHaveConnCloseRequest;

            bHaveConnCloseRequest = FindConnCloseRequestHeader(
                                        IsRequestUsingProxy()
                                            ? HTTP_QUERY_PROXY_CONNECTION
                                            : HTTP_QUERY_CONNECTION
                                            );
            if (!(IsConnCloseResponse() || bHaveConnCloseRequest)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 persistent connection\n"
                            ));

                SetKeepAlive(TRUE);
                SetPersistentConnection(IsRequestUsingProxy()
                                        && !IsTalkingToSecureServerViaProxy()
                                        );
            } else {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 non-persistent connection: close on: request: %B; response: %B\n",
                            bHaveConnCloseRequest,
                            IsConnCloseResponse()
                            ));

                SetKeepAlive(FALSE);
                SetNoLongerKeepAlive();
                ClearPersistentConnection();
            }
        }
    }

Cleanup:

    //
    // we are finished updating the response headers (no other thread should be
    // waiting for this if the reference count and object state is correct)
    //

    _ResponseHeaders.UnlockHeaders();

quit:
    PERF_LEAVE(UpdateResponseHeaders);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders(
    IN OUT LPSTR* ppszBuffer,
    IN DWORD      dwBufferLength
    )

/*++

Routine Description:

    Create the response headers given a buffer containing concatenated headers.
    Called when we are creating this object from the cache

Arguments:

    lpszBuffer      - pointer to buffer containing headers

    dwBufferLength  - length of lpszBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create headers

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders",
                 "%.32q, %d",
                 ppszBuffer,
                 dwBufferLength
                 ));

    //
    // there SHOULD NOT already be a response buffer if we're adding an
    // external buffer
    //

    INET_ASSERT(_ResponseBuffer == NULL);

    DWORD error;
    BOOL eof = FALSE;

    _ResponseBuffer = (LPBYTE) *ppszBuffer;
    _ResponseBufferLength = dwBufferLength;
    _BytesReceived = dwBufferLength;
    error = UpdateResponseHeaders(&eof);
    if (error != ERROR_SUCCESS) {

        //
        // if we failed, we will clean up our variables including clearing
        // out the response buffer address and length, but leave freeing
        // the buffer to the caller
        //

        _ResponseBuffer = NULL;
        _ResponseBufferLength = 0;
        ResetResponseVariables();

    } else {

        //
        // Success - the object owns the buffer so the caller should not free.
        //

        *ppszBuffer = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the HTTP version string from the status line

Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryResponseVersion);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR string;
    DWORD length;

    //
    // get a pointer into the response buffer where the status line starts
    // and its length
    //

    string = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    length = (DWORD)statusLine->StringLength();

    //
    // the version string is the first token on the line, delimited by spaces
    //

    DWORD index;

    for (index = 0; index < length; ++index) {

        //
        // we'll also check for CR and LF, although just space should be
        // sufficient
        //

        if ((string[index] == ' ')
        || (string[index] == '\r')
        || (string[index] == '\n')) {
            break;
        }
    }
    if (*lpdwBufferLength > index) {
        memcpy(lpBuffer, (LPVOID)string, index);
        ((LPSTR)lpBuffer)[index] = '\0';
        *lpdwBufferLength = index;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = index + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryResponseVersion);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Returns the status code as a string or a number

Arguments:

    lpBuffer            - pointer to buffer where results written

    lpdwBufferLength    - IN: length of buffer
                          OUT: size of returned information, or required size'
                               of buffer

    dwModifiers         - flags which modify returned value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusCode);

    DWORD error;
    DWORD requiredSize;

    if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
        requiredSize = sizeof(_StatusCode);
        if (*lpdwBufferLength >= requiredSize) {
            *(LPDWORD)lpBuffer = _StatusCode;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        //
        // the number should always be only 3 characters long, but we'll be
        // flexible (just in case)
        //

        char numBuf[sizeof("4294967296")];

        requiredSize = wsprintf(numBuf, "%u", _StatusCode) + 1;

#ifdef DEBUG
        // Debug check to make sure everything is good because the above
        // used to be ultoa.
        char debugBuf[sizeof("4294967296")];
        ultoa(_StatusCode, debugBuf, 10);
        if (strcmp(debugBuf,numBuf))
        {
            INET_ASSERT(FALSE);
        }

        INET_ASSERT(requiredSize == lstrlen(numBuf) + 1);
#endif

        if (*lpdwBufferLength >= requiredSize) {
            memcpy(lpBuffer, (LPVOID)numBuf, requiredSize);
            *lpdwBufferLength = requiredSize - 1;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    PERF_LEAVE(QueryStatusCode);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the status text - if any - returned by the server in the status line

Arguments:

    lpBuffer            - pointer to buffer where status text is written

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: length of the status text string minus 1 for the
                               '\0', or the required buffer length if we return
                               ERROR_INSUFFICIENT_BUFFER

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusText);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR str;
    DWORD len;

    //
    // find the third token on the status line. The status line has the form
    //
    //  "HTTP/1.0 302 Try again\r\n"
    //
    //   ^        ^   ^
    //   |        |   |
    //   |        |   +- status text
    //   |        +- status code
    //   +- version
    //

    str = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    len = statusLine->StringLength();

    DWORD i;

    i = 0;

    int j;

    for (j = 0; j < 2; ++j) {
        while ((i < len) && (str[i] != ' ')) {
            ++i;
        }
        while ((i < len) && (str[i] == ' ')) {
            ++i;
        }
    }
    len -= i;
    if (*lpdwBufferLength > len) {
        memcpy(lpBuffer, (LPVOID)&str[i], len);
        ((LPSTR)lpBuffer)[len] = '\0';
        *lpdwBufferLength = len;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = len + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryStatusText);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders(
    IN BOOL bCrLfTerminated,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the raw response headers

Arguments:

    bCrLfTerminated     - TRUE if we want RAW_HEADERS_CRLF else RAW_HEADERS

    lpBuffer            - pointer to buffer where headers returned

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: returned length of lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRawHeaders",
                 "%B, %#x, %#x [%d]",
                 bCrLfTerminated,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength
                 ));

    PERF_ENTER(QueryRawHeaders);

    DWORD error = _ResponseHeaders.QueryRawHeaders(
                    (LPSTR)_ResponseBuffer,
                    bCrLfTerminated,
                    lpBuffer,
                    lpdwBufferLength
                    );

    IF_DEBUG_CODE() {
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        }
    }

    PERF_LEAVE(QueryRawHeaders);

    DEBUG_LEAVE(error);

    return error;

}


VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName(
    IN DWORD dwQueryIndex
    )

/*++

Routine Description:

    Removes all headers of a particular type from the request object

Arguments:

    lpszHeaderName  - name of header to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "RemoveAllRequestHeadersByName",
                 "%q, %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex
                 ));

    PERF_ENTER(RemoveAllRequestHeadersByName);

    _RequestHeaders.RemoveAllByIndex(dwQueryIndex);

    PERF_LEAVE(RemoveAllRequestHeadersByName);

    DEBUG_LEAVE(0);
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders(
    VOID
    )

/*++

Routine Description:

    Tests for a couple of well-known headers that are important to us as well as
    the app:

        "Connection: Keep-Alive"
        "Proxy-Connection: Keep-Alive"
        "Connection: Close"
        "Proxy-Connection: Close"
        "Transfer-Encoding: chunked"
        "Content-Length: ####"
        "Content-Range: bytes ####-####/####"

    The header DOES NOT contain CR-LF. That is, dwHeaderLength will not include
    any counts for line termination

    We need to know if the server honoured a request for a keep-alive connection
    so that we don't try to receive until we hit the end of the connection. The
    server will keep it open.

    We need to know the content length if we are talking over a persistent (keep
    alive) connection.

    If either header is found, we set the corresponding flag in the HTTP_HEADERS
    object, and in the case of "Content-Length:" we parse out the length.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders",
                 NULL
                 ));

    DWORD dwError = ERROR_SUCCESS;

    //
    // check for "Content-Length:"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_LENGTH) )
    {
        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;

        DWORD iSlotContentLength = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_LENGTH];
        curHeader = _ResponseHeaders.GetSlot(iSlotContentLength);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            --dwHeaderLength;
            ++lpszHeader;
        }
        while (dwHeaderLength && isdigit(*lpszHeader)) {
            _ContentLength = _ContentLength * 10 + (*lpszHeader - '0');
            --dwHeaderLength;
            ++lpszHeader;
        }

        //
        // once we have _ContentLength, we don't modify it (unless
        // we fix it up when using a 206 partial response to resume
        // a partial download.)  The header value should be returned
        // by HttpQueryInfo().  Instead, we keep account of the
        // amount of keep-alive data left to copy in _BytesRemaining
        //

        _BytesRemaining = _ContentLength;

        //
        // although we said we may be one past the end of the header, in
        // reality, if we received a buffer with "Content-Length:" then we
        // expect it to be terminated by CR-LF (or CR-CR-LF or just LF,
        // depending on the wackiness quotient of the server)
        //

        // MSXML3 bug 56001: commenting-out this assert; it's informational
        //                   only and ignorable.
        // INET_ASSERT((*lpszHeader == '\r') || (*lpszHeader == '\n'));

        SetHaveContentLength(TRUE);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_ContentLength = %d\n",
                    _ContentLength
                    ));

        _BytesInSocket = (_ContentLength != 0)
                ? (_ContentLength - (_BytesReceived - _DataOffset))
                : 0;

        //
        // we could have multiple responses in the same buffer. If
        // the amount received is greater than the content length
        // then we have all the data; there are no bytes left in
        // the socket for the current response
        //

        if ((int)_BytesInSocket < 0) {
            _BytesInSocket = 0;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("bytes left in socket = %d\n",
                    _BytesInSocket
                    ));

    }


    if ( IsResponseHeaderPresent(HTTP_QUERY_CONNECTION) ||
         IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION) )
    {
        //
        // check for "Connection: Keep-Alive" or "Proxy-Connection: Keep-Alive".
        // This test protects us against the unlikely
        // event of a server returning to us a keep-alive response header (because
        // that would cause problems for the proxy)
        //

        if (IsWantKeepAlive() && (!IsKeepAlive() || IsResponseHttp1_1()))
        {
            HEADER_STRING * curHeader;
            DWORD dwHeaderLength, headerNameLength;
            LPSTR lpszHeader;


            DWORD iSlot;

            char ch;

            if (IsRequestUsingProxy() &&
                IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
            }
            else if (IsResponseHeaderPresent(HTTP_QUERY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Length+1;
            }
            else
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
                INET_ASSERT(FALSE);
            }

            curHeader      = _ResponseHeaders.GetSlot(iSlot);
            lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
            dwHeaderLength = curHeader->StringLength();

            dwHeaderLength -= headerNameLength;
            lpszHeader     += headerNameLength;

            while (dwHeaderLength && (*lpszHeader == ' ')) {
                ++lpszHeader;
                --dwHeaderLength;
            }

            //
            // both headers use "Keep-Alive" as header-value ONLY for HTTP 1.0 servers
            //

            if (((int)dwHeaderLength >= KEEP_ALIVE_LEN)
            && !strnicmp(lpszHeader, KEEP_ALIVE_SZ, KEEP_ALIVE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Keep-Alive\n"
                            ));

                //
                // BUGBUG - we are setting k-a when coming from cache!
                //

                SetKeepAlive(TRUE);
                SetPersistentConnection(headerNameLength == HTTP_PROXY_CONNECTION_LEN);
            }

            //
            // also check for "Close" as header-value ONLY for HTTP 1.1 servers
            //

            else if ((*lpszHeader == 'C' || *lpszHeader == 'c')
                     && ((int)dwHeaderLength >= CLOSE_LEN)
                     && IsResponseHttp1_1()
                     && !strnicmp(lpszHeader, CLOSE_SZ, CLOSE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Close (HTTP/1.1)\n"
                            ));

                SetConnCloseResponse(TRUE);
            }
        }
    }

    //
    // check for "Transfer-Encoding:"
    //

    if (IsResponseHeaderPresent(HTTP_QUERY_TRANSFER_ENCODING) &&
        IsResponseHttp1_1())
    {

        //
        // If Http 1.1, check for Chunked Transfer
        //

        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;
        DWORD iSlot;

        iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING];
        curHeader = _ResponseHeaders.GetSlot(iSlot);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            ++lpszHeader;
            --dwHeaderLength;
        }

        //
        // look for "chunked" entry that confirms that we're doing chunked transfer encoding
        //

        if (((int)dwHeaderLength >= CHUNKED_LEN)
        && !strnicmp(lpszHeader, CHUNKED_SZ, CHUNKED_LEN))
        {
            INTERNET_HANDLE_OBJECT* pRoot = GetRootHandle(this);
            DWORD_PTR dwChunkFilterCtx = 0;

            // Now that we know this is a chunked response, allocate
            // a decoder context for parsing the data later.  If anything
            // fails here, the request needs to fail.            
            if (S_OK != pRoot->_ChunkFilter.RegisterContext(&dwChunkFilterCtx))
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            else if (!_ResponseFilterList.Insert(&pRoot->_ChunkFilter, dwChunkFilterCtx))
            {
                pRoot->_ChunkFilter.UnregisterContext(dwChunkFilterCtx);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            SetHaveChunkEncoding(TRUE);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("server is sending Chunked Transfer Encoding\n"
                        ));

            //
            // if both "transfer-encoding: chunked" and "content-length:"
            // were received then the chunking takes precedence
            //

            INET_ASSERT(!(IsChunkEncoding() && IsContentLength()));

            if (IsContentLength()) {
                SetHaveContentLength(FALSE);
            }

        }
    }

    SetBadNSServer(FALSE);

    if (IsResponseHttp1_1())
    {

        //
        // For IIS 4.0 Servers, and all other normal servers, if we make
        //  a HEAD request, we should ignore the Content-Length.
        //
        // IIS 3.0 servers send an illegal body, and this is a bug in the server.
        //  since they're not HTTP 1.1 we should be ok here.
        //

        if ( (GetMethodType() == HTTP_METHOD_TYPE_HEAD) &&
             (_ContentLength > 0) &&
             IsWantKeepAlive()
             )
        {

            //
            // set length to 0
            //

            _ContentLength = 0;

        }

        if ( IsRequestHttp1_1() )
        {


            //
            // check for NS servers that don't return correct HTTP/1.1 responses
            //

            LPSTR buffer;
            DWORD buflen;
            DWORD status = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                                   (LPVOID*)&buffer,
                                                   &buflen,
                                                   0
                                                   );

    #define NSEP    "Netscape-Enterprise/3"
    #define NSEPLEN (sizeof(NSEP) - 1)
    #define NSFT    "Netscape-FastTrack/3"
    #define NSFTLEN (sizeof(NSFT) - 1)
    #define NSCS    "Netscape-Commerce/3"
    #define NSCSLEN (sizeof(NSCS) - 1)

            if (status == ERROR_SUCCESS) {

                BOOL fIsBadServer = ((buflen > NSEPLEN) && !strnicmp(buffer, NSEP, NSEPLEN))
                                 || ((buflen > NSFTLEN) && !strnicmp(buffer, NSFT, NSFTLEN))
                                 || ((buflen > NSCSLEN) && !strnicmp(buffer, NSCS, NSCSLEN));

                if ( fIsBadServer )
                {
                    CServerInfo * pServerInfo = GetServerInfo();

                    SetBadNSServer(fIsBadServer);

                    if (pServerInfo != NULL)
                    {
                        //
                        // Note this Bad Server info in the server info obj,
                        //   as we they fail to do keep-alive with SSL properly
                        //

                        pServerInfo->SetBadNSServer();
                    }


                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("IsBadNSServer() == %B\n",
                                IsBadNSServer()
                                ));
                }
            }
        }

        //
        // BUGBUG - content-type: multipart/byteranges means we
        //          also have data
        //

        DWORD statusCode = GetStatusCode();

        if (!IsBadNSServer()
            && !IsContentLength()
            && !IsChunkEncoding()
            && (((statusCode >= HTTP_STATUS_CONTINUE)               // 100
                && (statusCode < HTTP_STATUS_OK))                   // 200
                || (statusCode == HTTP_STATUS_NO_CONTENT)           // 204
                || (statusCode == HTTP_STATUS_MOVED)                // 301
                || (statusCode == HTTP_STATUS_REDIRECT)             // 302
                || (statusCode == HTTP_STATUS_REDIRECT_METHOD)      // 303
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)         // 304
                || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB))  // 307
            || (GetMethodType() == HTTP_METHOD_TYPE_HEAD)) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("header-only HTTP/1.1 response\n"
                        ));

            SetData(FALSE);
        }
    }

quit:
    DEBUG_LEAVE(dwError);
    return dwError;
}


//
// this array has the same order as the HTTP_METHOD_TYPE enum
//

#define MAKE_REQUEST_METHOD_TYPE(Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## Type

//
// darrenmi - need a new macro because *_M-POST isn't a valid enum member.
// we need a seperate enum type and string value.
//
// map HTTP_METHOD_TYPE_MPOST <=> "M-POST"
//

#define MAKE_REQUEST_METHOD_TYPE2(EnumType,Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## EnumType

static const struct _REQUEST_METHOD {
    int Length;
    LPSTR Name;
    HTTP_METHOD_TYPE MethodType;
} MethodNames[] = {
    MAKE_REQUEST_METHOD_TYPE(GET),
    MAKE_REQUEST_METHOD_TYPE(HEAD),
    MAKE_REQUEST_METHOD_TYPE(POST),
    MAKE_REQUEST_METHOD_TYPE(PUT),
    MAKE_REQUEST_METHOD_TYPE(PROPFIND),
    MAKE_REQUEST_METHOD_TYPE(PROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(LOCK),
    MAKE_REQUEST_METHOD_TYPE(UNLOCK),
    MAKE_REQUEST_METHOD_TYPE(COPY),
    MAKE_REQUEST_METHOD_TYPE(MOVE),
    MAKE_REQUEST_METHOD_TYPE(MKCOL),
    MAKE_REQUEST_METHOD_TYPE(CONNECT),
    MAKE_REQUEST_METHOD_TYPE(DELETE),
    MAKE_REQUEST_METHOD_TYPE(LINK),
    MAKE_REQUEST_METHOD_TYPE(UNLINK),
    MAKE_REQUEST_METHOD_TYPE(BMOVE),
    MAKE_REQUEST_METHOD_TYPE(BCOPY),
    MAKE_REQUEST_METHOD_TYPE(BPROPFIND),
    MAKE_REQUEST_METHOD_TYPE(BPROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(BDELETE),
    MAKE_REQUEST_METHOD_TYPE(SUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(UNSUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(NOTIFY),
    MAKE_REQUEST_METHOD_TYPE(POLL), 
    MAKE_REQUEST_METHOD_TYPE(CHECKIN),
    MAKE_REQUEST_METHOD_TYPE(CHECKOUT),
    MAKE_REQUEST_METHOD_TYPE(INVOKE),
    MAKE_REQUEST_METHOD_TYPE(SEARCH),
    MAKE_REQUEST_METHOD_TYPE(PIN),
    MAKE_REQUEST_METHOD_TYPE2(MPOST,M-POST)
};


HTTP_METHOD_TYPE
MapHttpRequestMethod(
    IN LPCSTR lpszVerb
    )

/*++

Routine Description:

    Maps request method string to type. Method names *are* case-sensitive

Arguments:

    lpszVerb    - method (verb) string

Return Value:

    HTTP_METHOD_TYPE

--*/

{
    int verbLen = strlen(lpszVerb);

    for (int i = 0; i < ARRAY_ELEMENTS(MethodNames); ++i) {
        if ((MethodNames[i].Length == verbLen)
        && (memcmp(lpszVerb, MethodNames[i].Name, verbLen) == 0)) {
            return MethodNames[i].MethodType;
        }
    }

    //
    // we now hande HTTP_METHOD_TYPE_UNKNOWN
    //

    return HTTP_METHOD_TYPE_UNKNOWN;
}


DWORD
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod,
    OUT LPCSTR * lplpcszName
    )

/*++

Routine Description:

    Map a method type to the corresponding name and length

Arguments:

    tMethod     - to map

    lplpcszName - pointer to pointer to returned name

Return Value:

    DWORD
        Success - length of method name

        Failure - (DWORD)-1

--*/

{
    DWORD length;

    if ((tMethod >= HTTP_METHOD_TYPE_FIRST) && (tMethod <= HTTP_METHOD_TYPE_LAST)) {
        *lplpcszName = MethodNames[tMethod].Name;
        length = MethodNames[tMethod].Length;
    } else {
        length = (DWORD)-1;
    }
    return length;
}

#if INET_DEBUG

LPSTR
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod
    )
{
    return (tMethod == HTTP_METHOD_TYPE_UNKNOWN)
        ? "Unknown"
        : MethodNames[tMethod].Name;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\hdrparse.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP_HEADER_PARSER implementation
//

HTTP_HEADER_PARSER::HTTP_HEADER_PARSER(
    IN LPSTR szHeaders,
    IN DWORD cbHeaders
    ) : HTTP_HEADERS()

/*++

Routine Description:

    Constructor for the HTTP_HEADER_PARSER object.  Calls ParseHeaders to
      build a parsed version of the header string passed in.

Arguments:

    szHeaders      - pointer to the headers to parse

    cbHeaders      - length of the headers

Return Value:

    None.

--*/

{
    DWORD dwBytesScaned = 0;
    BOOL fFoundCompleteLine;
    BOOL fFoundEndOfHeaders;
    DWORD error;

    error = ParseHeaders(
        szHeaders,
        cbHeaders,
        TRUE, // Eof
        &dwBytesScaned,
        &fFoundCompleteLine,
        &fFoundEndOfHeaders
        );

    INET_ASSERT(error == ERROR_SUCCESS);
    INET_ASSERT(fFoundCompleteLine);
    INET_ASSERT(fFoundEndOfHeaders);
}


BOOL
HTTP_HEADER_PARSER::ParseStatusLine(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT DWORD *lpdwStatusCode,
    OUT DWORD *lpdwMajorVersion,
    OUT DWORD *lpdwMinorVersion
    )

/*++

Routine Description:

    Parses the Status line of an HTTP server response.  Takes care of adding the status
     line to HTTP header array.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    BOOL  - TRUE if line was successively parsed and processed, FALSE otherwise

--*/

{

#define BEFORE_VERSION_NUMBERS 0
#define MAJOR_VERSION_NUMBER   1
#define MINOR_VERSION_NUMBER   2
#define STATUS_CODE_NUMBER     3
#define AFTER_STATUS_CODE      4
#define MAX_STATUS_INTS        4

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    DWORD dwStatusLineSize = 0;
    LPSTR lpszStatusLine;
    int ver_state = BEFORE_VERSION_NUMBERS;
    DWORD adwStatusInts[MAX_STATUS_INTS];
    BOOL success = TRUE;

    for ( int i = 0; i < MAX_STATUS_INTS; i++)
        adwStatusInts[i] = 0;

    lpszStatusLine = response;

    //
    // While walking the Status Line looking for terminating \r\n,
    //   we extract the Major.Minor Versions and Status Code in that order.
    //   text and spaces will lie between/before/after the three numbers
    //   but the idea is to remeber which number we're calculating based on a numeric state
    //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
    //

    while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
    {
        // below should be wrapped in while (response[i] != ' ') to be more robust???
        switch (ver_state)
        {
            case BEFORE_VERSION_NUMBERS:
                if (*response == '/')
                {
                    INET_ASSERT(ver_state == BEFORE_VERSION_NUMBERS);
                    ver_state++; // = MAJOR_VERSION_NUMBER
                }
                else if (*response == ' ')
                {
                    ver_state = STATUS_CODE_NUMBER;
                }

                break;

            case MAJOR_VERSION_NUMBER:

                if (*response == '.')
                {
                    INET_ASSERT(ver_state == MAJOR_VERSION_NUMBER);
                    ver_state++; // = MINOR_VERSION_NUMBER
                    break;
                }
                // fall through

            case MINOR_VERSION_NUMBER:

                if (*response == ' ')
                {
                    INET_ASSERT(ver_state == MINOR_VERSION_NUMBER);
                    ver_state++; // = STATUS_CODE_NUMBER
                    break;
                }
                // fall through

            case STATUS_CODE_NUMBER:

                if (isdigit(*response)) {
                    int val = *response - '0';
                    adwStatusInts[ver_state] = adwStatusInts[ver_state] * 10 + val;
                }
                else if ( adwStatusInts[STATUS_CODE_NUMBER] > 0 )
                {
                    //
                    // we eat spaces before status code is found,
                    //  once we have the status code we can go on to the next
                    //  state on the next non-digit. This is done
                    //  to cover cases with several spaces between version
                    //  and the status code number.
                    //

                    INET_ASSERT(ver_state == STATUS_CODE_NUMBER);
                    ver_state++; // = AFTER_STATUS_CODE
                    break;
                } else if (!isspace(*response)) {
                    adwStatusInts[ver_state] = (DWORD)-1;
                }

                break;

            case AFTER_STATUS_CODE:
                break;

        }

        ++response;
        ++dwBytesScanned;
    }

    dwStatusLineSize = dwBytesScanned;

    if (response == lpszEnd) {

        //
        // response now points one past the end of the buffer. We may be looking
        // over the edge...
        //
        // if we're at the end of the connection then the server sent us an
        // incorrectly formatted response. Probably an error.
        //
        // Otherwise its a partial response. We need more
        //


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response in status line\n"
                    ));

        success = fEof ? TRUE : FALSE;

        //
        // if we really hit the end of the response then update the amount of
        // headers scanned
        //

        if (!success) {
            dwBytesScanned = 0;
        }

        goto quit;

    }

    while ((response < lpszEnd)
    && ((*response == '\r') || (*response == ' '))) {
        ++response;
        ++dwBytesScanned;
    }

    if (response == lpszEnd) {

        //
        // hit end of buffer without finding LF
        //

        success = FALSE;

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("hit end of buffer without finding LF\n"
                    ));

        goto quit;

    } else if (*response == '\n') {
        ++response;
        ++dwBytesScanned;

        //
        // if we found the empty line then we are done
        //

        success = TRUE;
    }


    INET_ASSERT(success);

    //
    // Now we have our parsed header to add to the array
    //

    HEADER_STRING * freeHeader;
    DWORD iSlot;

    freeHeader = FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        INET_ASSERT(FALSE);
        success = FALSE;
        goto quit;
    } else {
        INET_ASSERT(iSlot == 0); // status line should always be first
        freeHeader->CreateOffsetString((DWORD)(lpszStatusLine - lpHeaderBase), dwStatusLineSize);
        freeHeader->SetHash(0); // status line has no hash value.
    }


quit:

    *lpdwStatusCode    = adwStatusInts[STATUS_CODE_NUMBER];
    *lpdwMajorVersion  = adwStatusInts[MAJOR_VERSION_NUMBER];
    *lpdwMinorVersion  = adwStatusInts[MINOR_VERSION_NUMBER];

    *lpdwBufferLengthScanned += dwBytesScanned;

    return success;
}

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Loads headers into HTTP_HEADERS member for subsequent parsing.

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.

    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

    do
    {
        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;

        //
        // Remove leading whitespace from header
        //

        while ( (response < lpszEnd) && ((*response == ' ') || (*response == '\t')) )
        {
            ++response;
            ++dwBytesScanned;
        }

        //
        // Scan for HeaderName:
        //

        lpszHeaderName = response;
        dwPreviousAmountOfBytesScanned = dwBytesScanned;

        while ((response < lpszEnd) && (*response != ':') && (*response != '\r') && (*response != '\n'))
        {
            //
            // This code incapsulates CalculateHashNoCase as an optimization,
            //   we attempt to calculate the Hash value as we parse the header.
            //

            CHAR ch = *response;

            if ((ch >= 'A') && (ch <= 'Z')) {
                ch = MAKE_LOWER(ch);
            }
            dwHash += (DWORD)(dwHash << 5) + ch;

            ++response;
            ++dwBytesScanned;
        }

        dwHeaderNameLength = (DWORD) (response - lpszHeaderName);

        //
        // catch bogus responses: if we find what looks like one of a (very)
        // small set of HTML tags, then assume the previous header was the
        // last
        //

        if ((dwHeaderNameLength >= sizeof("<HTML>") - 1)
            && (*lpszHeaderName == '<')
            && (!strnicmp(lpszHeaderName, "<HTML>", sizeof("<HTML>") - 1)
                || !strnicmp(lpszHeaderName, "<HEAD>", sizeof("<HEAD>") - 1))) {
            *pfFoundEndOfHeaders  = TRUE;
            break;
        }

        //
        // Keep scanning till end of the line.
        //

        while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
        {
            ++response;
            ++dwBytesScanned;
        }

        dwHeaderLineLength = (DWORD) (response - lpszHeaderName); // note: this headerLINElength

        if (response == lpszEnd) {

            //
            // response now points one past the end of the buffer. We may be looking
            // over the edge...
            //
            // if we're at the end of the connection then the server sent us an
            // incorrectly formatted response. Probably an error.
            //
            // Otherwise its a partial response. We need more
            //


            DEBUG_PRINT(HTTP,
                        INFO,
                        ("found end of short response\n"
                        ));

            success = fEof ? TRUE : FALSE;

            //
            // if we really hit the end of the response then update the amount of
            // headers scanned
            //

            if (!success) {
                dwBytesScanned = dwPreviousAmountOfBytesScanned;
            }

            break;

        }
        else
        {

            //
            // we reached a CR or LF. This is the end of this current header. Find
            // the start of the next one
            //

            //
            // first, strip off any trailing spaces from the current header. We do
            // this by simply reducing the string length. We only look for space
            // and tab characters. Only do this if we have a non-zero length header
            //

            if (dwHeaderLineLength != 0) {
                for (int i = -1; response[i] == ' ' || response[i] == '\t'; --i) {
                    --dwHeaderLineLength;
                }
            }

            INET_ASSERT((int)dwHeaderLineLength >= 0);

            //
            // some servers respond with "\r\r\n". Lame
            // A new twist: "\r \r\n". Lamer
            //

            while ((response < lpszEnd)
            && ((*response == '\r') || (*response == ' '))) {
                ++response;
                ++dwBytesScanned;
            }
            if (response == lpszEnd) {

                //
                // hit end of buffer without finding LF
                //

                success = FALSE;

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("hit end of buffer without finding LF\n"
                            ));

                //
                // get more data, reparse this line
                //

                dwBytesScanned = dwPreviousAmountOfBytesScanned;
                break;
            } else if (*response == '\n') {
                ++response;
                ++dwBytesScanned;

                //
                // if we found the empty line then we are done
                //

                if (dwHeaderLineLength == 0) {
                    *pfFoundEndOfHeaders  = TRUE;
                    break;
                }

                success = TRUE;
            }
        }

        //
        // Now we have our parsed header to add to the array
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;

        } else {
            freeHeader->CreateOffsetString((DWORD) (lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
            freeHeader->SetHash(dwHash);
        }


        //CHAR szTemp[256];
        //
        //memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
        //lpszHeaderName[dwHeaderLineLength] = '\0';

        //DEBUG_PRINT(HTTP,
        //    INFO,
        //    ("ParseHeaders: adding=%q\n", lpszHeaderName
        //    ));


        //
        // Now see if this is a known header we are adding, if so then we note that fact
        //

        DWORD dwKnownQueryIndex;

        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
        }
    } while (TRUE);

quit:

    *lpdwBufferLengthScanned += dwBytesScanned;
    *pfFoundCompleteLine = success;

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\hhead.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hhead.cxx

Abstract:

    This file contains autogenerated table values of a perfect hash function
    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp
    Contents:
      GlobalKnownHeaders
      GlobalHeaderHashs

Author:

   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]

Revision History:

--*/


#include <wininetp.h>
#include "httpp.h"

#ifdef HEADER_HASH_SEED
#if (HEADER_HASH_SEED != 1291949)
#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header
#endif
#else
#define HEADER_HASH_SEED 1291949
#endif

#ifdef MAX_HEADER_HASH_SIZE
#if (MAX_HEADER_HASH_SIZE != 153)
#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header
#endif
#else
#define MAX_HEADER_HASH_SIZE 153
#endif

#ifdef HTTP_QUERY_MAX
#if (HTTP_QUERY_MAX != 77)
#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp
#endif
#endif

//
// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.
// This array must be used with the same hash function used to generate it.
// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.
//   0-ed entries indicate error values
//

const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {
      0,   0,   0,  71,   0,   0, 
     53,   0,   0,   0,   0,   0, 
     40,  60,  72,   0,   0,   0, 
     64,  61,   0,  28,   4,   0, 
     76,  57,   0,  30,   0,   8, 
      0,  15,   0,   0,   0,   0, 
     24,   0,  66,  29,   0,   0, 
      0,   0,   0,   0,  13,  14, 
     16,  33,   0,   0,   0,  68, 
     41,   0,   7,   0,   0,   0, 
      0,   0,  32,  17,  51,  48, 
     67,  11,   0,   0,   5,   0, 
     65,   2,   0,   0,  35,   6, 
      0,   0,  31,  50,   0,   0, 
      0,  49,  78,  26,   0,   0, 
     42,   0,   0,  43,   0,  27, 
     69,   9,   1,   0,   0,  18, 
     10,   0,   0,   3,  47,  55, 
      0,  44,   0,  56,   0,  70, 
     54,  52,   0,   0,   0,   0, 
      0,   0,  36,  62,   0,   0, 
     45,   0,   0,  12,   0,  73, 
     77,   0,  63,   0,  59,   0, 
      0,   0,   0,  58,  38,   0, 
      0,   0,  39,  25,   0,  37, 
      0,  34,   0, 
   };

//
// GlobalKnownHeaders - array of HTTP request and response headers that we understand.
// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H
//

#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal

const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {
    HEADER_ENTRY("Mime-Version",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x179ED708),
    HEADER_ENTRY("Content-Type",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A50E357),
    HEADER_ENTRY("Content-Transfer-Encoding",  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x562B730E),
    HEADER_ENTRY("Content-Id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xE7ADCA82),
    HEADER_ENTRY("Content-Description",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9D4EB3D9),
    HEADER_ENTRY("Content-Length",             (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER), 0x4E02E517),
    HEADER_ENTRY("Content-Language",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA6681019),
    HEADER_ENTRY("Allow",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x297A46CC),
    HEADER_ENTRY("Public",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C5DD44C),
    HEADER_ENTRY("Date",                       (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xBB71C70B),
    HEADER_ENTRY("Expires",                    (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC153144D),
    HEADER_ENTRY("Last-Modified",              (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x23617A4F),
    HEADER_ENTRY("Message-id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC9AE6FAC),
    HEADER_ENTRY("Uri",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D45D),
    HEADER_ENTRY("Derived-From",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x6AAF4091),
    HEADER_ENTRY("Cost",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB717626),
    HEADER_ENTRY("Link",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB764B5B),
    HEADER_ENTRY("Pragma",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C26E9A5),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_NUMBER, 0x0),
    HEADER_ENTRY("",                           0, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Connection",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x190A507D),
    HEADER_ENTRY("Accept",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x581B295D),
    HEADER_ENTRY("Accept-Charset",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC87564B4),
    HEADER_ENTRY("Accept-Encoding",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x81EEF031),
    HEADER_ENTRY("Accept-Language",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2827D6EE),
    HEADER_ENTRY("Authorization",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xEC768B9E),
    HEADER_ENTRY("Content-Encoding",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2F295C),
    HEADER_ENTRY("Forwarded",                  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x420550EB),
    HEADER_ENTRY("From",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB732781),
    HEADER_ENTRY("If-Modified-Since",          (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x88B69529),
    HEADER_ENTRY("Location",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8DD3A2C6),
    HEADER_ENTRY("Orig-Uri",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x47CCA2FB),
    HEADER_ENTRY("Referer",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7CFEFF98),
    HEADER_ENTRY("Retry-After",                (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xD2881822),
    HEADER_ENTRY("Server",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8244B644),
    HEADER_ENTRY("Title",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AD094CF),
    HEADER_ENTRY("User-Agent",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x968679A8),
    HEADER_ENTRY("WWW-Authenticate",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x21BED5E),
    HEADER_ENTRY("Proxy-Authenticate",         HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBE0F117B),
    HEADER_ENTRY("Accept-Ranges",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC3BF828A),
    HEADER_ENTRY("Set-Cookie",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC704A760),
    HEADER_ENTRY("Cookie",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x5DA54DC7),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Refresh",                    0, 0x7D05EAFC),
    HEADER_ENTRY("Content-Disposition",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDCB6FC4A),
    HEADER_ENTRY("Age",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF607DDA),
    HEADER_ENTRY("Cache-Control",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBBD3B86F),
    HEADER_ENTRY("Content-Base",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A469ED0),
    HEADER_ENTRY("Content-Location",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC201A76E),
    HEADER_ENTRY("Content-Md5",                HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDD672BFB),
    HEADER_ENTRY("Content-Range",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD43BEC42),
    HEADER_ENTRY("Etag",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB72A1CE),
    HEADER_ENTRY("Host",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB74340B),
    HEADER_ENTRY("If-Match",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x971A5776),
    HEADER_ENTRY("If-None-Match",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF6E9D3),
    HEADER_ENTRY("If-Range",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9774B8F6),
    HEADER_ENTRY("If-Unmodified-Since",        (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC946042C),
    HEADER_ENTRY("Max-Forwards",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x3C693EC8),
    HEADER_ENTRY("Proxy-Authorization",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x96A221ED),
    HEADER_ENTRY("Range",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AA7E69A),
    HEADER_ENTRY("Transfer-Encoding",          HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBD09B166),
    HEADER_ENTRY("Upgrade",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7DAF65B5),
    HEADER_ENTRY("Vary",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB7BA5AF),
    HEADER_ENTRY("Via",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D76D),
    HEADER_ENTRY("Warning",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xF56B7D23),
    HEADER_ENTRY("Expect",                     (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x62F2EDB6),
    HEADER_ENTRY("Proxy-Connection",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD79F12C),
    HEADER_ENTRY("Unless-Modified-Since",      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8E53B934),
    HEADER_ENTRY("Ms-Echo-Request",            0, 0xBB7AF4AF),
    HEADER_ENTRY("Ms-Echo-Reply",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA5326612),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Proxy-Support",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C4F7F99),
    HEADER_ENTRY("Authentication-Info",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xB03F47E6),
    HEADER_ENTRY("PassportURLs",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF7C676F),
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\headers.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    headers.h

Abstract:

    This file contains the well-known HTTP/MIME request/response headers.
    For each header, two manifests are defined. HTTP_*_SZ contains the header
    name, immediatly followed by a colon. HTTP_*_LEN is the strlen of the
    corresponding HTTP_*_SZ, which does not include the terminating '\0'.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#define CSTRLEN(str)  (sizeof(str)-1)

#ifndef _HEADERS_H_
#define _HEADERS_H_

struct KnownHeaderType {
    LPSTR Text;
    INT Length;
    DWORD Flags;
    DWORD HashVal;
};

#define MAX_HEADER_HASH_SIZE 153
#define HEADER_HASH_SEED 1291949


extern const BYTE GlobalHeaderHashs[];
extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
FASTCALL
CalculateHashNoCase(
    IN LPCSTR lpszString,
    IN DWORD dwStringLength
    );


//
// Various other header defines for different HTTP headers.
//

#define HTTP_ACCEPT_RANGES_SZ           "Accept-Ranges:"
#define HTTP_ACCEPT_RANGES_LEN          CSTRLEN(HTTP_ACCEPT_RANGES_SZ)

#define HTTP_DATE_SZ                    "Date:"
#define HTTP_DATE_LEN                   (sizeof(HTTP_DATE_SZ) - 1)

#define HTTP_EXPIRES_SZ                 "Expires:"
#define HTTP_EXPIRES_LEN                (sizeof(HTTP_EXPIRES_SZ) - 1)


#define HTTP_CONTENT_DISPOSITION_SZ     "Content-Disposition:"
#define HTTP_CONTENT_DISPOSITION_LEN     (sizeof(HTTP_CONTENT_DISPOSITION_SZ) - 1)

#define HTTP_LAST_MODIFIED_SZ           "Last-Modified:"
#define HTTP_LAST_MODIFIED_LEN          (sizeof(HTTP_LAST_MODIFIED_SZ) - 1)

// nuke?
#define HTTP_UNLESS_MODIFIED_SINCE_SZ   "Unless-Modified-Since:"
#define HTTP_UNLESS_MODIFIED_SINCE_LEN  CSTRLEN(HTTP_UNLESS_MODIFIED_SINCE_SZ)

#define HTTP_SERVER_SZ                  "Server:"
#define HTTP_SERVER_LEN                 (sizeof(HTTP_SERVER_SZ) - 1)

#define HTTP_CONNECTION_SZ              "Connection:"
#define HTTP_CONNECTION_LEN             (sizeof(HTTP_CONNECTION_SZ) - 1)

#define HTTP_PROXY_CONNECTION_SZ        "Proxy-Connection:"
#define HTTP_PROXY_CONNECTION_LEN       (sizeof(HTTP_PROXY_CONNECTION_SZ) - 1)

#define HTTP_SET_COOKIE_SZ              "Set-Cookie:"
#define HTTP_SET_COOKIE_LEN             (sizeof(HTTP_SET_COOKIE_SZ)-1)

//
//  Miscellaneous header goodies.
//

#define CHUNKED_SZ                      "chunked"
#define CHUNKED_LEN                     (sizeof(CHUNKED_SZ) - 1)

#define KEEP_ALIVE_SZ                   "Keep-Alive"
#define KEEP_ALIVE_LEN                  (sizeof(KEEP_ALIVE_SZ) - 1)

#define CLOSE_SZ                        "Close"
#define CLOSE_LEN                       (sizeof(CLOSE_SZ) - 1)

#define BYTES_SZ                        "bytes"
#define BYTES_LEN                       CSTRLEN(BYTES_SZ)

#define HTTP_VIA_SZ                     "Via:"
#define HTTP_VIA_LEN                    (sizeof(HTTP_VIA_SZ) - 1)

#define HTTP_DATE_SIZE  40

// Cache control defines:

#define HTTP_CACHE_CONTROL_SZ           "Cache-Control:"
#define HTTP_CACHE_CONTROL_LEN          CSTRLEN(HTTP_CACHE_CONTROL_SZ)

#define HTTP_AGE_SZ                     "Age:"
#define HTTP_AGE_LEN                    (sizeof(HTTP_AGE_SZ)-1)

#define HTTP_VARY_SZ                    "Vary:"
#define HTTP_VARY_LEN                   (sizeof(HTTP_VARY_SZ)-1)

#define NO_CACHE_SZ                     "no-cache"
#define NO_CACHE_LEN                    (sizeof(NO_CACHE_SZ) -1)

#define NO_STORE_SZ                     "no-store"
#define NO_STORE_LEN                    (sizeof(NO_STORE_SZ) -1)

#define MUST_REVALIDATE_SZ              "must-revalidate"
#define MUST_REVALIDATE_LEN             (sizeof(MUST_REVALIDATE_SZ) -1)

#define MAX_AGE_SZ                      "max-age"
#define MAX_AGE_LEN                     (sizeof(MAX_AGE_SZ) -1)

#define PRIVATE_SZ                      "private"
#define PRIVATE_LEN                     (sizeof(PRIVATE_SZ) - 1)

#define POSTCHECK_SZ                    "post-check"
#define POSTCHECK_LEN                   (sizeof(POSTCHECK_SZ) -1)

#define PRECHECK_SZ                     "pre-check"
#define PRECHECK_LEN                    (sizeof(PRECHECK_SZ) -1)

#define FILENAME_SZ                     "filename"
#define FILENAME_LEN                    (sizeof(FILENAME_SZ) - 1)

#define USER_AGENT_SZ                   "user-agent"
#define USER_AGENT_LEN                  (sizeof(USER_AGENT_SZ) - 1)

#endif  // _HEADERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\httptime.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    This file contains the numerical defines for the date/parsing routines located
    in the httptime.cxx file.

Author:

    Arthur Bierer (arthurbi) 12-Dec-1997

Revision History:

--*/


#ifndef _HTTPTIME_H_
#define _HTTPTIME_H_

#define BASE_DEC 10 // base 10

//
// Date indicies used to figure out what each entry is.
//


#define DATE_INDEX_DAY_OF_WEEK     0

#define DATE_1123_INDEX_DAY        1
#define DATE_1123_INDEX_MONTH      2
#define DATE_1123_INDEX_YEAR       3
#define DATE_1123_INDEX_HRS        4
#define DATE_1123_INDEX_MINS       5
#define DATE_1123_INDEX_SECS       6

#define DATE_ANSI_INDEX_MONTH      1
#define DATE_ANSI_INDEX_DAY        2
#define DATE_ANSI_INDEX_HRS        3
#define DATE_ANSI_INDEX_MINS       4
#define DATE_ANSI_INDEX_SECS       5
#define DATE_ANSI_INDEX_YEAR       6

#define DATE_INDEX_TZ              7

#define DATE_INDEX_LAST            DATE_INDEX_TZ
#define MAX_DATE_ENTRIES           (DATE_INDEX_LAST+1)




//
// DATE_TOKEN's DWORD values used to determine what day/month we're on
//

#define DATE_TOKEN_JANUARY      1
#define DATE_TOKEN_FEBRUARY     2
#define DATE_TOKEN_MARCH        3
#define DATE_TOKEN_APRIL        4
#define DATE_TOKEN_MAY          5
#define DATE_TOKEN_JUNE         6
#define DATE_TOKEN_JULY         7
#define DATE_TOKEN_AUGUST       8
#define DATE_TOKEN_SEPTEMBER    9
#define DATE_TOKEN_OCTOBER      10
#define DATE_TOKEN_NOVEMBER     11
#define DATE_TOKEN_DECEMBER     12       

#define DATE_TOKEN_LAST_MONTH   (DATE_TOKEN_DECEMBER+1)

#define DATE_TOKEN_SUNDAY       0
#define DATE_TOKEN_MONDAY       1
#define DATE_TOKEN_TUESDAY      2                  
#define DATE_TOKEN_WEDNESDAY    3
#define DATE_TOKEN_THURSDAY     4
#define DATE_TOKEN_FRIDAY       5
#define DATE_TOKEN_SATURDAY     6

#define DATE_TOKEN_LAST_DAY     (DATE_TOKEN_SATURDAY+1)
 
#define DATE_TOKEN_GMT          0xFFFFFFFD

#define DATE_TOKEN_LAST         DATE_TOKEN_GMT

#define DATE_TOKEN_ERROR        (DATE_TOKEN_LAST+1)

                            
#endif  // _HTTPTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\httptime.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    httptime.cxx

Abstract:

    This file contains routines to get various timestamps from an http response
    header.

    We handle only the three standards-mandated date forms, since these are used by
    the vast majority of sites out there on the WWW. Handling additional date forms
    adds to the overhead of these functions, so unless a new form makes headway, we
    will keep these functions simple.

    Contents:
        FGetHttpExpiryTime
        FGetHttpLastModifiedTime
        FParseHttpDate
        FHttpDateTimeToFiletime
        FFileTimetoHttpDateTime
        HttpDateToSystemTime
        HttpTimeFromSystemTime
        (FInternalParseHttpDate)
        (MapDayMonthToDword)

Author:

    Shishir Pardikar (shishirp) 06-Jan-1996

Revision History:

    06-Jan-1996 rfirth
        Created this header

    12-Dec-1997 arthurbi
        Rewrote the date parser to reduce allocs, and other bad stuff.

--*/

#include <wininetp.h>
#include "httpp.h"
#include "httptime.h"

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/


/******************************** Local Functions ***************************/

BOOL
FHttpDateTimeToFiletime(
    LPCSTR pcszStr,      // input datetime string
    LPCSTR *rgszWkDay,   // day of week strings
    LPCSTR *rgszMon,     // month strings
    LPCSTR pcszSep,      // seperators
    UINT dateId,         // date format
    FILETIME *lpft       // output filetime in GMT
    );


BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    );


/****************************************************************************/






//+---------------------------------------------------------------------------
//
//  Function: FGetHttpExpiryTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpExpiryTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES, NULL, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

//+---------------------------------------------------------------------------
//
//  Function: FGetHttpLastModifiedTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpLastModifiedTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

DWORD
inline
MapDayMonthToDword(
    LPCSTR lpszDay
    )
/*++

Routine Description:

    Looks at the first three bytes of string to determine if we're looking
        at a Day of the Week, or Month, or "GMT" string.  Is inlined so that
        the compiler can optimize this code into the caller FInternalParseHttpDate.

Arguments:

    lpszDay - a string ptr to the first byte of the string in question.

Return Value:

    DWORD
    Success - The Correct date token, 0-6 for day of the week, 1-14 for month, etc

    Failure - DATE_TOKEN_ERROR

--*/

{
    switch ( MAKE_UPPER(*lpszDay) ) // make uppercase
    {
        case 'A':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'P':
                    return DATE_TOKEN_APRIL;
                case 'U':
                    return DATE_TOKEN_AUGUST;

            }
            return DATE_TOKEN_ERROR;

        case 'D':
            return DATE_TOKEN_DECEMBER;

        case 'F':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'R':
                    return DATE_TOKEN_FRIDAY;
                case 'E':
                    return DATE_TOKEN_FEBRUARY;
            }

            return DATE_TOKEN_ERROR;

        case 'G':
            return DATE_TOKEN_GMT;

        case 'M':

            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'O':
                    return DATE_TOKEN_MONDAY;
                case 'A':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'R':
                            return DATE_TOKEN_MARCH;
                        case 'Y':
                            return DATE_TOKEN_MAY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;            

        case 'N':
            return DATE_TOKEN_NOVEMBER;

        case 'J':

            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_JANUARY;

                case 'U':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'N':
                            return DATE_TOKEN_JUNE;
                        case 'L':
                            return DATE_TOKEN_JULY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;

        case 'O':
            return DATE_TOKEN_OCTOBER;

        case 'S':
            
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_SATURDAY;
                case 'U':
                    return DATE_TOKEN_SUNDAY;
                case 'E':
                    return DATE_TOKEN_SEPTEMBER;
            }

            return DATE_TOKEN_ERROR;


        case 'T':
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {    
                case 'U':
                    return DATE_TOKEN_TUESDAY;
                case 'H':
                    return DATE_TOKEN_THURSDAY;
            }

            return DATE_TOKEN_ERROR;

        case 'U':
            return DATE_TOKEN_GMT;
            
        case 'W':
            return DATE_TOKEN_WEDNESDAY;

    }

    return DATE_TOKEN_ERROR;
}

BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    )
/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME/SYSTEMTIME time format.  

    Important this a time-critical function and should only be changed 
     with the intention of optimizing or a critical need work item.

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.
            Must be NULL if not intended to be used !!!

    lpSysTime - Ptr to SYSTEMTIME struture. Used to return Systime if needed.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    int i = 0, iLastLettered = -1;
    BOOL fIsANSIDateFormat = FALSE;
    DWORD rgdwDateParseResults[MAX_DATE_ENTRIES];
    SYSTEMTIME  sSysTime;
    FILETIME    ftTime;
    BOOL fRet = TRUE;

    DEBUG_ENTER((DBG_HTTP,
                Bool,
                "FInternalParseHttpDate",
                "%x %.10q",
                lpft,
                lpInputBuffer
                ));

    //
    // Date Parsing v2 (1 more to go), and here is how it works... 
    //  We take a date string and churn through it once, converting
    //  integers to integers, Month,Day, and GMT strings into integers,
    //  and all is then placed IN order in a temp array. 
    //
    // At the completetion of the parse stage, we simple look at 
    //  the data, and then map the results into the correct 
    //  places in the SYSTIME structure.  Simple, No allocations, and
    //  No dirting the data.   
    //
    // The end of the function does something munging and pretting
    //  up of the results to handle the year 2000, and TZ offsets
    //  Note: do we need to fully handle TZs anymore?
    //

    memset(rgdwDateParseResults, 0, sizeof(rgdwDateParseResults));

    while ( *lpInputBuffer && i < MAX_DATE_ENTRIES)
    {
        if ( *lpInputBuffer >= '0' && *lpInputBuffer <= '9' )
        {
            //
            // we have a numerical entry, scan through it and convent to DWORD
            //

            rgdwDateParseResults[i] = 0;

            do {
                rgdwDateParseResults[i] *= BASE_DEC;
                rgdwDateParseResults[i] += (DWORD) (*lpInputBuffer - '0');
                lpInputBuffer++;
            } while ( *lpInputBuffer && *lpInputBuffer >= '0' && *lpInputBuffer <= '9' );

            i++; // next token
        }
        else if ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
             (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') )
        {
            //
            // we have a string, should be a day, month, or GMT
            //   lets skim to the end of the string
            //
            
            rgdwDateParseResults[i] = 
                MapDayMonthToDword(lpInputBuffer);

            iLastLettered = i;

            // We want to ignore the possibility of a time zone such as PST or EST in a non-standard
            // date format such as "Thu Dec 17 16:01:28 PST 1998" (Notice that the year is _after_ the time zone
            if ((rgdwDateParseResults[i] == DATE_TOKEN_ERROR) 
                && 
                !(fIsANSIDateFormat && (i==DATE_ANSI_INDEX_YEAR)))
            {
                fRet = FALSE;
#ifdef DEBUG
                dprintf("FInternalParseHttpDate: Invalid Date Format, could not parse %s\n", lpInputBuffer);
#endif
                
                goto quit;
            }

            //
            // At this point if we have a vaild string
            //  at this index, we know for sure that we're
            //  looking at a ANSI type DATE format.
            //

            if ( i == DATE_ANSI_INDEX_MONTH )
            {
                fIsANSIDateFormat = TRUE;
            }

            //
            // Read past the end of the current set of alpha characters,
            //  as MapDayMonthToDword only peeks at a few characters
            //

            do {
                lpInputBuffer++;
            } while ( *lpInputBuffer && 
                        ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
                          (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') ) );

            i++; // next token
        }
        else
        {
            //
            // For the generic case its either a space, comma, semi-colon, etc.
            //  the point is we really don't care, nor do we need to waste time
            //  worring about it (the orginal code did).   The point is we 
            //  care about the actual date information, So we just advance to the 
            //  next lexume.
            //

            lpInputBuffer++;        
        }
    }

    //
    // We're finished parsing the string, now take the parsed tokens
    //  and turn them to the actual structured information we care about.
    //  So we build lpSysTime from the Array, using a local if none is passed in.
    //

    if ( lpSysTime == NULL )
    {
        lpSysTime = &sSysTime;
    }

    lpSysTime->wDayOfWeek    = (WORD)rgdwDateParseResults[DATE_INDEX_DAY_OF_WEEK];
    lpSysTime->wMilliseconds =  0;

    if ( fIsANSIDateFormat )
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MONTH];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_SECS];
        if (iLastLettered != DATE_ANSI_INDEX_YEAR)
        {
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_YEAR];
        }
        else
        {
            // Warning! This is a hack to get around the toString/toGMTstring fiasco (where the timezone is
            // appended at the end. (See above)
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_INDEX_TZ];
         }
    }
    else
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_1123_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MONTH];
        lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_YEAR];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_1123_INDEX_SECS];
    }

    //
    // Normalize the year, 90 == 1990, handle the year 2000, 02 == 2002
    //  This is Year 2000 handling folks!!!  We get this wrong and 
    //  we all look bad. 
    //

    if (lpSysTime->wYear < 100) {
        lpSysTime->wYear += ((lpSysTime->wYear < 80) ? 2000 : 1900);
    }

    //
    // if we got misformed time, then plug in the current time
    // !lpszHrs || !lpszMins || !lpszSec
    //

    if ( i < 4) 
    {
        SYSTEMTIME  sCurSysTime;

        // this is a bad date; logging.
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));

        GetSystemTime(&sCurSysTime);

        if ( i < 2 )
        {
            //
            // If we really messed up the parsing, then
            //  just use the current time. 
            //

            *lpSysTime = sCurSysTime;
        }
        else
        {
            lpSysTime->wHour = sCurSysTime.wHour;
            lpSysTime->wMinute = sCurSysTime.wMinute;
            lpSysTime->wSecond = sCurSysTime.wSecond;
        }
    }


    if ((lpSysTime->wDay > 31)
    || (lpSysTime->wHour > 23)
    || (lpSysTime->wMinute > 59)
    || (lpSysTime->wSecond > 59)) 
    {
        fRet = FALSE;
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
        goto quit;
    }

    // Hack: we want the system time to be accurate. This is _suhlow_
    // The time passed in is in the local time zone; we have to convert this into GMT.
    
    if (iLastLettered==DATE_ANSI_INDEX_YEAR)
    {
        i--;
        
        FILETIME ft1, ft2;

        fRet = 
            SystemTimeToFileTime(lpSysTime, &ft1);

        if (fRet)
        {
            fRet = LocalFileTimeToFileTime(&ft1, &ft2);
            if (fRet)
            {
                fRet = FileTimeToSystemTime(&ft2, lpSysTime);
            }

        }
        
        if (!fRet)
        {
            DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
            goto quit;
        }
    }


    //
    // If FILETIME Ptr passed in/or we have an Offset to another Time Zone
    //   then convert to FILETIME for necessity/convenience
    //

    if ( lpft ||
         (i > DATE_INDEX_TZ &&
          rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT))
    {

        if ( lpft == NULL )
        {
            lpft = &ftTime;
        }

        fRet = 
            SystemTimeToFileTime(lpSysTime, lpft);

        if ( ! fRet )
        {
           DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
           goto quit;
        }

        if (i > DATE_INDEX_TZ &&
            rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT) 
        {
            // time zones are a very expensive operation, I want to know if this is a common case.
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*** Received a time zone: %d\n", (int) rgdwDateParseResults[DATE_INDEX_TZ]
                        ));

            //
            // if we received +/-nnnn as offset (hhmm), modify the output FILETIME
            //

            LONGLONG delta;
            BOOL negative;
            int offset;

            offset = (int) rgdwDateParseResults[DATE_INDEX_TZ];

            //
            // BUGBUG - some sites return +0000 instead of GMT. Presumably, this is
            //          an offset from GMT (== 0). What are the units? What are the
            //          boundaries (-12 hours to +12 hours? In seconds? (43200
            //          seconds in 12 hours, so can't be this)
            //

            //
            // BUGBUG - must handle negatives...and (-1 == GMT)
            //

            if (offset < 0) {
                negative = TRUE;
                offset = -offset;
            } else {
                negative = FALSE;
            }

            //
            // hours and minutes as 100nSec intervals
            //

            delta = (((offset / 100) * 60)
                    + (offset % 100)) * 60 * 10000000;
            if (negative) {
                delta = -delta;
            }
            AddLongLongToFT(lpft,delta);

            //
            // Chk to see if we Need to turn the offseted 
            //   FILETIME back into SYSTEMTIME.
            //

            if ( lpSysTime == &sSysTime )
            {
                fRet = FileTimeToSystemTime(lpft, lpSysTime);
            }
        }
    }

quit:

    DEBUG_LEAVE(fRet);

    return fRet;
}

PUBLIC 
BOOL 
FParseHttpDate(
    OUT FILETIME *lpft,
    IN  LPCSTR lpInputBuffer
    )

/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME time format.  

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    return FInternalParseHttpDate(
                lpft,                
                NULL, // SYSTEMTIME
                lpInputBuffer
                );
}



//+---------------------------------------------------------------------------
//
//  Function: FFileTimetoHttpDateTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    )
{
    SYSTEMTIME  sSysTime;

    INET_ASSERT (*lpdwSize >= HTTP_DATE_SIZE);

    if (FileTimeToSystemTime(lpft, &sSysTime)) {
        *lpdwSize = wsprintf(lpszBuff, cszHttpDateFmt
                , rgszWkDay[sSysTime.wDayOfWeek]
                , sSysTime.wDay
                , rgszMon[sSysTime.wMonth-1]
                , sSysTime.wYear
                , sSysTime.wHour
                , sSysTime.wMinute
                , sSysTime.wSecond);
        return (TRUE);
    }
    return (FALSE);
}


BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    Takes a HTTP time/date string of the format "Sat, 6 Jan 1996 21:22:04 GMT"
    and converts it to a SYSTEMTIME structure

Arguments:

    lpszHttpDate    - pointer to time string to convert

    lpSystemTime    - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string

--*/

{
    return FInternalParseHttpDate(
                NULL, // FILETIME               
                lpSystemTime, 
                (LPCSTR)lpszHttpDate
                );
}


INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPSTR lpszTime          // output string buffer
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    lpszTime: buffer to return the string in

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %#x",
                     pst,
                     lpszTime
                     ));

    DWORD dwErr;
    BOOL fResult = TRUE;
    FILETIME ft;

    INET_ASSERT(!( IsBadReadPtr (pst, sizeof(*pst))
                || IsBadWritePtr (lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE)
                || !SystemTimeToFileTime(pst, &ft)
                ));

    if (!SystemTimeToFileTime(pst, &ft))
    {
        fResult = FALSE;
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        SYSTEMTIME st;

        if (!FileTimeToSystemTime(&ft, &st))
        {
            // If a round trip isn't allowed (e.g. boundary case involving year
            // near 65535), then fail the call.
            fResult = FALSE;
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            pst = &st;
        }

        if (fResult)
        {
            wsprintf (lpszTime, cszHttpDateFmt,
                rgszWkDay[pst->wDayOfWeek],
                pst->wDay,
                rgszMon[pst->wMonth-1],
                pst->wYear,
                pst->wHour,
                pst->wMinute,
                pst->wSecond);
        }
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI
BOOL
WINAPI
InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeToSystemTimeA",
                     "%q, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));
    BOOL fRet;;
    
    INET_ASSERT(! (IsBadWritePtr (lpSysTime, sizeof(*lpSysTime)) 
                || IsBadStringPtr(lpcszTimeString, 0xffff)) );

    fRet = FInternalParseHttpDate(NULL, lpSysTime, (LPCSTR)lpcszTimeString);
    if (!fRet)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
    }
    DEBUG_LEAVE_API(fRet);
    return (fRet);
}

INTERNETAPI
BOOL
WINAPI
WinHttpTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPWSTR lpszTime         // output string buffer
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    lpszTime: buffer to return the string in

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpTimeFromSystemTimeW",
                     "%#x, %#x",
                     pst,
                     lpszTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;
    DWORD ccSize;
    
    if (!lpszTime
        || IsBadWritePtr(lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE)
        || !pst
        || IsBadReadPtr(pst, sizeof(*pst)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpTime.psStr = (LPSTR)ALLOC_BYTES(WINHTTP_TIME_FORMAT_BUFSIZE);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpTime.dwAlloc = WINHTTP_TIME_FORMAT_BUFSIZE;
    
    fResult = InternetTimeFromSystemTimeA(pst, mpTime.psStr);

    if (fResult)
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE/sizeof(WCHAR)))
        {
            INET_ASSERT(FALSE);
            fResult = FALSE;
            dwErr = ERROR_INSUFFICIENT_BUFFER;;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI
BOOL
WINAPI
WinHttpTimeToSystemTime(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpTimeFromSystemTime",
                     "%wq, %#x",
                     lpcszTimeString,
                     lpSysTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;

    if (!lpcszTimeString
        || IsBadStringPtrW(lpcszTimeString,-1)
        || !lpSysTime
        || IsBadWritePtr(lpSysTime,sizeof(SYSTEMTIME)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpcszTimeString, 0, mpTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpcszTimeString, mpTime);
    fResult = InternetTimeToSystemTimeA(mpTime.psStr, lpSysTime, NULL);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\proc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This file contains global procedure declarations for the HTTP API
    project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>

DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    );

BOOL FParseHttpDate(
    FILETIME *lpFt,
    LPCSTR lpcszDateStr
    );

BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    );

#if defined(__cplusplus)
}
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\open.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    open.cxx

Abstract:

    This file contains the implementation of the HttpOpenRequestA API.

    The following functions are exported by this module:

        HttpOpenRequestA
        WinHttpOpenRequest
        ParseHttpUrl
        ParseHttpUrl_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpOpenRequestA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hConnect            - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request. May be NULL in which
                          case "GET" will be used

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier. May be NULL in which case the empty
                          string will be used

    lpszVersion         - The version string for the request. May be NULL in
                          which case "HTTP/1.0" will be used

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    HINTERNET

        Success - non-NULL (open) handle to an HTTP request

        Failure - NULL. Error status is available by calling GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestA",
                     "%#x, %.80q, %.80q, %.80q, %.80q, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD error;
    HINTERNET hConnectMapped = NULL;
    BOOL fRequestUsingProxy;
    HINTERNET hRequest = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // find path from internet handle and validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters. Allow lpszVerb to default to "GET" if a NULL pointer
    // is supplied
    //

    if (!ARGUMENT_PRESENT(lpszVerb) || (*lpszVerb == '\0')) {
        lpszVerb = DEFAULT_HTTP_REQUEST_VERB;
    }

    //
    // if a NULL pointer or empty string is supplied for the object name, then
    // convert to the default object name (root object)
    //

    if (!ARGUMENT_PRESENT(lpszObjectName) || (*lpszObjectName == '\0')) {
        lpszObjectName = "/";
    }

    // check the rest of the parameters
    if (dwFlags & ~WINHTTP_OPEN_REQUEST_FLAGS_MASK)
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // default to the current supported version
    char versionBuffer[sizeof("HTTP/4294967295.4294967295")];
    DWORD verMajor;
    DWORD verMinor;

    if (!ARGUMENT_PRESENT(lpszVersion) || (*lpszVersion == '\0')) {
        wsprintf(versionBuffer,
                 "HTTP/%d.%d",
                 HttpVersionInfo.dwMajorVersion,
                 HttpVersionInfo.dwMinorVersion
                 );
        lpszVersion = versionBuffer;
        verMajor = HttpVersionInfo.dwMajorVersion;
        verMinor = HttpVersionInfo.dwMinorVersion;
    } else if (strnicmp(lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR p = (LPSTR)lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&p, 0, (LPINT)&verMajor);
        while (!isdigit(*p) && (*p != '\0')) {
            ++p;
        }
        ExtractInt(&p, 0, (LPINT)&verMinor);
    } else {
        verMajor = 1;
        verMinor = 0;
    }

    //
    // if we have HTTP 1.1 enabled in the registry and the version is < 1.1
    // then convert
    //

    if (GlobalEnableHttp1_1
    && (((verMajor == 1) && (verMinor == 0)) || (verMajor < 1))) {
        lpszVersion = "HTTP/1.1";
    }

    //
    // allow empty strings to be equivalent to NULL pointer
    //

    if (ARGUMENT_PRESENT(lpszReferrer) && (*lpszReferrer == '\0')) {
        lpszReferrer = NULL;
    }

    // get the target port
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;
    INTERNET_PORT hostPort;
    hostPort = pConnect->GetHostPort();

    //
    // set the per-thread info: parent handle object
    //

    _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);

    //
    // make local HTTP request handle object before we can add headers to it
    //

    error = RMakeHttpReqObjectHandle(hConnectMapped,
                                     &hRequest,
                                     NULL,  // (CLOSE_HANDLE_FUNC)wHttpCloseRequest
                                     dwFlags,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    //
    // add the request line
    //

    INET_ASSERT((lpszVerb != NULL) && (*lpszVerb != '\0'));
    INET_ASSERT((lpszObjectName != NULL) && (*lpszObjectName != '\0'));
    INET_ASSERT((lpszVersion != NULL) && (*lpszVersion != '\0'));

    if (!pRequest->LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // encode the URL-path
    //

    error = pRequest->AddRequest((LPSTR)lpszVerb,
                                 (LPSTR)lpszObjectName,
                                 (LPSTR)lpszVersion
                                 );
    if (error != ERROR_SUCCESS) {
        pRequest->UnlockHeaders();
        goto quit;
    }

    //
    // set the method type from the verb
    //

    pRequest->SetMethodType(lpszVerb);

    //
    // add the headers
    //

    if (lpszReferrer != NULL) {
        error = pRequest->AddRequestHeader(HTTP_QUERY_REFERER,
                                           (LPSTR)lpszReferrer,
                                           lstrlen(lpszReferrer),
                                           0,
                                           CLEAN_HEADER
                                           );
        if (error != ERROR_SUCCESS) {
            pRequest->UnlockHeaders();
            goto quit;
        }
    }

    if (lplpszAcceptTypes != NULL) {
        while (*lplpszAcceptTypes) {
            error = pRequest->AddRequestHeader(HTTP_QUERY_ACCEPT,
                                               (LPSTR)*lplpszAcceptTypes,
                                               lstrlen(*(LPSTR*)lplpszAcceptTypes),
                                               0,
                                               CLEAN_HEADER | COALESCE_HEADER_WITH_COMMA
                                               );
            if (error != ERROR_SUCCESS) {
                pRequest->UnlockHeaders();
                goto quit;
            }
            ++lplpszAcceptTypes;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    pRequest->UnlockHeaders();

    //
    // change the object state to opened
    //

    pRequest->SetState(HttpRequestStateOpen);
    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetRequestUsingProxy(
                                                    FALSE
                                                    );

    if (hostPort == INTERNET_INVALID_PORT_NUMBER)
    {
        if (dwFlags & WINHTTP_FLAG_SECURE)
        {
            pRequest->SetHostPort(INTERNET_DEFAULT_HTTPS_PORT);
        }
        else
        {
            pRequest->SetHostPort(INTERNET_DEFAULT_HTTP_PORT);
        }
    }
    else
    {
        pRequest->SetHostPort(hostPort);
    }

    //
    // if the object name is not set then all cache methods fail
    //

    URLGEN_FUNC fn;
    fn = (URLGEN_FUNC)pHttpGetUrlString;

    //
    // BUGBUG - change prototype to take LPCSTR
    //

    error = pRequest->SetObjectName((LPSTR)lpszObjectName,
                                    NULL,
                                    &fn
                                    );

quit:

    _InternetDecNestingCount(1);

done:

    if (error != ERROR_SUCCESS) {
        if (hRequest != NULL) {
            WinHttpCloseHandle(((HANDLE_OBJECT *)hRequest)->GetPseudoHandle());
        }

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        hRequest = NULL;
    } else {

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hRequest = ((HANDLE_OBJECT *)hRequest)->GetPseudoHandle();
    }

    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(hRequest);

    return hRequest;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hHttpSession        - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier

    lpszVersion         - The version string for the request

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    !NULL - An open handle to an HTTP request.

    NULL - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpenRequest",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags
                     ));

    HINTERNET hConnectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpVerb, mpObjectName, mpVersion, mpReferrer;
    MEMORYPACKETTABLE mptAcceptTypes;
    BOOL isLocal;
    BOOL isAsync;

    if (dwFlags &~ (WINHTTP_OPEN_REQUEST_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    // map the handle
    dwErr = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS) 
    {
        goto cleanup;
    }

    // find path from internet handle and validate handle
    dwErr = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (dwErr != ERROR_SUCCESS) 
    {
        goto cleanup;
    }

    if (lpszVerb)
    {
        if (IsBadStringPtrW(lpszVerb, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszVerb,0,mpVerb);
        if (!mpVerb.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVerb,mpVerb);
    }
    if (lpszObjectName)
    {
        if (IsBadStringPtrW(lpszObjectName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT*)hConnectMapped;
        DWORD dwCodePage = pConnect->GetCodePage();
        dwErr = ConvertUnicodeToMultiByte(lpszObjectName, dwCodePage, &mpObjectName, 
                (dwFlags&(WINHTTP_FLAG_ESCAPE_PERCENT|WINHTTP_FLAG_NULL_CODEPAGE))|WINHTTP_FLAG_DEFAULT_ESCAPE ); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    if (lpszVersion)
    {
        if (IsBadStringPtrW(lpszVersion, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszVersion,0,mpVersion);
        if (!mpVersion.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVersion,mpVersion);
    }
    if (lpszReferrer)
    {
        if (IsBadStringPtrW(lpszReferrer, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszReferrer,0,mpReferrer);
        if (!mpReferrer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszReferrer,mpReferrer);
    }

    // Create a table of ansi strings
    if (lplpszAcceptTypes)
    {
        WORD csTmp=0;
        do
        {
            if (IsBadReadPtr(lplpszAcceptTypes+csTmp*sizeof(LPCWSTR), sizeof(LPCWSTR)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            if (lplpszAcceptTypes[csTmp])
            {
                if (IsBadStringPtrW(lplpszAcceptTypes[csTmp++], -1))
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }
            else
                break;
        }
        while (TRUE);

        mptAcceptTypes.SetUpFor(csTmp);
        for (WORD ce=0; ce < csTmp; ce++)
        {
            mptAcceptTypes.pdwAlloc[ce] = (lstrlenW(lplpszAcceptTypes[ce]) + 1)*sizeof(WCHAR);
            mptAcceptTypes.ppsStr[ce] = (LPSTR)ALLOC_BYTES(mptAcceptTypes.pdwAlloc[ce]*sizeof(CHAR));
            if (!mptAcceptTypes.ppsStr[ce])
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            mptAcceptTypes.pdwSize[ce] = WideCharToMultiByte(CP_ACP,
                                                                0,
                                                                lplpszAcceptTypes[ce],
                                                                mptAcceptTypes.pdwAlloc[ce]/sizeof(WCHAR),
                                                                mptAcceptTypes.ppsStr[ce],
                                                                mptAcceptTypes.pdwAlloc[ce],NULL,NULL);
        }
    }

    hInternet = HttpOpenRequestA(hConnect, mpVerb.psStr, mpObjectName.psStr, mpVersion.psStr,
                               mpReferrer.psStr, (LPCSTR*)mptAcceptTypes.ppsStr,
                               dwFlags, NULL);

cleanup:
    if (hConnectMapped != NULL)
    {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\makeconn.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    makeconn.cxx

Abstract:

    This file contains the MakeConnection method

    Contents:
        CFsm_MakeConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_MakeConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_MakeConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_MakeConnection * stateMachine = (CFsm_MakeConnection *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->MakeConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm(
    IN CFsm_MakeConnection * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(MakeConnection_Fsm);

    CFsm_MakeConnection & fsm = *Fsm;
    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    if (state == FSM_STATE_INIT) {
        if (GetAuthState() == AUTHSTATE_NEEDTUNNEL) {
            state = FSM_STATE_1;
        } else if (IsTalkingToSecureServerViaProxy()) {
            state = FSM_STATE_3;
        } else {
            state = FSM_STATE_6;
        }
    } else {
        state = fsm.GetFunctionState();
    }
    switch (state) {
    case FSM_STATE_1:

        //
        // If we're attempting to do NTLM authentication using Proxy tunnelling
        // and we don't have a keep-alive socket to use, then create one
        //

        if (!(IsWantKeepAlive() && (_Socket != NULL) && _Socket->IsOpen())) {
            fsm.SetFunctionState(FSM_STATE_2);
            error = OpenProxyTunnel();
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
                goto quit;
            }
        } else {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_2:
        if ((error != ERROR_SUCCESS)
        || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        if (_Socket->IsSecure()) {
            /* SCLE ref */
            error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // Undo the proxy-ified info found in this Request Object, make it seem like
        //  we're doing a connect connection, since we're about to do something like it
        //  ( a tunnelled connection through the firewall )
        //

        error = SetServerInfoWithScheme(INTERNET_SCHEME_HTTP, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LPSTR urlPath;
        DWORD urlPathLength;

        //
        // get URL-path again if it was changed during tunnel creation
        //

        error = CrackUrl(GetURL(),
                     lstrlen(GetURL()),
                     FALSE, // don't escape URL-path
                     NULL,  // don't care about scheme type
                     NULL,  // or scheme name
                     NULL,  // or scheme name length
                     NULL,  // or host name
                     NULL,  // or host name length
                     NULL,  // or port
                     NULL,  // or user name
                     NULL,  // or user name length
                     NULL,  // or password
                     NULL,  // or password length
                     &urlPath,
                     &urlPathLength,
                     NULL,  // don't care about extra
                     NULL,  // or extra length
                     NULL
                     );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        if (LockHeaders())
        {
            ModifyRequest(HTTP_METHOD_TYPE_GET,
                          urlPath,
                          urlPathLength,
                          NULL,
                          0
                          );

            UnlockHeaders();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        //SetProxyNTLMTunnelling(FALSE);
        SetRequestUsingProxy(FALSE);             // don't generate proxy stuff.
        break;

    case FSM_STATE_3:

        //
        // Hack for SSL2 Client Hello bug in IIS Servers.
        //  Need to ReOpen connection after failure with
        //  a Client Hello Message.
        //

        if (_Socket != NULL) {
            ((ICSecureSocket *)_Socket)->SetProviderIndex(0);
        }

attempt_ssl_connect:

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_4);
        error = OpenProxyTunnel();
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_4:
        if ((error != ERROR_SUCCESS) || (GetStatusCode() != HTTP_STATUS_OK)) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if the app wants a secure channel (PCT/SSL) then we must negotiate
        // the security here
        //

        //
        // dwProviderIndex will be managed by SecureHandshakeWithServer,
        // And will be set to 0 when we can't try anymore.
        //

        DWORD asyncFlags;

        //
        // find out if we're async. N.B. see Assumes
        //

        asyncFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;

        //
        // If we're Posting or sending data, make sure
        //  the SSL connection knows about it, for the
        //  purposes of generating errors.
        //

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
        || (GetMethodType() == HTTP_METHOD_TYPE_PUT)) {
            asyncFlags |= SF_SENDING_DATA;
        }

        fsm.SetFunctionState(FSM_STATE_5);
        error = ((ICSecureSocket *)_Socket)->SecureHandshakeWithServer(
                                                (asyncFlags | SF_ENCRYPT),
                                                &fsm.m_bAttemptReconnect);
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_5:
        if (error != ERROR_SUCCESS) {

            if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED)
            {
                if (_Socket->IsSecure())
                {
                    if(m_pSecurityInfo)
                    {
                        /* SCLE ref */
                        m_pSecurityInfo->Release();
                    }
                    /* SCLE ref */
                    m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                }
            }

            //
            // we disconnected the socket and we won't attempt to reconnect. We
            // need to release the connection to balance the connection limiter
            //

            if (!fsm.m_bAttemptReconnect)
            {
                ReleaseConnection(TRUE,     // bClose
                                  FALSE,    // bIndicate
                                  TRUE      // bDispose
                                  );
            }
            else
            {
                _Socket->Disconnect();
            }
        }

        //
        // SSL2 hack for old IIS servers.
        //  We re-open the socket, and call again.
        //

        if (fsm.m_bAttemptReconnect) {
            goto attempt_ssl_connect;
        }
        break;

    case FSM_STATE_6:
        fsm.SetFunctionState(FSM_STATE_7);
        error = OpenConnection(FALSE, FALSE);
        if (error == ERROR_IO_PENDING) {
            break;
        }

    case FSM_STATE_7:
//dprintf("HTTP connect took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        //hack
        if (error == ERROR_SUCCESS &&
            _Socket &&
            _Socket->IsSecure() &&
            m_pSecurityInfo == NULL
            )
        {
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
        }
        break;

    default:

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
//        PERF_LEAVE(MakeConnection_Fsm);

    }
        PERF_LEAVE(MakeConnection_Fsm);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\request.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Contains HTTP utility functions

    Contents:
        pHttpGetUrlLen
        pHttpGetUrlString
        pHttpBuildUrl

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine finds the length of an HTTP URL from targethostname
    port and the object and returns the length

Arguments:

    SchemeType      - type of scheme for URL

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port (if not default)

    lpdwUrlLen      - returned URL length

Return Value:

    DWORD

--*/

{
    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {
        return ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

    int portLen;

    *lpdwUrlLen = 0;

    if (dwPort) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);
        
        portLen = lstrlen(TcpipPortString);
    } else {
        portLen = 0;
    }

    *lpdwUrlLen = schemeLength
                + sizeof("://")
                + portLen
                + lstrlen(lpszTargetName)
                + lstrlen(lpszObjectName)
                ;

    return ERROR_SUCCESS;
}

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an HTTP URL constructed
    from the TargetHost, the ObjectName and the port. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      -
    lpszTargetName  -
    lpszCWD         -
    lpszObjectName  -
    lpszExtension   -
    dwPort          -
    lplpUrlName     -
    lpdwUrlLen      -

Return Value:

    DWORD

--*/

{
    DWORD dwError, dwSav, i;
    URL_COMPONENTS sUrlComp;
    char *pBuff = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH);

    if (pBuff == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpszCWD == NULL);

    *lplpUrlName = NULL;

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = SchemeType;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = lpszObjectName;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = INTERNET_MAX_URL_LENGTH;

    for (i=0; i<2; i++)
    {
        if(!WinHttpCreateUrlA(&sUrlComp, 0, pBuff, &dwSav))
        {
            dwError = GetLastError();

            if ((dwError == ERROR_INSUFFICIENT_BUFFER)
                && (i==0))
            {
                LPSTR pTemp = (LPSTR)REALLOCATE_MEMORY(pBuff, dwSav, LMEM_MOVEABLE);
                if (pTemp)
                {
                    pBuff = pTemp;
                    continue;
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            goto Cleanup;
        }
        else
        {
            dwError = ERROR_SUCCESS;
            break;
        }
    }
    // BUGBUG, this is because WinHttpCreateUrl is not returning
    // the correct size

    dwSav = strlen(pBuff)+5;

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(pBuff, *lplpUrlName, &dwSav, ICU_ENCODE_SPACES_ONLY)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (pBuff)
        FREE_MEMORY(pBuff);
    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    )

/*++

Routine Description:

    This routine builds an HTTP URL in the buffer passed. If the size is not
    enough it returns ERROR_INSUFFICIENT_BUFFER.

Arguments:

    SchemeType      - type of scheme - http, gopher, etc.

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port number (if not default)

    lpszUrl         - place to write URL

    lpdwBuffSize    - IN: size of lpszUrl buffer
                      OUT: size of URL written to lpszUrl

Return Value:

    DWORD

--*/

{
    DWORD dwBuffLen;
    DWORD error;

    error = pHttpGetUrlLen(SchemeType,
                           lpszTargetName,
                           lpszObjectName,
                           dwPort,
                           &dwBuffLen
                           );
    if (error != ERROR_SUCCESS) {
        return error;
    }
    if (dwBuffLen > *lpdwBuffSize) {
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {

        //
        // should never happen
        //

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

    LPSTR p = lpszUrl;
    int len;
    int urlLength;

    memcpy((LPVOID)p, (LPVOID)schemeName, schemeLength);
    p += schemeLength;
    urlLength = schemeLength;

    memcpy((LPVOID)p, (LPVOID)"://", sizeof("://") - 1);
    p += sizeof("://") - 1;
    urlLength += sizeof("://") - 1;

    len = lstrlen(lpszTargetName);
    memcpy((LPVOID)p, (LPVOID)lpszTargetName, len);
    p += len;
    urlLength += len;

    if (dwPort && (dwPort != INTERNET_DEFAULT_HTTP_PORT)) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);

        INET_ASSERT(TcpipPortString[0] != '\0');

        *p++ = ':';
        len = lstrlen(TcpipPortString);
        memcpy((LPVOID)p, (LPVOID)TcpipPortString, len);
        p += len;
        urlLength += len + 1;
    }

    len = lstrlen(lpszObjectName);
    memcpy((LPVOID)p, (LPVOID)lpszObjectName, len);
    urlLength += len;

    *lpdwBuffSize = urlLength;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\read.cxx ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name:

    read.cxx

Abstract:

    This file contains the implementation of the HttpReadData API.

    Contents:
        HttpReadData
        CFsm_HttpReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::ReadData
        CFsm_ReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable
        CFsm_HttpQueryAvailable::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse
        CFsm_DrainResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpReadData remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwLen
    );

//
// functions
//


DWORD
HttpReadData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Reads a block of data from an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetReadFile() which
        globally validates parameters for all Internet data read
        functions

         2. We will never get a request for 0 bytes at this level. This
        request will have been handled in InternetReadFile()

Arguments:

    hRequest                - mapped HTTP request handle

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToRead   - number of bytes to read into lpBuffer

    lpdwNumberOfBytesRead   - number of bytes read into lpBuffer

    dwSocketFlags           - controlling socket operation

Return Value:

    TRUE - The data was read successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpReadData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 dwSocketFlags
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) hRequest;

    error = DoFsm(New CFsm_HttpReadData(lpBuffer,
                                        dwNumberOfBytesToRead,
                                        lpdwNumberOfBytesRead,
                                        dwSocketFlags,
                                        pRequest
                                       ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpReadData * stateMachine = (CFsm_HttpReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->HttpReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm(
    IN CFsm_HttpReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpReadData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!CheckReceiveResponseState() || !IsValidHttpState(READ)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
            goto quit;
        }
        error = ReadData(fsm.m_lpBuffer,
                         fsm.m_dwNumberOfBytesToRead,
                         fsm.m_lpdwNumberOfBytesRead,
                         FALSE, // BUGBUG RFirthRemove on chkin
                         fsm.m_dwSocketFlags
                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    PERF_LOG(PE_TRACE, 0x1002);

    DEBUG_LEAVE(error);

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN BOOL fNoAsync, // BUGBUG RFirthRemove on DrainSocket checkin
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT ReadData method

    Reads data into users buffer. Reads from header buffer if data exists
    there, or reads from the socket

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToRead   - size of buffer/number of bytes to read

    lpdwNumberOfBytesRead   - pointer to returned number of bytes read

    fNoAsync                - TRUE if we want to override defaults and have
                              no Async Read.

    dwSocketFlags           - controlling socket operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData",
                 "%#x, %d, %#x, %B, %#x",
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 fNoAsync,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(New CFsm_ReadData(lpBuffer,
                                          dwNumberOfBytesToRead,
                                          lpdwNumberOfBytesRead,
                                          fNoAsync,
                                          dwSocketFlags,
                                          this
                                          ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadData * stateMachine = (CFsm_ReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm(
    IN CFsm_ReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_LOG(PE_TRACE, 0x6001);

    CFsm_ReadData & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {

        PERF_LOG(PE_TRACE, 0x6101);

        error = fsm.GetError();
        goto receive_continue;
    }

    fsm.m_dwBytesRead = 0;
    fsm.m_dwBufferLeft = fsm.m_dwNumberOfBytesToRead;
    fsm.m_nBytesCopied = 0;

    //
    // if there's no data then we're done
    //

    if (!IsData()) {

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("!IsData()\n"
                    ));

        SetState(HttpRequestStateReopen);

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //
    // If using keep-alive, reduce output buffer so we don't over-read.
    //

    if (IsKeepAlive() && IsContentLength()) {
        if (_BytesRemaining == 0) {

            INET_ASSERT(error == ERROR_SUCCESS);

            PERF_LOG(PE_TRACE, 0x6102);

            goto done;
        }

        PERF_LOG(PE_TRACE, 0x6103);

        fsm.m_dwBufferLeft = min(fsm.m_dwBufferLeft, _BytesRemaining);
    }

    //
    // if there's data left in the response buffer then copy it
    //

    fsm.m_bEof = FALSE;

    if (IsBufferedData()) {

        DWORD amountToCopy = min(fsm.m_dwNumberOfBytesToRead, BufferDataAvailToRead());

        if (amountToCopy != 0) {

            PERF_LOG(PE_TRACE, 0x6104);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Copying %d (%#x) bytes from header buffer @ %#x - %d left\n",
                        amountToCopy,
                        amountToCopy,
                        BufferedDataStart(),
                        BufferDataAvailToRead() - amountToCopy
                        ));

            memcpy(fsm.m_lpBuffer, BufferedDataStart(), amountToCopy);
            ReduceDataAvailToRead(amountToCopy);
            fsm.m_dwBytesRead += amountToCopy;
            fsm.m_dwBufferLeft -= amountToCopy;
            fsm.m_nBytesCopied += amountToCopy;

            //
            // we don't update lpBuffer here. Receive() takes the address of
            // the start of the buffer
            //

        }

        //
        // if we exhausted all the buffer space, then we're done
        //

        if (fsm.m_dwBufferLeft == 0) {

            PERF_LOG(PE_TRACE, 0x6105);

            goto done;
        }
    }

    //
    // find out if we're async. Even though the handle was created for async I/O
    // the request may be satisfied immediately
    //

    DWORD asyncFlags;

    if ( fsm.m_fNoAsync )   // BUGBUG RFirthRemove on Checkin of DrainSocket
        asyncFlags = 0;
    else
        asyncFlags = (IsAsyncHandle()
                        && (fsm.m_dwBufferLeft > AvailableDataLength()))
                   ? SF_NON_BLOCKING
                   : 0
                   ;

    //
    // if we have data already received in the query buffer, then return that
    //

    if (HaveQueryData()) {

        PERF_LOG(PE_TRACE, 0x6106);

        DWORD nCopied;

        nCopied = CopyQueriedData((LPVOID)((LPBYTE)fsm.m_lpBuffer + fsm.m_dwBytesRead),
                                  fsm.m_dwBufferLeft
                                  );

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied %d (%#x) bytes from query buffer @ %#x - %d left\n",
                    nCopied,
                    nCopied,
                    (LPBYTE)_QueryBuffer - _QueryOffset,
                    _QueryBytesAvailable
                    ));

        fsm.m_dwBytesRead += nCopied;
        fsm.m_dwBufferLeft -= nCopied;
        fsm.m_nBytesCopied += nCopied;
        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    if (HaveReadFileExData()) {
        PERF_LOG(PE_TRACE, 0x6107);
        *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
        --fsm.m_dwNumberOfBytesToRead;
        --fsm.m_dwBufferLeft;
        ++fsm.m_dwBytesRead;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied 1 byte (%#x) from ReadFileEx buffer %#x\n",
                    (BYTE)_ReadFileExData & 0xff,
                    &_ReadFileExData
                    ));

        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    if ( IsChunkEncoding() && IsDecodingFinished() )
    {
        PERF_LOG(PE_TRACE, 0x6108);
        fsm.m_bEof = TRUE;
        goto done;
    }

    //
    // we're about to check the socket. Make sure its valid to do so
    //

    //INET_ASSERT(_Socket != NULL);

    if ((_Socket == NULL) || !_Socket->IsOpen()) {

        //
        // socket was closed - no more data
        //

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6109);
        goto quit;
    }

read_again:

    fsm.m_nBytes = fsm.m_dwBytesRead;

    //
    // if we had a content-length and we don't think there is any data left to
    // read then we're done
    //

    if (IsContentLength() && (_BytesInSocket == 0)) {
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6110);
        goto done;
    }

    //
    // receive data into user's buffer. Because we don't own the buffer, we
    // cannot resize it
    //

    LPVOID lpBuffer;
    DWORD dwBytesToRead;
    DWORD dwBufferLeft;
    DWORD dwBytesRead;

    lpBuffer = fsm.m_lpBuffer;
    dwBytesToRead = fsm.m_dwNumberOfBytesToRead;
    dwBufferLeft = fsm.m_dwBufferLeft;
    dwBytesRead = fsm.m_dwBytesRead;

    //INET_ASSERT(!(fsm.m_dwSocketFlags & SF_NO_WAIT)
    //            ? (fsm.m_dwBufferLeft <= _BytesRemaining)
    //            : TRUE);

    PERF_LOG(PE_TRACE, 0x6111);

    if (IsBadNSServer() && !IsConnCloseResponse()) {
        SetBadNSReceiveTimeout();
    }

    error = _Socket->Receive(&fsm.m_lpBuffer,
                             &fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBufferLeft,
                             &fsm.m_dwBytesRead,
                             0,
                             SF_INDICATE
                             | ((fsm.m_dwSocketFlags & SF_NO_WAIT)
                                ? SF_NO_WAIT
                                : (IsChunkEncoding() ? 0 : SF_RECEIVE_ALL)),
                             &fsm.m_bEof
                             );

    //
    // only if we performed an asynchronous no-wait receive and there was no
    // data available in the socket will we get WSAEWOULDBLOCK. Make another
    // receive request, this time without no-wait. It will complete
    // asynchronously and the app must make another no-wait request
    //

    if (error == WSAEWOULDBLOCK) {

        PERF_LOG(PE_TRACE, 0x6112);

        INET_ASSERT(fsm.m_dwSocketFlags & SF_NO_WAIT);
        INET_ASSERT(!fsm.m_bEof);

        //
        // BUGBUG - IsAsyncHandle() || IsAsyncRequest()
        //

        if ((fsm.m_dwBytesRead == 0) && IsAsyncHandle()) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Initiating wait-for-data (1-byte read)\n"
                        ));

            fsm.m_lpBuffer = (LPVOID)&_ReadFileExData;
            fsm.m_dwNumberOfBytesToRead = 1;
            fsm.m_dwBufferLeft = 1;
            fsm.m_dwSocketFlags &= ~SF_NO_WAIT;

            INET_ASSERT(!_HaveReadFileExData);

            SetReadFileExData();

            _ReadFileExData = 0;

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            PERF_LOG(PE_TRACE, 0x6113);

            if (IsBadNSServer() && !IsConnCloseResponse()) {
                SetBadNSReceiveTimeout();
            }

            error = _Socket->Receive(&fsm.m_lpBuffer,
                                     &fsm.m_dwNumberOfBytesToRead,
                                     &fsm.m_dwBufferLeft,
                                     &fsm.m_dwBytesRead,
                                     0,
                                     fsm.m_dwSocketFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_SUCCESS) {

                PERF_LOG(PE_TRACE, 0x6114);

                BOOL fReadNothing = (fsm.m_dwBytesRead == 0 ? TRUE : FALSE);

                //
                // we have successfully read a single byte from the socket.
                //

                //INET_ASSERT(FALSE);

                fsm.m_lpBuffer = lpBuffer;
                fsm.m_dwNumberOfBytesToRead = dwBytesToRead;
                fsm.m_dwBufferLeft = dwBufferLeft;
                fsm.m_dwBytesRead = dwBytesRead;
                if (fReadNothing) {
                    // Don't copy if nothing was actually read.
                    ResetReadFileExData();
                }
                else {
                    *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
                    --fsm.m_dwBufferLeft;
                    ++fsm.m_dwBytesRead;
                }

                //
                // BUGBUG - if socket unblocked already, should go round & read
                //          again, not just return 1 byte
                //

            }

            PERF_LOG(PE_TRACE, 0x6115);

        } else {

            PERF_LOG(PE_TRACE, 0x6116);

            DEBUG_PRINT(HTTP,
                        WARNING,
                        ("Not initiating wait-for-data: bytesRead = %d, asyncHandle = %B\n",
                        fsm.m_dwBytesRead,
                        IsAsyncHandle()
                        ));

            //
            // read data from buffers but nothing available from socket
            //

            error = ERROR_SUCCESS;
        }
    }

    if (error == ERROR_IO_PENDING) {
        PERF_LOG(PE_TRACE, 0x6117);
        goto quit_pending;
    }

receive_continue:

    PERF_LOG(PE_TRACE, 0x6118);

    //
    // if we timed-out while talking to 'bad' NS server (returns HTTP/1.1 but
    // content-length or chunked encoding info) then close the connection and
    // reset any RFX status. We return SUCCESS in this case
    //

    if ((error == ERROR_WINHTTP_TIMEOUT) && IsBadNSServer()) {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Bad NS server: Closing connection %#x/%d on timeout\n",
                    _Socket ? _Socket->GetSocket() : -1,
                    _Socket ? _Socket->GetSourcePort() : -1
                    ));

        CloseConnection(TRUE);
        ResetReadFileExData();
        SetData(FALSE);
        fsm.m_bEof = TRUE;
        error = ERROR_SUCCESS;
        goto quit;
    }
    if (error == ERROR_SUCCESS) {
        if (IsContentLength()) {

            INET_ASSERT(fsm.m_dwBytesRead >= fsm.m_nBytes);

            _BytesInSocket -= fsm.m_dwBytesRead - fsm.m_nBytes;

            INET_ASSERT((int)_BytesInSocket >= 0);

            if ((int)_BytesInSocket < 0) {
                _BytesInSocket = 0;
            }
        }

        if ( IsChunkEncoding() && !(HaveReadFileExData()))
        {

            PERF_LOG(PE_TRACE, 0x6119);

            DWORD dwChunkBytesRead = 0;
            DWORD dwChunkBytesWritten = 0;

            error = _ResponseFilterList.Decode(
                (LPBYTE)fsm.m_lpBuffer + fsm.m_nBytesCopied,
                fsm.m_dwBytesRead - fsm.m_nBytesCopied,
                NULL,
                NULL,
                &dwChunkBytesRead,
                &dwChunkBytesWritten);

            // When no error, the number of bytes read should match the input byte count
            INET_ASSERT(error == ERROR_SUCCESS &&  // for now, let's see all errors
                        fsm.m_dwBytesRead - fsm.m_nBytesCopied == dwChunkBytesRead);

            fsm.m_dwBufferLeft += (fsm.m_dwBytesRead - fsm.m_nBytesCopied);
            fsm.m_dwBytesRead  -= (fsm.m_dwBytesRead - fsm.m_nBytesCopied);

            fsm.m_dwBufferLeft -= dwChunkBytesWritten;
            fsm.m_dwBytesRead  += dwChunkBytesWritten;
            fsm.m_nBytesCopied += dwChunkBytesWritten;

            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            // Chunked transfers tell us when to expect EOF
            if ( IsDecodingFinished() )
            {
                fsm.m_bEof = TRUE;
            }
            else if (fsm.m_dwBytesRead < fsm.m_dwNumberOfBytesToRead &&
                     !fsm.m_bEof)
            {
                // read some more
                goto read_again;
            }
        }
    } else {

        PERF_LOG(PE_TRACE, 0x6121);

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("error %d on socket %#x\n",
                    error,
                    _Socket->GetSocket()
                    ));

        //
        // socket error
        //

        SetState(HttpRequestStateError);

        //
        // cause connection to be closed/released
        //

        fsm.m_bEof = TRUE;
    }

done:

    //
    // only update bytes remaining, EOF and the current stream position values
    // if we're returning data. If we just completed reading ReadFileEx data
    // then don't update. The 1 byte of ReadFileEx data will be read on the next
    // read proper
    //

    if (HaveReadFileExData()) {
        goto quit;
    }

    //
    // whether the data came from the response buffer or the socket, if we have
    // a content-length, update the amount of data left to retrieve
    //

    if (IsChunkEncoding()
        && IsDecodingFinished()
        && (_QueryBytesAvailable == 0)
        && (BufferDataAvailToRead() == 0)) {
        fsm.m_bEof = TRUE;
    } else if (IsKeepAlive() && IsContentLength()) {
        _BytesRemaining -= fsm.m_dwBytesRead;

        INET_ASSERT((int)_BytesRemaining >= 0);
        //
        // if we have read all the entity-body then we can release the keep-alive
        // connection, or close the socket
        //

        if (_BytesRemaining<=0 && ((int)_BytesRemaining>=-2)) {
            // We might overshoot by 1 or 2 because of server misinformation.
            fsm.m_bEof = TRUE;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("read %d bytes\n",
                fsm.m_dwBytesRead
                ));

    //
    // if we reached the end of the connection - either the end of the server
    // connection for real, or we received all indicated data on a keep-alive
    // connection - then close the connection
    //

    if (fsm.m_bEof) {

        PERF_LOG(PE_TRACE, 0x6122);

        //
        // if we don't need to keep hold of the connection, release it. In the
        // case of multi-part authentication (NTLM) over keep-alive connection
        // we need to keep the connection. With Kerberos, we don't need to keep
        // the connection.
        //

        if (GetAuthState() != AUTHSTATE_CHALLENGE) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("end of data - freeing connection %#x (Auth State = %s)\n",
                        _Socket ? _Socket->GetSocket() : 0,
                        (GetAuthState() == AUTHSTATE_NONE)
                            ? "NONE"
                            : ((GetAuthState() == AUTHSTATE_NEGOTIATE)
                                ? "NEGOTIATE"
                                : ((GetAuthState() == AUTHSTATE_CHALLENGE)
                                    ? "CHALLENGE"
                                    : "?"))
                        ));

            CloseConnection(FALSE);

        } else {

            // AUTHSTATE_CHALLENGE - check if request is through proxy or is kerberos.

            // When IsRequestUsingProxy returns TRUE, there are three types of connections possible:
            // 1) http request forwarded by the proxy to the server
            // 2) connect request to proxy to establish https tunnel
            // 3) using https tunnel through proxy to the server

            // I believe the various methods return:
            // http conn. tunnel
            // IsRequestUsingProxy                          1 1 1
            // IsViaProxy                       1 1 0
            // IsTunnel 0   1 0
            // IsTalkingToSecureServerViaProxy 0 0 1

            INET_ASSERT(_pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE);

            if (GetAuthCtx()->GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - kerberos and auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }                
            else if (IsRequestUsingProxy()
                && !(IsTunnel() || IsTalkingToSecureServerViaProxy())
                && (_pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED)
                && !_pAuthCtx->_fIsProxy)
            {
                // Ordinarily, if the auth state is AUTHSTATE_CHALLENGE we wish to keep
                // the current connection open (keep alive) so that the response will go
                // out on the same socket. NTLM, which requires keep-alive, does not
                // work when going through a proxy. In the case that the proxy does not return keep-alive with the
                // challenge (Catapult appears to be the only proxy that does) we want to
                // close the socket to ensure that it is not subsequently used for the response.

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }
            else
            {
                //  Keep alive required - don't close socket.
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("not freeing connection - auth state challenge\n"
                            ));
            }

        }

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

quit:

    //
    // update the amount of data returned then we're outta here
    //

    *fsm.m_lpdwNumberOfBytesRead = fsm.m_dwBytesRead;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

quit_pending:

    PERF_LOG(PE_TRACE, 0x6002);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines how much data is available to be read by the caller

    BUGBUG - need cache case

Arguments:

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_WINHTTP_INCORRECT_HANDLE_STATE

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable",
                 "%#x",
                 lpdwNumberOfBytesAvailable
                 ));

    DWORD error = DoFsm(New CFsm_HttpQueryAvailable(lpdwNumberOfBytesAvailable,
                                                    this
                                                    ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpQueryAvailable::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpQueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpQueryAvailable * stateMachine = (CFsm_HttpQueryAvailable *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm(
    IN CFsm_HttpQueryAvailable * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpQueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD bytesAvailable = 0;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto fsm_continue;
    }

    INET_ASSERT(fsm.GetState() == FSM_STATE_INIT);

    //
    // the handle must be readable
    //

    if (!CheckReceiveResponseState() || !IsValidHttpState(READ)) {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    fsm.m_bEof = FALSE;

    //
    // error must be ERROR_SUCCESS - we just read it out of FSM & didn't jump
    // anywhere
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // first check if there is data to receive at all
    //

    if (IsData()) {

        //
        // if there's buffered data still available from receiving the headers,
        // then return that length, else query the information from the socket
        //

        if (IsBufferedData()) {
            bytesAvailable = BufferDataAvailToRead();

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("%d bytes available in buffer\n",
                        bytesAvailable
                        ));

        } else if (_Socket != NULL) {

            //
            // the rest of the data must be read from the socket
            //

            BOOL checkSocket;

            if (IsKeepAlive() && IsContentLength()) {
                checkSocket = ((int)_BytesInSocket > 0) ? TRUE : FALSE;
            } else if (IsChunkEncoding()) {
                checkSocket = !IsDecodingFinished();
            } else {
                checkSocket = TRUE;
            }
            if (checkSocket) {
                if (_QueryBuffer != NULL) {
                    bytesAvailable = _QueryBytesAvailable;
                    checkSocket = (bytesAvailable == 0) ? TRUE : FALSE;
                } else {
                    error = _Socket->AllocateQueryBuffer(&_QueryBuffer,
                                                         &_QueryBufferLength
                                                         );
                    if (error != ERROR_SUCCESS) {
                        checkSocket = FALSE;
                    }
                }
            } else if (IsKeepAlive() && IsContentLength() && (_BytesRemaining == 0)) {
                fsm.m_bEof = TRUE;
            } else if (IsChunkEncoding() && IsDecodingFinished()) {
                fsm.m_bEof = TRUE;
            }
            if (checkSocket) {

                INET_ASSERT(_Socket->IsValid());
                INET_ASSERT(_QueryBytesAvailable == 0);

                //
                // reset the query buffer offset
                //

                _QueryOffset = 0;

                //
                // don't create another FSM just for the DataAvailable2 wrapper.
                // If it ever becomes more than a call to Receive() then create
                // an FSM
                //

                fsm.m_lpBuffer = _QueryBuffer;
                fsm.m_dwBufferLength = (IsKeepAlive() && IsContentLength())
                                     ? min(_BytesRemaining, _QueryBufferLength)
                                     : _QueryBufferLength;
                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;

                //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

                if (IsBadNSServer() && !IsConnCloseResponse()) {
                    SetBadNSReceiveTimeout();
                }

                error = _Socket->Receive(&fsm.m_lpBuffer,
                                         &fsm.m_dwBufferLength,
                                         &fsm.m_dwBufferLeft, // don't care about this
                                         &_QueryBytesAvailable,
                                         0,
                                         0,
                                         &fsm.m_bEof
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

fsm_continue:

                if ((error == ERROR_WINHTTP_TIMEOUT) && IsBadNSServer()) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("Bad NS server: Closing connection %#x/%d on timeout\n",
                                _Socket ? _Socket->GetSocket() : -1,
                                _Socket ? _Socket->GetSourcePort() : -1
                                ));

                    CloseConnection(TRUE);
                    _QueryBytesAvailable = 0;
                    error = ERROR_SUCCESS;
                }
                if (error == ERROR_SUCCESS) {


                    if ( IsChunkEncoding() && (_QueryBytesAvailable != 0))
                    {
                        DWORD dwChunkBytesRead = 0;
                        DWORD dwChunkBytesWritten = 0;

                        error = _ResponseFilterList.Decode((LPBYTE)_QueryBuffer,
                                                           _QueryBytesAvailable,
                                                           NULL,
                                                           NULL,
                                                           &dwChunkBytesRead,
                                                           &dwChunkBytesWritten);

                        _QueryBytesAvailable = dwChunkBytesWritten;

                        INET_ASSERT(error == ERROR_SUCCESS); // I want to see this.

                        if ( error != ERROR_SUCCESS )
                        {
                            goto quit;
                        }
                    }

                    bytesAvailable = _QueryBytesAvailable;

                    //
                    // note the amount of data that is available immediately.
                    // This allows e.g. async InternetReadFile() to complete
                    // synchronously if the next request is for <= bytesAvailable
                    //

                    //SetAvailableDataLength(bytesAvailable);

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("%d bytes available in socket %#x\n",
                                bytesAvailable,
                                (_Socket ? _Socket->GetSocket() : 0)
                                ));

                    if ((bytesAvailable == 0)
                    && (IsChunkEncoding() ? IsDecodingFinished() : TRUE)) {
                        fsm.m_bEof = TRUE;
                    }
                    if (IsKeepAlive() && IsContentLength()) {
                        _BytesInSocket -= bytesAvailable;

                        INET_ASSERT((int)_BytesInSocket >= 0);

                        if ((int)_BytesInSocket < 0) {
                            _BytesInSocket = 0;
                        }
                    }
                }
            }
        } else {

            //
            // all data read from socket & socket released
            //

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(bytesAvailable == 0);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
    } else {

        INET_ASSERT(error == ERROR_SUCCESS);

        //
        // we may have already removed all the data from the socket
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("all data has been read\n"
                    ));

        fsm.m_bEof = TRUE;
    }

quit:

    *fsm.m_lpdwNumberOfBytesAvailable = bytesAvailable;

    //
    // if we have reached the end of the data then we can release the connection
    //

    /*
    if (fsm.m_bEof || (bytesAvailable >= _BytesRemaining)) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }
    */
    if (fsm.m_bEof) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse(
    OUT LPBOOL lpbDrained
    )

/*++

Routine Description:

    Receives any remaining response data into the buffer we allocated for the
    headers. Used in redirection: if the server returns some HTML page (e.g.)
    with the redirection response, we give the app a chance to read it. This
    way, we allow the app to retrieve the data immediately during the status
    callback in which we indicate that the request has been redirected

Arguments:

    lpbDrained  - TRUE if we really drained the socket else FALSE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to ERROR_WINHTTP_XXX

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse",
                 "%#x",
                 lpbDrained
                 ));

    DWORD error = DoFsm(New CFsm_DrainResponse(lpbDrained, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_DrainResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_DrainResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_DrainResponse * stateMachine = (CFsm_DrainResponse *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->DrainResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm(
    IN CFsm_DrainResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_DrainResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL drainIt = FALSE;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        drainIt = TRUE;
        goto fsm_continue;
    }

    PERF_LOG(PE_TRACE, 0x8001);

    drainIt = TRUE;

    //
    // if the socket is already closed, we can't drain it
    //

    if ((_Socket == NULL) || !_Socket->IsValid()) {
        drainIt = FALSE;
    } else if (IsWantKeepAlive()) {

        //
        // IIS 1.0 has a bug where it can return a failure indication to a
        // request that was made using a keep-alive connection. The response
        // doesn't contain a keep-alive header but the server has left open the
        // connection AND it has returned us fewer bytes than was claimed in
        // the content-length header. If we try to drain the response buffer at
        // this point, we will wait a long time waiting for the server to send
        // us the non-existent additional bytes. Therefore, if we are talking
        // to an IIS 1.0 server, we don't drain the response buffer
        //

        LPSTR lpszServerBuf;
        DWORD serverBufferLength;

        if (_ResponseHeaders.LockHeaders())
        {
            error = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                            (LPVOID *)&lpszServerBuf,
                                            &serverBufferLength,
                                            0
                                            );
            if (error == ERROR_SUCCESS) {

#define IIS         "Microsoft-IIS/"
#define IIS_LEN     (sizeof(IIS) - 1)

#define PWS         "Microsoft-PWS/"
#define PWS_LEN     (sizeof(PWS) - 1)

#define PWS95       "Microsoft-PWS-95/"
#define PWS95_LEN   (sizeof(PWS95) - 1)

#define IIS10       "Microsoft-Internet-Information-Server/"
#define IIS10_LEN   (sizeof(IIS10) - 1)

                if ((serverBufferLength > IIS_LEN)
                    && !strnicmp(lpszServerBuf, IIS, IIS_LEN)) {

                    int major_num = 0;

                    for (DWORD i = IIS_LEN; i < serverBufferLength; ++i) {

                        char ch = lpszServerBuf[i];

                        if (isdigit(ch)) {
                            major_num = major_num * 10 + (int)(ch - '0');
                        } else {
                            break;
                        }
                    }
                    if (major_num < 4) {
                        drainIt = FALSE;
                    }
                } else if (IsBadNSServer()) {
                    drainIt = FALSE;
                } else if (((serverBufferLength > IIS10_LEN)
                            && !strncmp(lpszServerBuf, IIS10, IIS10_LEN))
                           || ((serverBufferLength > PWS_LEN)
                               && !strncmp(lpszServerBuf, PWS, PWS_LEN))
                           || ((serverBufferLength > PWS95_LEN)
                               && !strncmp(lpszServerBuf, PWS95, PWS95_LEN))) {
                    drainIt = FALSE;
                }
            }
            _ResponseHeaders.UnlockHeaders();
        }
    }

    error = ERROR_SUCCESS;

    if (drainIt) {

        fsm.m_dwAsyncFlags = IsAsyncHandle() ? SF_WAIT : 0;
        fsm.m_dwAmountToRead = IsContentLength() ? _BytesInSocket : (DWORD)-1;
        //DWORD bufferLeft = _ResponseBufferLength - _BytesReceived;
        fsm.m_dwBufferLeft = min(fsm.m_dwAmountToRead, _ResponseBufferLength - _BytesReceived);

        if (IsChunkEncoding() && IsDecodingFinished()) {
            fsm.m_dwAmountToRead = 0;
            fsm.m_bEof = TRUE;

            INET_ASSERT(fsm.m_dwBytesReceived == 0);

        }

        //
        // either receive the amount specified in the "Content-Length" header, or
        // receive until we hit the end of the connection. We may have already
        // received the entire response
        //

        while ((fsm.m_dwAmountToRead != 0) && !fsm.m_bEof && (error == ERROR_SUCCESS)) {

            fsm.m_dwPreviousBytesReceived = _BytesReceived;

            //
            // receive the rest of the data. We are assuming here that it is a
            // couple of K at the most. Notice that we don't care to make status
            // callbacks to the app while we are doing this
            //

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                     &_ResponseBufferLength,
                                     &fsm.m_dwBufferLeft,
                                     &_BytesReceived,
                                     0,   // dwExtraSpace
                                     SF_EXPAND
                                     | SF_COMPRESS
                                     | fsm.m_dwAsyncFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

fsm_continue:

            if (error == ERROR_SUCCESS) {

                DWORD nRead = _BytesReceived - fsm.m_dwPreviousBytesReceived;

                if (IsContentLength()) {
                    fsm.m_dwAmountToRead -= nRead;

                    INET_ASSERT((int)fsm.m_dwAmountToRead >= 0);

                    _BytesInSocket -= nRead;

                    INET_ASSERT((int)_BytesInSocket >= 0);

                    if (IsKeepAlive()) {
                        _BytesRemaining -= nRead;

                        INET_ASSERT((int)_BytesRemaining >= 0);

                        //
                        // if we have read all the entity-body then we can
                        // release the keep-alive connection, or close the
                        // socket
                        //

                        //
                        // BUGBUG - put back post-ie30a
                        //

                        //if (_BytesRemaining == 0) {
                        //    fsm.m_bEof = TRUE;
                        //}
                    }
                }

                if ( IsChunkEncoding() )
                {
                    DWORD dwChunkBytesRead = 0;
                    DWORD dwChunkBytesWritten = 0;

                    INET_ASSERT(!IsContentLength());

                    error = _ResponseFilterList.Decode(
                        _ResponseBuffer + fsm.m_dwPreviousBytesReceived,
                        nRead,
                        NULL,
                        NULL,
                        &dwChunkBytesRead,
                        &dwChunkBytesWritten
                        );

                    nRead = dwChunkBytesWritten;
                    _BytesReceived = nRead + fsm.m_dwPreviousBytesReceived;

                    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                    if ( error != ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( IsDecodingFinished() )
                    {
                        fsm.m_bEof = TRUE;
                        break;
                    }
                }

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwPreviousBytesReceived = _BytesReceived;
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // update the amount of data immediately available to the caller
        //

        IncreaseAvailableDataLength(fsm.m_dwBytesReceived);

        //
        // and set the end-of-file indication in the top level handle object
        //

        SetEndOfFile();

        //
        // there is no more data to be received on this HTTP object
        //

        //SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

    //
    // return indication that we drained the socket
    //

    DEBUG_PRINT(HTTP,
                INFO,
                ("returning *lpbDrained = %B\n",
                drainIt
                ));

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        *fsm.m_lpbDrained = drainIt;
    }

    PERF_LOG(PE_TRACE, 0x8002);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout(
    VOID
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout",
                 NULL
                 ));

    if ((_Socket != NULL)
        && !IsContentLength()
        && !IsChunkEncoding()) {

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo) {

            DWORD timeout = max(5000, 5 * pServerInfo->GetRTT());

            _Socket->SetTimeout(RECEIVE_TIMEOUT, timeout);
            SetTimeout(WINHTTP_OPTION_RECEIVE_TIMEOUT, timeout);
        }
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\response.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    This file contains the HTTP Request Handle Object ReceiveResponse method

    Contents:
        CFsm_ReceiveResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (1 K)

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_ReceiveResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReceiveResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReceiveResponse * stateMachine = (CFsm_ReceiveResponse *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReceiveResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm(
    IN CFsm_ReceiveResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
#if INET_DEBUG
//#define RLF_TEST_CODE
#ifdef RLF_TEST_CODE

//
// single 100 response
//

#define TEST_HEADER_0   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n"

//
// single 100 header
//

#define TEST_HEADER_1   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// continue header with moderate amount of data
//

#define TEST_HEADER_2   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Content-Length: 128\r\n" \
                        "Content-Type: octet/shmoctet\r\n" \
                        "\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef"

//
// continue header seen from apache server
//

#define TEST_HEADER_3   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n" \
                        "\n\n\n\n\n"

//
// multiple continue headers, no data
//

#define TEST_HEADER_4   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// single 100 response, preceeded by preamble and containing a chunked response
//

#define TEST_HEADER_5   "!!!! this is a pre-amble, should be ignored even though it includes HTTP !!!!" \
                        "     " \
                        "HTTP/1.1 100 Go ahead punk, make my day\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0010 this is the first chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "  10; this is the second chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "00F3\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "012" \
                        "\r\n" \
                        "0000; the final chunk\r\n" \
                        "\r\n" \
                        "Entity-Header: this is the chunk footer\r\n" \
                        "\r\n"

//
// enpty chunk encoded response with empty footer
//

#define TEST_HEADER_6   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0\r\n" \
                        "\r\n" \
                        "\r\n"

    const struct {LPSTR ptr; DWORD len;} test_cases[] = {
        TEST_HEADER_0, sizeof(TEST_HEADER_0) - 1,
        TEST_HEADER_1, sizeof(TEST_HEADER_1) - 1,
        TEST_HEADER_2, sizeof(TEST_HEADER_2) - 1,
        TEST_HEADER_3, sizeof(TEST_HEADER_3) - 1,
        TEST_HEADER_4, sizeof(TEST_HEADER_4) - 1,
        TEST_HEADER_5, sizeof(TEST_HEADER_5) - 1,
        TEST_HEADER_6, sizeof(TEST_HEADER_6) - 1
    };
    DWORD test_index = 99;

#endif // def RLF_TEST_CODE
#endif // INET_DEBUG

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(ReceiveResponse_Fsm);

    CFsm_ReceiveResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();

    if (error != ERROR_SUCCESS) {

        if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) {

            if ((_Socket != NULL) && _Socket->IsSecure())
            {
                if(m_pSecurityInfo)
                {
                    /* SCLE ref */
                    m_pSecurityInfo->Release();
                }
                /* SCLE ref */
                m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            }

            SetState(HttpRequestStateOpen);
            CloseConnection(TRUE);
            fsm.SetDone();
            goto quit2;
        }

        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    do {
        switch (state) {
        case FSM_STATE_INIT:
            if (_ResponseBuffer == NULL) {
                _ResponseBufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
                _ResponseBuffer = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED,
                                                          _ResponseBufferLength);
                if (_ResponseBuffer == NULL) {
                    _ResponseBufferLength = 0;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            INET_ASSERT(_BytesReceived == 0);

            fsm.m_dwResponseLeft = _ResponseBufferLength;
            state = FSM_STATE_2;

            //
            // fall through
            //

#ifdef RLF_TEST_CODE

            InternetGetDebugVariable("WininetTestIndex", &test_index);
            if (test_index < ARRAY_ELEMENTS(test_cases)) {
                _BytesReceived = test_cases[test_index].len;
                memcpy(_ResponseBuffer, test_cases[test_index].ptr, _BytesReceived);
                fsm.m_dwResponseLeft = _ResponseBufferLength - _BytesReceived;
            }

#endif // def RLF_TEST_CODE

        case FSM_STATE_2:

            //
            // we will allow Receive() to expand the buffer (and therefore initially
            // allocate it), and to compress the buffer if we receive the end of the
            // connection. It is up to UpdateResponseHeaders() to figure out when
            // enough data has been read to indicate end of the headers
            //

            fsm.SetFunctionState(FSM_STATE_3);

            INET_ASSERT(_Socket != NULL);

            if (_Socket != NULL) {
                error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                         &_ResponseBufferLength,
                                         &fsm.m_dwResponseLeft,
                                         &_BytesReceived,
                                         0,
                                         SF_EXPAND
                                         | SF_COMPRESS
                                         | SF_INDICATE,
                                         &fsm.m_bEofResponseHeaders
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto quit;
                }
            } else {
                error = ERROR_WINHTTP_OPERATION_CANCELLED;
            }

            //
            // fall through
            //

        case FSM_STATE_3:

            //
            // if we are using a keep-alive connection that was previously timed-out
            // by the server, we may not find out about it until now
            //
            // Note: it seems we can get a zero length response at this point also,
            // which I take to mean that the server-side socket has been closed
            //

            INET_ASSERT(_BytesReceived <= _ResponseBufferLength);

            if ((error != ERROR_SUCCESS)
            || ((_BytesReceived == 0) && IsKeepAlive())) {

                //
                // We need to reset the state if we got a
                // certificate request.
                //

                if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) {

                    if ((_Socket != NULL) && _Socket->IsSecure())
                    {
                        if(m_pSecurityInfo)
                        {
                            /* SCLE ref */
                            m_pSecurityInfo->Release();
                        }
                        /* SCLE ref */
                        m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                    }

                    SetState(HttpRequestStateOpen);
                }
                CloseConnection(TRUE);
                goto quit;
            }

            //
            // if we received no data then the server has closed the connection
            // already
            //

            if (_BytesReceived != 0) {

                BOOL bHaveFinalResponse;

                do {
                    bHaveFinalResponse = TRUE;
                    error = UpdateResponseHeaders(&fsm.m_bEofResponseHeaders);
//if (!(rand() % 7)) {
//    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
//}
                    if (error != ERROR_SUCCESS) {
//dprintf("UpdateResponseHeaders() returns %d\n", error);
                        break;
                    }

                    DWORD statusCode;

                    statusCode = GetStatusCode();

                    //
                    // receive next packet if we didn't get a status code yet
                    //

                    if (statusCode == 0) {
                        break;
                    }

                    //
                    // discard any 1xx responses and get the headers again
                    //

                    if (fsm.m_bEofResponseHeaders
                    && (statusCode >= HTTP_STATUS_CONTINUE)
                    && (statusCode < HTTP_STATUS_OK)) {
                        bHaveFinalResponse = FALSE;
                        fsm.SetFunctionState(FSM_STATE_4);

                        //
                        // get any data that came with the header
                        //

                        fsm.m_bDrained = FALSE;
                        if (IsContentLength() && (_BytesInSocket != 0)) {
                            error = DrainResponse(&fsm.m_bDrained);
                            if (error != ERROR_SUCCESS) {
                                goto quit;
                            }
                        }

                        //
                        // fall through
                        //

        case FSM_STATE_4:

                        //
                        // now that we have drained the socket, we can indicate
                        // the response to the app. This gives apps chance to
                        // perform progress reporting for each 100 response
                        // received, e.g.
                        //
                        DWORD dwStatusCode = statusCode;
                        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE,
                                               &dwStatusCode,
                                               sizeof(dwStatusCode)
                                               );

                        //
                        // if there is no more data left in the buffer then we
                        // can receive the next response at the start of the
                        // buffer, else continue from where the previous one
                        // ended
                        //

                        if (fsm.m_bDrained || !IsBufferedData()) {
                            fsm.m_dwResponseLeft = _ResponseBufferLength;
                            _BytesReceived = 0;
                            _DataOffset = 0;
                            _ResponseScanned = 0;
                        } else {
                            _ResponseScanned = _DataOffset;
                            if (IsContentLength()) {
                                _ResponseScanned += _ContentLength;
                            }
                        }
                        _ResponseHeaders.FreeHeaders();
                        _ResponseHeaders.Initialize();
                        ZapFlags();
                        _ContentLength = 0;
                        _BytesRemaining = 0;
                        _BytesInSocket = 0;
                        fsm.m_bEofResponseHeaders = FALSE;
                        if (_DataOffset == 0) {

                            //
                            // need to read next response - nothing left in
                            // buffer
                            //

                            break;
                        }
                    }

                    // If we have a server authentication context
                    // and the response is anything but 401, mark
                    // the socket as authenticated.
                    AUTHCTX *pAuthCtx;
                    pAuthCtx = GetAuthCtx();
                    if (pAuthCtx && !pAuthCtx->_fIsProxy
                        && (statusCode != HTTP_STATUS_DENIED))
                    {

#define MICROSOFT_IIS_SERVER_SZ "Microsoft-IIS/"
#define MICROSOFT_PWS_SERVER_SZ "Microsoft-PWS/"

#define MICROSOFT_IIS_SERVER_LEN (sizeof(MICROSOFT_IIS_SERVER_SZ) - 1)
#define MICROSOFT_PWS_SERVER_LEN (sizeof(MICROSOFT_PWS_SERVER_SZ) - 1)

                        LPSTR pszBuf;
                        DWORD cbBuf;
                        cbBuf = MAX_PATH;
                        if (FastQueryResponseHeader(HTTP_QUERY_SERVER, 
                            (LPVOID*) &pszBuf, &cbBuf, 0) == ERROR_SUCCESS)
                        {
                            if (cbBuf >= MICROSOFT_IIS_SERVER_LEN 
                                && (!strncmp(pszBuf, MICROSOFT_IIS_SERVER_SZ, MICROSOFT_IIS_SERVER_LEN)
                                    || !strncmp(pszBuf, MICROSOFT_PWS_SERVER_SZ, MICROSOFT_PWS_SERVER_LEN)))

                            {                            
                                // Found an IIS header. Mark socket as authenticated if 
                                // IIS 1, 2 or 3. Lengths of both strings are same.
                                CHAR *pVer = pszBuf + MICROSOFT_IIS_SERVER_LEN;
                                if (*pVer == '1'
                                    || *pVer == '2'
                                    || *pVer == '3'
                                    )
                                {
                                    // IIS 1, 2 or 3  - mark dirty.
                                    _Socket->SetAuthenticated();
                                }
                            }                                
                        }
                        else
                        {
                            // Unknown server; may be IIS 1,2 or 3.
                            _Socket->SetAuthenticated();
                        }
                    }

                } while (!bHaveFinalResponse);
            } else {
                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            }

            //
            // set state to perform next receive
            //

            state = FSM_STATE_2;
        }
    } while ((error == ERROR_SUCCESS) && !fsm.m_bEofResponseHeaders);

    //
    // we should update the RTT as soon as we get received data from
    // the socket, but then we'd have to store the RTT in the socket
    // object or access this one, etc. Just keep it here for now -
    // its a reasonable approximation in the normal IE case: not too
    // much time spent in callbacks etc.
    //

    UpdateRTT();
//dprintf("RTT for %s = %d\n", GetURL(), GetRTT());
//dprintf("OS = %s, PS = %s\n", ((GetOriginServer() != NULL) ? GetOriginServer()->GetHostName() : "none"),
//    ((GetServerInfo() != NULL) ? GetServerInfo()->GetHostName() : "none"));

    //
    // we have received the headers and possibly some (or all) of the data. The
    // app can now query the headers and receive the data
    //

    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //
    if ( IsChunkEncoding() )
    {
        DWORD dwChunkBytesRead = 0;
        DWORD dwChunkBytesWritten = 0;

        error = _ResponseFilterList.Decode(
            (LPBYTE) BufferedDataStart(),
            BufferedDataLength(),
            NULL,
            NULL,
            &dwChunkBytesRead,
            &dwChunkBytesWritten
            );

        _ResponseBufferDataReadyToRead = dwChunkBytesWritten;

        INET_ASSERT(error == ERROR_SUCCESS);
        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    SetAvailableDataLength(BufferDataAvailToRead());

    //
    // IIS caches authentication credentials on keep-alive sockets.
    //

    if (_Socket) {

        if (IsAuthorized()) {
            _Socket->SetAuthorized();
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // if we got the socket from the keep-alive pool, but found no keep-
        // alive header then we no longer have a keep-alive connection
        //

        if (_bKeepAliveConnection && !IsKeepAlive()) {
//dprintf("*** %s - NO LONGER K-A socket %#x\n", GetURL(), _Socket->GetSocket());
            SetNoLongerKeepAlive();
        }

        //
        // don't maintain the connection if there's no more data to read. UNLESS
        // we are in the middle of establishing an authenticated connection
        // (implies using keep-alive connection, e.g. NTLM)
        // IsData() returns FALSE if there's no data at all, otherwise we
        // check to see if we have read all the data already (i.e. with the
        // response headers)
        //

        if ((error != ERROR_SUCCESS)
            || (

                //
                // data-less response (ignoring keep-alive & content-length)
                //

                (!IsData()

                 //
                 // all data body in header buffer
                 //

                 || (IsKeepAlive()
                     && IsContentLength()
                     && (BufferedDataLength() == GetContentLength())
                     )
                 )

                //
                // but only if not in the middle of auth negotiation and if the
                // connection hasn't been dropped by the server
                //

                && ((GetAuthState() != AUTHSTATE_NEGOTIATE)
                    || IsNoLongerKeepAlive())
                )
            ) {

//dprintf("socket %#x [%#x/%d] error=%d, IsData()=%B, K-A=%B, C-L=%d, BDL=%d, AS=%d\n",
//        _Socket,
//        _Socket ? _Socket->GetSocket() : 0,
//        _Socket ? _Socket->GetSourcePort() : 0,
//        error,
//        IsData(),
//        IsKeepAlive(),
//        GetContentLength(),
//        BufferedDataLength(),
//        GetAuthState()
//        );

            //
            // BUGBUG - if this is a new keep-alive connection?
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("closing: error = %d, IsData() = %B, K-A = %B, IsC-L = %B, BDL = %d, C-L = %d\n",
                        error,
                        IsData(),
                        IsKeepAlive(),
                        IsContentLength(),
                        BufferedDataLength(),
                        GetContentLength()
                        ));

            if(GetStatusCode() != HTTP_STATUS_REDIRECT || (HTTP_METHOD_TYPE_HEAD == GetMethodType()))
                CloseConnection((error != ERROR_SUCCESS) ? TRUE : FALSE);
            else
                DEBUG_PRINT(HTTP, INFO, ("Not closing socket, Status code = %d \n", GetStatusCode()));

            //
            // set the relevant state
            //

            if (error != ERROR_SUCCESS &&
                (error != ERROR_WINHTTP_SECURE_FAILURE ||
                 GetStatusFlags() & ~(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID |
                                     WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)) &&
                error != ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
            {
                SetState(HttpRequestStateError);
            }
        }

        PERF_LEAVE(ReceiveResponse_Fsm);
    }

quit2:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\redirect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    Contains HTTP_REQUEST_HANDLE_OBJECT method for handle redirection

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::Redirect

Author:

    Richard L Firth (rfirth) 18-Feb-1996

Environment:

    Win32 user-level

Revision History:

    18-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// manifests
//

#define DEFAULT_COOKIE_BUFFER_LENGTH    (1 K)

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect(
    IN HTTP_METHOD_TYPE tMethod,
    IN BOOL fRedirectToProxy
    )

/*++

Routine Description:

    Called after a successful SendData() in which we discover that the requested
    object has been moved.

    We need to change the HTTP_REQUEST_HANDLE_OBJECT so that we can resubmit the
    request and retrieve the redirected object.

    To do this we have to:

        get the new URI
        crack the new URI
        if callbacks are enabled or the server is the same and we are using keep-alive
            drain the current response into the response buffer
        if we are not using keep-alive
            kill the connection
        if callbacks are enabled
            indicate redirection to the app
        create a new request header
        if the server or port has changed
            update the local server & port information

Arguments:

    tMethod - new request method type (e.g. if POST => GET), or POST => POST ( for HTTP 1.1)

    fRedirectToProxy  - TRUE if we're actually redirected to use a proxy instead of another site


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "Redirect",
                "%s, %x",
                MapHttpMethodType(tMethod),
                fRedirectToProxy
                ));

    DWORD error = DoFsm(New CFsm_Redirect(tMethod, FALSE, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_Redirect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_Redirect::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_Redirect * stateMachine = (CFsm_Redirect *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->Redirect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm(
    IN CFsm_Redirect * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm",
                 "%#x",
                 Fsm
                 ));

    DWORD index;
    LPSTR uriBuffer = NULL;
    DWORD uriLength = INTERNET_MAX_PATH_LENGTH;
    CFsm_Redirect & fsm = *Fsm;
    DWORD error = fsm.GetError();
    char *buffer = NULL;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (!_ResponseHeaders.LockHeaders()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!IsKeepAlive() || IsContentLength() || IsChunkEncoding()) {
            error = DrainResponse(&fsm.m_bDrained);
            if (error != ERROR_SUCCESS) {
                goto Cleanup;
            }
        }
    }

    //
    // get the "Location:" header
    //
    // BUGBUG - we also need to get & parse the "URI:" header(s)
    //

    do {

        //
        // we allow ourselves to fail due to insufficient buffer (at least once)
        //

        uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength, FALSE);
        if (uriBuffer != NULL) {

            DWORD previousLength = uriLength;

            index = 0;

            error = QueryResponseHeader(HTTP_QUERY_LOCATION,
                                        uriBuffer,
                                        &uriLength,
                                        0,      // no modifiers
                                        &index  // should only be one
                                        );
            if (error == ERROR_SUCCESS) {

                if (uriLength == 0) {
                    // Don't let an empty value succeed
                    error = ERROR_WINHTTP_REDIRECT_FAILED;
                }
                else {
                    //
                    // we probably allocated too much buffer - shrink it
                    //

                    uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength + 1, FALSE);

                    //
                    // check for NULL below
                    //
                }

            } else if ((error == ERROR_INSUFFICIENT_BUFFER)
            && (previousLength >= uriLength)) {

                //
                // this should never happen, but we will avoid a loop if it does
                //

                INET_ASSERT(FALSE);

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else if (error == ERROR_WINHTTP_HEADER_NOT_FOUND) {
                // Be clear that this is failing due to having
                // no defined location to redirect to since there's no header
                error = ERROR_WINHTTP_REDIRECT_FAILED;
            }
        }
        if (uriBuffer == NULL) {

            //
            // failed to (re)alloc or shrink
            //

            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } while (error == ERROR_INSUFFICIENT_BUFFER);
    if (error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    ////
    //// strip all cookie request headers
    ////
    //
    //RemoveAllRequestHeadersByName("Cookie");
    //
    ////
    //// and add any we received
    ////
    //
    //DWORD headerLength;
    //DWORD bufferLength;
    //LPVOID lpHeader;
    //
    //bufferLength = DEFAULT_COOKIE_BUFFER_LENGTH;
    //lpHeader = (LPVOID)ResizeBuffer(NULL, bufferLength, FALSE);
    //if (lpHeader == NULL) {
    //    error = ERROR_NOT_ENOUGH_MEMORY;
    //    goto Cleanup;
    //}
    //
    //index = 0;
    //
    //do {
    //    headerLength = bufferLength;
    //    error = QueryResponseHeader("Set-Cookie",
    //                                sizeof("Set-Cookie") - 1,
    //                                lpHeader,
    //                                &headerLength,
    //                                0,
    //                                &index
    //                                );
    //    if (error == ERROR_INSUFFICIENT_BUFFER) {
    //        error = ERROR_SUCCESS;
    //        bufferLength = headerLength;
    //        lpHeader = (LPVOID)ResizeBuffer((HLOCAL)lpHeader,
    //                                        bufferLength,
    //                                        FALSE
    //                                        );
    //        if (lpHeader == NULL) {
    //            error = ERROR_NOT_ENOUGH_MEMORY;
    //            goto Cleanup;
    //        }
    //    } else if (error == ERROR_SUCCESS) {
    //        error = AddRequestHeader("Cookie",
    //                                 sizeof("Cookie") - 1,
    //                                 (LPSTR)lpHeader,
    //                                 headerLength,
    //                                 0,
    //                                 0
    //                                 );
    //    }
    //} while (error == ERROR_SUCCESS);
    //
    //INET_ASSERT(error == ERROR_HTTP_HEADER_NOT_FOUND);

    //
    // we may have been given a partial URL. Combine it with the current base
    // URL. If both are base URLs then we just get back the new one
    //

    DWORD newUrlLength = INTERNET_MAX_URL_LENGTH;

    buffer = (char *) ALLOCATE_FIXED_MEMORY(newUrlLength + 1);
    if (buffer == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(GetURL() != NULL);

    for (int i=0; i<2; i++)
    {
        if (!InternetCombineUrl(GetURL(),
                                uriBuffer,
                                buffer,
                                &newUrlLength,
                                ICU_ENCODE_SPACES_ONLY)) 
        {
            error = GetLastError();
            if (error == ERROR_INSUFFICIENT_BUFFER)
            {
                if (i==0) 
                {
                    LPSTR pTemp = (LPSTR)REALLOCATE_MEMORY(buffer, newUrlLength + 1, LMEM_MOVEABLE);
                    if (pTemp)
                    {
                        buffer = pTemp;
                        continue;
                    }
                    else
                    {
                        error = ERROR_HTTP_REDIRECT_FAILED;
                    }
                }
                else
                {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                }
            }
            
            goto Cleanup;
        }
        else
        {
            error = ERROR_SUCCESS;
            break;
        }
    }
    //
    // we are done with uriBuffer
    //

    uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

    INET_ASSERT(uriBuffer == NULL);

    //
    // if we ended up with exactly the same URL then we're done. Note that the
    // URLs may be the same, even if they're lexicographically different - host
    // name vs. IP address e.g., encoded vs. unencoded, case sensitive? In the
    // encoded case, the URLs should be in canonical form. We may have an issue
    // with host vs IP address which will lead to an additional transaction
    //

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        DWORD eAuthScheme = 0;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if ((eAuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT) &&
            !strcmp(GetURL(), buffer))   
            // Passport1.4 auth need redirect to same site works
        {
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("URLs match: %q, %q\n",
                        GetURL(),
                        buffer
                        ));

            error = ERROR_HTTP_NOT_REDIRECTED;
            goto Cleanup;
        }
    }

    //
    // crack the new URL
    //

    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extra;
    DWORD extraLength;

    error = CrackUrl(buffer,
                     newUrlLength,
                     FALSE, // don't escape URL-path
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &port,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     &urlPath,
                     &urlPathLength,
                     &extra,
                     &extraLength,
                     NULL
                     );
    if ((error != ERROR_SUCCESS) || (hostNameLength == 0)) {

        //
        // if this is an URL for which we don't understand the protocol then
        // defer redirection to the caller
        //

        if (error == ERROR_WINHTTP_UNRECOGNIZED_SCHEME) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        } else if (hostNameLength == 0) {
            error = ERROR_HTTP_NOT_REDIRECTED;
        }
        goto Cleanup;
    }

    //
    // if the scheme is not HTTP or HTTPS then we can't automatically handle it.
    // We have to return it to the caller. For example, we cannot transmogrify
    // a HTTP handle to an FTP directory handle, and there's no way we can
    // handle a file:// URL (we don't understand file://)
    //

    if ((schemeType != INTERNET_SCHEME_HTTP)
    && (schemeType != INTERNET_SCHEME_HTTPS)) {
        error = ERROR_HTTP_REDIRECT_FAILED;
        goto Cleanup;
    }

    //
    // BUGBUG - we may get back an IP address (IPX?) in which case we need to
    //          resolve it again
    //

    //
    // map port
    //

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    //
    // if the server & port remain the same and we are using keep-alive OR
    // we think the app may want to read any data associated with the redirect
    // header (i.e. callbacks are enabled) then drain the response
    //

    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_SCHEME currentSchemeType;

    currentHostPort = GetHostPort();
    currentHostName = GetHostName(&currentHostNameLength);
    currentSchemeType = ((WINHTTP_FLAG_SECURE & GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    //
    // close the connection
    //

    //
    // BUGBUG - if we are redirecting to the same site and we have a keep-alive
    //          connection, then we don't have to do this. Worst case is that
    //          we go to get the keep-alive connection and some other bounder
    //          has taken it
    //

    //
    // if we didn't actually drain the socket because of the server type or
    // because there was no or incorrect data indication then force the
    // connection closed (if keep-alive)
    //

    CloseConnection(fsm.m_bDrained ? FALSE : TRUE);

    //
    // inform the app of the redirection. At this point, we have received all
    // the headers and data associated with the original request. We have not
    // modified the object with information for the new request. This is so
    // the application can query information about the original request - e.g.
    // the original URL - before we make the new request for the redirected item
    //

    // Make sure buffer is copied over before reporting to app, since we continue
    // to use this buffer.
    InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, buffer, TRUE/*bCopyBuffer*/);

    //
    // BUGBUG - app may have closed the request handle
    //

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            newUrlLength -= extraLength;
        } else {
            urlPathLength += extraLength;
        }
    }

    //
    // create the new request line. If we're going via proxy, add the entire URI
    // else just the URL-path
    //

    //
    // BUGBUG - do we need to perform any URL-path escaping here?
    //

    //
    // BUGBUG - always modifying POST to GET
    //

    //
    // BUGBUG - [arthurbi]
    //   this breaks For HTTPS sent over  HTTP to
    //   a proxy which turns it into HTTPS.
    //

    //INET_ASSERT(fsm.m_tMethod == HTTP_METHOD_TYPE_GET);

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    //
    // Set Url in the request object. Authentication, and Cookies
    //  depend on checking the new URL not the previous one.
    //

    BYTE bTemp;

    bTemp = buffer[newUrlLength];
    buffer[newUrlLength] = 0;

    BOOL fSuccess;

    fSuccess = SetURL(buffer);
    buffer[newUrlLength] = bTemp;

    if (!fSuccess) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // update the method, server and port, if they changed
    //

    SetMethodType(fsm.m_tMethod);

    if (port != currentHostPort) {
        SetHostPort(port);
    }
    if ((hostNameLength != currentHostNameLength)
    || (strnicmp(hostName, currentHostName, hostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        CHAR chBkChar = hostName[hostNameLength]; // save off char

        hostName[hostNameLength] = '\0';
        SetHostName(hostName);

        hostValueSize = hostNameLength;
        hostValueStr = hostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                hostName[hostNameLength] = chBkChar; // put back char
                error = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", hostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        hostName[hostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        SetServerInfo(FALSE);
    }

    //
    // if the new method is GET then remove any content-length headers (there
    // *should* only be 1!) - we won't be sending any data on the redirected
    // request. Remove any content-type (again should only be 1) also
    //

    if (fsm.m_tMethod == HTTP_METHOD_TYPE_GET) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_LENGTH);
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_TYPE);
    }

    //
    // Catch Redirections from HTTPS to HTTP (and) HTTP to HTTPS
    //

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags;

        OpenFlags = GetOpenFlags();

        //
        // Switched From HTTPS to HTTP
        //

        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(WINHTTP_FLAG_SECURE);
        }

        //
        // Switched From HTTP to HTTPS
        //

        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (WINHTTP_FLAG_SECURE);
        }


        SetOpenFlags(OpenFlags);
        SetSchemeType(schemeType);

    }

Cleanup:

    if (buffer)
        FREE_MEMORY(buffer);
    if (uriBuffer != NULL) {
        uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

        INET_ASSERT(uriBuffer == NULL);
    }

    _ResponseHeaders.UnlockHeaders();

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\send.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the HTTP Request Handle Object SendRequest method

    Contents:
        CFsm_SendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_SendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_SendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_SendRequest * stateMachine = (CFsm_SendRequest *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->SendRequest_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm(
    IN CFsm_SendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(SendRequest_Fsm);

    CFsm_SendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPSTR requestBuffer = fsm.m_pRequestBuffer;
    DWORD requestLength = fsm.m_dwRequestLength;
    LPVOID lpOptional = fsm.m_lpOptional;
    DWORD dwOptionalLength = fsm.m_dwOptionalLength;
    BOOL bExtraCrLf = fsm.m_bExtraCrLf;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    switch (state) {

    case FSM_STATE_INIT:

    fsm.SetFunctionState(FSM_STATE_1);
    error = DoFsm(New CFsm_MakeConnection(this));


    case FSM_STATE_1:

        if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        // Monolithic upload: If we have optional data to send,
        // save off in handle and flag that the data has been saved.
        // This is useful in the case of redirects and auth, because of RR FSM changes:
        if (fsm.m_lpOptional && fsm.m_dwOptionalLength)
        {
            _lpOptionalSaved = fsm.m_lpOptional;
            _dwOptionalSaved = fsm.m_dwOptionalLength;
            _fOptionalSaved = TRUE;
        }            
        else
        // Check if optional data has been saved in handle during a previous
        // SendRequest or negotiate stage. If so, restore it and content length:
        // Do it only if you don't have something already:
        if (_fOptionalSaved)
        {
            // Restore the fsm optional values and content length.
            
            lpOptional = fsm.m_lpOptional = _lpOptionalSaved;
            dwOptionalLength = fsm.m_dwOptionalLength = _dwOptionalSaved;

            if(!IsWriteRequired())
            // Reset Content-Length, but only if Writes are not required. If Writes are required, someplace
            // else would have done it. In the case of redirects and auth, we should not hit this for Writes,
            // because we fail the request:
            {
                DWORD cbNumber;
                CHAR szNumber[sizeof("4294967295")];
                cbNumber = wsprintf(szNumber, "%d", fsm.m_dwOptionalLength);

                ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                    (LPSTR)szNumber,
                                    cbNumber,
                                    0,   // dwIndex
                                    ADD_HEADER
                                    ); 
            }
        }

        // # 62953
        // If initiating NTLM authentication, don't submit request data since
        // we're expecting to get a challenge and resubmit the request anyway.
        if (GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            if (!((PLUG_CTX*)(GetAuthCtx()))->_fNTLMProxyAuth)
            {
                // We are in the negotiate phase during a POST
                // and do not have an authenticated socket. 
                // In both monolithic upload InternetWriteFile
                // cases, we wish to omit any post data, and reflect
                // this in the content length.
                if (!((GetMethodType() == HTTP_METHOD_TYPE_GET) && !IsMethodBody()))
                {
                    ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                         "0",
                                         1,
                                         0,   // dwIndex
                                         ADD_HEADER
                                         );
                }

                fsm.m_lpOptional = lpOptional = NULL;
                fsm.m_dwOptionalLength = dwOptionalLength = 0;
            }        
        }

        bExtraCrLf = (!(GetOpenFlags() & WINHTTP_FLAG_SECURE)
                      && (dwOptionalLength != 0)
                      && ((GetServerInfo() != NULL)
                        ? GetServerInfo()->IsHttp1_0()
                        : TRUE));

        //
        // collect request headers into blob
        //

        BOOL bCombinedData;

        requestBuffer = CreateRequestBuffer(&requestLength,
                                            lpOptional,
                                            dwOptionalLength,
                                            bExtraCrLf,
                                            GlobalTransportPacketLength,
                                            &bCombinedData
                                            );
        if (requestBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        DEBUG_PRINT(HTTP, INFO, ("SendRequest_FSM: lpOptional=0x%x dwOptionalLength=%d\n", 
                                fsm.m_lpOptional, fsm.m_dwOptionalLength));

        if (bCombinedData) {

            //
            // everything copied to one buffer. No need to send separate
            // optional data and CR-LF termination
            //

            fsm.m_lpOptional = lpOptional = NULL;
            fsm.m_dwOptionalLength = dwOptionalLength = 0;
            bExtraCrLf = FALSE;
        }
        fsm.m_pRequestBuffer = requestBuffer;
        fsm.m_dwRequestLength = requestLength;
        fsm.m_bExtraCrLf = bExtraCrLf;
        DEBUG_PRINT(HTTP, INFO, ("fsm.m_pRequestBuffer=0x%x\r\n", fsm.m_pRequestBuffer));
        StartRTT();

        //
        // send the request. If we are using a keep-alive connection, this may
        // fail because the server timed it out since we last used it. We must
        // be prepared to re-establish
        //

        fsm.SetFunctionState(FSM_STATE_3);
        error = _Socket->Send(requestBuffer, requestLength, SF_INDICATE);

        //
        // fall through
        //

    case FSM_STATE_3:
        if (error != ERROR_SUCCESS) {
            if (error != ERROR_IO_PENDING) {
                CloseConnection(TRUE);
            }
            goto quit;
        }

        //
        // send any optional data (that we didn't send in the request buffer).
        // If this fails then we don't retry. We assume that if the first send
        // succeedeed, but the second failed, then this is a non-recoverable
        // error
        //

        //fsm.m_bExtraCrLf = bExtraCrLf = TRUE;
        if (dwOptionalLength != 0) {

            LPSTR buffer = (LPSTR)lpOptional;
            DWORD length = dwOptionalLength;

            if (bExtraCrLf) {
                length += sizeof(gszCRLF) - 1;
                if (requestLength >= length) {
                    buffer = requestBuffer;
                } else if (length <= GlobalTransportPacketLength) {
                    requestBuffer = (LPSTR)ResizeBuffer(requestBuffer,
                                                        length,
                                                        FALSE
                                                        );
                    buffer = requestBuffer;
                    fsm.m_pRequestBuffer = requestBuffer;
                } else {
                    length -= sizeof(gszCRLF) - 1;
                }
                if (buffer == requestBuffer) {
                    memcpy(buffer, lpOptional, dwOptionalLength);
                    buffer[dwOptionalLength] = '\r';
                    buffer[dwOptionalLength + 1] = '\n';
                    fsm.m_bExtraCrLf = bExtraCrLf = FALSE;
                }
            }
            fsm.SetFunctionState(FSM_STATE_4);
            error = _Socket->Send(buffer, length, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_4:

        //
        // Here we also add an extra CR-LF if the app is sending data (even if
        // the amount of data supplied is zero) unless we are using a keep-alive
        // connection, in which case we're not dealing with old servers which
        // require CR-LF at the end of post data.
        //
        // But only do this for non-HTTP 1.1 servers and proxies ( ie when
        //  the user puts us in HTTP 1.0 mode)
        //

        if ((error == ERROR_SUCCESS) && bExtraCrLf) {
            fsm.SetFunctionState(FSM_STATE_5);
            error = _Socket->Send(gszCRLF, 2, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_5:

        //
        // we are now in receiving state
        //

        if (error == ERROR_SUCCESS) {
            SetState(HttpRequestStateResponse);
        }
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
//dprintf("HTTP connect-send took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        fsm.SetDone();

        PERF_LEAVE(SendRequest_Fsm);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\query.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    query.cxx

Abstract:

    This file contains the implementation of the HttpQueryInfoA API.

    Contents:
        HttpQueryInfoA
        WinHttpQueryHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryInfo

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpQueryInfoA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private prototypes
//

//
// private data
//

#define NUM_HEADERS ARRAY_ELEMENTS(GlobalKnownHeaders)

//
// functions
//


INTERNETAPI
BOOL
WINAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCSTR  lpszName OPTIONAL,   
    IN OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries a request or response header from the HTTP request handle

Arguments:

    hRequest            - an open HTTP request handle returned by
                          HttpOpenRequest()

    dwInfoLevel         - one of the HTTP_QUERY_* values indicating the
                          attribute to query. In addition, the following flags
                          can be set:

                            HTTP_QUERY_FLAG_REQUEST_HEADERS
                                - Causes the request headers to be queried. The
                                  default is to check the response headers

                            HTTP_QUERY_FLAG_SYSTEMTIME
                                - Causes headers that contain date & time
                                  information to be returned as SYSTEMTIME
                                  structures

                            HTTP_QUERY_FLAG_NUMBER
                                - Causes header value to be returned as a number.
                                  Useful for when the app knows it is expecting
                                  a numeric value, e.g. status code

    lpBuffer            - pointer to the buffer to receive the information.
                          If dwInfoLevel is HTTP_QUERY_CUSTOM then buffer
                          contains the header to query.

                          If NULL then we just return the required buffer length
                          to hold the header specified by dwInfoLevel

    lpdwBufferLength    - IN: contains the length (in BYTEs) of lpBuffer
                          OUT: size of data written to lpBuffer, or required
                               buffer length if ERROR_INSUFFICIENT_BUFFER
                               returned

    lpdwIndex           - IN: 0-based header index
                          OUT: next index to query, if success returned

Return Value:

    TRUE    - The query succeeded. lpBuffer contains the query information, and
              *lpdwBufferLength contains the size (in BYTEs) of the information

    FALSE   - The operation failed. Error status is available by calling
              GetLastError().

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpQueryInfoA",
                     "%#x, %s (%#x), %#x [%q], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : "",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD defaultIndex = 0;
    DWORD error;
    HINTERNET hRequestMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // find path from Internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    DWORD queryModifiers;
    DWORD infoLevel;

    queryModifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    infoLevel = dwInfoLevel & HTTP_QUERY_HEADER_MASK;

    if (((infoLevel > HTTP_QUERY_MAX) && (infoLevel != HTTP_QUERY_CUSTOM))
    || (lpdwBufferLength == NULL)

    //
    // nip in the bud apps that want SYSTEMTIME AND NUMBER for same header(!)
    //

#define EXCLUSIVE_MODIFIERS (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

    || ((dwInfoLevel & EXCLUSIVE_MODIFIERS) == EXCLUSIVE_MODIFIERS)) {

        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the app passed in a NULL lpdwIndex then it is asking for index 0
    //

    if (!ARGUMENT_PRESENT(lpdwIndex)) {
        lpdwIndex = &defaultIndex;
    }

    //
    // if the app is asking for one of the special query items - status code,
    // status text, HTTP version, or one of the raw header variants, then make
    // sure the index is 0. These pseudo-header types cannot be enumerated
    //

    if ((*lpdwIndex != 0)
    && ((infoLevel == HTTP_QUERY_VERSION)
        || (infoLevel == HTTP_QUERY_STATUS_CODE)
        || (infoLevel == HTTP_QUERY_STATUS_TEXT)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS_CRLF))) {

        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    //
    // ensure that we can use any flags passed in
    //

    if (infoLevel == HTTP_QUERY_CUSTOM) {

        //
        // the app has given us a string to locate. We only accept strings in
        // the following format:
        //
        //  <header-to-find>[:][CR][LF]<EOS>
        //
        // The header cannot contain any spaces
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        int queryLength = 0;
        int headerLength = 0;

        for (; lpszName[queryLength] != '\0'; ++queryLength) {
            if ((lpszName[queryLength] == ':')
            || (lpszName[queryLength] == '\r')
            || (lpszName[queryLength] == '\n')) {
                break;
            }
            if (iscntrl(lpszName[queryLength])
            || isspace(lpszName[queryLength])) {
                error = ERROR_INVALID_PARAMETER;
                break;
            }
        }        
    } else if ((queryModifiers & ~GlobalKnownHeaders[infoLevel].Flags) != 0) {
        error = ERROR_HTTP_INVALID_QUERY_REQUEST;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if NULL buffer pointer then app wants length of option: set buffer length
    // to zero
    //

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;
    if (dwInfoLevel & HTTP_QUERY_FLAG_REQUEST_HEADERS) {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_REQUEST, TRUE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        }
    } else {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_RESPONSE, TRUE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        }
    }
    if (error == ERROR_SUCCESS) {
        error = pRequest->QueryInfo(dwInfoLevel,
                                    lpszName,
                                    lpBuffer,
                                    lpdwBufferLength,
                                    lpdwIndex
                                    );
    }

quit:

    _InternetDecNestingCount(1);

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        success = FALSE;
    } else {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        DEBUG_DUMP_API(DUMP_API_DATA,
                       "Query data:\n",
                       lpBuffer,
                       *lpdwBufferLength
                       );

        success = TRUE;
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCWSTR lpszName OPTIONAL, 
       OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries information from the HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    dwInfoLevel - One of the HTTP_QUERY_* values indicating the attribute
        to query.

    lpBuffer - Pointer to the buffer to receive the information.

    dwBufferLength - On entry, contains the length (in BYTEs) of the data
        buffer. On exit, contains the size (in BYTEs) of the data written
        to lpBuffer.

Return Value:

    TRUE - The query succeeded. lpBuffer contains the query information,
        and lpBufferLength contains the size (in BYTEs) of the information.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryHeaders",
                     "%#x, %s (%#x), %wq, %#x, %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpszName? lpszName : L"<null>",
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult=FALSE;
    INET_ASSERT(hRequest);
    MEMORYPACKET mpBuffer, mpName;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && ProbeWriteBuffer(lpBuffer, *lpdwBufferLength))
        || (lpdwIndex && IsBadWritePtr(lpdwIndex, sizeof(*lpdwIndex))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
    {
        if (!lpszName 
            || IsBadStringPtrW(lpszName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszName,0,mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszName,mpName);
    }

    if (lpBuffer)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = HttpQueryInfoA(hRequest,dwInfoLevel, mpName.psStr,
        mpBuffer.psStr, &mpBuffer.dwSize, lpdwIndex);

    if (!((dwInfoLevel & HTTP_QUERY_FLAG_NUMBER) ||
        (dwInfoLevel & HTTP_QUERY_FLAG_SYSTEMTIME)))
    {
        // This is the default, we've been handed back a string.
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            *lpdwBufferLength *= sizeof(WCHAR);
            if (*lpdwBufferLength<=mpBuffer.dwAlloc)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, mpBuffer.dwAlloc/sizeof(WCHAR));
                *lpdwBufferLength -= sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
    }
    else
    {
        if (fResult)
        {
            memcpy(lpBuffer, (LPVOID)mpBuffer.psStr, mpBuffer.dwSize);
        }
        *lpdwBufferLength = mpBuffer.dwSize;
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

//
// object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryInfo(
    IN DWORD dwInfoLevel,
    IN LPCSTR headerName,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Header query method for HTTP_REQUEST_HANDLE_OBJECT class

Arguments:

    dwInfoLevel         - level of info (header) to get

    headerName          - name of header with HTTP_QUERY_CUSTOM

    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

    lpdwIndex           - IN: 0-based index of named header to return
                          OUT: index of next header if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

                  ERROR_HTTP_INVALID_QUERY_REQUEST
                    The caller asked for e.g. the Accept: header to be returned
                    as a SYSTEMTIME structure, or for e.g. a request header that
                    only exists for response headers (status code, for example)

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/

{
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT(lpdwIndex != NULL);

    DWORD error;
    DWORD headerNameLength;
    DWORD modifiers;

    modifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    dwInfoLevel &= HTTP_QUERY_HEADER_MASK;

    if (dwInfoLevel == HTTP_QUERY_CUSTOM) {
        for (headerNameLength = 0; ; ++headerNameLength) {
            if ((headerName[headerNameLength] == '\0')
            || (headerName[headerNameLength] == ':')
            || (headerName[headerNameLength] == '\r')
            || (headerName[headerNameLength] == '\n')) {
                break;
            }
        }
    } else if (dwInfoLevel == HTTP_QUERY_REQUEST_METHOD) {

        LPSTR lpszVerb;
        DWORD dwVerbLength;

        lpszVerb = _RequestHeaders.GetVerb(&dwVerbLength);
        if ((lpszVerb != NULL) && (dwVerbLength != 0)) {

            //
            // the verb is (usually) space terminated
            //

            while ((dwVerbLength > 0) && (lpszVerb[dwVerbLength - 1] == ' ')) {
                --dwVerbLength;
            }

            //
            // *lpdwBufferLength will be 0 if lpBuffer is NULL
            //

            if (*lpdwBufferLength > dwVerbLength) {
                memcpy(lpBuffer, lpszVerb, dwVerbLength);
                ((LPBYTE)lpBuffer)[dwVerbLength] = '\0';
                error = ERROR_SUCCESS;
            } else {
                ++dwVerbLength;
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            *lpdwBufferLength = dwVerbLength;
        } else {
            error = ERROR_HTTP_HEADER_NOT_FOUND;
        }
        goto quit;
    } else {
        headerName = GlobalKnownHeaders[dwInfoLevel].Text;
        headerNameLength = GlobalKnownHeaders[dwInfoLevel].Length;
    }

    if (modifiers & HTTP_QUERY_FLAG_REQUEST_HEADERS) {

        //
        // we can always query request headers, even if the server is down
        // level
        //

        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
        case HTTP_QUERY_STATUS_CODE:
        case HTTP_QUERY_STATUS_TEXT:

            //
            // can't query these sub-header values from the request headers
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _RequestHeaders.QueryRawHeaders(
                        NULL,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = QueryRequestHeadersWithEcho(
                        dwInfoLevel == HTTP_QUERY_ECHO_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_CUSTOM:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryRequestHeader(headerName,
                                           headerNameLength,
                                           lpBuffer,
                                           lpdwBufferLength,
                                           modifiers,
                                           lpdwIndex
                                           );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        default:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryRequestHeader( dwInfoLevel,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        }
    } else if (!IsDownLevel()) {
        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            error = QueryResponseVersion(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_STATUS_CODE:
            error = QueryStatusCode(lpBuffer, lpdwBufferLength, modifiers);
            break;

        case HTTP_QUERY_STATUS_TEXT:
            error = QueryStatusText(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _ResponseHeaders.QueryRawHeaders(
                        (LPSTR)_ResponseBuffer,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_CUSTOM:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryResponseHeader(
                                            headerName,
                                            headerNameLength,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        default:

            if (_ResponseHeaders.LockHeaders())
            {
                error = QueryResponseHeader(
                                            dwInfoLevel,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _ResponseHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;
        }
    } else {

        //
        // there are no response headers from down-level servers
        //

        error = ERROR_HTTP_HEADER_NOT_FOUND;
    }

quit:

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeadersWithEcho(
    IN BOOL bCrlfTerminated,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Header query for request headers with echo headers added if any..

Arguments:

    bCrlfTerminated     - should the headers be seperated by CRLF's
    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/
{
    INET_ASSERT(lpdwBufferLength != NULL);

    DWORD error;
    LPSTR lpszEchoHeaderIn = NULL ;
    LPSTR lpszEchoHeaderOut = NULL;
    DWORD cbHeaderIn = 0;
    DWORD cbHeaderOut = 0;
    BOOL bEchoPresent = FALSE;

    // List of headers to filter out of the Request headers

    LPSTR rglpFilter [ ] =
    {
        GlobalKnownHeaders[HTTP_QUERY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
        GlobalKnownHeaders[HTTP_QUERY_COOKIE].Text,
        GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text,
        GlobalKnownHeaders[HTTP_QUERY_HOST].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_NONE_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_UNMODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_UNLESS_MODIFIED_SINCE].Text,
    };

    if (!_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = FastQueryResponseHeader(HTTP_QUERY_ECHO_REQUEST,
                                    (LPVOID *)&lpszEchoHeaderIn,
                                    &cbHeaderIn,
                                    0);

    if (error == ERROR_SUCCESS)
    {
        DWORD cbEchoRequest = GlobalKnownHeaders[HTTP_QUERY_ECHO_REQUEST].Length;
        DWORD cbEchoReply   = GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Length;

        bEchoPresent = TRUE;

        // Add echo-reply: to the begining of the header.
        cbHeaderOut = cbEchoReply  + 1                      // For echo-reply:
                        + cbHeaderIn                        // Send back the stuff from the header.
                        + (bCrlfTerminated ? 2 : 1)         // 2 for CRLF
                        + 1;                                // 1 for NULL terminator

        lpszEchoHeaderOut = (LPSTR) _alloca(cbHeaderOut); // Add 1 for null terminator.

        if ( lpszEchoHeaderOut == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        LPSTR lpsz = lpszEchoHeaderOut;

        memcpy(lpszEchoHeaderOut, GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text, cbEchoReply);
        lpsz += cbEchoReply;

        lpsz[0] = ':';
        lpsz++;


        memcpy(lpsz, lpszEchoHeaderIn, cbHeaderIn );
        lpsz += cbHeaderIn;


        if ( bCrlfTerminated)
        {
            lpsz[0] = '\r';
            lpsz[1] = '\n';
            lpsz += 2;
        }
        else
        {
            lpsz[0] = '\0';
            lpsz++;
        }

        *lpsz = '\0';
    }

    DWORD dwBufferLength;
    dwBufferLength = *lpdwBufferLength;


    error = _RequestHeaders.QueryFilteredRawHeaders(
                NULL,
                rglpFilter,
                sizeof(rglpFilter)/sizeof(rglpFilter[0]),
                TRUE,
                TRUE,
                bCrlfTerminated,
                lpBuffer,
                lpdwBufferLength
                );

    if ( !bEchoPresent )
    {
        // Nothing more to do in this case.
    }
    else if ( error == ERROR_SUCCESS )
    {
        DWORD dwBufferReqd = *lpdwBufferLength + cbHeaderOut;
        // Check if we have space to add extra headers.
        if (dwBufferReqd <= dwBufferLength)
        {
            memcpy((LPSTR)lpBuffer + *lpdwBufferLength, lpszEchoHeaderOut, cbHeaderOut);
            *lpdwBufferLength += cbHeaderOut - 1; // -1 to exclude terminating '\0'
        }
        else
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            // There is a NULL termination count included both in cbHeaderOut and *lpdwBufferLength
            // hence the -1.
            *lpdwBufferLength += cbHeaderOut - 1 ;
        }
    }
    else if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        *lpdwBufferLength += cbHeaderOut - 1 ;
    }
    else
    {
        // For other errors just return the original error from QueryRawHeaders.
    }

done:
    _ResponseHeaders.UnlockHeaders();

quit:
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\socket.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    socket.cxx

Abstract:

    This file contains general socket utilities.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection
        CFsm_OpenConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloseConnection
        HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection
        HTTP_REQUEST_HANDLE_OBJECT::AbortConnection
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel
        CFsm_OpenProxyTunnel::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    18-Dec-1995 rfirth
        Reworked for C++

    27-Mar-1996 arthurbi
        Added OpenProxyTunnel Method

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection(
    IN BOOL bNewConnection,
    IN BOOL fNoCreate  /* = FALSE */
    )

/*++

Routine Description:

    Get a connection to the web server. Either use a pre-existing keep-alive
    connection from the global pool or create a new connection

Arguments:

    bNewConnection  - TRUE if we are NOT to get a connection from the keep-alive
                      pool

    fNoCreate       - TRUE if we should NOT create a new socket if a k-a isn't found.
                      This is currently for the SSL tunneling case where we want to break
                      and send a CONNECT if a k-a doesn't match our criteria.
                      
Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Opened connection

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection",
                "%B",
                bNewConnection
                ));

    DWORD error = DoFsm(New CFsm_OpenConnection(bNewConnection, this, fNoCreate));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenConnection state

Arguments:

    Fsm - containing open connection state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenConnection * stateMachine = (CFsm_OpenConnection *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm(
    IN CFsm_OpenConnection * Fsm
    )

/*++

Routine Description:

    Open connection FSM

Arguments:

    Fsm - containing state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenConnection & fsm = *Fsm;
    DWORD error = fsm.GetError();
    CServerInfo * pServerInfo = GetServerInfo();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // BUGBUG - redundancy. Either put these in the FSM or figure out why we need
    //          to do proxy name processing here
    //

    //
    // if this object was created from an InternetOpen() handle which specified
    // INTERNET_OPEN_TYPE_PROXY then we connect to the proxy, otherwise we
    // connect to the server specified in InternetConnect()
    //

    LPSTR hostName;
    LPSTR hostNameServer;
    DWORD hostLength;
    INTERNET_PORT hostPort;

    hostName = hostNameServer = GetHostName(&hostLength);
    hostPort = GetHostPort();

    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        SetViaProxy(TRUE);
        hostName = proxyHostName;
        hostLength = proxyHostNameLength;
        hostPort = proxyHostPort;
    }

    INET_ASSERT(hostName != NULL);
    INET_ASSERT(hostPort != INTERNET_INVALID_PORT_NUMBER);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto get_continue;            
        case FSM_STATE_2:
            goto connect_continue;       
        default:

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
            goto quit;
        }
    }

    //
    // we may already have a keep-alive connection - don't ask for a new one.
    // This happens in the challenge phase of a multi-part (e.g. NTLM) auth
    // negotiation over keep-alive
    //

    if (IsWantKeepAlive() && !fsm.m_bNewConnection && (_Socket != NULL)
    && _Socket->IsOpen()) {

        //INET_ASSERT(_bKeepAliveConnection);

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x, ALREADY open on Socket=%#x\n", this, _Socket );
        //}


        error = ERROR_SUCCESS;
        goto quit;
    }

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this request wants a keep-alive connection AND we are allowed to use
    // one (i.e. not forced to generate a new connection) AND we can find one
    // then we're done, otherwise we have to generate a new connection
    //

    DWORD dwSocketFlags;

    dwSocketFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;
    if ((IsWantKeepAlive() || (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION))
    && !fsm.m_bNewConnection) {
        dwSocketFlags |= SF_KEEP_ALIVE;
    }
    if (GetOpenFlags() & WINHTTP_FLAG_SECURE) {
        dwSocketFlags |= SF_SECURE;
    }
    if ( IsTunnel() )
    {
        dwSocketFlags |= SF_TUNNEL;
        //    dprintf("Opening Tunnel for nested req=%#x, Socket Flags=%#x, K-A=%B, Secure=%B, N-B=%B\n",
        //             this, dwSocketFlags, (dwSocketFlags & SF_KEEP_ALIVE), (dwSocketFlags & SF_SECURE),
        //            (dwSocketFlags & SF_NON_BLOCKING));
    }


    INET_ASSERT(_Socket == NULL);

    _Socket = NULL;
    fsm.SetFunctionState(FSM_STATE_1);
    // If m_fNoCreate flag is set, then we're attempting to find
    // a matching SSL tunnel that's already been established.
    error = DoFsm(new CFsm_GetConnection(
                            dwSocketFlags,
                            fsm.m_fNoCreate ? GetHostPort() : hostPort,
                            GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT),
                            10000,  // dwLimitTimeout
                            &_Socket,
                            pServerInfo,
                            fsm.m_fNoCreate ? hostNameServer : NULL
                            ));

get_continue:

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (_Socket != NULL) {

        //
        // _bKeepAliveConnection now means "this is a pre-existing k-a socket".
        // Only meaningful when re-establishing connect when dropped by server
        //

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x\n opened on K-A Socket=%#x\n", this, _Socket );
        //}


//dprintf("%s existing K-A connection %#x\n", GetURL(), _Socket->GetSocket());
        _bKeepAliveConnection = TRUE;

        //
        // Get any security Info
        //

        if (_Socket->IsSecure()) {
            if (m_pSecurityInfo != NULL) {
                /* SCLE ref */
                m_pSecurityInfo->Release();
            }
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            ((ICSecureSocket*)_Socket)->SetSecureFlags(SECURITY_FLAG_SECURE);
        }

        //
        // successfully got keep-alive connection from the pool
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("%skeep-alive connection: socket %#x, port %d\n",
                    _Socket->IsSecure() ? "SSL " : "",
                    _Socket->GetSocket(),
                    _Socket->GetSourcePort()
                    ));

        goto quit;
    }
    else if (fsm.m_fNoCreate)
    {
        goto quit;
    }

    //
    // the socket didn't come from the pool
    //

    _bKeepAliveConnection = FALSE;

    //
    // we may already have a socket if we're reusing the object
    //

    if (GetOpenFlags() & WINHTTP_FLAG_SECURE)
    {
        _Socket = New ICSecureSocket();

        // Search on the appropriate cache, session vs. global
        INTERNET_HANDLE_OBJECT * pInternet;
        pInternet = GetRootHandle (this);

        if (m_pSecurityInfo == NULL)
        {
            /* SCLE ref */
            m_pSecurityInfo = (pInternet->GetSslSessionCache())->Find(GetHostName());
            if (NULL == m_pSecurityInfo)
            {
                /* SCLE ref */
                m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
            }
        }

        if (_Socket != NULL)
        {
            _Socket->SetEncryption();
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetSecurityEntry(m_pSecurityInfo);
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
            ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
            if (GetEnableFlags() & WINHTTP_ENABLE_SSL_REVOCATION)
                ((ICSecureSocket *)_Socket)->SetSecureFlags(SECURITY_FLAG_CHECK_REVOCATION);
        }
    }
    else
    {
        if (dwSocketFlags & SF_TUNNEL)
        {
            _Socket = New ICSecureSocket;
            ((ICSecureSocket *)_Socket)->ResetFlags(FALSE);
        }
        else
        {
            _Socket = New ICSocket;
        }
    }
    if (_Socket != NULL)
    {
        fsm.m_bCreatedSocket = TRUE;
    }
    else
    {

        //
        // balance number of available connections
        //

        ReleaseConnection(FALSE, FALSE, FALSE);
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Turn on Socks, if needed.
    //

    GetSocksProxyName(&proxyHostName,
                      &proxyHostNameLength,
                      &proxyHostPort
                      );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        _Socket->EnableSocks(proxyHostName, proxyHostPort);
    }

    //
    // NOTE: if secure connection is required, TargetServer must
    //       be a fully qualified domain name.
    //       The hostname is used in comparison with CN found in
    //       the certificate.  The hostname MUST NOT BE the
    //       result of a DNS lookup. DNS lookups are open to
    //       spoofing, and that may prevent a security from
    //       being detected.
    //
    //
    // If we're Posting or sending data, make sure
    //  the SSL connection code knows about it.  Therefore we set
    //  the flag "SF_SENDING_DATA" for the purposes of
    //  generating errors if found while making the connection.
    //

    _Socket->SetPort(hostPort);
    fsm.SetFunctionState(FSM_STATE_2);
    error = _Socket->Connect(GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT),
                             GetTimeoutValue(WINHTTP_OPTION_CONNECT_RETRIES),
                             SF_INDICATE
                             | (IsAsyncHandle() ? SF_NON_BLOCKING : 0)
                             | (((GetMethodType() == HTTP_METHOD_TYPE_POST)
                             || (GetMethodType() == HTTP_METHOD_TYPE_PUT))
                                ? SF_SENDING_DATA
                                : 0)
                             );

connect_continue:

    if (error == ERROR_SUCCESS) {
//dprintf("%s NEW connection %#x\n", GetURL(), _Socket->GetSocket());

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("new connection: socket %#x\n",
                    _Socket->GetSocket()
                    ));

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x opened for Socket=%#x\n", this, _Socket );
        //}


        /*
            24918: Invalid ASSERT because the m_Socket member in _Socket can be invalidated
            due to closing handle : code downstream of this assert takes that into consideration.
            for eg. SetLinger puts the call in a try..except.
         */
         
        //INET_ASSERT(_Socket->IsOpen());

        //pServerInfo->AddActiveConnection();
        
        // enable send and receive timeout - ignore any errors

        _Socket->SetTimeout(SEND_TIMEOUT,
                            GetTimeoutValue(WINHTTP_OPTION_SEND_TIMEOUT)
                            );
                            
        _Socket->SetTimeout(RECEIVE_TIMEOUT,
                            GetTimeoutValue(WINHTTP_OPTION_RECEIVE_TIMEOUT)
                            );
                            
        //
        // set zero linger: force connection closed at transport level when
        // we close the socket. Ignore the error
        //

        _Socket->SetLinger(TRUE, 0);
    }

quit:

    if (error != ERROR_IO_PENDING) {

        //
        // if we created the socket but failed to connect then delete the socket
        // object
        //

        if ((error != ERROR_SUCCESS) && fsm.m_bCreatedSocket) {

            //
            // we created a socket so we must increase the available connection
            // count on failure
            //

            INET_ASSERT(_Socket != NULL);

            ReleaseConnection(TRUE,     // close socket (if open)
                              FALSE,    // don't indicate
                              TRUE      // dispose of socket object
                              );
        }
//dprintf("%s get/connect pending socket %#x\n", GetURL(), _Socket ? _Socket->GetSocket() : 0);
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloseConnection(
    IN BOOL bForceClosed
    )

/*++

Routine Description:

    Performs the opposite of OpenConnection(), i.e. closes the socket or marks
    it not in use if keep-alive

Arguments:

    bForceClosed    - TRUE if we are to forcibly release a keep-alive connection
                      (i.e. the server timed out before we did)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::CloseConnection",
                "%B",
                bForceClosed
                ));

//dprintf("*** closing %s%s socket %#x\n",
//        (_bKeepAliveConnection || IsKeepAlive()) ? "K-A " : "",
//        GetURL(),
//        _Socket ? _Socket->GetSocket() : 0
//        );

    DWORD error = ERROR_SUCCESS;
    BOOL bClose = TRUE;
    BOOL bDelete = TRUE;

    if (_Socket == NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("socket already deleted\n"
                    ));

        goto quit;
    }
    if (_bKeepAliveConnection || IsKeepAlive()) {

        //
        // keep-alive connection: just return the connection to the pool
        //

        if ((IsContentLength() && (GetBytesInSocket() != 0))
        || (IsChunkEncoding() && !IsDecodingFinished())
        || IsNoLongerKeepAlive() || _Socket->IsClosed()
        || ((_State & 0x0F) < (HttpRequestStateObjectData & 0x0F))) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("forcing %#x [%#x] closed: bytes left = %d/%d; no longer k-a = %B; closed = %B\n",
                        _Socket,
                        _Socket->GetSocket(),
                        GetBytesInSocket(),
                        GetContentLength(),
                        IsNoLongerKeepAlive(),
                        _Socket->IsClosed()
                        ));

//dprintf("forcing k-a %#x closed - bytes=%d/%d, no longer=%B, chunked=%B, chunk-finished=%B\n",
//        _Socket->GetSocket(),
//        GetBytesInSocket(),
//        GetContentLength(),
//        IsNoLongerKeepAlive(),
//        IsChunkEncoding(),
//        IsDecodingFinished()
//        );
            bForceClosed = TRUE;
        }
        if (!bForceClosed) {
            bClose = FALSE;
            bDelete = FALSE;
        } else {
//dprintf("%#x forced close\n", _Socket->GetSocket());
        }
    }

    ReleaseConnection(bClose, TRUE, bDelete);
    _Socket = NULL;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;

quit:

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection(
    IN BOOL bClose,
    IN BOOL bIndicate,
    IN BOOL bDispose
    )

/*++

Routine Description:

    Releases the connection back to the server limited pool and optionally
    closes the socket handle and destroys the socket object

Arguments:

    bClose      - if TRUE, increments the available connection count in the
                  server info object and closes the handle, else we are
                  returning a keep-alive connection; after this call we no
                  longer have a socket object owned by this request handle
                  object

    bIndicate   - TRUE if we indicate to the user when we close the socket
                  handle

    bDispose    - TRUE if we are disposing of the socket object (mutually
                  exclusive with !bClose), in which case we will no longer have
                  a socket object after this call returns

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection",
                 "%B, %B, %B",
                 bClose,
                 bIndicate,
                 bDispose
                 ));

    INET_ASSERT(_Socket != NULL);
    //INET_ASSERT(_Socket->IsOpen());

    CServerInfo * pServerInfo = GetServerInfo();

    // Always disconnect sockets which have been marked as authenticated.
    // This is to avoid posting data to IIS4 while preauthenticating
    // and inducing the server to close the connection.
    if (_Socket)
        bClose = (bClose || _Socket->IsAuthenticated());
        
    ICSocket * pSocket = bClose ? NULL : _Socket;

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo != NULL) {
        if (bClose && (_Socket != NULL)) {

            //
            // BUGBUG - this should be set based on bGraceful parameter
            //

            _Socket->SetLinger(FALSE, 0);

            //INET_ASSERT(!_bKeepAliveConnection || _bNoLongerKeepAlive);
            _Socket->Shutdown(SD_BOTH);
            _Socket->Disconnect(bIndicate ? SF_INDICATE : 0);
            if (bDispose) {
                _Socket->Dereference();
                _Socket = NULL;
            }
        } else {
            _Socket = NULL;
        }
        //if (IsResponseHttp1_1() && IsKeepAlive()) {
        //    pServerInfo->ReleasePipelinedConnection(pSocket);
        //} else {
            pServerInfo->ReleaseConnection(pSocket);
        //}
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AbortConnection(
    IN BOOL bForce
    )

/*++

Routine Description:

    Aborts the current connection. Closes the socket and frees up all receive
    buffers. If the connection is keep-alive, we have the option to forcefully
    terminate the connection, or just return the socket to the keep-alive pool

Arguments:

    bForce  - if TRUE and keep-alive, forcefully close the keep-alive socket

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::AbortConnection",
                "%B",
                bForce
                ));

    DWORD error;

    error = CloseConnection(bForce);
    if (error == ERROR_SUCCESS) {

        //
        // destroy all response variables. This is similar to ReuseObject()
        // except we don't change the object state, or reset the end-of-file
        // state
        //

        _ResponseHeaders.FreeHeaders();
        FreeResponseBuffer();
        ResetResponseVariables();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel(
    VOID
    )

/*++

Routine Description:

    Creates a connection with the requested server via a Proxy
    tunnelling method.

    Works by creating a nested child HTTP and Connect request object.
    These objects send a "CONNECT" verb to the proxy server asking for
    a connection to made with the destination server. Upon completion the
    child objects are discarded.  If a class 200 response is not received from
    proxy server, the proxy response is copied into this object
    and returned to the user.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel",
                 NULL
                 ));

    DWORD error = DoFsm(New CFsm_OpenProxyTunnel(this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenProxyTunnel::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenProxyTunnel state

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenProxyTunnel::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenProxyTunnel * stateMachine = (CFsm_OpenProxyTunnel *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenProxyTunnel_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm(
    IN CFsm_OpenProxyTunnel * Fsm
    )

/*++

Routine Description:

    State machine for OpenProxyTunnel

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenProxyTunnel & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    // Need to bury error on blocked async item that failed to find
    // established SSL tunnel
    if (error != ERROR_SUCCESS && fsm.GetFunctionState() != FSM_STATE_2) {
        goto quit;
    }
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    //  Need to use handle magic for async requests
    //  so we'll have the reference before jumping.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto send_continue;

        case FSM_STATE_2:
            goto keep_alive_tunnel;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);
            goto quit;
        }
    }

    // Do not continue if handle is in NTLM challenge state - we
    // already have a valid socket set up for tunnelling.
    if ((_Socket != NULL) && (GetAuthState() == AUTHSTATE_CHALLENGE))
    {
        error = ERROR_SUCCESS;
        goto quit;
    }


    // First, try and fetch an already established tunnel
    // from the keep-alive pool.  If so, we can avoid the nested
    // CONNECT request.
    //
    if (_Socket == NULL)
    {
        error = OpenConnection(FALSE, TRUE);

        if (error == ERROR_IO_PENDING)
        {
            fsm.SetFunctionState(FSM_STATE_2);
            goto quit;
        }
keep_alive_tunnel:
        if (error == ERROR_SUCCESS && _Socket != NULL)
        {
            // No need to create nested request.  We found an active SSL tunnel
            // for this server in the keep-alive pool.
            goto quit;
        }
        else
        {
            // Start over as normal tunnel since bypass to find
            // keep-alive failed.
            error = ERROR_SUCCESS;
        }
    }

    //
    //  With the Internet Handle Object,
    //  construct a new Connect Object, and new HttpRequest Object.
    //

    //
    // increment the nested request level around InternetConnect(). This is
    // required to stop InternetConnect() believing this is the async part of
    // a two-part (FTP) request (original async hackery)
    //

    _InternetIncNestingCount();
    fsm.m_hConnect = InternetConnect(pInternet->GetPseudoHandle(),
                                     GetHostName(),
                                     GetHostPort(),
                                     0, // no flags
                                     NULL
                                     );
    _InternetDecNestingCount(1);
    if (!fsm.m_hConnect) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_IO_PENDING);

        goto quit;
    }

    //
    // Now do an Open Request. This will pick up the secure proxy flag.
    //

    fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                     "CONNECT",
                                     "/",    // we don't need this for a CONNECT
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL
                                     );
    if (!fsm.m_hRequest) {
        error = GetLastError();
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(fsm.m_hRequest,
                               (LPVOID *)&fsm.m_hRequestMapped,
                               FALSE);
    if ((error != ERROR_SUCCESS) || (fsm.m_hRequestMapped == NULL)) {
        goto quit;
    }

    fsm.m_pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.m_hRequestMapped;

    //
    // we need to set the special secure proxy flag in the request object
    //

    fsm.m_pRequest->SetTunnel();


    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );
    fsm.m_pRequest->SetProxyName(proxyHostName,
                                 proxyHostNameLength,
                                 proxyHostPort
                                 );

    //
    // Transfer any proxy user/pass from the handle.
    //
    LPSTR lpszUser, lpszPass;

    // Get username + password off of outer handle.
    if (GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
    {
        // This will automatically re-validate the username/password
        // on the tunneling handle.
        fsm.m_pRequest->SetProp (WINHTTP_OPTION_PROXY_USERNAME
            & WINHTTP_OPTION_MASK, lpszUser);
        fsm.m_pRequest->SetProp (WINHTTP_OPTION_PROXY_PASSWORD
            & WINHTTP_OPTION_MASK, lpszPass);
    }

    if (_pProxyCreds)
    {
        fsm.m_pRequest->_pProxyCreds = new WINHTTP_REQUEST_CREDENTIALS(_pProxyCreds->_AuthScheme,
                                                                       _pProxyCreds->_pszRealm,
                                                                       _pProxyCreds->_pszUserName,
                                                                       _pProxyCreds->_pszPassword);
        if (fsm.m_pRequest->_pProxyCreds == NULL)
        {
            // If we couldn't clone it, transfer it. This is not efficient, but it will work.
            fsm.m_pRequest->_pProxyCreds = _pProxyCreds;
            _pProxyCreds = NULL; // ownership transferred
        }
    }

    //
    // Transfer any authentication context to the tunnelling handle.
    //

    //fsm.m_pRequest->SetAuthCtx (_pTunnelAuthCtx);


    //dprintf("New tunnel request %#x making nested request= %#x\n", this, fsm.m_pRequest);

    //
    // Do the Nested SendRequest to the Proxy Server.
    //  ie send the CONNECT method.
    //

    fsm.SetFunctionState(FSM_STATE_1);
    if (!HttpSendRequest(fsm.m_hRequest, NULL, 0, NULL, 0)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            goto done;
        }
        goto quit;
    }

send_continue:

    //
    // Check Status Code Returned from proxy Server Here.
    // If its not 200 we let the user view it as a Proxy Error
    //  and DON'T continue our connection to the SSL/PCT Server.
    //

    //dprintf("Received Nested Response, Socket=%#x, org request=%#x, nested request=%#x\n", fsm.m_pRequest->_Socket, this, fsm.m_pRequest);

    _StatusCode = fsm.m_pRequest->GetStatusCode();

    switch (_StatusCode) {

        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_PROXY_AUTH_REQ:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            break;

        default:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            goto quit;
    }


    //
    // Transfer any authentication context back to the outer handle.
    //

    if ( _pTunnelAuthCtx ) {
        delete _pTunnelAuthCtx;
    }

    _pTunnelAuthCtx = fsm.m_pRequest->GetAuthCtx();
    // Don't leave the potential for a deleted request reference
    // to be left in the trasferred context.
    if (_pTunnelAuthCtx)
    {
        _pTunnelAuthCtx->_pRequest = NULL;
    }

    fsm.m_pRequest->SetAuthCtx (NULL);

    _PreferredScheme = fsm.m_pRequest->_PreferredScheme;
    _SupportedSchemes = fsm.m_pRequest->_SupportedSchemes;
    _AuthTarget = fsm.m_pRequest->_AuthTarget;

    //
    // pull the socket handle from the socket object used to communicate with
    // the proxy
    //

    INET_ASSERT(fsm.m_pRequest->_Socket != NULL);

    /*
    if server returned anything other than 200 then we failed; revert to non-
    secure socket
    */

    if (_Socket == NULL)
    {
        // transfer socket reference from nested request
        _Socket = fsm.m_pRequest->_Socket;
        fsm.m_pRequest->_Socket = NULL;

        // Socket should now be marked as secure
        ((ICSecureSocket *)_Socket)->ResetFlags(TRUE);
    }
    if(m_pSecurityInfo == NULL)
    {
        /* SCLE ref */
        m_pSecurityInfo = pInternet->GetSslSessionCache()->Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            /* SCLE ref */
            m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    if (_Socket != NULL)
    {

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetSecurityEntry(m_pSecurityInfo);
        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
        ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
        if (GetEnableFlags() & WINHTTP_ENABLE_SSL_REVOCATION)
            ((ICSecureSocket *)_Socket)->SetSecureFlags(SECURITY_FLAG_CHECK_REVOCATION);

        // Update values for the established tunnel
        _Socket->SetPort(fsm.m_pRequest->GetHostPort());
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

quit:

    if (fsm.m_hRequestMapped != NULL) {
        DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    }

    if (fsm.m_hRequest != NULL) {

        BOOL bOk;
        bOk = WinHttpCloseHandle(fsm.m_hRequest);
        INET_ASSERT(bOk);
    }

    if (fsm.m_hConnect != NULL) {

        BOOL bOk;
        bOk = WinHttpCloseHandle(fsm.m_hConnect);
        INET_ASSERT(bOk);
    }

    //
    // We Reset the ThreadInfo back to the the previous
    //  object handle, and context values.
    //

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, GetPseudoHandle(), (HINTERNET)this);
        _InternetClearLastError(lpThreadInfo);
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN HTTP_REQUEST_HANDLE_OBJECT *pChildRequestObj
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 pChildRequestObj
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(pChildRequestObj->_BytesReceived);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pChildRequestObj->_ResponseBuffer,
           pChildRequestObj->_BytesReceived
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                pChildRequestObj->_BytesReceived
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\sendreq.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest
        HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders
        CFsm_HttpSendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish
        HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo
        HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest(
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID *lplpOptional,
    IN LPDWORD lpdwOptionalLength,
    IN DWORD dwOptionalLengthTotal
    )

/*++

Routine Description:

    Performs Initiatization of the HTTP Request by setting up the necessary
     headers and preparing the POST data.

Arguments:

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total Length for File Upload.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - One of the Win32 Error values.

  Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest",
                 "%#x, %d, %d, %#x",
                 lplpOptional ? *lplpOptional : NULL,
                 lpdwOptionalLength ? *lpdwOptionalLength : NULL,
                 dwOptionalLengthTotal
                 ));

    DWORD error = ERROR_SUCCESS;
    LPVOID lpOptional       = *lplpOptional;
    DWORD dwOptionalLength  = *lpdwOptionalLength;

    //
    // validate parameters
    //

    if ((lpOptional == NULL) || (dwOptionalLength == 0)) {
        lpOptional = NULL;
        dwOptionalLength = 0;
    }

    //
    // the headers lengths can be -1 meaning that we should calculate the
    // string lengths. We must do this before calling MakeAsyncRequest()
    // which is expecting the parameters to be correct
    //

    if (dwHeadersLength == -1) 
    {
        dwHeadersLength = lstrlen((LPCSTR)lpszHeaders);
    } 

    //
    // if the caller specified some additional headers, then add them before
    // we make the request asynchronously
    //

    if (ARGUMENT_PRESENT(lpszHeaders) && (*lpszHeaders != '\0')) {

        //
        // we use the API here because the headers came from the app, and
        // we don't trust it
        //

        if (!HttpAddRequestHeaders(GetPseudoHandle(),
                                   lpszHeaders,
                                   dwHeadersLength,

                                   //
                                   // if the object is being re-used then
                                   // replace the headers to avoid
                                   // duplicating original headers
                                   //

                                   IS_VALID_HTTP_STATE(this, REUSE, TRUE)
                                    ? ( HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD ): 0
                                    //? HTTP_ADDREQ_FLAG_REPLACE : 0
                                   )) {
            error = GetLastError();
            goto quit;
        }
    }

    //
    // If we fall through then we are connected and a) either the thing
    // is not in the cache or we did a conditional get or c) there was
    // some cache error
    //

    error = ERROR_SUCCESS;

    //
    // if the app supplied a user-agent string to InternetOpen() AND hasn't
    // added a "User-Agent:" header, then add it
    //

    LPSTR userAgent;
    DWORD userAgentLength;

    userAgent = GetUserAgent(&userAgentLength);
    if (userAgent != NULL) {
        ReplaceRequestHeader(HTTP_QUERY_USER_AGENT,
                             userAgent,
                             userAgentLength,
                             0, // dwIndex,
                             ADD_HEADER_IF_NEW
                             );
    }

    //
    // do the same thing with the "Host:" header. The header-value is the host
    // name supplied to InternetConnect() (or the name of the redirected host)
    //

    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;

    hostName = GetHostName(&hostNameLength);
    hostPort = GetHostPort();

    INET_ASSERT((hostName != NULL) && (hostNameLength > 0));

    char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];

    if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
    && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) {
        if (lstrlen(hostName) > INTERNET_MAX_HOST_NAME_LENGTH)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        hostNameLength = wsprintf(hostValue, "%s:%d", hostName, (hostPort & 0xffff));
        hostName = hostValue;
    }
    ReplaceRequestHeader(HTTP_QUERY_HOST,
                         hostName,
                         hostNameLength,
                         0, // dwIndex,
                         ADD_HEADER_IF_NEW
                         );

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    //if (pRequest->GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION) {
    //    pRequest->SetWantKeepAlive(TRUE);
    //}

    //
    // add the content-length header IF we are sending data OR this is a POST,
    // AND ONLY if the app has not already added the header
    //

    if (dwOptionalLength || dwOptionalLengthTotal)
        SetMethodBody();
        
    if (((dwOptionalLength != 0) || (dwOptionalLengthTotal != 0))

    //
    // BUGBUG - just comparing against a method type is insufficient. We need
    //          a test of whether the method implies sending data (PUT, etc).
    //          We make the same test in other places
    //

    || (GetMethodType() != HTTP_METHOD_TYPE_GET)) {

        DWORD dwContentLength;

        char number[sizeof("4294967295")];

        //
        // For File Upload we need to add the Content-Length
        //   header off of the Total Length, Not the current
        //   data size.  Since we get more data via InternetWriteFile
        //

        if ( dwOptionalLengthTotal != 0 )
        {
            dwContentLength = dwOptionalLengthTotal;
        }
        else
        {
            dwContentLength = dwOptionalLength;
        }

        // _itoa(dwOptionalLength, number, 10);
        wsprintf(number, "%d", dwContentLength);

        DWORD numberLength = lstrlen(number);

        /*----------------------------------------------------------------------

        #62953 NOTE --  Authstate can never be in the AUTHSTATE_NEGOTIATE
        state here. It is not necessary to zero out the content length
        header here when omitting post data on NTLM negotiate since this
        will be done later in the request. The commented-out code is not
        necessary.

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
            && (GetAuthState() == AUTHSTATE_NEGOTIATE))
        {

            ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                "0",
                                1,
                                0,   // dwIndex
                                ADD_HEADER
                                );
        }

        ---------------------------------------------------------------------*/

        // Normally we don't over-write the content-length
        // header if one already exists.
        DWORD dwAddHeader;
        dwAddHeader = ADD_HEADER_IF_NEW;

        // But if we're posting data and have an auth ctx
        // over-write the content-length header which will
        // have been reset to 0 to omit post data on the
        // negotiate phase.
        AUTHCTX *pAuthCtx;
        pAuthCtx = GetAuthCtx();
        if (pAuthCtx)
        {
            dwAddHeader = ADD_HEADER;
        }


        ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                            (LPSTR)number,
                            numberLength,
                            0,   // dwIndex
                             dwAddHeader
                            );

    }

quit:

    *lplpOptional       = lpOptional;
    *lpdwOptionalLength = dwOptionalLength;

    DEBUG_LEAVE(error);

    return error;
}



DWORD
CFsm_HttpSendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpSendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_HttpSendRequest * stateMachine = (CFsm_HttpSendRequest *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Start(stateMachine);
        break;

    case FSM_STATE_FINISH:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Finish(stateMachine);
        break;

    case FSM_STATE_ERROR:

        //CHECK_FSM_OWNED(Fsm);

        error = Fsm->GetError();

        //
        // If we block to call GetProxyInfo async, then
        //  we may get unblocked during a cancel.  We need to
        //   handle it by freeing the object in our destructor.
        //

        INET_ASSERT( (!stateMachine->m_fOwnsProxyInfoQueryObj) ?
                        ( error == ERROR_WINHTTP_OPERATION_CANCELLED ||
                          error == ERROR_WINHTTP_TIMEOUT )  :
                        TRUE );

        Fsm->SetDone();
        break;

    default:

        //CHECK_FSM_OWNED(Fsm);

        stateMachine->m_fOwnsProxyInfoQueryObj = TRUE;
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    Calls SendData() method in a loop, handling redirects (& authentications?)
    until we have successfully started to retrieve what was originally requested

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Operation completed successfully

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_WINHTTP_INCORRECT_HANDLE_STATE
                    The HTTP request handle is in the wrong state for this
                    request

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Start);

    //CHECK_FSM_OWNED(Fsm);

    CFsm_HttpSendRequest & fsm = *Fsm;

    //
    // we must loop here while the server redirects us or while we authenticate
    // the user
    //

    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    //
    // We set m_fOwnsProxyInfoObj TRUE, because by virtue of being here
    //   we have know that we now own the pointer in our fsm, pointed to by
    //   fsm.m_pProxyInfoQuery.
    //
    // This boolean is used to know when we are allowed to FREE and ACCESS
    //   this pointer.  If FALSE, we CANNOT touch this pointer because
    //   the auto-proxy thread may be accessing it.   The auto-proxy thread
    //   will unblock us, this releasing its "un-offical" lock on this pointer.
    //

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if (state == FSM_STATE_INIT)
    {        
        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
        {
            state = FSM_STATE_4;
            fsm.SetFunctionState(FSM_STATE_4);
        }
    }
    else
    {
        state = fsm.GetFunctionState();
    }

retry_send_request:

    do {
        switch (state) {
        case FSM_STATE_INIT:
        case FSM_STATE_1:

            //CHECK_FSM_OWNED(Fsm);

            fsm.m_iRetries = 2;
            fsm.m_bAuthNotFinished = FALSE;
            fsm.m_dwCookieIndex = 0;

            //
            // Terrible bug that afflicts NS servers while doing SSL,
            //  they lie (those buggers), and claim they do keep-alive,
            //  but when we attempt to reuse their Keep-Alive sockets,
            //  they all fail, so we therefore must increase the retry count
            //  so we can empty all the bad keep-alive sockets out of the pool
            //
              
            if ( (GetOpenFlags() & WINHTTP_FLAG_SECURE) )
            {
                CServerInfo * pServerInfo = GetServerInfo();
    
                if ( pServerInfo && pServerInfo->IsBadNSServer() )
                {
                    fsm.m_iRetries = 5;
                }
            }

            //
            // if we're not in the right state to send, drain the socket
            //

            if (!IsValidHttpState(SEND)) {

#define DRAIN_SOCKET_BUFFER_LENGTH  (1 K)

                if (fsm.m_pBuffer == NULL) {
                    fsm.m_pBuffer = (LPVOID)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        DRAIN_SOCKET_BUFFER_LENGTH);
                    if (fsm.m_pBuffer == NULL) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }
                }
                do {
                    if (!fsm.m_bSink) {
                        fsm.m_bSink = TRUE;
                        fsm.SetFunctionState(FSM_STATE_2);
                        error = ReadData(fsm.m_pBuffer,
                                         DRAIN_SOCKET_BUFFER_LENGTH,
                                         &fsm.m_dwBytesDrained,
                                         TRUE,
                                         0);
                        if (error == ERROR_IO_PENDING) {
                            goto quit;
                        }
                    }

                    //
                    // fall through to state 2
                    //

        case FSM_STATE_2:

                    fsm.m_bSink = FALSE;
                } while ((error == ERROR_SUCCESS) && (fsm.m_dwBytesDrained != 0));
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
                if (fsm.m_pBuffer != NULL) {
                    fsm.m_pBuffer = (LPVOID)FREE_MEMORY(fsm.m_pBuffer);

                    INET_ASSERT(fsm.m_pBuffer == NULL);

                }

                ReuseObject();

                INET_ASSERT(!IsData());
                INET_ASSERT(IS_VALID_HTTP_STATE(this, SEND, TRUE));

                //
                // BUGBUG - if we're not in the right state?
                //

            }

            //
            // generate the correct request headers based
            //  on what types, or whether we're using
            //  proxies
            //


            fsm.SetFunctionState(FSM_STATE_3);
            error = UpdateProxyInfo(Fsm, FALSE);

            if (error == ERROR_IO_PENDING) {
                goto done;
            }

            //
            // set function state to not-FSM_STATE_3 to differentiate interrupted
            // path in FSM_STATE_3
            //

            fsm.SetFunctionState(FSM_STATE_BAD);

            //
            // fall through
            //

        case FSM_STATE_3:

            if ((error == ERROR_SUCCESS)
            && (fsm.GetFunctionState() == FSM_STATE_3)) {
                error = UpdateProxyInfo(Fsm, TRUE);
            }

            if (error != ERROR_SUCCESS) {
                fsm.m_bCancelRedoOfProxy = TRUE;
                goto quit;
            }

            //
            // get any cookies required for this site, but only if app didn't
            // tell us it will handle cookies
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES) )
            {
                if (CreateCookieHeaderIfNeeded())
                {
                   // SetPerUserItem(TRUE);
                }
            }

            //
            // if this URL requires authentication then add its header here, but
            // only if the app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_AUTH)) 
            {
                SetPPAbort(FALSE); // let's assume Passport is not going to abort the send.
                
                error = AuthOnRequest(this);
                if (error != ERROR_SUCCESS) 
                {
                    goto quit;
                }

                if (PPAbort())
                {
                    // Passport needed to abort the send cuz the DA wanted to redirect
                    // the App to an different site *AND* the app wanted to handle the 
                    // redirect itself.
                    error = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto quit;
                }
            }
try_again:
            fsm.SetFunctionState(FSM_STATE_4);
            DEBUG_PRINT(HTTP, INFO, ("State_3_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));
            error = DoFsm(New CFsm_SendRequest(fsm.m_lpOptional,
                                               fsm.m_dwOptionalLength,
                                               this
                                               ));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_4:
            DEBUG_PRINT(HTTP, INFO, ("State_4_start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            //
            // This adds CR-LF for the File Upload case
            //

            //if (_RequestMethod == HTTP_METHOD_TYPE_POST && _AddCRLFToPOST && fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST)
            //{
            //    error = _Socket->Send(gszCRLF, 2, 0);
            //    if (error != ERROR_SUCCESS) {
            //        goto quit;
            //    }
            //}
            fsm.m_bWasKeepAlive = (_bKeepAliveConnection || IsKeepAlive());
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {

                //
                // must be doing proxy tunnelling request if status code set
                //

                INET_ASSERT(((GetStatusCode() != HTTP_STATUS_OK)
                            && (GetStatusCode() != 0))
                            ? IsTalkingToSecureServerViaProxy()
                            : TRUE
                            );

                //
                // server may have reset keep-alive connection
                //

                if ((error == ERROR_WINHTTP_CONNECTION_ERROR)
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after send. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after send\n");
                    CloseConnection(TRUE);
                    goto try_again;
                }
                goto quit;
            }
            if (fsm.m_arRequest == AR_HTTP_BEGIN_SEND_REQUEST) {
                goto quit;
            }
            fsm.SetFunctionState(FSM_STATE_5);
            error = DoFsm(New CFsm_ReceiveResponse(this));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_5:

            DEBUG_PRINT(HTTP, INFO, ("State_5_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (error != ERROR_SUCCESS) {
//dprintf("*** post-receive: error=%d, retries=%d\n", error, fsm.m_iRetries);

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_WINHTTP_CONNECTION_ERROR)
                || (error == ERROR_HTTP_INVALID_SERVER_RESPONSE))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after receive. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after receive\n");
                    CloseConnection(TRUE);
                    _ResponseHeaders.FreeHeaders();
                    ResetResponseVariables();
                    _ResponseHeaders.Initialize();
                    goto try_again;
                }

                goto quit;
            }

            fsm.SetFunctionState(FSM_STATE_6);


        case FSM_STATE_6:
            DEBUG_PRINT(HTTP, INFO, ("State_6_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //
            // put any received cookie headers in the cookie jar, but only if the
            // app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
            && IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE) )
            {
                DWORD dwError;
                dwError = ExtractSetCookieHeaders(&fsm.m_dwCookieIndex);

                if ( dwError == ERROR_IO_PENDING )
                {
                    error = ERROR_IO_PENDING;
                    goto quit;
                }
            }

            //
            // we need to handle various intermediary return codes:
            //
            //  30x - redirection
            //  40x - authentication
            //
            // BUT ONLY if the app didn't tell us it wanted to handle these itself
            //

            DWORD statusCode;
            BOOL bNoAuth;

            statusCode = GetStatusCode();
            bNoAuth = (GetOpenFlags() & INTERNET_FLAG_NO_AUTH) ? TRUE : FALSE;

            //
            // if the status is 200 (most frequently return header == success)
            // and we are not authenticating all responses then we're done
            //

            if ((statusCode == HTTP_STATUS_OK) && bNoAuth) {
                goto quit;
            }

            //
            // handle authentication before checking the cache
            //

            if (!bNoAuth) {

                //
                // call packages for basic, ntlm
                //

                error = AuthOnResponse(this);
                // passport1.4 auth could change the status code from 302 to 401 here
                statusCode = GetStatusCode();

                if (error == ERROR_WINHTTP_FORCE_RETRY) {

                    // Force a retry error only if Writes are required, otherwise we have all the data for a redirect:
                    if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST && IsWriteRequired())
                    {
                        goto quit;
                    }

                    //
                    // the object has been updated with new info - try again
                    //

                    fsm.m_bFinished = FALSE;
                    fsm.m_bAuthNotFinished = TRUE;
                    error = ERROR_SUCCESS;

                    //
                    // Reset auto-proxy info so we can retry the connection
                    //

                    if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                    {
                        delete fsm.m_pProxyInfoQuery;
                        fsm.m_pProxyInfoQuery = NULL;
                    }


                } else if (error == ERROR_WINHTTP_INCORRECT_PASSWORD) {

                    //
                    // just return success to the app which will have to check the
                    // headers and make the request again, with the right password
                    //

                    error = ERROR_SUCCESS;
                    goto quit;
                } 
            }

            //
            // if we can read from the cache then let us try
            //

            if ((statusCode == HTTP_STATUS_OK)
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)
                || (statusCode == HTTP_STATUS_PRECOND_FAILED)
                || (statusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (statusCode == 0)) {

            }

            BOOL fMustRedirect;
            
            fMustRedirect = FALSE;

            if (_pAuthCtx)
            {
                if (_pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)_pAuthCtx;
                    if (pPPCtx->m_lpszRetUrl)
                    {
                        fMustRedirect = TRUE;
                    }
                }
            }

            //
            // handle redirection
            //

            fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_UNKNOWN;

            fsm.m_bRedirected = FALSE;

            if (((statusCode == HTTP_STATUS_AMBIGUOUS)              // 300
                 || (statusCode == HTTP_STATUS_MOVED)               // 301
                 || (statusCode == HTTP_STATUS_REDIRECT)            // 302
                 || (statusCode == HTTP_STATUS_REDIRECT_METHOD)     // 303
                 || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB)) // 307
                && (fMustRedirect || !(GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT))) {

                //
                // Clean out expired PROXY_STATE
                //

                error = ERROR_SUCCESS;
                if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                {
                    delete fsm.m_pProxyInfoQuery;
                    fsm.m_pProxyInfoQuery = NULL;
                }
                //fsm.m_pProxyState = NULL;
                SetProxyName(NULL, 0, 0);

                //
                // if we've already had the max allowable redirects then quit
                //

                if (fsm.m_dwRedirectCount == 0) {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                    fsm.m_bRedirectCountedOut = TRUE;
                    goto quit;
                }

                //
                // we got 300 (ambiguous), 301 (permanent move), 302 (temporary
                // move), or 303 (redirection using new method)
                //

                switch (statusCode) {
                case HTTP_STATUS_AMBIGUOUS:

                    //
                    // 300 - multiple choice
                    //

                    //
                    // If there is a Location header, we do an "automatic" redirect
                    //

                    if (_ResponseHeaders.LockHeaders())
                    {
                        if (! IsResponseHeaderPresent(HTTP_QUERY_LOCATION)) {
                            _ResponseHeaders.UnlockHeaders();
                            fsm.m_bFinished = TRUE;
                            break;
                        }
                        _ResponseHeaders.UnlockHeaders();
                    }
                    else
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    //
                    // fall through
                    //

                case HTTP_STATUS_MOVED:

                    // Table View:
                    //Method            301             302             303             307
                    //  *               *               *           GET         *
                    //POST                  GET         GET             GET             POST
                    //
                    //Put another way:
                    //301 & 302  - All methods are redirected to the same method but POST. POST is
                    //  redirected to a GET.
                    //303 - All methods are redirected to GET
                    //307 - All methods are redirected to the same method.

                    //
                    // 301 - permanently moved
                    //

                    //
                    // fall through
                    //

                case HTTP_STATUS_REDIRECT:

                    //
                    // 302 - temporarily moved (POST => GET, everything stays the same)
                    //
                    fsm.m_tMethodRedirect = GetMethodType();
                    if (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST)
                    //
                    // A POST change method to a GET
                    //
                    {
                        fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                        // force no optional data on second and subsequent sends
                        fsm.m_dwOptionalLength = 0;
                        _fOptionalSaved = FALSE;
                    }

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;

                    break;
                case HTTP_STATUS_REDIRECT_METHOD:

                    //
                    // 303 - see other (POST => GET)
                    //

                    fsm.m_tMethodRedirect = (GetMethodType() == HTTP_METHOD_TYPE_HEAD) ?
                                                    HTTP_METHOD_TYPE_HEAD :
                                                    HTTP_METHOD_TYPE_GET;

                    //
                    // force no optional data on second and subsequent sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    _fOptionalSaved = FALSE;

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                case HTTP_STATUS_REDIRECT_KEEP_VERB:

                    //
                    // 307 - see other (POST => POST)
                    //

                    //if (IsHttp1_1()) {
                    fsm.m_tMethodRedirect = GetMethodType();

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                default:
                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // BUGBUG - force no optional data on second and subsequent
                    //          sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;
                }

                //
                // Only allow redirect to continue if we are successful.
                //

                if (fsm.m_bRedirected
                && ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_UNKNOWN)
                    || (fsm.m_tMethodRedirect == GetMethodType()))) {
                    fsm.SetFunctionState(FSM_STATE_7);
                    error = Redirect(fsm.m_tMethodRedirect, FALSE);
                    if (error != ERROR_SUCCESS) {
                        goto quit;
                    }
                }
            } else {

                //
                // not a status that we handle. We're done
                //   BUT WAIT, we're only finshed if also
                //   finished retrying HTTP authentication.
                //
                // if the app told us not to handle authentication auth_not_finished
                // will be FALSE
                //

                if (!fsm.m_bAuthNotFinished) {
                    fsm.m_bFinished = TRUE;
                }
            }

            //
            // fall through
            //

        case FSM_STATE_7:
            DEBUG_PRINT(HTTP, INFO, ("State_7_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (fsm.m_bRedirected) {
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // cleanup response headers from redirection
                //

                ReuseObject();

                //
                // Allow Redirects to exit out and force the HttpEndRequestA
                //  caller to notice.
                //

                if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD &&
                    // Force a retry error only if Writes are required, otherwise we have all the data for a redirect:
                     IsWriteRequired()
                     )
                {
                    error = ERROR_WINHTTP_FORCE_RETRY;
                }
            }
        }
        state = FSM_STATE_INIT;
    } while (!fsm.m_bFinished && (error == ERROR_SUCCESS));

quit:
        DEBUG_PRINT(HTTP, INFO, ("Quit1: error = 0x%x\r\n", error));

    if (error == ERROR_IO_PENDING) {
        goto done;
    }

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        DWORD eAuthScheme = 0;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if (!fsm.m_bCancelRedoOfProxy && 
            //(GetStatusCode() != HTTP_STATUS_DENIED) &&
            ((eAuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT) || (GetStatusCode() != HTTP_STATUS_DENIED)) && // this is safer
            fsm.m_pInternet->RedoSendRequest(&error, fsm.m_pRequest->GetSecureFlags(), fsm.m_pProxyInfoQuery, GetOriginServer(), GetServerInfo())) 
        {
            fsm.m_bFinished = FALSE;
            fsm.m_bRedirectCountedOut = FALSE;
            fsm.m_dwRedirectCount = GlobalMaxHttpRedirects;
            fsm.SetState(FSM_STATE_INIT);
            state = FSM_STATE_INIT;
            DEBUG_PRINT(HTTP, INFO, ("Quit2: error = 0x%x\r\n", error));
            goto retry_send_request;
        } 
        else 
        {
            //SetProxyName(NULL, 0, 0);
            DEBUG_PRINT(HTTP, INFO, ("Quit3: error = 0x%x\r\n", error));
        }
    }

    //
    // if ERROR_HTTP_REDIRECT_FAILED then we tried to redirect, but found that
    // we couldn't do it (e.g. http:// to ftp:// or file://, etc.) We need to
    // defer this to the caller to clean up & make the new request. They will
    // have all the header info (plus we probably already indicated the new
    // URL during the redirect callback).  Rather than returning ERROR_SUCCESS,
    // we will now fail with this error.
    //
    // Cases where we are redirected to the same site will return ERROR_SUCCESS.
    //

    if ((error == ERROR_HTTP_NOT_REDIRECTED)
    && !fsm.m_bRedirectCountedOut) {
        error = ERROR_SUCCESS;
    }

    fsm.SetNextState(FSM_STATE_FINISH);

done:

    PERF_LEAVE(HttpSendRequest_Start);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Finish);

    CFsm_HttpSendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    INET_ASSERT(fsm.m_hRequestMapped != NULL);

    //if (!IsAsyncHandle() && (fsm.m_hRequestMapped != NULL)) {
    //    DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    //}

    //
    // we will return FALSE even if this is an async operation and the error is
    // ERROR_IO_PENDING
    //

    fsm.SetDone(error);
    //fsm.SetApiResult(error == ERROR_SUCCESS);

    PERF_LEAVE(HttpSendRequest_Finish);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::BuildProxyMessage(
    IN CFsm_HttpSendRequest * Fsm,
    AUTO_PROXY_ASYNC_MSG * pProxyMsg,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Calls CrackUrl to parses request URL, and 
      transfers the information to the AUTO_PROXY_ASYNC_MSG

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR currentUrl;
    DWORD currentUrlLength;

    //
    // Gather the URL off the handle
    //

    currentUrl = GetURL();

    if (currentUrl) {
        currentUrlLength = lstrlen(currentUrl);

        //
        // BUGBUG [arthurbi] the following can be a slow call,
        //   but its too risky to change the complete behavior where
        //   we cache it
        //

        //
        // crack the current URL
        //

        memset(pUrlComponents, 0, sizeof(URL_COMPONENTS));
        pUrlComponents->dwStructSize = sizeof(URL_COMPONENTS);

        error = CrackUrl(currentUrl,
                         currentUrlLength,
                         FALSE, // don't escape URL-path
                         &(pUrlComponents->nScheme),
                         NULL,  // don't care about Scheme Name
                         NULL,
                         &(pUrlComponents->lpszHostName),
                         &(pUrlComponents->dwHostNameLength),
                         &(pUrlComponents->nPort),
                         NULL,  // don't care about user name
                         NULL,
                         NULL,  // or password
                         NULL,
                         &(pUrlComponents->lpszUrlPath),
                         &(pUrlComponents->dwUrlPathLength),
                         NULL,  // no extra
                         NULL,
                         NULL
                         );

        pProxyMsg->SetProxyMsg(
            pUrlComponents->nScheme,
            currentUrl,
            currentUrlLength,
            pUrlComponents->lpszHostName,
            pUrlComponents->dwHostNameLength,
            pUrlComponents->nPort
            );
    } else {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INVALID_URL;
    }
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    INTERNET_HANDLE_OBJECT * pInternet,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Wrapper over GetProxyInfo call to determine proxy
        settings on our given object

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    INET_ASSERT(fsm.m_pProxyInfoQuery);
    INET_ASSERT(pInternet);

    SetProxyName(NULL, 0, 0);

    fsm.m_fOwnsProxyInfoQueryObj = FALSE;

    if (IsProxy() || (GetProxyInfo() == PROXY_INFO_DIRECT))
    {
        error = GetProxyInfo(&fsm.m_pProxyInfoQuery);
    }
    else
    {
        error = pInternet->GetProxyInfo(&fsm.m_pProxyInfoQuery);
    }

    //
    //  If GetProxyInfo returns pending, then we no longer have
    //   access to the pointer that we've passed.
    //

    if ( error == ERROR_IO_PENDING )
    {
        //
        // Bail out, DO NOT TOUCH any OBJECTS or FSMs 
        //

        goto quit;
    }

    // then regardless we own it unless GetProxyInfo went pending with the FSM
    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    INET_ASSERT( error == ERROR_SUCCESS );

    if ( ! ((fsm.m_pProxyInfoQuery)->IsUseProxy()) )
    {
        SetIsTalkingToSecureServerViaProxy(FALSE);        
    }

quit:

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckForCachedProxySettings(
    IN AUTO_PROXY_ASYNC_MSG *pProxyMsg,
    OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Attempts to determine and then resolve if there are cached
     proxy settings saved away in the CServerInfo object,
     which is found in our HTTP_REQUEST_ object.  This can
     be very useful since calling off to an auto-proxy thread
     can be quite expensive in terms of performance.

Arguments:

    pProxyMsg - the object containing our current proxy message
      information, that we use to scripple our proxy state for
      a given request

    ppProxyServerInfo - on return, may contain the resultant
      cached ServerInfo object.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    CServerInfo * pOriginServer = GetOriginServer();
    CServerInfo * pProxyServer;

    INET_ASSERT(pProxyMsg);

    *ppProxyServerInfo = NULL;

    if (pOriginServer)
    {
        BOOL fCachedEntry;

        pProxyServer = 
            pOriginServer->GetCachedProxyServerInfo(            
                pProxyMsg->_tUrlProtocol,
                pProxyMsg->_nUrlPort,
                &fCachedEntry
                );

        if (fCachedEntry)
        {
            if ( pProxyServer )
            {
                if (pProxyServer->CopyCachedProxyInfoToProxyMsg(pProxyMsg))
                {
                    SetOriginServer();
                    *ppProxyServerInfo = pProxyServer;
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            
                // nuke extra ref, sideeffect of GetCachedProxy... call            
                ::ReleaseServerInfo(pProxyServer);
            }  
            else
            {
                // DIRECT, no-proxy cached.
                pProxyMsg->SetUseProxy(FALSE);
                pProxyMsg->_lpszProxyHostName = NULL;
                error = ERROR_SUCCESS;
                goto quit;
            }
        }
    }

    pProxyMsg->SetVersion();

quit:
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    IN OUT URL_COMPONENTS * pUrlComponents,
    OUT LPSTR * lplpszRequestObject,
    OUT DWORD * lpdwRequestObjectSize
    )
/*++

Routine Description:

    Armed with the results of the proxy query, this method takes care of 
    assembling the various variables and states to deal with various 
    types of proxies.

    More specifally, this handles HTTP Cern Proxies, SOCKS proxies, 
    SSL-CONNECT/HTTP proxies, and special cases such as FTP URLs
    with passwords through an HTTP Cern Proxy.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    LPSTR lpszUrlObject = NULL;
    LPSTR lpszObject = pUrlComponents->lpszUrlPath;
    DWORD dwcbObject = pUrlComponents->dwUrlPathLength;

    if ((fsm.m_pProxyInfoQuery)->GetProxyScheme() == INTERNET_SCHEME_SOCKS)
    {
        SetSocksProxyName((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                          (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                          (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                          );

        (fsm.m_pProxyInfoQuery)->_lpszProxyHostName = NULL;
        (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength = 0;
    }
    else if (pUrlComponents->nScheme == INTERNET_SCHEME_HTTPS)
    {
        SetIsTalkingToSecureServerViaProxy(TRUE);
    }
    else
    {
        SetIsTalkingToSecureServerViaProxy(FALSE); // default value.

        //
        // if this request is going via proxy then we send the entire URL as the
        // request
        //

        DWORD urlLength;

        //
        // in secure proxy tunnelling case we are going to send the request
        // "CONNECT <host>:<port>"
        //

        if (IsTunnel()) {
            urlLength = pUrlComponents->dwHostNameLength + sizeof(":65535");
        } else {
            urlLength = INTERNET_MAX_URL_LENGTH;
        }

        lpszUrlObject = (LPSTR)ResizeBuffer(NULL, urlLength, FALSE);
        if (lpszUrlObject == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (IsTunnel())
        {
            // When tunneling, the scheme is http for the CONNECT and the port
            // info may be stripped to 0 if the default http port was specified
            // in the original SSL tunneling URL.
            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                INET_ASSERT (pUrlComponents->nScheme == INTERNET_SCHEME_HTTP);
                pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            memcpy (lpszUrlObject, pUrlComponents->lpszHostName, pUrlComponents->dwHostNameLength);
            wsprintf (lpszUrlObject + pUrlComponents->dwHostNameLength, ":%d", pUrlComponents->nPort);
        }
        else
        {
            //
            // there may be a user name & password (only if FTP)
            //

            LPSTR userName;
            DWORD userNameLength;
            LPSTR password;
            DWORD passwordLength;

            userName = NULL;
            userNameLength = 0;
            password = NULL;
            passwordLength = 0;

            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                switch (pUrlComponents->nScheme)
                {
                    case INTERNET_SCHEME_HTTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
                        break;

                    case INTERNET_SCHEME_HTTPS:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTPS_PORT;
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        break;
                }
            }

            pUrlComponents->lpszUserName = userName;
            pUrlComponents->dwUserNameLength = userNameLength;
            pUrlComponents->lpszPassword = password;
            pUrlComponents->dwPasswordLength = passwordLength;

            for (int i=0; i<2; i++)
            {
                if (!WinHttpCreateUrlA(pUrlComponents, 0, lpszUrlObject, &urlLength))
                {
                    error = GetLastError();

                    if ((error == ERROR_INSUFFICIENT_BUFFER)
                        && (i==0))
                    {
                        LPSTR pTemp = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                        urlLength,
                                                        FALSE);

                        if (pTemp)
                        {
                            lpszUrlObject = pTemp;
                            continue;
                        }
                        else
                        {
                            error = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    goto quit;
                }
                else
                {
                    error = ERROR_SUCCESS;
                    break;
                }
            }
            //
            // shrink the buffer to fit
            //

            lpszUrlObject = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                (urlLength + 1) * sizeof(TCHAR),
                                                FALSE
                                                );

            INET_ASSERT(lpszUrlObject != NULL);

            if (lpszUrlObject == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
        }

        SetRequestUsingProxy(TRUE);

        lpszObject = lpszUrlObject;
        dwcbObject = lstrlen(lpszUrlObject);
    }

quit:

    *lplpszRequestObject   = lpszObject;
    *lpdwRequestObjectSize = dwcbObject;

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN LPSTR lpszObject,
    IN DWORD dwcbObject,
    IN OUT URL_COMPONENTS * pUrlComponents,
    IN OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Based on object and URL information, for a given HTTP request, 
    this function assembles the "special cases" and modifes the 
    request headers in prepartion of making the actual request.

    The "special cases" includes the handling of HTTP versioning, 
    HTTP 1.0/1.1 keep-alives, and Pragma headers.

    This function also deals with the update the ServerInfo object
    that contains the host resolution information.


Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszVersion = NULL;
    DWORD dwVersionLen = 0;

    CFsm_HttpSendRequest & fsm = *Fsm;

    if ( lpszObject == NULL) 
    {
        lpszObject = pUrlComponents->lpszUrlPath;
        dwcbObject = pUrlComponents->dwUrlPathLength;
    }
        
    INET_ASSERT(dwcbObject > 0 );

    if (!_RequestHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we are going via proxy and HTTP 1.1 through proxy is disabled
    // then modify the request version to HTTP/1.0
    //

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() &&        
        ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) &&
        !GlobalEnableProxyHttp1_1 || GetMethodType() == HTTP_METHOD_TYPE_CONNECT) {
        lpszVersion = "HTTP/1.0";
        dwVersionLen = sizeof("HTTP/1.0") - 1;
    }

    ModifyRequest(GetMethodType(),
                  lpszObject,
                  dwcbObject,
                  lpszVersion,
                  dwVersionLen
                  );

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() )        
    {
        SetProxyName( (fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                      (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                      );

        if ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) {

            if (_ServerInfo != NULL)
            {
                _ServerInfo->SetProxyByPassed(FALSE);
            }

            //
            // changing server info from origin server to proxy server. Keep
            // pointer to origin server so that we can update connect and
            // round-trip times
            //

            SetOriginServer();

            if (*ppProxyServerInfo) {
                // cached server info
                SetServerInfo(*ppProxyServerInfo);
                *ppProxyServerInfo = NULL;
            }
            else
            {            
                error = SetServerInfo((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength
                                      );
                if (error != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        if (_ServerInfo != NULL)
        {
            _ServerInfo->SetProxyByPassed(TRUE);

            if ( pUrlComponents->lpszHostName )
            {
                error = SetServerInfo(pUrlComponents->lpszHostName,
                                      pUrlComponents->dwHostNameLength
                                      );

                if (error != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }

        }
    }

    //
    // determine whether we use persistent connections and ensure the correct
    // type and number of keep-alive headers are present
    //

    //
    // BUGBUG - we need to check for "Connection: keep-alive". There may be
    //          other types of "Connection" header, and the keep-alive header
    //          may contain additional information
    //

    DWORD bufferLength;
    DWORD index;
    DWORD dwHeaderNameIndex;

    if (IsRequestUsingProxy()) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_PROXY_CONNECTION;
    } else {
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_CONNECTION;
    }

    if (IsRequestHeaderPresent(dwHeaderNameIndex)) {
        SetWantKeepAlive(TRUE);
        SetOpenFlags(
            GetOpenFlags() | INTERNET_FLAG_KEEP_CONNECTION);
    }

    error = ERROR_SUCCESS;

    //
    // if the global keep-alive switch
    // is off then we don't want any keep-alive headers
    //

    if (GlobalDisableKeepAlive)
    {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);

        if (IsRequestHttp1_1())
        {
            //
            // Add "Connection: Close" header because we're not doing
            //  keep-alive on this Request, needed for HTTP 1.1
            //

            (void)ReplaceRequestHeader(HTTP_QUERY_CONNECTION,
                                       CLOSE_SZ,
                                       CLOSE_LEN,
                                       0,
                                       REPLACE_HEADER
                                       );
        }

        SetOpenFlags(
            GetOpenFlags() & ~INTERNET_FLAG_KEEP_CONNECTION);
    }

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    if (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION)
    {
        SetWantKeepAlive(TRUE);
        (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                   KEEP_ALIVE_SZ,
                                   KEEP_ALIVE_LEN,
                                   0,
                                   ADD_HEADER_IF_NEW
                                   );
    }

    //
    // if app added "connection: close" then we don't want keep-alive
    //

    if (IsRequestHttp1_1()) {

        BOOL bClose = FindConnCloseRequestHeader(dwHeaderNameIndex);
        BOOL bWantKeepAlive;
        DWORD dwOpenFlags = GetOpenFlags();

        if (bClose || (IsTunnel() && GetAuthState() != AUTHSTATE_CHALLENGE)) {
            RemoveAllRequestHeadersByName(dwHeaderNameIndex);

            //
            // For a Tunnel to a proxy we want to make sure that
            //  keep-alive is off since is does not make sense
            //  to do keep-alive with in a HTTP CONNECT request
            //
            // Note: we do not add the Connection: close header
            //  because of its amphorus definition in this case.
            //

            if (!IsTunnel()) {
                (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                           CLOSE_SZ,
                                           CLOSE_LEN,
                                           0,
                                           REPLACE_HEADER
                                           );
            }
            bWantKeepAlive= FALSE;
            dwOpenFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
        } else {
            bWantKeepAlive = TRUE;
            dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        SetWantKeepAlive(bWantKeepAlive);
        SetOpenFlags(dwOpenFlags);
    }

    if (GetOpenFlags() & WINHTTP_FLAG_BYPASS_PROXY_CACHE)
    {
        // add "Pragma: No-Cache" header
        
        ReplaceRequestHeader(HTTP_QUERY_CACHE_CONTROL,
                           NO_CACHE_SZ,
                           NO_CACHE_LEN,
                           0,   // dwIndex
                           ADD_HEADER_IF_NEW
                           );

        // add "Cache-Control: No-Cache" header for HTTP 1.1

        if (IsRequestHttp1_1())
        {
            ReplaceRequestHeader(HTTP_QUERY_PRAGMA,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
        }                           
    }


Cleanup:

    _RequestHeaders.UnlockHeaders();

quit:

    return error;

}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN BOOL fCallback
    )

/*++

Routine Description:

    Queries Proxy Information, and based on the proxy info it assembles the appropriate
     HTTP request.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo",
                 "%#x, %B",
                 Fsm,
                 fCallback
                 ));

    PERF_ENTER(UpdateProxyInfo);

    DWORD error = ERROR_SUCCESS;

    CFsm_HttpSendRequest & fsm = *Fsm;

    CServerInfo *pProxyServer = NULL;

    INTERNET_HANDLE_OBJECT * pInternet;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    URL_COMPONENTS urlComponents;

    LPSTR lpszObject = NULL;
    DWORD dwcbObject = 0;


    // once we're woken up, we own the obj stored in our FSM.
    INET_ASSERT(fsm.m_fOwnsProxyInfoQueryObj); 

    //
    // Get the Obj Pointers we care about
    //

    pInternet = GetRootHandle (this);

    //
    // Clear our handle state in regards to proxy settings
    //

    SetSocksProxyName(NULL, NULL, NULL);
    SetRequestUsingProxy(FALSE);

    //
    // Parse URL, I have to do this every time,
    //  and even worse we need to do this before our caching code
    //  gets hit, but we can't move it because the quit code
    //  depends on the parsed URL.  In the future we should cache this!!
    //

    error = BuildProxyMessage(
                Fsm,
                &proxyInfoQuery,
                &urlComponents
                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // No proxy installed on this object, bail out
    //

    if ( ((GetProxyInfo() == PROXY_INFO_DIRECT) || (!IsProxy() && ! pInternet->IsProxy())) 
        && ! IsOverrideProxyMode() )
    {
        INET_ASSERT(fsm.m_pProxyInfoQuery == NULL);
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        goto quit;
    }

    //
    // If we're in the callback, just retrieve the results,
    //  from the orginal blocking call to proxy code
    //

    if ( fsm.m_pProxyInfoQuery )
    {            
        fCallback = TRUE;

        if ( ! (fsm.m_pProxyInfoQuery)->IsBackroundDetectionPending()) {
            (fsm.m_pProxyInfoQuery)->SetQueryOnCallback(TRUE);
        }

        error = QueryProxySettings(Fsm, pInternet, &urlComponents);
        if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy())              
        {
            goto quit;
        }
    }
    else
    {
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        
        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
        proxyInfoQuery.SetShowIndication(TRUE);        

        if (!IsTunnel() && !IsOverrideProxyMode())
        {
            error = QueryProxySettings(Fsm, pInternet, &urlComponents);
            if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy()) {
                goto quit;
            }
        }
        else // fall-back
        {
            //
            // Get the current proxy information,
            //   if we're in an nested SSL tunnell
            //

            GetProxyName(&(fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                         &(fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                         &(fsm.m_pProxyInfoQuery)->_nProxyHostPort
                         );

            (fsm.m_pProxyInfoQuery)->_tProxyScheme = INTERNET_SCHEME_DEFAULT;
            (fsm.m_pProxyInfoQuery)->SetUseProxy(TRUE);
        }
    }

    //
    // Need to figure out whether we're actually talking
    //  to a Server via proxy.  In this case we need to
    //  special case some logic in the Send so we create
    //  a sub-request to the proxy-server, and then do this
    //  request to the main SSL server.
    //

    if ( (fsm.m_pProxyInfoQuery)->IsUseProxy() ) 
    {
        error = ProcessProxySettings(
                    Fsm,
                    &urlComponents,
                    &lpszObject,
                    &dwcbObject
                    );    
    }
    else
    {
        // Ensure this is false in case of very slim chance of
        // redirect from internet https to intranet http
        SetIsTalkingToSecureServerViaProxy(FALSE);
    }

quit:

    //
    // If we didn't fail with pending,
    //  go ahead and process the request headers
    //
   
    if ( error != ERROR_IO_PENDING)
    {
        if ( error == ERROR_SUCCESS ) {
            error = UpdateRequestInfo(Fsm, lpszObject, dwcbObject, &urlComponents, &pProxyServer);
        }

        //
        // Now, Unlink the proxyinfomsg struc from the fsm,
        //   if its our stack based variable that we used as a temp
        //

        if ( fsm.m_fOwnsProxyInfoQueryObj &&
             fsm.m_pProxyInfoQuery &&
             ! (fsm.m_pProxyInfoQuery)->IsAlloced() )
        {
            fsm.m_pProxyInfoQuery = NULL;
        }

    }

    //
    // Don't leak objects, Give a hoot, don't pollute !!
    //

    if ( pProxyServer != NULL )
    {
        ::ReleaseServerInfo(pProxyServer);
    }

    if ( lpszObject != NULL &&
         lpszObject != urlComponents.lpszUrlPath)
    {
        FREE_MEMORY(lpszObject);
    }

    PERF_LEAVE(UpdateProxyInfo);

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Determine if Connection: Close added to request headers

Arguments:

    dwIndex - id of Connection header to search for (Connection or
              Proxy-Connection)

Return Value:

    BOOL
        TRUE    - header found

        FALSE   - header not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader",
                 "%d [%s]",
                 dwIndex,
                 InternetMapHttpOption(dwIndex)
                 ));

    BOOL bFound = FALSE;

    if (CheckedConnCloseRequest()) {
        bFound = IsConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION);
    } else {

        LPSTR ptr;
        DWORD len;
        DWORD index = 0;

        while (FastQueryRequestHeader(dwIndex,
                                      (LPVOID *)&ptr,
                                      &len,
                                      index) == ERROR_SUCCESS) {
            if ((len == CLOSE_LEN) && (strnicmp(ptr, CLOSE_SZ, len) == 0)) {
                bFound = TRUE;
                break;
            }
            index++;
        }
        SetCheckedConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION, bFound);
    }

    DEBUG_LEAVE(bFound);

    return bFound;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
HTTP_REQUEST_HANDLE_OBJECT::SetTimeout(
    IN DWORD dwTimeoutOption,
    IN DWORD dwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        _dwResolveTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        _dwConnectTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        _dwConnectRetries = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        _dwSendTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        _dwReceiveTimeout = dwTimeoutValue;
        break;
        
    default:
        INET_ASSERT(FALSE);
        
        bRetval = FALSE;
        break;
    }

    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetTimeout(
    IN DWORD dwTimeoutOption
    )
{
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        return _dwResolveTimeout;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        return _dwConnectTimeout;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        return _dwConnectRetries;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        return _dwSendTimeout;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        return _dwReceiveTimeout;
    }

    INET_ASSERT(FALSE);
    
    // we should not be here, but in case we are, return 0
    return 0;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
HTTP_REQUEST_HANDLE_OBJECT::SetTimeouts(
    IN DWORD        dwResolveTimeout,
    IN DWORD        dwConnectTimeout,
    IN DWORD        dwSendTimeout,
    IN DWORD        dwReceiveTimeout
    )
{
    _dwResolveTimeout = dwResolveTimeout;
    _dwConnectTimeout = dwConnectTimeout;
    _dwSendTimeout = dwSendTimeout;
    _dwReceiveTimeout = dwReceiveTimeout;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\http\write.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    write.cxx

Abstract:

    This file contains the implementation of the HttpWriteData API.

    Contents:
        HttpWriteData
        HTTP_REQUEST_HANDLE_OBJECT::WriteData

Author:

    Arthur Bierer (arthurbi) 07-Apr-1997

Revision History:



--*/

#include <wininetp.h>
#include "httpp.h"



//
// functions
//



DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

    dwSocketFlags           - controlling socket operation


Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/


{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpWriteData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(New CFsm_HttpWriteData(lpBuffer,
                                              dwNumberOfBytesToWrite,
                                              lpdwNumberOfBytesWritten,
                                              dwSocketFlags,
                                              (HTTP_REQUEST_HANDLE_OBJECT *)hRequest
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpWriteData::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpWriteData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpWriteData * stateMachine = (CFsm_HttpWriteData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:

        pRequest->SetAddCRLF(TRUE);

        //
        // Fall through
        //

    case FSM_STATE_CONTINUE:
        error = pRequest->HttpWriteData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm(
    IN CFsm_HttpWriteData * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpWriteData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {
        if (!IsValidHttpState(WRITE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
            goto quit;
        }

        error = _Socket->Send(
                           fsm.m_lpBuffer,
                           fsm.m_dwNumberOfBytesToWrite,
                           SF_INDICATE
                           );

    }

    if (error == ERROR_SUCCESS)
    {
        *fsm.m_lpdwNumberOfBytesWritten = fsm.m_dwNumberOfBytesToWrite;
    }


quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\httpcache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    httpcache.cxx

Abstract:

    Contains API implementation of the WinHTTP-UrlCache interaction layer 

Environment:

    Win32 user-level

Revision History:


--*/

/*++

- TODO: All functions assume that parameter validation has been performed already in the layer above it.  Make
sure all parameters that gets passed in (in test programs etc...) are validated and correct.

- As it currently stands, the HTTP-Cache API functions are exposed outside via DLL exports.  This is NOT what's supposed
to happen.  This layer is supposed to be an internal layer.  Eliminate the DLL exports as soon as the API hooks are
completed and extensive testing has been done to make sure that the component is really working as expected.

- FindUrlCacheEntry trys to find the address specified by "http://"+_szServername+_szLastVerb

-- */

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "cachehndl.hxx"

////////////////////////////////////////////////////////////////////////////////////////////
// Global Variables
//

CACHE_HANDLE_MANAGER * CacheHndlMgr;


////////////////////////////////////////////////////////////////////////////////////////////
//
// API implementation
//

HINTERNET
WINAPI
WinHttpCacheOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Handle,
                     "WinHttpCacheOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr;
    HINTERNET hInternet = NULL;
    
    if ((dwFlags & WINHTTP_FLAG_ASYNC) && 
       (dwFlags & WINHTTP_CACHE_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    hInternet = WinHttpOpen(
        pszAgentW, 
        dwAccessType, 
        pszProxyW, 
        pszProxyBypassW, 
        dwFlags);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;

}

HINTERNET
WINAPI
WinHttpCacheOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER_API((DBG_CACHE,
                     Handle,
                     "WinHttpCacheOpenRequest",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags
                     ));

    HINTERNET hRequest; 

    hRequest = WinHttpOpenRequest(
                    hConnect, 
                    lpszVerb, 
                    lpszObjectName, 
                    lpszVersion, 
                    lpszReferrer, 
                    lplpszAcceptTypes, 
                    dwFlags);

    if (hRequest != NULL) 
    {
        // The caching layer only works with GET requests
        if(wcscmp(L"GET", lpszVerb) == 0)
        {  
            if (CacheHndlMgr == NULL)
            {
                CacheHndlMgr = new CACHE_HANDLE_MANAGER;
                if (CacheHndlMgr == NULL)
                {
                    DEBUG_PRINT(CACHE, ERROR, ("Not enough memory to initialize CACHE_HANDLE_MANAGER"));
                    goto quit;
                }
           }

            CacheHndlMgr->AddCacheRequestObject(hRequest);
        }
    }
    
quit:
    
    DEBUG_LEAVE(hRequest);
    return hRequest;
}


BOOL
WINAPI
WinHttpCacheSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER((DBG_CACHE,
                Bool,
                "WinHttpCacheSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    BOOL fResult = FALSE;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
            CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->SendRequest(
                        lpszHeaders,
                        dwHeadersLength,
                        lpOptional,
                        dwOptionalLength
                        );
            goto quit;
        }
    } 

    fResult = WinHttpSendRequest(hRequest,
                               lpszHeaders,
                               dwHeadersLength,
                               lpOptional,
                               dwOptionalLength,
                               dwTotalLength,
                               dwContext);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
    
}

BOOL
WINAPI
WinHttpCacheReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest = 
            CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->ReceiveResponse(lpBuffersOut);
            goto quit;
        }
    }

    fResult = WinHttpReceiveResponse(hRequest,
                                   lpBuffersOut);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

BOOL
WINAPI
WinHttpCacheQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
           CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->QueryDataAvailable(lpdwNumberOfBytesAvailable);
            goto quit;
        }
    }

    fResult = WinHttpQueryDataAvailable(hRequest,
                                     lpdwNumberOfBytesAvailable);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

BOOL
WINAPI
WinHttpCacheReadData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheReadData",
                     "%#x, %#x, %d, %#x",
                     hRequest,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
           CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->ReadData(lpBuffer, 
                                              dwNumberOfBytesToRead,
                                              lpdwNumberOfBytesRead);
            goto quit;
        }
    }

    fResult = WinHttpReadData(hRequest,
                           lpBuffer,
                           dwNumberOfBytesToRead,
                           lpdwNumberOfBytesRead);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
    
}

BOOL
WINAPI
WinHttpCacheCloseHandle(
    IN HINTERNET hInternet
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "WinHTTPCacheCloseRequestHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD dwHandleType;
    DWORD dwSize = sizeof(DWORD);
    DWORD fResult = FALSE;
    
    if (hInternet == NULL)
        goto quit;
    
    WinHttpQueryOption(hInternet, WINHTTP_OPTION_HANDLE_TYPE, &dwHandleType, &dwSize);
    if (dwHandleType == WINHTTP_HANDLE_TYPE_REQUEST)
    {
        if (CacheHndlMgr != NULL)
        {
            HTTPCACHE_REQUEST * HTTPCacheRequest;
            if ((HTTPCacheRequest =
            CacheHndlMgr->GetCacheRequestObject(hInternet)) != NULL)
            {
                fResult = HTTPCacheRequest->CloseRequestHandle();
                
                CacheHndlMgr->RemoveCacheRequestObject(hInternet);

                if (CacheHndlMgr->RefCount() == 0)
                {
                    delete CacheHndlMgr;
                    CacheHndlMgr = NULL;
                }

                goto quit;
            }
        }
    }

    fResult = WinHttpCloseHandle(hInternet);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\cachehndl.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachehndl.cxx

Abstract:

    Cache handle manager for creating, deleting, reference counting,
    and mapping HINTERNET objects to HTTPCACHE_REQUEST objects

Author:

Revision History:

--*/

/*

  Class CACHE_HANDLE_MANAGER public interface:

    BOOL AddCacheRequestObject(HINTERNET hRequest);
    BOOL GetCacheRequestObject(HINTERNET hRequest, HTTPCACHE_REQUEST* CacheRequest); 
    BOOL RemoveCacheRequestObject(HINTERNET hRequest);
    
    CACHE_HANDLE_MANAGER();
    ~CACHE_HANDLE_MANAGER();
    
*/
#include <wininetp.h>
#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"
#include "cachelogic.hxx"
#include "cachehndl.hxx"

/*
We'll also let the handle manager takes care of the work of loading and unloading
the URLCACHE library
*/

CACHE_HANDLE_MANAGER::CACHE_HANDLE_MANAGER() 
{
    HeadCacheRequestList = NULL;
    dwRefCount = 0;
    HndlMgrCritSec.Init();
	DLLUrlCacheEntry(DLL_PROCESS_ATTACH);
}

CACHE_HANDLE_MANAGER::~CACHE_HANDLE_MANAGER() 
{
    HndlMgrCritSec.FreeLock();
	DLLUrlCacheEntry(DLL_PROCESS_DETACH);    
}

// Precondition:  hRequest really is a HTTP_REQUEST_HANDLE_OBJECT.
BOOL CACHE_HANDLE_MANAGER::AddCacheRequestObject(HINTERNET hRequest)
{    
    DWORD dwHandleType;
    DWORD dwSize = sizeof(DWORD);
    DWORD fResult = FALSE;
    
    HndlMgrCritSec.Lock();

    if (hRequest == NULL)
        goto quit;
    
    // If you try to give me a Connect or Session handle and try to trick me into
    // thinking that it's a Request handle, then I'll fail you!
    WinHttpQueryOption(hRequest, WINHTTP_OPTION_HANDLE_TYPE, &dwHandleType, &dwSize);
    if (dwHandleType != WINHTTP_HANDLE_TYPE_REQUEST)
        goto quit;

    // We don't add another hInternet->HTTPCACHE_REQUEST mapping if one already exists
    if (GetCacheRequestObject(hRequest) != NULL)
        goto quit;

    // Traverse to the end of the list
    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;
    if (HeadCacheRequestList != NULL)
    {
        for (;;)
        {
            if (CurCacheRequestList->next == NULL)
                break;
            CurCacheRequestList = CurCacheRequestList->next;
        }

        if ((CurCacheRequestList->next = new CACHE_REQUEST_LIST(hRequest)) != NULL)
        {
            dwRefCount++;
            fResult = TRUE;
            goto quit;
        }
    }
    else
    {
        if ((HeadCacheRequestList = new CACHE_REQUEST_LIST(hRequest)) != NULL) 
        {
            dwRefCount++;
            fResult = TRUE;
            goto quit;
        }
    }

quit:
    HndlMgrCritSec.Unlock();
    return fResult;
    
}
    
HTTPCACHE_REQUEST * CACHE_HANDLE_MANAGER::GetCacheRequestObject(HINTERNET hRequest)
{
    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;

    while (CurCacheRequestList != NULL)
    {
        if (CurCacheRequestList->CacheRequestObj->GetRequestHandle() == hRequest)
        {
            return CurCacheRequestList->CacheRequestObj;
        }
        CurCacheRequestList = CurCacheRequestList->next;
    }

    return NULL;
}

BOOL CACHE_HANDLE_MANAGER::RemoveCacheRequestObject(HINTERNET hRequest)
{
    if (HeadCacheRequestList == NULL)
        return FALSE;

    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;

    if (HeadCacheRequestList->CacheRequestObj->GetRequestHandle() == hRequest)
    {
        HndlMgrCritSec.Lock();

        HeadCacheRequestList = HeadCacheRequestList->next;
        delete CurCacheRequestList;
        CurCacheRequestList = NULL;
        
        dwRefCount--;
        
        HndlMgrCritSec.Unlock();

        return TRUE;
    }
    

    while (CurCacheRequestList->next != NULL)
    {
        if (CurCacheRequestList->next->CacheRequestObj->GetRequestHandle() == hRequest)
        {
            HndlMgrCritSec.Lock();
            
            CACHE_REQUEST_LIST * DeleteCacheRequestList = CurCacheRequestList->next;
            
            if (CurCacheRequestList->next->next == NULL)
                CurCacheRequestList->next = NULL;
            else
                CurCacheRequestList->next = CurCacheRequestList->next->next;

            delete DeleteCacheRequestList;
            DeleteCacheRequestList = NULL;
            
            dwRefCount--;
            
            HndlMgrCritSec.Unlock();

            return TRUE;
        }
        CurCacheRequestList = CurCacheRequestList->next;
    }
        
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\cachelogic.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachelogic.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object public interface and a few 
    miscellaneous global variables and classes

Author:

Revision History:

--*/

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"
#include "..\urlcache\hndlmgr.hxx"

#include "cachelogic.hxx"
#include "internalapi.hxx"

/////////////////////////////////////////////////////////////////////////
//
// Global variables specific to HttpCache 
//
//
/////////////////////////////////////////////////////////////////////////

#define CACHE_ENTRY_INFOEX_SIZE 1024 * 5    // we need this much to prevent buffer overrun

/////////////////////////////////////////////////////////////////////////
//
// HTTPCACHE_REQUEST Constructors and destructors
//
//
/////////////////////////////////////////////////////////////////////////

HTTPCACHE_REQUEST::HTTPCACHE_REQUEST(HINTERNET hRequest)
{
    _hRequest = hRequest;

    InternalQueryOptionA(_hRequest, WINHTTP_OPTION_CACHE_FLAGS, &_dwCacheFlags);
    InternalQueryOptionA(_hRequest, WINHTTP_OPTION_REQUEST_FLAGS, &_dwRequestFlags);
    
	_lpszFileName = NULL;
	_lpszFileExtension = NULL;
	_lpszCacheWriteLocalFilename = NULL;

    _fIsPartialCache = FALSE;
    _fCacheWriteInProgress = FALSE;
    _fDeleteWriteFile = FALSE;
    _fCacheReadInProgress = FALSE;
    _fLazyUpdate = FALSE;

    _fHasExpiry = FALSE;
    _fHasLastModTime = FALSE;
    _fHasPostCheck = FALSE;
    _fMustRevalidate = FALSE;


	_pCacheEntryInfo = (CACHE_ENTRY_INFOEX *) ALLOCATE_FIXED_MEMORY(CACHE_ENTRY_INFOEX_SIZE); 
    // Set the URL for this object
    // if you drill down to the defn of GetURL(), you'll see that it's returning
    // _CacheUrlName from the class.  This variable has NOTHING to do with the
    // caching layer.  They just have a misleading variable name there!
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
    InternetQueryOptionA(_hRequest, WINHTTP_OPTION_URL, _szUrl, &dwSize);

	// This is where _nextState is set
    _nextState = CHECK_IF_IN_CACHE;

    if (_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_READ)
        _nextState = PREPARE_DOWNLOAD_FROM_INET;
    
}


HTTPCACHE_REQUEST::~HTTPCACHE_REQUEST()
{
    // If there's a file that we're using to write to the cache,
    // but fails to commit to the cache index, then we entirely
    // get rid of the file here
    if (_fDeleteWriteFile == TRUE)
    {
        CloseHandle(_hCacheWriteFile);
        DeleteFile(_lpszCacheWriteLocalFilename);
    }
    
    if (_lpszFileName)
        FREE_MEMORY(_lpszFileName);

    if (_lpszFileExtension)
        FREE_MEMORY(_lpszFileExtension);
  
    if (_lpszCacheWriteLocalFilename)
        FREE_MEMORY(_lpszCacheWriteLocalFilename);

    if (_pCacheEntryInfo)
        FREE_MEMORY(_pCacheEntryInfo);
}


/////////////////////////////////////////////////////////////////////////
//
// HTTPCACHE_REQUEST Public interface:
//      SendRequest
//      ReceiveResponse
//      QueryDataAvailable
//      ReadData
//
// Essentially these public interfaces keep track of a state variable (_nextState)
// and manipulate the states based on the results returned from the private
// functions.
//
// It is structured so that ONLY the public interface should manipulate the state
// variables
//
// The lpszHeader and lpOptional parameters are being ignored
// by the cache, unless the cache fails (cache lookup fails or IMS request
// returns 200 OK), in which case we call the net SendRequest with
// the passed-in parameters

PUBLIC BOOL HTTPCACHE_REQUEST::SendRequest(
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength
    )

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::SendRequest",
                 NULL
                 ));

    BOOL fResult = FALSE;
	BOOL fFinish = FALSE;

    do
    {
        switch(_nextState)
        {
            case CHECK_IF_IN_CACHE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("CHECK_IF_IN_CACHE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));
                
                fResult = OpenCacheReadStream();
                
                if (fResult)
                {
                    _fCacheReadInProgress = TRUE;
                    DEBUG_PRINT(CACHE, INFO, ("%s coming from the cache\n", GetUrl()));
                    if (IsPartialCacheEntry())
                        _nextState = ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER;
                    else
                        _nextState = ADD_NORMAL_CONTENT_IMS_HEADER;
                }
                else
                {
                    _fCacheReadInProgress = FALSE;
                    _nextState = PREPARE_DOWNLOAD_FROM_INET;
                }
                
                break;

            case ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                // we don't need to check for expiry if it's a partial content
                LockPartialCacheEntry();
                AddRangeRequestHeaders();
                _nextState = SEND_REQUEST;

                break;
                    
            case ADD_NORMAL_CONTENT_IMS_HEADER:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("ADD_NORMAL_CONTENT_IMS_HEADER state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (_dwCacheFlags & CACHE_FLAG_ALWAYS_RESYNCHRONIZE || 
                   IsExpired() == TRUE)
                {   
                    AddIfModifiedSinceHeaders();
                    _nextState = SEND_REQUEST;
                }
                else
                {
                    _nextState = PREPARE_READ_FROM_CACHE;
                }
                
                break;

            case SEND_REQUEST:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("SEND_REQUEST state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                DWORD dwStatusCode;
                DWORD dwAction;
                 
                fResult = TransmitRequest(&dwStatusCode);
                if (fResult)
                {
                    CheckResponseAfterIMS(dwStatusCode);

                    // If I get a 304 back, then it means it's not modified, and I can grab it
                    // from the cache
                    if (dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                        _nextState = PREPARE_READ_FROM_CACHE;
                        
                    // If I get back a 200 then I can start reading data from the net;
                    // but I don't have to do a SendRequets again caz it's already done in
                    // the Transmit request call
                    else if (dwStatusCode == HTTP_STATUS_OK)
                        _nextState = PREPARE_READ_FROM_INET_AFTER_200_RESPONSE;

                    // If we get a 206, then do the partial read
                    else if (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT &&
                           _pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY) 
                        _nextState = PARTIAL_READ;

                    // Otherwise, I'll have to clear all the headers, reset the request object
                    // and redo the full SendRequest again (CACHE_SEND_ERROR state)
                }
                else
                {
                    _nextState = CACHE_SEND_ERROR;
                }

                break;

            case PARTIAL_READ:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PARTIAL_READ state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                fResult = FakePartialCacheResponseHeaders();
                                
                _nextState = PREPARE_READ_FROM_CACHE;
                fFinish = TRUE;
                break;
                
            case PREPARE_READ_FROM_CACHE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_READ_FROM_CACHE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                // If the request can be satisifed by the cache, we complete the SendRequest
                // transaction by recovering the response headers from the cache so that the
                // user is not aware that the content is coming from the cache
                FakeCacheResponseHeaders();
                fResult = TRUE;
                fFinish = TRUE;
                break;

            case PREPARE_READ_FROM_INET_AFTER_200_RESPONSE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_READ_FROM_INET_AFTER_200_RESPONSE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (IsPartialCacheEntry())
                    DeletePartialCacheFile();

                CloseCacheReadStream();

                _nextState = PREPARE_DOWNLOAD_FROM_INET;
                fFinish = TRUE;
                break;
                
            // somehow adding the request header fails, so we fall back to downloading from inet
            case CACHE_SEND_ERROR:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("CACHE_SEND_ERROR state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (IsPartialCacheEntry())
                    DeletePartialCacheFile();

                CloseCacheReadStream();

                // Reset the request handle object (clear any previous request headers, etc...)
                // so it can be used to send new requests again
                InternalReuseHTTP_Request_Handle_Object(_hRequest);

                _nextState = PREPARE_DOWNLOAD_FROM_INET;
                break;
                
            case PREPARE_DOWNLOAD_FROM_INET:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_DOWNLOAD_FROM_INET state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                fResult = WinHttpSendRequest(
                            _hRequest, 
                            lpszHeaders,
                            dwHeadersLength,
                            lpOptional,
                            dwOptionalLength,
                            0, 
                            0);
                
                fFinish = TRUE;
                break;

            default:
                fResult = FALSE;
                fFinish = TRUE;
                break;
        }
    } while (!fFinish);

    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::ReceiveResponse(LPVOID lpBuffersOut)
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReceiveResponse",
                 NULL
                 ));
    BOOL fResult = FALSE;

    switch (_nextState)
    {
        case PREPARE_READ_FROM_CACHE:
            _nextState = BEGIN_CACHE_READ;    
            fResult = TRUE;
            break;

        case PREPARE_DOWNLOAD_FROM_INET:
            _nextState = BEGIN_DOWNLOAD_FROM_INET;
            fResult = WinHttpReceiveResponse(_hRequest, lpBuffersOut);
            break;
        default:
            fResult = FALSE;
            break;
    }

    DEBUG_LEAVE(fResult);
    return fResult;    
}

PUBLIC BOOL HTTPCACHE_REQUEST::QueryDataAvailable(LPDWORD lpdwNumberOfBytesAvailable) 
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::QueryDataAvailable",
                 NULL
                 ));

    BOOL fResult = FALSE;
    switch (_nextState)
    {
        case END_CACHE_READ:
        case END_READ_DATA:
            *lpdwNumberOfBytesAvailable = 0;
            fResult = TRUE;
            break;

        case BEGIN_CACHE_READ:
            // We assume that the cached file size is less than 4 GB (= 2^32).  If the cached file is 
            // really that big we might as well not cache it
            *lpdwNumberOfBytesAvailable = _pCacheEntryInfo->dwSizeLow;
            fResult = TRUE;
            break;

        case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:  
        case DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE:
        case BEGIN_DOWNLOAD_FROM_INET:
            fResult = WinHttpQueryDataAvailable(_hRequest, lpdwNumberOfBytesAvailable);
            break;
 
        default:
            break;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::ReadData(LPVOID lpBuffer, 
                                            DWORD dwNumberOfBytesToRead,
                                            LPDWORD lpdwNumberOfBytesRead)
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReadData",
                 NULL
                 ));

    BOOL fFinish = FALSE;        
    BOOL fResult = FALSE;
    do
    {
        switch (_nextState)
        {
            case BEGIN_CACHE_READ:
                DEBUG_PRINT(CACHE, 
                             INFO,
                             ("BEGIN_CACHE_READ state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = ReadDataFromCache(lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
                if (fResult == FALSE)
                    _nextState = BEGIN_DOWNLOAD_FROM_INET;
                else if (*lpdwNumberOfBytesRead == 0)
                {
                    _nextState = END_CACHE_READ;
                }
                else
                {
                    _nextState = BEGIN_CACHE_READ;      // just to be more clear
                    fFinish = TRUE;
                }                
                break;
                
            case BEGIN_DOWNLOAD_FROM_INET:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("BEGIN_DOWNLOAD_FROM_INET state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_WRITE)
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                else
                    _nextState = PREP_FOR_CACHE_WRITE;

                if (GetScheme() == INTERNET_SCHEME_HTTPS && 
                   _dwCacheFlags & CACHE_FLAG_DISABLE_SSL_CACHING)
                {
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;  // SetPerUserItem(TRUE) ??;
                }

                break;

            case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("DOWNLOAD_FROM_INET_WITH_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = WinHttpReadData(_hRequest, 
                                         lpBuffer, 
                                         dwNumberOfBytesToRead, 
                                         lpdwNumberOfBytesRead);
                if (fResult)
                    _nextState = WRITE_TO_CACHE_ENTRY;
                else
                {
                    _nextState = COMMIT_PARTIAL_CACHE_ENTRY;
                    fFinish = TRUE;
                }
                break;

            case DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = WinHttpReadData(_hRequest, 
                                         lpBuffer, 
                                         dwNumberOfBytesToRead, 
                                         lpdwNumberOfBytesRead);
                fFinish = TRUE;
                break;
                
            case PREP_FOR_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREP_FOR_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                INET_ASSERT((_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_WRITE) == FALSE);
                BOOL fNoCache;
                
                if (FCanWriteHTTP1_1ResponseToCache(&fNoCache))
                {
                
                    // fNoCache indicates that a cache-control: no-store
                    // or cache-control: no-cache is present, so we need
                    // to make sure that the cache does not keep any
                    // previous copies of the file as well
                    if (fNoCache)        
                        DeleteUrlCacheEntryA(GetUrl());

                    SetFilenameAndExtForCacheWrite();
                    _RealCacheFileSize = 0;
                    
                    if (CreateCacheWriteFile())
                    {
                        _fCacheWriteInProgress = TRUE;
                        _nextState = DOWNLOAD_FROM_INET_WITH_CACHE_WRITE;
                    }
                    else
                    {    
                        _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                    }
                }    
                else
                {
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                }
                break;

            case WRITE_TO_CACHE_ENTRY:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("WRITE_TO_CACHE_ENTRY state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (*lpdwNumberOfBytesRead == 0)
                    _nextState = END_CACHE_WRITE;
                else
                {
                    if ((fResult = WriteToCacheFile((LPBYTE) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead)) == TRUE)
                    {
                        _nextState = DOWNLOAD_FROM_INET_WITH_CACHE_WRITE;
                        fFinish = TRUE;
                    }
                    else
                    {
                        _nextState = COMMIT_PARTIAL_CACHE_ENTRY;
                    }
                }
                break;

            case COMMIT_PARTIAL_CACHE_ENTRY:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("COMMIT_PARTIAL_CACHE_ENTRY state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (!CommitCacheFileEntry(FALSE))
                    // The partial entry cannot be committed to the cache, so let's
                    // delete it in the destructor so it'll not become a stale entry
                    _fDeleteWriteFile = TRUE;
                else
                    _fDeleteWriteFile = FALSE;

                _fCacheWriteInProgress = FALSE; 
                _nextState = END_READ_DATA;
                fResult = TRUE;
                fFinish = TRUE;
                break;
                
            case END_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (!CommitCacheFileEntry(TRUE))
                    // The file cannot be committed to the cache, so let's
                    // delete it in the destructor so it'll not become a stale entry
                    _fDeleteWriteFile = TRUE;
                else
                    _fDeleteWriteFile = FALSE;

                _fCacheWriteInProgress = FALSE; 
                _nextState = END_READ_DATA;
                fResult = TRUE;
                fFinish = TRUE;
                break;

            case END_CACHE_READ:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_CACHE_READ state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                // Close the cache read file handle
                CloseCacheReadStream();
                _fCacheReadInProgress = FALSE;
                if (_fIsPartialCache == TRUE)
                {
                    _nextState = BEGIN_DOWNLOAD_FROM_INET;
                    _fIsPartialCache = FALSE;
                }
                else
                    _nextState = END_READ_DATA;

                fResult = TRUE;
                fFinish = TRUE;
                break;


            case END_READ_DATA:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_READ_DATA state\n in HTTPCACHE_REQUEST::ReadData"
                             ));

                lpBuffer = (LPVOID)'\0';
                *lpdwNumberOfBytesRead = 0;
                fResult = TRUE;
                fFinish = TRUE;
                break;

            // If we ever got here, we REALLY SHOULD PANIC!!  Fix this later
            default:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("HTTPCACHE_REQUEST::ReadData FSM is in bogus state\n"
                             ));

                fResult = WinHttpReadData(_hRequest, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
                fFinish = TRUE;
                break;
                
        }
    } while (!fFinish);

    // Before you exit this loop, make sure you set fResult to the intended value
    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::CloseRequestHandle()
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CloseHandle",
                 NULL
                 ));

    BOOL fResult = FALSE;
    switch (_nextState)
    {            
        case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:
            // The idea here is that if the user calls WinHttpCloseHandle
            // before the full content has been downloaded, then we
            // should try to commit it as a partial entry for later retrieval
            
            if (!CommitCacheFileEntry(FALSE))
                // The file cannot be committed to the cache, so let's
                // delete it in the destructor so it'll not become a stale entry
                _fDeleteWriteFile = TRUE;
            else
                _fDeleteWriteFile = FALSE;

            _fCacheWriteInProgress = FALSE; 
            
            // intentional fall through;
            
        case END_READ_DATA:
        default:
            fResult = WinHttpCloseHandle(_hRequest);
            break;

    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


////////////////////////////////////////////////////////////////////////
//
// Miscelleneous utility functions
//
//
//


/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokExA (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

#define EXE_EXTENSION   TEXT(".exe")
#define DLL_EXTENSION   TEXT(".dll")
#define CGI_EXTENSION   TEXT(".cgi")

LPSTR GetFileExtensionFromUrl(
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwLength)
/*++

Routine Description:
    This routine returns a possible file extension from a URL
    It does this by walking back from the end till the first  dot.

Arguments:

    lpszUrl         Url to derive the extension from

    lpdwLength      max length of the extension expected

Returns:

    NULL if no dot within the passed in length or a forward slash or a
    backward slash encountered before the dot. Otherwise returns a pointer
    pointing past the dot in the url string

Comments:

--*/
{
    const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";

    INET_ASSERT(lpszUrl && lpdwLength);

    if (!lpszUrl)
    {
        *lpdwLength = 0;
        return NULL;
    }

    LPSTR pszPeriod = NULL;
    BOOL fContinue = TRUE;

    // Scanning from left to right, note where we last saw a period.
    // If we see a character that cannot be in an extension, and we've seen a period, forget
    // about the period.
    // Repeat this until we've reached the end of the url, a question mark (query) or hash (fragment)

    // 1.6.98: _However_, if the file extension we've discovered is either .dll or .exe, 
    //         we'll continue to scan beyond the query mark for a file extension.

    // 1.20.98: And if we find no extension before the question mark, we'll look after it, then.
    
    while (fContinue)
    {
        switch (*lpszUrl)
        {
        case TEXT('.'):
            pszPeriod = lpszUrl;
            break;

        case TEXT('?'):
            if (pszPeriod)
            {
                if ((!StrCmpNI(pszPeriod, EXE_EXTENSION, ARRAY_ELEMENTS(EXE_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, DLL_EXTENSION, ARRAY_ELEMENTS(DLL_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, CGI_EXTENSION, ARRAY_ELEMENTS(CGI_EXTENSION)-1)))
                {
                    pszPeriod = NULL;
                    break;
                }
            }
            else
            {
                break;
            }
            
        case TEXT('#'):
        case TEXT('\0'):
            fContinue = FALSE;
            break;

        default:
            if (pszPeriod && strchr(vszInvalidFilenameChars, *lpszUrl))
            {
                pszPeriod = NULL;
            }        
        }
        lpszUrl++;
    }
    // This will be off by one
    lpszUrl--;
    if (pszPeriod)
    {
        if (*lpdwLength < (DWORD)(lpszUrl-pszPeriod))
        {
            pszPeriod = NULL;
        }
        else
        {
            pszPeriod++;
            *lpdwLength = (DWORD)(lpszUrl-pszPeriod);
        }
    }
    return pszPeriod;
}

// This function and the #define should be moved to registry.cxx

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

PRIVATE BOOL GetFileExtensionFromMimeType(
    LPCSTR  lpszMimeType,
    DWORD   dwMimeLen,
    LPSTR   lpszFileExtension,
    LPDWORD lpdwExtLen
    )
{
    HKEY    hKey = NULL;
    LPSTR   lpszMimeKey = (LPSTR)_alloca(sizeof(MIME_TO_FILE_EXTENSION_KEY)+dwMimeLen);

    memcpy(lpszMimeKey, MIME_TO_FILE_EXTENSION_KEY,
            sizeof(MIME_TO_FILE_EXTENSION_KEY)-1);
    memcpy(lpszMimeKey + sizeof(MIME_TO_FILE_EXTENSION_KEY) - 1, lpszMimeType,
            dwMimeLen);
    lpszMimeKey[sizeof(MIME_TO_FILE_EXTENSION_KEY) + dwMimeLen - 1] = '\0';

    if (REGOPENKEYEX(HKEY_CLASSES_ROOT,
                               lpszMimeKey,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey)==ERROR_SUCCESS)
    {
        DWORD dwType, dwError = RegQueryValueEx(hKey,
                                EXTENSION_VALUE,
                                NULL,
                                &dwType,
                                (LPBYTE)lpszFileExtension,
                                lpdwExtLen);
        REGCLOSEKEY(hKey);
        return (dwError==ERROR_SUCCESS);
    }
    return FALSE;
}

PRIVATE BOOL FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    )
{
    LPCSTR rgszExcludedMimeTypes[] = {
        "multipart/mixed",
        "multipart/x-mixed-replace",
        "multipart/x-byteranges"
    };

    const DWORD rgdwExcludedMimeTypeSizes[] = {
        sizeof("multipart/mixed") - 1,
        sizeof("multipart/x-mixed-replace") - 1,
        sizeof("multipart/x-byteranges") - 1
    };


    DWORD i;
    LPCSTR * lprgszMimeExcludeTable = rgszExcludedMimeTypes;
    DWORD dwMimeExcludeCount = (sizeof(rgszExcludedMimeTypes)/sizeof(LPSTR));
    const DWORD *lprgdwMimeExcludeTableOfSizes = rgdwExcludedMimeTypeSizes;

    for (i = 0; i < dwMimeExcludeCount; ++i) {
        if ((dwMimeTypeSize == lprgdwMimeExcludeTableOfSizes[i]) &&
            !strnicmp(lpszMimeType,
                      lprgszMimeExcludeTable[i],
                      lprgdwMimeExcludeTableOfSizes[i])) {

            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\cacheread.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cacheread.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object which involve reading from the cache

Author:

Revision History:

--*/

#include <wininetp.h>
#include <string.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "internalapi.hxx"
#include "..\http\proc.h"

extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)


////////////////////////////////////////////////////////////////////////////////
//
// Cache read related private functions:
//
//      EndCacheRead
//      ReadDataFromCache
//      SendIMSRequest
//      CheckIfInCache
//      CheckIsExpired
//      AddIfModifiedSinceAndETag
//      CheckResponseAfterIMS
//
//

PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::ResetCacheReadVariables()
/*++

Routine Description:

    Should be call to reset all variables related to cache read for new requests

Return Value: 

    NONE
    
--*/
{
    _hCacheReadStream = NULL;
    _dwCurrentStreamPosition = 0;
}

PRIVATE BOOL HTTPCACHE_REQUEST::CloseCacheReadStream(VOID)
/*++

Routine Description:

    Close the cache read stream to fully complete the cache read operation.    

Pre-condition:

    OpenCacheReadStream() returns TRUE
    
Side Effects:  

    _hCacheReadStream = NULL;
    _dwCurrentStreamPosition = 0;

Return Value: 

    BOOL indicating whether the call is successful or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CloseCacheReadStream",
                 NULL
                 ));

    BOOL fResult = FALSE;

    if (_fIsPartialCache == TRUE)
        return TRUE;
    
    INET_ASSERT(_hCacheReadStream != NULL);

    if (UnlockUrlCacheEntryStream(_hCacheReadStream, 0))
    {
        // reinitializes the variables so the new requests won't screw up
        fResult = TRUE;
        ResetCacheReadVariables();
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE BOOL HTTPCACHE_REQUEST::ReadDataFromCache(
                                    LPVOID lpBuffer,
                                    DWORD dwNumberOfBytesToRead,
                                    LPDWORD lpdwNumberOfBytesRead
                                    )
/*++

Routine Description:

    Try to read dwNumberOfBytesToRead bytes of data from the current file pointer for the
    cache entry, and return the data to lpBuffer.  Also return the actual number of bytes
    read to lpdwNumberOfBytesRead

    Similar to HTTP_REQUEST_HANDLE_OBJECT::AttemptReadFromFile in Wininet
    
Parameters:

Precondition:

    OpenCacheReadStream() returns TRUE before is function is being called
    
Side Effects:  

    NONE

Return Value: 

    BOOL indicating whether the call is successful or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReadDataFromCache",
                 NULL
                 ));

    BOOL fSuccess;
    DWORD dwBytesToCopy = 0;

    if (!dwNumberOfBytesToRead)
    {
        *lpdwNumberOfBytesRead = 0;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    if (_fCacheReadInProgress && !_fIsPartialCache)
    {
        // INET_ASSERT(_VirtualCacheFileSize == _RealCacheFileSize);

        // Entire read should be satisfied from cache.
        *lpdwNumberOfBytesRead = dwNumberOfBytesToRead;

        if (ReadUrlCacheEntryStream(_hCacheReadStream, 
                                    _dwCurrentStreamPosition, 
                                    lpBuffer, 
                                    lpdwNumberOfBytesRead, 
                                    0))
        {
            _dwCurrentStreamPosition += *lpdwNumberOfBytesRead;
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        else
        {
            *lpdwNumberOfBytesRead = 0;
            DEBUG_PRINT(CACHE, ERROR, ("Error in ReadUrlCacheEntryStream: _hCacheReadStream=%d, _dwCurrentStreamPosition=%d\n",
                            _hCacheReadStream, _dwCurrentStreamPosition));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    else if (_fCacheWriteInProgress || _fCacheReadInProgress && _fIsPartialCache)
    {
        // See if the read is completely within the file.
        if (_dwCurrentStreamPosition + *lpdwNumberOfBytesRead > _VirtualCacheFileSize) // && !IsEndOfFile()   ??
        {

            DEBUG_PRINT(CACHE, ERROR, ("Error: Current streampos=%d cbToRead=%d, _VirtualCacheFileSize=%d\n",
                            _dwCurrentStreamPosition, *lpdwNumberOfBytesRead, _VirtualCacheFileSize));

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        INET_ASSERT((_lpszCacheWriteLocalFilename != NULL) || _fIsPartialCache);

        if (_fIsPartialCache)
        {
            _lpszCacheWriteLocalFilename = NewString(_pCacheEntryInfo->lpszLocalFileName);

            INET_ASSERT(_lpszCacheWriteLocalFilename);
        }
        
        HANDLE hfRead;
        hfRead = CreateFile(_lpszCacheWriteLocalFilename, 
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE, 
                          NULL, 
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL);

        if (hfRead == INVALID_HANDLE_VALUE) 
        {
            DEBUG_PRINT(CACHE, ERROR, ("CreateFile failed:  Local filename = %s", _lpszCacheWriteLocalFilename));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        // Read the data from the file.
        SetFilePointer (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
        fSuccess = ReadFile (hfRead, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead, NULL);
        if (fSuccess)
            _dwCurrentStreamPosition += *lpdwNumberOfBytesRead;

        CloseHandle(hfRead);
        
        return fSuccess;
        
    }
    else
    {
        DEBUG_PRINT(CACHE, ERROR, ("Error: unexpected program path.  (possibly uninitalized variables?)\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
}

PRIVATE VOID HTTPCACHE_REQUEST::CheckResponseAfterIMS(DWORD dwStatusCode)
/*++

Routine Description:

    We get back the response after sending a IMS request.  This routine finds out
    if the content is modified (in which case we have to go to the net again), not
    modfied (in which case we can grab it from the cache), or whether it's a 
    partial cache entry (it which case we follow the partial cache logic in partial.cxx)

    Similar to HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO in wininet
    
Parameters:

    dwStatusCode - the HTTP response status code sent back from the server after the IMS request
    
Precondition:

    TransmitRequest() (conditional send request) has been called
    
Side Effects:  

    NONE
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::CheckResponseAfterIMS",
                 "%d",
                 dwStatusCode
                 ));

    // Assume that a conditional send request has already been called and response returned back.    
    INET_ASSERT((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                || (dwStatusCode == HTTP_STATUS_PRECOND_FAILED)
                || (dwStatusCode == HTTP_STATUS_OK)
                || (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (dwStatusCode == 0));

    // Extract the time stamps from the HTTP headers
    CalculateTimeStampsForCache();

    // TODO:  fVariation??

    // We get a 304 (if-modified-since was not modified), then use the entry from the cache
    // Optimization:  When the return status is OK and the server sent us a last modified time
    // that is exactly the same as what's in the cache entry, then we follow the same behavior 
    // as a 304
    if ((dwStatusCode == HTTP_STATUS_NOT_MODIFIED) ||        
       ((_fHasLastModTime) && (FT2LL(_ftLastModTime) == FT2LL(_pCacheEntryInfo->LastModifiedTime))))
    {
        DWORD dwAction = CACHE_ENTRY_SYNCTIME_FC;

        if (_fHasExpiry)
        {
            (_pCacheEntryInfo->ExpireTime).dwLowDateTime = _ftExpiryTime.dwLowDateTime;
            (_pCacheEntryInfo->ExpireTime).dwHighDateTime = _ftExpiryTime.dwHighDateTime;
            dwAction |= CACHE_ENTRY_EXPTIME_FC;
        }

        // update the cache entry type if needed
        DWORD dwType;
        dwType = _pCacheEntryInfo->CacheEntryType;
        if (dwType)
            _pCacheEntryInfo->CacheEntryType |= dwType;
        dwAction |= CACHE_ENTRY_TYPE_FC;

        // Update the last sync time to the current time
        // so we can do once_per_session logic
        if (!SetUrlCacheEntryInfoA(_pCacheEntryInfo->lpszSourceUrlName, _pCacheEntryInfo, dwAction))
        {
            // NB if this call fails, the worst that could happen is
            // that next time around we will do an if-modified-since
            // again
            INET_ASSERT(FALSE);
        }

    }
    
    DEBUG_LEAVE(0);
}

PRIVATE BOOL HTTPCACHE_REQUEST::TransmitRequest(IN OUT DWORD * pdwStatusCode)
/*++

Routine Description:

    A call to WinHttpSendRequest.  Use this call to send a I-M-S or a 
    U-M-S request

Parameter

    pdwStatusCode - returns the status code of the Send request
    
Return Value: 

    BOOL - whether the call is successful
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::TransmitRequest",
                 NULL
                 ));

    DWORD dwSize = sizeof(DWORD);
    BOOL fResult;
    
    // Someone will get here only if they're calling WinHttpSendRequest()
    // and is using the cache, so...
    INET_ASSERT(_hRequest);

    // resend the HTTP request
    WinHttpSendRequest(_hRequest, NULL, 0, NULL, 0, 0, 0);
    WinHttpReceiveResponse(_hRequest, NULL);

    // Examine what HTTP status code I get back after the send request
    fResult = WinHttpQueryHeaders(_hRequest, 
                            WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                            NULL, 
                            pdwStatusCode, 
                            &dwSize, 
                            NULL);

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL HTTPCACHE_REQUEST::FakeCacheResponseHeaders()
/*++

Routine Description:

    If a resource is coming from the cache, sets the HTTP Response Headers
    so that users apps calling WinHttpQueryHeaders get the right behaviours.

    Basically this function is the HTTP_REQUEST_HEADER::FHttpBeginCacheRetreival,
    AddTimestampsForCacheToResponseHeaders(), and AddTimeHeader() from
    from wininet all packed together
    
Precondition:

    The GET request content can be fulfilled by the cache
    
Return Value: 

    BOOL
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::FakeCacheResponseHeaders",
                 NULL
                 ));

    LPSTR lpHeaders = NULL;
    DWORD dwError = ERROR_INVALID_PARAMETER;
    TCHAR szBuf[128];
    BOOL fResult = FALSE;
    
    // DO we need to warp this call by a _ResponseHeader.LockHeader() and
    // UnlockHeader() pair??
    
    // allocate buffer for headers
    lpHeaders = (LPSTR)ALLOCATE_FIXED_MEMORY(_pCacheEntryInfo->dwHeaderInfoSize+512);
    if (!lpHeaders)
        goto quit;

    memcpy(lpHeaders, _pCacheEntryInfo->lpHeaderInfo, _pCacheEntryInfo->dwHeaderInfoSize);

    InternalReuseHTTP_Request_Handle_Object(_hRequest);

    dwError = InternalCreateResponseHeaders(_hRequest, &lpHeaders, _pCacheEntryInfo->dwHeaderInfoSize);

    if (dwError == ERROR_SUCCESS)
    {
        if (AddTimeResponseHeader(_pCacheEntryInfo->LastModifiedTime, WINHTTP_QUERY_LAST_MODIFIED))
        {
            if (AddTimeResponseHeader(_pCacheEntryInfo->ExpireTime, WINHTTP_QUERY_EXPIRES))
            {    
                fResult = TRUE;
            }
         }
     }

quit:
    if (lpHeaders)
        FREE_MEMORY(lpHeaders);

    DEBUG_LEAVE(fResult);
    return (fResult);
    
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::AddTimeResponseHeader(
    IN FILETIME fTime,
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Add a response header that has a time-related value.
    
    Used mainly as a helper function for FakeCacheResponseHeaders to add 
    time-related response headers

Parameters:

    fTime - Time in FILTIME format
    dwQueryIndex - the type of response header to add
    
Return Value: 

    BOOL
    
--*/    
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::AddTimeResponseHeader",
                 "%#x:%#x, %d",
                 fTime.dwLowDateTime,
                 fTime.dwHighDateTime,
                 dwQueryIndex
                 ));

    BOOL fResult = FALSE;
    SYSTEMTIME systemTime;
    DWORD dwLen;
    TCHAR szBuf[64];
    
    if (FT2LL(fTime) != LONGLONG_ZERO) 
    {
        if (FileTimeToSystemTime((CONST FILETIME *)&fTime, &systemTime)) 
        {
            if (InternetTimeFromSystemTimeA((CONST SYSTEMTIME *)&systemTime,
                                              szBuf)) 
            {
                fResult = (ERROR_SUCCESS == InternalReplaceResponseHeader(
                                                    _hRequest,
                                                    dwQueryIndex,
                                                    szBuf,
                                                    strlen(szBuf),
                                                    0,
                                                    WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
                                                    ));
                                                    
                                               
            } 
        }
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE BOOL HTTPCACHE_REQUEST::OpenCacheReadStream()
/*++

Routine Description:

    Determines if the URL entry of this object is already in the cache, and
    if so, open up the cache read file stream so that cache retrieval
    can be done.
    
Return Value: 

    BOOL
    
--*/
    
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::OpenCacheReadStream",
                 NULL
                 ));

    BOOL fResult = FALSE;
    LPSTR lpszUrl;
    HANDLE hReadStream;
    
    lpszUrl = GetUrl();
    
    // look up URL from the cache and if found, get the handle to the cache objects
    // We DO NOT take redirection into account.  Redirection is handled at a higher layer 
    if (UrlCacheRetrieve(lpszUrl, FALSE, &hReadStream, &_pCacheEntryInfo) == ERROR_SUCCESS)
    {
        DEBUG_PRINT (CACHE, INFO, ("%s found in the cache!!  Local filename: %s\n", lpszUrl, _pCacheEntryInfo->lpszLocalFileName));

        // Note that if this is a partial entry, then _hCacheReadStream will be set
        // to NULL.  But at this point we don't check whether this is a partial
        // entry or not
        ResetCacheReadVariables();
        _hCacheReadStream = hReadStream;
        
        fResult = TRUE;
    }
    else
        _hCacheReadStream = NULL;
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

// --- from wininet\http\cache.cxx
/*============================================================================
IsExpired (...)

4/17/00 (RajeevD) Corrected back arrow behavior and wrote detailed comment.
 
We have a cache entry for the URL.  This routine determines whether we should
synchronize, i.e. do an if-modified-since request.  This answer depends on 3
factors: navigation mode, expiry on cache entry if any, and syncmode setting.

1. There are two navigation modes:
a. hyperlinking - clicking on a link, typing a URL, starting browser etc.
b. back/forward - using the back or forward buttons in the browser.

In b/f case we generally want to display what was previously shown.  Ideally
wininet would cache multiple versions of a given URL and trident would specify
which one to use when hitting back arrow.  For now, the best we can do is use
the latest (only) cache entry or resync with the server.

EXCEPTION: if the cache entry sets http/1.1 cache-control: must-revalidate,
we treat as if we were always hyperlinking to the cache entry.  This is 
normally used during offline mode to suppress using a cache entry after
expiry.  This overloaded usage gives sites a workaround if they dislike our
new back button behavior.

2. Expiry may fall into one of 3 buckets:
a. no expiry information
b. expiry in past of current time (hyperlink) or last-access time (back/fwd)
c. expiry in future of current time (hyperlink) or-last access time (back/fwd)

3. Syncmode may have 3 settings
a. always - err on side of freshest data at expense of net perf.
b. never - err on side of best net perf at expense of stale data.
c. once-per-session - middle-of-the-road setting
d. automatic - slight variation of once-per-session where we decay frequency
of i-m-s for images that appear to be static.  This is the default.

Based on these factors, there are 5 possible result values in matrices below:
1   synchronize
0   don't synchronize
?   synchronize if last-sync time was before start of the current session, 
?-  Like per-session except if URL is marked static and has a delay interval.
0+  Don't sync if URL is marked static, else fall back to per-session


HYPERLINKING

When hyperlinking, expiry takes precedence, then we look at syncmode.

                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Current Time     of Current Time
                               
   Always           1                   0                   1  


   Never            0                   0                   1


   Per-Session      ?                   0                   1


   Automatic        ?-                  0                   1

   
BACK/FORWARD

When going back or forward, we generally don't sync.  The exception is if
we should have sync'ed the URL on the previous navigate but didn't.  We
deduce this by looking at the last-sync time of the entry.


                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Last-Access Time of Last-Access Time
    
   Always           ?                   0                   ?


   Never            0                   0                   ?


   Per-Session      ?                   0                   ?


   Automatic        0+                  0                   ?


When considering what might have happened when hyperlinking to this URL,
the decision tree has 5 outcomes:
1. We might have had no cache entry and downloaded to cache for the first time
2. Else we might have had a cache entry and used it w/o i-m-s
3. Else we did i-m-s but the download was aborted
4. Or the i-m-s returned not modified
5. Or the i-m-s returned new content
Only in case 3 do we want to resync the cache entry.

============================================================================*/

PRIVATE BOOL HTTPCACHE_REQUEST::IsExpired ()
/*++

Routine Description:

    Determines whether the current cache entry is expired.  If it's 
    expired then we need to synchronize (i.e. do a i-m-s request)

Parameters:

    NONE
    
Side Effects:  

    _fLazyUpdate

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::IsExpired",
                 NULL
                 ));

    BOOL fExpired;
    FILETIME ftCurrentTime;
    GetCurrentGmtTime (&ftCurrentTime);

    if ((_dwCacheFlags & CACHE_FLAG_FWD_BACK)
        && !(_pCacheEntryInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        // BACK/FORWARD CASE

        if (FT2LL (_pCacheEntryInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // We have an expires time.
            if (FT2LL (_pCacheEntryInfo->ExpireTime) > FT2LL(_pCacheEntryInfo->LastAccessTime))
            {
                // Expiry was in future of last access time, so don't resync.
                fExpired = FALSE;
            }                
            else
            {
                // Entry was originally expired.  Make sure it was sync'ed once.
                fExpired = (FT2LL(_pCacheEntryInfo->LastSyncTime) < dwdwSessionStartTime);
            }
        }
        else switch (_dwCacheFlags)
        {
            default:
            case CACHE_FLAG_SYNC_MODE_AUTOMATIC:
                if (_pCacheEntryInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    fExpired = FALSE;
                    break;
                }
            // else intentional fall-through...
        
            case CACHE_FLAG_SYNC_MODE_ALWAYS:
            case CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION:
                fExpired = (FT2LL(_pCacheEntryInfo->LastSyncTime) < dwdwSessionStartTime);
                break;

            case CACHE_FLAG_SYNC_MODE_NEVER:
                fExpired = FALSE;
                break;
                
        } // end switch
    }
    else
    {
        // HYPERLINKING CASE

        // Always strictly honor expire time from the server.
        _fLazyUpdate = FALSE;
        
        if(   (_pCacheEntryInfo->CacheEntryType & POST_CHECK_CACHE_ENTRY ) &&
             !(_dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
        {
            //
            // this is the (instlled) post check cache entry, so we will do
            // post check on this ietm
            //
            fExpired = FALSE;
            _fLazyUpdate = TRUE;
            
        }
        else if (FT2LL(_pCacheEntryInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // do we have postCheck time?
            //
            //           ftPostCheck                   ftExpire
            //               |                            |
            // --------------|----------------------------|-----------> time
            //               |                            | 
            //    not expired |   not expired (bg update)  |   expired
            //
            //               
            LONGLONG qwPostCheck = FT2LL(_pCacheEntryInfo->ftPostCheck);
            if( qwPostCheck != LONGLONG_ZERO )
            {
                LONGLONG qwCurrent = FT2LL(ftCurrentTime);

                if( qwCurrent < qwPostCheck )
                {
                    fExpired = FALSE;
                }
                else
                if( qwCurrent < FT2LL(_pCacheEntryInfo->ExpireTime) ) 
                {
                    fExpired = FALSE;

                    // set background update flag  
                    // (only if we are not doing lazy updating ourselfs)
                    if ( !(_dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
                    {
                        _fLazyUpdate = TRUE;
                    }
                }
                else
                {
                    fExpired = TRUE;
                }
            }
            else 
                fExpired = FT2LL(_pCacheEntryInfo->ExpireTime) <= FT2LL(ftCurrentTime);
        }
        else switch (_dwCacheFlags)
        {

            case CACHE_FLAG_SYNC_MODE_NEVER:
                // Never check, unless the page has expired
                fExpired = FALSE;
                break;

            case CACHE_FLAG_SYNC_MODE_ALWAYS:
                fExpired = TRUE;
                break;

            default:
            case CACHE_FLAG_SYNC_MODE_AUTOMATIC:

                if (_pCacheEntryInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    // We believe this entry never actually changes.
                    // Check the entry if interval since last checked
                    // is less than 25% of the time we had it cached.
                    LONGLONG qwTimeSinceLastCheck = FT2LL (ftCurrentTime)
                        - FT2LL(_pCacheEntryInfo->LastSyncTime);
                    LONGLONG qwTimeSinceDownload = FT2LL (ftCurrentTime)
                        - FT2LL (_pCacheEntryInfo->ftDownload);
                    fExpired = qwTimeSinceLastCheck > qwTimeSinceDownload/4;
                    break;
                }
                // else intentional fall through to once-per-session rules.

            case CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION:

                fExpired = TRUE;

                // Huh. We don't have an expires, so we'll improvise
                // but wait! if we are hyperlinking then there is added
                // complication. This semantic has been figured out
                // on Netscape after studying various sites
                // if the server didn't send us expiry time or lastmodifiedtime
                // then this entry expires when hyperlinking
                // this happens on queries

                if (_dwCacheFlags & INTERNET_FLAG_HYPERLINK
                    && !FT2LL(_pCacheEntryInfo->LastModifiedTime))
                {
                    // shouldn't need the hyperlink test anymore
                    DEBUG_PRINT(CACHE, INFO, ("Hyperlink semantics\n"));
                    INET_ASSERT(fExpired==TRUE);
                    break;
                }

                // We'll assume the data could change within a day of the last time
                // we sync'ed.
                // We want to refresh UNLESS we've seen the page this session
                // AND the session's upper bound hasn't been exceeded.
                if      ((dwdwSessionStartTime < FT2LL(_pCacheEntryInfo->LastSyncTime))
                    &&
                        (FT2LL(ftCurrentTime) < FT2LL(_pCacheEntryInfo->LastSyncTime) + 
                            dwdwHttpDefaultExpiryDelta))
                {                    
                    fExpired = FALSE;
                }            
                break;

        } // end switch
        
    } // end else for hyperlinking case

    DEBUG_LEAVE(fExpired);
    return fExpired;
}

PRIVATE BOOL HTTPCACHE_REQUEST::AddIfModifiedSinceHeaders()
/*++

Routine Description:

    Add the necessary IMS request headers to validate whether a cache
    entry can still be used to satisfy the GET request.

    Code from HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader
    and HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound from wininet

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::AddIfModifiedSinceHeaders",
                 NULL
                 ));

    BOOL fResult = FALSE;

    // add if-modified-since only if there is last modified time
    // sent back by the site. This way you never get into trouble
    // where the site doesn't send you an last modified time and you
    // send if-modified-since based on a clock which might be ahead
    // of the site. So the site might say nothing is modified even though
    // something might be. www.microsoft.com is one such example
    if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
    {

        TCHAR szBuf[64];
        TCHAR szHeader[HTTP_IF_MODIFIED_SINCE_LEN + 76];
        DWORD dwLen;
        DWORD dwError;
        BOOL success = FALSE;

        INET_ASSERT (FT2LL(_pCacheEntryInfo->LastModifiedTime));

        dwLen = sizeof(szBuf);

        if (FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime), szBuf, &dwLen))
        {
            if (_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY)
            {
                INET_ASSERT (dwLen);
                dwLen = wsprintf(szHeader, "%s %s", HTTP_IF_MODIFIED_SINCE_SZ, szBuf); 
            }
            else
            {
                dwLen = wsprintf(szHeader, "%s %s; length=%d", HTTP_IF_MODIFIED_SINCE_SZ, 
                               szBuf, _pCacheEntryInfo->dwSizeLow);
            }
            
            fResult = HttpAddRequestHeadersA(_hRequest, 
                                             szHeader, 
                                             dwLen,
                                             WINHTTP_ADDREQ_FLAG_ADD);

        }
    }
    
    // Only HTTP 1.1 support the ETag header
    if (!(_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
    {
        fResult = TRUE;
    }
    else
    {
        // Look for the ETag header
        TCHAR szOutBuf[256];
        TCHAR szHeader[256 + HTTP_IF_NONE_MATCH_LEN];
        DWORD dwOutBufLen = 256;
        DWORD dwHeaderLen;
        
        // If the ETag header is present, then add the "if-range: <etag>" header
        if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ETAG, NULL, szOutBuf, &dwOutBufLen, NULL))
        {
            dwHeaderLen = wsprintf(szHeader, "%s %s", HTTP_IF_NONE_MATCH_SZ, szOutBuf);

            fResult = HttpAddRequestHeadersA(_hRequest, 
                                              szHeader, 
                                              dwHeaderLen, 
                                              WINHTTP_ADDREQ_FLAG_ADD_IF_NEW);
        }
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::CalculateTimeStampsForCache()
/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Side Effects:  

    The calculated time stamps values are saved as private members 
    _ftLastModTime, _ftExpiryTime, _ftPostCheckTime, _fHasExpiry,
    _fHasLastModTime, _fHasPostCheck, and _fMustRevalidate.

Return Value: 

    NONE

--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::CalculateTimeStampsForCache",
                 NULL
                 ));

    TCHAR buf[512];
    LPSTR lpszBuf;
    BOOL fRet = FALSE;

    DWORD dwLen, index = 0;
    BOOL fPostCheck = FALSE;
    BOOL fPreCheck = FALSE;
    FILETIME ftPreCheckTime;
    FILETIME ftPostCheckTime;

    // reset the private variables
    _fHasLastModTime = FALSE;
    _fHasExpiry = FALSE;
    _fHasPostCheck = FALSE;
    _fMustRevalidate = FALSE;

    // Do we need to enter a critical section?
    // _ResponseHeaders.LockHeaders();

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    //
    // we really want all the post-fetch stuff works with 1.0 proxy
    // so we loose our grip a little bit here: enable all Cache-Control
    // max-age work with 1.0 response.
    //
    //if (IsResponseHttp1_1())

    CHAR  *ptr, *pToken;
    INT nDeltaSecsPostCheck = 0;
    INT nDeltaSecsPreCheck = 0;

    BOOL fResult;
    DWORD dwError;
    
    while (1)
    {
        // Scan headers for Cache-Control: max-age header.
        dwLen = sizeof(buf);
        fResult = HttpQueryInfoA(_hRequest, 
                                WINHTTP_QUERY_CACHE_CONTROL,
                                NULL,
                                buf,
                                &dwLen,
                                &index);

        if (fResult == TRUE) 
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();

        switch (dwError)
        {
          case ERROR_SUCCESS:      
            buf[dwLen] = '\0';
            pToken = ptr = buf;

            // Parse a token from the string; test for sub headers.
            while (pToken = StrTokExA(&ptr, ","))  // <<-- Really test this out, used StrTokEx before
            {
                SKIPWS(pToken);

                if (strnicmp(POSTCHECK_SZ, pToken, POSTCHECK_LEN) == 0)
                {
                    pToken += POSTCHECK_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    nDeltaSecsPostCheck = atoi(pToken);

                    // Calculate post fetch time 
                    GetCurrentGmtTime(&ftPostCheckTime);
                    AddLongLongToFT(&ftPostCheckTime, (nDeltaSecsPostCheck * (LONGLONG) 10000000));
                
                    fPostCheck = TRUE;
                }
                else if (strnicmp(PRECHECK_SZ, pToken, PRECHECK_LEN) == 0)
                {
                    // found
                    pToken += PRECHECK_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    nDeltaSecsPreCheck = atoi(pToken);

                    // Calculate pre fetch time (overwrites ftExpire ) 
                    GetCurrentGmtTime(&ftPreCheckTime);
                    AddLongLongToFT(&ftPreCheckTime, (nDeltaSecsPreCheck * (LONGLONG) 10000000));

                    fPreCheck = TRUE;
                }
                else if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                {
                    // Found max-age. Convert to integer form.
                    // Parse out time in seconds, text and convert.
                    pToken += MAX_AGE_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    INT nDeltaSecs = atoi(pToken);
                    INT nAge;

                    // See if an Age: header exists.

					// Using a local index variable:
                    DWORD indexAge = 0;
                    dwLen = sizeof(INT)+1;

                    if (HttpQueryInfoA(_hRequest,
                                      HTTP_QUERY_AGE | HTTP_QUERY_FLAG_NUMBER,
                                      NULL,
                                      &nAge,
                                      &dwLen,
                                      &indexAge))

                    {
                        // Found Age header. Convert and subtact from max-age.
                        // If less or = 0, attempt to get expires header.
                        nAge = ((nAge < 0) ? 0 : nAge);

                        nDeltaSecs -= nAge;
                        if (nDeltaSecs <= 0)
                            // The server (or some caching intermediary) possibly sent an incorrectly
					        // calculated header. Use "Expires", if no "max-age" directives at higher indexes.
                            // Note: This behaviour could cause a situation where the "pre-check"
                            // and "post-check" are picked up from the current index, and "max-age" is
                            // picked up from a higher index. "pre-check" and "post-check" are IE 5.x 
                            // extensions, and generally not bunched together with "max-age", so this
                            // should work fine. More info on "pre-check" and "post-check":
                            // <http://msdn.microsoft.com/workshop/author/perf/perftips.asp#Use_Cache-Control_Extensions>
                            continue;
                    }

                    // Calculate expires time from max age.
                    GetCurrentGmtTime(&_ftExpiryTime);
                    AddLongLongToFT(&_ftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                    fRet = TRUE;
                }
                else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                {
                    pToken += MUST_REVALIDATE_LEN;
                    SKIPWS(pToken);
                    if (*pToken == 0 || *pToken == ',')
                        _fMustRevalidate = TRUE;
                        
                }
            }

            // If an expires time has been found, break switch.
            if (fRet)
                break;
					
            // Need to bump up index to prevent possibility of never-ending outer while(1) loop.
            // Otherwise, on exit from inner while, we could be stuck here reading the 
            // Cache-Control at the same index.
            // HttpQueryInfoA(WINHTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
            // or an error, and we'll be good to go:
			index++;
            continue;

          case ERROR_INSUFFICIENT_BUFFER:
            index++;
            continue;

          default:
            break; // no more Cache-Control headers.
        }

        //
        // pre-post fetch headers must come in pair, also
        // pre fetch header overwrites the expire 
        // and make sure postcheck < precheck
        //
        if( fPreCheck && fPostCheck && 
            ( nDeltaSecsPostCheck < nDeltaSecsPreCheck ) ) 
        {
            fRet = TRUE;
            _ftPostCheckTime = ftPostCheckTime;
            _ftExpiryTime = ftPreCheckTime;
            _fHasPostCheck = TRUE;

            if( nDeltaSecsPostCheck == 0 && 
                !(_dwCacheFlags & CACHE_FLAG_BGUPDATE) )
            {
                //
                // "post-check = 0"
                // this page has already passed the lazy update time
                // this means server wants us to do background update 
                // after the first download  
                //
                // (bg fsm will be created at the end of the cache write)
                //
                _fLazyUpdate = TRUE;
            }
        }
        else
        {
            fPreCheck = FALSE;
            fPostCheck = FALSE;
        }

        break; // no more Cache-Control headers.
    }

    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        dwLen = sizeof(buf) - 1;
        index = 0;
        if (HttpQueryInfoA(_hRequest, HTTP_QUERY_EXPIRES, NULL, buf, &dwLen, &index))
        {
            fRet = FParseHttpDate(&_ftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(&_ftExpiryTime);
                AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(_hRequest, HTTP_QUERY_DATE, NULL, buf, &dwLen, &index) == ERROR_SUCCESS
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Data: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(_ftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(&_ftExpiryTime);
            AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    _fHasExpiry = fRet;

    if (!fRet)
    {
        _ftExpiryTime.dwLowDateTime = 0;
        _ftExpiryTime.dwHighDateTime = 0;
    }

    fRet = FALSE;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(_hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buf, &dwLen, &index))
    {
        DEBUG_PRINT(CACHE,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(&_ftLastModTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(CACHE,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    _fHasLastModTime = fRet;

    if (!fRet)
    {
        _ftLastModTime.dwLowDateTime = 0;
        _ftLastModTime.dwHighDateTime = 0;
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\internalapi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    internalapi.cxx
    
Abstract:

    Contains internal (unexposed) codes for getting/setting various properties of 
    the HTTP_REQUEST_HANDLE_OBJECT object.

    Used mainly by the WinHTTP caching layer to obtain and set extended information
    not possible through the WinHTTP C++ API.

    The cache should not be made aware about the internal class structure of 
    WinHTTP (to make a cleaner separation between the core WinHTTP layer and
    the caching layer), therefore the cache must call these internal functions to
    access internal WinHTTP functionalities.
    
Environment:

    Win32 user-mode DLL

Revision History:

--*/
#include <wininetp.h>
#include "internalapi.hxx"

BOOL InternalQueryOptionA(
    IN HINTERNET hInternet, 
    IN DWORD dwOption, 
    IN OUT LPDWORD lpdwResult
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalQueryOptionA",
                  "%#x, %d, %d",
                  hInternet,
                  dwOption,
                  *lpdwResult));

    BOOL fSuccess;
    DWORD dwError;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pReq;
    
    // map the handle
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwError == ERROR_SUCCESS) {
        hInternet = hObjectMapped;
        dwError = RGetHandleType(hInternet, &handleType);
    }

    if (dwError != ERROR_SUCCESS) {
        goto quit;
    }

    dwError = ERROR_INVALID_OPERATION;

    if (handleType == TypeHttpRequestHandle)
        pReq = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
    else
        goto quit;
    
    if (pReq == NULL)
        goto quit;
    
    switch (dwOption)
    {
      case WINHTTP_OPTION_REQUEST_FLAGS:
        *lpdwResult = pReq->GetOpenFlags();
        break;
        
      case WINHTTP_OPTION_CACHE_FLAGS:
        *lpdwResult = pReq->GetInternetOpenFlags();
        break;
        
      default:
        break;
    }

    dwError = ERROR_SUCCESS;
   
quit:
    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError = ERROR_SUCCESS)
        fSuccess = TRUE;
    else
        fSuccess = FALSE;

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}

DWORD InternalReplaceResponseHeader(
    IN HINTERNET hRequest,
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalReplaceResponseHeaders",
                  "%#x, %d",
                  hRequest,
                  dwQueryIndex));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->ReplaceResponseHeader(
                                dwQueryIndex,
                                lpszHeaderValue,
                                dwHeaderValueLength,
                                dwIndex,
                                dwFlags);
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

DWORD InternalAddResponseHeader(
    IN HINTERNET hRequest,
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalAddResponseHeaders",
                  "%#x",
                  hRequest));
    
    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    fResult = pRequest->AddInternalResponseHeader(
            dwHeaderIndex,
            lpszHeader,
            dwHeaderLength
            );
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

DWORD InternalCreateResponseHeaders(
    IN HINTERNET hRequest,
    IN OUT LPSTR* ppszBuffer,
    IN DWORD dwBufferLength
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalCreateResponseHeaders",
                  "%#x",
                  hRequest));
    
    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->CreateResponseHeaders(
                            ppszBuffer,
                            dwBufferLength);
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

    
BOOL InternalIsResponseHeaderPresent(
    IN HINTERNET hRequest, 
    IN DWORD dwQueryIndex
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalIsResponseHeadersPresent",
                  "%#x, %d",
                  hRequest,
                  dwQueryIndex));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    BOOL fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->IsResponseHeaderPresent(dwQueryIndex);

    DEBUG_LEAVE(fResult);
    return fResult;
}


BOOL InternalIsResponseHttp1_1(
    IN HINTERNET hRequest
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalIsResponseHttp1_1",
                  "%#x",
                  hRequest));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    BOOL fResult;

    fResult = ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->IsResponseHttp1_1();
    DEBUG_LEAVE(fResult);
    return fResult;
}

VOID InternalReuseHTTP_Request_Handle_Object(
    IN HINTERNET hRequest
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  None, 
                  "InternalReuseHTTP_Request_Handle_Object",
                  "%#x",
                  hRequest));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->ReuseObject();

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\cachewrite.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachewrite.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object which involve writing to the cache

Author:

Revision History:

--*/

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "..\http\headers.h"
#include "cachelogic.hxx"
#include "internalapi.hxx"
#include "..\http\proc.h"

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};
DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);
DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE,
    IN DWORD dwExpectedLength = 0
);

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::IsStaticImage()
/*++

Routine Description:

   To improve performance, Internet Explorer classify whether a cached 
   contents is a static image or not.  Images usually do not change as
   often as text contents, so they do not have to be revalidated
   from the server as often, thus improving performance.  

   Let the cache know if the item is likely to be a static image if it
   satisfies all four of the following requirements
     1. No expire time.
     2. Has last-modified time.
     3. The content-type is image/*
     4. No '?' in the URL.

Pre-condition: 

    CalculateTimeStampsForCache() has been called

Side Effects: 

    NONE

Return Value:

    BOOL to indicate whether the image is a static image or not
--*/
{
    TCHAR szHeader[256];
    DWORD dwSize = 256;
    return (!FT2LL(_ftExpiryTime)
            && FT2LL(_ftLastModTime)
            && (HttpQueryInfoA(_hRequest, HTTP_QUERY_CONTENT_TYPE,
                NULL, (LPVOID *) &szHeader, &dwSize, 0) == TRUE)
            && (StrCmpNI (szHeader, "image/", sizeof("image/")-1) == 0)
            && (!StrChr (GetUrl(), '?'))
           );
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::ExtractHeadersForCacheCommit(
    OUT LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    )
    
/*++

Routine Description:

    Most HTTP response headers are to be kept inside the cache in index.dat, so 
    that those pieces of information can be retrieved and examined
    in subsequent requests.  

    This function will extract all the HTTP response headers that will normally be
    committed to the cache entry

    Similar to FilterHeaders in Wininet
    
Parameters:

    LPSTR lpszHeaderInfo - Caller should allocate sufficient memory to hold the
                          extracted headers
        
Side Effects: 

    NONE

Return Value:

    BOOL to indicate whether the call is successful or not
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ExtractHeadersForCacheCommit",
                 NULL
                 ));

    BOOL fResult = FALSE;
    
    if (lpszHeaderInfo == NULL)
    {
        DEBUG_PRINT(CACHE, ERROR, ("First parameter is NULL.  Cannot continue\n"));
        goto quit;
    }
    
    DWORD i, len, lenT, reduced = 0, dwHeaderTableCount;
    LPSTR lpT, lpMark, lpNext, *lprgszHeaderExcludeTable;

    LPSTR rgszExcludeHeaders[] = {
        HTTP_SET_COOKIE_SZ,
        HTTP_LAST_MODIFIED_SZ,
        HTTP_SERVER_SZ,
        HTTP_DATE_SZ,
        HTTP_EXPIRES_SZ,
        HTTP_CONNECTION_SZ,
        HTTP_PROXY_CONNECTION_SZ,
        HTTP_VIA_SZ,
        HTTP_VARY_SZ,
        HTTP_AGE_SZ,
        HTTP_CACHE_CONTROL_SZ,
        HTTP_ACCEPT_RANGES_SZ,
        HTTP_CONTENT_DISPOSITION_SZ
    };
    
    lprgszHeaderExcludeTable = rgszExcludeHeaders;
    dwHeaderTableCount = sizeof(rgszExcludeHeaders) / sizeof(LPSTR);

    DWORD dwRawHeaderLen = 1024;
    TCHAR szRawHeaderInfo[1024];

    // We need to get the raw headers (with line breaks), and then
    // parse out the junk in the rest of this routine
    if (!HttpQueryInfoA(_hRequest, 
                       HTTP_QUERY_RAW_HEADERS_CRLF,
                       NULL,
                       (LPVOID *) &szRawHeaderInfo,
                       &dwRawHeaderLen,
                       NULL))
    {
        DEBUG_PRINT(CACHE, ERROR, ("HttpQueryInfoA failed\n"));
        goto quit;
    }

    // skip over the status line
    // NB this assumes that the raw buffer is nullterminated (CR/LF)
    lpT = strchr(szRawHeaderInfo, '\r');
    if (!lpT) {
        goto quit;
    }

    INET_ASSERT(*(lpT + 1) == '\n');

    lpT += 2;

    do 
    {
        // find the header portion
        lpMark = strchr(lpT, ':');
        if (!lpMark) 
        {
            break;
        }

        // get the end of the header line
        lpNext = strchr(lpMark, '\r');

        if (!lpNext)
        {
            INET_ASSERT(FALSE);
            // A properly formed header _should_ terminate with \r\n, but sometimes
            // that just doesn't happen
            lpNext = lpMark;
            while (*lpNext)
            {
                lpNext++;
            }
        }
        else
        {
            INET_ASSERT(*(lpNext + 1) == '\n');
            lpNext += 2;
        }

        len = (DWORD) PtrDifference(lpMark, lpT) + 1; 
        lenT = dwRawHeaderLen;  // doing all this to see it properly in debugger

        BOOL bFound = FALSE;

        for (i = 0; i < dwHeaderTableCount; ++i) 
        {
            if (!strnicmp(lpT, lprgszHeaderExcludeTable[i], len)) 
            {
                bFound = TRUE;
                break;
            }
        }

        // If bFound is true, then it means that it's not one of the special headers,
        // so nuke the header
        if (bFound) 
        {
            len = lenT - (DWORD)PtrDifference(lpNext, szRawHeaderInfo) + 1; // for NULL character

            // ACHTUNG memove because of overlapped copies
            memmove(lpT, lpNext, len);

            // keep count of how much we reduced the header by
            reduced += (DWORD) PtrDifference(lpNext, lpT);

            // lpT is already properly positioned because of the move
        } 
        else 
        {
            lpT = lpNext;
        }
    } while (TRUE);
    
    dwRawHeaderLen -= reduced;
    fResult = TRUE;
    
    // return results
    strncpy(lpszHeaderInfo, szRawHeaderInfo, dwRawHeaderLen);
    *lpdwHeaderLen = dwRawHeaderLen;
    DEBUG_PRINT(CACHE, 
                 INFO, 
                 ("Extracted header is %s.  Length = %d\n", 
                 lpszHeaderInfo,
                 *lpdwHeaderLen));

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL HTTPCACHE_REQUEST::CommitCacheFileEntry(
    IN BOOL fNormal
    )
/*++

Routine Description:

    Commit the downloaded resource to the cache index.  No redirection
    is taken into account here (unlike the way wininet works)
    
    Similar to INTERNET_CONNECT_HANDLE_OBJECT::LocalEndCacheWrite and 
    EndCacheWrite from wininet
    
Pre-conditions:

    CalculateTimeStampsForCache() has been called

Parameters:

    fNormal - TRUE if normal end cache write operation of the complete resource
             FALSE if interruptions occur during ReadData such that the entire
             resource hasn't been fully downloaded yet, and the resource will
             be marked as a partial cache entry.
             
Side effects:

    NONE
    
Return Value:

    BOOL to indicate whether the call is successful or not
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CommitCacheFileEntry",
                 "%B",
                 fNormal
                 ));
    
    TCHAR szFileExtension[] = "";  // eventally need to change
    TCHAR szFileName[MAX_PATH];
    DWORD dwCacheEntryType;
    BOOL fImage;
    TCHAR szHeaderInfo[2048];
    DWORD dwHeaderLen;
    BOOL fResult;
    DWORD dwError;
    FILETIME ftCreate;
    BOOL fHttp1_1;

    // We need a few more pieces of information before we
    // can call UrlCommitFile: 
    // 1) cache entry type 
    // 2) whether the item is a static image or not
    // 3) header info
    // 4) The time at which the cache file is created
    // Let's grab them now!

    dwCacheEntryType = 0;

    if (!fNormal)
    {
        if (!IsPartialResponseCacheable())
        {
            DEBUG_PRINT(CACHE, INFO, ("Partial response not cacheable, downloaded will be aborted\n"));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
        else
        {
            DEBUG_PRINT(CACHE, INFO, ("Partial response will be cached\n"));
            dwCacheEntryType |= SPARSE_CACHE_ENTRY;
            fNormal = TRUE;
        }
            
    }

    if (fNormal)
    {
        // 1) Grab cache entry type information
        if (_dwCacheFlags & CACHE_FLAG_MAKE_PERSISTENT)
            dwCacheEntryType |= STICKY_CACHE_ENTRY;

        if (InternalIsResponseHttp1_1(_hRequest) == TRUE)
        {
            dwCacheEntryType |= HTTP_1_1_CACHE_ENTRY;
            if (_fMustRevalidate == TRUE)
                dwCacheEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
        }

        // 2) Is it an image?
        fImage = IsStaticImage();

        // 3) Grab the header info
        if (!ExtractHeadersForCacheCommit(szHeaderInfo, &dwHeaderLen))
        {
            DEBUG_PRINT(CACHE, INFO, ("ExtractHeadersForCacheCommit failed\n"));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    // 4) Get filetime for the cache file, and close the file handle
    // that we first opened to write the content into
    INET_ASSERT(_hCacheWriteFile != INVALID_HANDLE_VALUE);
    GetFileTime( _hCacheWriteFile, &ftCreate, NULL, NULL );

    CalculateTimeStampsForCache();
    
    CloseHandle(_hCacheWriteFile);
    _hCacheWriteFile = INVALID_HANDLE_VALUE;
    
    DEBUG_PRINT(CACHE,
                INFO,
                ("Cache write EntryType = %x\r\n",
                dwCacheEntryType
                ));

    // Now do the real thing
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl = GetUrl();
    Args.pszFilePath = _lpszCacheWriteLocalFilename;
    Args.dwFileSize = _RealCacheFileSize;
    Args.qwExpires = *((LONGLONG *) &_ftExpiryTime);
    Args.qwLastMod = *((LONGLONG *) &_ftLastModTime);
    Args.qwPostCheck = *((LONGLONG *) &_ftPostCheckTime);
    Args.ftCreate = ftCreate;
    Args.dwEntryType = dwCacheEntryType;
    Args.pbHeaders = szHeaderInfo;
    Args.cbHeaders = dwHeaderLen;
    Args.pszFileExt = _lpszFileExtension;
    Args.pszRedirect = NULL;      // BUGBUG should we pass in GetUrl() instead?
    Args.fImage = fImage;
    Args.dwIdentity = 0;
            
    dwError = UrlCacheCommitFile(&Args);

    if (dwError != ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE, ERROR,
                      ("CommitUrlCacheEntry(%q) failed\n",
                      _lpszCacheWriteLocalFilename
                     ));
        
        if (dwError == ERROR_SHARING_VIOLATION) 
        {
            // we got new URL data, but the old one is in use.
            // expire it, so any new user's will go to the net
            // ExpireUrl();
        }

        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    DEBUG_LEAVE(TRUE);
    return TRUE;
}


PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::SetFilenameAndExtForCacheWrite()
/*
Routine Description:

    This function attempts to find out the filename and extension for the resource to be
    cached by querying the appropriate HTTP headers.  
    It is possible that EITHER filename or extension will by NULL, but they will NEVER
    be both NULL.  

    Adopt from HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite from Wininet

    TODO: content-length ??

Side effects:

    LPSTR _lpszFileName 
    LPSTR _lpszFileExtension

    These variables will be set.  These variables are needed
    1) when first creating a file for cache write
    2) when the file is committed to the cache
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::SetFilenameAndExtForCacheWrite",
                 NULL
                 ));

    BOOL fResult = FALSE;
    TCHAR cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    TCHAR szFileName[MAX_PATH];
    const TCHAR szDefaultExtension[] = "txt";
    
    DWORD dwLen, cbFileName, dwIndex;
    BOOL fIsUncertainMime = FALSE;

    TCHAR szBuf[256];
    LPSTR ptr, pToken;

    // If the content-disposition header is available, then parse out any filename and use it
    // From RFC2616: The Content-Disposition response-header field has been proposed as a means for 
    // the origin server to suggest a default filename if the user requests that the content is saved to a file.
    if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_DISPOSITION, NULL, 
                            szBuf, &(dwLen = sizeof(szBuf)), &dwIndex))
    {
        // Could have multiple tokens in the Content-Disposition header. Scan for the "filename" token.
        ptr = pToken = szBuf;
        while (ptr = StrTokExA(&pToken, ";"))
        {
            // Skip any leading ws in token.
            SKIPWS(ptr);

            // Compare against "filename".
            if (!strnicmp(ptr, FILENAME_SZ, FILENAME_LEN))
            {
                // Found it.
                ptr += FILENAME_LEN;

                // Skip ws before '='.
                SKIPWS(ptr);

                // Must have '='
                if (*ptr == '=')
                {
                    // Skip any ws after '=' and point
                    // to beginning of the file name
                    ptr++;
                    SKIPWS(ptr);

                    // Skip past any quotes
                    if (*ptr == '\"')
                        ptr++;

                    SKIPWS(ptr);

                    cbFileName = strlen(ptr);

                    if (cbFileName)
                    {
                        // Ignore any trailing quote.
                        if (ptr[cbFileName-1] == '\"')
                            cbFileName--;
                            
                        memcpy(szFileName, ptr, cbFileName);
                        szFileName[cbFileName] = '\0';
                        _lpszFileName = NewString(szFileName, MAX_PATH);
                    }
                }
                break;
            }
        }
    }

    // Either no Content-disposition header or filename not parsed, so try to figure out
    // the file extension using the Content-Type header
    if (!_lpszFileName)
    {
        DWORD dwMimeLen = sizeof(szBuf);
        if ((HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_ENCODING, NULL,
            szBuf, &dwMimeLen, 0)) && StrCmpNI(szBuf,"binary",6) )
        {
            // if there is content encoding, we should not use
            // content-type for file extension

            //Modifying this for bug 98611.
            //For 'binary' encoding use the Content-Type to find extension
            _lpszFileExtension = NULL;
        }

        else if (HttpQueryInfoA(_hRequest, HTTP_QUERY_CONTENT_TYPE, NULL,
                szBuf, &(dwMimeLen = sizeof(szBuf)), 0))
        {
            dwLen = sizeof(cExt);
            fIsUncertainMime = strnicmp(szBuf, "text/plain", dwMimeLen)==0;

            if (!fIsUncertainMime &&
                GetFileExtensionFromMimeType(szBuf, dwMimeLen, cExt, &dwLen))
            {
                // get past the '.' because the cache expects it that way
                _lpszFileExtension = NewString(&cExt[1], DEFAULT_MAX_EXTENSION_LENGTH);
            }
        }

        //
        // if we couldn't get the MIME type or failed to map it then try to get
        // the file extension from the object name requested
        //

        if (_lpszFileExtension == NULL)
        {
            dwLen = DEFAULT_MAX_EXTENSION_LENGTH + 1;
            LPSTR lpszExt;
            lpszExt = GetFileExtensionFromUrl(GetUrl(), &dwLen);
            if (_lpszFileExtension != NULL)
            {
                _lpszFileExtension = NewString(lpszExt, dwLen);
                _lpszFileExtension[dwLen] = '\0';
            }
        }

        if ((_lpszFileExtension == NULL) && fIsUncertainMime)
        {
            INET_ASSERT(sizeof(szDefaultExtension) < DEFAULT_MAX_EXTENSION_LENGTH);

            _lpszFileExtension = NewString(szDefaultExtension, sizeof(szDefaultExtension));
        }
    }

    DEBUG_PRINT(CACHE, INFO, ("Filename = %s, File extension = %s\n", _lpszFileName, _lpszFileExtension));
    DEBUG_LEAVE(NULL);    
}


PRIVATE BOOL
HTTPCACHE_REQUEST::CreateCacheWriteFile()
/*++

Routine Description:

    Create a file for subsequent cache writes to write the data to

    Similar to INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheWrite
    in wininet

Pre-condition: 

    SetFilenameAndExtForCacheWrite() has been called

Side Effects: 

    _lpszCacheWriteLocalFilename will contain the full path of the file at 
    which the cache contents will be written to

    _hCacheWriteFile will contain the handle to the cache write file

Return Value:

    BOOL indicating whether the call succeeds or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CreateCacheWriteFile",
                 NULL
                 ));

    TCHAR szFileName[MAX_PATH];
    BOOL fResult = FALSE;
    
    // NOTE:  We are not making use of _lpszFileName from the
    // previous call to SetFilenameAndExtForCacheWrite()...
    // Possibly a bug??
    if (!CreateUrlCacheEntryA(GetUrl(), 0, _lpszFileExtension, 
                             szFileName, 0))
    {
        DEBUG_PRINT(CACHE, 
                      ERROR, 
                      ("Error:  CreateUrlCacheEntry failed for %s\n",
                      GetUrl()));
        goto quit;
    }
    else
    {
        DEBUG_PRINT(CACHE, INFO, ("Cache filename = %q\n", szFileName));
    }

    // monkey around with the local filename (szFileName)
    _hCacheWriteFile = CreateFile(szFileName, 
                              GENERIC_WRITE, 
                              0, 
                              NULL, 
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);
    if (_hCacheWriteFile == INVALID_HANDLE_VALUE) 
    {
        DEBUG_PRINT (CACHE, INFO, ("CreateFile API failed %x\n", GetLastError()));
        if( _hCacheWriteFile != INVALID_HANDLE_VALUE ) 
        {
            CloseHandle(_hCacheWriteFile);
            _hCacheWriteFile = INVALID_HANDLE_VALUE;
        }

        DeleteFile(szFileName);
        goto quit;
    }

    INET_ASSERT(_lpszCacheWriteLocalFilename == NULL);
    _lpszCacheWriteLocalFilename = NewString(szFileName);

    if (!_lpszCacheWriteLocalFilename) 
    {
        if (_lpszCacheWriteLocalFilename != NULL) 
        {
            (void)FREE_MEMORY((HLOCAL)_lpszCacheWriteLocalFilename);
            _lpszCacheWriteLocalFilename = NULL;

            DeleteFile(szFileName);
        }
    }

    INET_ASSERT(_hCacheWriteFile != INVALID_HANDLE_VALUE);
    fResult = TRUE;
    
quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL
HTTPCACHE_REQUEST::WriteToCacheFile(
    LPBYTE lpBuffer, 
    DWORD dwBufferLen, 
    LPDWORD lpdwBytesWritten
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::WriteToCacheFile",
                 "%d",
                 dwBufferLen
                 ));

    BOOL fResult;
    fResult =  WriteFile(_hCacheWriteFile,
                     lpBuffer,
                     dwBufferLen,
                     lpdwBytesWritten,
                     NULL );
    
    _RealCacheFileSize += *lpdwBytesWritten;
    
    DEBUG_PRINT(CACHE, 
                 INFO, 
                 ("%d bytes written to the cache file %s", 
                 *lpdwBytesWritten, 
                 _lpszCacheWriteLocalFilename));

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL
HTTPCACHE_REQUEST::FCanWriteHTTP1_1ResponseToCache(
    BOOL * fNoCache
    )
/*
Routine Description:

    Examine the cache-control headers and MIME exclusion list 
    to see if the given resource can be written to cache storage

    Similar to HTTP_REQUEST_HANDLE_OBJECT::FCanWiteToCache in Wininet

Precondition: 

    The resource comes from a HTTP 1.1 server

Side Effects:

    NONE
    
Parameters:

    fNoCache - indicate whether the cache entry must not be remained from the cache 
               because the response contains certain explicitly/implicitly HTTP headers 
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::FCanWriteHTTP1_1ResponseToCache",
                 NULL
                 ));
        
    BOOL ok = FALSE;
    BOOL fVary = FALSE;
    
    *fNoCache = FALSE;     // Set fNoCache if there is pragma: no-cache

    DWORD index;
    TCHAR szBuf[1024];
    DWORD dwBufLen = sizeof(szBuf);

    //
    // Also set fNoCache if there is Cache-Control: no-cache or no-store header,
    // if there is a Cache-Control: private header and we're *not* on NT with user profiles,
    // or any Vary: headers. These are only checked for HTTP 1.1 servers.
    //
    CHAR *ptr, *pToken;
    index = 0;

    // Scan for Cache-Control header.
    dwBufLen = sizeof(szBuf);
    while (HttpQueryInfoA(_hRequest,
                          WINHTTP_QUERY_CACHE_CONTROL,
                          NULL,
                          szBuf,
                          &dwBufLen,
                          &index))
    {
        // Check for no-cache or no-store or private.
        CHAR chTemp = szBuf[dwBufLen];

        szBuf[dwBufLen] = '\0';
        pToken = ptr = szBuf;
        // Parse a token from the string; test for sub headers.
        while (*pToken != '\0')
        {
            SKIPWS(pToken);

            // no-cache, no-store.
            if (strnicmp(NO_CACHE_SZ, pToken, NO_CACHE_LEN) == 0)
            {
                *fNoCache = TRUE;
                break;
            }

            if( strnicmp(NO_STORE_SZ, pToken, NO_STORE_LEN) == 0) 
            {
                *fNoCache = TRUE;
            }

            // The PRIVATE_SZ tag should be handled one level higher
            // private.
            // if (strnicmp(PRIVATE_SZ, pToken, PRIVATE_LEN) == 0)
            // {
            //     SetPerUserItem(TRUE);
            // }

            while (*pToken != '\0')
            {
                if ( *pToken == ',')
                {
                    pToken++;
                    break;
                }

                pToken++;
            }

        } // while (*pToken != '\0')

        // We've finished parsing it, now return our terminator back to its proper place
        szBuf[dwBufLen] = chTemp;

        // If fNoCache, we're done. Break out of switch.
        if (*fNoCache)
            break;

        index++;

    } // while FastQueryResponseHeader == ERROR_SUCCESS

    // Finally, check if any Vary: headers exist, EXCEPT "Vary: User-Agent"
    dwBufLen = sizeof(szBuf);
    if (HttpQueryInfoA(_hRequest,
                      HTTP_QUERY_VARY,
                      NULL,
                      szBuf,
                      &dwBufLen,
                      NULL) == TRUE       
       && !(dwBufLen == USER_AGENT_LEN && !strnicmp (szBuf, USER_AGENT_SZ, dwBufLen)) )
    {
        fVary = TRUE;
        goto quit;
    }

    DWORD StatusCode;
    DWORD dwSize = sizeof(DWORD);
    // accept HTTP/1.0 or downlevel server responses
    if (HttpQueryInfoA(_hRequest,
                      WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                      NULL,
                      &StatusCode,
                      &dwSize,
                      NULL)) 
    {
        if (StatusCode == HTTP_STATUS_OK || StatusCode == 0)
        {
            dwBufLen = sizeof(szBuf);
            if (HttpQueryInfoA(_hRequest,
                              WINHTTP_QUERY_CONTENT_TYPE,
                              NULL,
                              szBuf,
                              &dwBufLen,
                              NULL)) 
            {
                if (::FExcludedMimeType(szBuf, dwBufLen))
                {
                    ok = FALSE;
                    DEBUG_PRINT(CACHE, 
                                 INFO, 
                                 ("%s Mime Excluded from caching\n",
                                 szBuf
                                 ));
                    goto quit;
                }
            }

            // BUGBUGBUG:  What are we going to do with the Vary header???????
            ok = TRUE;
            goto quit;
        }
    }
    
quit:
    DEBUG_LEAVE(ok);
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\partial.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    partial.cxx

Abstract:

    Routines for manipulating partial cache entries

Author:

Revision History:

--*/

#include <wininetp.h>
#include <string.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "..\http\proc.h"
#include "internalapi.hxx"

PRIVATE VOID HTTPCACHE_REQUEST::DeletePartialCacheFile(VOID)
{
    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // We can't use the partial cache entry because it is
        // stale, so delete the data file we got from cache.
        if (_hSparseFileReadHandle != INVALID_HANDLE_VALUE)
            CloseHandle(_hSparseFileReadHandle);
        _hSparseFileReadHandle = INVALID_HANDLE_VALUE;

        DeleteFile(_pCacheEntryInfo->lpszLocalFileName);
    }
}
PRIVATE BOOL HTTPCACHE_REQUEST::IsPartialCacheEntry(VOID)
// Given an entry in the cache, is the cache entry a partial cache entry
// Side effect: _fIsPartialCache;
// Precondition:  CheckIfInCache() returns TRUE
{
    INET_ASSERT(_pCacheEntryInfo != NULL);
    
    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
        _fIsPartialCache = TRUE;
    else
        _fIsPartialCache = FALSE;
    
    return _fIsPartialCache;
}

PRIVATE VOID HTTPCACHE_REQUEST::LockPartialCacheEntry(VOID)
// Side effect: The file pointer of the cache entry got moved to the last byte
// _fIsPartialCache may change status if the file seems corrupted
{
    INET_ASSERT(_fIsPartialCache == TRUE);
    
    // open the file so it can't be deleted
    _hSparseFileReadHandle = CreateFile(_pCacheEntryInfo->lpszLocalFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

     // Check the file size
    if (_hSparseFileReadHandle == INVALID_HANDLE_VALUE || 
       (SetFilePointer (_hSparseFileReadHandle, 0, NULL, FILE_END) 
        != _pCacheEntryInfo->dwSizeLow))
    {
        CloseHandle(_hSparseFileReadHandle);
        _fIsPartialCache = FALSE;
    }
}

// What are we doing here?
// Three things
// 1.  We have a partial cache entry for this URL.  No need to check
//     for expiry or correct user.  Add a Range: header to get the
//     rest of the data.
// 
// 2.  If there was Last-Modified-Time, add Unless-Modified-Since header,
//     which assures coherency in the event the URL data changed since
//     the partial download.
//
// 3.  If the entry has a 1.1 ETag, add the If-Range header.
//
PRIVATE BOOL HTTPCACHE_REQUEST::AddRangeRequestHeaders()
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::AddRangeRequestHeaders",
                 NULL));

    INET_ASSERT(_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY);

    TCHAR szBuf[64+HTTP_RANGE_LEN];
    TCHAR szBuf2[64+HTTP_UMS_LEN];
  
    DWORD cbBuf = wsprintf (szBuf, "%s: bytes=%d-", HTTP_RANGE_SZ, _pCacheEntryInfo->dwSizeLow);
    DWORD cbBuf2;
    BOOL fResult = FALSE;
    
    if (!HttpAddRequestHeadersA(_hRequest,
                                szBuf,
                                cbBuf,
                                ADD_HEADER))
        goto quit;

    if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
    {
        cbBuf = sizeof(szBuf);
        FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime),
                                szBuf, &cbBuf);
        cbBuf2 = wsprintf(szBuf2, "%s: %s", HTTP_UMS_SZ, szBuf);
        if (!HttpAddRequestHeadersA(_hRequest,
                                    szBuf2, 
                                    cbBuf2, 
                                    ADD_HEADER))
        goto quit;
    }

    // Only HTTP 1.1 support the ETag header
    if (!(_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
    {
        fResult = TRUE;
    }
    else
    {
        // Look for the ETag header
        TCHAR szOutBuf[256];
        TCHAR szHeader[256 + HTTP_IF_RANGE_LEN];
        DWORD dwOutBufLen = 256;
        DWORD dwHeaderLen;
        
        // If the ETag header is present, then add the "if-range: <etag>" header
        if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ETAG, NULL, szOutBuf, &dwOutBufLen, NULL))
        {
            dwHeaderLen = wsprintf(szHeader, "%s %s", HTTP_IF_NONE_MATCH_SZ, szOutBuf);

            fResult = HttpAddRequestHeadersA(_hRequest, 
                                              szHeader, 
                                              dwHeaderLen, 
                                              WINHTTP_ADDREQ_FLAG_ADD_IF_NEW);
        }
    }

quit:
    if ((fResult == TRUE) || 
        (fResult == FALSE && GetLastError() == ERROR_WINHTTP_HEADER_ALREADY_EXISTS)) 
        fResult = TRUE;

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::IsPartialResponseCacheable(VOID)
/*++

Routine Description:

    The transfer of the content of the HTTP response has been 
    interrupted.  This call finds out if the currently (incomplete)
    content can be commited to the cache.  

    The main criteria for this decision is whether the HTTP server
    from which the request was originated can handle range
    request.  If the server returns a "Accept-ranges" header, then
    the content is cacheable.

Arguments:

    None.

Return Value:

    BOOL

--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::IsPartialResponseCacheable",
                 NULL));

    TCHAR szHeader[256];
    DWORD dwSize = 256;

    DWORD dwIndex;
    BOOL fRet = FALSE;
    DWORD dwErr;

// Until chunked transfer has been implemented, we don't care
// about this bit of code
/*
    if (_RealCacheFileSize >= _ContentLength)
    {
        // We don't handle chunked transfer upon resuming a partial
        // download, so we require a Content-Length header.  Also,
        // if download file is actually complete, yet not committed
        // to cache (possibly because the client didn't read to eof)
        // then we don't want to save a partial download.  Otherwise
        // we might later start a range request for the file starting
        // one byte beyond eof.  MS Proxy 1.0 will return an invalid
        // 206 response containing the last byte of the file.  Other
        // servers or proxies that follow the latest http spec might
        // return a 416 response which is equally useless to us.
        
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }
*/
    // For HTTP/1.0, must have last-modified time, otherwise we
    // don't have a way to tell if the partial downloads are coherent.
    if (!InternalIsResponseHttp1_1(_hRequest) && (FT2LL(_ftLastModTime) == 0))
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    // First check if there's a Content-Range header from the response
    // headers.  
    if (!HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_RANGE, NULL, szHeader, &dwSize, NULL))    
    {
        // We didn't get a Content-Range header which implies the server
        // supports byte range for this URL, so we must look for the
        // explicit invitation of "Accept-Ranges: bytes" response header.
        dwSize = 256;
        dwIndex = 0;
        if (!HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ACCEPT_RANGES, NULL, szHeader, &dwSize, &dwIndex)
           || !(dwSize == sizeof(BYTES_SZ) - 1 && !strnicmp(szHeader, BYTES_SZ, dwSize)))
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    dwSize = 256;
    if (!InternalIsResponseHttp1_1(_hRequest))
    {
        // For HTTP/1.0, only cache responses from Server: Microsoft-???/*
        // Microsoft-PWS-95/*.* will respond with a single range but
        // with incorrect Content-Length and Content-Range headers.
        // Other 1.0 servers may return single range in multipart response.

        const static char szPrefix[] = "Microsoft-";
        const static DWORD ibSlashOffset = sizeof(szPrefix)-1 + 3;

        if (!HttpQueryInfoA(_hRequest, HTTP_QUERY_SERVER, NULL, szHeader, &dwSize, 0)
            || dwSize <= ibSlashOffset
            || szHeader[ibSlashOffset] != '/'
            || memcmp(szHeader, szPrefix, sizeof(szPrefix) - 1)
           )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }
    else // if (IsResponseHttp1_1())
    {
        // For http 1.1, must have strong etag.  A weak etag starts with
        // a character other than a quote mark and cannot be used as a 
        // coherency validator.  IIS returns a weak etag when content is
        // modified within a single file system time quantum.        
        if (!HttpQueryInfoA(_hRequest, HTTP_QUERY_ETAG, NULL, szHeader, &dwSize, 0)
            || szHeader[0] != '\"')
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    fRet = TRUE;

quit:

    DEBUG_LEAVE(fRet);
    return fRet;
 }


PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::FakePartialCacheResponseHeaders(VOID)
/*++

Routine Description:

    Resume partial download.
    First thing we do here is we verify the Content-Range header is
    a valid one, and then parse it to get the numerical range values

    After that's verified, the second thing we do is we fake the 
    response headers.  The intent is to fix up the response headers 
    to appear same as a 200 response so that the partial caching 
    becomes completely invisible to the user app
    
Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::FakePartialCacheResponseHeaders",
                 NULL));

    TCHAR szBuffer[256];
    DWORD dwBufferLength = sizeof(szBuffer);
    DWORD dwIndex = 0;
    TCHAR szTempBuf[256];
    DWORD dwErr = ERROR_SUCCESS;
    
    INET_ASSERT (!_fCacheWriteInProgress);

    
    
    // Retrieve the start and end of Content-Range header
    if (!HttpQueryInfoA(_hRequest,
                       HTTP_QUERY_CONTENT_RANGE,
                       NULL,
                       szBuffer, 
                       &dwBufferLength,
                       &dwIndex))
    {
        goto quit;
    }

    INET_ASSERT (szBuffer);

    PSTR pszLimit;
    LPSTR pszHeader;
    DWORD cbHeader;

    pszHeader = szBuffer;
    pszLimit = szBuffer + dwBufferLength;
    INET_ASSERT (pszLimit);
    *pszLimit = 0;

    // Extract the document length as a string and number.
    // The http 1.1 spec is very explicit that we MUST parse
    // the header and return an error if invalid.  We expect
    // it to be of the form Content-Range: bytes xxx-yyy/zzz.
    PSTR pszStart, pszEnd, pszLength;
    DWORD dwStart, dwEnd, dwLength;

    // Ensure that value is prefixed with "bytes"
    PSTR pszBytes = pszHeader;
    if (strnicmp (pszBytes, BYTES_SZ, sizeof(BYTES_SZ) - 1))
        goto quit;

    // Parse and validate start of range.
    pszStart = pszBytes + sizeof(BYTES_SZ) - 1;
    SKIPWS (pszStart);
    dwStart = StrToInt (pszStart);
    if (dwStart != _pCacheEntryInfo->dwSizeLow)
        goto quit;

    // Parse and validate end of range.
    pszEnd = StrChr (pszStart, '-');
    if (!pszEnd++)
        goto quit;
    dwEnd = StrToInt (pszEnd);
    if (dwStart > dwEnd)
        goto quit;

    // Parse and validate length.
    pszLength = StrChr (pszEnd, '/');
    if (!pszLength)
        goto quit;
    pszLength++;
    dwLength = StrToInt (pszLength);
    if (dwEnd + 1 != dwLength)
        goto quit;


    //  Which headers are we exactly changing here?
    //  1.  Change the content-length header to reflect the length of
    //      the total amount of data, not just the partial content.
    //  2.  Add an implicit "Accept-Ranges: bytes" header
    //  3.  Change the status code from 206 to 200
    //  4.  Remove the "Content-Range" header

    // Step 1:  Modify the content-length header
    wsprintf (szTempBuf, "%d", dwLength);
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_CONTENT_LENGTH, 
                                szTempBuf, 
                                strlen(szTempBuf), 
                                0, 
                                WINHTTP_ADDREQ_FLAG_REPLACE);
    
    /// _pRequest->SetContentLength(dwLength);   // why do we need to do this????
    INET_ASSERT(dwErr == ERROR_SUCCESS);
    
    // Step 2: Some servers omit "Accept-Ranges: bytes" since it is implicit
    // in a 206 response.  This is important to Adobe Amber ActiveX
    // control and other clients that may issue their own range
    // requests. Add the header if not present.
    if (!InternalIsResponseHeaderPresent(_hRequest, HTTP_QUERY_ACCEPT_RANGES))
    {
        const static char szAccept[] = "bytes";
        dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_ACCEPT_RANGES, 
                                (LPSTR) szAccept, 
                                sizeof(szAccept)-1, 
                                0, 
                                ADD_HEADER);
        INET_ASSERT (dwErr == ERROR_SUCCESS);
    }    

    // Step 3: Fake the status code
    
    /*  this code is replaced by the call to ReplaceStatusHeader()
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_STATUS_TEXT,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);

    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_STATUS_CODE,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);
    
    INET_ASSERT(dwErr == ERROR_SUCCESS);
    */

   BOOL bOK;
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->ReplaceStatusHeader("200 OK");
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->SetStatusCode(200);
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->UpdateResponseHeaders(&bOK);  //BUGBUG do we need this?

    // Step 4: Remove the Content-Range header.  We'll just hope that this
    // operation really works.  (no Error code is returned by the caller)
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_CONTENT_RANGE,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);    

    // Adjust the file size
    _VirtualCacheFileSize = dwStart;
    _RealCacheFileSize    = dwStart;
    DEBUG_LEAVE (dwErr);
    return TRUE;
    
quit:
    DEBUG_LEAVE (dwErr);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\cookie.h ===
// cookie.h - header for external cookie funcs code.

class CCookieJar;

CCookieJar * CreateCookieJar();
void CloseCookieJar(CCookieJar * CookieJar);

#ifndef WININET_SERVER_CORE
void PurgeCookieJar();
#endif

#define COOKIE_SECURE   INTERNET_COOKIE_IS_SECURE
#define COOKIE_SESSION  INTERNET_COOKIE_IS_SESSION // never saved to disk
#define COOKIE_NOUI     4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\idl\httprequestid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 2000                    **
//*********************************************************************


//;begin_internal
#ifndef __HTTPREQUESTID_H__
#define __HTTPREQUESTID_H__
//;end_internal

#define DISPID_HTTPREQUEST_BASE                     0x00000001


#define DISPID_HTTPREQUEST_OPEN                     (DISPID_HTTPREQUEST_BASE)
#define DISPID_HTTPREQUEST_SETREQUESTHEADER         (DISPID_HTTPREQUEST_BASE + 1)
#define DISPID_HTTPREQUEST_GETRESPONSEHEADER        (DISPID_HTTPREQUEST_BASE + 2)
#define DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS    (DISPID_HTTPREQUEST_BASE + 3)
#define DISPID_HTTPREQUEST_SEND                     (DISPID_HTTPREQUEST_BASE + 4)
#define DISPID_HTTPREQUEST_OPTION                   (DISPID_HTTPREQUEST_BASE + 5)
#define DISPID_HTTPREQUEST_STATUS                   (DISPID_HTTPREQUEST_BASE + 6)
#define DISPID_HTTPREQUEST_STATUSTEXT               (DISPID_HTTPREQUEST_BASE + 7)
#define DISPID_HTTPREQUEST_RESPONSETEXT             (DISPID_HTTPREQUEST_BASE + 8)
#define DISPID_HTTPREQUEST_RESPONSEBODY             (DISPID_HTTPREQUEST_BASE + 9)
#define DISPID_HTTPREQUEST_RESPONSESTREAM           (DISPID_HTTPREQUEST_BASE + 10)
#define DISPID_HTTPREQUEST_ABORT                    (DISPID_HTTPREQUEST_BASE + 11)
#define DISPID_HTTPREQUEST_SETPROXY                 (DISPID_HTTPREQUEST_BASE + 12)
#define DISPID_HTTPREQUEST_SETCREDENTIALS           (DISPID_HTTPREQUEST_BASE + 13)
#define DISPID_HTTPREQUEST_WAITFORRESPONSE          (DISPID_HTTPREQUEST_BASE + 14)
#define DISPID_HTTPREQUEST_SETTIMEOUTS              (DISPID_HTTPREQUEST_BASE + 15)

//;begin_internal
#endif // __HTTPREQUESTID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\ansi.h ===
#if defined(_WIN64)
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct {
    DWORD   dwOption;            // option to be queried or set
    union {
        DWORD    dwValue;        // dword value for the option
        LPSTR    pszValue;       // pointer to string value for the option
        FILETIME ftValue;        // file-time value for the option
    } Value;
} INTERNET_PER_CONN_OPTIONA, * LPINTERNET_PER_CONN_OPTIONA;
typedef INTERNET_PER_CONN_OPTIONA INTERNET_PER_CONN_OPTION;
typedef LPINTERNET_PER_CONN_OPTIONA LPINTERNET_PER_CONN_OPTION;

typedef struct {
    DWORD   dwSize;             // size of the INTERNET_PER_CONN_OPTION_LIST struct
    LPSTR   pszConnection;      // connection name to set/query options
    DWORD   dwOptionCount;      // number of options to set/query
    DWORD   dwOptionError;      // on error, which option failed
    LPINTERNET_PER_CONN_OPTIONA  pOptions;
                                // array of options to set/query
} INTERNET_PER_CONN_OPTION_LISTA, * LPINTERNET_PER_CONN_OPTION_LISTA;
typedef INTERNET_PER_CONN_OPTION_LISTA INTERNET_PER_CONN_OPTION_LIST;
typedef LPINTERNET_PER_CONN_OPTION_LISTA LPINTERNET_PER_CONN_OPTION_LIST;

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSA, * LPURL_COMPONENTSA;
typedef URL_COMPONENTSA URL_COMPONENTS;
typedef LPURL_COMPONENTSA LPURL_COMPONENTS;

typedef struct _INTERNET_BUFFERSA {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSA * Next;   // chain of buffers
    LPCSTR   lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERSA, * LPINTERNET_BUFFERSA;
typedef INTERNET_BUFFERSA INTERNET_BUFFERS;
typedef LPINTERNET_BUFFERSA LPINTERNET_BUFFERS;

BOOLAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPSTR lpszTime          // output string buffer
    );
#define InternetTimeFromSystemTime  InternetTimeFromSystemTimeA

BOOLAPI
InternetTimeToSystemTimeA(
    IN  LPCSTR lpszTime,         // NULL terminated string
    OUT SYSTEMTIME *pst,         // output in GMT time
    IN  DWORD dwReserved
    );
#define InternetTimeToSystemTime  InternetTimeToSystemTimeA

typedef struct
{
    DWORD dwAccessType;      // see WINHTTP_ACCESS_* types below
    LPSTR lpszProxy;         // proxy server list
    LPSTR lpszProxyBypass;   // proxy bypass list
} WINHTTP_PROXY_INFOA;

typedef WINHTTP_PROXY_INFOA* LPINTERNET_PROXY_INFO;


BOOLAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );

BOOLAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
#define InternetOpen  InternetOpenA

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetConnect  InternetConnectA

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetOpenUrl  InternetOpenUrlA

INTERNETAPI
BOOL
WINAPI
InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetReadFileEx  InternetReadFileExA

INTERNETAPI
BOOL
WINAPI
InternetWriteFileExA(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSA lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetWriteFileEx  InternetWriteFileExA

BOOLAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#define InternetQueryOption  InternetQueryOptionA

BOOLAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
#define InternetSetOption  InternetSetOptionA

BOOLAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA

INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback
    );
#define InternetSetStatusCallback  InternetSetStatusCallbackA

BOOLAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
#define HttpAddRequestHeaders  HttpAddRequestHeadersA

#define HTTP_VERSIONA           "HTTP/1.0"
#define HTTP_VERSION            HTTP_VERSIONA

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define HttpOpenRequest  HttpOpenRequestA

BOOLAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#define HttpSendRequest  HttpSendRequestA

BOOLAPI WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
   
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    );
#define HttpSetCredentials  HttpSetCredentialsA

INTERNETAPI
BOOL
WINAPI
HttpSendRequestExA(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define HttpSendRequestEx  HttpSendRequestExA

BOOLAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCSTR      lpszName OPTIONAL,
    IN OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
#define HttpQueryInfo  HttpQueryInfoA

#if defined(__cplusplus)
} // end extern "C" {
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\constant.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    constant.h

Abstract:

    Contains all internal constant values used in INTERNET.DLL

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// manifests
//

#define K       * 1024
#define M       * 1048576
#define _1K     (1 K)
#define _2K     (2 K)
#define _4K     (4 K)
#define _8K     (8 K)
#define _16K    (16 K)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#include "iert.h"
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)

 
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\httpcache\test\testhttpcache.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
// 
// Test driver for the WinHTTP-UrlCache interaction layer
//

#include <windows.h>
#include <winhttp.h>
#include <internal.h>
#include <conio.h>
#include <stdio.h>
#include <tchar.h>
#include <fstream.h>
#include <stdlib.h>

//////////////////////////////////////////////////////////////////////////////////////////////////

// Globals
wchar_t g_wszHost[50];
wchar_t g_wszPath[50];
DWORD g_dwTotalRequests;
DWORD g_dwNumConnections;

// Hard-coded #define
//#define HOSTNAME L"t-eddieng"
//#define HOSTNAME "www.w3.org"
//#define HOSTNAME "msw"
LPCWSTR szObjectName[] = { L"/?action=a", 
                             L"default.asp", 
                             L"/", 
                             L"/default.asp", 
                             L"/?action=a", 
                             L"/?action=b", 
                             L"/default.asp?action=a", 
                             L"/?action=a" 
                           };

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
#if 0
void TestCase1() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<1; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[i], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }

    
    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
            else
                printf("%s", pszOutBuffer);
        
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;
    if (WinHttpQueryOption( hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}




//////////////////////////////////////////////////////////////////////////////////////////////////
//
// TestCase2 - weird case (call QueryDataAvailable before ReceiveResponse)
//
// Get from network all the time
//
void TestCase2() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<4; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[0], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }


    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    // TEST CASE:  Calling WinHttpQueryOption and WinHttpQueryHeaders before WinHttpReceiveResponse
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;

/*
    if (WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        


    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_LAST_MODIFIED, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns last_modified = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());
    
    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns content length = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());
*/
    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
        {
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
            goto done;
        }
            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
        
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestCase3() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<1; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[i], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }


    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    // TEST CASE:  Calling WinHttpQueryOption and WinHttpQueryHeaders before WinHttpReceiveResponse
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;

    if (WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns URL - dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_EXPIRES, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns expires = %S\n", wszOptionData);
    else
        printf ("Error %u in expires.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_LAST_MODIFIED, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns last_modified = %S\n", wszOptionData);
    else
        printf ("Error %u in last-modified.\n", GetLastError());


    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_IF_MATCH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns if-match = %S\n", wszOptionData);
    else
        printf ("Error %u in If-match.\n", GetLastError());
    
    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns content length = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
        {
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
            goto done;
        }

        // Allocate space for the buffer.
        pszOutBuffer = new char[dwSize+1];
        ZeroMemory(pszOutBuffer, dwSize+1);

        // Read the Data.
        if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
        {    
            printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
            goto done;
        }
        else
            printf("%s", pszOutBuffer);
        
        // Free the memory allocated to the buffer.
        delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Test multiple open connect handles and open request handles synchronously
//
void TestCase4(DWORD dwNumOfConnect, DWORD dwNumOfRequest) {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[dwNumOfConnect];
    hRequest = new HINTERNET[dwNumOfRequest];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<dwNumOfConnect; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<dwNumOfRequest; i++)
    {
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", szObjectName[0], NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

    }

done:
    for (DWORD i=0; i<dwNumOfRequest; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;

    for (DWORD i=0; i<dwNumOfConnect; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;

    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestFullRead() {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[g_dwNumConnections];
    hRequest = new HINTERNET[g_dwTotalRequests];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Agent", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<g_dwNumConnections; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, g_wszHost, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<g_dwTotalRequests; i++)
    {
        printf ("Interation %d in request loop.\n\n", i);
        
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", g_wszPath, NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

        WCHAR wszOptionData[2048];
        dwSize = 2048;
        if (WinHttpQueryHeaders(hRequest[i], WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
            printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
        else
            printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

        // Keep checking for data until there is nothing left.
        do 
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpCacheQueryDataAvailable( hRequest[i], &dwSize))
            {
                printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
                goto done;
            }

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest[i], (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
            
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
        } while (dwSize>0);

    }

done:
    for (DWORD i=0; i<g_dwTotalRequests; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;
    
    for (DWORD i=0; i<g_dwNumConnections; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;
    
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}




//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestPartialRead() {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[g_dwNumConnections];
    hRequest = new HINTERNET[g_dwTotalRequests];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Agent", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<g_dwNumConnections; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, g_wszHost, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<g_dwTotalRequests; i++)
    {
        printf ("Interation %d in request loop.\n\n", i);
        
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", g_wszPath, NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

        WCHAR wszOptionData[2048];
        dwSize = 2048;
        if (WinHttpQueryHeaders(hRequest[i], WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
            printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
        else
            printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

        // DON'T Keep checking for data until there is nothing left.

            // Check for available data.
            dwSize = 0;
            if (!WinHttpCacheQueryDataAvailable( hRequest[i], &dwSize))
            {
                printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
                goto done;
            }

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest[i], (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
            
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;

    }

done:
    for (DWORD i=0; i<g_dwTotalRequests; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;
    
    for (DWORD i=0; i<g_dwNumConnections; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;
    
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}



void __cdecl main(
    int argc,
    CHAR * argv[]
    )
{
    BOOL fPartial = FALSE;
    int iArgStart = 2;
    
    if (argc == 1 || (argc >= 2 && strcmp(argv[1], "/?") == 0))
        goto syntax;

    if (strcmp(argv[1], "/P") == 0 || strcmp(argv[1], "/p") == 0)
        fPartial = TRUE;
    else if (strcmp(argv[1], "/F") == 0 || strcmp(argv[1], "/f") == 0)
        fPartial = FALSE;
    else
    {
        fPartial = FALSE;
        iArgStart = 1;
    }

    if (argc != iArgStart + 4)
    {
        printf ("Error: Invalid number of parameters\n");
        printf ("For help type %s /?\n", argv[0]);
        return;
    }
    
    g_dwTotalRequests = atoi(argv[iArgStart + 2]);
    g_dwNumConnections = atoi(argv[iArgStart + 3]);
    if (g_dwTotalRequests <= 0 || g_dwNumConnections <= 0)
    {
        printf ("Error: Number of requests and number of connections must be greater than 0\n");
        printf ("For help type %s /?\n", argv[0]);
        return;
    }
        
    MultiByteToWideChar(CP_ACP, 0, argv[iArgStart + 0], -1, g_wszHost, 50);
    MultiByteToWideChar(CP_ACP, 0, argv[iArgStart + 1], -1, g_wszPath, 50);

    if (fPartial == TRUE)
        TestPartialRead();
    else
        TestFullRead();

    return;
    
syntax:
    printf ("Test driver for the WinHTTP caching layer.\n\n");
    printf ("%s [/F | /P] ServerName ObjectName NumRequests NumConn\n\n", argv[0]);
    printf ("   /F                  Full GET request (default setting)\n");
    printf ("   /P                  Partial GET request (i.e. interrupt before the entire file is downloaded)\n");
    printf ("   ServerName\n");
    printf ("   ObjectName\n");
    printf ("   NumReqPerConn\n");
    printf ("   NumConn             URL you want to connect to, and how many loops do you want.\n");           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\debugmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.h

Abstract:

    Header for debugmem.cxx

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Revision History:

    02-Feb-1995
        Created

--*/

#ifdef WINHTTP_FOR_MSXML
#error include msxmlmem.h, not debugmem.h, for MSXML
#endif

#if defined(__cplusplus)
extern "C" {
#endif


//
// manifests
//

//
// USE_PRIVATE_HEAP_IN_RETAIL - by default we use the process heap in the retail
// build. Alternative is to use a private (wininet) heap (which we do in the
// debug version if required)
//

#if !defined(USE_PRIVATE_HEAP_IN_RETAIL)
#define USE_PRIVATE_HEAP_IN_RETAIL  0
#endif

//
// prototypes
//

VOID
InternetDebugMemInitialize(
    VOID
    );

VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    );

HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    );

SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    );

BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    );

//
// macros
//

#if defined(USE_DEBUG_MEMORY)

#define ALLOCATOR(Flags, Size) \
    InternetDebugAllocMem(Flags, Size, __FILE__, __LINE__)

#define DEALLOCATOR(hLocal) \
    InternetDebugFreeMem(hLocal, __FILE__, __LINE__)

#define REALLOCATOR(hLocal, Size, Flags) \
    InternetDebugReAllocMem(hLocal, Size, Flags, __FILE__, __LINE__)

#define MEMORYSIZER(hLocal) \
    InternetDebugSizeMem(hLocal, __FILE__, __LINE__)

#define INITIALIZE_MEMORY_MANAGER() \
    InternetDebugMemInitialize()

#define TERMINATE_MEMORY_MANAGER(bReport) \
    InternetDebugMemTerminate(bReport)

#define CHECK_MEMORY_FREED(bReport) \
    InternetDebugCheckMemFreed(bReport)

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    InternetDebugMemReport(bTermSym, bCloseFile)

#else   // retail version


#if defined(USE_ROCKALL)

extern void INITIALIZE_MEMORY_MANAGER();
extern void TERMINATE_MEMORY_MANAGER(BOOL bReport);
extern void* ALLOCATOR(int Flags, int Size);
extern void* DEALLOCATOR(void *hLocal); 
extern void* REALLOCATOR(void *hLocal, int Size, int Flags);
extern int MEMORYSIZER(void *hLocal);

#else

#define ALLOCATOR(Flags, Size) \
    LocalAlloc(Flags, Size)

#define DEALLOCATOR(hLocal) \
    LocalFree(hLocal)

#define REALLOCATOR(hLocal, Size, Flags) \
    LocalReAlloc(hLocal, Size, Flags)

#define MEMORYSIZER(hLocal) \
    LocalSize(hLocal)

#define INITIALIZE_MEMORY_MANAGER() \
    /* NOTHING */

#define TERMINATE_MEMORY_MANAGER(bReport) \
    /* NOTHING */

#endif


#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */

#endif // defined(USE_DEBUG_MEMORY)

#if defined(USE_ROCKALL)

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((void*)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((void*)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((void*)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((void*)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((void*)(hLocal))

#else

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((HLOCAL)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((HLOCAL)(hLocal))

#endif // USE_ROCKALL

#define New     new
#if defined(__cplusplus)
}
#endif

//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\ihttprequest\httprequest.cxx ===
/*
 *  HttpRequest.cpp
 *
 *  WinHttp.WinHttpRequest COM component
 *
 *  Copyright (C) 2000 Microsoft Corporation. All rights reserved. *
 *
 *  Much of this code was stolen from our Xml-Http friends over in
 *  inetcore\xml\http\xmlhttp.cxx. Thanks very much!
 *
 */
#include <wininetp.h>
#include "httprequest.hxx"
#include <olectl.h>


/////////////////////////////////////////////////////////////////////////////
// private function prototypes
static void    WideCharToUtf8(WCHAR * buffer, UINT cch, BYTE * bytebuffer, UINT * cb);
static HRESULT BSTRToUTF8(char ** psz, DWORD * pcbUTF8, BSTR bstr);
static HRESULT AsciiToBSTR(BSTR * pbstr, char * sz, int cch);
static HRESULT BSTRToAscii(char ** psz, BSTR bstr);
static BSTR    GetBSTRFromVariant(VARIANT varVariant);
static BOOL    GetBoolFromVariant(VARIANT varVariant, BOOL fDefault);
static DWORD   GetDwordFromVariant(VARIANT varVariant, DWORD dwDefault);
static long    GetLongFromVariant(VARIANT varVariant, long lDefault);
static HRESULT CreateVector(VARIANT * pVar, const BYTE * pData, DWORD cElems);
static HRESULT ReadFromStream(char ** ppData, ULONG * pcbData, IStream * pStm);
static void    MessageLoop();
static DWORD   UpdateTimeout(DWORD dwTimeout, DWORD dwStartTime);
static HRESULT FillExcepInfo(HRESULT hr, EXCEPINFO * pExcepInfo);
static BOOL    IsValidVariant(VARIANT v);

static BOOL         s_fWndClassRegistered;
static const char * s_szWinHttpEventMarshallerWndClass = "_WinHttpEventMarshaller";


#define SafeRelease(p) \
{ \
    if (p) \
        (p)->Release();\
    (p) = NULL;\
}

#ifndef HWND_MESSAGE
#define HWND_MESSAGE    ((HWND)-3)
#endif


inline BOOL IsValidBstr(BSTR bstr)
{
    // A BSTR can be NULL, or if non-NULL, it should at least
    // point to a 2-byte terminating NULL character.
    return (bstr == NULL) || (!IsBadReadPtr(bstr, 2));
}



#ifndef WINHTTP_STATIC_LIBRARY
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    if (rclsid != CLSID_WinHttpRequest)
        return CLASS_E_CLASSNOTAVAILABLE;

    if (riid != IID_IClassFactory || ppv == NULL)
        return E_INVALIDARG;

    CClassFactory * pCF = New CClassFactory();

    if (pCF)
    {
        *ppv = static_cast<IClassFactory *>(pCF);
        pCF->AddRef();
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }
}
CClassFactory::CClassFactory()
{
    _cRefs = 0;
}


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        *ppvObject = static_cast<IClassFactory *>(this);
        AddRef();
        return NOERROR;
    }
    else
        return E_NOINTERFACE;
}


ULONG STDMETHODCALLTYPE CClassFactory::AddRef()
{
    return ++_cRefs;
}

ULONG STDMETHODCALLTYPE CClassFactory::Release()
{
    if (--_cRefs == 0)
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


STDMETHODIMP
CClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject)
{
    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    if (ppvObject == NULL)
        return E_INVALIDARG;

    return CreateHttpRequest(riid, ppvObject);
}


STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

#else

STDAPI WinHttpCreateHttpRequestComponent(REFIID riid, void ** ppvObject)
{
    return CreateHttpRequest(riid, ppvObject);
}

#endif //WINHTTP_STATIC_LIBRARY



STDMETHODIMP
CreateHttpRequest(REFIID riid, void ** ppvObject)
{
    CHttpRequest *  pHttpRequest = New CHttpRequest();
    HRESULT         hr;

    if (pHttpRequest)
    {
        hr = pHttpRequest->QueryInterface(riid, ppvObject);

        if (FAILED(hr))
        {
            delete pHttpRequest;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}




/*
 *  CHttpRequest::CHttpRequest constructor
 *
 */

CHttpRequest::CHttpRequest()
{
    Initialize();
}



/*
 *  CHttpRequest::~CHttpRequest destructor
 *
 */

CHttpRequest::~CHttpRequest()
{
    ReleaseResources();
}


HRESULT STDMETHODCALLTYPE
CHttpRequest::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;

    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IWinHttpRequest || riid == IID_IDispatch || riid == IID_IUnknown)
    {
        *ppv = static_cast<IWinHttpRequest *>(this);
        AddRef();
    }
    else if (riid == IID_IConnectionPointContainer)
    {
        *ppv = static_cast<IConnectionPointContainer *>(this);
        AddRef();
    }
    else if (riid == IID_IProvideClassInfo)
    {
        *ppv = static_cast<IProvideClassInfo *>(static_cast<IProvideClassInfo2 *>(this));
        AddRef();
    }
    else if (riid == IID_IProvideClassInfo2)
    {
        *ppv = static_cast<IProvideClassInfo2 *>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}



ULONG STDMETHODCALLTYPE
CHttpRequest::AddRef()
{
    if (GetCurrentThreadId() == _dwMainThreadId)
        ++_cRefsOnMainThread;

    return InterlockedIncrement(&_cRefs);
}


ULONG STDMETHODCALLTYPE
CHttpRequest::Release()
{
    if (GetCurrentThreadId() == _dwMainThreadId)
    {
        if ((--_cRefsOnMainThread == 0) && _fAsync)
        {
            // Clean up the Event Marshaller. This must be done
            // on the main thread.
            _CP.ShutdownEventSinksMarshaller();

            // If the worker thread is still running, abort it
            // and wait for it to run down.
            Abort();
        }
    }

    DWORD cRefs  = InterlockedDecrement(&_cRefs);

    if (cRefs == 0)
    {
        delete this;
        return 0;
    }
    else
        return cRefs;
}


HRESULT
CHttpRequest::GetHttpRequestTypeInfo(REFGUID guid, ITypeInfo ** ppTypeInfo)
{
    HRESULT hr = NOERROR;

    ITypeLib *  pTypeLib;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];

    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);

    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetTypeInfoOfGuid(guid, ppTypeInfo);

        pTypeLib->Release();
    }

    return hr;
}

STDMETHODIMP
CHttpRequest::GetTypeInfoCount(UINT * pctinfo)
{
    if (!pctinfo)
        return E_INVALIDARG;

    *pctinfo = 1;

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::GetTypeInfo(UINT iTInfo, LCID, ITypeInfo ** ppTInfo)
{
    if (!ppTInfo)
        return E_INVALIDARG;

    *ppTInfo = NULL;

    if (iTInfo != 0)
        return DISP_E_BADINDEX;

    if (!_pTypeInfo)
    {
        HRESULT hr = GetHttpRequestTypeInfo(IID_IWinHttpRequest, &_pTypeInfo);

        if (FAILED(hr))
            return hr;
    }

    *ppTInfo = _pTypeInfo;
    _pTypeInfo->AddRef();

    return NOERROR;
}


struct IDMAPPING
{
    const OLECHAR * wszMemberName;
    DISPID          dispId;
};

static const IDMAPPING IdMapping[] =
{
    { L"Open",                  DISPID_HTTPREQUEST_OPEN },
    { L"SetRequestHeader",      DISPID_HTTPREQUEST_SETREQUESTHEADER },
    { L"Send",                  DISPID_HTTPREQUEST_SEND },
    { L"Status",                DISPID_HTTPREQUEST_STATUS },
    { L"WaitForResponse",       DISPID_HTTPREQUEST_WAITFORRESPONSE },
    { L"GetResponseHeader",     DISPID_HTTPREQUEST_GETRESPONSEHEADER },
    { L"ResponseBody",          DISPID_HTTPREQUEST_RESPONSEBODY },
    { L"ResponseText",          DISPID_HTTPREQUEST_RESPONSETEXT },
    { L"ResponseStream",        DISPID_HTTPREQUEST_RESPONSESTREAM },
    { L"StatusText",            DISPID_HTTPREQUEST_STATUSTEXT },
    { L"SetCredentials",        DISPID_HTTPREQUEST_SETCREDENTIALS },
    { L"SetProxy",              DISPID_HTTPREQUEST_SETPROXY },
    { L"GetAllResponseHeaders", DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS },
    { L"Abort",                 DISPID_HTTPREQUEST_ABORT },
    { L"SetTimeouts",           DISPID_HTTPREQUEST_SETTIMEOUTS },
    { L"Option",                DISPID_HTTPREQUEST_OPTION }
};


STDMETHODIMP
CHttpRequest::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames,
    UINT        cNames,
    LCID        ,
    DISPID *    rgDispId)
{
    if (riid != IID_NULL)
        return E_INVALIDARG;

    HRESULT     hr = NOERROR;

    if (cNames > 0)
    {
        hr = DISP_E_UNKNOWNNAME;

        for (int i = 0; i < (sizeof(IdMapping)/sizeof(IdMapping[0])); i++)
        {
            if (StrCmpIW(rgszNames[0], IdMapping[i].wszMemberName) == 0)
            {
                hr = NOERROR;
                rgDispId[0] = IdMapping[i].dispId;
                break;
            }
        }
    }

    return hr;
}


// _DispGetOptionalParam
//
// Helper routine to fetch optional parameters. If DispGetParam returns
// DISP_E_PARAMNOTFOUND, the error is converted to NOERROR.
//
static inline HRESULT _DispGetOptionalParam
(
    DISPPARAMS *    pDispParams,
    DISPID          dispid,
    VARTYPE         vt,
    VARIANT *       pvarResult,
    unsigned int *  puArgErr
)
{
    HRESULT hr = DispGetParam(pDispParams, dispid, vt, pvarResult, puArgErr);

    return (hr == DISP_E_PARAMNOTFOUND) ? NOERROR : hr;
}



STDMETHODIMP
CHttpRequest::Invoke(DISPID dispIdMember, REFIID riid,
    LCID,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pVarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT         hr = NOERROR;
    unsigned int    uArgErr;


    if (wFlags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT))
        return E_INVALIDARG;

    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    if (IsBadReadPtr(pDispParams, sizeof(DISPPARAMS)))
        return E_INVALIDARG;

    if (!puArgErr)
    {
        puArgErr = &uArgErr;
    }
    else if (IsBadWritePtr(puArgErr, sizeof(UINT)))
    {
        return E_INVALIDARG;
    }

    if (pVarResult)
    {
        if (IsBadWritePtr(pVarResult, sizeof(VARIANT)))
            return E_INVALIDARG;

        VariantInit(pVarResult);
    }

    switch (dispIdMember)
    {
    case DISPID_HTTPREQUEST_ABORT:
        {
            hr = Abort();

            break;
        }

    case DISPID_HTTPREQUEST_SETPROXY:
        {
            VARIANT     varProxySetting;
            VARIANT     varProxyServer;
            VARIANT     varBypassList;

            VariantInit(&varProxySetting);
            VariantInit(&varProxyServer);
            VariantInit(&varBypassList);

            hr = DispGetParam(pDispParams, 0, VT_UI4, &varProxySetting, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 1, VT_BSTR, &varProxyServer, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 2, VT_BSTR, &varBypassList, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetProxy(V_UI4(&varProxySetting), varProxyServer, varBypassList);
            }

            VariantClear(&varProxySetting);
            VariantClear(&varProxyServer);
            VariantClear(&varBypassList);

            break;
        }

    case DISPID_HTTPREQUEST_SETCREDENTIALS:
        {
            VARIANT     varUserName;
            VARIANT     varPassword;
            VARIANT     varAuthTarget;

            VariantInit(&varUserName);
            VariantInit(&varPassword);
            VariantInit(&varAuthTarget);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varUserName, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varPassword, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 2, VT_UI4, &varAuthTarget, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetCredentials(V_BSTR(&varUserName), V_BSTR(&varPassword),
                            V_UI4(&varAuthTarget));
            }

            VariantClear(&varUserName);
            VariantClear(&varPassword);
            VariantClear(&varAuthTarget);
            
            break;
        }

    case DISPID_HTTPREQUEST_OPEN:
        {
            VARIANT     varMethod;
            VARIANT     varUrl;
            VARIANT     varAsync;

            VariantInit(&varMethod);
            VariantInit(&varUrl);
            VariantInit(&varAsync);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varMethod, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varUrl, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 2, VT_BOOL, &varAsync, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = Open(V_BSTR(&varMethod), V_BSTR(&varUrl), varAsync);
            }

            VariantClear(&varMethod);
            VariantClear(&varUrl);
            VariantClear(&varAsync);

            break;
        }

    case DISPID_HTTPREQUEST_SETREQUESTHEADER:
        {
            VARIANT     varHeader;
            VARIANT     varValue;

            VariantInit(&varHeader);
            VariantInit(&varValue);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varHeader, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varValue, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetRequestHeader(V_BSTR(&varHeader), V_BSTR(&varValue));
            }

            VariantClear(&varHeader);
            VariantClear(&varValue);

            break;
        }

    case DISPID_HTTPREQUEST_GETRESPONSEHEADER:
        {
            VARIANT     varHeader;

            VariantInit(&varHeader);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varHeader, puArgErr);

            if (SUCCEEDED(hr))
            {
                BSTR    bstrValue = NULL;

                hr = GetResponseHeader(V_BSTR(&varHeader), &bstrValue);

                if (SUCCEEDED(hr) && pVarResult)
                {
                    V_VT(pVarResult)   = VT_BSTR;
                    V_BSTR(pVarResult) = bstrValue;
                }
                else
                    SysFreeString(bstrValue);
            }

            VariantClear(&varHeader);

            break;
        }

    case DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS:
        {
            BSTR    bstrResponseHeaders = NULL;

            hr = GetAllResponseHeaders(&bstrResponseHeaders);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrResponseHeaders;
            }
            else
                SysFreeString(bstrResponseHeaders);

            break;
        }

    case DISPID_HTTPREQUEST_SEND:
        {
            if (pDispParams->cArgs <= 1)
            {
                VARIANT     varEmptyBody;

                VariantInit(&varEmptyBody);

                hr = Send((pDispParams->cArgs == 0) ? varEmptyBody : pDispParams->rgvarg[0]);
            }
            else
            {
                hr = DISP_E_BADPARAMCOUNT;
            }
            break;
        }

    case DISPID_HTTPREQUEST_STATUS:
        {
            long    Status;

            hr = get_Status(&Status);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult) = VT_I4;
                V_I4(pVarResult) = Status;
            }
            break;
        }

    case DISPID_HTTPREQUEST_STATUSTEXT:
        {
            BSTR    bstrStatus = NULL;

            hr = get_StatusText(&bstrStatus);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrStatus;
            }
            else
                SysFreeString(bstrStatus);

            break;
        }

    case DISPID_HTTPREQUEST_RESPONSETEXT:
        {
            BSTR    bstrResponse = NULL;

            hr = get_ResponseText(&bstrResponse);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrResponse;
            }
            else
                SysFreeString(bstrResponse);

            break;
        }

    case DISPID_HTTPREQUEST_RESPONSEBODY:
        {
            if (pVarResult)
            {
                hr = get_ResponseBody(pVarResult);
            }
            break;
        }

    case DISPID_HTTPREQUEST_RESPONSESTREAM:
        {
            if (pVarResult)
            {
                hr = get_ResponseStream(pVarResult);
            }
            break;
        }

    case DISPID_HTTPREQUEST_OPTION:
        {
            VARIANT                 varOption;
            WinHttpRequestOption    Option;

            VariantInit(&varOption);

            hr = DispGetParam(pDispParams, 0, VT_I4, &varOption, puArgErr);

            if (FAILED(hr))
                break;

            Option = static_cast<WinHttpRequestOption>(V_I4(&varOption));

            if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
            {
                if (pVarResult)
                {
                    hr = get_Option(Option, pVarResult);
                }
            }
            else if (wFlags & DISPATCH_PROPERTYPUT)
            {
                hr = put_Option(Option, pDispParams->rgvarg[0]);
            }

            VariantClear(&varOption);
            break;
        }

    case DISPID_HTTPREQUEST_WAITFORRESPONSE:
        {
            VARIANT      varTimeout;
            VARIANT_BOOL boolSucceeded;

            VariantInit(&varTimeout);

            hr = _DispGetOptionalParam(pDispParams, 0, VT_I4, &varTimeout, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = WaitForResponse(varTimeout, &boolSucceeded);
            }

            if (pVarResult)
            {
                V_VT(pVarResult)   = VT_BOOL;
                V_BOOL(pVarResult) = boolSucceeded;
            }

            VariantClear(&varTimeout);
            break;
        }

    case DISPID_HTTPREQUEST_SETTIMEOUTS:
        {
            VARIANT     varResolveTimeout;
            VARIANT     varConnectTimeout;
            VARIANT     varSendTimeout;
            VARIANT     varReceiveTimeout;

            VariantInit(&varResolveTimeout);
            VariantInit(&varConnectTimeout);
            VariantInit(&varSendTimeout);
            VariantInit(&varReceiveTimeout);

            hr = DispGetParam(pDispParams, 0, VT_I4, &varResolveTimeout, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_I4, &varConnectTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 2, VT_I4, &varSendTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 3, VT_I4, &varReceiveTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetTimeouts(V_I4(&varResolveTimeout), V_I4(&varConnectTimeout),
                            V_I4(&varSendTimeout),
                            V_I4(&varReceiveTimeout));
            }

            VariantClear(&varResolveTimeout);
            VariantClear(&varConnectTimeout);
            VariantClear(&varSendTimeout);
            VariantClear(&varReceiveTimeout);
            break;
        }

    default:
        hr = DISP_E_MEMBERNOTFOUND;
        break;
    }

    if (FAILED(hr) && (pExcepInfo != NULL))
    {
        hr = FillExcepInfo(hr, pExcepInfo);
    }

    return hr;
}

static
HRESULT
FillExcepInfo(HRESULT hr, EXCEPINFO * pExcepInfo)
{
    // Don't create excepinfo for these errors to mimic oleaut behavior.
    if( hr == DISP_E_BADPARAMCOUNT ||
        hr == DISP_E_NONAMEDARGS ||
        hr == DISP_E_MEMBERNOTFOUND ||
        hr == E_INVALIDARG)
    {
        return hr;
    }

    // clear out exception info
    IErrorInfo * pei = NULL;

    pExcepInfo->wCode = 0;
    pExcepInfo->scode = hr;

    // if error info exists, use it
    GetErrorInfo(0, &pei);
   
    if (pei)
    {
        // give back to OLE
        SetErrorInfo(0, pei);

        pei->GetHelpContext(&pExcepInfo->dwHelpContext);
        pei->GetSource(&pExcepInfo->bstrSource);
        pei->GetDescription(&pExcepInfo->bstrDescription);
        pei->GetHelpFile(&pExcepInfo->bstrHelpFile);

        // give complete ownership to OLEAUT
        pei->Release();

        hr = DISP_E_EXCEPTION;
    }

    return hr;

}

STDMETHODIMP
CHttpRequest::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!ppTI)
        return E_POINTER;

    *ppTI = NULL;
    
    return GetHttpRequestTypeInfo(CLSID_WinHttpRequest, ppTI);
}


STDMETHODIMP
CHttpRequest::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (!pGUID)
        return E_POINTER;

    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = IID_IWinHttpRequestEvents;
    }
    else
        return E_INVALIDARG;
    
    return NOERROR;
}


STDMETHODIMP
CHttpRequest::EnumConnectionPoints(IEnumConnectionPoints **)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CHttpRequest::FindConnectionPoint(REFIID riid, IConnectionPoint ** ppCP)
{
    if (!ppCP)
        return E_POINTER;

    if (riid == IID_IWinHttpRequestEvents)
    {
        return _CP.QueryInterface(IID_IConnectionPoint, (void **)ppCP);
    }
    else
        return CONNECT_E_NOCONNECTION;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (!ppvObject)
        return E_INVALIDARG;

    if (riid == IID_IUnknown || riid == IID_IConnectionPoint)
    {
        *ppvObject = static_cast<IUnknown *>(static_cast<IConnectionPoint *>(this));
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE
CHttpRequest::CHttpRequestEventsCP::AddRef()
{
    return Px()->AddRef();
}


ULONG STDMETHODCALLTYPE
CHttpRequest::CHttpRequestEventsCP::Release()
{
    return Px()->Release();
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::GetConnectionInterface(IID * pIID)
{
    if (!pIID)
        return E_POINTER;

    *pIID = IID_IWinHttpRequestEvents;
    return NOERROR;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::GetConnectionPointContainer
(
    IConnectionPointContainer ** ppCPC
)
{
    if (!ppCPC)
        return E_POINTER;

    return Px()->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::Advise(IUnknown * pUnk, DWORD * pdwCookie)
{
    if (!pUnk || !pdwCookie)
    {
        return E_POINTER;
    }

    IWinHttpRequestEvents * pIWinHttpRequestEvents;
    HRESULT                 hr;

    hr = pUnk->QueryInterface(IID_IWinHttpRequestEvents, (void **)&pIWinHttpRequestEvents);

    if (SUCCEEDED(hr))
    {
        *pdwCookie = _SinkArray.Add(static_cast<IUnknown *>(pIWinHttpRequestEvents));
        
        if (*pdwCookie)
        {
            _cConnections++;
            hr = NOERROR;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = CONNECT_E_CANNOTCONNECT;

    return hr;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::Unadvise(DWORD dwCookie)
{
    IUnknown * pSink = _SinkArray.GetUnknown(dwCookie);

    if (pSink)
    {
        _SinkArray.Remove(dwCookie);
        pSink->Release();
        --_cConnections;
    }

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::EnumConnections(IEnumConnections **)
{
    return E_NOTIMPL;
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseStart(long Status, BSTR ContentType)
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        GetSink()->OnResponseStart(Status, ContentType);
    }
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseDataAvailable
(
    const BYTE *    rgbData,
    DWORD           cbData
)
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        VARIANT varData;
        HRESULT hr;
        
        VariantInit(&varData);

        hr = CreateVector(&varData, rgbData, cbData);

        if (SUCCEEDED(hr))
        {
            GetSink()->OnResponseDataAvailable(&V_ARRAY(&varData));
        }

        VariantClear(&varData);
    }
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseFinished()
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        GetSink()->OnResponseFinished();
    }
}


HRESULT
CHttpRequest::CHttpRequestEventsCP::CreateEventSinksMarshaller()
{
    HRESULT     hr = NOERROR;

    if (_cConnections > 0)
    {
        SafeRelease(_pSinkMarshaller);
        hr = CWinHttpRequestEventsMarshaller::Create(&_SinkArray, &_pSinkMarshaller);
    }

    return hr;
}


void
CHttpRequest::CHttpRequestEventsCP::ShutdownEventSinksMarshaller()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->Shutdown();
}


void
CHttpRequest::CHttpRequestEventsCP::ReleaseEventSinksMarshaller()
{
    SafeRelease(_pSinkMarshaller);
}


void
CHttpRequest::CHttpRequestEventsCP::FreezeEvents()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->FreezeEvents();
}


void
CHttpRequest::CHttpRequestEventsCP::UnfreezeEvents()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->UnfreezeEvents();
}


CHttpRequest::CHttpRequestEventsCP::~CHttpRequestEventsCP()
{
    // If any connections are still alive, unadvise them.
    if (_cConnections > 0)
    {
        _SinkArray.ReleaseAll();
        _cConnections = 0;
    }
}


/*
 *  CHttpRequest::Initialize
 *
 *  Purpose:
 *      Zero all data members
 *
 */
void
CHttpRequest::Initialize()
{
    _cRefs = 0;

    _pTypeInfo = NULL;
    _bstrUserAgent = NULL;

    _dwProxySetting  = INTERNET_OPEN_TYPE_PRECONFIG;
    _bstrProxyServer = NULL;
    _bstrBypassList  = NULL;

    _eState = CHttpRequest::CREATED;

    _fAsync            = FALSE;
    _hWorkerThread     = NULL;
    _cRefsOnMainThread = 0;
    _dwMainThreadId    = GetCurrentThreadId();
    _hrAsyncResult     = NOERROR;

    _bAborted          = false;
    _bSetTimeouts      = false;
    _bDisableRedirects = false;

    _hInet = NULL;
    _hConnection = NULL;
    _hHTTP = NULL;

    _ResolveTimeout = 0;
    _ConnectTimeout = 0;
    _SendTimeout    = 0;
    _ReceiveTimeout = 0;

    _cbRequestBody    = 0;
    _szRequestBuffer  = NULL;

    _dwCodePage          = CP_UTF8;
    _dwEscapePercentFlag = 0; 

    _szResponseBuffer = NULL;
    _cbResponseBuffer = 0;
    _cbResponseBody   = 0;

    _hAbortedConnectObject = NULL;
    _hAbortedRequestObject = NULL;

    _bstrCertSubject = NULL;
    _dwSslIgnoreFlags = 0;
}



/*
 *  CHttpRequest::ReleaseResources
 *
 *  Purpose:
 *      Release all handles, events, and buffers
 *
 */
void
CHttpRequest::ReleaseResources()
{
    SafeRelease(_pTypeInfo);

    if (_hWorkerThread)
    {
        CloseHandle(_hWorkerThread);
        _hWorkerThread = NULL;
    }

    _CP.ReleaseEventSinksMarshaller();

    //
    // Derefence aborted handle objects (if any).
    //

    if (_hAbortedRequestObject != NULL)
    {
        DereferenceObject(_hAbortedRequestObject);
        _hAbortedRequestObject = NULL;
    }

    if (_hAbortedConnectObject != NULL)
    {
        DereferenceObject(_hAbortedConnectObject);
        _hAbortedConnectObject = NULL;
    }

    if (_hHTTP)
    {
        HINTERNET temp = _hHTTP;
        _hHTTP = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_hConnection)
    {
        HINTERNET temp = _hConnection;
        _hConnection = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_hInet)
    {
        HINTERNET temp = _hInet;
        _hInet = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
    }

    if (_bstrUserAgent)
    {
        SysFreeString(_bstrUserAgent);
        _bstrUserAgent = NULL;
    }

    if (_bstrProxyServer)
    {
        SysFreeString(_bstrProxyServer);
        _bstrProxyServer = NULL;
    }

    if (_bstrBypassList)
    {
        SysFreeString(_bstrBypassList);
        _bstrBypassList = NULL;
    }

    if (_bstrCertSubject)
    {
        SysFreeString(_bstrCertSubject);
        _bstrCertSubject = NULL;
    }
}


/*
 *  CHttpRequest::Reset
 *
 *  Purpose:
 *      Release all resources and initialize data members
 *
 */

void
CHttpRequest::Reset()
{
    ReleaseResources();
    Initialize();
}



/*
 *  CHttpRequest::Recycle
 *
 *  Purpose:
 *      Recycle object
 *
 */

void
CHttpRequest::Recycle()
{
    //
    // Wait for the worker thread to shut down. This shouldn't take long
    // since the Abort will close the Request and Connection handles.
    //
    if (_hWorkerThread)
    {
        DWORD   dwWaitResult;

        for (;;)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hWorkerThread,
                                FALSE,
                                INFINITE,
                                QS_ALLINPUT);

            if (dwWaitResult == (WAIT_OBJECT_0 + 1))
            {
                // Message waiting in the message queue.
                // Run message pump to clear queue.
                MessageLoop();
            }
            else
            {
                break;
            }
        }

        CloseHandle(_hWorkerThread);
        _hWorkerThread = NULL;
    }

    _hConnection = NULL;
    _hHTTP = NULL;

    //
    // Derefence aborted handle objects (if any).
    //

    if (_hAbortedRequestObject != NULL)
    {
        DereferenceObject(_hAbortedRequestObject);
        _hAbortedRequestObject = NULL;
    }

    if (_hAbortedConnectObject != NULL)
    {
        DereferenceObject(_hAbortedConnectObject);
        _hAbortedConnectObject = NULL;
    }

    _fAsync           = FALSE;
    _hrAsyncResult    = NOERROR;

    _bAborted         = false;

    // don't reset timeouts, keep any that were set.

    _cbRequestBody    = 0;
    _cbResponseBuffer = 0;
    _cbResponseBody   = 0;

    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
    }

    _CP.ShutdownEventSinksMarshaller();

    _CP.ReleaseEventSinksMarshaller();

    // Allow events to fire; Abort() would have frozen them from firing.
    _CP.UnfreezeEvents();

    SetState(CHttpRequest::CREATED);
}



/*
 *  CHttpRequest::ReadResponse
 *
 *  Purpose:
 *      Read the response bits
 *
 *  Parameters:
 *      None
 *
 *  Errors:
 *      E_FAIL
 *      E_OUTOFMEMORY
 */
HRESULT
CHttpRequest::ReadResponse()
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode;
    long        lStatus;
    BSTR        bstrContentType = NULL;
    DWORD       dwContentLength = 0;

    // Determine the content length

    DWORD cb = sizeof(dwContentLength);

    fRetCode = HttpQueryInfoA(
                    _hHTTP,
                    HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    &dwContentLength,
                    &cb,
                    0);

    hr = get_Status(&lStatus);

    if (FAILED(hr))
        goto Error;

    hr = _GetResponseHeader(L"Content-Type", &bstrContentType);

    if (FAILED(hr))
    {
        bstrContentType = SysAllocString(L"");
        if (bstrContentType == NULL)
            goto ErrorOutOfMemory;

        hr = NOERROR;
    }

    _CP.FireOnResponseStart(lStatus, bstrContentType);

    if (dwContentLength != 0)
    {
        _szResponseBuffer = New char[dwContentLength];

        if (_szResponseBuffer)
        {
            _cbResponseBuffer = dwContentLength;
        }
        else
            goto ErrorOutOfMemory;
    }
    else
    {
        _szResponseBuffer = NULL;
        _cbResponseBuffer = 0;
    }


    //
    // Read data until there is no more - we need to buffer the data
    //
    while (!_bAborted)
    {
    	DWORD   cbAvail = 0;
        DWORD   cbRead  = 0;

        fRetCode = WinHttpQueryDataAvailable(_hHTTP, &cbAvail);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        // Check for buffer overflow - dynamically resize if neccessary
        if (_cbResponseBody + cbAvail > _cbResponseBuffer)
        {
            ULONG cbNewSize = _cbResponseBody + cbAvail;
            
            char * szNewBuf = New char[cbNewSize];

            if (!szNewBuf)
                goto ErrorOutOfMemory;

            if (_szResponseBuffer)
            {
                ::memcpy(szNewBuf, _szResponseBuffer, _cbResponseBody);
                delete [] _szResponseBuffer;
            }

            _cbResponseBuffer = cbNewSize;

            _szResponseBuffer = szNewBuf;
        }

        fRetCode = WinHttpReadData(
                    _hHTTP,
                    &_szResponseBuffer[_cbResponseBody],
                    cbAvail,
                    &cbRead);

        if (!fRetCode)
        {
            goto ErrorFail;
        }
        
        // No more data
        if (cbRead == 0)
            break;

        _CP.FireOnResponseDataAvailable((const BYTE *)&_szResponseBuffer[_cbResponseBody],
                cbRead);

        _cbResponseBody += cbRead;
    }

    SetState(CHttpRequest::RESPONSE);

    hr = NOERROR;

Cleanup:
    if (bstrContentType)
        SysFreeString(bstrContentType);

    _CP.FireOnResponseFinished();

    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



STDMETHODIMP
CHttpRequest::SetProxy(HTTPREQUEST_PROXY_SETTING ProxySetting,
    VARIANT     varProxyServer,
    VARIANT     varBypassList)
{
    HRESULT             hr = NOERROR;

    if (!IsValidVariant(varProxyServer) || !IsValidVariant(varBypassList))
        return E_INVALIDARG;

    if (_bstrProxyServer)
    {
        SysFreeString(_bstrProxyServer);
        _bstrProxyServer = NULL;
    }

    if (_bstrBypassList)
    {
        SysFreeString(_bstrBypassList);
        _bstrBypassList = NULL;
    }

    switch (ProxySetting)
    {
        case HTTPREQUEST_PROXYSETTING_PRECONFIG:
            _dwProxySetting = INTERNET_OPEN_TYPE_PRECONFIG;
            break;

        case HTTPREQUEST_PROXYSETTING_DIRECT:
            _dwProxySetting   = INTERNET_OPEN_TYPE_DIRECT;
            break;

        case HTTPREQUEST_PROXYSETTING_PROXY:
            _dwProxySetting   = INTERNET_OPEN_TYPE_PROXY;
            _bstrProxyServer  = GetBSTRFromVariant(varProxyServer);
            _bstrBypassList   = GetBSTRFromVariant(varBypassList);
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

    if (SUCCEEDED(hr))
    {
        if (_hInet)
        {
            WINHTTP_PROXY_INFOW ProxyInfo;

            memset(&ProxyInfo, 0, sizeof(ProxyInfo));

            ProxyInfo.dwAccessType    = _dwProxySetting;
            ProxyInfo.lpszProxy       = _bstrProxyServer;
            ProxyInfo.lpszProxyBypass = _bstrBypassList;
            
            if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_PROXY,
                        &ProxyInfo,
                        sizeof(ProxyInfo)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    SetErrorInfo(hr);

    return hr;
}


STDMETHODIMP
CHttpRequest::SetCredentials(
    BSTR bstrUserName,
    BSTR bstrPassword,
    HTTPREQUEST_SETCREDENTIALS_FLAGS Flags)
{
    HRESULT     hr;

    // Must call Open method before SetCredentials.
    if (! _hHTTP)
    {
        goto ErrorCannotCallBeforeOpen;
    }

    if (!IsValidBstr(bstrUserName) || !IsValidBstr(bstrPassword))
        return E_INVALIDARG;

    if (Flags == HTTPREQUEST_SETCREDENTIALS_FOR_SERVER)
    {
        // Set Username and Password.
        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_USERNAME, 
            bstrUserName, 
            SysStringLen(bstrUserName));

        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PASSWORD, 
            bstrPassword,
            SysStringLen(bstrPassword));
    }
    else if (Flags == HTTPREQUEST_SETCREDENTIALS_FOR_PROXY)
    {
        // Set Username and Password.
        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PROXY_USERNAME, 
            bstrUserName, 
            SysStringLen(bstrUserName));

        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PROXY_PASSWORD, 
            bstrPassword,
            SysStringLen(bstrPassword));
    }
    else
        return E_INVALIDARG;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Cleanup;
}


/*
 *  CHttpRequest::Open
 *
 *  Purpose:
 *      Open a logical HTTP connection
 *
 *  Parameters:
 *      bstrMethod      IN      HTTP method (GET, PUT, ...)
 *      bstrUrl         IN      Target URL
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_ACCESSDENIED
 *      Errors from InternetOpenA and WinHttpCrackUrlA and InternetConnectA
 *          and HttpOpenRequestA
 */

STDMETHODIMP
CHttpRequest::Open(
    BSTR            bstrMethod,
    BSTR            bstrUrl,
    VARIANT         varAsync)
{
    HRESULT         hr = NOERROR;
    BSTR            bstrHostName = NULL;
    BSTR            bstrUrlPath = NULL;
    DWORD           dwHttpOpenFlags = 0;
    URL_COMPONENTSW url;

    // Check for reinitialization
    if (_eState != CHttpRequest::CREATED)
    {
        //
        // Abort any request in progress.
        // This will also recycle the object.
        //
        Abort();
    }

    // Validate parameters
    if (!bstrMethod || !bstrUrl ||
            !IsValidBstr(bstrMethod) ||
            !IsValidBstr(bstrUrl) ||
            !lstrlenW(bstrMethod) ||    // cannot have empty method
            !lstrlenW(bstrUrl)    ||    // cannot have empty url
            !IsValidVariant(varAsync))
        return E_INVALIDARG;

    _fAsync = GetBoolFromVariant(varAsync, FALSE);

    //
    // Open an Internet Session if one does not already exist.
    //
    if (!_hInet)
    {
        _hInet = WinHttpOpen(
                    GetUserAgentString(),
                    _dwProxySetting,
                    _bstrProxyServer,
                    _bstrBypassList,
                    0);

        if (!_hInet)
            goto ErrorFail;

        // In winhttp5, this should be adjusted through an exposed option
        // or flag, rather than going through the back door.
        HINTERNET hSessionMapped = NULL;
        if (ERROR_SUCCESS == MapHandleToAddress(_hInet,
                                                (LPVOID *)&hSessionMapped,
                                                FALSE) &&
            hSessionMapped)
        {
            ((INTERNET_HANDLE_OBJECT *)hSessionMapped)->SetUseSslSessionCache(TRUE);
            DereferenceObject(hSessionMapped);
        }
    }

    //
    // If any timeouts were set previously, apply them.
    //
    if (_bSetTimeouts)
    {
        if (!WinHttpSetTimeouts(_hInet, (int)_ResolveTimeout,
                        (int)_ConnectTimeout,
                        (int)_SendTimeout,
                        (int)_ReceiveTimeout))
            goto ErrorFail;
    }


    //
    // Set the code page on the Session handle; the Connect
    // handle will also inherit this value.
    //
    if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_CODEPAGE,
                &_dwCodePage,
                sizeof(_dwCodePage)))
        goto ErrorFail;


    // Break the URL into the required components
    ZeroMemory(&url, sizeof(URL_COMPONENTSW));

    url.dwStructSize = sizeof(URL_COMPONENTSW);
    url.dwHostNameLength  = 1;
    url.dwUrlPathLength   = 1;
    url.dwExtraInfoLength = 1;

    if (!WinHttpCrackUrl(bstrUrl, 0, 0, &url))
        goto ErrorFail;


    // Check for non-http schemes
    if (url.nScheme != INTERNET_SCHEME_HTTP && url.nScheme != INTERNET_SCHEME_HTTPS)
        goto ErrorUnsupportedScheme;

    // IE6/Reno Bug #6236: if the client does not specify a resource path,
    // then add the "/".
    if (url.dwUrlPathLength == 0)
    {
        INET_ASSERT(url.dwExtraInfoLength == 1);

        url.lpszUrlPath = L"/";
        url.dwUrlPathLength = 1;
    }

    bstrHostName = SysAllocStringLen(url.lpszHostName, url.dwHostNameLength);
    bstrUrlPath  = SysAllocStringLen(url.lpszUrlPath, lstrlenW(url.lpszUrlPath));

    if (!bstrHostName || !bstrUrlPath)
        goto ErrorOutOfMemory;


    INET_ASSERT(_hConnection == NULL);
    INET_ASSERT(_hHTTP == NULL);

    _hConnection = WinHttpConnect(
                    _hInet,
                    bstrHostName,
                    url.nPort,
                    0);

    if (!_hConnection)
        goto ErrorFail;

    if (url.nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwHttpOpenFlags |= WINHTTP_FLAG_SECURE;
    }

    //
    // Apply EscapePercentInURL option.
    //
    dwHttpOpenFlags |= _dwEscapePercentFlag;

    _hHTTP = WinHttpOpenRequest(
                _hConnection,
                bstrMethod,
                bstrUrlPath,
                NULL,
                NULL,
                NULL,
                dwHttpOpenFlags);

    if (!_hHTTP)
        goto ErrorFail;

    // Set the SSL ignore flags through an undocumented front door
    if (_dwSslIgnoreFlags)
    {
        WinHttpSetOption(_hHTTP,
                         WINHTTP_OPTION_SECURITY_FLAGS,
                         (LPVOID)&_dwSslIgnoreFlags,
                         sizeof(_dwSslIgnoreFlags));
    }

    SetState(CHttpRequest::OPENED);

    hr = NOERROR;

Cleanup:
    if (bstrHostName)
        SysFreeString(bstrHostName);;
    if (bstrUrlPath)
        SysFreeString(bstrUrlPath);

    SetErrorInfo(hr);

    return hr;

ErrorUnsupportedScheme:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    goto Cleanup;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SetRequestHeader
 *
 *  Purpose:
 *      Set a request header
 *
 *  Parameters:
 *      bstrHeader      IN      HTTP request header
 *      bstrValue       IN      Header value
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::SetRequestHeader(BSTR bstrHeader, BSTR bstrValue)
{
    WCHAR *     wszHeaderValue = NULL;  
    DWORD       cchHeaderValue;
    DWORD       dwModifiers = HTTP_ADDREQ_FLAG_ADD;
    HRESULT     hr = NOERROR;

    // Validate header parameter (null or zero-length value is allowed)
    if (!bstrHeader || !IsValidBstr(bstrHeader) ||
            lstrlenW(bstrHeader)==0 ||
            !IsValidBstr(bstrValue))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::OPENED)
        goto ErrorCannotCallBeforeOpen;
    else if (_eState >= CHttpRequest::SENDING)
        goto ErrorCannotCallAfterSend;

    // Ignore attempts to set the Content-Length header; the
    // content length is computed and sent automatically.
    if (StrCmpIW(bstrHeader, L"Content-Length") == 0)
        goto Cleanup;

    cchHeaderValue = SysStringLen(bstrHeader) + SysStringLen(bstrValue)
                        + 2 /* wcslen(L": ") */
                        + 2 /* wcslen(L"\r\n") */;

    wszHeaderValue = New WCHAR [cchHeaderValue + 1];

    if (!wszHeaderValue)
        goto ErrorOutOfMemory;

    wcscpy(wszHeaderValue, bstrHeader);
    wcscat(wszHeaderValue, L": ");
    if (bstrValue)
        wcscat(wszHeaderValue, bstrValue);
    wcscat(wszHeaderValue, L"\r\n");

    // For blank header values, erase the header by setting the
    // REPLACE flag.
    if (SysStringLen(bstrValue) == 0)
    {
        dwModifiers |= HTTP_ADDREQ_FLAG_REPLACE;
    }
    
    if (! WinHttpAddRequestHeaders(_hHTTP, wszHeaderValue,
            -1L,
            dwModifiers))
        goto ErrorFail;

    hr = NOERROR;

Cleanup:
    if (wszHeaderValue)
        delete [] wszHeaderValue;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorCannotCallAfterSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SetRequiredRequestHeaders
 *
 *  Purpose:
 *      Set implicit request headers
 *
 *  Parameters:
 *      None
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

HRESULT
CHttpRequest::SetRequiredRequestHeaders()
{
    HRESULT hr = NOERROR;
    char    szContentLengthHeader[sizeof("Content-Length") +
                                  sizeof(": ") +
                                  15 +   // content-length value
                                  sizeof("\r\n") + 1];

    lstrcpy(szContentLengthHeader, "Content-Length: ");
    _ltoa(_cbRequestBody,
        szContentLengthHeader + 16, /* "Content-Length: " */
        10);
    lstrcat(szContentLengthHeader, "\r\n");

    if (! HttpAddRequestHeadersA(_hHTTP, szContentLengthHeader,
            -1L,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE))
    {
        hr = E_FAIL;
    }

    // Add an Accept: */* header if no other Accept header
    // has been set. Ignore any return code, since it is
    // not fatal if this fails.
    HttpAddRequestHeadersA(_hHTTP, "Accept: */*",
            -1L,
            HTTP_ADDREQ_FLAG_ADD_IF_NEW);

    return hr;
}


DWORD WINAPI WinHttpRequestSendAsync(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize its thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    HRESULT hr;
    DWORD   dwExitCode;

    CHttpRequest * pWinHttpRequest = reinterpret_cast<CHttpRequest *>(lpParameter);

    INET_ASSERT(pWinHttpRequest != NULL);

    dwExitCode = pWinHttpRequest->SendAsync();

    pWinHttpRequest->Release();

    // If this worker thread was impersonating, revert to the default
    // process identity.
    RevertToSelf();

    return dwExitCode;
}


/*
 *  CHttpRequest::CreateAsyncWorkerThread
 *
 */

HRESULT
CHttpRequest::CreateAsyncWorkerThread()
{
    DWORD   dwWorkerThreadId;
    HANDLE  hThreadToken = NULL;
    HRESULT hr;

    hr = _CP.CreateEventSinksMarshaller();

    if (FAILED(hr))
        return hr;

    hr = NOERROR;

    //
    // If the current thread is impersonating, then grab its access token
    // and revert the current thread (so it is nolonger impersonating).
    // After creating the worker thread, we will make the main thread
    // impersonate again. Apparently you should not call CreateThread
    // while impersonating.
    //
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
            FALSE,
            &hThreadToken))
    {
        INET_ASSERT(hThreadToken != 0);

        RevertToSelf();
    }

    // Create the worker thread suspended.
    _hWorkerThread = CreateThread(NULL, 0, WinHttpRequestSendAsync,
                            (void *)static_cast<CHttpRequest *>(this),
                            CREATE_SUSPENDED,
                            &dwWorkerThreadId);

    // If CreateThread fails, grab the error code now.
    if (!_hWorkerThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If the main thread was impersonating, then:
    //  (1) have the worker thread impersonate the same user, and
    //  (2) have the main thread resume impersonating the 
    //      client too (since we called RevertToSelf above).
    //
    if (hThreadToken)
    {
        if (_hWorkerThread)
        {
            SetThreadToken(&_hWorkerThread, hThreadToken);
        }

        SetThreadToken(NULL, hThreadToken);
        
        CloseHandle(hThreadToken);
    }

    // If the worker thread was created, start it running.
    if (_hWorkerThread)
    {
        // The worker thread owns a ref count on the component.
        // Don't call AddRef() as it will attribute the ref count
        // to the main thread.
        _cRefs++;

        ResumeThread(_hWorkerThread);
    }
    else
    {
        _CP.ShutdownEventSinksMarshaller();
        _CP.ReleaseEventSinksMarshaller();
    }

    return hr;
}


/*
 *  CHttpRequest::Send
 *
 *  Purpose:
 *      Send the HTTP request
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

STDMETHODIMP
CHttpRequest::Send(VARIANT varBody)
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode = FALSE;
    BOOL        fRetryWithClientAuth = TRUE;

    // Validate parameter
    if (!IsValidVariant(varBody))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::OPENED)
        goto ErrorCannotCallBeforeOpen;

    // Get the request body
    hr = SetRequestBody(varBody);

    if (FAILED(hr))
        goto Error;

    hr = SetRequiredRequestHeaders();

    if (FAILED(hr))
        goto Error;

    if (_bDisableRedirects)
    {
        DWORD   dwDisable = WINHTTP_DISABLE_REDIRECTS;

        WinHttpSetOption(_hHTTP,
                        WINHTTP_OPTION_DISABLE_FEATURE,
                        (void *) &dwDisable,
                        sizeof(DWORD));
    }

    
try_again:
    SetState(CHttpRequest::SENDING);
    
    if (_fAsync)
    {
        hr = CreateAsyncWorkerThread();

        if (FAILED(hr))
            goto Error;
    }
    else
    {
        // Send the HTTP request
        fRetCode = WinHttpSendRequest(
                        _hHTTP,
                        NULL, 0,            // No header info here
                        _szRequestBuffer,
                        _cbRequestBody,
                        _cbRequestBody,
                        0);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        fRetCode = WinHttpReceiveResponse(_hHTTP, NULL);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        SetState(CHttpRequest::SENT);

        // Read the response data
        hr = ReadResponse();

        if (FAILED(hr))
            goto Error;
    }

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if (!_fAsync &&
        hr == HRESULT_FROM_WIN32(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) &&
        fRetryWithClientAuth)
    {
        fRetryWithClientAuth = FALSE;
        // Try to enumerate the first cert in the reverted user context,
        // select the cert (per object sesssion, not global), and send
        // the request again.
        if (SelectCertificate())
            goto try_again;
    }
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SendAsync
 *
 *  Purpose:
 *      Send the HTTP request
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

DWORD
CHttpRequest::SendAsync()
{
    DWORD   dwLastError = 0;
    DWORD   fRetCode;
    HRESULT hr;
    BOOL    fRetryWithClientAuth = TRUE;

try_again:
    if (_bAborted || !_hHTTP)
        goto ErrorUnexpected;

    // Send the HTTP request
    fRetCode = WinHttpSendRequest(
                    _hHTTP,
                    NULL, 0,            // No header info here
                    _szRequestBuffer,
                    _cbRequestBody,
                    _cbRequestBody,
                    0);

    if (!fRetCode)
        goto ErrorFail;

    fRetCode = WinHttpReceiveResponse(_hHTTP, NULL);

    if (!fRetCode)
        goto ErrorFail;

    if (!_bAborted)
    {
        SetState(CHttpRequest::SENT);

        hr = ReadResponse();

        if (FAILED(hr))
        {
            if (hr == E_OUTOFMEMORY)
                goto ErrorOutOfMemory;
            goto ErrorFail;
        }
    }

    hr = NOERROR;

Cleanup:
    _hrAsyncResult = hr;
    return dwLastError;

ErrorUnexpected:
    dwLastError = ERROR_WINHTTP_INTERNAL_ERROR;
    hr = HRESULT_FROM_WIN32(dwLastError);
    goto Cleanup;

ErrorFail:
    dwLastError = GetLastError();
    if (dwLastError == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED &&
        fRetryWithClientAuth)
    {
        fRetryWithClientAuth = FALSE;
        // Try to enumerate the first cert in the reverted user context,
        // select the cert (per object sesssion, not global), and send
        // the request again.
        if (SelectCertificate())
        {
            SetState(CHttpRequest::SENDING);
            goto try_again;
        }
    }
    hr = HRESULT_FROM_WIN32(dwLastError);
    goto Cleanup;

ErrorOutOfMemory:
    dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::WaitForResponse(VARIANT varTimeout, VARIANT_BOOL * pboolSucceeded)
{
    HRESULT     hr = NOERROR;
    bool        bSucceeded= true;
    DWORD       dwTimeout;

    // Validate parameters; null pboolSucceeded pointer is Ok.
    if (!IsValidVariant(varTimeout) ||
            (pboolSucceeded &&
             IsBadWritePtr(pboolSucceeded, sizeof(VARIANT_BOOL))))
        return E_INVALIDARG;

    // Get the timeout value. Disallow numbers
    // less than -1 (which means INFINITE).
    
    if (GetLongFromVariant(varTimeout, INFINITE) < -1L)
        return E_INVALIDARG;

    dwTimeout = GetDwordFromVariant(varTimeout, INFINITE);


    // Validate state. 
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    //
    // WaitForResponse is a no-op if we're not in async mode.
    //
    if (_fAsync && _hWorkerThread)
    {
        //
        // Has the worker thread has already finished?
        //
        if (WaitForSingleObject(_hWorkerThread, 0) == WAIT_TIMEOUT)
        {
            //
            // Convert Timeout from seconds to milliseconds. Any timeout
            // value over 4 million seconds (~46 days) is "rounded up"
            // to INFINITE. :)
            //
            if (dwTimeout > 4000000)   // avoid overflow
            {
                dwTimeout = INFINITE;
            }
            else
            {
                // convert to milliseconds
                dwTimeout *= 1000;
            }


            DWORD   dwStartTime;
            DWORD   dwWaitResult;
            bool    bWaitAgain;
            
            do
            {
                dwStartTime = GetTickCount();

                dwWaitResult = MsgWaitForMultipleObjects(1, &_hWorkerThread,
                                    FALSE,
                                    dwTimeout,
                                    QS_ALLINPUT);
                
                bWaitAgain = false;

                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                    // Thread exited.
                    MessageLoop();
                    hr = _hrAsyncResult;
                    bSucceeded = SUCCEEDED(hr);
                    break;
                case WAIT_OBJECT_0 + 1:
                    // Message waiting in the message queue.
                    // Run message pump to clear queue.
                    MessageLoop();
                    bWaitAgain = true;
                    break;
                case WAIT_TIMEOUT:
                    // Timeout.
                    bSucceeded = false;
                    break;
                case (-1):
                default:
                    // Error.
                    goto ErrorFail;
                    break;
                }

                // If we're going to continue waiting for the worker
                // thread, decrease timeout appropriately.
                if (bWaitAgain)
                {
                    dwTimeout = UpdateTimeout(dwTimeout, dwStartTime);
                }
            } while (bWaitAgain);
        }
        else
        {
            // If the worker thread is already done, then pump messages
            // to clear any events that it may have posted.
            MessageLoop();
            hr = _hrAsyncResult;
            bSucceeded = SUCCEEDED(hr);
        }
    }

Cleanup:
    if (pboolSucceeded)
    {
        *pboolSucceeded = (bSucceeded ? VARIANT_TRUE : VARIANT_FALSE);
    }

    SetErrorInfo(hr);
    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    bSucceeded = false;
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::Abort()
{
    //
    // Abort if not already aborted and not in the CREATED state,
    // (meaning at least the Open method has been called).
    //
    if ((_eState > CHttpRequest::CREATED) && !_bAborted)
    {
        DWORD   error;

        _bAborted = true;

        // Tell our connection point manager to abort any
        // events "in flight"--i.e., abort any events that
        // may have already been posted by the worker thread.
        _CP.FreezeEvents();

        if (_hHTTP)
        {
            //
            // Add a ref count on the HTTP Request handle.
            //
            INET_ASSERT(_hAbortedRequestObject == NULL);
            error = MapHandleToAddress(_hHTTP, (LPVOID *)&_hAbortedRequestObject, FALSE);
            INET_ASSERT(error == 0);

            WinHttpCloseHandle(_hHTTP);
        }

        if (_hConnection)
        {
            //
            // Add a ref count on the Connection handle.
            //
            INET_ASSERT(_hAbortedConnectObject == NULL);
            error = MapHandleToAddress(_hConnection, (LPVOID *)&_hAbortedConnectObject, FALSE);
            INET_ASSERT(error == 0);

            WinHttpCloseHandle(_hConnection);
        }

        // Recycle the object.
        Recycle();
    }

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::SetTimeouts(long ResolveTimeout, long ConnectTimeout, long SendTimeout, long ReceiveTimeout)
{
    if ((ResolveTimeout < -1L) || (ConnectTimeout < -1L) ||
        (SendTimeout < -1L)    || (ReceiveTimeout < -1L))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = NOERROR;

    _ResolveTimeout = (DWORD) ResolveTimeout;
    _ConnectTimeout = (DWORD) ConnectTimeout;
    _SendTimeout    = (DWORD) SendTimeout;
    _ReceiveTimeout = (DWORD) ReceiveTimeout;
    
    _bSetTimeouts   = true;

    if (_hHTTP)
    {
        DWORD fRetCode;

        fRetCode = WinHttpSetTimeouts(_hHTTP, (int)_ResolveTimeout,
                        (int)_ConnectTimeout,
                        (int)_SendTimeout,
                        (int)_ReceiveTimeout);

        if (!fRetCode)
            hr = E_INVALIDARG;
    }

    return hr;
}


/*
 *  CHttpRequest::SetRequestBody
 *
 *  Purpose:
 *      Set the request body
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 */

HRESULT
CHttpRequest::SetRequestBody(VARIANT varBody)
{
    HRESULT             hr = NOERROR;
    VARIANT             varTemp;
    BSTR                bstrBody = NULL;
    SAFEARRAY *         psa = NULL;
    VARIANT *           pvarBody = NULL;
    IStream *           pStm = NULL;

    // varBody is validated by CHttpRequest::Send().

    VariantInit(&varTemp);

    // Free a previously set body and its response
    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
        _cbRequestBody = 0;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
        _cbResponseBuffer = 0;
        _cbResponseBody = 0;
    }

    if (V_ISBYREF(&varBody))
    {
        pvarBody = varBody.pvarVal;
    }
    else
    {
        pvarBody = &varBody;
    }

    // Check for an empty body
    if (V_VT(pvarBody) == VT_EMPTY ||
        V_VT(pvarBody) == VT_NULL  ||
        V_VT(pvarBody) == VT_ERROR)
        goto Cleanup;

    //
    // Extract the body: BSTR or array of UI1
    //

    // We need to explicitly look for the byte array since it will be converted
    // to a BSTR by VariantChangeType.
    if (V_ISARRAY(pvarBody) && (V_VT(pvarBody) & VT_UI1))
    {
        BYTE *  pb = NULL;
        long    lUBound = 0;
        long    lLBound = 0;

        psa = V_ARRAY(pvarBody);

        // We only handle 1 dimensional arrays
        if (SafeArrayGetDim(psa) != 1)
            goto ErrorFail;

        // Get access to the blob
        hr = SafeArrayAccessData(psa, (void **)&pb);

        if (FAILED(hr))
            goto Error;

        // Compute the data size from the upper and lower array bounds
        hr = SafeArrayGetLBound(psa, 1, &lLBound);

        if (FAILED(hr))
            goto Error;

        hr = SafeArrayGetUBound(psa, 1, &lUBound);

        if (FAILED(hr))
            goto Error;

        _cbRequestBody = lUBound - lLBound + 1;

        if (_cbRequestBody > 0)
        {
            // Copy the data into the request buffer
            _szRequestBuffer = New char [_cbRequestBody];

            if (!_szRequestBuffer)
            {
                _cbRequestBody = 0;
                goto ErrorOutOfMemory;
            }
            
            ::memcpy(_szRequestBuffer, pb, _cbRequestBody);
        }
        
        SafeArrayUnaccessData(psa);
        psa = NULL;
    }
    else
    {
        // Try a BSTR
        bstrBody = GetBSTRFromVariant(*pvarBody);

        if (bstrBody)
        {
            hr = BSTRToUTF8(&_szRequestBuffer, &_cbRequestBody, bstrBody);

            if (FAILED(hr))
                goto Error;
        }
        else
        {
            // Try a Stream
            if (V_VT(pvarBody) == VT_UNKNOWN || V_VT(pvarBody) == VT_DISPATCH)
            {
                IStream *   pStm;

                hr = pvarBody->punkVal->QueryInterface(
                            IID_IStream,
                            (void **)&pStm);

                if (FAILED(hr))
                    goto Error;

                hr = ReadFromStream(
                            &_szRequestBuffer,
                            &_cbRequestBody,
                            pStm);

                pStm->Release();

                if (FAILED(hr))
                    goto Error;
            }
        }
    }

    hr = NOERROR;

Cleanup:
    VariantClear(&varTemp);
    if (psa)
        SafeArrayUnaccessData(psa);
    if (bstrBody)
        SysFreeString(bstrBody);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::GetResponseHeader
 *
 *  Purpose:
 *      Get a response header
 *
 *  Parameters:
 *      bstrHeader      IN      HTTP request header
 *      pbstrValue      OUT     Header value
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 *      Errors from WinHttpQueryHeaders
 */

STDMETHODIMP
CHttpRequest::GetResponseHeader(BSTR bstrHeader, BSTR * pbstrValue)
{
    return _GetResponseHeader(bstrHeader, pbstrValue);
}

HRESULT
CHttpRequest::_GetResponseHeader(OLECHAR * wszHeader, BSTR * pbstrValue)
{
    HRESULT     hr = NOERROR;
    WCHAR *     wszHeaderValue = NULL;
    DWORD       cb;
    BOOL        fRetCode;

    // Validate parameters
    if (IsBadReadPtr(wszHeader, 2) ||
            IsBadWritePtr(pbstrValue, sizeof(BSTR)) ||
            !lstrlenW(wszHeader))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrValue = NULL;

    cb = 64; // arbitrary size in which many header values will fit

    wszHeaderValue = New WCHAR[cb];

    if (!wszHeaderValue)
        goto ErrorOutOfMemory;

RetryQuery:
    // Determine length of requested header
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_CUSTOM,
                    wszHeader,
                    wszHeaderValue,
                    &cb,
                    0);

    // Check for ERROR_INSUFFICIENT_BUFFER - reallocate the buffer and retry
    if (!fRetCode)
    {
        switch (GetLastError())
        {
            case ERROR_INSUFFICIENT_BUFFER:
            {
                delete [] wszHeaderValue;
                wszHeaderValue = New WCHAR[cb]; // should this be cb/2?
                if (!wszHeaderValue)
                    goto ErrorOutOfMemory;
                goto RetryQuery;
            }

            case ERROR_HTTP_HEADER_NOT_FOUND:
                goto ErrorFail;
        
            default:
                goto ErrorFail;
        }
    }

    *pbstrValue = SysAllocString(wszHeaderValue);

    if (!*pbstrValue)
        goto ErrorOutOfMemory;

    hr = NOERROR;

Cleanup:
    if (wszHeaderValue)
        delete [] wszHeaderValue;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    goto Cleanup;
}


/*
 *  CHttpRequest::GetAllResponseHeaders
 *
 *  Purpose:
 *      Return the response headers
 *
 *  Parameters:
 *      pbstrHeaders    IN/OUT      CRLF delimited headers
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::GetAllResponseHeaders(BSTR * pbstrHeaders)
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode;
    WCHAR *     wszAllHeaders = NULL;
    WCHAR *     wszFirstHeader = NULL;
    DWORD       cb = 0;

    // Validate parameter
    if (IsBadWritePtr(pbstrHeaders, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrHeaders = NULL;

RetryQuery:
    // Determine the length of all headers and then get all the headers
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_RAW_HEADERS_CRLF,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    wszAllHeaders,
                    &cb,
                    0);

    if (!fRetCode)
    {
        // Allocate a buffer large enough to hold all headers
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            wszAllHeaders = New WCHAR[cb];

            if (!wszAllHeaders)
                goto ErrorOutOfMemory;

            goto RetryQuery;
        }
        else
        {
            goto ErrorFail;
        }
    }

    // Bypass status line - jump past first CRLF (0x13, 0x10)
    wszFirstHeader = wcschr(wszAllHeaders, '\n');

    if (*wszFirstHeader == '\n')
    {
        *pbstrHeaders = SysAllocString(wszFirstHeader + 1);

        if (!*pbstrHeaders)
            goto ErrorOutOfMemory;
    }

    hr = NOERROR;
    
Cleanup:
    if (wszAllHeaders)
        delete [] wszAllHeaders;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    if (pbstrHeaders)
    {
        SysFreeString(*pbstrHeaders);
        *pbstrHeaders = NULL;
    }
    goto Cleanup;
}


/*
 *  CHttpRequest::get_status
 *
 *  Purpose:
 *      Get the request status code
 *
 *  Parameters:
 *      plStatus        OUT     HTTP request status code
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::get_Status(long * plStatus)
{
    HRESULT hr = NOERROR;
    DWORD   cb = sizeof(DWORD);
    BOOL    fRetCode;
    DWORD   dwStatus;

    // Validate parameter
    if (IsBadWritePtr(plStatus, sizeof(long)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    fRetCode = HttpQueryInfoA(
                    _hHTTP,
                    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    &dwStatus,
                    &cb,
                    0);

    if (!fRetCode)
        goto ErrorFail;

    *plStatus = dwStatus;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


/*
 *  CHttpRequest::get_StatusText
 *
 *  Purpose:
 *      Get the request status text
 *
 *  Parameters:
 *      pbstrStatus     OUT     HTTP request status text
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::get_StatusText(BSTR * pbstrStatus)
{
    HRESULT     hr = NOERROR;
    WCHAR       wszStatusText[32];
    WCHAR *     pwszStatusText = wszStatusText;
    BOOL        fFreeStatusString = FALSE;
    DWORD       cb;
    BOOL        fRetCode;

    // Validate parameter
    if (IsBadWritePtr(pbstrStatus, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrStatus = NULL;

    cb = sizeof(wszStatusText) / sizeof(WCHAR);

RetryQuery:
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_STATUS_TEXT,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    pwszStatusText,
                    &cb,
                    0);

    if (!fRetCode)
    {
        // Check for ERROR_INSUFFICIENT_BUFFER error
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            // Reallocate the status text buffer
            if (fFreeStatusString)
                delete pwszStatusText;

            pwszStatusText = New WCHAR[cb];

            if (!pwszStatusText)
                goto ErrorOutOfMemory;

            fFreeStatusString = TRUE;

            goto RetryQuery;
        }
        else
        {
            goto ErrorFail;
        }
    }

    // Convert the status text to a BSTR
    *pbstrStatus = SysAllocString(pwszStatusText);

    if (!*pbstrStatus)
        goto ErrorOutOfMemory;

    hr = NOERROR;

Cleanup:
    if (fFreeStatusString)
        delete [] pwszStatusText;
    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::get_ResponseBody
 *
 *  Purpose:
 *      Retrieve the response body as a SAFEARRAY of UI1
 *
 *  Parameters:
 *      pvarBody    OUT     Response blob
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_UNEXPECTED
 *      E_PENDING
 */

STDMETHODIMP
CHttpRequest::get_ResponseBody(VARIANT * pvarBody)
{
    HRESULT hr = NOERROR;

    // Validate parameter
    if (IsBadWritePtr(pvarBody, sizeof(VARIANT)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    VariantInit(pvarBody);

    if (_szResponseBuffer)
    {
        hr = CreateVector(
                pvarBody, 
                (const BYTE *)_szResponseBuffer,
                _cbResponseBody);

        if (FAILED(hr))
            goto Error;
    }
    else
    {
        V_VT(pvarBody) = VT_EMPTY;
    }

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    if (pvarBody)
        VariantClear(pvarBody);
    goto Cleanup;
}



/*
 *  CHttpRequest::get_ResponseText
 *
 *  Purpose:
 *      Retrieve the response body as a BSTR
 *
 *  Parameters:
 *      pbstrBody   OUT     response as a BSTR
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 *      E_PENDING
 */

STDMETHODIMP
CHttpRequest::get_ResponseText(BSTR * pbstrBody)
{
    HRESULT hr;

    // Validate parameter
    if (IsBadWritePtr(pbstrBody, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    hr = AsciiToBSTR(pbstrBody, _szResponseBuffer, (int)_cbResponseBody);
    
    if (FAILED(hr))
        goto Error;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::get_ResponseStream(VARIANT * pvarBody)
{
    HRESULT     hr = NOERROR;
    IStream *   pStm = NULL;

    // Validate parameter
    if (IsBadWritePtr(pvarBody, sizeof(VARIANT)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    VariantInit(pvarBody);

    hr = CreateStreamOnResponse(&pStm);
    
    if (FAILED(hr))
        goto Error;

    V_VT(pvarBody) = VT_UNKNOWN;
    pvarBody->punkVal = pStm;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    if (pvarBody)
        VariantClear(pvarBody);
    goto Cleanup;
}

void
CHttpRequest::SetState(State state)
{
    if (_fAsync)
    {
        InterlockedExchange((long *)&_eState, state);
    }
    else
    {
        _eState = state;
    }
}


/*
 *  CHttpRequest::CreateStreamOnResponse
 *
 *  Purpose:
 *      Create a Stream containing the Response data
 *
 *  Parameters:
 *      ppStm   IN/OUT      Stream
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 */

HRESULT
CHttpRequest::CreateStreamOnResponse(IStream ** ppStm)
{
    HRESULT         hr = NOERROR;
    ULONG           cbWritten;
    LARGE_INTEGER   liReset = { 0 };

    if (!ppStm)
        return E_INVALIDARG;

    *ppStm = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, ppStm);

    if (FAILED(hr))
        goto ErrorOutOfMemory;

    hr = (*ppStm)->Write(_szResponseBuffer, _cbResponseBody, &cbWritten);

    if (FAILED(hr))
        goto Error;

    hr = (*ppStm)->Seek(liReset, STREAM_SEEK_SET, NULL);

    if (FAILED(hr))
        goto Error;

    hr = NOERROR;

Cleanup:
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

Error:
    if (ppStm)
        SafeRelease(*ppStm);
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::get_Option(WinHttpRequestOption Option, VARIANT * Value)
{
    HRESULT     hr;

    if (IsBadWritePtr(Value, sizeof(VARIANT)))
        return E_INVALIDARG;

    switch (Option)
    {
    case WinHttpRequestOption_UserAgentString:
        {
            V_BSTR(Value) = SysAllocString(GetUserAgentString());

            if (V_BSTR(Value) == NULL)
                goto ErrorOutOfMemory;

            V_VT(Value) = VT_BSTR;

            break;
        }

    case WinHttpRequestOption_URL:
        {
            WCHAR * pwszUrl = NULL;
            DWORD   dwBufferSize = 0;

            if (_eState < CHttpRequest::OPENED)
                goto ErrorCannotCallBeforeOpen;

            if (!WinHttpQueryOption(_hHTTP, WINHTTP_OPTION_URL, NULL, &dwBufferSize) &&
                (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pwszUrl = New WCHAR[dwBufferSize + 1];

                if (!pwszUrl)
                    goto ErrorOutOfMemory;

                if (WinHttpQueryOption(_hHTTP, WINHTTP_OPTION_URL, pwszUrl, &dwBufferSize))
                {
                    V_BSTR(Value) = SysAllocString(pwszUrl);
                    V_VT(Value)   = VT_BSTR;

                    hr = NOERROR;
                }
                else
                {
                    hr = E_FAIL;
                }

                delete [] pwszUrl;

                if (FAILED(hr))
                {
                    goto ErrorFail;
                }
                else if (V_BSTR(Value) == NULL)
                {
                    goto ErrorOutOfMemory;
                }
            }
            break;
        }

    case WinHttpRequestOption_URLCodePage:
        V_I4(Value) = (long) _dwCodePage;
        V_VT(Value) = VT_I4;
        break;
    
    case WinHttpRequestOption_EscapePercentInURL:
        V_BOOL(Value) = (_dwEscapePercentFlag==WINHTTP_FLAG_ESCAPE_PERCENT) ? VARIANT_TRUE : VARIANT_FALSE;
        V_VT(Value)   = VT_BOOL;
        break;

    case WinHttpRequestOption_EnableRedirects:
        V_BOOL(Value) = _bDisableRedirects ? VARIANT_FALSE : VARIANT_TRUE;
        V_VT(Value)   = VT_BOOL;
        break;

    default:
        VariantInit(Value);
        return E_INVALIDARG;
    }    

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::put_Option(WinHttpRequestOption Option, VARIANT Value)
{
    HRESULT     hr;

    if (!IsValidVariant(Value))
        return E_INVALIDARG;

    switch (Option)
    {
    case WinHttpRequestOption_UserAgentString:
        {
            BSTR bstrUserAgent = GetBSTRFromVariant(Value);

            if (!bstrUserAgent || (*bstrUserAgent == L'\0'))
                return E_INVALIDARG;

            if (_hInet)
            {
                if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_USER_AGENT,
                        bstrUserAgent,
                        SysStringLen(bstrUserAgent)))
                {
                    goto ErrorFail;
                }
            }

            if (_hHTTP)
            {
                if (!WinHttpSetOption(_hHTTP, WINHTTP_OPTION_USER_AGENT,
                        bstrUserAgent,
                        SysStringLen(bstrUserAgent)))
                {
                    goto ErrorFail;
                }
            }

            if (_bstrUserAgent)
                SysFreeString(_bstrUserAgent);
            _bstrUserAgent = bstrUserAgent;
            break;
        }

    case WinHttpRequestOption_URL:
        // The URL cannot be set using the Option property.
        return E_INVALIDARG;

    case WinHttpRequestOption_URLCodePage:
        {
            _dwCodePage = GetDwordFromVariant(Value, CP_UTF8);

            if (_hInet)
            {
                if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_CODEPAGE,
                            &_dwCodePage,
                            sizeof(_dwCodePage)))
                    goto ErrorFail;
            }

            if (_hConnection)
            {
                if (!WinHttpSetOption(_hConnection, WINHTTP_OPTION_CODEPAGE,
                            &_dwCodePage,
                            sizeof(_dwCodePage)))
                    goto ErrorFail;
            }

            break;
        }
    
    case WinHttpRequestOption_EscapePercentInURL:
        {
            BOOL fEscapePercent = GetBoolFromVariant(Value, FALSE);

            _dwEscapePercentFlag = (fEscapePercent ? WINHTTP_FLAG_ESCAPE_PERCENT : 0);
            break;
        }

    case WinHttpRequestOption_SslErrorIgnoreFlags:
        {
            DWORD dwSslIgnoreFlags = GetDwordFromVariant(Value, _dwSslIgnoreFlags);
            if (dwSslIgnoreFlags & ~SECURITY_INTERNET_MASK)
            {
                return E_INVALIDARG;
            }

            // Break automatically, so we don't need the overhead of a callback.
            dwSslIgnoreFlags |= SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE;

            if (_hHTTP)
            {
                // Set the SSL ignore flags through an undocumented front door
                if (!WinHttpSetOption(_hHTTP,
                                     WINHTTP_OPTION_SECURITY_FLAGS,
                                     (LPVOID)&dwSslIgnoreFlags,
                                     sizeof(dwSslIgnoreFlags)))
                    goto ErrorFail;
            }
            _dwSslIgnoreFlags = dwSslIgnoreFlags;
            break;
        }

    case WinHttpRequestOption_SelectCertificate:
        {
            BSTR bstrCertSubject = GetBSTRFromVariant(Value);

            if (!bstrCertSubject)
            {
                // Allow all empty calls to be interpreted as "first enum"
                bstrCertSubject = SysAllocString(L"");
                if (!bstrCertSubject)
                    return E_OUTOFMEMORY;
            }
            if (_bstrCertSubject)
                SysFreeString(_bstrCertSubject);
            _bstrCertSubject = bstrCertSubject;
            break;
        }

    case WinHttpRequestOption_EnableRedirects:
        {
            BOOL fEnableRedirects = GetBoolFromVariant(Value, TRUE);

            _bDisableRedirects = fEnableRedirects ? false : true;
            break;
        }

    default:
        return E_INVALIDARG;
    }    

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


void
CHttpRequest::SetErrorInfo(HRESULT hr)
{
    if (SUCCEEDED(hr))
        return;
    
    ICreateErrorInfo *  pCErrInfo     = NULL;
    IErrorInfo *        pErrInfo      = NULL;
    DWORD               error         = hr;
    DWORD               dwFmtMsgFlag  = FORMAT_MESSAGE_FROM_SYSTEM;
    HMODULE             hModule       = NULL;
    DWORD               rc;
    LPWSTR              pwszMessage   = NULL;
    const DWORD         dwSize        = 512;

    pwszMessage = New WCHAR[dwSize];
    if (pwszMessage == NULL)
        return;
    
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        DWORD errcode = HRESULT_CODE(hr);

        if ((errcode > WINHTTP_ERROR_BASE) && (errcode <= WINHTTP_ERROR_LAST))
        {
            dwFmtMsgFlag = FORMAT_MESSAGE_FROM_HMODULE;

            hModule = GetModuleHandle("WINHTTP5.DLL");

            error = errcode;
        }
    }

    rc = ::FormatMessageW(dwFmtMsgFlag, hModule, 
                error, 
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                pwszMessage,
                dwSize,
                NULL);

    if (rc != 0)
    {
        if (SUCCEEDED(::CreateErrorInfo(&pCErrInfo)))
        {
            if (SUCCEEDED(pCErrInfo->QueryInterface(IID_IErrorInfo, (void **) &pErrInfo)))
            {
                pCErrInfo->SetSource(L"WinHttp.WinHttpRequest");
        
                pCErrInfo->SetGUID(IID_IWinHttpRequest);

                pCErrInfo->SetDescription(pwszMessage);
        
                ::SetErrorInfo(0, pErrInfo);

                pErrInfo->Release();
            }

            pCErrInfo->Release();
        }
    }

    delete [] pwszMessage;
}



BOOL
CHttpRequest::SelectCertificate()
{
    HCERTSTORE hMyStore = NULL;
    BOOL fRet = FALSE;
    HANDLE  hThreadToken = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    
    // If impersonating, revert while trying to obtain the cert
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
            FALSE,
            &hThreadToken))
    {
        INET_ASSERT(hThreadToken != 0);

        RevertToSelf();
    }

    // For now, just pick the first enum available
    // based on a simple CERT_ FIND_SUBJECT_STR criteria
    // If the user selected an empty string, then simply
    // pick the first enum.
    hMyStore = CertOpenSystemStore(NULL, "MY");
    if (!hMyStore)
    {
        goto Cleanup;
    }

    if (_bstrCertSubject && _bstrCertSubject[0])
    {
        pCertContext = CertFindCertificateInStore(hMyStore,
                                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_SUBJECT_STR,
                                                  (LPVOID) _bstrCertSubject,
                                                  NULL);
    }
    else
    {
        pCertContext = CertFindCertificateInStore(hMyStore,
                                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);
    }

    // Winhttp5 will add a couple of new options.
    // One will be an option to request that client auth
    // certs are not cached, so they can be session based.
    // Another will be for flushing the SSL cache on demand.
    //
    // For now, set this via a private method off of the
    // request object.
    if (pCertContext)
    {
        fRet = WinHttpSetOption(_hHTTP,
                                WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                                (LPVOID) pCertContext,
                                sizeof(CERT_CONTEXT));
    }

Cleanup:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (hMyStore)
        CertCloseStore(hMyStore, 0);
    
    // Restore the impersonating state for the current thread.
    if (hThreadToken)
    {
        SetThreadToken(NULL, hThreadToken);
        CloseHandle(hThreadToken);
    }
    return fRet;
}


/*
 *  BSTRToUTF8
 *
 *  Purpose:
 *      Convert a BSTR to UTF-8
 *
 */

static
HRESULT 
BSTRToUTF8(char ** psz, DWORD * pcbUTF8, BSTR bstr)
{
    UINT    cch = lstrlenW(bstr);
    
    *pcbUTF8 = 0;
    *psz     = NULL;
    
    if (cch == 0)
        return NOERROR;

    // Allocate the maximum buffer the UTF-8 string could be
    *psz = New char [(cch * 3) + 1];
    
    if (!*psz)
        return E_OUTOFMEMORY;

    *pcbUTF8 = cch * 3;

    WideCharToUtf8(bstr, cch, (BYTE *)*psz, (UINT *)pcbUTF8);

    (*psz)[*pcbUTF8] = 0;

    return NOERROR;
}



/**
 * Scans buffer and translates Unicode characters into UTF8 characters
 */
static
void
WideCharToUtf8(
    WCHAR * buffer, 
    UINT    cch,
    BYTE *  bytebuffer,
    UINT *  cb)
{
    UINT count = 0, m1 = *cb, m2 = m1 - 1, m3 = m2 - 1, m4 = m3 - 1;
    DWORD dw1;
    bool surrogate = false;

    for (UINT i = cch; i > 0; i--)
    {
        DWORD dw = *buffer;

        if (surrogate) //  is it the second char of a surrogate pair?
        {
            if (dw >= 0xdc00 && dw <= 0xdfff)
            {
                // four bytes 0x11110xxx 0x10xxxxxx 0x10xxxxxx 0x10xxxxxx
                if (count < m4)
                    count += 4;
                else
                    break;
                ULONG ucs4 = (dw1 - 0xd800) * 0x400 + (dw - 0xdc00) + 0x10000;
                *bytebuffer++ = (byte)(( ucs4 >> 18) | 0xF0);
                *bytebuffer++ = (byte)((( ucs4 >> 12) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)((( ucs4 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( ucs4 & 0x3F) | 0x80);
                surrogate = false;
                buffer++;
                continue;
            }
            else // Then dw1 must be a three byte character
            {
                if (count < m3)
                    count += 3;
                else
                    break;
                *bytebuffer++ = (byte)(( dw1 >> 12) | 0xE0);
                *bytebuffer++ = (byte)((( dw1 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( dw1 & 0x3F) | 0x80);
            }
            surrogate = false;
        }

        if (dw  < 0x80) // one byte, 0xxxxxxx
        {
            if (count < m1)
                count++;
            else
                break;
            *bytebuffer++ = (byte)dw;
        }
        else if ( dw < 0x800) // two WORDS, 110xxxxx 10xxxxxx
        {
            if (count < m2)
                count += 2;
            else
                break;
            *bytebuffer++ = (byte)((dw >> 6) | 0xC0);
            *bytebuffer++ = (byte)((dw & 0x3F) | 0x80);
        }
        else if (dw >= 0xd800 && dw <= 0xdbff) // Assume that it is the first char of surrogate pair
        {
            if (i == 1) // last wchar in buffer
                break;
            dw1 = dw;
            surrogate = true;
        }
        else // three bytes, 1110xxxx 10xxxxxx 10xxxxxx
        {
            if (count < m3)
                count += 3;
            else
                break;
            *bytebuffer++ = (byte)(( dw >> 12) | 0xE0);
            *bytebuffer++ = (byte)((( dw >> 6) & 0x3F) | 0x80);
            *bytebuffer++ = (byte)(( dw & 0x3F) | 0x80);
        }
        buffer++;
    }

    *cb = count;
}


/*
 *  AsciiToBSTR
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR
 *
 */

static
HRESULT 
AsciiToBSTR(BSTR * pbstr, char * sz, int cch)
{
    int cwch;

    // Determine how big the ascii string will be
    cwch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                NULL, 0);

    *pbstr = SysAllocStringLen(NULL, cwch);

    if (!*pbstr)
        return E_OUTOFMEMORY;

    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                *pbstr, cwch);

    return NOERROR;
}


/*
 *  BSTRToAscii
 *
 *  Purpose:
 *      Convert a BSTR to an ascii string
 *
 */

static
HRESULT 
BSTRToAscii(char ** psz, BSTR bstr)
{
    int cch;

    *psz = NULL;

    if (!bstr)
        return S_OK;


    // Determine how big the ascii string will be
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                NULL, 0, NULL, NULL);

    *psz = New char[cch + 1];

    if (!*psz)
        return E_OUTOFMEMORY;

    // Determine how big the ascii string will be
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                *psz, cch, NULL, NULL);

    (*psz)[cch] = 0;
    
    return S_OK;
}



/*
 *  GetBSTRFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a BSTR
 *
 */

static BSTR GetBSTRFromVariant(VARIANT varVariant)
{
    VARIANT varTemp;
    HRESULT hr;
    BSTR    bstrResult = NULL;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
                V_VT(&varVariant) != VT_ERROR)
    {
        VariantInit(&varTemp);

        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_BSTR);

        if (FAILED(hr))
            goto Error;
        
        bstrResult = V_BSTR(&varTemp); // take over ownership of BSTR
    }

    hr = NOERROR;

Cleanup:
    // DON'T clear the variant because we stole the BSTR
    //VariantClear(&varTemp);
    return bstrResult;

Error:
    goto Cleanup;
}


/*
 *  GetBoolFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a Boolean
 *
 */

static BOOL GetBoolFromVariant(VARIANT varVariant, BOOL fDefault)
{
    HRESULT hr;
    BOOL    fResult = fDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_BOOL);
    
        if (FAILED(hr))
            goto Cleanup;
        
        fResult = V_BOOL(&varTemp) == VARIANT_TRUE ? TRUE : FALSE;
    }

    hr = NOERROR;

Cleanup:
    return fResult;
}


/*
 *  GetDwordFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a DWORD
 *
 */

static DWORD GetDwordFromVariant(VARIANT varVariant, DWORD dwDefault)
{
    HRESULT hr;
    DWORD   dwResult = dwDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_UI4);
    
        if (FAILED(hr))
            goto Cleanup;
        
        dwResult = V_UI4(&varTemp);
    }

    hr = NOERROR;

Cleanup:
    return dwResult;
}

/*
 *  GetDwordFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a DWORD
 *
 */

static long GetLongFromVariant(VARIANT varVariant, long lDefault)
{
    HRESULT hr;
    long    lResult = lDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_I4);
    
        if (FAILED(hr))
            goto Cleanup;
        
        lResult = V_I4(&varTemp);
    }

    hr = NOERROR;

Cleanup:
    return lResult;
}

/**
 * Helper to create a char safearray from a string
 */
static
HRESULT
CreateVector(VARIANT * pVar, const BYTE * pData, DWORD cElems)
{
    HRESULT hr;
    BYTE * pB;

    SAFEARRAY * psa = SafeArrayCreateVector(VT_UI1, 0, cElems);
    if (!psa)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SafeArrayAccessData(psa, (void **)&pB);
    if (hr)
        goto Error;

    memcpy(pB, pData, cElems);

    SafeArrayUnaccessData(psa);
    INET_ASSERT((pVar->vt == VT_EMPTY) || (pVar->vt == VT_NULL));
    V_ARRAY(pVar) = psa;
    pVar->vt = VT_ARRAY | VT_UI1;

    hr = NOERROR;

Cleanup:
    return hr;

Error:
    if (psa)
        SafeArrayDestroy(psa);
    goto Cleanup;
}


/*
 *  ReadFromStream
 *
 *  Purpose:
 *      Extract the contents of a stream into a buffer.
 *
 *  Parameters:
 *      ppBuf   IN/OUT      Buffer
 *      pStm    IN          Stream
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 */

static
HRESULT
ReadFromStream(char ** ppData, ULONG * pcbData, IStream * pStm)
{
    HRESULT     hr = NOERROR;
    char *      pBuffer = NULL;	    // Buffer
    ULONG       cbBuffer = 0;       // Bytes in buffer
    ULONG       cbData = 0;         // Bytes of data in buffer
    ULONG       cbRead = 0;         // Bytes read from stream
    ULONG       cbNewSize = 0;
    char *      pNewBuf = NULL;

    if (!ppData || !pStm)
        return E_INVALIDARG;

    *ppData = NULL;
    *pcbData = 0;
    
    while (TRUE)
    {
        if (cbData + 512 > cbBuffer)
        {
            cbNewSize = (cbData ? cbData*2 : 4096);
            pNewBuf = New char[cbNewSize+1];

            if (!pNewBuf)
                goto ErrorOutOfMemory;

            if (cbData)
                ::memcpy(pNewBuf, pBuffer, cbData);

            cbBuffer = cbNewSize;
            delete[] pBuffer;
            pBuffer = pNewBuf;
            pBuffer[cbData] = 0;
        }

        hr = pStm->Read(
                    &pBuffer[cbData],
                    cbBuffer - cbData,
                    &cbRead);

        if (FAILED(hr))
            goto Error;
            
        cbData += cbRead;
        pBuffer[cbData] = 0;

        // No more data
        if (cbRead == 0)
            break;
    }

    *ppData = pBuffer;
    *pcbData = cbData;

    hr = NOERROR;

Cleanup:
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

Error:
    if (pBuffer)
        delete [] pBuffer;
    goto Cleanup;
}


static
void
MessageLoop()
{
    MSG     msg;

    // There is a window message available. Dispatch it.
    while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


static
DWORD
UpdateTimeout(DWORD dwTimeout, DWORD dwStartTime)
{
    if (dwTimeout != INFINITE)
    {
        DWORD   dwTimeNow = GetTickCount();
        DWORD   dwElapsedTime;

        if (dwTimeNow >= dwStartTime)
        {
            dwElapsedTime = dwTimeNow - dwStartTime;
        }
        else
        {
            dwElapsedTime = dwTimeNow + (0xFFFFFFFF - dwStartTime);
        }

        if (dwElapsedTime < dwTimeout)
        {
            dwTimeout -= dwElapsedTime;
        }
        else
        {
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}


DWORD CSinkArray::Add(IUnknown * pUnk)
{
    ULONG iIndex;

    IUnknown** pp = NULL;

    if (_nSize == 0) // no connections
    {
	_pUnk = pUnk;
	_nSize = 1;
	return 1;
    }
    else if (_nSize == 1)
    {
	// create array
	pp = (IUnknown **)ALLOCATE_FIXED_MEMORY(sizeof(IUnknown*)* _DEFAULT_VECTORLENGTH);
	if (pp == NULL)
		return 0;
	memset(pp, 0, sizeof(IUnknown *) * _DEFAULT_VECTORLENGTH);
	*pp = _pUnk;
	_ppUnk = pp;
	_nSize = _DEFAULT_VECTORLENGTH;
    }

    for (pp = begin(); pp < end(); pp++)
    {
	if (*pp == NULL)
	{
	    *pp = pUnk;
	    iIndex = ULONG(pp-begin());
	    return iIndex+1;
	}
    }

    int nAlloc = _nSize*2;
    pp = (IUnknown **)REALLOCATE_MEMORY(_ppUnk, sizeof(IUnknown*)*nAlloc, LMEM_ZEROINIT);
    if (pp == NULL)
	return 0;

    _ppUnk = pp;
    memset(&_ppUnk[_nSize], 0, sizeof(IUnknown *)*_nSize);
    _ppUnk[_nSize] = pUnk;
    iIndex = _nSize;
    _nSize = nAlloc;
    return iIndex+1;
}

BOOL CSinkArray::Remove(DWORD dwCookie)
{
    ULONG iIndex;

    if (dwCookie == NULL)
        return FALSE;
    if (_nSize == 0)
        return FALSE;
    iIndex = dwCookie-1;
    if (iIndex >= (ULONG)_nSize)
        return FALSE;
    if (_nSize == 1)
    {
        _nSize = 0;
        return TRUE;
    }
    begin()[iIndex] = NULL;
    return TRUE;
}

void CSinkArray::ReleaseAll()
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            SafeRelease(*pp);
	}
    }
}


HRESULT STDMETHODCALLTYPE
CSinkArray::QueryInterface(REFIID, void **)
{
    return E_NOTIMPL;
}


ULONG STDMETHODCALLTYPE
CSinkArray::AddRef()
{
    return 2;
}


ULONG STDMETHODCALLTYPE
CSinkArray::Release()
{
    return 1;
}

void STDMETHODCALLTYPE
CSinkArray::OnResponseStart(long Status, BSTR bstrContentType)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[3]) != NULL)
            {
                pSink->OnResponseStart(Status, bstrContentType);
            }
	}
    }
}


void STDMETHODCALLTYPE
CSinkArray::OnResponseDataAvailable(SAFEARRAY ** ppsaData)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[4]) != NULL)
            {
                pSink->OnResponseDataAvailable(ppsaData);
            }
	}
    }
}


void STDMETHODCALLTYPE
CSinkArray::OnResponseFinished(void)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[5]) != NULL)
            {
                pSink->OnResponseFinished();
            }
	}
    }
}


CWinHttpRequestEventsMarshaller::CWinHttpRequestEventsMarshaller
(
    CSinkArray *    pSinkArray,
    HWND            hWnd
)
{
    INET_ASSERT((pSinkArray != NULL) && (hWnd != NULL));

    _pSinkArray  = pSinkArray;
    _hWnd        = hWnd;
    _cRefs       = 0;
    _bFireEvents = true;

    _cs.Init();
}


CWinHttpRequestEventsMarshaller::~CWinHttpRequestEventsMarshaller()
{
    INET_ASSERT(_pSinkArray == NULL);
    INET_ASSERT(_hWnd == NULL);
    INET_ASSERT(_cRefs == 0);
}


HRESULT
CWinHttpRequestEventsMarshaller::Create
(
    CSinkArray *                        pSinkArray,
    CWinHttpRequestEventsMarshaller **  ppSinkMarshaller
)
{
    CWinHttpRequestEventsMarshaller *   pSinkMarshaller = NULL;
    HWND                                hWnd = NULL;
    HRESULT                             hr = NOERROR;


    if (!RegisterWinHttpEventMarshallerWndClass())
        goto ErrorFail;

    hWnd = CreateWindowEx(0, s_szWinHttpEventMarshallerWndClass, NULL,
                0, 0, 0, 0, 0, 
                (IsPlatformWinNT() && GlobalPlatformVersion5) ? HWND_MESSAGE : NULL, 
                NULL, GlobalDllHandle, NULL);

    if (!hWnd)
        goto ErrorFail;

    pSinkMarshaller = New CWinHttpRequestEventsMarshaller(pSinkArray, hWnd);

    if (!pSinkMarshaller)
        goto ErrorOutOfMemory;

    SetLastError(0);
    
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pSinkMarshaller);

    if (GetLastError() != 0)
        goto ErrorFail;

    pSinkMarshaller->AddRef();

    *ppSinkMarshaller = pSinkMarshaller;

Exit:
    if (FAILED(hr))
    {
        if (pSinkMarshaller)
        {
            delete pSinkMarshaller;
        }
        else if (hWnd)
        {
            DestroyWindow(hWnd);
        }
    }

    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Exit;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Exit;
}


void
CWinHttpRequestEventsMarshaller::Shutdown()
{
    if (_cs.Lock())
    {
        FreezeEvents();

        if (_hWnd)
        {
            MessageLoop();

            DestroyWindow(_hWnd);
            _hWnd = NULL;
        }

        _pSinkArray = NULL;

        _cs.Unlock();
    }
}


LRESULT CALLBACK
CWinHttpRequestEventsMarshaller::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg >= WHREM_MSG_ON_RESPONSE_START && msg <= WHREM_MSG_ON_RESPONSE_FINISHED)
    {
        CWinHttpRequestEventsMarshaller *   pMarshaller;
        CSinkArray *                        pSinkArray;
        bool                                bOkToFireEvents = false;

        pMarshaller = (CWinHttpRequestEventsMarshaller *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (pMarshaller)
        {
            pSinkArray = pMarshaller->GetSinkArray();
            bOkToFireEvents = pMarshaller->OkToFireEvents();
        }

        switch (msg)
        {
        case WHREM_MSG_ON_RESPONSE_START:
            {
                BSTR bstrContentType = (BSTR) lParam;

                if (bOkToFireEvents)
                {
                    pSinkArray->OnResponseStart((long) wParam, bstrContentType);
                }

                if (bstrContentType)
                {
                    SysFreeString(bstrContentType);
                }
            }
            break;

        case WHREM_MSG_ON_RESPONSE_DATA_AVAILABLE:
            {
                SAFEARRAY * psaData = (SAFEARRAY *) wParam;

                if (bOkToFireEvents)
                {
                    pSinkArray->OnResponseDataAvailable(&psaData);
                }

                if (psaData)
                {
                    SafeArrayDestroy(psaData);
                }
            }
            break;

        case WHREM_MSG_ON_RESPONSE_FINISHED:
            if (bOkToFireEvents)
            {
                pSinkArray->OnResponseFinished();
            }
            break;
        }

        return 0;
    }
    else
    {
        return DefWindowProc(hWnd, msg, wParam, lParam);
    }
}


HRESULT STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;

    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IWinHttpRequestEvents || riid == IID_IUnknown)
    {
        *ppv = static_cast<IWinHttpRequestEvents *>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}



ULONG STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::AddRef()
{
    return InterlockedIncrement(&_cRefs);
}


ULONG STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::Release()
{
    DWORD cRefs = InterlockedDecrement(&_cRefs);

    if (cRefs == 0)
    {
        delete this;
        return 0;
    }
    else
        return cRefs;
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseStart(long Status, BSTR bstrContentType)
{
    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            BSTR    bstrContentTypeCopy;

            bstrContentTypeCopy = SysAllocString(bstrContentType);

            PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_START,
                (WPARAM) Status,
                (LPARAM) bstrContentTypeCopy);

            // Note: ownership of bstrContentType is transferred to the 
            // message window, so the string is not freed here.
        }
        _cs.Unlock();
    }
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseDataAvailable(SAFEARRAY ** ppsaData)
{

    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            SAFEARRAY * psaDataCopy = NULL;

            if (SUCCEEDED(SafeArrayCopy(*ppsaData, &psaDataCopy)))
            {
                PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_DATA_AVAILABLE,
                    (WPARAM) psaDataCopy, 0);
            }

            // Note: ownership of psaDataCopy is transferred to the 
            // message window, so the array is not freed here.
        }
        _cs.Unlock();
    }
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseFinished(void)
{
    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_FINISHED, 0, 0);
        }

        _cs.Unlock();
    }
}



BOOL RegisterWinHttpEventMarshallerWndClass()
{
    if (s_fWndClassRegistered)
        return TRUE;

    // only one thread should be here
    if (!GeneralInitCritSec.Lock())
        return FALSE;

    if (s_fWndClassRegistered == FALSE)
    {
        WNDCLASS    wndclass;

        wndclass.style          = 0;
        wndclass.lpfnWndProc    = &CWinHttpRequestEventsMarshaller::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = GlobalDllHandle;
        wndclass.hIcon          = NULL;
        wndclass.hCursor        = NULL;;
        wndclass.hbrBackground  = (HBRUSH)NULL;
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = s_szWinHttpEventMarshallerWndClass;

        // Register the window class
        if (RegisterClass(&wndclass))
        {
            s_fWndClassRegistered = TRUE;
        }
    }

    GeneralInitCritSec.Unlock();

    return s_fWndClassRegistered;
}


void CleanupWinHttpRequestGlobals()
{
    if (s_fWndClassRegistered)
    {
        // Register the window class
        if (UnregisterClass(s_szWinHttpEventMarshallerWndClass, GlobalDllHandle))
        {
            s_fWndClassRegistered = FALSE;
        }
    }
}


static
BOOL
IsValidVariant(VARIANT v)
{
    BOOL    fOk = TRUE;

    if (V_ISBYREF(&v))
    {
        if (IsBadReadPtr(v.pvarVal, sizeof(VARIANT)))
        {
            fOk = FALSE;
            goto Exit;
        }
        else
            v = *(v.pvarVal);
    }

    switch (v.vt)
    {
    case VT_BSTR:
        fOk = IsValidBstr(v.bstrVal);
        break;

    case (VT_BYREF | VT_BSTR):
        fOk = !IsBadReadPtr(v.pbstrVal, sizeof(BSTR));
        break;

    case (VT_BYREF | VT_VARIANT):
        fOk = !IsBadReadPtr(v.pvarVal, sizeof(VARIANT)) &&
               IsValidVariant(*(v.pvarVal));
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        fOk = !IsBadReadPtr(v.punkVal, sizeof(void *));
        break;
    }

Exit:
    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\dummy.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dummy.cxx

Abstract:

    Dummy file for build so we can generate the precompiled header for the
    internet project

    Contents:

Author:

     Richard L Firth (rfirth) 03-Feb-1995

Revision History:

    03-Feb-1995
        Created

--*/

#include "wininetp.h"

void __cdecl main(int, char**);

void __cdecl main(int argc, char** argv) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\handle.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header file for common\handle.cxx

Author:

    Richard L Firth (rfirth) 01-Nov-1994

Revision History:

    01-Nov-1994 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
HandleInitialize(
    VOID
    );

VOID
HandleTerminate(
    VOID
    );

DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    );

DWORD
FreeHandle(
    IN HINTERNET Handle
    );

DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    );

DWORD
DereferenceObject(
    IN LPVOID lpObject
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\inetchar.h ===
#ifndef INETCHAR_H

#define INETCHAR_H

/* Copyright (c) 1998  Microsoft Corporation

Module Name:

    inetchar.h

Abstract:

    macros for converting between Unicode and MultiByte characters.

    Contents:
        REASSIGN_ALLOC
        REASSIGN_SIZE
        ALLOC_MB
        UNICODE_TO_ANSI
        
Author:

    Ahsan S. Kabir  

Revision History:

    18Nov97 akabir
        Created

*/

//

// ---- Macros to simplify recovering values from memory packets -------------

#define REASSIGN_ALLOC(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwAlloc;
    
#define REASSIGN_SIZE(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwSize;


// -- (MAYBE_)ALLOC_MB ------------
// Macros to allocate enough memory for an ansi-equivalent string

#define ALLOC_MB(URLW,DWW,MPMP) { \
    MPMP.dwAlloc = ((DWW ? DWW : lstrlenW(URLW))+ 1)*sizeof(WCHAR); \
    MPMP.psStr = (LPSTR)ALLOC_BYTES(MPMP.dwAlloc*sizeof(CHAR)); }


// -- UNICODE_TO_ANSI -----
// Base case macro to convert from unicode to ansi
// We're subtracting 1 because we're converting the nullchar in dwAlloc.

#define UNICODE_TO_ANSI(pszW, mpA) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,NULL); \
        mpA.psStr[mpA.dwSize]= '\0';

#define UNICODE_TO_ANSI_CHECKED(pszW, mpA, pfNotSafe) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,pfNotSafe); \
        mpA.psStr[mpA.dwSize]= '\0';

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\defaults.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    defaults.h

Abstract:

    Contains all default manifests for WININET

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

//
// default timeout values and retry counts
//

#define DEFAULT_RESOLVE_TIMEOUT             INFINITE
#define DEFAULT_CONNECT_TIMEOUT             ((LONG)1*60*1000)   // 1 minute
#define DEFAULT_CONNECT_RETRIES             5
#ifndef unix
#define DEFAULT_SEND_TIMEOUT                ((LONG)30*1000)     // 30 seconds
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)30*1000)     // 30 seconds
#else
#define DEFAULT_SEND_TIMEOUT                ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minutes
#endif /* unix */
#define DEFAULT_KEEP_ALIVE_TIMEOUT          (1 * 60 * 1000)         // 1 minute
#define DEFAULT_FROM_CACHE_TIMEOUT          (5 * 1000)              // 5 seconds
#define DEFAULT_DNS_CACHE_ENTRIES           32
#define DEFAULT_DNS_CACHE_TIMEOUT           (30 * 60)               // 30 minutes
#define DEFAULT_MAX_HTTP_REDIRECTS          100
#define DEFAULT_MAX_CONNECTIONS_PER_SERVER  2                       // default HTTP 1.1
#define DEFAULT_MAX_CONS_PER_1_0_SERVER     4                       // default HTTP 1.0
#define DEFAULT_CONNECTION_LIMIT_TIMEOUT    (1 * 60 * 1000)         // 1 minute
#define DEFAULT_CONNECTION_INACTIVE_TIMEOUT (10 * 1000)             // 10 seconds
#define DEFAULT_SERVER_INFO_TIMEOUT         (2 * 60 * 1000)         // 2 minutes
#define DEFAULT_NETWORK_OFFLINE_TIMEOUT     (5 * 1000)              // 5 seconds
#define DEFAULT_DIAL_UP_OFFLINE_TIMEOUT     (20 * 1000)             // 20 seconds
#define DEFAULT_IDLE_TIMEOUT                1000                    // 1 second
#define DEFAULT_NETWORK_PING_RETRIES        1
#define DEFAULT_DIAL_UP_PING_RETRIES        4

//
// thread pool default constants
//

#define DEFAULT_MINIMUM_THREADS     0
#define DEFAULT_MAXIMUM_THREADS     4   // arbitrary
#define DEFAULT_INITIAL_THREADS     1
#define DEFAULT_THREAD_IDLE_TIMEOUT (2 * 60 * 1000) // 2 minutes
#define DEFAULT_WORK_QUEUE_LIMIT    8
#define DEFAULT_WORK_ITEM_PRIORITY  0

//
// async scheduler thread default constants
//

#define DEFAULT_WORKER_THREAD_TIMEOUT       (2 * 60 * 1000)        // 2 minutes
#define DEFAULT_MAXIMUM_QUEUE_DEPTH         2
#define DEFAULT_FIBER_STACK_SIZE            (16 K)
#define DEFAULT_CREATE_FIBER_ATTEMPTS       4

//
// default sizes
//

#define DEFAULT_RECEIVE_BUFFER_INCREMENT        (1 K)
#define DEFAULT_TRANSPORT_PACKET_LENGTH         (1 K)
#define DEFAULT_HTML_QUERY_BUFFER_LENGTH        (4 K)
#define DEFAULT_SOCKET_SEND_BUFFER_LENGTH       ((DWORD)-1)
#define DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH    ((DWORD)-1)
#define DEFAULT_SOCKET_QUERY_BUFFER_LENGTH      (8 K)

//
// default strings
//

#define DEFAULT_HTTP_REQUEST_VERB       "GET"
#define DEFAULT_EMAIL_NAME              "user@domain"
#define DEFAULT_URL_SCHEME_NAME         "http"

// default SSL protocols
#define DEFAULT_SECURE_PROTOCOLS        (SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\inetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetp.h

Abstract:

    Contains the Internet Gateway Service private functions proto type
    definitions.

Author:

    Madan Appiah  (madana)  11-Nov-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _INETP_
#define _INETP_

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

typedef enum {
    TypeGenericHandle = 'HneG',
    TypeInternetHandle = 'tenI',
    TypeFtpConnectHandle = 'noCF',
    TypeFtpFindHandle = 'dnFF',
    TypeFtpFindHandleHtml = 'HnFF',
    TypeFtpFileHandle = 'liFF',
    TypeFtpFileHandleHtml = 'HlFF',
    TypeGopherConnectHandle = 'noCG',
    TypeGopherFindHandle = 'dnFG',
    TypeGopherFindHandleHtml = 'HnFG',
    TypeGopherFileHandle = 'liFG',
    TypeGopherFileHandleHtml = 'HlFG',
    TypeHttpConnectHandle = 'noCH',
    TypeHttpRequestHandle = 'qeRH',
    TypeFileRequestHandle = 'flRH',
    TypeWildHandle = 'dliW'
} HINTERNET_HANDLE_TYPE, *LPHINTERNET_HANDLE_TYPE;

//
// typedef virtual close function.
//

typedef BOOL ( *CLOSE_HANDLE_FUNC ) ( HINTERNET );
typedef BOOL ( *CONNECT_CLOSE_HANDLE_FUNC ) ( HINTERNET, DWORD );

//
// prototypes
//

BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    );

DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    );

//
// remote/RPC/object functions
//

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    );

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    );

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    );

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    );

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    );

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    );

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    );

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    );

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    );

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    );

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    );

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback
    );

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType,
    IN DWORD dwFlags
    );

DWORD
RMakeInternetConnectObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    LPSTR lpszServerName,
    INTERNET_PORT nServerPort,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

DWORD
RMakeHttpReqObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );


//
// non-exported Internet subordinate functions
//
DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    );

DWORD
HttpReadData(
    IN HINTERNET hHttpRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    );

PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

DWORD
pHttpGetUrlInfo(
    IN HANDLE RequestHandle,
    IN LPBYTE Headers,
    IN DWORD HeadersLength,
    IN LPBYTE UrlBuf,
    IN OUT DWORD *UrlBufLen,
    IN BOOL ReloadFlagCheck
    );

BOOLAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlW
#else
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlA
#endif // !UNICODE

BOOLAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCombineUrlW(
    IN LPCWSTR lpszBaseUrl,
    IN LPCWSTR lpszRelativeUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCombineUrl  InternetCombineUrlW
#else
#define InternetCombineUrl  InternetCombineUrlA
#endif // !UNICODE

#if defined(__cplusplus)
}
#endif

#endif // _INETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    External definitions for data in dll\globals.c

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#if defined(__cplusplus)
extern "C" {
#endif

//
// macros
//

#define UPDATE_GLOBAL_PROXY_VERSION() \
    InterlockedIncrement((LPLONG)&GlobalProxyVersionCount)


#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


//
// external variables
//

extern HINSTANCE GlobalDllHandle;
#define GlobalResHandle     GlobalDllHandle  // change for plugable ui
extern DWORD GlobalPlatformType;
extern DWORD GlobalPlatformVersion5;
extern DWORD GlobalPlatformMillennium;

extern BOOL GlobalDataInitialized;

extern DWORD InternetMajorVersion;
extern DWORD InternetMinorVersion;
extern DWORD InternetBuildNumber;

extern const DWORD GlobalResolveTimeout;
extern const DWORD GlobalConnectTimeout;
extern const DWORD GlobalConnectRetries;
extern const DWORD GlobalSendTimeout;
extern const DWORD GlobalReceiveTimeout;
extern const DWORD GlobalFtpAcceptTimeout;
extern const DWORD GlobalTransportPacketLength;
extern const DWORD GlobalKeepAliveSocketTimeout;
extern const DWORD GlobalSocketSendBufferLength;
extern const DWORD GlobalSocketReceiveBufferLength;
extern const DWORD GlobalMaxHttpRedirects;
extern const DWORD GlobalMaxConnectionsPerServer;
extern const DWORD GlobalMaxConnectionsPer1_0Server;
extern const DWORD GlobalConnectionInactiveTimeout;
extern const DWORD GlobalServerInfoTimeout;

extern BOOL InDllCleanup;
extern BOOL GlobalDynaUnload;
extern BOOL GlobalDisableKeepAlive;
extern const DWORD GlobalSecureProtocols;
extern BOOL GlobalEnableHttp1_1;
extern BOOL GlobalEnableProxyHttp1_1;
extern BOOL GlobalDisableReadRange;
extern BOOL GlobalIsProcessExplorer;
extern const BOOL GlobalEnableFortezza;
extern HANDLE g_hCompletionPort;
extern LPOVERLAPPED g_lpCustomOverlapped;
#define COMPLETION_BYTES_CUSTOM ((DWORD)-1)
#define COMPLETION_BYTES_EXITIOCP ((DWORD)-2)
#define WINHTTP_GLOBAL_IOCP_THREADS_BACKUP 2
extern DWORD g_cNumIOCPThreads;

#if INET_DEBUG
extern LONG g_cWSACompletions;
extern LONG g_cCustomCompletions;
#endif

extern LONG g_cSessionCount;
class CAsyncCount
{
private:

    DWORD dwRef;

public:

    CAsyncCount()
    {
        dwRef = 0;
    }
    
    DWORD AddRef();
    VOID Release();
    //make sure you grab the GeneralInitCritSec before making this call.
    DWORD GetRef()
    {
        return dwRef;
    }
};
extern CAsyncCount* g_pAsyncCount;

extern const BOOL fDontUseDNSLoadBalancing;

extern BOOL GlobalWarnOnPost;
extern BOOL GlobalWarnAlways;

extern LONG GlobalInternetOpenHandleCount;
extern DWORD GlobalProxyVersionCount;
extern BOOL GlobalAutoProxyInInit;
extern BOOL GlobalAutoProxyCacheEnable;
extern BOOL GlobalDisplayScriptDownloadFailureUI;

extern SERIALIZED_LIST GlobalObjectList;

extern LONGLONG dwdwHttpDefaultExpiryDelta;
extern LONGLONG dwdwSessionStartTime;
extern LONGLONG dwdwSessionStartTimeDefaultDelta;

extern SECURITY_CACHE_LIST GlobalCertCache;

extern BOOL GlobalDisableNTLMPreAuth;

extern CCritSec AuthenticationCritSec;
extern CCritSec GeneralInitCritSec;
extern CCritSec LockRequestFileCritSec;
extern CCritSec AutoProxyDllCritSec;
extern CCritSec MlangCritSec;

extern GLOBAL PP_CONTEXT GlobalPassportContext;

extern const char vszSyncMode[];




extern INTERNET_VERSION_INFO InternetVersionInfo;
extern HTTP_VERSION_INFO HttpVersionInfo;
extern BOOL fCdromDialogActive;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

extern char gszAt[];
extern char gszBang[];
extern char gszCRLF[3];

//
// novell client32 (hack) "support"
//

extern BOOL GlobalRunningNovellClient32;
extern const BOOL GlobalNonBlockingClient32;


// shfolder.dll hmod handle
extern HMODULE g_HMODSHFolder;
// shell32.dll hmod handle
extern HMODULE g_HMODShell32;

extern DWORD GlobalIdentity;
extern GUID GlobalIdentityGuid;
#ifdef WININET6
extern HKEY GlobalCacheHKey;
#endif


//
// prototypes
//

BOOL
GlobalDllInitialize(
    VOID
    );

VOID
GlobalDllTerminate(
    VOID
    );

DWORD
GlobalDataInitialize(
    VOID
    );

VOID
GlobalDataTerminate(
    VOID
    );

BOOL
IsHttp1_1(
    VOID
    );

VOID
ChangeGlobalSettings(
    VOID
    );


typedef HRESULT
(STDAPICALLTYPE * PFNINETMULTIBYTETOUNICODE)
(
    LPDWORD  lpdword,
    DWORD    dwSrcEncoding,
    LPCSTR   lpSrcStr,
    LPINT    lpnSrcSize,
    LPWSTR   lpDstStr,
    LPINT    lpDstStrSize
);

// Loads Mlang and returns a pointer to the MultiByte to Unicode converter.
// Could return NULL if mlang.dll couldn't be loaded for some reason. 
PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( );

#if defined(__cplusplus)
}
#endif

#endif //_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\iwinsock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    iwinsock.hxx

Abstract:

    Contains prototypes for indirected sockets functions

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Moved into SOCKET_FUNC_ARRAY in order to supports Socks.

--*/

#if !defined(_IWINSOCK_)
#define _WINSOCK_

#if defined(__cplusplus)
extern "C" {
#endif

//
// includes
//

#include <winsock2.h>
#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

//
// prototypes
//

BOOL
IwinsockInitialize(
    VOID
    );

VOID
IwinsockTerminate(
    VOID
    );

DWORD
LoadWinsock(
    VOID
    );

VOID
UnloadWinsock(
    VOID
    );

DWORD
SafeCloseSocket(
    IN SOCKET Socket
    );

//
// sockets functions
//

extern
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

extern
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    );

extern
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    );

extern
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    );

extern
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    LPSTR lpHostName
    );

extern
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

extern
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    );

extern
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    );

extern
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    );

extern
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    );

extern
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    );

extern
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    );

extern
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    );

extern
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );

extern
int 
(PASCAL FAR * _I_WSARecv)(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesRecvd,                           
    LPDWORD lpFlags,                                        
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    );

extern
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    );

extern
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    );

extern
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_WSASend)(
    SOCKET s,                                                  
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    );

extern
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    );

extern
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    );

extern
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    );

extern
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    );

//
// WSA functions
//

extern
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    );

extern
int
(PASCAL FAR * _I_WSACleanup)(
    void
    );

extern
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    );

extern
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    );

extern
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    );

class CWrapOverlapped
{
    WSAOVERLAPPED m_Overlapped;
    LONG m_dwReferenceCount;

public:

    CWrapOverlapped()
    {
        //Don't need to zero out the overlapped struct here.
        // since we zero it out in the fsm's before using (see icsocket.cxx)
        m_dwReferenceCount = 1;
    }
    
    LONG Reference()
    {
        return InterlockedIncrement(&m_dwReferenceCount);
    }

    BOOL Dereference()
    {
        BOOL bRet = FALSE;
        LONG lResult = InterlockedDecrement(&m_dwReferenceCount);

        if (lResult == 0)
        {
            delete this;
            bRet = TRUE;
        }

        return bRet;
    }

    LPWSAOVERLAPPED GetOverlapped()
    {
        return &m_Overlapped;
    }

    friend CWrapOverlapped* GetWrapOverlappedObject(LPVOID lpAddress);
};
//
// macros
//

#ifndef unix
#if defined(FD_ISSET)
#undef FD_ISSET
#endif

#define FD_ISSET(fd, set) _I___WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))
#endif /* unix */

#if INET_DEBUG

VOID
IWinsockCheckSockets(
    VOID
    );

#define CHECK_SOCKETS() IWinsockCheckSockets()

#else

#define CHECK_SOCKETS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif

#endif // _IWINSOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\inetdbg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;

//
// INTERNET_DEBUG_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _INTERNET_DEBUG_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _INTERNET_DEBUG_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} INTERNET_DEBUG_RECORD, *LPINTERNET_DEBUG_RECORD;

//
// INTERNET_FUNCTION_TRIGGER - if we are required to trigger on a function, this
// structure maintains the debugging flags
//

typedef struct _INTERNET_FUNCTION_TRIGGER {

    //
    // Next - we maintain a singly-linked list of INTERNET_FUNCTION_TRIGGERs
    //

    struct _INTERNET_FUNCTION_TRIGGER* Next;

    //
    // Hash - hash value for the function name, to cut-down strcmp's to 1
    //

    DWORD Hash;

    //
    // Function - name of the function - must match exactly
    //

    LPCSTR Function;

    //
    // Category - category debug flags to use when this function triggers
    //

    DWORD MajorCategory;

} INTERNET_FUNCTION_TRIGGER, *LPINTERNET_FUNCTION_TRIGGER;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

LPSTR
InternetMapStatus(
    IN DWORD Status
    );

LPSTR
InternetMapOption(
    IN DWORD Option
    );

LPSTR
InternetMapSSPIError(
    IN DWORD Status
    );

LPSTR
InternetMapHttpOption(
    IN DWORD Option
    );

LPSTR
InternetMapHttpState(
    IN WORD State
    );

LPSTR
InternetMapHttpStateFlag(
    IN WORD Flag
    );

LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    );

LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    );

LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    );

LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    );

LPSTR
InternetMapService(
    IN DWORD Service
    );         

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN_VALUE eToken
    );

LPSTR
InternetMapChunkState(
    IN CHUNK_DECODE_STATE eState
    );

DWORD
InternetHandleCount(
    VOID
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// exceptn.cxx
//

VOID
SetExceptionHandler(
    VOID
    );

#else

#define dprintf (VOID)

#endif // #ifdef ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg
    
#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define SH_DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define SH_DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif
 
#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            SH_DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(RETAIL_LOGGING)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */
    
#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\makefile.inc ===
winhttp.h: winhttp.w
	hsplit -o winhttp.h internal.h winhttp.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\inetsspi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsspi.h

Abstract:

    Contains all constant values and prototype decls used in inetsspi.cxx

Author:

    Sophia Chung (SophiaC)  02-Jan-1996

Revision History:

--*/

#ifndef _INETSSPI_H_
#define _INETSSPI_H_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active
#define ENC_CAPS_SCHANNEL_CREDS    0x00000004       // Uses SCHANNEL Creds Struct

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

#define IS_CRED_INVALID(s) (((s)->dwUpper == 0xFFFFFFFF) && ((s)->dwLower == 0xFFFFFFFF))

typedef struct _SEC_PROVIDER
{
    CHAR            *pszName;          // security pkg name
    CredHandle      hCreds;           // credential handle
    DWORD           dwFlags;          // encryption capabilities
    BOOL            fEnabled;         // enable flag indicator
    DWORD           dwProtocolFlags;  // protocol flags that this provider supports.
    PCCERT_CONTEXT  pCertCtxt;        // cert context to use when getting default credentials.
} SEC_PROVIDER, *PSEC_PROVIDER;

//
//  Array of encryption providers
//

extern SEC_PROVIDER SecProviders[];

//
//  Global EncProvider flag
//

extern DWORD dwEncFlags;


//
//  Prototypes
//

BOOL
SecurityPkgInitialize(
    BOOL fForce = FALSE
    );

DWORD
EncryptData(
    IN CtxtHandle* hContext,
    IN LPVOID   lpBuffer,
    IN DWORD    dwInBufferLen,
    OUT LPVOID *lplpBuffer,
    OUT DWORD  *lpdwOutBufferLen,
    OUT DWORD  *lpdwInBufferBytesEncrypted
    );

DWORD
DecryptData(
    IN CtxtHandle* hContext,
    IN OUT DBLBUFFER* pdblbufBuffer,
    OUT DWORD     *lpdwBytesNeeded,
    OUT LPBYTE        lpOutBuffer,
    IN OUT DWORD  *lpdwOutBufferLeft,
    IN OUT DWORD  *lpdwOutBufferReceived,
    IN OUT DWORD  *lpdwOutBufferBytesRead
    );

VOID
TerminateSecConnection(
    IN CtxtHandle* hContext
    );


DWORD 
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo,
                  IN LPDWORD lpdwStatusFlag);


#ifdef __cplusplus
}
#endif

#endif //_INETSSPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\macros.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all internal macros used in INTERNET.DLL

    Contents:
        ROUND_UP_?K
        ROUND_UP_DWORD
        NEW
        DEL
        NEW_STRING
        DEL_STRING
        NEW_MEMORY
        ZAP
        PRIVATE
        PUBLIC
        GLOBAL
        LOCAL
        DEBUG_FUNCTION
        SKIPWS

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// macros
//

//
// ROUND_UP_ - return (n) rounded up to the next (k) bytes
//

#define ROUND_UP_NK(n, k)   (((n) + ((_ ## k ## K) - 1)) & -(_ ## k ## K))
#define ROUND_UP_2K(n)      ROUND_UP_NK(n, 2)
#define ROUND_UP_4K(n)      ROUND_UP_NK(n, 4)
#define ROUND_UP_8K(n)      ROUND_UP_NK(n, 8)
#define ROUND_UP_16K(n)     ROUND_UP_NK(n, 16)

//
// ROUND_UP_DWORD - return (n) rounded up to the next 4 bytes
//

#define ROUND_UP_DWORD(value) \
    (((value) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))

//
// NEW - allocates a new 'object' of type (obj). Memory is allocated with
// LocalAlloc and initialized to zeroes
//

#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))

//
// DEL - (should be DELETE, but that symbol is taken) - does opposite of NEW()
//

#define DEL(object) \
    FREE_MEMORY(object)

//
// NEW_STRING - performs NEW for a string
//

#define NEW_STRING(string) \
    NewString(string, 0)

//
// DEL_STRING - performs DEL for a string
//

#define DEL_STRING(string) \
    FREE_MEMORY(string)

//
// NEW_MEMORY - performs NEW for arbitrary sized memory
//

#define NEW_MEMORY(n, type) \
    (type FAR *)ALLOCATE_FIXED_MEMORY(n * sizeof(type))

//
// ZAP - zeroes an object (must be a variable, not a pointer)
//

#define ZAP(thing) \
    ZeroMemory((PVOID)&thing, sizeof(thing))

//
// STRTOUL - character-width independent (compile-time controlled) strtoul
//

#define STRTOUL             strtoul

//
// PRIVATE - make static items visible in debug version *FOR GLOBALS ONLY*. Use
// LOCAL in functions
//

#if INET_DEBUG

#define PRIVATE

#else

//#define PRIVATE static
#define PRIVATE

#endif // INET_DEBUG

//
// PUBLIC - just used as an aide-a-programmer pour le nonce
//

#define PUBLIC

//
// GLOBAL - same as PUBLIC, aide-a-programmer (for now) that tells you this
// thang has global scope
//

#define GLOBAL

//
// LOCAL - always expands to static, so you know that this thing only has
// local scope (within the current block)
//

#define LOCAL   static

//
// DEBUG_FUNCTION - this is a debug-only routine (if it get compiled in retail
// version a compile-time error is generated)
//

#if INET_DEBUG

#define DEBUG_FUNCTION

#else

#define DEBUG_FUNCTION

#endif // INET_DEBUG

//
// SKIPWS - skips blank widespace on the front of a string
//

#define SKIPWS(s) while (*(s)==' ' || *(s)=='\t') (s)++;


//
// MAKE_LOWER - takes an assumed upper character and bit manipulates into a lower.
//              (make sure the character is Upper case alpha char to begin, otherwise it corrupts)
//

#define MAKE_LOWER(c) (c | 0x20)

//
// MAKE_UPPER - takes an assumed lower character and bit manipulates into a upper.
//              (make sure the character is Lower case alpha char to begin, otherwise it corrupts)
//

#define MAKE_UPPER(c) (c & 0xdf)

//
// FASTCALL - used to bypass problems that may arise with UNIX compilers
//

#ifdef FASTCALL
#undef FASTCALL
#endif

#ifdef unix
#define FASTCALL
#else
#define FASTCALL __fastcall
#endif


//
// macro to cast FILETIME to LONGLONG
//
#define FT2LL(x) ( ((LONGLONG)((x).dwLowDateTime)) | (((LONGLONG)((x).dwHighDateTime))<<32) )


//
// Inline function to handle adding LONGLONG to FILETIME.
//
static __inline
void AddLongLongToFT( IN OUT LPFILETIME lpft,
                      IN     LONGLONG   llVal )
{
        LONGLONG llTmp;

        llTmp = FT2LL(*lpft);
        llTmp += llVal;

        lpft->dwLowDateTime =  ((LPDWORD)&llTmp)[0];
        lpft->dwHighDateTime = ((LPDWORD)&llTmp)[1];
}





//
// Macro to compute the number of bytes between two pointers
// The type of this expression is size_t, a signed integral
// type matching the size of a pointer
//
#define PtrDifference(x,y)  ((LPBYTE)(x) - (LPBYTE)(y))

//
// Macro to typecast 64-bit quantity to 32-bits
// Asserts in debug mode if the typecast loses information
//
#ifdef  DBG
#define GuardedCast(x)      ((x)<=0xFFFFFFFFL ? (DWORD)(x) : (InternetAssert(FALSE, __FILE__, __LINE__), 0))
#else
#define GuardedCast(x)      (DWORD)(x)
#endif

// Macro for the most common case
#define PtrDiff32(x,y)      (GuardedCast(PtrDifference(x,y)))

#define NOVTABLE            __declspec(novtable)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\msxmlmem.h ===
typedef INT_PTR	TAG;

#include "../../core/base/memutil.h"


#define ALLOCATE_ZERO_MEMORY(Size)  \
    _MemAlloc(Size, HEAP_ZERO_MEMORY)

#define ALLOCATE_FIXED_MEMORY(Size) \
    MemAllocNe(Size)

#define ALLOCATE_MEMORY(Flags, Size) \
    ((Flags & LMEM_ZEROINIT) != 0 ?     \
        ALLOCATE_ZERO_MEMORY(Size) : ALLOCATE_FIXED_MEMORY(Size))

#define FREE_ZERO_MEMORY(pv) \
    FREE_MEMORY((pv))

#define FREE_FIXED_MEMORY(pv) \
    FREE_MEMORY((pv))

#define FREE_MEMORY(pv) \
    (MemFree((pv)), NULL)

#define REALLOCATE_MEMORY(pv, Size, Flags) \
    _MemReAlloc((pv), (Size), HEAP_ZERO_MEMORY)


#define New     new_ne


#define INITIALIZE_DEBUG_MEMORY() \
    /* NOTHING */

#define TERMINATE_DEBUG_MEMORY(bReport) \
    /* NOTHING */

#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */


//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)


struct TLSDATA;

inline void InitializeMsxmlTLS()
{
    extern struct TLSDATA * EnsureTlsData();

    (void) EnsureTlsData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\proxreg.h ===
#include <inetreg.h>

#define BLOB_BUFF_GRANULARITY   1024

class CRegBlob
{
    private:
        HKEY    _hkey;
        BOOL    _fWrite;
        BOOL    _fCommit;
        DWORD   _dwOffset;
        DWORD   _dwBufferLimit;
        BYTE *  _pBuffer;
        LPCSTR  _pszValue;

    public:
        CRegBlob(BOOL fWrite);
        ~CRegBlob();
        DWORD Init(HKEY hBaseKey, LPCSTR pszSubKey, LPCSTR pszValue);
        DWORD Abandon();
        DWORD Commit();
        DWORD WriteString(LPCSTR pszString);
        DWORD ReadString(LPCSTR * ppszString);
        DWORD WriteBytes(LPCVOID pBytes, DWORD dwByteCount);
        DWORD ReadBytes(LPVOID pBytes, DWORD dwByteCount);

    private:
        DWORD Encrpyt();
        DWORD Decrypt();
};


typedef struct {

    //
    // dwStructSize - Structure size to handle growing list of new entries or priv/pub structures
    //

    DWORD dwStructSize;

    //
    // dwFlags - Proxy type flags
    //

    DWORD dwFlags;

    //
    // dwCurrentSettingsVersion - a counter incremented every time we change our settings
    //

    DWORD dwCurrentSettingsVersion;

    //
    // lpszConnectionName - name of the Connectoid for this connection
    //
    
    LPCSTR lpszConnectionName;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;

} INTERNET_PROXY_INFO_EX, * LPINTERNET_PROXY_INFO_EX;

// name of blob for saved legacy settings
#define LEGACY_SAVE_NAME            "SavedLegacySettings"

DWORD
LoadProxySettings();

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

DWORD
SetPerConnOptions(
    HINTERNET hInternet,    
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2
    );

HKEY
FindBaseProxyKey(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\parsers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.h

Abstract:

    Contains prototypes etc. for common\parsers.cxx

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD ConvertedNumber
    );

BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD ConvertedNumber
    );

BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT ConvertedNumber
    );

BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\parseurl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.h

Abstract:

    Header for parseurl.c and protocol-specific parsers

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Revision History:

    26-Apr-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define SAFE                0x00    // character is safe in all schemes
#define SCHEME_FTP          0x01    // character is unsafe in FTP scheme
#define SCHEME_GOPHER       0x02    // character is unsafe in gopher scheme
#define SCHEME_HTTP         0x04    // character is unsafe in HTTP scheme
#define UNSAFE              0x80    // character is unsafe in all schemes
#define HOSTNAME            0x08

#define SCHEME_ANY          (SCHEME_FTP | SCHEME_GOPHER | SCHEME_HTTP)

//
// types
//

typedef
DWORD
(*LPFN_URL_PARSER)(
    LPHINTERNET,
    LPSTR,
    DWORD,
    LPSTR,
    DWORD,
    DWORD,
    DWORD_PTR
    );

//
// prototypes
//

BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    );

BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    );

DWORD
ParseUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPVOID hMapped,
    IN LPCSTR Url,
    IN LPCSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* UrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    );

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    );

class MEMORYPACKET;

DWORD
ConvertUnicodeToMultiByte(
    IN LPCWSTR lpszObjectName, 
    IN DWORD dwCodePage, 
    OUT MEMORYPACKET* pmpObjectName, 
    IN DWORD dwFlags);
    
//
// flags for EncodeUrlPath
//

#define NO_ENCODE_PATH_SEP  0x00000001

DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR UnescapedString,
    IN OUT LPDWORD UnescapedLength
    );

DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    );

DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT INTERNET_PORT* lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    );

LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    );

//
// protocol-specific URL parsers
//


DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\passport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.h

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PASSPORT_H
#define PASSPORT_H

typedef void* PP_CONTEXT;
typedef void* PP_LOGON_CONTEXT;

//
// Passport related error codes
//

// generic internal error
#define PP_GENERIC_ERROR   -1   // biaow-todo: GetLastError() to return more specific error codes

// generic async error
#define PP_REQUEST_PENDING -9

//
// return codes from PP_Logon
//
#define PP_LOGON_SUCCESS    0
#define PP_LOGON_FAILED     1
#define PP_LOGON_REQUIRED   2

//
// return codes from PP_GetReturnVerbAndUrl
//
#define PP_RETURN_KEEP_VERB 1
#define PP_RETURN_USE_GET   0

#define PFN_LOGON_CALLBACK PVOID    // biaow-todo: define the async callback prototype

//
// Passport Context routines
//

PP_CONTEXT 
PP_InitContext(
    IN PCWSTR    pwszHttpStack, // "WinInet.dll" or "WinHttp5.dll"

    IN HINTERNET hSession       // An existing session (i.e. hInternet) returned by InternetOpen() 
                                // or WinHttpOpen(); hSession must compatible with pwszHttpStack. 
                                // (e.g.WinInet.Dll<->InternetOpen() or WinHttp5.Dll<->WinHttpOpen() )
    );

VOID 
PP_FreeContext(
	IN PP_CONTEXT hPP
    );

//
// Passport Logon Context routines
//

PP_LOGON_CONTEXT
PP_InitLogonContext(
	IN PP_CONTEXT  hPP,
	IN PCWSTR      pwszPartnerInfo,   // i.e. "WWW-Authenticate: Passport1.4 ..." from partner 
                                      // site's 302 re-direct
    IN DWORD       dwParentFlags
    );

DWORD
PP_Logon(
    IN PP_LOGON_CONTEXT    hPPLogon,
	IN HANDLE	           hEvent,          // biaow-todo: async
    IN PFN_LOGON_CALLBACK  pfnLogonCallback,// biaow-todo: async
    IN DWORD               dwContext        // biaow-todo: async
    );

// -- This method should be called when PP_Logon() returns PP_LOGON_REQUIRED 
// -- (i.e. 401 from a Passport DA)
BOOL
PP_GetChallengeInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
    OUT HBITMAP**       ppBitmap,   // can be NULL; if not NULL, ownership of the bitmap 
                                    // is not transferred to the user
    OUT PBOOL           pfPrompt,
  	IN PWSTR    	    pwszCbText,
    IN OUT PDWORD       pdwTextLen,
    IN PWSTR            pwszRealm,
    IN DWORD            dwMaxRealmLen
    );

// -- if the credentials are NULL/NULL, the means the default creds will be used
// -- if default creds can not be retrieved, this method will return FALSE
BOOL 
PP_SetCredentials(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN PCWSTR              pwszRealm,
    IN PCWSTR              pwszTarget,  // optional if user/pass are known (not null)
    IN PCWSTR              pwszSignIn,  // can be NULL
    IN PCWSTR              pwszPassword // can be NULL
    );

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    );

BOOL 
PP_GetAuthorizationInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	IN OUT PDWORD       pdwTicketLen,
	OUT PBOOL           pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	IN PWSTR            pwszUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// -- biaow-todo: async
VOID 
PP_AbortLogon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

// -- biaow-todo: 
VOID 
PP_Logout(
    IN PP_CONTEXT hPP,
    IN DWORD      dwFlags
    );

VOID 
PP_FreeLogonContext(
    IN PP_LOGON_CONTEXT    hPPLogon
	);

BOOL
PP_ForceNexusLookup(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszDARealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);



#ifdef PP_DEMO

BOOL PP_ContactPartner(
	IN PP_CONTEXT   hPP,
    IN PCWSTR       pwszPartnerUrl,
    IN PCWSTR       pwszVerb,
    IN PCWSTR       pwszHeaders,
    IN PWSTR        pwszData,
    IN OUT PDWORD   pdwDataLength
    );

#endif // PP_DEMO

#endif // PASSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\private.h ===
// Stuff removed from public header file...

#define INTERNET_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.

// maximum field lengths (arbitrary)
// NOTE: if these are put back in the public header, rename them to WINHTTP_.
#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_REALM_LENGTH       128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length

// This is a bogus limit we should get rid of.
#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_URL_LENGTH         (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

// INTERNET_DIAGNOSTIC_SOCKET_INFO - info about the socket in use
// (diagnostic purposes only, hence internal)

typedef struct {
    DWORD_PTR Socket;
    DWORD     SourcePort;
    DWORD     DestPort;
    DWORD     Flags;
} INTERNET_DIAGNOSTIC_SOCKET_INFO, * LPINTERNET_DIAGNOSTIC_SOCKET_INFO;

//
// INTERNET_DIAGNOSTIC_SOCKET_INFO.Flags definitions
//

#define IDSI_FLAG_KEEP_ALIVE    0x00000001  // set if from keep-alive pool
#define IDSI_FLAG_SECURE        0x00000002  // set if secure connection
#define IDSI_FLAG_PROXY         0x00000004  // set if using proxy
#define IDSI_FLAG_TUNNEL        0x00000008  // set if tunnelling through proxy

#ifdef __WINCRYPT_H__
#ifdef ALGIDDEF
//
// INTERNET_SECURITY_INFO - contains information about certificate
// and encryption settings for a connection.
//

#define INTERNET_SECURITY_INFO_DEFINED

typedef WINHTTP_CERTIFICATE_INFO  INTERNET_CERTIFICATE_INFO;
typedef WINHTTP_CERTIFICATE_INFO* LPINTERNET_CERTIFICATE_INFO;


typedef struct {

    //
    // dwSize - Size of INTERNET_SECURITY_INFO structure.
    //

    DWORD dwSize;


    //
    // pCertificate - Cert context pointing to leaf of certificate chain.
    //

    PCCERT_CONTEXT pCertificate;

    //
    // Start SecPkgContext_ConnectionInfo
    // The following members must match those
    // of the SecPkgContext_ConnectionInfo
    // sspi structure (schnlsp.h)
    //


    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;


} INTERNET_SECURITY_INFO, * LPINTERNET_SECURITY_INFO;


typedef struct {
    //
    // dwSize - size of INTERNET_SECURITY_CONNECTION_INFO
    //
    DWORD dwSize;

    // fSecure - Is this a secure connection.
    BOOL fSecure;

    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;

} INTERNET_SECURITY_CONNECTION_INFO , * LPINTERNET_SECURITY_CONNECTION_INFO;
#endif // ALGIDDEF
#endif // __WINCRYPT_H__

BOOLAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwReserved
    );

#define INTERNET_SERVICE_HTTP   3

// flags for InternetReadFileEx()
#define IRF_NO_WAIT     0x00000008

BOOLAPI
InternetGetLastResponseInfo(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#endif // !UNICODE

typedef struct _INTERNET_COOKIE {
    DWORD cbSize;
    LPSTR pszName;
    LPSTR pszData;
    LPSTR pszDomain;
    LPSTR pszPath;
    FILETIME *pftExpires;
    DWORD dwFlags;
    LPSTR pszUrl;
} INTERNET_COOKIE, *PINTERNET_COOKIE;

#define INTERNET_COOKIE_IS_SECURE   0x01
#define INTERNET_COOKIE_IS_SESSION  0x02

//
// internal error codes that are used to communicate specific information inside
// of Wininet but which are meaningless at the interface
//

#define INTERNET_INTERNAL_ERROR_BASE            (WINHTTP_ERROR_BASE + 900)



//
// INTERNET_PER_CONN_OPTION_LIST - set per-connection options such as proxy
// and autoconfig info
//
// Set and queried using WinHttp[Set|Query]Option with
// INTERNET_OPTION_PER_CONNECTION_OPTION
//

typedef struct
{
    DWORD   dwOption;            // option to be queried or set
    union
    {
        DWORD    dwValue;        // dword value for the option
        LPWSTR   pszValue;       // pointer to string value for the option
        FILETIME ftValue;        // file-time value for the option
    } Value;
} INTERNET_PER_CONN_OPTIONW, * LPINTERNET_PER_CONN_OPTIONW;

#ifdef UNICODE
typedef INTERNET_PER_CONN_OPTIONW INTERNET_PER_CONN_OPTION;
typedef LPINTERNET_PER_CONN_OPTIONW LPINTERNET_PER_CONN_OPTION;
#endif // UNICODE

typedef struct
{
    DWORD   dwSize;             // size of the INTERNET_PER_CONN_OPTION_LIST struct
    LPWSTR  pszConnection;      // connection name to set/query options
    DWORD   dwOptionCount;      // number of options to set/query
    DWORD   dwOptionError;      // on error, which option failed
    LPINTERNET_PER_CONN_OPTIONW  pOptions;
                                // array of options to set/query
} INTERNET_PER_CONN_OPTION_LISTW, * LPINTERNET_PER_CONN_OPTION_LISTW;

#ifdef UNICODE
typedef INTERNET_PER_CONN_OPTION_LISTW INTERNET_PER_CONN_OPTION_LIST;
typedef LPINTERNET_PER_CONN_OPTION_LISTW LPINTERNET_PER_CONN_OPTION_LIST;
#endif // UNICODE

//
// Options used in INTERNET_PER_CONN_OPTON struct
//
#define INTERNET_PER_CONN_FLAGS                         1
#define INTERNET_PER_CONN_PROXY_SERVER                  2
#define INTERNET_PER_CONN_PROXY_BYPASS                  3
#define INTERNET_PER_CONN_AUTOCONFIG_URL                4
#define INTERNET_PER_CONN_AUTODISCOVERY_FLAGS           5
#define INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL      6
#define INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS  7
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME   8
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL    9


//
// PER_CONN_FLAGS
//
#define PROXY_TYPE_DIRECT                               0x00000001   // direct to net
#define PROXY_TYPE_PROXY                                0x00000002   // via named proxy
#define PROXY_TYPE_AUTO_PROXY_URL                       0x00000004   // autoproxy URL
#define PROXY_TYPE_AUTO_DETECT                          0x00000008   // use autoproxy detection


#define INTERNET_OPEN_TYPE_DIRECT                       WINHTTP_ACCESS_TYPE_NO_PROXY
#define INTERNET_OPEN_TYPE_PROXY                        WINHTTP_ACCESS_TYPE_NAMED_PROXY
#define INTERNET_OPEN_TYPE_PRECONFIG                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  WINHTTP_ACCESS_TYPE_DEFAULT_PROXY

typedef HTTP_VERSION_INFO  INTERNET_VERSION_INFO;
typedef HTTP_VERSION_INFO* LPINTERNET_VERSION_INFO;

#define ERROR_HTTP_HEADER_NOT_FOUND             ERROR_WINHTTP_HEADER_NOT_FOUND             
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      ERROR_WINHTTP_INVALID_SERVER_RESPONSE      
#define ERROR_HTTP_INVALID_QUERY_REQUEST        ERROR_WINHTTP_INVALID_QUERY_REQUEST        
#define ERROR_HTTP_HEADER_ALREADY_EXISTS        ERROR_WINHTTP_HEADER_ALREADY_EXISTS        
#define ERROR_HTTP_REDIRECT_FAILED              ERROR_WINHTTP_REDIRECT_FAILED              
#define ERROR_HTTP_NOT_REDIRECTED               ERROR_WINHTTP_NOT_REDIRECTED               

#define INTERNET_INVALID_PORT_NUMBER    INTERNET_DEFAULT_PORT // use the protocol-specific default

#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION                
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE                
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING   
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID                  
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION         
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH              
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE            
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW                       
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC                      
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE                        
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES                     
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED               
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID                  
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI                         
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM                
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST                        
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK                        
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA                      
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION                     
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE                 
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT                 
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS                 
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF            
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION                  
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT                      
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET              
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING             
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE             
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION               
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING            
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED                   
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM                        
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE           
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION                    
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI                    
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER                     
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER                 
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER                      
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE                       
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT                  
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE            
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE          
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES               
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE                  
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE                      
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD              
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH                     
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION         
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE                         
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL               
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE                
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION            
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5                 
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE               
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG                        
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST                        
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH                    
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH               
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE                    
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE         
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS                
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION         
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE                       
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING           
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE                     
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY                        
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA                         
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING                     
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT                      
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION            
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE       
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST                
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY                  
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS                
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF           
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT               
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO         
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX                         
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM                      
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS        
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME             
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER                 

#define ERROR_WINHTTP_FORCE_RETRY               ERROR_WINHTTP_RESEND_REQUEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\rescache.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains prototypes, structures, manifests for rescache.c

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// manifests
//

#define RESOLVER_CACHE_DISABLED         -1
#define MINIMUM_RESOLVER_CACHE_ENTRIES  1
#define MAXIMUM_RESOLVER_CACHE_ENTRIES  128 // arbitrary, just in case user decides to wack it up
#define LIVE_FOREVER                    ((DWORD)-1)
#define LIVE_DEFAULT                    ((DWORD)0)

//
// types
//

//
// HOSTENT_CACHE_ENTRY_STATE - the hostent cache entry can be in-use, unused, or
// awaiting deletion
//

typedef enum {
    ENTRY_UNUSED = 1,
    ENTRY_IN_USE,
    ENTRY_DELETE
} HOSTENT_CACHE_ENTRY_STATE;

//
// RESOLVER_CACHE_ENTRY - we maintain a doubly-linked list of these. The list is
// maintained in MRU order - we throw out the one at the far end of the list.
// The structure is variable length, dependent on the amount of data in the
// hostent. We also honour the time-to-live in the DNS answer. When we get a
// response we set the ExpirationTime field. On future cache hits, if the
// current time is >= the ExpirationTime value then we must throw out this entry
// and refresh the cache
//

typedef struct {

    //
    // ListEntry - cache entries comprise a double-linked list
    //

    LIST_ENTRY ListEntry;

    //
    // ExpirationTime - formed by adding the time-to-live value from the DNS
    // response to the result obtained from time(). If ever time() returns a
    // value >= ExpirationTime, this entry is stale and must be refreshed
    //

    DWORD ExpirationTime;

    //
    // HostName - original name resolved to Hostent
    //

    LPSTR HostName;

    //
    // State - unused, in-use, or delete
    //

    HOSTENT_CACHE_ENTRY_STATE State;

    //
    // ReferenceCount - only change State when zero
    //

    LONG ReferenceCount;

    //
    // Hostent - the fixed data portion of a HOSTENT structure. The variable
    // part overflows the end of this structure
    //

    HOSTENT Hostent;

} RESOLVER_CACHE_ENTRY, *LPRESOLVER_CACHE_ENTRY;

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
QueryHostentCache(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL,
    OUT LPHOSTENT * Hostent,
    OUT LPDWORD TimeToLive
    );

VOID
CacheHostent(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR lpszHostName,
    IN LPHOSTENT pHostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc=NULL,
    IN DWORD dwAllocSize=0
    );

VOID
FlushHostentCache(
    SERIALIZED_LIST* pResolverCache
    );

VOID
ThrowOutHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    );

VOID
ReleaseHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    );

#if defined(__cplusplus)
}
#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains name resolution cache structure definition

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
InitNameresCache(
    VOID
);

DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpAddressInfoList
);

DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
);

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
);

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfoList
);

DWORD
DeinitNameresCache(
    VOID
);

#if defined(__cplusplus)
}
#endif

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\resinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resinfo.h

Abstract:

    Resource owner info header. Used for tracking resources in debug build

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if INET_DEBUG

//
// types
//

//typedef struct {
//    DWORD Tid;
//    DWORD CallersAddress;
//    DWORD CallersCaller;
//    DWORD SourceFileLine;
//    LPSTR SourceFileName;
//} RESOURCE_INFO, *LPRESOURCE_INFO;
typedef struct {
    DWORD Tid;
    LPSTR SourceFileName;
    DWORD SourceFileLine;
} RESOURCE_INFO, *LPRESOURCE_INFO;

//#define GET_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define GET_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

//#define INITIALIZE_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define INITIALIZE_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

#else

#define GET_RESOURCE_INFO(pResource)
#define INITIALIZE_RESOURCE_INFO(pResource)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\inethttp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    inethttp.h

Abstract:

    This header maps some wininet API to winhttp

--*/

// API mappings

#define InternetTimeFromSystemTime  WinHttpTimeFromSystemTime

#define InternetTimeToSystemTime    WinHttpTimeToSystemTime

#define InternetCrackUrl            WinHttpCrackUrl

#define InternetCreateUrl           WinHttpCreateUrl

#define InternetOpen                WinHttpOpen

#define InternetSetStatusCallback(h, pcb)\
    WinHttpSetStatusCallback(h, pcb, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, 0)

#define InternetSetOption           WinHttpSetOption

#define InternetQueryOption         WinHttpQueryOption

#define InternetConnect(h,s,port,user,pass,svc,flag,ctx) \
    WinHttpConnect(h,s,port,flag,ctx)

#define HttpOpenRequest             WinHttpOpenRequest

#define HttpAddRequestHeaders       WinHttpAddRequestHeaders

#define HttpSendRequest(h,ph,cbh,pr,cbr)\
    WinHttpSendRequest(h,ph,cbh,pr,cbr,cbr,0)


#define HttpSendRequestEx(h,pbi,pbo,dw,c)\
    WinHttpSendRequest(h,   \
        (pbi)->lpcszHeader,     \
        (pbi)->dwHeadersLength, \
        (pbi)->lpvBuffer,       \
        (pbi)->dwBufferLength,  \
        (pbi)->dwBufferTotal,   \
        0)

#define InternetWriteFile(h,p,cb,pcb)\
    WinHttpWriteData(h,p,cb,pcb,0)

#define HttpEndRequest              WinHttpReceiveResponse

#define HttpQueryInfo(h,dw,pb,pcb,ndx)\
	WinHttpQueryHeaders(h,dw,((LPCWSTR) pb),pb,pcb,ndx)

#define InternetQueryDataAvailable  WinHttpQueryDataAvailable

#define InternetReadFile(h,p,cb,pcb)\
    WinHttpReadData(h,p,cb,pcb,0)

#define InternetCloseHandle         WinHttpCloseHandle

#define InternetOpenUrl             WinHttpOpenUrl


// InternetSetOption values

#define INTERNET_FIRST_OPTION                        WINHTTP_FIRST_OPTION
#define INTERNET_OPTION_CALLBACK                     WINHTTP_OPTION_CALLBACK
#define INTERNET_OPTION_RESOLVE_TIMEOUT              WINHTTP_OPTION_RESOLVE_TIMEOUT
#define INTERNET_OPTION_CONNECT_TIMEOUT              WINHTTP_OPTION_CONNECT_TIMEOUT
#define INTERNET_OPTION_CONNECT_RETRIES              WINHTTP_OPTION_CONNECT_RETRIES
#define INTERNET_OPTION_SEND_TIMEOUT                 WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT              WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_HANDLE_TYPE                  WINHTTP_OPTION_HANDLE_TYPE
#define INTERNET_OPTION_READ_BUFFER_SIZE             WINHTTP_OPTION_READ_BUFFER_SIZE
#define INTERNET_OPTION_WRITE_BUFFER_SIZE            WINHTTP_OPTION_WRITE_BUFFER_SIZE
#define INTERNET_OPTION_PARENT_HANDLE                WINHTTP_OPTION_PARENT_HANDLE
#define INTERNET_OPTION_REQUEST_FLAGS                WINHTTP_OPTION_REQUEST_FLAGS
#define INTERNET_OPTION_EXTENDED_ERROR               WINHTTP_OPTION_EXTENDED_ERROR
#define INTERNET_OPTION_SECURITY_FLAGS               WINHTTP_OPTION_SECURITY_FLAGS
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT  WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT
#define INTERNET_OPTION_URL                          WINHTTP_OPTION_URL
#define INTERNET_OPTION_SECURITY_KEY_BITNESS         WINHTTP_OPTION_SECURITY_KEY_BITNESS
#define INTERNET_OPTION_PROXY                        WINHTTP_OPTION_PROXY
#define INTERNET_OPTION_VERSION                      WINHTTP_OPTION_VERSION
#define INTERNET_OPTION_USER_AGENT                   WINHTTP_OPTION_USER_AGENT
#define INTERNET_OPTION_CONTEXT_VALUE                WINHTTP_OPTION_CONTEXT_VALUE
#define INTERNET_OPTION_CLIENT_CERT_CONTEXT          WINHTTP_OPTION_CLIENT_CERT_CONTEXT
#define INTERNET_OPTION_POLICY                       WINHTTP_OPTION_POLICY
#define INTERNET_OPTION_REQUEST_PRIORITY             WINHTTP_OPTION_REQUEST_PRIORITY
#define INTERNET_OPTION_HTTP_VERSION                 WINHTTP_OPTION_HTTP_VERSION
#define INTERNET_OPTION_ERROR_MASK                   WINHTTP_OPTION_ERROR_MASK
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT         WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT      WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT            WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT         WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_CODEPAGE                     WINHTTP_OPTION_CODEPAGE
#define INTERNET_OPTION_MAX_CONNS_PER_SERVER         WINHTTP_OPTION_MAX_CONNS_PER_SERVER
#define INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER     WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER
#define INTERNET_OPTION_PER_CONNECTION_OPTION        WINHTTP_OPTION_PER_CONNECTION_OPTION
#define INTERNET_OPTION_DIGEST_AUTH_UNLOAD           WINHTTP_OPTION_DIGEST_AUTH_UNLOAD
#define INTERNET_LAST_OPTION                         WINHTTP_LAST_OPTION

// status callback

#define INTERNET_ASYNC_RESULT                        WINHTTP_ASYNC_RESULT
#define LPINTERNET_ASYNC_RESULT                      LPWINHTTP_ASYNC_RESULT

#define INTERNET_STATUS_RESOLVING_NAME               WINHTTP_STATUS_RESOLVING_NAME
#define INTERNET_STATUS_NAME_RESOLVED                WINHTTP_STATUS_NAME_RESOLVED
#define INTERNET_STATUS_CONNECTING_TO_SERVER         WINHTTP_STATUS_CONNECTING_TO_SERVER
#define INTERNET_STATUS_CONNECTED_TO_SERVER          WINHTTP_STATUS_CONNECTED_TO_SERVER
#define INTERNET_STATUS_SENDING_REQUEST              WINHTTP_STATUS_SENDING_REQUEST
#define INTERNET_STATUS_REQUEST_SENT                 WINHTTP_STATUS_REQUEST_SENT
#define INTERNET_STATUS_RECEIVING_RESPONSE           WINHTTP_STATUS_RECEIVING_RESPONSE
#define INTERNET_STATUS_RESPONSE_RECEIVED            WINHTTP_STATUS_RESPONSE_RECEIVED
#define INTERNET_STATUS_CLOSING_CONNECTION           WINHTTP_STATUS_CLOSING_CONNECTION
#define INTERNET_STATUS_CONNECTION_CLOSED            WINHTTP_STATUS_CONNECTION_CLOSED
#define INTERNET_STATUS_HANDLE_CREATED               WINHTTP_STATUS_HANDLE_CREATED
#define INTERNET_STATUS_HANDLE_CLOSING               WINHTTP_STATUS_HANDLE_CLOSING
#define INTERNET_STATUS_DETECTING_PROXY              WINHTTP_STATUS_DETECTING_PROXY
#define INTERNET_STATUS_REQUEST_COMPLETE             WINHTTP_STATUS_REQUEST_COMPLETE
#define INTERNET_STATUS_REDIRECT                     WINHTTP_STATUS_REDIRECT
#define INTERNET_STATUS_INTERMEDIATE_RESPONSE        WINHTTP_STATUS_INTERMEDIATE_RESPONSE

#define INTERNET_STATUS_CALLBACK                     WINHTTP_STATUS_CALLBACK
#define LPINTERNET_STATUS_CALLBACK                   LPWINHTTP_STATUS_CALLBACK
#define INTERNET_INVALID_STATUS_CALLBACK             WINHTTP_INVALID_STATUS_CALLBACK
#define INTERNET_NO_CALLBACK                         0

// flags

#define INTERNET_FLAG_RELOAD                         WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_RESYNCHRONIZE                  WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_PRAGMA_NO_CACHE                WINHTTP_FLAG_BYPASS_CACHE
#define INTERNET_FLAG_NO_CACHE_WRITE                 0
#define INTERNET_FLAG_DONT_CACHE                     0
#define INTERNET_FLAG_MAKE_PERSISTENT                0
#define INTERNET_FLAG_READ_PREFETCH                  0
#define INTERNET_FLAG_CACHE_IF_NET_FAIL              0
#define INTERNET_FLAG_CACHE_ASYNC                    0
#define INTERNET_FLAG_BGUPDATE                       0
#define INTERNET_FLAG_HYPERLINK                      0
#define INTERNET_FLAG_FWD_BACK                       0
#define INTERNET_FLAG_NO_UI                          0
#define INTERNET_FLAG_KEEP_CONNECTION                0


// handle types

#define INTERNET_HANDLE_TYPE_INTERNET           WINHTTP_HANDLE_TYPE_SESSION
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       WINHTTP_HANDLE_TYPE_CONNECT
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       WINHTTP_HANDLE_TYPE_REQUEST


#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION                
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE                
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING   
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID                  
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION         
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH              
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE            
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW                       
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC                      
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE                        
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES                     
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED               
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID                  
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI                         
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM                
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST                        
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK                        
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA                      
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION                     
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE                 
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT                 
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS                 
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF            
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION                  
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT                      
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET              
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING             
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE             
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION               
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING            
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED                   
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM                        
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE           
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION                    
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI                    
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER                     
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER                 
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER                      
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE                       
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT                  
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE            
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE          
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES               
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE                  
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE                      
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD              
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH                     
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION         
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE                         
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL               
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE                
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION            
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5                 
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE               
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG                        
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST                        
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH                    
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH               
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE                    
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE         
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS                
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION         
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE                       
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING           
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE                     
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY                        
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA                         
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING                     
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT                      
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION            
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE       
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST                
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY                  
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS                
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF           
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT               
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO         
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX                         
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM                      
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS        
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME             
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER                 

#define ERROR_INTERNET_FORCE_RETRY              WINHTTP_ERROR_RESEND_REQUEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for dll\registry.c

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//
// prototypes
//

DWORD
OpenInternetSettingsKey(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

#ifdef WININET6
DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
#endif

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );


#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\secinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    secinit.h

Abstract:

    Contains prototypes for indirected security functions

Author:

    Sophia Chung (sophiac) 7-Feb-1996

Revision History:

--*/

#if !defined(_SECINIT_)

#define _SECINIT_

#if defined(__cplusplus)
extern "C" {
#endif

#include <sspi.h>

#if defined(__cplusplus)
}
#endif

extern CCritSec InitializationSecLock;

extern PSecurityFunctionTable   GlobalSecFuncTable;
extern WIN_VERIFY_TRUST_FN      pWinVerifyTrust;
extern WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

extern HCERTSTORE   g_hMyCertStore;

#define g_EnumerateSecurityPackages \
        (*(GlobalSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(GlobalSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(GlobalSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(GlobalSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(GlobalSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(GlobalSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(GlobalSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved4))

LONG WINAPI WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD);

// Don't use WinVerifyTrust directly to verify secure channel connections.
// Use the wininet wrapper WinVerifySecureChannel instead.
#define g_WinVerifyTrust \
        pWinVerifyTrust


typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

#define CRYPT_INSTALL_DEFAULT_CONTEXT_NAME      "CryptInstallDefaultContext"

typedef BOOL
(WINAPI * CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
);

#define CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME    "CryptUninstallDefaultContext"
    
typedef BOOL
(WINAPI * CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)   
(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
);

typedef PCCERT_CHAIN_CONTEXT
(WINAPI *CERT_FIND_CHAIN_IN_STORE_FN)
(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
);

#define CERT_FIND_CHAIN_IN_STORE_NAME            "CertFindChainInStore"

typedef VOID
(WINAPI *CERT_FREE_CERTIFICATE_CHAIN_FN)
(
    IN PCCERT_CHAIN_CONTEXT pChainContext
);

#define CERT_FREE_CERTIFICATE_CHAIN_NAME        "CertFreeCertificateChain"


extern CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext;
extern CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext;
extern CERT_FIND_CHAIN_IN_STORE_FN        g_CertFindChainInStore;
extern CERT_FREE_CERTIFICATE_CHAIN_FN     g_CertFreeCertificateChain;

extern HCRYPTPROV GlobalFortezzaCryptProv;

#define LOCK_SECURITY()   (InitializationSecLock.Lock())
#define UNLOCK_SECURITY() (InitializationSecLock.Unlock())


//
// prototypes
//

BOOL
SecurityInitialize(
    VOID
    );

VOID
SecurityTerminate(
    VOID
    );

DWORD
LoadSecurity(
    VOID
    );

VOID
UnloadSecurity(
    VOID
    );

DWORD
LoadWinTrust(
    VOID
    );


BOOL
IsFortezzaInstalled(
    VOID
    );

#endif // _SECINIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\thrdinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.h

Abstract:

    Per-thread structure definitions/macros

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define INTERNET_THREAD_INFO_SIGNATURE  'drhT'  // "Thrd"

//
// forward references
//

class CFsm;

//
// types
//

//
// INTERNET_THREAD_INFO - per-thread information, handily referenced via a TLS
// slot
//

typedef struct _INTERNET_THREAD_INFO {

    //
    // List - doubly linked list that we delete on DLL_PROCESS_DETACH
    //

    LIST_ENTRY List;

#if INET_DEBUG

    //
    // Signature - lets us know that this structure is probably an
    // INTERNET_THREAD_INFO
    //

    DWORD Signature;

#endif

    //
    // ThreadId - used to identify this thread within a process
    //

    DWORD ThreadId;

    //
    // ErrorNumber - arbitrary error code, supplied in InternetSetLastError
    //

    DWORD ErrorNumber;

    //
    // hErrorText - we store the last error text on a per-thread basis. This
    // handle identifies a moveable buffer
    //

    HLOCAL hErrorText;

    //
    // ErrorTextLength - length of the error text in hErrorText
    //

    DWORD ErrorTextLength;

    //
    // hObject - the current Internet object handle being used in this API. We
    // need this to maintain context e.g. when we want to get timeout values
    //

    HINTERNET hObject;

    //
    // hObjectMapped - this is the address of the real object mapped to hObject
    //

    HINTERNET hObjectMapped;

    //
    // IsAsyncWorkerThread - TRUE if this thread is an async worker thread
    //

    BOOL IsAsyncWorkerThread;

    //
    // InCallback - TRUE if we have made an app callback. Used to detect
    // re-entrancy
    //

    BOOL InCallback;

    //
    // fExitThread - This is the last thread we're waiting for termination of.
    //

    BOOL fExitThread;
    
    //
    // NestedRequests - incremented when we detect that we're processing an API
    // in the async worker thread context. If this API then calls other APIs,
    // then we need to treat (mapped) handles differently in the called APIs
    //

    DWORD NestedRequests;

    //
    // dwMappedErrorCode - the real error code returned by e.g. a winsock API,
    // before it was mapped to a WinInet error
    //

    DWORD dwMappedErrorCode;

    //
    // Fsm - currently executing Finite State Machine
    //

    CFsm * Fsm;

#ifdef ENABLE_DEBUG

    //
    // IsAsyncSchedulerThread - TRUE if this INTERNET_THREAD_INFO belongs to the
    // one-and-only async scheduler thread
    //

    BOOL IsAsyncSchedulerThread;

    //
    // per-thread debug variables
    //

    //
    // Pointer to LIFO (stack) of INTERNET_DEBUG_RECORDs. Used to generate
    // indented call-tracing for diagnostics
    //

    LPINTERNET_DEBUG_RECORD Stack;

    //
    // CallDepth - nesting level for calls
    //

    int CallDepth;

    //
    // IndentIncrement - the current indent level. Number of spaces
    //

    int IndentIncrement;

    //
    // StartTime and StopTime - used for timing calls to e.g. send(), recv()
    //

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;

#endif // #ifdef ENABLE_DEBUG

} INTERNET_THREAD_INFO, *LPINTERNET_THREAD_INFO;

//
// macros
//

//
// InternetClearLastError - frees the response text buffer for this thread
//

#define InternetClearLastError() \
    InternetSetLastError(0, NULL, 0, 0)

//
// InternetResetObjectHandle - resets the per-thread current object handle
//

#define InternetResetObjectHandle() \
    InternetSetObjectHandle(NULL)

//
// _InternetIncNestingCount - increments nesting level count
//

#define _InternetIncNestingCount() \
    lpThreadInfo->NestedRequests++;

// ** debug version
//#define _InternetIncNestingCount() \
//    if ( lpThreadInfo->NestedRequests > 0xffff ) { \
//        OutputDebugString("InternetIncNestingCount, inc over threshold, contact arthurbi, x68073 (sechs)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests++;

//
// _InternetDecNestingCount - decrements nesting level count
//

#define _InternetDecNestingCount(dwNestingLevel) \
    lpThreadInfo->NestedRequests -= dwNestingLevel;

// ** debug version
//#define _InternetDecNestingCount(dwNestingLevel) \
//    if ( lpThreadInfo->NestedRequests == 0 ) { \
//        OutputDebugString("InternetDecNestingCount, attempting to dec 0, contact arthurbi, x68073 (sieben)\n"); \
//        DebugBreak(); \
//    } \
//    if ( dwNestingLevel != 1 && dwNestingLevel != 0 ) { \
//        OutputDebugString("InternetDecNestingCount, invalid nesting level, contact arthurbi, x68073 (acht)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests -= dwNestingLevel;

//
// _InternetSetObjectHandle - set the object handle given the thread info block
//

#define _InternetSetObjectHandle(lpThreadInfo, hInternet, hMapped) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new obj handle on thrd=%x, old=%x, new=%x (map: old=%x, new=%x)\n", \
            lpThreadInfo, \
            lpThreadInfo->hObject, \
            hInternet, \
            lpThreadInfo->hObjectMapped, \
            hMapped \
            )); \
    lpThreadInfo->hObject = hInternet; \
    lpThreadInfo->hObjectMapped = hMapped;

//
// _InternetClearLastError - clear the last error info given the thread info
// block
//

#define _InternetClearLastError(lpThreadInfo) \
    _InternetSetLastError(lpThreadInfo, 0, NULL, 0, 0)

//
// _InternetResetObjectHandle - clear the object handle given the thread info
// block
//

#define _InternetResetObjectHandle(lpThreadInfo) \
    _InternetSetObjectHandle(lpThreadInfo, NULL, NULL)

//
// _InternetGetObjectHandle - retrieves the object handle from the per-thread
// info block
//

#define _InternetGetObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObject

//
// _InternetGetMappedObjectHandle - retrieves the mapped object handle from the
// per-thread info block
//

#define _InternetGetMappedObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObjectMapped

//
// InternetDisableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetDisableAsync(lpThreadInfo) \
    _InternetSetAsync(FALSE)

//
// InternetEnableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetEnableAsync(lpThreadInfo, Val) \
    _InternetSetAsync(TRUE)

//
// _InternetGetAsync - returns the async worker thread indication from the
// thread info block
//

#define _InternetGetAsync(lpThreadInfo) \
    lpThreadInfo->IsAsyncWorkerThread

//
// _InternetSetAsync - turns on or off the async worker thread indication in the
// thread info block
//

#define _InternetSetAsync(lpThreadInfo, Val) \
    lpThreadInfo->IsAsyncWorkerThread = Val

#define _InternetGetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback

#define _InternetSetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = TRUE

#define _InternetResetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = FALSE

#if INET_DEBUG

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE)

#else

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    /* NOTHING */

#endif

//
// prototypes
//

#define UI_ACTION_CODE_NONE_TAKEN                   0
#define UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
#define UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
#define UI_ACTION_CODE_USER_ACTION_COMPLETED        3


LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    );

VOID
InternetDestroyThreadInfo(
    VOID
    );

VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

VOID
InternetTerminateThreadInfo(
    VOID
    );

LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    );

VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    );

DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo,
    IN BOOL  bCopyBuffer=FALSE,
    IN BOOL  bConvertToUnicode=TRUE
    );

DWORD
InternetIndicateStatus(
    IN DWORD dwInternetStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN BOOL  bCopyBuffer=FALSE,
    IN BOOL  bConvertToUnicode=FALSE
    );

DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    );

DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

#define SLE_APPEND          0x00000001
#define SLE_ZERO_TERMINATE  0x00000002

DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

LPSTR
InternetLockErrorText(
    VOID
    );

VOID
InternetUnlockErrorText(
    VOID
    );

VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    );

HINTERNET
InternetGetObjectHandle(
    VOID
    );

HINTERNET
InternetGetMappedObjectHandle(
    VOID
    );

//
// external data
//

extern SERIALIZED_LIST ThreadInfoList;

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\util.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header for util.cxx

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if !defined(__UTIL_H__)
#define __UTIL_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))
#define PLATFORM_TYPE_UNIX          ((DWORD)(2))

#define PLATFORM_SUPPORTS_UNICODE   0x00000001

// max header allowed by wininet in the cache

#define MAX_HEADER_SUPPORTED            2048
#define MAX_USERNAME                    128
#define DEFAULT_MAX_EXTENSION_LENGTH    8

//
// types
//

//
// TRI_STATE - for places where we need to differentiate between TRUE/FALSE and
// uninitialized
//

typedef enum {
    TRI_STATE_UNKNOWN = -1,
    TRI_STATE_FALSE = 0,
    TRI_STATE_TRUE = 1
} TRI_STATE;

//
// DLL_ENTRY_POINT - maps a name to an entry point in a DLL
//

typedef struct {
    LPSTR lpszProcedureName;
    FARPROC * lplpfnProcedure;
} DLL_ENTRY_POINT, * LPDLL_ENTRY_POINT;

//
// DLL_INFO - used to dynamically load/unload libraries
//

typedef struct {
    LPSTR lpszDllName;
    HINSTANCE hModule;
    LONG LoadCount;
    DWORD dwNumberOfEntryPoints;
    LPDLL_ENTRY_POINT lpEntryPoints;
} DLL_INFO, * LPDLL_INFO;

//
// macros
//

#define IsPlatformWin95() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WIN95) ? TRUE : FALSE)

#define IsPlatformWinNT() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : FALSE)

//#define IsUnicodeSupported() \
//    (BOOL)((PlatformSupport() & PLATFORM_SUPPORTS_UNICODE) ? TRUE : FALSE)

#define DLL_ENTRY_POINT_ELEMENT(name) \
    # name, (FARPROC *)&_I_ ## name

#define DLL_INFO_INIT(name, entryPoints) { \
    name, \
    NULL, \
    0, \
    ARRAY_ELEMENTS(entryPoints), \
    (LPDLL_ENTRY_POINT)&entryPoints \
}


#define CompareFileTime(ft1, ft2)   ( ((*(LONGLONG *)&ft1) > (*(LONGLONG *)&ft2)) ? 1 : \
                                        ( ((*(LONGLONG *)&ft1) == (*(LONGLONG *)&ft2)) ? 0 : -1 ) )


#define WRAP_REVERT_USER(fn, args, retVal) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    retVal = fn args; \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define SAFE_WRAP_REVERT_USER(fn, args, retVal) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    __try \
    { \
        retVal = fn args; \
    } \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    { \
    } \
    ENDEXCEPT \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define WRAP_REVERT_USER_VOID(fn, args) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    fn args; \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define SAFE_WRAP_REVERT_USER_VOID(fn, args) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    __try \
    { \
        fn args; \
    } \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    { \
    } \
    ENDEXCEPT \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

//
// prototypes
//

LPSTR
NewString(
    IN LPCSTR String,
    IN DWORD dwLen = 0
    );

LPWSTR
NewStringW(
    IN LPCWSTR String,
    IN DWORD dwLen = 0
    );


LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    );

HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    );

LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    );

LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    );

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    );

DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os = NULL
    );

DWORD
PlatformSupport(
    VOID
    );

DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    );

DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    );

DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    );

//
// flags for LoadDllEntryPoints()
//

#define LDEP_PARTIAL_LOAD_OK    0x00000001  // ok if not all entry points can be loaded

DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    );

DWORD
MapInternetError(
    IN DWORD ErrorCode,
    IN LPDWORD lpdwStatus = NULL
    );

DWORD
CalculateHashValue(
    IN LPSTR lpszString
    );

VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    );

LPTSTR
FTtoString(
    IN FILETIME *pftTime
    );

BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
);

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    );

BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    );

//DWORD
//UnicodeToUtf8(
//    IN LPCWSTR pwszIn,
//    IN DWORD dwInLen,
//    OUT LPBYTE pszOut,
//    IN OUT LPDWORD pdwOutLen
//    );

DWORD
CountUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    IN BOOL bEncode
    );

DWORD
ConvertUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    OUT LPBYTE pszOut,
    IN DWORD dwOutLen,
    IN BOOL bEncode
    );

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    );

DWORD 
GetTickCountWrap();

#ifdef DONT_USE_IERT
char *
StrTokEx(
    IN OUT char ** pstring, 
    IN const char * control);

double 
StrToDbl(
    IN const char *str, 
    IN OUT char **strStop);
#endif //DONT_USE_IERT
#if defined(__cplusplus)
}
#endif


DWORD
WideCharToAscii(PCWSTR pszW, char ** ppszA);

DWORD
AsciiToWideChar_UsingGlobalAlloc(const char * pszA, LPWSTR * ppszW);

#endif // defined(__UTIL_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\xpltfrm.h ===
#ifndef __XPLTFRM_H__
#define __XPLTFRM_H__

#include <platform.h>

#ifdef unix
#define LONGLONG_ZERO 0LL
#define __int8 char
#define DIR_SEPARATOR_CHAR TEXT('/')
#define DIR_SEPARATOR_STRING TEXT("/")
#define WEBDIR_STRING "Web/"
// Follwing is workaround for MainWin Registry API bug 2053.
#else
#define LONGLONG_ZERO 0i64
#define DIR_SEPARATOR_CHAR TEXT('\\')
#define DIR_SEPARATOR_STRING TEXT("\\")
#define WEBDIR_STRING "Web\\" 
#endif /* unix */

#endif /* __XPLTFRM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

//
// types
//

typedef struct {

#if INET_DEBUG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // INET_DEBUG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CCritSec Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if INET_DEBUG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if INET_DEBUG

BOOL
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // INET_DEBUG

BOOL
InitializeSerializedList(LPSERIALIZED_LIST pList);

#define TerminateSerializedList(list) \
    ((list)->Lock.FreeLock())

#define LockSerializedList(list) \
    ((list)->Lock.Lock())

#define UnlockSerializedList(list) \
    ((list)->Lock.Unlock())

BOOL
InsertAtHeadOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

BOOL
InsertAtTailOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

BOOL
RemoveFromSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // INET_DEBUG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\wininetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Includes all headers for precompiled header to build Windows Internet
    client DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#ifndef __WININETP_H__
#define __WININETP_H__ 1

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

// #define STRESS_BUG_DEBUG // for stress debugging

#if DBG

#define STRESS_BUG_DEBUG // for stress debugging

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// common include files
//


//
// CRT includes
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h> // Pull in the 'offsetof' macro.
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <excpt.h>
#include <limits.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>

#if defined(__cplusplus)
}
#endif

//#include <fastcrit.h>

//
// SSL/PCT Security includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>    // standard SSPI interface
#include <issperr.h> // SSPI errors.
#include <spseal.h>  // Private SSPI Seal/UnSeal functions.
#include <schnlsp.h> // shared private schannel/wininet interfaces.
#include <wintrust.h> // various CAPI stuff for cert management
#include <wincrypt.h>
#if defined(__cplusplus)
}
#endif


#define WININET_SERVER_CORE     1

//
// WININET includes
//

#include <iwinsock.h>
#include <winhttp.h>
#include <internal.h>
#include <private.h>
#include <ansi.h>
#include <wininetd.h>
#include <resinfo.h>
#include <syncobj.hxx>
#include <serialst.h>
#include <chunkflt.hxx>
#include <inetdbg.h>
#ifdef WINHTTP_FOR_MSXML
#  include <msxmlmem.h>
#else
#  include <debugmem.h>
#endif
#include <shlwapi.h>
#define NO_SHLWAPI_MLUI
#include <shlwapip.h>
#include <malloc.h>
#include <crtsubst.h>
#include <handle.h>
#include <constant.h>
#include <macros.h>
#include <inetp.h>
#include <util.h>
#include <proxreg.h>
#include <icstring.hxx>
#include <cliauth.hxx>
#include <certcach.hxx>
#include <buffer.hxx>
#include <thrdinfo.h>
#include <defaults.h>
#include <passport.h>
#include <spluginx.hxx>
#include <splugin.hxx>
#include <secinit.h>
#include <inetsspi.h>
#include <tstr.h>
#include <registry.h>
#include <parseurl.h>
#include <globals.h>
#include <autoprox.hxx>
#include <reslock.hxx>
#include <proxysup.hxx>
#include <hinet.hxx>
#include <priolist.hxx>
#include <icasync.hxx>
#include <caddrlst.hxx>
#include <icsocket.hxx>
#include <ssocket.hxx>
#include <servinfo.hxx>
#include <connect.hxx>
#include <http.hxx>
#include <cookie.h>
#include <rescache.h>
#include <parsers.h>
#include <fsm.hxx>
#include <mpacket.hxx>
#include <inetchar.h>
#include <bgtask.hxx>

#if defined(__cplusplus)
extern "C" {
#endif


//
//  Various protocol package initializers.
//

BOOL
WINAPI
WinInetDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

#if defined(__cplusplus)
}
#endif

//
// Need version 0x400 for ras defines for this to work on win95 gold.
//
#if defined(__cplusplus)
extern "C" {
#endif

#undef WINVER
#define WINVER 0x400

#include <ras.h>
#include <raserror.h>

#ifdef ICECAP
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall MarkCAP(long lMark);  // write mark to MEA
extern "C" void _stdcall AllowCAP(void);  // Allow profiling when 'profile=almostnever'
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define MarkCAP(n)
#define AllowCAP()
#endif

#if defined(__cplusplus)
}
#endif


/* X-Platform stuff */
#include <xpltfrm.h>

#endif /* __WININETP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\wininetd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wininetd.h

Abstract:

    Contains the interface for the WININET diagnostic capabilities.

    This interface only exists in the debug version of WININET.DLL.
    Calling the debug functions in the retail version of the DLL will
    yield ERROR_INVALID_PARAMETER

Author:

    Richard L Firth (rfirth) 14-Jun-1995

Revision History:

    14-Jun-1995 rfirth
        Created

--*/

//
// manifests
//

//
// if the environment or registry variable "WininetLog" is set to !0 then the
// following values will be used for control, category and error level resp.
// These options generate "WININET.LOG" in the current directory
//

#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define WINHTTP_OPTION_GET_DEBUG_INFO      1001
#define WINHTTP_OPTION_SET_DEBUG_INFO      1002
#define WINHTTP_OPTION_GET_HANDLE_COUNT    1003
#define WINHTTP_OPTION_GET_TRIGGERS        1004
#define WINHTTP_OPTION_SET_TRIGGERS        1005
#define WINHTTP_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         WINHTTP_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          WINHTTP_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_INET            0x00000001  // e.g. InternetOpenUrl()
#define DBG_FTP             0x00000002  // e.g. FtpFindFirstFile()
#define DBG_GOPHER          0x00000004  // e.g. GopherFindFirstFile()
#define DBG_HTTP            0x00000008  // e.g. HttpOpenRequest()
#define DBG_API             0x00000010  // APIs
#define DBG_UTIL            0x00000020  // various utility functions
#define DBG_UNICODE         0x00000040  // wide character functions
#define DBG_WORKER          0x00000080  // worker functions
#define DBG_HANDLE          0x00000100  // handle creation/deletion functions
#define DBG_SESSION         0x00000200  // session/creation functions
#define DBG_SOCKETS         0x00000400  // sockets functions
#define DBG_VIEW            0x00000800  // gopher view functions
#define DBG_BUFFER          0x00001000  // gopher buffer functions
#define DBG_PARSE           0x00002000  // FTP/gopher parse functions
#define DBG_MEMALLOC        0x00004000  // Debug memory allocation/free functions
#define DBG_SERIALST        0x00008000  // Serialized List functions
#define DBG_THRDINFO        0x00010000  // INTERNET_THREAD_INFO functions
#define DBG_PROTOCOL        0x00020000  // protocol functions
#define DBG_DLL             0x00040000  // DLL functions
#define DBG_REFCOUNT        0x00080000  // logs all reference count functions
#define DBG_REGISTRY        0x00100000  // logs all registry functions
#define DBG_TRACE_SOCKETS   0x00200000  // monitors socket usage
#define DBG_ASYNC           0x00400000  // logs async functions
#define DBG_CACHE           0x00800000  // logs cache specific stuff
#define DBG_INVALID_HANDLES 0x01000000  // logs invalid handles (e.g. in InternetCloseHandle())
#define DBG_OBJECTS         0x02000000  // dump object info
#define DBG_PROXY           0x04000000  // dump proxy info
#define DBG_RESLOCK         0x08000000  // dump resource lock info
#define DBG_DIALUP          0x10000000  // dump dial-up info
#define DBG_GLOBAL          0x20000000  // dump global-scope functions
#define DBG_ANY             0xFFFFFFFF  // internal

//
// types
//

//
// INTERNET_DEBUG_INFO - structure that receives the current debugging variables
// via InternetQueryOption(), or which contains the new debugging variables to
// be set via InternetSetOption()
//

typedef struct {

    //
    // ErrorLevel - DBG_INFO, etc.
    //

    int ErrorLevel;

    //
    // ControlFlags - DBG_THREAD_INFO, etc.
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - DBG_INET, etc.
    //

    DWORD CategoryFlags;

    //
    // BreakFlags - DBG_API, etc. where breakpoints will be taken
    //

    DWORD BreakFlags;

    //
    // IndentIncrement - increment to use for each depth increase
    //

    int IndentIncrement;

    //
    // Filename - name of output log being used/to use
    //

    char Filename[1];

} INTERNET_DEBUG_INFO, *LPINTERNET_DEBUG_INFO;

//
// INTERNET_TRIGGER_INFO - a diagnostic trigger. Triggers are enabled when the
// function named in this structure is executed. Triggers can enable or disable
// diagnostics
//

typedef struct {

    //
    // FunctionName - name of the function to act as trigger. ControlFlags has
    // DBG_TRIGGER_ON or DBG_TRIGGER_OFF set
    //

    LPCSTR FunctionName;

    //
    // ControlFlags - control flags to use when the trigger is enabled. If the
    // trigger disables diagnostics then the previous control flags will be
    // restored
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - category flags to use when the trigger is enabled. See
    // ControlFlags
    //

    DWORD CategoryFlags;

} INTERNET_TRIGGER_INFO, *LPINTERNET_TRIGGER_INFO;

//
// INTERNET_DEBUG_TRIGGERS - 1 or more of these will be returned from/given to
// InternetQueryOption()/InternetSetOption()
//

typedef struct {

    //
    // Count - number of INTERNET_TRIGGER_INFO structures contained herein
    //

    DWORD Count;

    //
    // Triggers - an array of 0 or more INTERNET_TRIGGER_INFO structures
    //

    INTERNET_TRIGGER_INFO Triggers[1];

} INTERNET_DEBUG_TRIGGERS, *LPINTERNET_DEBUG_TRIGGERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\inc\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
// Don't #define memmove to RtlMoveMemory for wchar.h
// because the protoypes don't match.
#pragma push_macro("memmove")
#undef memmove
#include <wchar.h>
#pragma pop_macro("memmove")


LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    );

LONG
wtol (
    IN LPWSTR Src
    );


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(wtol)(Src)

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscat)((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscpy)((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(wcslen)(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(wcswcs)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(_wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(wcscmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(ultow)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(atol)(Src)

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(strstr)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)
#define STRREV(s)           (LPTSTR)MAKE_STR_FUNCTION(strrev)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(lstrcmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_strnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(_ultoa)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  MAKE_STR_FUNCTION(memcpy)
#define MEMMOVE                 MAKE_STR_FUNCTION(memmove)

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((MAKE_STR_FUNCTION(wcslen)(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\lib\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\lib\libentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>

#ifndef WINHTTP_STATIC_LIBRARY
#error libentry.cxx should not be compiled into winhttpx.dll
#endif

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
WinHttpDllMainHook(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CCritSec GeneralInitCritSec;

//
// functions
//

BOOL
WINAPI
WinHttpDllMainHook(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (!GeneralInitCritSec.Init())
            return FALSE;

        if (!g_pAsyncCount)
        {
            g_pAsyncCount = New CAsyncCount();

            if (!g_pAsyncCount)
                return FALSE;
        }

        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_DEBUG_MEMORY();
        INET_DEBUG_START();

        if (!GlobalDllInitialize() || !InternetCreateThreadInfo(TRUE))
        {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            InternetTerminateThreadInfo();
        }

        PERF_DUMP();

        PERF_END();

        if (g_pAsyncCount)
        {
            delete g_pAsyncCount;
            g_pAsyncCount = 0;
        }
        //TERMINATE_DEBUG_MEMORY(FALSE);
        TERMINATE_DEBUG_MEMORY(TRUE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();
        
        GeneralInitCritSec.FreeLock();
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
//#include <wininetp.h>

//bw #include "headers.h"

// #define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ole2.h>
#include <math.h>


#include <windowsx.h>

/*lint ++flb*/

//bw DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

void * __cdecl
_calloc(size_t num, size_t size)
{
    void * pv = malloc(num * size);
    if (NULL == pv)
    {
        return NULL;
    }
    ZeroMemory(pv, num * size);
    return pv;
}

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return ((long)lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        //bw //bw TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      //bw Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          //bw Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

	index = long(_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (USHORT)(_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (USHORT)(_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) _calloc(1, cbImage)) == NULL)
    {
         //bw TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          return (NULL);
        }

                if (_gifinfo.Gif89.transparent != -1)
						FillMemory(image, cbImage, (BYTE)_gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                //bw TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    GIFSCREEN GifScreen;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        //bw TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        //bw TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        //bw TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen.Width = LM_to_uint(buf[0], buf[1]);
    GifScreen.Height = LM_to_uint(buf[2], buf[3]);
    GifScreen.BitPixel = 2 << (buf[4] & 0x07);
    GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen.Background = buf[5];
    GifScreen.AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
        {
            //bw TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen.BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        //bw TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            //bw TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                //bw TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                //bw TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            //bw TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen.Width;  
                _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                //bw TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) _calloc(1, sizeof(GIFFRAME));
        
        if ( pgfNew == NULL )
        {
            //bw TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen.Width ||
            (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // CALLOC will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                free( pgfNew );
                
                //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // CALLOC will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    free( pgfNew );
                    //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen.BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}

//#include <vector>
//#define vector std::vector

//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = NULL;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   /*vector<>*/HBITMAP vhbmp;
   /*vector<>*/COLORREF vcolorKey;
   /*vector<>*/int vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
//      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      // vcolorKey.push_back(colorKey);
      vcolorKey = colorKey;

      // biao change : vhbmp.push_back(hbm);
      vhbmp = hbm;
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      // vdelay.push_back(pgf->gced.uiDelayTime);      
      vdelay = pgf->gced.uiDelayTime;

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage._gad.cLoops == 0 && gifimage._gad.fLooped != 0)
   {
		*loop = 0; // HUGE_VAL;
   }
   else
   {
        *loop = gifimage._gad.cLoops;
   }
   
   *numBitmaps = 1;

   // Since the vector will go out of scope, move contents over to heap
   hImage  = (HBITMAP *)malloc(1 * sizeof(HBITMAP)); 
   if (NULL == hImage)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *delays = (int*)malloc(1 * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)malloc( sizeof(COLORREF) * 1 ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   for(i=0; i < 1; i++) {
      hImage[i] = vhbmp; // biao fix [i];
      (*colorKeys)[i] = vcolorKey; // [i];
      (*delays)[i] = vdelay; //[i];
   }

   *ppBitMaps = hImage;

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       free(hImage);
       free(*delays);
       free(*colorKeys);
   }
   return hr;
}

/*lint --flb*/

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP** ppBmp)
{
    HRESULT hr;
	HBITMAP * phBMPs = NULL;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop,
                      &phBMPs);

    if (FAILED(hr))
    {
        return FALSE;
    }

    *ppBmp = phBMPs;
	
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\passport.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.cpp

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface implementation.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "ppdefs.h"
#include "Session.h"
#include "logon.h"
#include "passport.h"

// #include "passport.tmh"

// -----------------------------------------------------------------------------
PP_CONTEXT 
PP_InitContext(
    PCWSTR	pwszHttpStack,
    HINTERNET hSession
    )
{
//	WPP_INIT_TRACING(L"Microsoft\\Passport1.4");
    
    if (pwszHttpStack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitConect() : pwszHttpStack is null");
        return 0;
    }

    SESSION* pSession;
    if (SESSION::CreateObject(pwszHttpStack, hSession, pSession) == FALSE)
    {
        return 0;
    }


    DoTraceMessage(PP_LOG_INFO, "Passport Context Initialized");
    
    return reinterpret_cast<PP_CONTEXT>(pSession);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeContext(
	PP_CONTEXT hPP
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    
    if (pSession->RefCount() > 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "Passport Context ref count not zero before freed");
    }

    delete pSession;

    DoTraceMessage(PP_LOG_INFO, "Passport Context Freed");

//	WPP_CLEANUP();
}

// -----------------------------------------------------------------------------
PP_LOGON_CONTEXT
PP_InitLogonContext(
	PP_CONTEXT hPP,
    PCWSTR	pwszPartnerInfo,
    DWORD dwParentFlags
    )
{
    if (hPP == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() : hPP is null");
        return 0;
    }

    LOGON* pLogon = new LOGON(reinterpret_cast<SESSION*>(hPP), dwParentFlags);
    if (pLogon == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() failed; not enough memory");
        return 0;
    }

    if (pLogon->Open(pwszPartnerInfo) == FALSE)
    {
        delete pLogon;
        return 0;
    }

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Initialized");
    
    return reinterpret_cast<PP_LOGON_CONTEXT>(pLogon);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeLogonContext(
    PP_LOGON_CONTEXT    hPPLogon
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeLogonContext() : hPPLogon is null");
        return;
    }

    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    delete  pLogon;

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Freed");
}

// -----------------------------------------------------------------------------
DWORD
PP_Logon(
    PP_LOGON_CONTEXT    hPPLogon,
	HANDLE	            hEvent,
    PFN_LOGON_CALLBACK  pfnLogonCallback,
    DWORD               dwContext	
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_Logon() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->Logon();
}

// -----------------------------------------------------------------------------
BOOL
PP_GetChallengeInfo(
    PP_LOGON_CONTEXT hPPLogon,
	HBITMAP**		 ppBitmap,
    PBOOL            pfPrompt,
  	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetInfoFromChallenge() : hPPLogon is null");
        return FALSE;
    }

	//PP_ASSERT(ppBitmap != NULL);
	//PP_ASSERT(pfPrompt != NULL);
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

	return pLogon->GetChallengeInfo(ppBitmap,
									pfPrompt,
                                    pwszCbText,
                                    pdwTextLen,
                                    pwszRealm,
                                    dwMaxRealmLen);
}

// -----------------------------------------------------------------------------
BOOL 
PP_SetCredentials(
    PP_LOGON_CONTEXT    hPPLogon,
    PCWSTR              pwszRealm,
    PCWSTR              pwszTarget,
    PCWSTR              pwszSignIn,
    PCWSTR              pwszPassword
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_SetCredentials() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->SetCredentials(pwszRealm, pwszTarget, pwszSignIn, pwszPassword);
}

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetLogonHost() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    return pLogon->GetLogonHost(pwszHostName, pdwHostNameLen);
}


// -----------------------------------------------------------------------------
BOOL 
PP_GetAuthorizationInfo(
    PP_LOGON_CONTEXT hPPLogon,
	PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	OUT PDWORD       pdwTicketLen,
	PBOOL            pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	PWSTR            pwszUrl,    // user supplied buffer ...
	OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetReturnVerbAndUrl() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetAuthorizationInfo(pwszTicket, 
                                        pdwTicketLen, 
                                        pfKeepVerb, 
                                        pwszUrl, 
                                        pdwUrlLen);
}


// -----------------------------------------------------------------------------
VOID 
PP_Logout(
    IN PP_CONTEXT hPP,
    IN DWORD      dwFlags
    )
{
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    pSession->Logout();
}

BOOL
PP_ForceNexusLookup(
    PP_LOGON_CONTEXT    hPP,
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszDARealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{

    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->GetDAInfoFromPPNexus(pwszRegUrl,
                                          pdwRegUrlLen,
                                          pwszDARealm,
                                          pdwDARealmLen);
}


#ifdef PP_DEMO

// -----------------------------------------------------------------------------
BOOL PP_ContactPartner(
	PP_CONTEXT hPP,
    PCWSTR pwszPartnerUrl,
    PCWSTR pwszVerb,
    PCWSTR pwszHeaders,
    PWSTR pwszData,
    PDWORD pdwDataLength
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_ContactPartner() : hPPLogon is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->ContactPartner(pwszPartnerUrl,
                                    pwszVerb,
                                    pwszHeaders,
                                    pwszData,
                                    pdwDataLength
                                    );
}

#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\httpsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

/*
#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinHTTP.h>
*/

#define INTERNET_DEFAULT_HTTP_PORT      80
#define INTERNET_DEFAULT_HTTPS_PORT     443
#define WINHTTP_HEADER_NAME_BY_INDEX    NULL
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  0
#define INTERNET_OPEN_TYPE_PRECONFIG  INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000
#define INTERNET_FLAG_NO_AUTH           0x00040000
#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_QUERY_WWW_AUTHENTICATE     40

typedef
VOID
(CALLBACK * WINHTTP_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef int INTERNET_SCHEME, * LPINTERNET_SCHEME;

#define INTERNET_SCHEME_HTTP        (1)
#define INTERNET_SCHEME_HTTPS       (2)

#define INTERNET_SCHEME_PARTIAL     (-2)
#define INTERNET_SCHEME_UNKNOWN     (-1)
#define INTERNET_SCHEME_DEFAULT     (0)
#define INTERNET_SCHEME_SOCKS       (3)
#define INTERNET_SCHEME_FIRST       (INTERNET_SCHEME_HTTP)
#define INTERNET_SCHEME_LAST        (INTERNET_SCHEME_SOCKS)

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef WINHTTP_STATUS_CALLBACK
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);


class WINHTTP_SESSION : public SESSION
{
protected:
    WINHTTP_SESSION(void);
    virtual ~WINHTTP_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT);

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
friend SESSION* CreateWinHttpSession(void);
};

SESSION* CreateWinHttpSession(void)
{
    return new WINHTTP_SESSION();
}

//
// Implementation for WINHTTP_SESSION
//

// -----------------------------------------------------------------------------
WINHTTP_SESSION::WINHTTP_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WINHTTP_SESSION::~WINHTTP_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0,
						0, // optional total length
                        dwContext);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             WINHTTP_HEADER_NAME_BY_INDEX,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WINHTTP_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    return NULL;
    /*
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
    */
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WINHTTP_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}

PVOID WINHTTP_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    return (*m_pfnStatusCallback)(hInternet,
                                  (WINHTTP_STATUS_CALLBACK)lpfnCallback,
                                  0,
                                  0);

}

BOOL WINHTTP_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}

BOOL WINHTTP_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "WinHttpCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "WinHttpOpen"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpen not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "WinHttpConnect"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpConnect not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpOpenRequest"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenRequest not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpSendRequest"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSendRequest not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "WinHttpQueryHeaders"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryHeaders not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpSetOption"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetOption not found");
        goto exit;
    }

    /*
    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "WinHttpOpenUrl"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenUrl not found");
        goto exit;
    }
    */

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpQueryOption"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryOption not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "WinHttpCrackUrl"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCrackUrl not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "WinHttpReadData"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpReadData not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "WinHttpSetStatusCallback"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "WinHttpAddRequestHeaders"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpAddRequestHeaders not found");
        goto exit;
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

BOOL WINHTTP_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft WinHttp Passport Authentication Service 1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,  // ? name didn't get changed yet
                                         NULL,
                                         NULL,
                                         0 /*WINHTTP_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WINHTTP_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WINHTTP_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0,
                        0,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\logon.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Logon.cpp

Abstract:


Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"
#include "passport.h"
#include "session.h"
#include "logon.h"
#include "ole2.h"
#include "wincrypt.h"

// #include "logon.tmh"

#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_OK                  200 // request completed

#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_QUERY_AUTHENTICATION_INFO  76
#define HTTP_QUERY_WWW_AUTHENTICATE     40


// NOTE*** below we assume(!) the WinInet & WinHttp shared the same error VALUE

#define ERROR_HTTP_HEADER_NOT_FOUND     12150L
#define ERROR_INTERNET_INVALID_CA       12045L
#define INTERNET_OPTION_SECURITY_FLAGS  31

#define SECURITY_FLAG_IGNORE_REVOCATION         0x00000080
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID

#define SECURITY_SET_MASK       (SECURITY_FLAG_IGNORE_REVOCATION |\
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA |\
                                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID |\
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |\
                                 SECURITY_FLAG_IGNORE_WRONG_USAGE)

#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define INTERNET_STATUS_REDIRECT                110

#define HTTP_ADDREQ_FLAG_ADD        0x20000000
#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)


LOGON::LOGON(SESSION* pSession, DWORD dwParentFlags)
    : m_pSession(pSession)
{
    m_pSession->AddRef();

    m_hConnect = NULL;
    
    m_fCredsPresent = FALSE;
    m_pwszSignIn = NULL;
    m_pwszPassword = NULL;

    m_pwszTicketRequest = NULL;
    m_pwszAuthInfo = NULL;
    m_pwszReturnUrl = NULL;

    m_pBitmap = NULL;
    m_fPrompt = FALSE;

    m_wTimeSkew[0] = L'\0';
    m_wNewDAUrl[0] = 0;
    m_dwParentFlags = dwParentFlags;

}

LOGON::~LOGON(void)
{
    if (m_pwszAuthInfo)
    {
        delete [] m_pwszAuthInfo;
    }
    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }
    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }
    if (m_pwszTicketRequest)
    {
        delete [] m_pwszTicketRequest;
    }
    if (m_pwszAuthHeader)
    {
        delete [] m_pwszAuthHeader;
    }
    m_pSession->RemoveRef();
}

// -----------------------------------------------------------------------------
BOOL LOGON::Open(
    PCWSTR	pwszPartnerInfo // in the form of "WWW-Authenticate: Passport1.4 ..."
    )
{
    PP_ASSERT(pwszPartnerInfo != NULL);

    // locate the auth scheme name, i.e. Passport1.4
    
    PCWSTR pwszTicketRequest = ::wcsstr(pwszPartnerInfo, L"Passport1.4");
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Passport1.4 scheme not found");
        return FALSE;
    }
    
    pwszTicketRequest += ::wcslen(L"Passport1.4");
    
    // skip white spaces between the scheme name and the Ticket Request (TR)

    while (*pwszTicketRequest == (L" ")[0]) { ++pwszTicketRequest; }
    
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Ticket Request missing");
        return FALSE;
    }
    
    // save the TR
    
    DWORD dwTrLen = ::wcslen(pwszTicketRequest);
    m_pwszTicketRequest = new WCHAR[dwTrLen + 1];
    if (m_pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }
    ::wcscpy(m_pwszTicketRequest, pwszTicketRequest);

    m_pwszAuthHeader = new WCHAR[dwTrLen + 2048/*Prepared for long creds*/ + 1]; 
    if (m_pwszAuthHeader == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }

    DoTraceMessage(PP_LOG_INFO, "LOGON::Open() succeed");

    return TRUE;
}

void LOGON::Close(void)
{
    PP_ASSERT(m_hConnect != NULL);
    PP_ASSERT(m_pSession != NULL);

    m_pSession->CloseHandle(m_hConnect);
    m_hConnect = NULL;
}



// pClearPassword is assumed to be at least 256 chars

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize )
{
    BOOL bOrigEncrypted = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    if ( pClearPassword == NULL )
        return;

    if ( cbSize == 0 )
    {
        // CryptUnprotectData doesn't like to be sent a zero-length buffer
        pClearPassword[0] = L'\0';
        return;		
    }

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            DWORD dwOutChars = OutBlob.cbData/sizeof(WCHAR);
            if ( dwOutChars < 256 )
            {
                wcsncpy ( pClearPassword, (WCHAR*)OutBlob.pbData, dwOutChars );
                pClearPassword[dwOutChars] = L'\0';
            }
            bOrigEncrypted = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    if ( !bOrigEncrypted )
    {
        // copy the plain text
        wcsncpy ( pClearPassword, (WCHAR*)pPassword, 256 );
    }

    return;
}



void LOGON::GetCachedCreds(
	PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    *pppCreds = NULL;
    *pdwCreds = 0;

    if (m_pSession->m_pfnReadDomainCred == NULL)
    {
        return;
    }

    ULONG CredTypes = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
    DWORD dwFlags = CRED_CACHE_TARGET_INFORMATION;
    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;


    memset ( (void*)&TargetInfo, 0, sizeof(CREDENTIAL_TARGET_INFORMATIONW));

	TargetInfo.TargetName = const_cast<PWSTR>(pwszTarget);
    TargetInfo.DnsDomainName = const_cast<PWSTR>(pwszRealm);
	TargetInfo.PackageName = L"Passport1.4";

    TargetInfo.Flags = 0;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;

    if ((*m_pSession->m_pfnReadDomainCred)(&TargetInfo, 
                                           dwFlags,
                                           pdwCreds,
                                           pppCreds ) != TRUE)
    {
        *pppCreds = NULL;
        *pdwCreds = 0;

    }
    else
    {
        if (m_pSession->IsLoggedOut())
        {
            FILETIME LogoutTimestamp;
            ::SystemTimeToFileTime(m_pSession->GetLogoutTimeStamp(), &LogoutTimestamp);
            if (CompareFileTime(&((**pppCreds)->LastWritten), &LogoutTimestamp) == -1)
            {
                // the cred is entered/created earlier (less) than the Logout request. It is no good.

                m_pSession->m_pfnCredFree(*pppCreds);
                *pppCreds = NULL;
                *pdwCreds = 0;
            }
            else
            {
            m_pSession->ResetLogoutFlag();
            }
        }
    }


    return;
}

// -----------------------------------------------------------------------------
BOOL LOGON::SetCredentials(
	PCWSTR pwszRealm,
	PCWSTR pwszTarget,
    PCWSTR pwszSignIn,
    PCWSTR pwszPassword
    )
{
    WCHAR wPass[256];
    PCREDENTIALW* ppCred = NULL;
    DWORD dwCreds = 0;
    PCREDENTIALW pCredToUse = NULL;

    if ((!pwszSignIn) && (!pwszPassword))
    {
		GetCachedCreds(pwszRealm, pwszTarget, &ppCred, &dwCreds);

        if (dwCreds > 0 && ppCred[0] != NULL )
        {
            for ( DWORD idx = 0; idx < dwCreds; idx++ )
            {
                if ( ppCred[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
                {
                    // check to see if prompt bit is set.   If set, keep looking, only use if
                    // the prompt bit isn't set.
                    if ( !(ppCred[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
                    {
                        pCredToUse = ppCred[idx];
                        break;
                    }
                }
            }
        }



        if (pCredToUse == NULL)
        {
            return FALSE;
        }

        DecryptPassword(wPass, 
                  PVOID(pCredToUse->CredentialBlob), 
                  pCredToUse->CredentialBlobSize);

        pwszSignIn = pCredToUse->UserName;
        pwszPassword = wPass;

    }

    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }

    DWORD dwSignInLen = ::wcslen(pwszSignIn);
    m_pwszSignIn = new WCHAR[dwSignInLen + 1];
    if (m_pwszSignIn == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        return FALSE;
    }

    ::wcscpy(m_pwszSignIn, pwszSignIn);

    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }

    DWORD dwPasswordLen = ::wcslen(pwszPassword);
    m_pwszPassword = new WCHAR[dwPasswordLen + 1];
    if (m_pwszPassword == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        delete [] m_pwszSignIn;
        m_pwszSignIn = NULL;
        return FALSE;
    }

    ::wcscpy(m_pwszPassword, pwszPassword);
    
    m_fCredsPresent = TRUE;

    if (ppCred)
    {
        if (m_pSession->m_pfnCredFree)
        {
            m_pSession->m_pfnCredFree(ppCred);
        }
    }

    return TRUE;
}

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP** ppBmp);
// -----------------------------------------------------------------------------
BOOL LOGON::DownLoadCoBrandBitmap(
    PWSTR pwszChallenge
    )
{
    PP_ASSERT(pwszChallenge != NULL);

    PWSTR pwszCbUrl = NULL;
    BOOL fRet = FALSE;

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(pwszChallenge, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no text in between commas");
            goto next_token;
        }

        // find cburl
        if (!::_wcsnicmp(Token, L"cburl", ::wcslen(L"cburl")))
        {
            PWSTR CbUrl = ::wcsstr(Token, L"=");
            if (CbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            CbUrl++; // skip "="

            while (*CbUrl == (L" ")[0]) { ++CbUrl; } // skip leading white spaces

            pwszCbUrl = new WCHAR[::wcslen(CbUrl)+1];
            if (pwszCbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; not enough memory");
                goto exit;
            }
            ::wcscpy(pwszCbUrl, CbUrl);

            DoTraceMessage(PP_LOG_INFO, "CoBrand URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"ts", ::wcslen(L"ts")))
        {
            ::wcscpy(m_wTimeSkew, Token);
        }
        else if (!::_wcsnicmp(Token, L"srealm", ::wcslen(L"srealm")))
        {
            PWSTR pwszRealm = ::wcsstr(Token, L"=");
            if (pwszRealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            pwszRealm++; // skip "="

            while (*pwszRealm == (L" ")[0]) { ++pwszRealm; } // skip leading white spaces

            ::wcscpy(m_wRealm, pwszRealm);

            DoTraceMessage(PP_LOG_INFO, "sRealm URL %ws found", pwszCbUrl);
        }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (pwszCbUrl)
    {
        HINTERNET hCbUrl = m_pSession->OpenUrl(pwszCbUrl, NULL, 0, 0);
        if (hCbUrl == NULL)
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; can not open URL %ws",
                           pwszCbUrl);
            goto exit;
        }

        {
            BYTE bBuf[1024];
            DWORD cbBuf = sizeof(bBuf);
            DWORD cbRead = 0;
            LPSTREAM pStream;

            if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) != S_OK)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            while (m_pSession->ReadFile(hCbUrl, bBuf, cbBuf, &cbRead) && cbRead)
                pStream->Write(bBuf, cbRead, NULL);

            LARGE_INTEGER Zero = {0};
            pStream->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream

            DoTraceMessage(PP_LOG_INFO, "CoBrand Graphic %ws downloaded", pwszCbUrl);
            
            if (Gif2Bmp(pStream, &m_pBitmap) == FALSE)
            {
                DoTraceMessage(PP_LOG_ERROR, "Gif2Bmp() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            pStream->Release();
            m_pSession->CloseHandle(hCbUrl);

            fRet = TRUE;

            DoTraceMessage(PP_LOG_INFO, "CoBrand Bitmap created");
        }
    }

exit:
    if (pwszCbUrl)
    {
        delete [] pwszCbUrl;
    }

    return fRet;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle401FromDA(
    HINTERNET   hRequest, 
    BOOL        fTicketRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    DWORD dwIndex = 0;
    BOOL  fFound = FALSE;
    WCHAR Challenge[2048];


    while (dwIndex != ERROR_HTTP_HEADER_NOT_FOUND)
    {
        DWORD ChallengeLength = sizeof(Challenge) / sizeof(WCHAR);

        if(m_pSession->QueryHeaders(hRequest,
                                    HTTP_QUERY_WWW_AUTHENTICATE, 
                                    Challenge,
                                    &ChallengeLength,
                                    &dwIndex))
        {
            if (::wcsstr(::_wcslwr(Challenge), L"passport1.4"))
            {
                fFound = TRUE;
                break;
            }
        }
        else
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                           dwErrorCode);
            break;
        }
    }

    if (!fFound)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; Passport1.4 auth header not found");
        goto exit;
    }

    if (::wcsstr(::_wcslwr(Challenge), L"retry"))
    {
        // biaow-todo: not yet implemented
        PP_ASSERT(TRUE); // shouldn't reach here
        dwRetVal = PP_LOGON_REQUIRED;
    }
    else if (::wcsstr(::_wcslwr(Challenge), L"failed"))
    {
        if (fTicketRequest)
        {
            dwRetVal = PP_LOGON_REQUIRED;
            DoTraceMessage(PP_LOG_INFO, "Handle401FromDA() : Logon required by DA");
        }
        else
        {
            dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
            DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
        }
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; no valid DA status");
        goto exit;
    }

    if (dwRetVal == PP_LOGON_REQUIRED)
    {
        if (::wcsstr(::_wcslwr(Challenge), L"prompt"))
        {
            m_fPrompt = TRUE;
        }
        else
        {
            m_fPrompt = FALSE;
        }

        DownLoadCoBrandBitmap(Challenge);
    }

exit:
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle200FromDA(
    HINTERNET hRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    
    PWSTR pwszBuffer = NULL;
    DWORD dwBuffer = 0;
    if((!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_AUTHENTICATION_INFO, 
                                  pwszBuffer,
                                  &dwBuffer))
       && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        pwszBuffer = new WCHAR[dwBuffer];
        if (pwszBuffer == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
            goto exit;
        }

        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_AUTHENTICATION_INFO, 
                                      pwszBuffer,
                                      &dwBuffer))
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; no Authenticate-Info header found");
            goto exit;
        }

        WCHAR Delimiters[] = L",";
        PWSTR Token = ::wcstok(pwszBuffer, Delimiters);
        while (Token != NULL)
        {
            while (*Token == (L" ")[0]) { ++Token; }
            if (Token == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::Handle200FromDA() : no text in between commas");
                goto next_token;
            }

            if (!::_wcsnicmp(Token, L"ru", ::wcslen(L"ru")))
            {
                PWSTR ReturnUrl = ::wcsstr(Token, L"=");
                if (ReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() : no = after cburl");
                    goto exit;
                }
                ReturnUrl++; // skip =
                
                while (*ReturnUrl == (L" ")[0]) { ++ReturnUrl; }  // skip leading white spaces
                
                m_pwszReturnUrl = new WCHAR[::wcslen(ReturnUrl)+1];
                if (m_pwszReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszReturnUrl, ReturnUrl);
            }
            else if (!::_wcsnicmp(Token, L"from-pp", ::wcslen(L"from-pp")))
            {
                m_pwszAuthInfo = new WCHAR[::wcslen(Token)+1];
                if (m_pwszAuthInfo == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszAuthInfo, Token);
            }

        next_token:

            Token = ::wcstok(NULL, Delimiters);
        }

        dwRetVal = PP_LOGON_SUCCESS;
    }
    else
    {
        PP_ASSERT(TRUE); // shouldn't reach here
        goto exit;
    }

exit:

    if (pwszBuffer)
    {
        delete [] pwszBuffer;
    }

    return dwRetVal;
}

VOID PrvLogonStatusCallback(    
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
)
{
    LOGON* pLogon = reinterpret_cast<LOGON*>(dwContext);

    pLogon->StatusCallback(hInternet,
                           dwInternetStatus,
                           lpvStatusInformation,
                           dwStatusInformationLength);


}

VOID LOGON::StatusCallback(
    IN HINTERNET hInternet,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength)
{
    if (dwInternetStatus == INTERNET_STATUS_REDIRECT)
    {
        ::wcscpy(m_wNewDAUrl, (LPCWSTR)lpvStatusInformation);
        BOOL fRet = m_pSession->AddHeaders(hInternet, 
                               m_pwszAuthHeader, 
                               ::wcslen(m_pwszAuthHeader),
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE
                               );

        PP_ASSERT(fRet == TRUE);
    }
}

BOOL LOGON::GetLogonHost(
    PWSTR       pwszHostName,
    OUT PDWORD  pdwHostNameLen
    ) const
{
    if (*pdwHostNameLen < DWORD(::wcslen(m_wDAHostName) + 1))
    {
        *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszHostName != NULL);

    ::wcscpy(pwszHostName, m_wDAHostName);

    *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;

    return TRUE;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Logon(
    void
    )
{
    PP_ASSERT(m_pSession != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    BOOL fTicketRequest;
    HINTERNET hRequest = 0;
    DWORD dwFlags = 0;

    ::wcscpy(m_pwszAuthHeader, L"Authorization: Passport1.4 ");

    if (m_fCredsPresent)
    {
        ::wcscat(m_pwszAuthHeader, L"sign-in=");
        ::wcscat(m_pwszAuthHeader, m_pwszSignIn);
        ::wcscat(m_pwszAuthHeader, L",");
        
        ::wcscat(m_pwszAuthHeader, L"pwd=");
        ::wcscat(m_pwszAuthHeader, m_pwszPassword);
        ::wcscat(m_pwszAuthHeader, L",");

        if (m_wTimeSkew[0])
        {
            ::wcscat(m_pwszAuthHeader, m_wTimeSkew);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        fTicketRequest = FALSE; // this is a login request, since we've gather credentials
    }
    else
    {
        ::wcscat(m_pwszAuthHeader, L"tname = , ");
        
        fTicketRequest = TRUE;
    }
    
    ::wcscat(m_pwszAuthHeader, m_pwszTicketRequest);

retry:

    // attempt connecting to the Passport DA

    if (m_hConnect)
    {
        m_pSession->CloseHandle(m_hConnect);
    }

    WCHAR       wDATargetObj[256];
    
    DWORD fStstus = m_pSession->GetDAInfo(m_pwszSignIn,
                                          m_wDAHostName, 256,
                                          wDATargetObj, 256);

    PP_ASSERT(fStstus == TRUE);
    
    m_hConnect = m_pSession->Connect(m_wDAHostName/*m_pSession->GetLoginHost()*/,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                                     );
    if (m_hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; can not connect to %ws, Error = %d",
                       m_wDAHostName, dwErrorCode);
        goto exit;
    }
    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }

    dwFlags = m_dwParentFlags;

    hRequest = m_pSession->OpenRequest(m_hConnect,
                                       NULL, // "GET"
                                       wDATargetObj/*m_pSession->GetLoginTarget()*/,
#ifdef DISABLE_SSL
                                       dwFlags | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS,
#else                                                 
                                                 dwFlags | INTERNET_FLAG_SECURE,
#endif
                                       (DWORD_PTR)this
                                       );
    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wDATargetObj, dwErrorCode);
        goto exit;
    }
    
    m_wNewDAUrl[0] = 0;
    m_pSession->SetStatusCallback(hRequest, PrvLogonStatusCallback);
    
    if (!m_pSession->SendRequest(hRequest, 
                                 m_pwszAuthHeader, 
                                 ::wcslen(m_pwszAuthHeader),
                                 (DWORD_PTR)this))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!m_pSession->QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!m_pSession->SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!m_pSession->SendRequest(hRequest, NULL, 0))
                {
                    dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                                   dwErrorCode);
                    goto exit;
                }
                else
                {
                    dwErrorCode = ERROR_SUCCESS;
                }
            }
        }
#endif // BAD_CERT_OK
        
        if (dwErrorCode != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                           dwErrorCode);

            if (m_pSession->GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == TRUE)
            {
                goto retry;
            }

            goto exit;
        }
    }

    {
        DWORD dwStatus, dwStatusLen;
        dwStatusLen = sizeof(dwStatus);
        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                                      &dwStatus,
                                      &dwStatusLen))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; can not retrieve Status Code, Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    
        if (dwStatus == HTTP_STATUS_DENIED)
        {
            dwRetVal = Handle401FromDA(hRequest, fTicketRequest);
        }
        else if (dwStatus == HTTP_STATUS_OK)
        {
            dwRetVal = Handle200FromDA(hRequest);
        }
        else
        {
            //PP_ASSERT(TRUE); // shouldn't reach here
            //goto exit;
        }

        if (dwRetVal == PP_GENERIC_ERROR)
        {
            if (m_pSession->GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == TRUE)
            {
                goto retry;
            }
        }
        else
        {
            if (m_wNewDAUrl[0])
            {
                m_pSession->UpdateDAInfo(m_pwszSignIn,
                                         m_wNewDAUrl);
                m_wNewDAUrl[0] = 0;
            }
        }
    }

exit:

    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetChallengeInfo(
	HBITMAP**		 ppBitmap,
	PBOOL			 pfPrompt,
	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen
    ) const
{
    if (ppBitmap)
    {
        *ppBitmap = m_pBitmap;
    }
    if (pfPrompt)
    {
        *pfPrompt = m_fPrompt;
    }

	// *pdwTextLen = 0; // biaow-todo:
    
    if (pwszRealm)
    {
        ::wcsncpy(pwszRealm, m_wRealm, dwMaxRealmLen-1);
    }
    
    return TRUE;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetAuthorizationInfo(
    PWSTR   pwszTicket,
    PDWORD  pdwTicketLen,
    PBOOL   pfKeepVerb,
    PWSTR   pwszUrl,
    PDWORD  pdwUrlLen 
    ) const
{
    if (m_pwszReturnUrl == NULL)
    {
        *pfKeepVerb = TRUE;
        *pdwUrlLen = 0;
        return TRUE;
    }

    if (*pdwUrlLen < DWORD(::wcslen(m_pwszReturnUrl) + 1))
    {
        *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszUrl != NULL);

    ::wcscpy(pwszUrl, m_pwszReturnUrl);

    *pfKeepVerb = FALSE;
    *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;

    if (*pdwTicketLen < DWORD(::wcslen(m_pwszAuthInfo) + 1))
    {
        *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszTicket != NULL);

    ::wcscpy(pwszTicket, m_pwszAuthInfo);
    *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\logon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    logon.h

Abstract:

    This interface abstracts a Passport Logon Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef LOGON_H
#define LOGON_H

class SESSION;

class LOGON
{
public:
    LOGON(SESSION*, DWORD dwParentFlags);
    virtual ~LOGON(void);

    BOOL Open(PCWSTR pwszPartnerInfo);
    void Close(void);

    BOOL SetCredentials(
        PCWSTR pwszRealm,
        PCWSTR pwszTarget,
        PCWSTR pwszSignIn,
        PCWSTR pwszPassword
        );

    BOOL GetLogonHost(
    	PWSTR       pwszHostName,
    	OUT PDWORD  pdwHostNameLen
        ) const;

    DWORD Logon(void);

    BOOL GetChallengeInfo(
		HBITMAP**		 ppBitmap,
        PBOOL            pfPrompt,
    	PWSTR			 pwszCbText,
        PDWORD           pdwTextLen,
        PWSTR            pwszRealm,
        DWORD            dwMaxRealmLen
        ) const;

    BOOL GetAuthorizationInfo(
        PWSTR   pwszTicket,       // e.g. "from-PP = ..."
        PDWORD  pdwTicketLen,
        PBOOL   pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
        PWSTR   pwszUrl,    // user supplied buffer ...
        PDWORD  pdwUrlLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    VOID StatusCallback(
        IN HINTERNET hInternet,
        IN DWORD dwInternetStatus,
        IN LPVOID lpvStatusInformation,
        IN DWORD dwStatusInformationLength);

protected:
    void GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL DownLoadCoBrandBitmap(
        PWSTR pwszChallenge
        );

    DWORD Handle401FromDA(
        HINTERNET   hRequest, 
        BOOL        fTicketRequest
        );

    DWORD Handle200FromDA(
        HINTERNET hRequest
        );

protected:

    SESSION*    m_pSession;

    HINTERNET   m_hConnect;
    BOOL        m_fCredsPresent;
    PWSTR       m_pwszSignIn;
    PWSTR       m_pwszPassword;
    WCHAR       m_wNewDAUrl[1024];
    PWSTR       m_pwszTicketRequest;
    PWSTR       m_pwszAuthInfo;
    PWSTR		m_pwszReturnUrl;
    // PWSTR       m_pwszCbUrl;
	BOOL		m_fWhistler;
    HBITMAP*    m_pBitmap;
    BOOL        m_fPrompt;
    WCHAR       m_wRealm[128];
    WCHAR       m_wTimeSkew[16];
    PWSTR       m_pwszAuthHeader;
    DWORD       m_dwParentFlags;

    WCHAR       m_wDAHostName[256];

};

#endif // LOGON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\inetsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinInet.h>
#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpwszUserName OPTIONAL,
    IN LPCWSTR lpwszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef INTERNET_STATUS_CALLBACK 
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
);

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);

class WININET_SESSION : public SESSION
{
protected:
    WININET_SESSION(void);
    virtual ~WININET_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT
        );

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
};

//
// Implementation for SESSION
//

SESSION* CreateWinHttpSession(void);

// -----------------------------------------------------------------------------
BOOL SESSION::CreateObject(PCWSTR pwszHttpStack, HINTERNET hSession, SESSION*& pSess)
{
    PP_ASSERT(pwszHttpStack != NULL);
    
    pSess = NULL;

    if (!::_wcsicmp(pwszHttpStack, L"WinInet.dll") || 
        !::_wcsicmp(pwszHttpStack, L"WinInet"))
    {
        pSess = new WININET_SESSION();
    }
    else
    {
        pSess = ::CreateWinHttpSession();
    }

    if (pSess)
    {
        return pSess->Open(pwszHttpStack, hSession);
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "CreateObject() failed; not enough memory");
        return FALSE;
    }
}

// -----------------------------------------------------------------------------
SESSION::SESSION(void)
{
    m_hHttpStack = 0;
    m_hCredUI = 0;
    m_RefCount = 0;

    m_pfnReadDomainCred = NULL;
    m_pfnCredFree = NULL;

    m_hKeyLM = NULL;
    m_hKeyCU = NULL;
    m_hKeyDAMap = NULL;

    m_fLogout = FALSE;

    m_LastNexusDownloadTime = 0xFFFFFFFF;
}

// -----------------------------------------------------------------------------
SESSION::~SESSION(void)
{
}

BOOL SESSION::GetDAInfoFromPPNexus(
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszRealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    BOOL fRetVal = FALSE;
    HINTERNET hRequest = NULL;
    HINTERNET hConnect = NULL;
    DWORD dwError;
    
#ifdef DBG
    WCHAR wNexusHost[512] = L"nexus.msn.pp.test.microsoft.com";
#else
    WCHAR wNexusHost[512] = L"nexus.passport.com";
#endif
    
    DWORD dwHostLen = sizeof(wNexusHost); // note: size of the buffer, not # of UNICODE characters
    
#ifdef DBG
    WCHAR wNexusObj[512] = L"sprdr/pprdr.asp";
#else
    WCHAR wNexusObj[512] = L"rdr/pprdr.asp";
#endif    
    DWORD dwObjLen = sizeof(wNexusObj);
    
    WCHAR wPassportUrls[1024];
    DWORD dwUrlsLen = ARRAYSIZE(wPassportUrls);
    DWORD dwValueType;

    WCHAR Delimiters[] = L",";
    PWSTR Token = NULL;
    // we allow only one Nexus contact per session to avoid infinite loop due to Nexus misconfiguration

    DWORD dwCurrentTime = ::GetTickCount();

    if ((dwCurrentTime >= m_LastNexusDownloadTime) && 
        (dwCurrentTime - m_LastNexusDownloadTime < 5*60*1000)) // 5 minutes
    {
        DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() failed: Nexus info already downloaded");
        goto exit;
    }

    // biaow-todo: when the Passport Team gives us THE final Nexus name, we'll then hard-code it here. And
    //             there will be no need to query registry here by then.
    
    if (m_hKeyLM)
    {
        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusHost",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusHost),
                                     &dwHostLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!

        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusObj",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusObj),
                                     &dwObjLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!
    }
    
    hConnect = Connect(wNexusHost,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                       );
    if (hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::GetDAInfoFromPPNexus(): failed to connect to %ws; Error = %d", 
                       wNexusHost, dwErrorCode);
        goto exit;
    }

    hRequest = OpenRequest(hConnect,
                           NULL,
                           wNexusObj,
#ifdef DISABLE_SSL
                           0
#else                                                 
                           INTERNET_FLAG_SECURE
#endif
                           );

    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wNexusObj, dwErrorCode);
        goto exit;
    }


    if (!SendRequest(hRequest, NULL, 0))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!SendRequest(hRequest, NULL, 0))
                {
                    DWORD dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): SendRequest() failed");
                    goto exit;
                }
            }
        }
#else
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): failed");
        goto exit;
#endif // BAD_CERT_OK
    }

    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     wPassportUrls,
                     &dwUrlsLen) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
        goto exit;
    }

    Token = ::wcstok(wPassportUrls, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no text in between commas");
            goto next_token;
        }

        // find DALocation
        if (!::_wcsnicmp(Token, L"DALogin", ::wcslen(L"DALogin")))
        {
            PWSTR pwszDAUrl = ::wcsstr(Token, L"=");
            if (pwszDAUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DALocation");
                goto exit;
            }
            
            pwszDAUrl++; // skip "="

            while (*pwszDAUrl == (L" ")[0]) { ++pwszDAUrl; } // skip leading white spaces

            ::wcscpy(m_wDefaultDAUrl, L"https://");
            ::wcscat(m_wDefaultDAUrl, pwszDAUrl);

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                    ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR));
                }
            }

            m_LastNexusDownloadTime = ::GetTickCount();
            fRetVal = TRUE;

            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DARealm", ::wcslen(L"DARealm")))
        {
            PWSTR pwszDARealm = ::wcsstr(Token, L"=");
            if (pwszDARealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DARealm");
                goto exit;
            }

            pwszDARealm++; // skip "="

            while (*pwszDARealm == (L" ")[0]) { ++pwszDARealm; } // skip leading white spaces

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR));
                }
            }

            if (pwszRealm)
            {
                if (*pdwRealmLen < ::wcslen(pwszDARealm) + 1)
                {
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                    fRetVal = FALSE;
                    goto exit;
                }
                else
                {
                    ::wcscpy(pwszRealm, pwszDARealm);
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                }
            }
            
            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DAReg", ::wcslen(L"DAReg")))
            {
                PWSTR pwszDAReg = ::wcsstr(Token, L"=");
                if (pwszDAReg == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DAReg");
                    goto exit;
                }

                pwszDAReg++; // skip "="

                while (*pwszDAReg == (L" ")[0]) { ++pwszDAReg; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR));
                    }
                }

                if (pwszRegUrl)
                {
                    if (*pdwRegUrlLen < ::wcslen(pwszDAReg) + 1)
                    {
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                        fRetVal = FALSE;
                        goto exit;
                    }
                    else
                    {
                        ::wcscpy(pwszRegUrl, pwszDAReg);
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
            }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

exit:
    if (hRequest)
    {
        CloseHandle(hRequest);
    }
    if (hConnect)
    {
        CloseHandle(hConnect);
    }

    return fRetVal;
}

BOOL SESSION::UpdateDAInfo(
    PCWSTR pwszSignIn,
    PCWSTR pwszDAUrl
    )
{
    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwError = ::RegSetValueExW(m_hKeyDAMap,
                                             pwszDomain,
                                             0,
                                             REG_SZ,
                                             reinterpret_cast<const LPBYTE>(const_cast<PWSTR>(pwszDAUrl)),
                                             ::wcslen(pwszDAUrl) * sizeof(WCHAR));
            if (dwError == ERROR_SUCCESS)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL SESSION::GetDAInfo(PCWSTR pwszSignIn,
                        LPWSTR pwszDAHostName,
                        DWORD HostNameLen,
                        LPWSTR pwszDAHostObj,
                        DWORD HostObjLen)
{
    LPCWSTR pwszDAUrl = m_wDefaultDAUrl;

    WCHAR wDomainDAUrl[1024];
    DWORD dwDomainUrlLen = sizeof(wDomainDAUrl);

    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwValueType;
            DWORD dwError = ::RegQueryValueExW(m_hKeyDAMap, 
                                               pwszDomain,
                                               0,
                                               &dwValueType,
                                               reinterpret_cast<LPBYTE>(wDomainDAUrl),
                                               &dwDomainUrlLen);
            
            PP_ASSERT(!(dwError == ERROR_MORE_DATA));
            // PP_ASSERT(dwValueType == REG_SZ);

            if (dwError == ERROR_SUCCESS)
            {
                pwszDAUrl = wDomainDAUrl;
            }
        }
    }

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));

    UrlComps.dwStructSize = sizeof(UrlComps);

    UrlComps.lpszHostName = pwszDAHostName;
    UrlComps.dwHostNameLength = HostNameLen;

    UrlComps.lpszUrlPath = pwszDAHostObj;
    UrlComps.dwUrlPathLength = HostObjLen;

    if (CrackUrl(pwszDAUrl, 
                 0, 
                 0, 
                 &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::GetDAInfo() failed; can not crack the URL %ws",
                       pwszDAUrl);
        return FALSE;
    }

    return TRUE;
}


BOOL SESSION::Open(PCWSTR /*pwszHttpStack*/, HINTERNET)
{
    BOOL fRetVal = FALSE;
    DWORD dwError;
    DWORD dwValueType;
    DWORD dwUrlLen = sizeof(m_wDefaultDAUrl); // note: size of the buffer, not # of UNICODE characters
    BOOL fDAInfoCached = FALSE; // assume NO DA info's cached locally

    dwError = ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyLM,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
        // we can't open the Passport key for read & write, let's try open it for read only
        ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyLM,
                          NULL);

        // if we still can't open it for read, we are still fine since we can download the info from the
        // Nexus server. *NOTE* m_hKeyLM could be NULL from this point on.
    }

    dwError = ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyCU,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);

        ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyCU,
                          NULL);
    }

    if (m_hKeyCU)
    {
        dwError = ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);

        if (dwError != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
            ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);        
        }
    }
    
    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerUrl",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                           &dwUrlLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerUrl",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                               &dwUrlLen) == ERROR_SUCCESS)
        {
            fDAInfoCached = TRUE;
        }
    }
    else
    {
        fDAInfoCached = TRUE;
    }

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    // PP_ASSERT(dwValueType == REG_SZ); BVT break!!!

    if (!fDAInfoCached || (::wcslen(m_wDefaultDAUrl) == ::wcslen(L"")))
    {
        if (GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == FALSE)
        {
            goto exit;
        }
    }
    else
    {
        /*
        URL_COMPONENTSW UrlComps;
        ::memset(&UrlComps, 0, sizeof(UrlComps));

        UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

        UrlComps.lpszHostName = m_wDAHostName;
        UrlComps.dwHostNameLength = ARRAYSIZE(m_wDAHostName);

        UrlComps.lpszUrlPath = m_wDATargetObj;
        UrlComps.dwUrlPathLength = ARRAYSIZE(m_wDATargetObj);

        if (CrackUrl(m_wDefaultDAUrl, 
                          0, 
                          0, 
                          &UrlComps) == FALSE)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "WININET_SESSION::Open() failed; can not crack the URL %ws",
                           m_wDefaultDAUrl);
            goto exit;
        }
        */
    }

    /*
    DWORD dwRegUrlLen = sizeof(m_wRegistrationUrl);
    dwError = ::RegQueryValueExW(m_hKeyLM, 
                       L"RegistrationUrl",
                       0,
                       &dwValueType,
                       reinterpret_cast<LPBYTE>(m_wRegistrationUrl),
                       &dwRegUrlLen);

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    */

    m_hCredUI = ::LoadLibraryW(L"advapi32.dll");
    if (m_hCredUI)
    {
        m_pfnReadDomainCred = 
                    reinterpret_cast<PFN_READ_DOMAIN_CRED_W>(::GetProcAddress(m_hCredUI, "CredReadDomainCredentialsW"));
        if (m_pfnReadDomainCred == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredReadDomainCredentialsW()"); 
        }

        m_pfnCredFree = 
            reinterpret_cast<PFN_CRED_FREE>(::GetProcAddress(m_hCredUI, "CredFree"));
        if (m_pfnCredFree == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredFree()"); 
        }
    }

    fRetVal = TRUE;

exit:

    return fRetVal;
}

void SESSION::Logout(void)
{
    if (!m_fLogout)
    {
        m_fLogout = TRUE;
        ::GetSystemTime(&m_LogoutTimeStamp);
    }
}

BOOL SESSION::IsLoggedOut(void) const
{
    return m_fLogout;
}

void SESSION::ResetLogoutFlag(void)
{
    m_fLogout = FALSE;
}

const SYSTEMTIME* SESSION::GetLogoutTimeStamp(void) const
{
    return &m_LogoutTimeStamp;
}

void SESSION::Close(void)
{
    if (m_hCredUI)
    {
       ::FreeLibrary(m_hCredUI);
        m_hCredUI = NULL;
    }

    if (m_hKeyDAMap)
    {
        ::RegCloseKey(m_hKeyDAMap);
    }

    if (m_hKeyCU)
    {
        ::RegCloseKey(m_hKeyCU);
    }
    
    if (m_hKeyLM)
    {
        ::RegCloseKey(m_hKeyLM);
    }
}


//
// Implementation for WININET_SESSION
//

// -----------------------------------------------------------------------------
WININET_SESSION::WININET_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WININET_SESSION::~WININET_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags,
							   dwContext);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WININET_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WININET_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}


PVOID WININET_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    PP_ASSERT (m_pfnStatusCallback != NULL);

    return (*m_pfnStatusCallback)(hInternet,
                                  (INTERNET_STATUS_CALLBACK)lpfnCallback);

}

BOOL WININET_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}



BOOL WININET_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "InternetCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "InternetOpenW"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenW not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "InternetConnectW"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetConnectW not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpOpenRequestW"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpOpenRequestW not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpSendRequestW"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpSendRequestW not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "HttpQueryInfoW"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpQueryInfoW not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "InternetSetOptionW"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetOptionW not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "InternetOpenUrlW"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenUrlW not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "InternetQueryOptionW"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetQueryOptionW not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "InternetCrackUrlW"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCrackUrlW not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "InternetReadFile"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetReadFile not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "InternetSetStatusCallbackW"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "HttpAddRequestHeadersW"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpAddRequestHeaders not found");
        goto exit;
    }


    fRet = TRUE;

exit:
    return fRet;
}

BOOL WININET_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft.NET-Passport-Authentication-Service/1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0 /*INTERNET_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WININET_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WININET_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH,
                               0);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\ppdefs.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppdefs.h

Abstract:

    Basic Passport definitions.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PP_DEFS_H
#define PP_DEFS_H

#include <Windows.h>

#define HINTERNET PVOID
#define INTERNET_PORT WORD

#define PP_LOG_INFO	 /*Noise*/ 0x00000001
#define PP_LOG_WARNING	/*Unusual*/ 0x00000002
#define PP_LOG_ERROR	 /*Error*/ 0x00000004

#ifdef DBG
#define PP_ASSERT(fVal) if (!fVal) DebugBreak();
#else
#define PP_ASSERT(fVal)
#endif

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

 #define WPP_CONTROL_GUIDS \
     WPP_DEFINE_CONTROL_GUID(Regular,(81b20fea,73a8,4b62,95bc,354477c97a6f), \
         WPP_DEFINE_BIT(Error)      \
         WPP_DEFINE_BIT(Unusual)    \
         WPP_DEFINE_BIT(Noise)      \
    ) 
    
//
// func pointer decl for CredUI
//

//#include <credui.h>
#include <wincred.h>

typedef BOOL
(WINAPI * PFN_READ_DOMAIN_CRED_W) (
	IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
	IN DWORD Flags,
	OUT DWORD *Count,
	OUT PCREDENTIALW **Credential
	);

typedef VOID
(WINAPI * PFN_CRED_FREE)(
    IN PVOID Buffer
    );


#define DoTraceMessage

#endif // PP_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\passport\session.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    session.h

Abstract:

    This interface abstracts a Passport Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef SESSION_H
#define SESSION_H

class SESSION
{
public:
    static
    BOOL CreateObject(PCWSTR pwszHttpStack,  HINTERNET hSession, SESSION*& pSess);

public:
    SESSION(void);
    virtual ~SESSION(void);

    UINT GetSessionId(void) const { return m_SessionId; }
    BOOL Match(UINT SessionId) const { return SessionId == m_SessionId; }

    void AddRef(void) { ++m_RefCount; }
    
    void RemoveRef(void) 
    {
        if (m_RefCount > 0)
        {
            --m_RefCount;
        }
    }

    UINT RefCount(void) const { return m_RefCount; }

    // methods to retrieve the registry-configured value

    // PCWSTR GetLoginHost(void) const { return m_wDAHostName; }
    // PCWSTR GetLoginTarget(void) const { return m_wDATargetObj; }
    PCWSTR GetRegistrationUrl(void) const { return m_wRegistrationUrl; }
    
    BOOL GetDAInfoFromPPNexus(
        IN PWSTR            pwszRegUrl,    // user supplied buffer ...
        IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                        // on successful return)
        IN PWSTR            pwszDARealm,    // user supplied buffer ...
        IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        );

    BOOL GetDAInfo(PCWSTR pwszSignIn,
                   LPWSTR pwszDAHostName,
                   DWORD HostNameLen,
                   LPWSTR pwszDAHostObj,
                   DWORD HostObjLen);

    BOOL UpdateDAInfo(
        PCWSTR pwszSignIn,
        PCWSTR pwszDAUrl
        );

    void Logout(void);

    BOOL IsLoggedOut(void) const;

    const SYSTEMTIME* GetLogoutTimeStamp(void) const;

    void ResetLogoutFlag(void);
    
    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET) = 0;
    virtual void Close(void) = 0;

    // methods below abstracts a subset of WinInet/WinHttp functionalities.

    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT) = 0;

    virtual HINTERNET OpenRequest(
        HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL) = 0;

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet) = 0;

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength) = 0;    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength) = 0;

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags) = 0;

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead) = 0;

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents) = 0;

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        ) = 0;

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        ) = 0;


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR  pwszData,
                                PDWORD pdwDataLength
                                ) = 0;
#endif // PP_DEMO

protected:
    static UINT m_SessionIdSeed;

    HMODULE     m_hHttpStack;
    HMODULE     m_hCredUI;
    UINT        m_SessionId;
    BOOL        m_fOwnedSession;
    UINT        m_RefCount;

    // WCHAR       m_wDAHostName[256];
    // WCHAR       m_wDATargetObj[64];
    WCHAR       m_wRegistrationUrl[256];

    PFN_READ_DOMAIN_CRED_W
                m_pfnReadDomainCred;
    PFN_CRED_FREE m_pfnCredFree;

    HKEY m_hKeyLM;
    HKEY m_hKeyCU;
    HKEY m_hKeyDAMap;
    WCHAR m_wDefaultDAUrl[1024];

    DWORD m_LastNexusDownloadTime;

    BOOL        m_fLogout;
    SYSTEMTIME  m_LogoutTimeStamp;

    friend class LOGON;
};

#endif // SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\cache.hpp ===
#ifndef _CACHE_HPP_
#define _CACHE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Bucket.hpp"
#include "Find.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The allocation cache.                                          */
    /*                                                                  */
    /*   The memory allocation cache consists of two stacks.  The       */
    /*   first stack contains preallocated elements which are           */
    /*   available for use.  The second stack contains elements         */
    /*   which have been deallocated and are about to be recycled.      */
    /*                                                                  */
    /********************************************************************/

class CACHE : public BUCKET
    {
		//
		//   Private data.
		//
		//   A cache sits on top of a bucket and shields 
		//   it from being swamped by calls.  The 'Active'
		//   flag is set when the cache is active.  The
		//   'Stealing' flag indicates that deallocated
		//   memory can be stolen and reallocated.  The
		//   'ThreadSafe' flag indicates that locking is
		//   required.
		//
		BOOLEAN						  Active;
		BOOLEAN						  Stealing;
		BOOLEAN						  ThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   When we are collecting statistics we enable 
		//   the following variables.  The 'CacheFills' 
		//   count keeps track of the number of times
		//   the cache was filled from the bucket.  The
		//   'CacheFlushes' count keeps track of the 
		//   number of times the cache flushed deleted
		//   elements to the bucket.  The 'HighTide' count  
		//   keeps track the the highest number of outstanding
		//   allocations since the last "DeleteAll()'.  The 
		//   'HighWater' count keeps track of the maximum 
		//   number of allocations at any point.  The
		//   'InUse' counts the the current number of outstanding 
		//   allocations.
		//
		SBIT32						  CacheFills;
		SBIT32						  CacheFlushes;
		SBIT32						  HighTide;
		SBIT32						  HighWater;
		SBIT32						  InUse;
#endif

		//
		//   A cache can be controlled by the user.  The
		//   'CacheSize' controls the number of allocations
		//   that can be preallocated or queued for 
		//   deletion.  The 'NumberOfChildren' is a count
		//   of the number of caches that allocate space
		//   from this cache.
		//
		SBIT16						  CacheSize;
		SBIT16						  FillSize;
		SBIT16						  NumberOfChildren;

		//
		//   The cache consists of two stacks.  The
		//   'DeleteStack' contains elements that are 
		//   waiting to be deleted.  The 'NewStack' 
		//   contains elements waiting to be allocated.
		//
		ADDRESS_AND_PAGE			  *DeleteStack;
		VOID						  **NewStack;

		//
		//   The top of the deleted stack is kept in
		//   'TopOfDeleteStack' and the top of the new
		//   stack is kept in 'TopOfNewStack'.
		//
		SBIT32						  TopOfDeleteStack;
		SBIT32						  TopOfNewStack;

		//
		//   The 'Spinlock' is a fast lock employed to
		//   make the cache multi-threaded if 'ThreadSafe'
		//   is true.
		//   
		SPINLOCK					  Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The cacahe is a subset of the full haep interface
		//   a certain calls simply bypass it.  However, there
		//   are a few additional functions for cases where the
		//   cache needs to be notified of significant heap
		//   events.
		//
        CACHE
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewCacheSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize,
			BOOLEAN					  NewStealing,
			BOOLEAN					  NewThreadSafe
			);

		VOID *CreateDataPage( VOID );

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteAll( VOID );

		BOOLEAN DeleteDataPage( VOID *Address );

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( VOID );

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		BOOLEAN SearchCache( VOID *Address );

		BOOLEAN Truncate( VOID );

		VOID UpdateCache
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CACHE( VOID );

		//
		//   Public inline functions.
		//
		//   A cache just like its parent bucket is closely
		//   coupled to various other classes and provides
		//   then is vital information.
		//
		INLINE VOID ClaimCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE PAGE *FindChildPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetAllocationSize()-1))),
				(CACHE*) this
				); 
			}

		INLINE PAGE *FindParentPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetPageSize()-1))),
				ParentCache
				); 
			}

		INLINE SBIT16 GetCacheSize( VOID )
			{ return CacheSize; }

		INLINE SBIT32 GetNumberOfChildren( VOID )
			{ return NumberOfChildren; }

		INLINE VOID ReleaseCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE BOOLEAN Walk( SEARCH_PAGE *Details )
			{ return NewPage -> Walk( Details ); }
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Cache statistics.
		//
		//   A cache has a collection statistics which it
		//   uses to measure how it is doing.  It is possible
		//   to get access to this data for the purpose of
		//   outputing various reports.
		//
		INLINE SBIT32 GetCacheFills( VOID )
			{ return CacheFills; }

		INLINE SBIT32 GetCacheFlushes( VOID )
			{ return CacheFlushes; }

		INLINE SBIT32 GetHighWater( VOID )
			{ return HighWater; }
#endif

	private:
		//
		//   Private functions.
		//
		//   A cache is initially inactive.  If at least one
		//   allocation request is made it will spring into
		//   life, allocate any space needed and prepare itself
		//   for use.
		//
		VOID CreateCacheStacks( VOID );
#ifdef ENABLE_HEAP_STATISTICS

		VOID ComputeHighWater( SBIT32 Size );
#endif

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        CACHE( CONST CACHE & Copy );

        VOID operator=( CONST CACHE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\bucket.hpp ===
#ifndef _BUCKET_HPP_
#define _BUCKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Connections.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A collection of pages.                                         */
    /*                                                                  */
    /*   A bucket is a collection of pages capable of allocating        */
    /*   fixed sized memory elements.  The pages are allocated from     */
    /*   from larger buckets and are stored in a linked list in         */
    /*   order of ascending of page addresses.                          */
    /*                                                                  */
    /********************************************************************/

class BUCKET : public CONNECTIONS
    {
		//
		//   Private type definitions.
		//
		//   All allocations are registered in bit vectors.
		//   Here we have some prototypes for seriously  
		//   optimized functions to do address to bit 
		//   vector computations.
		//
		typedef VOID *(BUCKET::*COMPUTE_ADDRESS)
			( 
			CHAR					  *Address,
			SBIT32					  Offset 
			);

		typedef SBIT32 (BUCKET::*COMPUTE_OFFSET)
			( 
			SBIT32					  Displacement,
			BOOLEAN					  *Found 
			);

		//
		//   Private data.
		//
		//   A bucket owns all the memory of a given size
		//   and manages it.  Above it is a cache to 
		//   protect it from huge number of calls and
		//   below it are the connections to various 
		//   other classes.  The 'AllocationSize' is the
		//   buckets allocation size.  The 'ChunkSize' is
		//   chunking size which is typically half way
		//   between the 'AllocationSize' and the 'PageSize'.
		//   The 'PageSize' is the size of the bucket
		//   where this bucket gets its space.
		//   
		//
		SBIT32                        AllocationSize;
		SBIT32						  ChunkSize;
		SBIT32						  PageSize;

		//
		//   It is the job of the bucket to keep track of
		//   all the information relating to allocations
		//   of a given 'AllocationSize'.  The 'ActivePages'
		//   keeps track of the number of available pages
		//   in the 'BucketList'.  The 'BucketList' is a
		//   linked list of pages that have available space.
		//   The 'CurrentPage' contains the highest address
		//   of the first page in the 'BucketList'.
		//
		SBIT32						  ActivePages;
		LIST						  BucketList;
		VOID						  *CurrentPage;

		//
		//   A bucket needs to be able to quickly convert
		//   bit vector offsets to addresses (and vice versa).
		//   The 'AllocationShift' is set when the 
		//   'AllocationSize' is a power of two to avoid 
		//   any divides.  The 'ChunkShift' is set when the
		//   'ChunckSize' is a power of two to avoid some
		//   divides.  The 'ComputeAddressFunction' and
		//   'ComputeOffsetFunction' point to optimized
		//   functions to do conversions that are selected
		//   by the constructor.
		//
		SBIT32						  AllocationShift;
		SBIT32						  ChunkShift;
		COMPUTE_ADDRESS				  ComputeAddressFunction;
		COMPUTE_OFFSET				  ComputeOffsetFunction;

		//
		//   A bucket typically contains a collection of
		//   pages.  As all pages are the same data that
		//   should really be stored in page descriptions
		//   is instead stored in the bucket to save space.
		//   The 'NumberOfElements' contains the number of
		//   elements in each pages bit vector.  The 
		//   'SizeOfChunks' contains the pre-computed chunk
		//   size.  The 'SizeOfElements' contains the number
		//   of words in the pages bit vector.  The 'SizeKey'
		//   contains an index which selects the size of the
		//   bit vector when a new page is created.
		//
		SBIT16						  NumberOfElements;
		SBIT16						  SizeOfChunks;
		SBIT16						  SizeOfElements;
		SBIT16						  SizeKey;

   public:
		//
		//   Public functions.
		//
		//   The functionality provided by this class pretty
		//   much matches the external API.  Nonetheless, these
		//   APIs are protected from excessive calls by a fast
		//   cache that is derived from this class.
		//
        BUCKET
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize 
			);

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteFromBucketList( PAGE *Page );

		VOID InsertInBucketList( PAGE *Page );

		BOOLEAN MultipleDelete
			( 
			ADDRESS_AND_PAGE		  *Array,
			SBIT32					  *Deleted,
			SBIT32					  Size 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		VOID UpdateBucket
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~BUCKET( VOID );

		//
		//   Public inline functions.
		//
		//   It saves a significant amount of space by putting
		//   common information in the bucket instead of a 
		//   separate copy in each page description.  Nonetheless,
		//   it means that both classes are very much dependent
		//   upon each other.
		//
		INLINE VOID *ComputeAddress( CHAR *Address,SBIT32 Offset )
			{ return (this ->* ComputeAddressFunction)( Address,Offset ); }

		INLINE SBIT32 ComputeOffset( SBIT32 Displacement,BOOLEAN *Found )
			{ return (this ->* ComputeOffsetFunction)( Displacement,Found ); }

		INLINE SBIT32 GetAllocationSize( VOID )
			{ return AllocationSize; }

		INLINE SBIT32 GetChunkSize( VOID )
			{ return ChunkSize; }

		VOID *GetCurrentPage( VOID )
			{ return CurrentPage; }

		INLINE SBIT16 GetNumberOfElements( VOID )
			{ return NumberOfElements; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE SBIT16 GetSizeOfChunks( VOID )
			{ return SizeOfChunks; }

		INLINE SBIT16 GetSizeOfElements( VOID )
			{ return SizeOfElements; }

		INLINE SBIT16 GetSizeKey( VOID )
			{ return SizeKey; }

	private:
		//
		//   Private functions.
		//
		//   When we need to convert an address to a bit 
		//   offset (or vice versa) we use one of the following 
		//   functions.
		//
		VOID *ComputeAddressBestCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressGoodCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressPoorCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWorstCase( CHAR *Address,SBIT32 Offset );

		SBIT32 ComputeOffsetBestCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetGoodCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetPoorCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWorstCase( SBIT32 Displacement,BOOLEAN *Found );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BUCKET( CONST BUCKET & Copy );

        VOID operator=( CONST BUCKET & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\connections.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Connections.hpp"
#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   There are a variety of connections that need to be made        */
    /*   after all the classes are ready for use.  However, we          */
    /*   initially zero all these connection pointers until we are      */
    /*   ready to link everything.                                      */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the connections.                                        */
    /*                                                                  */
    /*   When we create an allocator there is some information that     */
    /*   is not available.  Here we update the connection information   */
    /*   so we can locate the correct instances of various other        */
    /*   classes.                                                       */
    /*                                                                  */
    /********************************************************************/

VOID CONNECTIONS::UpdateConnections
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   We typically only need to update the connections once
	//   but in some situations multiple updates can occur.  If
	//   this is the case we carefully check the update is 
	//   consistent with the previous update.
	//
	if ( ! Active )
		{
		//
		//   We now have the information we need to update the 
		//   connections.
		//
		Active = True;
		Find = NewFind;
		Heap = NewHeap;
		NewPage = NewPages;
		ParentCache = NewParentCache;
		}
	else
		{
		//
		//   Nasty, we have already updated the connections once.  
		//   Since we have been called again we know this node 
		//   must be shared between two heaps.  We can deal with  
		//   this as long as selected pointers are the same.
		//
		if 
				(
				(Find != NewFind)
					||
				(NewPage != NewPages)
					||
				(ParentCache != NewParentCache)
				)
			{ Failure( "Sharing violation in UpdateConnections" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the connections.                                       */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::~CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\bucket.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Bucket.hpp"
#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here relate the compuation of the       */
    /*   current active page address range.                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HighestAddress			  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation bucket and prepare it for use.         */
    /*   We need to be sure to carefully check everything we have       */
    /*   been supplied as it has come indirectly from the user.         */
    /*                                                                  */
    /********************************************************************/

BUCKET::BUCKET
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize 
		)
    {
	//
	//   We want to make sure that the bucket configuration
	//   appears to make basic sense.  If not we have no 
	//   alternative than to throw an expection.
	//
	if
			(
			(NewAllocationSize > 0)
				&&
			(NewChunkSize >= NewAllocationSize)
				&&
			(NewChunkSize <= NewPageSize)
				&&
			PowerOfTwo( NewPageSize )
			)
		{
		//
		//   Create the bucket and prepare it for use.
		//   Pre-compute any information we can here to
		//   save work later.
		//
		AllocationSize = NewAllocationSize;
		ChunkSize = NewChunkSize;
		PageSize = NewPageSize;

		ActivePages = 0;
		AllocationShift = 0;
		ChunkShift = 0;

		//
		//   Compute the optimization level from the available
		//   bucket information.  The highest level means
		//   everything is a power of two (just shifts - yipee !!).
		//   The next means no chunks (i.e. simple scaling), The
		//   next means simple chunks (i.e. complex scaling).
		//   The final alternative is to horrid to discuss. 
		//   
		if ( ConvertDivideToShift( AllocationSize,& AllocationShift ) )
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{
				//
				//   The best case is when we can use shifts
				//   instead of multiply and divide.
				//
				ComputeAddressFunction = ComputeAddressBestCase;
				ComputeOffsetFunction = ComputeOffsetBestCase;
				}
			else
				{
				//
				//   When we have chunks we have to do more 
				//   work invloving additional multiples and
				//   divides.  Nonetheless, we try to minimize
				//   these as far as possible.
				// 
				if ( ConvertDivideToShift( ChunkSize,& ChunkShift ) )
					{
					//
					//   We have managed to replace some of the
					//   multiplies and divides with shifts.
					//
					ComputeAddressFunction = ComputeAddressPoorCase;
					ComputeOffsetFunction = ComputeOffsetPoorCase;
					}
				else
					{
					//
					//   We are unable to optimize this case.
					//   These calls will really hurt.
					//
					ComputeAddressFunction = ComputeAddressWorstCase;
					ComputeOffsetFunction = ComputeOffsetWorstCase;
					}
				}
			}
		else
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{ 
				//
				//   A good case is when we can use a few
				//   simple multiplies and divides to do simple
				//   scaling.
				//
				ComputeAddressFunction = ComputeAddressGoodCase;
				ComputeOffsetFunction = ComputeOffsetGoodCase;
				}
			else
				{ 
				//
				//   When we have chunks we have to do more 
				//   work invloving additional multiples and
				//   divides.  Nonetheless, we try to minimize
				//   these as far as possible.
				// 
				if ( ConvertDivideToShift( ChunkSize,& ChunkShift ) )
					{
					//
					//   We have managed to replace some of the
					//   multiplies and divides with shifts.
					//
					ComputeAddressFunction = ComputeAddressPoorCase;
					ComputeOffsetFunction = ComputeOffsetPoorCase;
					}
				else
					{
					//
					//   We are unable to optimize this case.
					//   These calls will really hurt.
					//
					ComputeAddressFunction = ComputeAddressWorstCase;
					ComputeOffsetFunction = ComputeOffsetWorstCase;
					}
				}
			}

		//
		//   Compute all the information that will be
		//   needed later to describe the allocation
		//   pages.
		//
		NumberOfElements = 
			((SBIT16) ((PageSize / ChunkSize) * (ChunkSize / AllocationSize)));
		SizeOfChunks = (SBIT16)
			((SBIT16) (ChunkSize / AllocationSize));
		SizeOfElements = (SBIT16)
			((SBIT16) (((NumberOfElements-1) / OverheadBitsPerWord) + 1));
		SizeKey = NoSizeKey;
		}
	else
		{ Failure( "Configuration in constructor for BUCKET" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressBestCase( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset << AllocationShift))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressGoodCase( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset * AllocationSize))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressPoorCase( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber << ChunkShift)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWorstCase( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber * ChunkSize)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetBestCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset = (Displacement >> AllocationShift);

	(*Found) = (Displacement == (ArrayOffset << AllocationShift));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetBestCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetGoodCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset = (Displacement / AllocationSize);

	(*Found) = (Displacement == (ArrayOffset * AllocationSize));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetGoodCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetPoorCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement >> ChunkShift);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber << ChunkShift);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetPoorCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWorstCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement / ChunkSize);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber * ChunkSize);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWorstCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a single memory allocation from a bucket.    */
    /*   We do this by passing the request on to the page.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	AUTO SEARCH_PAGE Details;

	//
	//   When we delete an allocation we need to ensure 
	//   the page has not radically changed since we found
	//   it.  Hence, we compare the current page version  
	//   number with the one we found earlier.  If all is 
	//   well we get the details relating to the allocation
	//   and then delete it.
	//
	return
		(
		((Page -> GetVersion()) == Version)
			&&
		(Page -> FindPage( Address,& Details,False ) != NULL)
			&&
		(Page -> Delete( & Details ))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page from the bucket list.                            */
    /*                                                                  */
    /*   When a page becomes full it is removed from the bucket list    */
    /*   so it will be no longer inspected when looking for free space. */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::DeleteFromBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	if ( (-- ActivePages) >= 0 )
		{
		//
		//   Delete the page from the bucket list as it is 
		//   no longer needed.  There are two cases when this 
		//   happens.  When the page is full and when the page 
		//   is about to be deleted.
		//
		Page -> DeleteFromBucketList( & BucketList );

		//
		//   Compute the highest address on the first page.  We 
		//   use this information to figure out whether to 
		//   recycle an allocation or pass it along for deletion
		//   in the cache.
		//
		Page = (PAGE::FirstInBucketList( & BucketList ));
		
		if ( ! Page -> EndOfBucketList() )
			{
			CurrentPage =
				(
				((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
				);
			}
		else
			{ CurrentPage = ((VOID*) HighestAddress); }
		}
	else
		{ Failure( "Active page count in DeleteFromBucketList" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a page into the bucket list.                            */
    /*                                                                  */
    /*   When a page is created or when it changes from being full      */
    /*   to having at least one free slot it is added to the bucket     */
    /*   list so that it can be used to allocate space.                 */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::InsertInBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	ActivePages ++;

	//
	//   We insert pages into the list in ascending address
	//   order.  This ensures that we always allocate the 
	//   lowest addresses first.  This is done to try to keep 
	//   the working set small and compact.
	//
	if ( ! BucketList.EndOfList() )
		{
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER PAGE *Last = (Page -> LastInBucketList( & BucketList ));

		//
		//   We are about to walk the entire page list
		//   trying to find where to insert this page.
		//   Lets see if the page needs to be inserted
		//   at the end of the list.  If so have saved
		//   ourseleves a lot of work and we can exit 
		//   early.
		//   
		if ( Address < (Last -> GetAddress()) )
			{
			REGISTER PAGE *Current;

			//
			//   Well it looks like we need to walk along 
			//   the entire page list to find the correct 
			//   place to insert this element.
			//
			for 
					( 
					Current = (Page -> FirstInBucketList( & BucketList ));
					! Current -> EndOfBucketList();
					Current = Current -> NextInBucketList() 
					)
				{
				//
				//   While the current address is lower 
				//   than ours we need to keep on walking.
				//
				if ( Address < (Current -> GetAddress()) )
					{
					//
					//   We have found the spot so insert 
					//   the bucket just before the current 
					//   bucket.
					//
					Current -> InsertBeforeInBucketList( & BucketList,Page );

					break;
					}
				}
			}
		else
			{
			//
			//   The page has the highest address so insert
			//   it at the end of the list.
			//
			Last -> InsertAfterInBucketList( & BucketList,Page );
			}
		}
	else
		{ Page -> InsertInBucketList( & BucketList ); }

	//
	//   Compute the highest address on the first page.  We can
	//   use this information to figure out whether to recycle an
	//   allocation or pass it along for deletion in the cache.
	//
	Page = (PAGE::FirstInBucketList( & BucketList ));
	
	CurrentPage =
		(
		((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When the delete cache becomes full we complete any pending     */
    /*   delete requests.  We also flush the delete cache when if       */
    /*   we need to allocate additional memory unless recycling is      */
    /*   enabled in which case we just steal it directly from the       */
    /*   delete cache.                                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleDelete
		( 
		ADDRESS_AND_PAGE			  *Array,
		SBIT32						  *Deleted,
		SBIT32						  Size 
		)
	{
	AUTO SEARCH_PAGE Details;
	REGISTER SBIT32 Count;

	//
	//   Zero the count of deleted items.
	//
	(*Deleted) = 0;

	//
	//   Delete each element one at a time.  We would love to
	//   delete them all at once but we haven't got a clue where
	//   they have come from so we have to do it one at a time. 
	//   
	for ( Count=0;Count < Size;Count ++ )
		{
		REGISTER ADDRESS_AND_PAGE *Current = & Array[ Count ];
		REGISTER PAGE *Page = Current -> Page;

		//
		//   It may see like a waste of time to batch up all
		//   the deletions.  Why not do them as they arrive.
		//   There are a number of reasons.  The deletes can
		//   be recycled, batchs of deletes is faster than
		//   single deletes (due to cache effects) and so on.
		//
		if
				(
				(Current -> Version == Page -> GetVersion())
					&&
				(Page -> FindPage( Current -> Address,& Details,False ) != NULL)
					&&
				(Page -> Delete( & Details ))
				)
			{ (*Deleted) ++; }
		}

	return ((*Deleted) == Size);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We need to make a multiple memory allocation from this			*/
    /*   bucket so walk the bucket list allocating any available        */
    /*   space and return it to the caller.                             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested 
		)
    {
	//
	//   Zero the count of allocated elements.
	//
	(*Actual) = 0;

	//
	//   We walk the sorted list of pages with available
	//   allocations searching for elements to allocate.
	//
	do
		{
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = NextPage
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   Lets find the next page now as the current 
			//   bucket may be removed from the bucket list
			//   by the following allocation call.
			//
			NextPage = Page -> NextInBucketList();

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the standard size then skip it.
			//
			if ( (ActualSize == NoSize) || (ActualSize == PageSize) )
				{
				//
				//   We try allocate all the space we need 
				//   from each page in the bucket list.  If 
				//   the page has enough space we can exit 
				//   early if not we go round the loop and
				//   try the next page.
				//
				if ( Page -> MultipleNew( Actual,Array,Requested ) )
					{ return True; }
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( (CACHE*) this )
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We see if we managed to allocate all the elements
	//   we wanted.  If so we are happy and we can get out 
	//   of here.
	//
	if ( (*Actual) < Requested )
		{
		//
		//   We see if we managed to allocate any elements 
		//   at all.  If not we fail the request.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 Delta = ((Requested) - (*Actual));

			//
			//   We are very naughty when we allocate multiple
			//   elements in that we put them in the array in
			//   reverse order.  The logic is that this is just
			//   what we want when we allocate out of the cache.
			//   However, if we are unable to allocate all the
			//   elements we needed then we have to move the 
			//   pointers down to the base of the array.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ Array[ Count ] = Array[ (Count + Delta) ]; }
			}
		else
			{ return False; }
		}

	return True;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We need to make a new memory allocation from this bucket       */
    /*   so search the page list of available space and return a        */
    /*   free element.                                                  */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::New( BOOLEAN SubDivided,SBIT32 NewSize )
    {
	do
		{
		REGISTER PAGE *Page;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = Page -> NextInBucketList()
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the correct size then skip it.
			//
			if 
					( 
					(ActualSize == NoSize) 
						|| 
					(ActualSize == ((NewSize == NoSize) ? PageSize : NewSize))
					)
				{
				//
				//   We know that any page that appears in 
				//   the bucket list will have at least one 
				//   free element available.  So if we find
				//   that the bucket list a suitable page 
				//   then we know that we can allocate something.
				//
				return (Page -> New( SubDivided ));
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( ((CACHE*) this),NewSize ) 
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We were unable to find anything we could allocate
	//   so fail the request.
	//
	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::ReleaseSpace( SBIT32 MaxActivePages )
    {
	REGISTER SBIT32 Current = ActivePages;

	//
	//   We only bother to try to trim the number of
	//   active pages if we are over the limit.
	//
	if ( Current > MaxActivePages )
		{
		REGISTER PAGE *NextPage;
		REGISTER PAGE *Page;

		//
		//   Walk the backwards along the bucket list 
		//   and delete the highest addressed free pages
		//   if we are over the limit.
		//
		for 
				( 
				Page = (PAGE::LastInBucketList( & BucketList ));
				(Current > MaxActivePages) 
					&& 
				(! Page -> EndOfBucketList());
				Page = NextPage
				)
			{
			//
			//   We are walking backwards down the bucket
			//   list looking for empty pages to delete.
			//   However, if we find a page we can remove
			//   it will be automatically removed from the
			//   list so we need to get the next pointer
			//   before this happens.
			//
			NextPage = Page -> PreviousInBucketList();

			//
			//   We can only release a page if it is empty
			//   if not we must skip it.
			//
			if ( Page -> Empty() )
				{
				Current --;

				DeletePage( Page ); 
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data we need.                                   */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::UpdateBucket
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	REGISTER SBIT16 NewSizeKey = (NewPages -> FindSizeKey( NumberOfElements ));

	//
	//   We compute and verify the size key to make sure
	//   it is suitable for all the pages that we will
	//   create after the heap constructor is completed.
	//
	if ( NewSizeKey != NoSizeKey )
		{
		//
		//   Update the size key and the connections.
		//
		SizeKey = NewSizeKey;

		UpdateConnections
			( 
			NewFind,
			NewHeap,
			NewPages,
			NewParentCache 
			);
		}
	else
		{ Failure( "Bucket can't get a size key in UpdateBucket" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the allocation bucket.                                 */
    /*                                                                  */
    /********************************************************************/

BUCKET::~BUCKET( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\connections.hpp ===
#ifndef _CONNECTIONS_HPP_
#define _CONNECTIONS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   At the top level the parent of all caches is a constant        */
    /*   called 'GlobalRoot'.                                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 GlobalRoot				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;
class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   We communicate between a page and the associated cache         */
    /*   using an address pointer, page pointer and version triple.     */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	PAGE							  *Page;
	SBIT32							  Version;
	}
ADDRESS_AND_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Connections to other classes.                                  */
    /*                                                                  */
    /*   The connections between the various classes in the memory      */
    /*   allocator is a twisted mess.  The root cause is that at a      */
    /*   fundamental level.  Every part depends on every other part.    */
    /*   Nonetheless, a significant effort has been made to seperate    */
    /*   the parts as best as possible.  The various classes are        */
    /*   linked here so every part can find the correct instance of     */
    /*   every other part.                                              */
    /*                                                                  */
    /********************************************************************/

class CONNECTIONS : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		BOOLEAN						  Active;

   public:
		//
		//   Public data.
		//
		//   All the classes that inherit this class get
		//   pointers to related classes they need to call
		//   from time to time. 
		//
		FIND                          *Find;
		HEAP                          *Heap;
		NEW_PAGE					  *NewPage;
		CACHE						  *ParentCache;

		//
		//   The 'Prefetch' is a class that will trigger
		//   a cache fetch if the CPU supports it.
		//   
		PREFETCH					  Prefetch;

        //
        //   Public functions.
		//
		//   The sole job of this class is to provide 
		//   pointers to related classes.  These pointers
		//   are unknown until after the heap has been
		//   created and this need to be dynamically
		//   linked during the execution of the top 
		//   level heap constructor.
        //
        CONNECTIONS( VOID );

		VOID UpdateConnections
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CONNECTIONS( VOID );

		//
		//   Public inline functions.
		//
		//   The complex linkages in the heap sometimes 
		//   lead to the case where a class has a pointer
		//   to it's cache but not to the class it needs
		//   to call.  Thus, to avoid replicating large
		//   numbers of pointers we export call interfaces
		//   from here to allow the required calls to be
		//   made indirectly.
		//
		INLINE VOID DeleteFromFindList( PAGE *Page )
			{ Find -> DeleteFromFindList( Page ); }

		INLINE VOID DeletePage( PAGE *Page )
			{ NewPage -> DeletePage( Page ); }

		INLINE HEAP *GetHeap( VOID )
			{ return Heap; }

		INLINE CACHE *GetParentCache( VOID )
			{ return ParentCache; }

		INLINE VOID InsertInFindList( PAGE *Page )
			{ Find -> InsertInFindList( Page ); }

		INLINE BOOLEAN TopCache( VOID )
			{ return (ParentCache == ((CACHE*) GlobalRoot)); }

	private:
        //
        //   Disabled operations.
        //
        CONNECTIONS( CONST CONNECTIONS & Copy );

        VOID operator=( CONST CONNECTIONS & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\bucketlist.hpp ===
#ifndef _BUCKET_LIST_HPP_
#define _BUCKET_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The bucket list.                                               */
    /*                                                                  */
    /*   All allocation buckets have a linked list of pages with        */
    /*   available space in ascending order of address.                 */
    /*                                                                  */
    /********************************************************************/

class BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  BucketList;

   public:
        //
        //   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
        //
        BUCKET_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromBucketList( LIST *HeadOfList )
			{ BucketList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfBucketList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> First()); }

		INLINE VOID InsertInBucketList( LIST *HeadOfList )
			{ BucketList.Insert( HeadOfList ); }

		INLINE VOID InsertAfterInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertAfter( HeadOfList,(LIST*) Page ); }

		INLINE VOID InsertBeforeInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertBefore( HeadOfList,(LIST*) Page ); }

		STATIC INLINE PAGE *LastInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> Last()); }

		INLINE PAGE *NextInBucketList( VOID )
			{ return ((PAGE*) BucketList.Next()); }

		INLINE PAGE *PreviousInBucketList( VOID )
			{ return ((PAGE*) BucketList.Previous()); }

        ~BUCKET_LIST( VOID )
			{ /* void */ };

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        BUCKET_LIST( CONST BUCKET_LIST & Copy );

        VOID operator=( CONST BUCKET_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\cache.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the maximum size of        */
    /*   the cache.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxCacheSize			  = ((2 << 16)-1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation cache and prepare it for use.  A       */
    /*   is inactive until the first request is received at which       */
    /*   time it springs into life.                                     */
    /*                                                                  */
    /********************************************************************/

CACHE::CACHE
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewCacheSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize,
		BOOLEAN						  NewStealing,
		BOOLEAN						  NewThreadSafe
		) :
		//
		//   Call the constructors for the contained classes.
		//
		BUCKET( NewAllocationSize,NewChunkSize,NewPageSize )
    {
	//
	//   We need to be very careful with the configuration
	//   information as it has come indirectly from the
	//   user and my be bogus.
	//
	if ( (NewCacheSize >= 0) && (NewCacheSize < MaxCacheSize) )
		{
		//
		//   Setup the cache and mark it as inactive.
		//
		Active = False;
		Stealing = NewStealing;
		ThreadSafe = NewThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		CacheFills = 0;
		CacheFlushes = 0;
		HighTide = 0;
		HighWater = 0;
		InUse = 0;
#endif

		CacheSize = ((SBIT16) NewCacheSize);
		FillSize = 1;
		NumberOfChildren = 0;

		//
		//   The stacks that may later contain allocations
		//   are set to zero just to be neat.
		//
		DeleteStack = NULL;
		NewStack = NULL;

		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	else
		{ Failure( "Cache size in constructor for CACHE" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create the cache stacks.                                       */
    /*                                                                  */
    /*   A cache is created on demand.  We do this when we get the      */
    /*   first allocation or deallocation request.                      */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::CreateCacheStacks( VOID )
	{
	//
	//   We allocate the cache stacks from the internal
	//   new page allocator if we have not done it already.
	//
	if ( DeleteStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(ADDRESS_AND_PAGE));

		DeleteStack = 
			((ADDRESS_AND_PAGE*) (NewPage -> NewCacheStack( Size )));
		}

	if ( NewStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(VOID*));

		NewStack = 
			((VOID**) (NewPage -> NewCacheStack( Size )));
		}

	//
	//   We can now activate the cache as long as we 
	//   were able to allocate both stacks.
	//
	if ( (NewStack != NULL ) && (DeleteStack != NULL ) )
		{
		//
		//   We have completed creating the cache so set
		//   various flags and zero various counters.
		//
		Active = True;

		//
		//   Setup the fill size.
		//
		FillSize = 1;

		//
		//   Zero the stack tops.
		//
		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new data page.                                        */
    /*                                                                  */
    /*   When we create a new page we also need to allocate some        */
    /*   memory to hold the associated data.                            */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::CreateDataPage( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Create a data page.
	//
	NewMemory = ((BUCKET*) this) -> New( True );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Compute high water.                                            */
    /*                                                                  */
    /*   Compute the high water mark for the current cache.             */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ComputeHighWater( SBIT32 Size )
	{
	//
	//   Update the usage statistics.
	//
	if ( (InUse += Size) > HighTide )
		{ 
		HighTide = InUse;
		
		if ( HighTide > HighWater )
			{ HighWater = HighTide; }
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   A memory deallocation cache.                                   */
    /*                                                                  */
    /*   We cache memory deallocation requests to improve performance.  */
    /*   We do this by stacking requests until we have a batch.         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   If recycling is allowed and the address is
		//   on the current page or a previous page and
		//   there is space on the new stack then put the
		//   element in the new stack for immediate reuse.
		//
		if 
				(
				(Stealing)
					&&
				(Address < GetCurrentPage())
					&&
				(TopOfNewStack < CacheSize)
				)
			{
			//
			//   The address is suitable for immediate
			//   reuse.  So put it on the stack of new
			//   elements.
			//
			NewStack[ (TopOfNewStack ++) ] = Address;

			Result = True;
			}
		else
			{
			REGISTER ADDRESS_AND_PAGE *Current = 
				(& DeleteStack[ TopOfDeleteStack ++ ]);

			//
			//   The address would best be deleted before
			//   being reused.
			//
			Current -> Address = Address;
			Current -> Page = Page;
			Current -> Version = Version;

			//
			//   When the delete stack is full we flush it.
			//
			if ( TopOfDeleteStack >= CacheSize )
				{
				AUTO SBIT32 Deleted;

				//
				//   Flush the delete stack.
				//
				Result = 
					(
					((BUCKET*) this) -> MultipleDelete
						(
						DeleteStack,
						& Deleted,
						TopOfDeleteStack 
						)
					);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				CacheFlushes ++;
				
				InUse += (TopOfDeleteStack - Deleted);
#endif

				//
				//   Zero the top of the stack.
				//
				TopOfDeleteStack = 0;
				}
			else
				{ Result = True; }
			}
		}
	else
		{
		//
		//   Delete the element.
		//
		Result = 
			(((BUCKET*) this) -> Delete( Address,Page,Version )); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	if ( Result )
		{ InUse --; }
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   The entire heap is about to be deleted under our feet.  We     */
    /*   need to prepare for this by disabling the cache as its         */
    /*   contents will disappear as well.                               */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::DeleteAll( VOID )
	{
	//
	//   Disable the cache if needed.
	//
	Active = False;
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Zero the statistics.
	//
	HighTide = 0;
	InUse = 0;
#endif

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Zero the top of stacks.
	//
	TopOfDeleteStack = 0;
	TopOfNewStack = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a data page.                                            */
    /*                                                                  */
    /*   Delete a data page that was associated with a smaller cache    */
    /*   so its space can be reused.                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::DeleteDataPage( VOID *Address )
	{
	AUTO SEARCH_PAGE Details;
	REGISTER BOOLEAN Result;
	REGISTER PAGE *Page;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Find the description of the data page we need to 
	//   delete and make sure it is valid.
	//
	Find -> ClaimFindShareLock();

	Page = FindParentPage( Address );

	if ( Page != NULL )
		{ Page = (Page -> FindPage( Address,& Details,False )); }

	Find -> ReleaseFindShareLock();

	//
	//   Delete the data page.
	//
	if ( Page != NULL )
		{ Result = (Page -> Delete( & Details )); }
	else
		{ Failure( "No data page in DeleteDataPage" ); }

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We have been asked to allocalte multiple
		//   new elements.  If it appears that we don't  
		//   have enough elements available but stealing 
		//   is allowed we can try raiding the deleted 
		//   stack.
		//
		if ( (Requested > TopOfNewStack) && (Stealing) )
			{
			while ( (TopOfDeleteStack > 0) && (TopOfNewStack < CacheSize) )
				{
				NewStack[ (TopOfNewStack ++) ] = 
					(DeleteStack[ (-- TopOfDeleteStack) ].Address);
				}
			}

		//
		//   We will allocate from the cache if requested 
		//   size is smaller than the number of available 
		//   elements.
		//
		if ( Requested <= TopOfNewStack )
			{
			REGISTER SBIT32 Count;

			//
			//   We need to copy the elements out of the
			//   cache into the callers array.
			//
			for ( Count=0;Count < Requested;Count ++ )
				{ Array[ Count ] = NewStack[ (-- TopOfNewStack) ]; }

			(*Actual) = Requested;

			Result = True;
			}
		else
			{
			REGISTER BUCKET *Bucket = ((BUCKET*) this);

			//
			//   We don't have enough elements in the cache 
			//   so we allocate directly from the bucket.
			//
			Result =
				(
				Bucket -> MultipleNew
					( 
					Actual,
					Array,
					Requested
					)
				);

			//
			//   We fill up the cache so we have a good 
			//   chance of dealing with any following 
			//   requests if it is less than half full.
			//
			if ( TopOfNewStack <= (CacheSize / 2) )
				{
				AUTO SBIT32 NewSize;
				REGISTER SBIT32 MaxSize = (CacheSize - TopOfNewStack);

				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   Bulk load the cache with new
				//   elements.
				//
				Bucket -> MultipleNew
					( 
					& NewSize, 
					& NewStack[ TopOfNewStack ],
					((FillSize < MaxSize) ? FillSize : MaxSize)
					);
#ifdef ENABLE_HEAP_STATISTICS

				CacheFills ++;
#endif
				TopOfNewStack += NewSize;
				}
			}
		}
	else
		{
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		Result = ((BUCKET*) this) -> MultipleNew
			( 
			Actual,
			Array,
			Requested
			);
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (*Actual) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We first try the stack for new allocations
		//   to see if there are any available elements.
		//
		if ( TopOfNewStack > 0 )
			{ NewMemory = (NewStack[ (-- TopOfNewStack) ]); }
		else
			{
			//
			//   When stealing is allowed we will recycle
			//   elements from the top of the deleted stack.
			//
			if ( (TopOfDeleteStack > 0) && (Stealing) )
				{ NewMemory = (DeleteStack[ (-- TopOfDeleteStack) ].Address); }
			else
				{
				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   We need to bulk load some new  
				//   memory from the heap.
				//
				if 
						( 
						((BUCKET*) this) -> MultipleNew
							( 
							& TopOfNewStack,
							NewStack,
							FillSize
							) 
						)
					{
					//
					//   Update the statistics and return
					//   the top element on the stack.
					//
#ifdef ENABLE_HEAP_STATISTICS
					CacheFills ++;
#endif
					NewMemory = NewStack[ (-- TopOfNewStack) ]; 
					}
				else
					{
					//
					//   Update the statistics and fail
					//   the request for memeory.
					//
					NewMemory = ((VOID*) AllocationFailure);
					}
				}
			}
		}
	else
		{ 
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		NewMemory = ((BUCKET*) this) -> New( False ); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	//
	//   Prefetch the first cache line if we are running
	//   a Pentium III or better.
	//
	Prefetch.L1( ((CHAR*) NewMemory),1 );

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation for non-standard sizes.                      */
    /*                                                                  */
    /*   A non standard sized allocation simply by-passes the cache     */
    /*   but it still needs to hold the lock to prevent failure on      */
    /*   SMP systems.                                                   */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( BOOLEAN SubDivided,SBIT32 NewSize )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Allocate a non-standard sized block.
	//
	NewMemory = ((BUCKET*) this) -> New( SubDivided,NewSize );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ReleaseSpace( SBIT32 MaxActivePages )
	{
	//
	//   When there is a potential for multiple threads 
	//   we claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Release the free space from the backet.
	//
	((BUCKET*) this) -> ReleaseSpace( MaxActivePages );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search the cacahe for an allocation.                           */
    /*                                                                  */
    /*   We sometimes need to search the cache to see if an             */
    /*   allocation is currently in the cacahe awaiting allocation      */
    /*   or release.                                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::SearchCache( VOID *Address )
	{
	REGISTER BOOLEAN Result = False;

	//
	//   We check to see if the cache is active.
	//
	if ( Active )
		{
		//
		//   When there is a potential for multiple 
		//   threads we claim the cache lock.
		//
		ClaimCacheLock();

		//
		//   We check to see if the cache is still 
		//   active.
		//
		if ( Active )
			{
			REGISTER SBIT32 Count;

			//
			//   Search the allocated cache.
			//
			for ( Count=(TopOfNewStack-1);Count >= 0;Count -- )
				{ 
				if ( Address == NewStack[ Count ] )
					{
					Result = True;
					break;
					}
				}

			//
			//   If it has not been found yet then try
			//   the deleted cache.
			//
			if ( ! Result )
				{
				//
				//   Search the deleted cache.
				//
				for ( Count=(TopOfDeleteStack-1);Count >= 0;Count -- )
					{ 
					if ( Address == DeleteStack[ Count ].Address )
						{
						Result = True;
						break;
						}
					}
				}
			}

		//
		//   Release any lock we may have claimed earlier.
		//
		ReleaseCacheLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   Flush the cache to release the maximum amount of space back    */
    /*   to the operating system.  This is slow but may be very         */
    /*   valuable in some situations.                                   */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Truncate( VOID )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Disable the cache if needed.
	//
	Active = False;

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Flush any elements in the delete cache.
	//   We do this now because we need to use 
	//   the delete cache below.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}
	
	//
	//   Flush any elements in the new cache by
	//   copying them over to the delete cache
	//   and adding the additional information
	//   required.
	//
	if ( TopOfNewStack > 0 )
		{
		//
		//   We need to find the data page for each  
		//   allocation we have in the new cache.
		//   Claim the lock here to make things a
		//   little more efficient.
		//
		Find -> ClaimFindShareLock();

		//
		//   We copy each allocation across and 
		//   add the associated page information.
		//
		for ( TopOfNewStack --;TopOfNewStack >= 0;TopOfNewStack -- )
			{
			REGISTER VOID *Address = (NewStack[ TopOfNewStack ]);
			REGISTER PAGE *Page = (ParentCache -> FindChildPage( Address ));

			//
			//   You would think that any memory in the
			//   new cache had to be valid.   Well it
			//   does except in the case when we have
			//   'Recycle' set and somebody does a double
			//   delete on a valid heap address.
			//
			if ( Page != NULL )
				{
				REGISTER ADDRESS_AND_PAGE *Current = 
					(& DeleteStack[ TopOfDeleteStack ++ ]);

				//
				//   We need to find the allocation page
				//   where the memory was allocated from
				//   so we can delete it.
				//
				Current -> Address = Address;
				Current -> Page = Page;
				Current -> Version = Page -> GetVersion();
				}
			else
				{ 
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				InUse ++;

#endif
				Result = False; 
				}
			}

		//
		//   Release the lock.
		//
		Find -> ReleaseFindShareLock();
		}

	//
	//   Flush the delete cache again to delete
	//   any new elements that we added to it
	//   above.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data it needs.                                  */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::UpdateCache
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   Notify the parent cache that it has a new
	//   child.
	//
	if ( NewParentCache != ((CACHE*) GlobalRoot) )
		{ NewParentCache -> NumberOfChildren ++; }

	//
	//   Update the allocation bucket.
	//
	UpdateBucket
		( 
		NewFind,
		NewHeap,
		NewPages,
		NewParentCache 
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the cache and ensure it is disabled.                   */
    /*                                                                  */
    /********************************************************************/

CACHE::~CACHE( VOID )
	{
	if ( Active )
		{ Failure( "Cache active in destructor for CACHE" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\heap.hpp ===
#ifndef _HEAP_HPP_
#define _HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class BUCKET;
class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The heap interface.                                            */
    /*                                                                  */
    /*   The traditional memory allocation interface only supports      */
    /*   a single allocation heap.  This memory allocator supports      */
    /*   multiple allocation heaps.  However, the interface nicely      */
    /*   hides this so at this point we are back to the traditional     */
    /*   single heap interface.                                         */
    /*                                                                  */
    /********************************************************************/

class HEAP : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		//   The heap is the top level container of all the
		//   functionality in the other classes.  The 'Active'
		//   flag indicates if the heap has been initialized.
		//   The 'MaxFreePages' controls the amount of free
		//   space the heap will slave before it starts to
		//   return it the the external allocator.  The
		//   'SmallestParentMask' is mask that shows which 
		//   parts of an address can be safely masked off
		//   and still ensure a hit in the find lookaside
		//   cache.  The 'ThreadSafe' flag indicates whether
		//   locking being used.
		//
		BOOLEAN						  Active;
		SBIT32						  MaxFreePages;
		BIT32						  SmallestParentMask;
		BOOLEAN						  ThreadSafe;

		//
		//   A heap is merely a collection of fixed sized
		//   allocation buckets (each with an optional cache).
		//   The 'CachesSize' is the total number of buckets.
		//   The 'MinCacheSize' is the allocation size of the
		//   smallest bucket.  The 'MidCacheSize' is the size
		//   of the bucket where the stride changes.  The
		//   'MaxCacheSize' is the allocation size of the 
		//   largest bucket externally visable.
		//
		SBIT32						  CachesSize;
		SBIT32						  MinCacheSize;
		SBIT32						  MidCacheSize;
		SBIT32						  MaxCacheSize;

		//
		//   A key function of the heap is to convert the
		//   requested allocation size into a pointer to
		//   the appropriate bucket (and cache).  This has
		//   to be very fast and is achieved using a direct
		//   lookup (i.e. an array).  The lookup array 
		//   consists of two sections (i.e. for small sizes
		//   and large sizes) to minimize space.  The 
		//   'MaxTable1' and 'MaxTable2' variables contain 
		//   the size of each section of the array.  The 
		//   'ShiftSize1' and 'ShiftSize2' variables contain
		//   the shift that should be applied to the size to
		//   obtain the appropriate index.  The 'SizeToCache1'
		//   and 'SizeToCache2' pointers refer to the direct
		//   lookup tables.
		//   
		SBIT32						  MaxTable1;
		SBIT32						  MaxTable2;
		SBIT32						  ShiftSize1;
		SBIT32						  ShiftSize2;
		CACHE                         **SizeToCache1;
		CACHE                         **SizeToCache2;

		//
		//   The heap needs to have access to most of the 
		//   other classes.  The 'Caches' class sits on
		//   top of an allocation bucket which owns all
		//   the allocated memory for a given size.  The
		//   'ExternalCache' is a special bucket that 
		//   contains weird sized pages.  The 'Find' class
		//   translates allocation addresses to page 
		//   descriptions.  The 'Rockall' class is needed
		//   to gain access to the external allocation APIs.
		//   The 'NewPage' class owns all page descriptions
		//   and plays a significant role in whole heap
		//   operations.  The 'TopCache' is the largest 
		//   bucket size and owns almost all the externally
		//   allocated memory.
		//
		CACHE						  **Caches;
		CACHE						  *ExternalCache;
		FIND						  *Find;
		NEW_PAGE					  *NewPage;
		PREFETCH					  Prefetch;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   A key feature of this heap is its ability to be
		//   significantly reconfigured at run time.  A great
		//   deal of complexity could have been removed if 
		//   certain static choices had been made.  Although
		//   this flexibility is nice the support of statistics
		//   here allows precise information to be collected so
		//   to enable the value of this to be maximized.
		//   
		//
		SBIT32						  CopyMisses;
		SBIT32						  MaxCopySize;
		SBIT32						  MaxNewSize;
		SBIT32						  NewMisses;
		SBIT32						  Reallocations;
		SBIT32						  *Statistics;
		SBIT32						  TotalCopySize;
		SBIT32						  TotalNewSize;
#endif

   public:
		//
		//   Public functions.
		//
		//   The heap exports the high level interface
		//   out to the world.  Any request a developer
		//   can make must come through one of these
		//   functions.
		//
        HEAP
			(
			CACHE					  *Caches1[],
			CACHE					  *Caches2[],
			SBIT32					  MaxFreeSpace,
			FIND					  *NewFind,
			NEW_PAGE				  *NewPages,
			ROCKALL					  *NewRockall,
			SBIT32					  Size1,
			SBIT32					  Size2,
			SBIT32					  Stride1,
			SBIT32					  Stride2,
			BOOLEAN					  NewThredSafe
			);

		BOOLEAN Delete( VOID *Address,SBIT32 Size = NoSize );

		VOID DeleteAll( BOOLEAN Recycle = True );

		BOOLEAN Details( VOID *Address,SBIT32 *Size = NULL );

		VOID LockAll( VOID );

		BOOLEAN MultipleDelete
			( 
			SBIT32					  Actual,
			VOID					  *Array[],
			SBIT32					  Size = NoSize
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested,
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *New
			( 
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *Resize
			( 
			VOID					  *Address,
			SBIT32					  NewSize,
			SBIT32					  Move = 1,
			SBIT32					  *Space = NULL,
			BOOLEAN					  NoDelete = False,
			BOOLEAN					  Zero = False
			);

		BOOLEAN Truncate( SBIT32 MaxFreeSpace = 0 );

		VOID UnlockAll( BOOLEAN Partial = False );

		BOOLEAN Verify( VOID *Address,SBIT32 *Size = NULL );

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			SBIT32					  *Size 
			);

        ~HEAP( VOID );

		//
		//   Public inline functions.
		//
		//   Although these functions are public they mostly
		//   intended for internal consumption and are not
		//   to be called externally.
		//
		INLINE SBIT32 GetMaxFreePages( VOID )
			{ return MaxFreePages; }

		INLINE BOOLEAN KnownArea( VOID *Address )
			{ return (Find -> KnownArea( Address,TopCache )); }

		INLINE VOID *SpecialNew( SBIT32 Size )
			{ return NewPage -> NewCacheStack( Size ); }

	private:
		//
		//   Private functions.
		//
		//   All of the statistical information is 
		//   generated and output when the heaps
		//   destructor executes.
		//
		CACHE *FindCache( SBIT32 Size );
#ifdef ENABLE_HEAP_STATISTICS

		VOID PrintDebugStatistics( VOID );
#endif
		//
		//   Private inline functions.
		//
		//   The notion that resizing an allocation is 
		//   cheap has worked its way into the minds of 
		//   a large number of developers.  As a result
		//   parameter has been added to the function to
		//   allow the actual behavior to be controlled.
		//
		INLINE BOOLEAN ResizeTest( SBIT32 Delta,SBIT32 Move )
			{
			return
				(
				((Move > 0) && ((((Delta >= 0) ? Delta : -Delta) >= Move)))
					||
				((Move < 0) && ((Delta > 0) || (Delta <= Move)))
				);
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        HEAP( CONST HEAP & Copy );

        VOID operator=( CONST HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\find.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the size of the hash       */
    /*   table and other related features.                              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinHash				  = 1024;
CONST SBIT32 MinHashSpace			  = (100/25);
CONST SBIT32 MinLookAside			  = 128;

CONST BIT32 NoAddressMask			  = ((BIT32) -1);
CONST SBIT32 NoCacheEntry			  = -1;

#ifndef ENABLE_RECURSIVE_LOCKS
    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

THREAD_LOCAL_STORE FIND::LockCount;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create the hash table and initialize it ready for use. The     */
    /*   configuration information supplied from the parameters needs   */
    /*   to be carefully checked as it has come indirectly from the     */
    /*   user and may be bogus.                                         */
    /*                                                                  */
    /********************************************************************/

FIND::FIND
		( 
		SBIT32						  NewMaxHash,
		SBIT32						  NewMaxLookAside,
		SBIT32						  NewFindThreshold,
		ROCKALL						  *NewRockall,
		BOOLEAN						  NewResize, 
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 AlignMask = (NewRockall -> NaturalSize()-1);

	//
	//   We need to make sure that the size of the hash table
	//   makes sense.  The hash table size needs to be a reasonable
	//   size (say 1k or larger) and a power of 2 (so we don't need
	//   to do any divides).
	//   
	if 
			(
			PowerOfTwo( (AlignMask+1) )
				&&
			(NewFindThreshold >= 0 )
				&&
			(NewMaxHash >= MinHash) 
				&&
			(ConvertDivideToShift( NewMaxHash,& HashMask ))
				&& 
			(NewMaxLookAside >= MinLookAside) 
				&& 
			(ConvertDivideToShift( NewMaxLookAside,& LookAsideMask ))
			)
		{
		REGISTER SBIT32 HashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   Set up the hash table.
		//
		MaxHash = NewMaxHash;

		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);
		Resize = NewResize;

		//
		//   Set up the lookaside table.
		//
		MaxLookAside = NewMaxLookAside;

		MaxAddressMask = NoAddressMask;
		MinAddressMask = NoAddressMask;

		LookAsideActions = 0;
		LookAsideShift = (32-LookAsideMask);
		LookAsideMask = ((1 << LookAsideMask)-1);
		LookAsideThreshold = NewFindThreshold;

		ThreadSafe = NewThreadSafe;

		//
		//   Create some space for the find table and the 
		//   look aside table.
		//
		Hash = ((LIST*) NewRockall -> NewArea( AlignMask,TotalSize,False ));
		LookAside = ((LOOK_ASIDE*) & Hash[ MaxHash ]);
		Rockall = NewRockall;

		//
		//   If the memory allocation request for the hash
		//   table fails we are doomed.  If it works we need
		//   to call the constructor for each linked list
		//   head node.
		//
		if ( Hash != ((LIST*) AllocationFailure) )
			{
			REGISTER SBIT32 Count;

			//
			//   Call the constructor for each hash table
			//   linked list header.
			//
			for ( Count=0;Count < NewMaxHash;Count ++ )
				{ PLACEMENT_NEW( & Hash[ Count ],LIST ); }

			//
			//   Zero the look aside structures.  We need
			//   to do this to ensure they do not match a
			//   valid allocation address later.
			//
			for ( Count=0;Count < MaxLookAside;Count ++ )
				{
				REGISTER LOOK_ASIDE *Current = & LookAside[ Count ];

				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Zero the statistics information.
			//
			Fills = 0;
			Hits = 0;
			MaxPages = 0;
			MaxTests = 0;
			Misses = 0;
			Scans = 0;
			Tests = 0;
#endif
			Used = 0;
			}
		else
			{ Failure( "Create hash fails in constructor for FIND" ); }
		}
	else
		{ Failure( "Hash table size in constructor for FIND" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a particular memory allocation.  All         */
    /*   we have is an address.  We use this to find the largest        */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation we need to delete.                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Delete( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the details we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,NULL,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we put the deleted 
	//   element back in the associated cache.
	//
	if ( Page != ((PAGE*) NULL) )
 		{
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Original = (Page -> GetVersion());

		//
		//   Prefetch the class data if we are running a
		//   Pentium III or better with locks.  We do this
		//   because prefetching hot SMP data structures
		//   really helps.  However, if the structures are
		//   not shared (i.e. no locks) then it is worthless
		//   overhead.
		//
		if ( ThreadSafe )
			{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

		//
		//   Release the lock if we claimed it earlier and
		//   update the lookaside if needed.
		//
		if ( Update )
			{ ReleaseFindShareLockAndUpdate( Address,Page,Original ); }
		else
			{ ReleaseFindShareLock(); }

		//
		//   We have found the associated page description
		//   so pass the delete request along to the cache
		//   and get out of here.
		//
		return (Cache -> Delete( Address,Page,Original ));
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock();

		return False; 
		}
  }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an item from the find table.                            */
    /*                                                                  */
    /*   We need to delete page from the find list.  We expect          */
    /*   this to take quite a while as multiple threads can be          */
    /*   using this class at the same time.                             */
    /*                                                                  */
    /********************************************************************/

VOID FIND::DeleteFromFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   hash and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Delete the page from the hash table.
	//
	Page -> DeleteFromFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various look aside entries
		//   and delete any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we delete an entry from the hash table
		//   the lookaside is potentially corrupt.  So we 
		//   need to delete any look aside entries relating
		//   to this page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Delete the look aside entry if it is stale.
			//
			if ( Segment == Current -> Address )
				{
				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
			}
		}

	//
	//   Update the statistics.
	//
	Used --;

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Details
		( 
		VOID						  *Address,
		SEARCH_PAGE					  *Details,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the deatils we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}
	else
		{
		//
		//   We may need to provide the all the details of the
		//   allocation for some reason.
		//
		if ( Details != NULL )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we extract the 
	//   information we want.
	//
	if ( Result = (Page != ((PAGE*) NULL)) )
 		{
		//
		//   Compute the size.  We would normally expect
		//   this to be the cache size.  However, there
		//   are some weird pages that sometimes have
		//   other sizes.
		//
		(*Size) = (Page -> ActualSize());
		}

	//
	//   Release the lock if we claimed it earlier and 
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Address,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find in the look aside.                                        */
    /*                                                                  */
    /*   We need to find a particular page in the look aside.  So we    */
    /*   try a simple look up (no lists or chains).                     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::FindLookAside( VOID *Address,PAGE **Page )
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Address );

		//
		//   We have hashed to a lookaside slot.  Maybe
		//   it contains what we want or maybe not.
		//
		if ( Address == Current -> Address )
			{
#ifdef DEBUGGING
			if ( Current -> Version == (Current -> Page -> GetVersion()) )
				{
#endif
				//
				//   We hit the lookaside and the 
				//   contents are valid.
				//
				(*Page) = (Current -> Page);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Hits ++;
#endif

				return True;
#ifdef DEBUGGING
				}
			else
				{ Failure( "Deleted page in FindLookAside" ); }
#endif
			}
		}
	else
		{
		//
		//   We update number of times we tried to
		//   use the lookaside and it was disabled.  
		//   After a while this will lead to the 
		//   lookaside being enabled.
		//
		LookAsideActions ++; 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   We missed the lookaside so update the 
	//   statistics to reflect our misfortune.
	//
	Misses ++;
#endif

	return False; 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find a page.                                                   */
    /*                                                                  */
    /*   We need to find a particular page in the hash table.  So we    */
    /*   scan along the associated linked list looking for a match.     */
    /*                                                                  */
    /********************************************************************/

PAGE *FIND::FindPage( VOID *Address,CACHE *ParentCache )
    {
#ifdef ENABLE_HEAP_STATISTICS
	REGISTER SBIT32 Cycles = 0;
	REGISTER PAGE *Result = NULL;
#endif
	REGISTER PAGE *Page;

	//
	//   Find the associated hash bucket and then walk
	//   along the linked list for this looking for
	//   the correct page description.
	//
	for 
			( 
			Page = PAGE::FirstInFindList( FindHashHead( Address ) );
			! Page -> EndOfFindList();
			Page = Page -> NextInFindList()
			)
		{
#ifdef ENABLE_HEAP_STATISTICS
		//
		//   Count the number of iterations in when we
		//   are recording statistics so we can calculate
		//   the average chain length.
		//
		Cycles ++;

#endif
		//
		//   We can identify the the target page by two key
		//   characteristics.  These are the start address and
		//   the parent page.   Although we may have sub-divided
		//   a page into various chunks each chunk will have
		//   a different parent (although its start address
		//   may sometimes be the same).
		//
		if 
				( 
				(Address == (Page -> GetAddress())) 
					&& 
				(ParentCache == (Page -> GetParentPage()))
				)
			{
#ifdef ENABLE_HEAP_STATISTICS
			//
			//   We have found the target page.  So return it
			//   to the caller.
			//
			if ( Page -> ValidPage() )
				{
				Result = Page;
				break;
				}
			else
				{ Failure( "Deleted page in FindPage" ); }
#else
			return Page;
#endif
			}
		}

#ifdef ENABLE_HEAP_STATISTICS
	//
	//   When we are in statistics mode we need to update the
	//   information so we can output it at the end of the
	//   run.
	//
	if ( MaxTests < Cycles )
		{ MaxTests = Cycles; }

	Tests += Cycles;

	Scans ++;

	return Result;
#else
	return NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Insert an item into the find table.                            */
    /*                                                                  */
    /*   We need to insert a new page into the find table.  We expect   */
    /*   this to take quite a while as multiple threads can be using    */
    /*   this class at the same time.                                   */
    /*                                                                  */
    /********************************************************************/

VOID FIND::InsertInFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   find table and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Insert a new page into the find table.
	//
	Page -> InsertInFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various lookaside entries
		//   and update any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we add an entry from the find table
		//   the lookaside is potentially corrupt.  So we 
		//   need to update any lookaside entries relating
		//   to the page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Add the new page to the lookaside as we
			//   expect it to get hit pretty soon one way
			//   or another.
			//
			Current -> Address = Segment;
			Current -> Page = Page;
#ifdef DEBUGGING
			Current -> Version = Page -> GetVersion();
#endif
			}
		}

	//
	//   Update the statistics and resize the find
	//   table if it is over 75% full.
	//
	if ( ((++ Used) + (MaxHash / MinHashSpace)) > MaxHash )
		{ ResizeHashTable(); }
#ifdef ENABLE_HEAP_STATISTICS

	if ( Used > MaxPages )
		{ MaxPages = Used; }
#endif

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out if it is known to the current heap.             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::KnownArea( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Find out if the address belongs to this heap
	//   or any other heap of which we are aware (i.e.
	//   when single image is active).
	//
	Page = (ParentCache -> FindParentPage( Address ));

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindShareLock();

	return (Page != ((PAGE*) NULL));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock and update.                              */
    /*                                                                  */
    /*   We have been asked to insert a page into the lookaside.        */
    /*   We assume the caller already has a share lock which we         */
    /*   release when we are finished.                                  */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ReleaseFindShareLockAndUpdate
		( 
		VOID						  *Address,
		PAGE						  *Page,
		SBIT32						  Version
		)
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		//
		//   Claim an exclusive lock so we can update the 
		//   lookaside as needed.
		//
		ChangeToExclusiveLock();

#ifdef DEBUGGING
		if ( Page -> ValidPage() )
			{
#endif
			if ( Version == (Page -> GetVersion()) )
				{
				REGISTER LONG Base = (((LONG) Address) & ~MinAddressMask);
				REGISTER VOID *Segment = ((VOID*) Base);
				REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Segment );

				//
				//   Overwrite any existing information.
				//
				Current -> Address = Segment;
				Current -> Page = Page;
#ifdef DEBUGGING
				Current -> Version = Page -> GetVersion();
#endif
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Fills ++;
#endif
				}
#ifdef DEBUGGING
			}
		else
			{ Failure( "Deleted page in ReleaseFindShareLockAndUpdate" ); }
#endif

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock(); 
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the find table.                                         */
    /*                                                                  */
    /*   We need to grow the hash table as it appears to be a little    */
    /*   small given the number of pages that have been created.        */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ResizeHashTable( VOID )
    {
	AUTO SBIT32 NewHashMask;
	AUTO SBIT32 NewLookAsideMask;

	//
	//   When we need to resize the hash table it is a
	//   straight race.  The first thread to claim the
	//   lock gets to do the work.  Everyone else just
	//   exits.
	//
	if ( (Resize) && (Spinlock.ClaimLock(0)) )
		{
		REGISTER SBIT32 AlignMask = (Rockall -> NaturalSize()-1);
		REGISTER SBIT32 NewMaxHash = (MaxHash * ExpandStore);
		REGISTER SBIT32 NewMaxLookAside = (MaxLookAside * ExpandStore);
		REGISTER SBIT32 NewHashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 NewLookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 NewTotalSize = (NewHashSize + NewLookAsideSize);
		REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   It is actually possible for a thread to get
		//   delayed for so long that it thinks the hash 
		//   table still needs to be resized long after the 
		//   work has been completed.  Additionally, we want
		//   to make sure that all the new values are sane.
		//
		if 
				(
				PowerOfTwo( (AlignMask+1) )
					&&
				(NewMaxHash > 0)
					&&
				(ConvertDivideToShift( NewMaxHash,& NewHashMask ))
					&&
				(NewMaxLookAside > 0)
					&& 
				(ConvertDivideToShift( NewMaxLookAside,& NewLookAsideMask ))
					&&
				((Used + (MaxHash / MinHashSpace)) > MaxHash)
				)
			{
			REGISTER LIST *NewHash;
			REGISTER LOOK_ASIDE *NewLookAside;

			//
			//   We have been picked as the victim who
			//   needs to resize the hash table.  We are
			//   going to call the external allocator 
			//   to get more memory.  As we know this is 
			//   likely to to nail us we drop the lock to 
			//   allow other threads to continue.
			//
			ReleaseFindExclusiveLock();

			//
			//   We know that allocating a new table and 
			//   initializing it is going to take ages.
			//   Well at least everyone else gets to carry
			//   on in the mean time.
			//
			NewHash = 
				((LIST*) Rockall -> NewArea( AlignMask,NewTotalSize,False ));

			NewLookAside = 
				((LOOK_ASIDE*) & NewHash[ NewMaxHash ]);

			//
			//   If the memory allocation request for the hash
			//   table fails we exit and try again later. 
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;

				//
				//   Call the constructor for each hash table
				//   linked list header.
				//
				for ( Count=0;Count < NewMaxHash;Count ++ )
					{ PLACEMENT_NEW( & NewHash[ Count ],LIST ); }

				//
				//   Zero the look aside structure.
				//
				for ( Count=0;Count < NewMaxLookAside;Count ++ )
					{
					REGISTER LOOK_ASIDE *Current = & NewLookAside[ Count ];

					Current -> Address = ((VOID*) NoCacheEntry);
					Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
					Current -> Version = ((SBIT32) NoCacheEntry);
#endif
					}
				}

			//
			//   Claim an exclusive lock so we can resize  
			//   the hash table.
			//
			ClaimFindExclusiveLock();

			//
			//   If we have allocated the new find table
			//   we can now rehash the existing entries.
			//   If not we are out of here.
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;
				REGISTER SBIT32 MaxOldHash = MaxHash;
				REGISTER LIST *OldHash = Hash;

				//
				//   Update the control information 
				//   for the new hash table.
				//
				MaxHash = NewMaxHash;
				HashShift = (32-NewHashMask);
				HashMask = ((1 << NewHashMask)-1);

				MaxLookAside = NewMaxLookAside;
				LookAsideShift = (32-NewLookAsideMask);
				LookAsideMask = ((1 << NewLookAsideMask)-1);

				Hash = NewHash;
				LookAside = NewLookAside;

				//
				//   Delete all the existing records
				//   from the old hash table and insert
				//   them into the new hash table.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{
					REGISTER LIST *Current = & OldHash[ Count ];

					//
					//   Walk along each hash bucket 
					//   deleting the records and inserting
					//   them into the new hash table.
					//
					while ( ! Current -> EndOfList() )
						{
						REGISTER PAGE *Page = PAGE::FirstInFindList( Current );
						REGISTER VOID *Address = (Page -> GetAddress());

						Page -> DeleteFromFindList( Current );

						Page -> InsertInFindList( FindHashHead( Address ) );
						}
					}

				//
				//   Time to do more operating system work
				//   so lets drop the lock again.
				//
				ReleaseFindExclusiveLock();

				//
				//   Delete all the list heads and return the
				//   original allocation to the operating system.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{ PLACEMENT_DELETE( & OldHash[ Count ],LIST ); }

				//
				//   Deallocate the old extent.
				//
				Rockall -> DeleteArea( ((VOID*) OldHash),TotalSize,False );

				//
				//   We are finished so reclaim the lock
				//   so we can exit.
				//
				ClaimFindExclusiveLock();
				}
			else
				{ Resize = False; }
			}

		Spinlock.ReleaseLock();
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the find table.                                         */
    /*                                                                  */
    /*   We need to update the find table with certain information      */
    /*   to ensure it is used correctly and consistently.               */
    /*                                                                  */
    /********************************************************************/

VOID FIND::UpdateFind( BIT32 NewMaxAddressMask,BIT32 NewMinAddressMask )
    {
	//
	//   When we have a single heap image all the 'TopCache' sizes
	//   must be the same.
	//
	if 
			( 
			(MaxAddressMask == NoAddressMask) 
				|| 
			(MaxAddressMask == NewMaxAddressMask) 
			)
		{
		//
		//   If we need to be thread safe then claim a sharable lock
		//   on the hash table to stop it being changed under our feet.
		//
		ClaimFindExclusiveLock();

		//
		//   Update the max address mask if it is not the current
		//   value but yet consistent.
		//
		MaxAddressMask = NewMaxAddressMask;

		//
		//   Update the address mask is the new heap has a smaller
		//   parent than all of the other heaps.
		//
		if ( MinAddressMask > NewMinAddressMask )
			{ MinAddressMask = NewMinAddressMask; }

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ Failure( "Different 'TopCache' sizes with 'SingleImage'" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER VOID *Memory = (*Address);
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   When the address is null we need to set up the heap
	//   walk.  In all other cases we just extract the next
	//   allocation in the list.
	//
	if ( Memory != NULL )
		{
		AUTO SEARCH_PAGE Details;

		//
		//   Lets try the lookaside table.  There is a pretty
		//   good chance that we will have the details we need 
		//   already in the cache.  If not we need to find it
		//   the hard way.  During the process we add the mapping
		//   into the lookaside for next time.
		//
		if
				(
				Update =
					( 
					! FindLookAside
						( 
						((VOID*) (((LONG) Memory) & ~MinAddressMask)),
						& Page 
						) 
					)
				)
			{
			//
			//   Find the allocation page and get the details of entry.
			//   We do this by finding the parent of the top cache.
			//   We  know that this is the global root and will find
			//   the correct page even if it is on another heap (as
			//   long as the find table is globally shared).
			//
			Page = (ParentCache -> FindParentPage( Memory ));
			}

		//
		//   We now compute all the details relating to the address
		//   so we can find any subsequent allocation.
		//
		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Memory,& Details,True )); }

		//
		//   We may have failed to find the address  .If so
		//   we simply fail the call.  If not we find the next
		//   allocation in the heap.
		//
		if ( Result = ((Page != ((PAGE*) NULL)) && (Details.Found)) )
 			{
			//
			//   We need to walk the heap to get te details
			//   of the next allocation.
			//
			if ( Result = (Page -> Walk( & Details )) )
				{
				REGISTER BIT32 AllocationBit =
					((*Details.VectorWord) & Details.AllocationMask);

				(*Active) = (AllocationBit != 0);
				(*Address) = Details.Address;
				(*Size) = (Details.Page -> ActualSize());

				//
				//   If we are considering putting something
				//   in the lookaside lets make sure that
				//   we will get to hit the cache entry at
				//   least once.  If not lets forget putting
				//   it in the cache.
				//
				if ( Update )
					{
					Update =
						(
						(((LONG) Memory) & ~MinAddressMask)
							==
						(((LONG) Details.Address) & ~MinAddressMask)
						);
					}
				}
			}
		}
	else
		{
		AUTO SEARCH_PAGE Details;

		//
		//   We start a heap walk by setting the initial 
		//   address to the value null.
		//
		Details.Address = NULL;
		Details.Cache = ParentCache;
		Details.Page = NULL;

		Page = NULL;
		Update = False;

		//
		//   We walk the heap to get te details of the
		//   first heap allocation.
		//
		if ( Result = (Page -> Walk( & Details )) )
			{
			REGISTER BIT32 AllocationBit =
				((*Details.VectorWord) & Details.AllocationMask);

			(*Active) = (AllocationBit != 0);
			(*Address) = Details.Address;
			(*Size) = (Details.Page -> ActualSize());
			}
		}

	//
	//   Release the lock if we claimed it earlier and
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Memory,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Delete the hash table and release all the associated memory.   */
    /*                                                                  */
    /********************************************************************/

FIND::~FIND( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
	REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
	REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

	//
	//   Call the destructor for each hash table
	//   linked list header.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{ PLACEMENT_DELETE( & Hash[ Count ],LIST ); }

	//
	//   Deallocate the area.
	//
	Rockall -> DeleteArea( ((VOID*) Hash),TotalSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\heappch.hpp ===
#ifndef _HEAP_PCH_HPP_
#define _HEAP_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Bucket.hpp"
#include "BucketList.hpp"
#include "Cache.hpp"
#include "Connections.hpp"
#include "Find.hpp"
#include "FindList.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "NewPageList.hpp"
#include "Page.hpp"
#include "Rockall.hpp"

#include "LibraryPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\findlist.hpp ===
#ifndef _FIND_LIST_HPP_
#define _FIND_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "BucketList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The find list.                                                 */
    /*                                                                  */
    /*   The find list links all the pages in the same hash bucket      */
    /*   together so that the correct page can be found.                */
    /*                                                                  */
    /********************************************************************/

class FIND_LIST : public BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  FindList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        FIND_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromFindList( LIST *HeadOfList )
			{ FindList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfFindList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInFindList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInFindList( LIST *HeadOfList )
			{ FindList.Insert( HeadOfList ); }

		INLINE PAGE *NextInFindList( VOID )
			{ return ComputePageAddress( ((CHAR*) FindList.Next()) ); }

        ~FIND_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(BUCKET_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND_LIST( CONST FIND_LIST & Copy );

        VOID operator=( CONST FIND_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\find.hpp ===
#ifndef _FIND_HPP_
#define _FIND_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "List.hpp"
#include "Page.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Find a memory allocation.                                      */
    /*                                                                  */
    /*   When a memory allocation is released all we are given is .     */
    /*   the allocation address.  This is not very helpful as the       */
    /*   allocation information is not stored relative to this          */
    /*   address.  Instead we use a hash table to map the allocation    */
    /*   address to the allocation information.                         */
    /*                                                                  */
    /********************************************************************/

class FIND : public ENVIRONMENT, public COMMON
    {
		//
		//   Private type specifications.
		//
		//   We need to do a recursive search in the find 
		//   table in order to locate the associated page
		//   from an address.  As this is expensive there
		//   is also a cache that slaves common translations
		//   to improve performance.
		//
		typedef struct
			{
			VOID					  *Address;
			PAGE					  *Page;
#ifdef DEBUGGING
			SBIT32					  Version;
#endif
			}
		LOOK_ASIDE;

		//
		//   Private data.
		//
		//   All the page descriptions are stored in the 
		//   hash table so they can be quickly found.  The
		//   key is the address of the first byte on the
		//   page.  The 'MaxHash' is the number of elements
		//   in the hash table and is always a power of two.
		//   The 'HashMask' is a bit mask to remove any 
		//   unwanted part of the hash key.  The 'HashShift'
		//   is the number of bits required to shift and is
		//   as a substitute for divide.  The 'Resize' flag
		//   indicates whether the hash table is permitted 
		//   to grow.
		//
		SBIT32						  MaxHash;

		SBIT32						  HashMask;
		SBIT32						  HashShift;
		BOOLEAN						  Resize;

		//
		//   The hash table allows addresses to be mapped to
		//   page descriptions quickly.  Nonetheless, it is 
		//   not fast enough.  To enhance performance a look
		//   aside cache slaves the hottest translations.  The
		//   'MaxLookAside' is the number of elements in the
		//   cache.  The 'MaxAddressMask' is a mask that removes 
		//   low order bits of an address and represents the
		//   span of each cache entry.  The 'LookAsideActions'
		//   is a simple count of requests to the cache.  The
		//   'LookAsideMask' and 'LookAsideShift' parallel the
		//   fields above in the hash table.  The 'LookAsideThreshold'
		//   determines at what point the cache will become 
		//   active.  The 'ThreadSafe' flag indicates whether
		//   locking is required.
		//
		SBIT32						  MaxLookAside;

		BIT32						  MaxAddressMask;
		BIT32						  MinAddressMask;

		SBIT32						  LookAsideActions;
		SBIT32						  LookAsideMask;
		SBIT32						  LookAsideShift;
		SBIT32						  LookAsideThreshold;
		BOOLEAN						  ThreadSafe;

		//
		//   When a request is made to translate an address to
		//   a page description the cache is the first port of
		//   call.  If the translation is not found then the
		//   hash table is tried.  The 'Hash' points to the hash
		//   table.  The 'LookAside' points to the lookaside
		//   hash table.  The 'Rockall' points to the external API
		//   to give access to the low level external allocation
		//   functions.  
		//
		LIST						  *Hash;
		LOOK_ASIDE					  *LookAside;
		ROCKALL						  *Rockall;

		//
		//   The translation of addresses to page descriptions
		//   is very common.  So care has been taken to ensure
		//   it is not a bottleneck when locking is enabled.  The
		//   'Sharelock' is a fast reader/writer lock and is used
		//   almost all the time.  The 'Spinlock' is an exclusive
		//   lock and is only used when the 'Hash' and 'LookAside'
		//   tables are resized.
		//
		PREFETCH					  Prefetch;
		SHARELOCK					  Sharelock;
		SPINLOCK					  Spinlock;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   There is a concern with any hash table about
		//   poor hashing keys and poor performance.  The
		//   statistics monitor various data so as to allow
		//   the performance metrics to be monitored.  The
		//   'Fills' counter keeps track of the number of
		//   cache fills.  The 'Hits' counter monitors the
		//   number of cache hits.  The 'MaxPages' counter
		//   is the high water mark of hash table entries.
		//   The 'MaxTests' is the max number of compares 
		//   done while searching an entry.  The 'Misses' 
		//   counter keeps track of the number of cache misses.
		//   The 'Scans' counter monitors the number of hash
		//   table searches.  The 'Tests' counter is the 
		//   total number of tests performed while searching
		//   for entries.
		//
		SBIT32						  Fills;
		SBIT32						  Hits;
		SBIT32						  MaxPages;
		SBIT32						  MaxTests;
		SBIT32						  Misses;
		SBIT32						  Scans;
		SBIT32						  Tests;
#endif
		SBIT32						  Used;
#ifndef ENABLE_RECURSIVE_LOCKS

		//
		//   Static private data.
		//
		//   It is not uncommon for developers to have some
		//   form of bias.  I dislike recursive locks so here
		//   I introduce a TLS value to indicate whether the
		//   current thread has a global lock.  If so all
		//   locking in the other classes is disabled.
		//
		STATIC THREAD_LOCAL_STORE	  LockCount;
#endif

   public:
		//
		//   Public functions.
		//
		//   The translation functionality supplied by this
		//   class is only applicable after an allocation
		//   has been made.  Hence, all of the APIs supported
		//   relate to the need to translate an allocation
		//   address to the host page description.
		//
        FIND
			( 
			SBIT32					  NewMaxHash,
			SBIT32					  NewMaxLookAside,
			SBIT32					  NewFindThreshold,
			ROCKALL					  *NewRockall,
			BOOLEAN					  NewResize,
			BOOLEAN					  NewThreadSafe 
			);

		BOOLEAN Delete( VOID *Address,CACHE *ParentCache );

		VOID DeleteFromFindList( PAGE *Page );

		BOOLEAN Details
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		PAGE *FindPage( VOID *Address,CACHE *ParentCache );

		VOID InsertInFindList( PAGE *Page );

		BOOLEAN KnownArea( VOID *Address,CACHE *ParentCache );

		VOID ReleaseFindShareLockAndUpdate
			( 
			VOID					  *Address,
			PAGE					  *Page,
			SBIT32					  Version 
			);

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		VOID UpdateFind
			( 
			BIT32					  NewMaxAddressMask,
			BIT32					  NewMinAddressMask
			);

        ~FIND( VOID );

		//
		//   Public inline functions.
		//
		//   Although this class is perhaps the most self
		//   contained.  Nonetheless, there is still lots
		//   of situations when other classes need to 
		//   interact and get information about the current
		//   situation.
		//
		INLINE VOID ClaimFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimExclusiveLock(); } 
			}

		INLINE VOID ClaimFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimShareLock(); } 
			}

		INLINE VOID DeleteAll( VOID )
			{ LookAsideActions = 0; }

		INLINE VOID ReleaseFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseExclusiveLock(); } 
			}

		INLINE VOID ReleaseFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseShareLock(); } 
			}

		//
		//   Static public inline functions.
		//
		//   There is a strong case for removing the lock
		//   count functionality from this class.  However,
		//   as it consists of a single declaration and the
		//   following inline functions I have not been
		//   driven to fix this yet.  Maybe some day. 
		//
#ifndef ENABLE_RECURSIVE_LOCKS
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) - 1))
				);
			}

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return ((SBIT32) LockCount.GetPointer()); }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) + 1))
				);
			}
#else
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return 0; }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ /* void */ }
#endif

#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Public inline statistic functions.
		//
		//   The statistics are typically provided in 
		//   debug builds to provide good information  
		//   about allocation patterns.  
		//
		INLINE SBIT32 AverageHashLength( VOID )
			{ return (Tests / ((Scans > 0) ? Scans : 1)); }

		INLINE SBIT32 CacheFills( VOID )
			{ return Fills; }

		INLINE SBIT32 CacheHits( VOID )
			{ return Hits; }

		INLINE SBIT32 CacheMisses( VOID )
			{ return Misses; }

		INLINE SBIT32 MaxHashLength( VOID )
			{ return MaxTests; }

		INLINE SBIT32 MaxHashSize( VOID )
			{ return MaxHash; }

		INLINE SBIT32 MaxLookAsideSize( VOID )
			{ return MaxLookAside; }

		INLINE SBIT32 MaxUsage( VOID )
			{ return ((MaxPages * 100) / MaxHash); }

		INLINE SBIT32 TotalScans( VOID )
			{ return Scans; }
#endif

	private:
		//
		//   Private functions.
		//
		//   Although the hashed lookup functionality is 
		//   externally visable the look aside cache is 
		//   hidden from view along with the ability to
		//   resize the hash table.
		//
		BOOLEAN FindLookAside( VOID *Address,PAGE **Page );

		VOID ResizeHashTable( VOID );

		//
		//   Private inline functions.
		//
		//   Although I am not keen on code in the headers
		//   certain functions are so small or so hot that
		//   I have to submit to the desire to do it. 
		//
		INLINE VOID ChangeToExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ChangeSharedLockToExclusiveLock(); } 
			}

		INLINE LIST *FindHashHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& Hash[ ((Value >> HashShift) & HashMask) ]); 
			}

		INLINE LOOK_ASIDE *FindLookAsideHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& LookAside[ ((Value >> LookAsideShift) & LookAsideMask) ]); 
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND( CONST FIND & Copy );

        VOID operator=( CONST FIND & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\newpage.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants set overall limits on the number and size of     */
    /*   page descriptions for pages within the memory allocator.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinNewPages			  = 1;
CONST SBIT32 VectorRange			  = ((2 << 15) - 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   A 'PAGE' structure has various fixed fields and a variable     */
    /*   sized allocation bit vector.  When this class is initialized   */
    /*   the user is required to supply us with an array that details   */
    /*   the sizes of allocation bit vectors supported.                 */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::NEW_PAGE
		(
		FIND						  *NewFind,
		SBIT32						  NewPageSizes[],
		ROCKALL						  *NewRockall,
		SBIT32						  Size,
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 DefaultRootSize = (NewRockall -> NaturalSize());
	REGISTER SBIT32 ReservedBytes = (Size * sizeof(NEW_PAGES));
	REGISTER SBIT32 SpareBytes = (DefaultRootSize - ReservedBytes);
	REGISTER SBIT32 StackSize = (SpareBytes / sizeof(VOID*));

	//
	//   We need to make sure that we appear to have a valid
	//   array of 'NewPageSizes' and that the bit vector sizes
	//   do not exceed the memory addressing range.
	//
	if 
			(
			PowerOfTwo( DefaultRootSize )
				&&
			(DefaultRootSize >= PageSize())
				&&
			(Size >= MinNewPages) 
				&&
			((NewPageSizes[ (Size-1) ] * OverheadBitsPerWord) <= VectorRange)
			)
		{
		REGISTER VOID *NewMemory = 
			(
			NewRockall -> NewArea
				( 
				(DefaultRootSize-1),
				DefaultRootSize,
				False
				)
			);

		//
		//   We are in big trouble if we can not allocate space
		//   to store this initial control information.  If the
		//   allocation fails we are forced to exit and the whole  
		//   memory allocator becomes unavailable.
		//
		if ( NewMemory != AllocationFailure )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 LastSize = 0;

			//
			//   We are now ready to setup the configuration
			//   information.
			//
			MaxCacheStack = 0;
			MaxNewPages = Size;
			MaxStack = StackSize;

			NaturalSize = DefaultRootSize;
			RootCoreSize = DefaultRootSize;
			RootStackSize = 0;
			ThreadSafe = NewThreadSafe;
			TopOfStack = 0;
			Version = 0;

			CacheStack = NULL;
			NewPages = ((NEW_PAGES*) NewMemory);
			Stack = ((VOID**) & NewPages[ Size ]);

			Find = NewFind;
			Rockall = NewRockall;
			TopCache = NULL;

			//
			//   Create a lists for the various page 
			//   sizes and prepare them for use.
			//
			for ( Count=0;Count < Size;Count ++ )
				{
				REGISTER SBIT32 CurrentSize = NewPageSizes[ Count ];

				if ( CurrentSize > LastSize )
					{
					REGISTER NEW_PAGES *NewPage = & NewPages[ Count ];

					//
					//   Create a list for the current
					//   size and fill in all the related
					//   details.
					//
					NewPage -> Elements = (CurrentSize * OverheadBitsPerWord);
					PLACEMENT_NEW( & NewPage -> ExternalList,LIST );
					PLACEMENT_NEW( & NewPage -> FullList,LIST );
					PLACEMENT_NEW( & NewPage -> FreeList,LIST );
					NewPage -> Size = (CurrentSize * sizeof(BIT32));

					LastSize = CurrentSize;
					}
				else
					{ Failure( "Sizes in constructor for NEW_PAGES" ); }
				}
			}
		else
			{ Failure( "No memory in constructor for NEW_PAGES" ); }
		}
	else
		{ Failure( "Setup of pages in constructor for NEW_PAGES" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create a new page.                                             */
    /*                                                                  */
    /*   Create a new 'PAGE' structure and prepare it for use.  If      */
    /*   we don't already have any pages of the required size then      */
    /*   allocate memory, create new 'PAGE' structures and link them    */
    /*   into the appropriate free chain.                               */
    /*                                                                  */
    /********************************************************************/

PAGE *NEW_PAGE::CreatePage( CACHE *Cache,SBIT32 NewSize )
    {
	REGISTER PAGE *NewPage = ((PAGE*) AllocationFailure);
	REGISTER SBIT16 SizeKey = (Cache -> GetSizeKey());

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER NEW_PAGES *Current;

		//
		//   When there is a potential for multiple threads 
		//   we claim the lock.
		//
		ClaimNewPageLock();

		//
		//   We allocate 'PAGE' structures as we need them
		//   and link them together in the free list.
		//   If we don't have any structures available we 
		//   allocate some more and add tem to the list.
		//
		if ( (Current = & NewPages[ SizeKey ]) -> FreeList.EndOfList() )
			{
			REGISTER SBIT32 ArrayElements = (Current -> Size - MinVectorSize);
			REGISTER SBIT32 ArraySize = (ArrayElements * sizeof(BIT32));
			REGISTER SBIT32 TotalSize = (sizeof(PAGE) + ArraySize);
			REGISTER SBIT32 FinalSize = CacheAlignSize( TotalSize );
			REGISTER SBIT32 TotalPages = (NaturalSize / FinalSize);

			//
			//   Nasty, we have run out of stack space.  If
			//   we can not grow this table then the heap
			//   will not be able to expand any further.
			//
			if ( TopOfStack >= MaxStack )
				{
				//
				//   Try to grow the stack size.
				//
				ResizeStack();

				//
				//   Update the pointer as the table may
				//   have moved.
				//
				Current = & NewPages[ SizeKey ];
				}

			//
			//   We may find ourseleves in a situation where
			//   the size of the new 'PAGE' structure is larger
			//   than the natural allocation size or the stack
			//   is full so we can't create new pages.  If so we
			//   refuse to create any new pages so any allocation
			//   requests for this size will fail.
			//
			if ( (TotalPages > 0) && (TopOfStack < MaxStack) )
				{
				REGISTER CHAR *NewMemory = 
					((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

				//
				//   We may also find ourselves unable to 
				//   anymore memory.  If so we will fail the
				//   request to create a page.
				//
				if ( NewMemory != AllocationFailure )
					{
					REGISTER SBIT32 Count;

					//
					//   Add the new allocation to stack of
					//   outstanding external allocations.
					//
					Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

					//
					//   Add the new elements to the free list
					//   for the current allocation size.
					//
					for 
							( 
							Count=0;
							Count < TotalPages;
							Count ++, (NewMemory += FinalSize)
							)
						{
						REGISTER PAGE *Page = ((PAGE*) NewMemory);

						//
						//   The page has been allocated but not 
						//   initialized so call the constructor
						//   and the destructor to get it into
						//   a sane state.
						//
						PLACEMENT_NEW( NewPage,PAGE ) 
							(
							NULL,
							NULL,
							0,
							NULL,
							0
							);

						PLACEMENT_DELETE( Page,PAGE );

						//
						//   Finally add the page to the free list
						//   so it can be used.
						//
						Page -> InsertInNewPageList( & Current -> FreeList ); 
						}
					}
				}
			}

		//
		//   We are now ready to create a new allocation
		//   page.  We start by requesting a page from
		//   the parent bucket.  If this works we know that 
		//   we have almost everthing we need to create the 
		//   new page.
		//
		if ( ! Current -> FreeList.EndOfList() )
			{
			REGISTER VOID *NewMemory;
			REGISTER CACHE *ParentPage = (Cache -> GetParentCache());

			NewPage = (PAGE::FirstInNewPageList( & Current -> FreeList ));

			//
			//   We have found a suitable page structure
			//   so remove it from the free list.
			//
			NewPage -> DeleteFromNewPageList( & Current -> FreeList );

			//
			//   Release any lock we might have as another
			//   thread may be waiting to delete a page and
			//   be holding the lock we need in order to
			//   create a page.
			//
			ReleaseNewPageLock();

			//
			//   We need to allocate memory to store the users 
			//   data.  After all we are the memory allocator
			//   and that is our job in life.  Typically, we do
			//   this by making a recursive internal request
			//   from a larger bucket.  Nonetheless, at some point
			//   we will reach the 'TopCache' and will be forced
			//   to request memory from an external source.
			//
			if ( (Cache -> TopCache()) || (NewSize != NoSize) )
				{
				REGISTER AlignMask = (TopCache -> GetPageSize()-1);

				//
				//   We allocate memory externally in large blocks 
				//   and sub-divide these allocations into smaller
				//   blocks.  The only exception is if the caller 
				//   caller is requesting some weird size in which
				//   case we request memory directly from the
				//   external allocator (usually the OS).
				//
				if ( NewSize == NoSize )
					{ NewSize = (Cache -> GetPageSize()); }

				//
				//   All externally allocated memory belongs
				//   to the global root.  Thus, it will be 
				//   found in the first lookup in the find
				//   table.
				//
				ParentPage = ((CACHE*) GlobalRoot);

				//
				//   Allocate from the external allocator.
				//
				NewMemory = (VerifyNewArea( AlignMask,NewSize ));
				}
			else
				{
				//
				//   Allocate memory from a larger cache and then
				//   sub-divide it as needed.
				//
				NewMemory = 
					(Cache -> GetParentCache() -> CreateDataPage()); 
				}

			//
			//   Reclaim any lock we have had earlier so 
			//   we can update the the new page structure.
			//
			ClaimNewPageLock();

			//
			//   Lets make sure we sucessfully allocated the
			//   memory for the data page.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   We now have everything we need so lets
				//   create a new page.
				//
				PLACEMENT_NEW( NewPage,PAGE ) 
					(
					NewMemory,
					Cache,
					NewSize,
					ParentPage,
					(Version += 2)
					);

				//
				//   Finally lets add the new page to the various
				//   lists so we can quickly find it again later.
				//
				Cache -> InsertInBucketList( NewPage );

				Cache -> InsertInFindList( NewPage );

				NewPage -> InsertInNewPageList
					(
					(Cache -> TopCache())
						? & Current -> ExternalList 
						: & Current -> FullList 
					); 
				}
			else
				{
				//
				//   We were unable to allocate any data space
				//   for this new page so lets free the page 
				//   description and exit.
				//
				NewPage -> InsertInNewPageList( & Current -> FreeList );

				NewPage = ((PAGE*) AllocationFailure);
				}
			}

		//
		//   We have finished so release the lock now. 
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key is out of range" ); }
#endif

	return NewPage;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete an entire heap and return all the memory to the         */
    /*   top level pool or the external allocator (usually the OS).     */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeleteAll( BOOLEAN Recycle )
    {
	REGISTER SBIT32 Count;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We assume at this point that we have blocked
	//   all memory allocation and dealloction requests.
	//   We are now going to walk through the various lists
	//   and just blow away things.  We are going to
	//   do this in a tidy way just in case the caller
	//   wants to use the heap again later.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   All allocations that appear in the full list
		//   have been sub-allocated from larger pages in
		//   almost all cases.
		//
		for
				(
				Page = (PAGE::FirstInNewPageList( & Current -> FullList ));
				! Page -> EndOfNewPageList();
				Page = NextPage
				)
			{
			REGISTER VOID *Address = (Page -> GetAddress());
			REGISTER CACHE *Cache = (Page -> GetCache());
			REGISTER SBIT32 PageSize = (Page -> GetPageSize());

			//
			//   We decide here how we will deal with the page.
			//   If it is empty, non-standard or we are not
			//   recycling we will blow it away.  If not we
			//   simply reset it for later use.
			//
			if ( (Page -> Empty()) || (PageSize != NoSize) || (! Recycle) )
				{
				//
				//   We need to release any associated data page.
				//   If this is the top level then release the
				//   memory back to the external allocator.  If 
				//   not we release it back to the parent bucket.
				//
				if ( PageSize == NoSize )
					{
					//
					//   If we are just recycling then we cleanly
					//   delete the page.  If not then we know it
					//   will be blown away later so why bother.
					//
					if ( Recycle )
						{
						REGISTER CACHE *ParentCache = 
							(Cache -> GetParentCache());

						if ( ! (ParentCache -> DeleteDataPage( Address )) )
							{ Failure( "Reset data page in DeleteAll" ); }
						}
					}
				else
					{ Rockall -> DeleteArea( Address,PageSize,True ); }

				//
				//   We may have been blowing away pages  
				//   randomly and now we are about to destroy 
				//   the current page.  So lets figure out 
				//   what page comes next before we continue.
				//
				NextPage = (Page -> NextInNewPageList());

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> FullList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			else
				{
				//
				//   We know that the current page has at 
				//   least one allocation on it so instead
				//   of deleting it we will mark it as free
				//   (except for any sub-allocations) and
				//   leave it around for next time.  If it
				//   is never used the next top level 
				//   'DeleteAll' will delete it.
				//
				Page -> DeleteAll();

				//
				//   We have now reset the current page so  
				//   lets figure out what page comes next.
				//
				NextPage = (Page -> NextInNewPageList());
				}
			}

		//
		//   We have a choice to make.  If we intend to
		//   use this heap again we keep all top level
		//   allocated memory in a list ready for reuse.
		//   If not we return it to the external allocator
		//   (usually the OS).
		//   
		if ( ! Recycle )
			{
			//
			//   The external allocations list contains an
			//   entry for every externally allocated page
			//   except those allocated for special internal 
			//   use within this class or for weird sized
			//   pages that appeared above in the 'FullList'.
			//
			for
					(
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ));
					! Page -> EndOfNewPageList();
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ))
					)
				{
				REGISTER VOID *Address = (Page -> GetAddress());
				REGISTER CACHE *Cache = (Page -> GetCache());
				REGISTER SBIT32 PageSize = (Page -> GetPageSize());

				//
				//   We no longer need this top level allocation
				//   so return it to the external allocator.
				//
				Rockall -> DeleteArea( Address,PageSize,True );

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> ExternalList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			}
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page.                                                 */
    /*                                                                  */
    /*   Delete a page structure, free the associated memory and        */
    /*   unlink it from the various allocation lists.                   */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeletePage( PAGE *Page )
    {
	REGISTER CACHE *Cache = Page -> GetCache();
	REGISTER SBIT16 SizeKey = Cache -> GetSizeKey();

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER NEW_PAGES *Current = & NewPages[ SizeKey ];
		REGISTER SBIT32 Size = (Page -> GetPageSize());

		//
		//   We need to release any associated data page.
		//   If this is the top level then release the
		//   memory back to the external allocator.  If 
		//   not we release it back to the parent bucket.
		//
		if ( Size == NoSize )
			{ 
			REGISTER CACHE *ParentCache = (Cache -> GetParentCache());

			if ( ! (ParentCache -> DeleteDataPage( Address )) )
				{ Failure( "Deleting data page in DeletePage" ); }
			}
		else
			{ Rockall -> DeleteArea( Address,Size,True ); }

		//
		//   Claim the global lock so that the various  
		//   lists can be updated.
		//
		ClaimNewPageLock();

		//
		//   Remove the page from the lists and delete it.
		//
		Cache -> DeleteFromBucketList( Page );

		Cache -> DeleteFromFindList( Page );

		Page -> DeleteFromNewPageList
			(
			(Cache -> TopCache())
				? & Current -> ExternalList 
				: & Current -> FullList 
			); 

		PLACEMENT_DELETE( Page,PAGE );

		//
		//   Finally add the page to the free list
		//   so it can be recycled.
		//
		Page -> InsertInNewPageList( & Current -> FreeList );

		//
		//   We have finsihed so release the lock.
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key out of range in DeletePage" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find the correct index in new page.                            */
    /*                                                                  */
    /*   When we come to create a new page we need to make sure the     */
    /*   bit vector is large enough for the page.  We calculate this    */
	/*   here just once to save time later.                             */
    /*                                                                  */
    /********************************************************************/

SBIT16 NEW_PAGE::FindSizeKey( SBIT16 NumberOfElements )
    {
	REGISTER SBIT32 Count;

	//
	//   Search the table of page structures looking for 
	//   elements of a suitable size.  As the table is
	//   known to be in order of increasing size we can
	//   terminate the search as soon as we find something 
	//   large enough.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		if ( NumberOfElements <= Current -> Elements )
			{ return ((SBIT16) Count); }
		}

	//
	//   Nasty, we don't seem to have anything large enough
	//   to store the bit vector.
	//
	return NoSizeKey;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new cache stack.                                      */
    /*                                                                  */
    /*   A cache stack is an array that contains memory allocations     */
    /*   that are waiting to be allocated or released.                  */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::NewCacheStack( SBIT32 Size )
    {
	REGISTER VOID *NewStack;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We ensure that there is enough space to make the
	//   allocation.  If not we request additional space
	//   and prepare it for use.
	//
	if ( (CacheStack == NULL) || ((MaxCacheStack + Size) > NaturalSize) )
		{
		//
		//   Nasty, we have run out of stack space.  If
		//   we can not grow this table then the heap
		//   will not be able to expand any further.
		//
		if ( TopOfStack >= MaxStack )
			{
			//
			//   Try to grow the stack size.
			//
			ResizeStack();
			}

		//
		//   We may find ourseleves in a situation where
		//   the size of the new stack structure is larger
		//   than the natural allocation size or the stack
		//   is full so we can't create new pages.  If so we
		//   refuse to create any new stacks.
		//
		if ( (Size < NaturalSize) && (TopOfStack < MaxStack) )
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

			//
			//   We may also find ourselves unable to 
			//   anymore memory.  If so we will fail the
			//   request to create a new cache stack.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   Add the new allocation to stack of
				//   outstanding external allocations.
				//
				Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

				//
				//   Prepare the new memory block for use.
				//   
				CacheStack = NewMemory;
				MaxCacheStack = 0;
				}
			else
				{ return NULL; }
			}
		else
			{ return NULL; }
		}

	//
	//   We allocate some space for the new cache 
	//   stack and update and align the high water
	//   mark of the space used.
	//
	NewStack = ((VOID*) & CacheStack[ MaxCacheStack ]);

	MaxCacheStack += (Size + CacheLineMask);
	MaxCacheStack &= ~CacheLineMask;

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return NewStack;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Resize the new page stack.                                     */
    /*                                                                  */
    /*   The new page stack holds pointers to all the pages owned       */
    /*   by the heap.  If this stack become full we must expand it      */
	/*   otherwise we can no longer grow the heap.                      */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::ResizeStack( VOID )
    {
	REGISTER SBIT32 NewSize = 
		(((RootStackSize <= 0) ? NaturalSize : RootStackSize) * 2);

	//
	//   Lets just check that we have really run out
	//   of stack space as expanding it really hurts.
	//
	if ( TopOfStack >= MaxStack )
		{
		REGISTER VOID *NewMemory = 
			(
			Rockall -> NewArea
				( 
				(NaturalSize-1),
				NewSize,
				False
				)
			);

		//
		//   We need to verify that we were able to allocate
		//   fresh memory for the stack.
		//
		if ( NewMemory != NULL )
			{
			REGISTER BOOLEAN DeleteStack = (RootStackSize > 0);
			REGISTER VOID *OriginalMemory = ((VOID*) Stack);
			REGISTER SBIT32 OriginalSize = (MaxStack * sizeof(VOID*));

			//
			//   All is well as we were able to allocate 
			//   additional space for the stack.  All we 
			//   need to do now is to update the control 
			//   information.
			//
			MaxStack = (NewSize / sizeof(VOID*));

			RootStackSize = NewSize;

			Stack = ((VOID**) NewMemory);

			//
			//   Now lets copy across the existing data. 
			//
			memcpy( NewMemory,OriginalMemory,OriginalSize );

			//
			//   When the heap is created we put the
			//   stack on the root core page.  Later
			//   we may move it if we expand it.  If
			//   this is the case we have to delete  
			//   the previous expansion here.
			//
			if ( DeleteStack )
				{
				//
				//   Deallocate the existing stack if it
				//   is not on the root core page.
				//
				Rockall -> DeleteArea( OriginalMemory,OriginalSize,False );
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify an external allocation.                                 */
    /*                                                                  */
    /*   All memory requests are allocated from the external allocator  */
	/*   at the highest level.  Here we have a wrapper for this         */
    /*   function so we can test the result and make sure it is sane.   */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::VerifyNewArea( SBIT32 AlignMask,SBIT32 Size )
	{
#ifdef DEBUGGING
	//
	//   We need to ensure that the alignment of the new
	//   external allocation is a power of two.
	//
	if ( PowerOfTwo( (AlignMask + 1) ) )
		{
#endif
		REGISTER VOID *NewMemory = 
			(Rockall -> NewArea( AlignMask,Size,True ));

		//
		//   We need to ensure that the external allocation
		//   request is sucessful.  If not it makes no sense
		//   to try and check it.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   We require the external memory allocator to always
			//   allocate memory on the requested boundary.  If not 
			//   we are forced to reject the supplied memory.
			//
			if ( (((SBIT32) NewMemory) & AlignMask) == 0 )
				{ return NewMemory; }
			else
				{ 
				Rockall -> DeleteArea( NewMemory,Size,True );
				
				Failure( "Alignment of allocation in VerifyNewArea" );
				}
			}
#ifdef DEBUGGING
		}
	else
		{ Failure( "Alignment is not a power of two in VerifyNewArea" ); }
#endif

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN NEW_PAGE::Walk( SEARCH_PAGE *Details )
    {
	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We examine the current address to see if it
	//   is null.  If so then this is the start of a
	//   heap walk so we need to set it up.
	//
	if ( Details -> Address == NULL )
		{
		REGISTER SBIT32 Count;

		//
		//   Walk through the list of different sized
		//   page descriptions.
		//
		for ( Count=0;Count < MaxNewPages;Count ++ )
			{
			REGISTER NEW_PAGES *Current = & NewPages[ Count ];

			//
			//   Compute a pointer to the first element
			//   of the current size.
			//
			Details -> Page = 
				(PAGE::FirstInNewPageList( & Current -> FullList ));

			//
			//   Examine the current list of full (or 
			//   partially full) pages.  If there is at  
			//   least one page then this is the starting 
			//   point for the heap walk.
			//
			if ( ! Details -> Page -> EndOfNewPageList() )
				{
				//
				//   Compute the starting address of the 
				//   heap walk.
				//
				Details -> Address = 
					(Details -> Page -> GetAddress());

				break;
				}
			}
		}
	else
		{
		REGISTER PAGE *LastPage = Details -> Page;

		//
		//   We have exhusted the current page so walk
		//   the list and find the next page.
		//
		Details -> Page = 
			(Details -> Page -> NextInNewPageList());

		//
		//   We need to ensure that we have not reached
		//   the end of the current list.
		//
		if ( Details -> Page -> EndOfNewPageList() )
			{
			REGISTER SBIT32 Count;
			REGISTER BOOLEAN Found = False;

			//
			//   We need to find a new page description
			//   list to walk so reset the current 
			//   address just in case we don't find 
			//   anything.
			//
			Details -> Address = NULL;

			//
			//   We have reached the end of the current
			//   list and we need to continue with the
			//   start of the next list.  However, we
			//   don't know which list we were using
			//   previously.  So first we identify the
			//   previous list and then select the next
			//   avaibale list.
			//
			for ( Count=0;Count < MaxNewPages;Count ++ )
				{
				REGISTER NEW_PAGES *Current = & NewPages[ Count ];

				//
				//   We search for the original list
				//   we were walking.
				//
				if ( ! Found )
					{
					//
					//   When we find the original list
					//   then we set a flag showing that
					//   the next available list is the
					//   target.
					//
					if 
							( 
							LastPage 
								== 
							(PAGE::LastInNewPageList( & Current -> FullList )) 
							)
						{ Found = True; }
					}
				else
					{
					//
					//   We have found the previous list
					//   so the first element of the next
					//   list seems a good place to continue.
					//
					Details -> Page = 
						(PAGE::FirstInNewPageList( & Current -> FullList ));

					//
					//   We check to make sure that the list
					//   has at least one active page.  If not
					//   it is worthless and we continue looking
					//   for a suitable list.
					//
					if ( ! Details -> Page -> EndOfNewPageList() )
						{
						//
						//   Compute the starting address for 
						//   the next page in the heap walk.
						//
						Details -> Address = 
							(Details -> Page -> GetAddress());

						break;
						}
					}
				}
			}
		else
			{ 
			//
			//   Compute the starting address for 
			//   the next page in the heap walk.
			//
			Details -> Address = 
				(Details -> Page -> GetAddress());
			}
		}

	//
	//   If we find a new heap page to walk we update
	//   the details.  We mark some entry's as exhusted
    //   so as to provoke other code to set them up.
	//
	if ( Details -> Address != NULL )
		{
		//
		//   Compute the new allocation details.
		//
		Details -> Page -> FindPage
			( 
			Details -> Address,
			Details,
			False 
			);
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return (Details -> Address != NULL);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory all the page structures and release any allocated      */
    /*   memory.                                                        */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::~NEW_PAGE( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Delete all active allocations.
	//
	DeleteAll( False );

	//
	//   We are about to delete all of the memory 
	//   allocated by this class so destroy any
	//   internal pointers.
	//
	MaxCacheStack = 0;
	CacheStack = NULL;

	//
	//   We have now deleted all the memory allocated by
	//   this heap except for the memory  allocated directly 
	//   by this class.  Here we finish off the job by 
	//   deleting these allocations and reseting the internal 
	//   data structures.
	//
	for ( Count=0;Count < TopOfStack;Count ++ )
		{
		REGISTER VOID *Current = Stack[ Count ];

		Rockall -> DeleteArea( Current,NaturalSize,False );
		}

	TopOfStack = 0;

	//
	//   If we were forced to expand the root stack then
	//   release this additional memory now.
	//
	if ( RootStackSize > 0 )
		{
		//
		//   Deallocate root stack which previously 
		//   contained pointers to all the memory
		//   allocated by this class.
		//
		Rockall -> DeleteArea( ((VOID*) Stack),RootStackSize,False );
		}

	//
	//   Delete all the new page list headings just
	//   to be neat
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		PLACEMENT_DELETE( & Current -> ExternalList,LIST );
		PLACEMENT_DELETE( & Current -> FullList,LIST );
		PLACEMENT_DELETE( & Current -> FreeList,LIST );
		}

	//
	//   Deallocate root core page which previously 
	//   contained all the new page lists.
	//
	Rockall -> DeleteArea( ((VOID*) NewPages),RootCoreSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\heap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control minimum size of an         */
    /*   allocation bucket.                                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinParentSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a heap and prepare it for use.  Additionally, make      */
    /*   sure that the heap configuration makes sense.  This is         */
    /*   tricky as the whole structure of the heap can be changed       */
    /*   by the external configuration information.                     */
    /*                                                                  */
    /********************************************************************/

HEAP::HEAP
		(
		CACHE						  *Caches1[],
		CACHE						  *Caches2[],
		SBIT32						  MaxFreeSpace,
		FIND						  *NewFind,
		NEW_PAGE					  *NewPages,
		ROCKALL						  *NewRockall,
		SBIT32						  Size1,
		SBIT32						  Size2,
		SBIT32						  Stride1,
		SBIT32						  Stride2,
		BOOLEAN						  NewThreadSafe
		)
    {
	//
	//   The top three buckets are special and a user can not 
	//   allocate memory from two of them.  Thus, unless we have  
	//   at least four buckets the memory allocator is not going 
	//   to be very useful. 
	//
	if ( (Size1 >= 1) && (Size2 >= 3) )
		{
		REGISTER CACHE *FirstCache = Caches1[0];
		REGISTER CACHE *MiddleCache = Caches2[0];
		REGISTER CACHE *LastCache = Caches2[ (Size2-3) ];

		//
		//   Calculate the minimum and maximum allocation sizes.
		//   All allocations outside of this range will be passed
		//   directly to the external allocator.
		//
		CachesSize = (Size1 + Size2);
		MinCacheSize = FirstCache -> GetAllocationSize();
		MidCacheSize = MiddleCache -> GetAllocationSize();
		MaxCacheSize = LastCache -> GetAllocationSize();

		//
		//   Calculate and save various useful pointers needed
		//   during the course of execution.
		//
		Caches = Caches1;
		ExternalCache = (Caches2[ (Size2-1) ]);
		Find = NewFind;
		NewPage = NewPages;
		Rockall = NewRockall;
		TopCache = (Caches2[ (Size2-2) ]);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Zero the heap statistics.
		//
		CopyMisses = 0;
		MaxCopySize = 0;
		MaxNewSize = 0;
		NewMisses = 0;
		Reallocations = 0;
		TotalCopySize = 0;
		TotalNewSize = 0;
#endif

		//
		//   The external allocation size must be reasonable.
		//   All allocation sizes must be a multiple of the
		//   minimum allocation size.  The minimum allocation
		//   size and the middle allocation size must be a 
		//   power of two.
		//   
		if 
				( 
				(ExternalCache -> GetPageSize() == TopCache -> GetPageSize())
					&& 
				(PowerOfTwo( Rockall -> NaturalSize() ))
					&&
				(Rockall -> NaturalSize() >= PageSize())
					&&
				(TopCache -> GetPageSize() >= PageSize())
					&&
				(PowerOfTwo( TopCache -> GetPageSize() ))
					&&
				((Stride1 > 0) && (PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (PowerOfTwo( Stride2 )))
					&&
				(ConvertDivideToShift( Stride1,& ShiftSize1 ))
					&&
				(ConvertDivideToShift( Stride2,& ShiftSize2 ))
				)
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 TopCacheSize = (TopCache -> GetPageSize());
			REGISTER SBIT32 MaxSize1 = (MidCacheSize / Stride1);
			REGISTER SBIT32 MaxSize2 = (TopCacheSize / Stride2);

			//
			//   Calculate the maximum number of free pages 
			//   that can be kept.  Also set the smallest parent
			//   mask to the maximum value.
			//
			MaxFreePages = (MaxFreeSpace / (TopCache -> GetAllocationSize()));
			SmallestParentMask = ((TopCache -> GetAllocationSize())-1);
			ThreadSafe = NewThreadSafe;

			//
			//   Calculate the sizes of the arrays that map 
			//   sizes to caches.
			//
			MaxTable1 = (MaxSize1 * sizeof(CACHE*));
			MaxTable2 = (MaxSize2 * sizeof(CACHE*));

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < Size1;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches1[ Count1 ];
				REGISTER CACHE *Next = Caches1[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride1) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < (Size2-2);Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER CACHE *Next = Caches2[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The external and top caches have special rules
			//   which must be checked to ensure these caches
			//   are valid.
			//
			for ( Count1=(Size2-2);Count1 < Size2;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Top cache size not multiple of minimum" ); }

				if ( AllocationSize != Current -> GetChunkSize() )
					{ Failure( "Chunk size not suitable for top cache" ); }

				if ( AllocationSize != Current -> GetPageSize() )
					{ Failure( "Page size not suitable for top cache" ); }

				if ( Current -> GetCacheSize() != 0 )
					{ Failure( "Cache size not zero for top cache" ); }
				}

			//
			//   We need to allocate two arrays to enable requested
			//   sizes to be quickly mapped to allocation caches.
			//   Here we allocate the tables and later fill in all
			//   the necessary mapping information.
			//
			SizeToCache1 = (CACHE**) 
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxTable1 + MaxTable2),
					False
					)
				);
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   When we are compiled for statistics we keep
			//   information on all the allocations we see.
			//
			Statistics = (SBIT32*)
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxCacheSize * sizeof(SBIT32)),
					False
					)
				);
#endif

			//
			//   We make sure that the allocations we made 
			//   did not fail.  If not we have to fail the 
			//   creation of the whole heap.
			//
			if 
					( 
					(SizeToCache1 != ((CACHE**) AllocationFailure))
#ifdef ENABLE_HEAP_STATISTICS
						&&
					(Statistics != ((SBIT32*) AllocationFailure))
#endif
					) 
				{
				REGISTER SBIT32 Count2;

				//
				//   Cycle through the first segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize1;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride1)
								> 
							(Caches1[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache1[ Count1 ] = Caches1[ Count2 ];
					}

				//
				//   Compute the start address for the second
				//   segment of the table.
				//
				SizeToCache2 = 
					((CACHE**) & ((CHAR*) SizeToCache1)[ MaxTable1 ]);

				//
				//   Cycle through the second segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize2;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride2)
								> 
							(Caches2[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache2[ Count1 ] = Caches2[ Count2 ];
					}

				//
				//   Now that we have created the size to cache 
				//   mappings lets use them to link each cache to  
				//   the cache it uses to allocate additional 
				//   memory.
				//
				for ( Count1=0;Count1 < (CachesSize-1);Count1 ++ )
					{
					REGISTER CACHE *CurrentCache = Caches[ Count1 ];
					REGISTER SBIT32 PageSize = CurrentCache -> GetPageSize();
					REGISTER CACHE *ParentCache = FindCache( PageSize );
					REGISTER BOOLEAN Top = (CurrentCache == ParentCache);

					//
					//   Ensure that the parent cache is suitable
					//   and in line with what we were expecting. 
					//
					if 
							(
							(PowerOfTwo( PageSize ))
								&&
							(PageSize >= MinParentSize)
								&&
							(PageSize == (ParentCache -> GetAllocationSize()))
							)
						{
						//
						//   We keep track of the smallest
						//   cache that is a parent.  We can
						//   use this to improve the performance
						//   of the find hash table.
						//
						if ( ((BIT32) PageSize) < SmallestParentMask )
							{ SmallestParentMask = (PageSize-1); }

						//
						//   Update the current cache with  
						//   information about it's parent 
						//   cache.
						//
						CurrentCache -> UpdateCache
							(
							NewFind,
							this,
							NewPages,
							((Top) ? ((CACHE*) GlobalRoot) : ParentCache)
							); 
						} 
					else
						{ Failure( "Parent bucket is invalid" ); }
					}

				//
				//   The external cache is an exact duplicate
				//   of the top cache and is used to hold all
				//   memory allocations that are too large for
				//   any bucket.  Nonetheless, its parent is
				//   still the top cache.
				//
				ExternalCache -> UpdateCache
					(
					NewFind,
					this,
					NewPages,
					TopCache
					);

				//
				//   Update the hash table with the minimum
				//   parent size for this heap.
				//
				Find -> UpdateFind
					(
					(TopCache -> GetAllocationSize()-1),
					SmallestParentMask 
					);

				//
				//   Update the new page structure with the 
				//   details of the top cache.
				//
				NewPage -> UpdateNewPage( TopCache );

				//
				//   Activate the heap.
				//
				Active = True;
				}
			else
				{ Failure( "Mapping table in constructor for HEAP" ); }
			}
		else
			{ Failure( "The allocation sizes in constructor for HEAP" ); }
		}
	else
		{ Failure( "A heap size in constructor for HEAP" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We need to release some memory.  First we try to slave the     */
    /*   request in the free cache so we can do a batch of releases     */
    /*   later.  If not we are forced to do it at once.                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Delete( VOID *Address,SBIT32 Size )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   When the caller gives us the size of the 
		//   allocation we can short cut the deallocation 
		//   process by skipping directly to the correct 
		//   cache.  However, if the user supplies us
		//   with bogus data we will retry using the
		//   the full deallocation process.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			if ( Find -> Delete( Address,Cache ) )
				{ return True; }
			}

		//
		//   It looks like all we have is the address so 
		//   deallocate using the long path.
		//
		return (Find -> Delete( Address,TopCache ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We delete the entire heap and free all existing allocations.   */
    /*   If 'Recycle' is requested we slave the allocated memory as     */
    /*   we expect some new allocations.  If not we return all the      */
    /*   memory to the external allocator.                              */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::DeleteAll( BOOLEAN Recycle )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   We claim all of the heap locks to freeze
		//   all new allocations or deletions.
		//
		LockAll();

		//
		//   Now reset all the caches and the find
		//   hash table statistics.
		//
		Find -> DeleteAll();

		for ( Count=0;Count < CachesSize;Count ++ )
			{ Caches[ Count ] -> DeleteAll(); }

		//
		//   Delete the heap.
		//
		NewPage -> DeleteAll( Recycle );

		//
		//   Now release all the heap locks we claimed
		//   earlier and unfreeze the heap.
		//
		UnlockAll();

		//
		//   Trim the free space if needed.
		//
		if ( Recycle )
			{ TopCache -> ReleaseSpace( MaxFreePages ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Details( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Size' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.
		//
		if ( Size == NULL )
			{ Size = & Dummy; }

		//
		//   Find the details relating to this allocation
		//   and return them.
		//
		return (Find -> Details( Address,NULL,TopCache,Size ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a cache.                                                  */
    /*                                                                  */
    /*   Find the allocation cache for the size supplied and return     */
    /*   a pointer to it.                                               */
    /*                                                                  */
    /********************************************************************/

CACHE *HEAP::FindCache( SBIT32 Size )
	{
	REGISTER CACHE *Cache;

	//
	//   Compute the cache address.
	//
	if ( Size < MidCacheSize )
		{ return (SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }

	//
	//   Prefetch the class data if we are running a
	//   Pentium III or better with locks.  We do this
	//   because prefetching hot SMP data structures
	//   really helps.  However, if the structures are
	//   not shared (i.e. no locks) then it is worthless
	//   overhead.
	//
	if ( ThreadSafe )
		{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

	return Cache;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim a lock on the entire heap.                               */
    /*                                                                  */
    /*   We claim a lock on the heap to improve performance             */
    /*   or prevent others from performing heap operations.             */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::LockAll( VOID )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We claim the locks if we have not already
		//   claimed them earlier.
		//
		if ( Find -> GetLockCount() == 0 )
			{
			REGISTER SBIT32 Count;

			//
			//   We claim all of the heap locks to freeze
			//   all new allocations or deletions.
			//
			for ( Count=0;Count < CachesSize;Count ++ )
				{ Caches[ Count ] -> ClaimCacheLock(); }

			//
			//  Although the heap is frozen at this point
			//  we claim the last few locks just to be
			//  tidy.
			//
			Find -> ClaimFindExclusiveLock();

			NewPage -> ClaimNewPageLock();
			}

		//
		//   Increment the per thread lock count.
		//
		Find -> IncrementLockCount();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete multiple allocations.                                   */
    /*                                                                  */
    /*   We need to release multiple memory allocations.  First we try  */
    /*   to slave the requets in the free cache so we can do a batch    */
    /*   of releases later.  If not we are forced to do it immediately. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleDelete
		( 
		SBIT32						  Actual,
		VOID						  *Array[],
		SBIT32						  Size 
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;
		REGISTER BOOLEAN Result = True;
		REGISTER CACHE *ParentCache = ((CACHE*) GlobalRoot);

		//
		//   When the caller gives us the size of the allocation
		//   we can short cut the deallocation process by skipping
		//   directly to the correct cache.  However, if the user
		//   supplies us with bogus data we will retry using the
		//   the long path.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			ParentCache = (Cache -> GetParentCache());
			}

		//
		//   Delete each memory allocation one at a time.
		//   We would like to delete them all at once but
		//   we can't be sure they are all vaild or related.
		//
		for ( Count=0;Count < Actual;Count ++ )
			{
			REGISTER VOID *Address = Array[ Count ];

			//
			//   First try to optimize the delete and if that
			//   fails then try the long path.
			//
			if 
					(
					(ParentCache == ((CACHE*) GlobalRoot)) 
						|| 
					(! Find -> Delete( Address,ParentCache )) 
					)
				{
				Result =
					(
					Find -> Delete( Address,TopCache )
						&&
					Result
					);
				}
			}

		return Result;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We have been asked to allocate muliple memory blocks.   We     */
    /*   we do this by using the cache and then claiming and addition   */
    /*   space from the heap as needed.                                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested,
		SBIT32						  Size,
		SBIT32						  *Space,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Actual' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.  Regardless we zero it.
		//
		if ( Actual == NULL )
			{ Actual = & Dummy; }

		(*Actual) = 0;

		//
		//   We need to be sure that the size requested is in the 
		//   range supported by the memory allocator.  If not we
		//   do a series of single allocations from the default
		//   allocator.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
			REGISTER SBIT32 NewSize = (Cache -> GetAllocationSize());

			//
			//   Allocate memory from the appropriate 
			//   allocation bucket.
			//
			(VOID) Cache -> MultipleNew( Actual,Array,Requested );

			//
			//   If needed return the actual amount  
			//   of space allocated for each element.
			//
			if ( Space != NULL )
				{ (*Space) = NewSize; }
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] += Requested;
#endif

			//
			//   If needed zero each element that is  
			//   allocated.
			//
			if ( Zero )
				{
				REGISTER SBIT32 Count;

				for ( Count=((*Actual)-1);Count >= 0;Count -- )
					{ ZeroMemory( Array[ Count ],NewSize ); }
				}

			return ((*Actual) == Requested);
			}
		else
			{
			//
			//   If the allocation size is greater than
			//   zero we create the allocations.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
				//
				//   We have got a request for an element size
				//   larger than the largest bucket size.  So 
				//   we call the single allocation interface 
				//   as this supports large sizes.
				//
				for 
					( 
					/* void */;
					((*Actual) < Requested)
						&&
					((Array[ (*Actual) ] = New( Size )) != AllocationFailure);
					(*Actual) ++ 
					);

				//
				//   If needed return the actual amount of space 
				//   allocated for each element.
				//
				if ( Space != NULL )
					{ (*Space) = Size; }

				return ((*Actual) == Requested);
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We have been asked to allocate some memory.  Hopefully,        */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket.                                                        */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::New( SBIT32 Size,SBIT32 *Space,BOOLEAN Zero )
	{
	REGISTER VOID *NewMemory = ((VOID*) AllocationFailure);

	//
	//   Although normally a class is never called before
	//   its constructor. The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We ensure the allocation size is in
		//   the range supported by the heap.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] ++;
#endif

			//
			//   Allocate memory from the appropriate
			//   cache in the heap.
			//
			NewMemory = (Cache -> New()); 
			Size = (Cache -> GetAllocationSize());
			}
		else
			{ 
			//
			//   If the allocation size is greater than
			//   zero we create the allocation.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the allocation statistics.
				//
				if ( Size > MaxNewSize )
					{ MaxNewSize = Size; }

				NewMisses ++;
				TotalNewSize += Size;

#endif
				//
				//   Allocate memory from a special
				//   cache bucket which gets space
				//   externally.
				//
				NewMemory = (ExternalCache -> New( False,Size ));
				}
			else
				{ NewMemory = ((VOID*) AllocationFailure); }
			}

		//
		//   We need to be sure that the allocation 
		//   request did not fail.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   If needed return the actual amount of space 
			//   allocated for this request.
			//
			if ( Space != NULL )
				{ (*Space) = Size; }

			//
			//   Zero the memory if the needed.
			//
			if ( Zero )
				{ ZeroMemory( NewMemory,Size ); }
			}
		}

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Print statistics.                                              */
    /*                                                                  */
    /*   We output the allocation statistics to the debug console.      */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::PrintDebugStatistics( VOID )
	{
	REGISTER HANDLE Semaphore;
	
	//
	//   As we may have multiple heaps executing there 
	//   destructors at the same time we create a semaphore
	//   to prevent multiple threads producing output at
	//   the same time.
	//
	if ( (Semaphore = CreateSemaphore( NULL,1,MaxCpus,"Print" )) != NULL)
        {
		//
		//   Wait for the global semaphore.
		//
		if 
				( 
				WaitForSingleObject( Semaphore,INFINITE ) 
					== 
				WAIT_OBJECT_0 
				)
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 CurrentSize = 0;
			REGISTER SBIT32 GrandTotal = 0;
			REGISTER SBIT32 HighWater = 0;
			REGISTER SBIT32 Total = 0;

			//
			//   Output the titles to the debug console.
			//
			DebugPrint
				( 
				"\n"
				"  Original    New      Bucket    High   "
				"   Cache    Cache     Partial    Grand\n" 
				"    Size    Allocs      Size     Water  "
				"   Fills   Flushes     Total     Total\n"
				);

			//
			//   Output details for every sample size.
			//
			for ( Count=0;Count < MaxCacheSize;Count ++ )
				{
				REGISTER SBIT32 Hits = Statistics[ Count ]; 

				//
				//   Skip the sample if there are no hits.
				//
				if ( Hits > 0 )
					{
					REGISTER CACHE *Cache = FindCache( (Count+1) );
					REGISTER SBIT32 CacheSize = Cache -> GetAllocationSize();

					//
					//   Zero the running totals at the end
					//   of each bucket.
					//
					if ( CurrentSize != CacheSize )
						{
						CurrentSize = CacheSize;
						Total = 0;

						DebugPrint
							( 
							"----------------------------------------"
							"--------------------------------------\n" 
							);
						}

					//
					//   Compute and output the totals.
					//
					if ( Total == 0)
						{ HighWater += (Cache -> GetHighWater() * CacheSize); }

					Total += Hits;
					GrandTotal += Hits;

					DebugPrint
						(
						"%8d  %8d  %8d  %8d  %8d  %8d  %8d  %8d\n",
						(Count + 1),
						Hits,
						CacheSize,
						Cache -> GetHighWater(),
						Cache -> GetCacheFills(),
						Cache -> GetCacheFlushes(),
						Total,
						GrandTotal
						); 
					}
				}

			//
			//   Print the hash table statistics.
			//
			DebugPrint( "\nHash Table Statistics" );
			DebugPrint( "\n---------------------\n" );

			DebugPrint
				(
				"\t*** Cache ***\n"
				"\tFills\t\t: %d\n\tHits\t\t: %d\n\tMisses\t\t: %d\n"
				"\t*** Table ***\n"
				"\tAverage\t\t: %d\n\tMax\t\t: %d\n\tScans\t\t: %d\n"
				"\tMax Hash\t: %d\n\tMax LookAside\t: %d\n\tUsage\t\t: %d%%\n",
				Find -> CacheFills(),
				Find -> CacheHits(),
				Find -> CacheMisses(),
				Find -> AverageHashLength(),
				Find -> MaxHashLength(),
				Find -> TotalScans(),
				Find -> MaxHashSize(),
				Find -> MaxLookAsideSize(),
				Find -> MaxUsage()
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nOversize Statistics" );
			DebugPrint( "\n-------------------\n" );

			DebugPrint
				(
				"\tAverage Size\t: %d\n\tMax Size\t: %d\n\tMisses\t\t: %d\n",
				(TotalNewSize / ((NewMisses > 0) ? NewMisses : 1)),
				MaxNewSize,
				NewMisses
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nRealloc Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tAverage Copy\t: %d\n\tCalls\t\t: %d\n\tMax Copy\t: %d\n"
				"\tTotal Copies\t: %d\n",
				(TotalCopySize / ((CopyMisses > 0) ? CopyMisses : 1)),
				Reallocations,
				MaxCopySize,
				CopyMisses
				);

			//
			//   Print the general statistics.
			//
			DebugPrint( "\nSummary Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tHigh Water\t: %d\n",
				HighWater
				);
			}
		else
			{ Failure( "Sleep failed in PrintDebugStatistics" ); }

		//
		//   Release the global semaphore.
		//
		ReleaseSemaphore( Semaphore,1,NULL );

		CloseHandle( Semaphore );
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We have been asked to reallocate some memory.  Hopefully,      */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket, do a copy and free the orginal allocation.             */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::Resize
		( 
		VOID						  *Address,
		SBIT32						  NewSize,
		SBIT32						  Move,
		SBIT32						  *Space,
		BOOLEAN						  NoDelete,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Size;
		AUTO SBIT32 NewSpace;

		//
		//   Find the details of the existing allocation.
		//   If there is no existing allocation then exit.
		//
		if ( Details( Address,& Size ) )
			{
			REGISTER VOID *NewMemory;
			REGISTER SBIT32 Smallest = ((Size < NewSize) ? Size : NewSize);

			//
			//   Make sure the sizes appear to make sense.
			//
			if ( Smallest > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the statistics.
				//
				Reallocations ++;

#endif
				//
				//   When the new allocation allocation is 
				//   standard heap allocation size we check 
				//   for various optimizations.
				//
				if ( NewSize <= MaxCacheSize )
					{
					REGISTER CACHE *Cache = (FindCache( NewSize ));
					REGISTER SBIT32 CacheSize = (Cache -> GetAllocationSize());
					REGISTER SBIT32 Delta = (CacheSize - Size);
					
					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   We need to allocate some more
						//   memory and copy the old data.
						//   into the new area.
						//
						NewMemory = (Cache -> New());
						NewSpace = CacheSize;
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the statistics.
						//
						Statistics[ (NewSize-1) ] ++;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				else
					{
					REGISTER SBIT32 Delta = (NewSize - Size);

					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   One of the sizes is not within the
						//   allocation range of the heap.  So
						//   I have to punt and reallocate.
						//   
						NewMemory = 
							(
							ExternalCache -> New
								( 
								False,
								(NewSpace = NewSize)
								)
							);
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the allocation statistics.
						//
						if ( NewSize > MaxNewSize )
							{ MaxNewSize = NewSize; }

						NewMisses ++;
						TotalNewSize += NewSize;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				
				//
				//   We need to make sure we were able to allocate
				//   the new memory otherwise the copy will fail.
				//
				if ( NewMemory != ((VOID*) AllocationFailure) )
					{
					//
					//   Copy the contents of the old allocation 
					//   to the new allocation.
					//
					memcpy
						( 
						((void*) NewMemory),
						((void*) Address),
						((int) Smallest) 
						);

					//
					//   If needed return the actual amount of  
					//   space allocated for this request.
					//
					if ( Space != NULL )
						{ (*Space) = NewSpace; }

					//
					//   Delete the old allocation unless we
					//   need to keep it around.
					//
					if ( ! NoDelete )
						{
						//
						//   Delete the old allocation.
						//
						if ( ! Delete( Address,Size ) )
							{ Failure( "Deleting allocation in Resize" ); }
						}

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 Difference = (NewSpace - Smallest);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) NewMemory);

							ZeroMemory( & Array[ Smallest ],Difference ); 
							} 
						}	
#ifdef ENABLE_HEAP_STATISTICS

					//
					//   Update the allocation statistics.
					//
					if ( Smallest > MaxCopySize )
						{ MaxCopySize = Smallest; }

					CopyMisses ++;
					TotalCopySize += Smallest;
#endif
					}

				return NewMemory;
				}
			}
		}

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This pretty much a do nothing   */
    /*   as we do this automatically anyway.  The only thing we can     */
    /*   do is free any space the user suggested keeping earlier.       */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Truncate( SBIT32 MaxFreeSpace )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Flush all the caches and to free up
		//   as much space as possible.
		//
		for ( Count=0;Count < CachesSize;Count ++ )
			{
			Result =
				(
				(Caches[ Count ] -> Truncate())
					&&
				(Result)
				); 
			}

		//
		//   We slave all available free space in the top
		//   bucket so force it to be released.
		//
		TopCache -> ReleaseSpace
			(
			(MaxFreeSpace / (TopCache -> GetAllocationSize()))
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We release the locks so others can use the heap.               */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::UnlockAll( BOOLEAN Partial )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   Decrement the per thread lock count.
		//
		Find -> DecrementLockCount();

		//
		//   We release the locks only if we have claimed 
		//   them earlier.
		//
		if ( (Find -> GetLockCount()) == 0 )
			{
			//
			//   Now release all the heap locks we claimed
			//   earlier and unfreeze the heap.
			//
			NewPage -> ReleaseNewPageLock();

			Find -> ReleaseFindExclusiveLock();

			//
			//   When we destroy the heap we hold on
			//   to the cache locks to prevent errors.
			//
			if ( ! Partial )
				{
				REGISTER SBIT32 Count;

				//
				//   Now release all the cache locks we claimed
				//   earlier and unfreeze the cache.
				//
				for ( Count=0;Count < CachesSize;Count ++ )
					{ Caches[ Count ] -> ReleaseCacheLock(); }
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify of a memory allocation.                                 */
    /*                                                                  */
    /*   We need to verify the details of a memory allocation.          */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.  Finally, we check that the element       */
    /*   is not in the cache waiting to be allocated or freed.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Verify( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SEARCH_PAGE Details;
		AUTO SBIT32 NewSize;

		//
		//   We extract the size of the allocation and  
		//   any associated allocation information.
		//   to see if it is present.
		//
		if ( Find -> Details( Address,& Details,TopCache,& NewSize ) )
			{
			//
			//   We need to be careful to make sure this 
			//   element is actually allocated.
			//
			if ( Details.Found )
				{
				//
				//   We know that the element appears to be 
				//   allocated but it may be in the cache
				//   somewhere so ensure this is not the case.
				//
				if ( (NewSize > 0) && (NewSize <= MaxCacheSize) )
					{
					if ( Details.Cache -> SearchCache( Address ) )
						{ return False; }
					}

				//
				//   We have shown that the element is active
				//   so return the size if requested.
				//
				if ( Size != NULL )
					{ (*Size) = NewSize; }

				return True;
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		SBIT32						  *Size 
		)
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We walk the heap and find the next allocation
		//   along with some basic information.
		//
		if ( Find -> Walk( Active,Address,TopCache,Size ) )
			{
			//
			//   We know that the element appears to be 
			//   allocated but it may be in the cache
			//   somewhere so ensure this is not the case.
			//
			if ( ((*Size) > 0) && ((*Size) <= MaxCacheSize) )
				{
				if ( FindCache( (*Size) ) -> SearchCache( (*Address) ) )
					{ (*Active) = False; }
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   We would like to destroy the heap at the end of the run        */
    /*   just to be tidy.  However, to do this we need to know that     */
    /*   all of the other destructors have been called and that the     */
    /*   application will not request more memory or use any existing   */
    /*   allocations.  We can't know this without help from the         */
    /*   compiler and OS.                                               */
    /*                                                                  */
    /********************************************************************/

HEAP::~HEAP( VOID )
	{
	REGISTER SBIT32 Count;

	//
	//   We mark the heap as inactive.
	//
	Active = False;

	//
	//   We claim all of the heap locks to freeze
	//   all new allocations or deletions.
	//
	LockAll();

	//
	//   Now reset all the caches.
	//
	for ( Count=0;Count < CachesSize;Count ++ )
		{ Caches[ Count ] -> DeleteAll(); }

	//
	//   Delete the heap.
	//
	NewPage -> DeleteAll( False );

	//
	//   We release any of the shared locks we 
	//   cliamed earlier.
	//
	UnlockAll( True );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Deal with heap statistics.
	//
	if ( Statistics != NULL ) 
		{
		//
		//   Print all the statistics.
		//
		PrintDebugStatistics();

		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) Statistics),
			(MaxCacheSize * sizeof(SBIT32)),
			False
			); 
		}
#endif

	//
	//   Delete the heap mapping tables.
	//
	if ( SizeToCache1 != NULL ) 
		{ 	
		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) SizeToCache1),
			(MaxTable1 + MaxTable2),
			False
			); 
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\heappch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\newpagelist.hpp ===
#ifndef _NEW_PAGE_LIST_HPP_
#define _NEW_PAGE_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "FindList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The new page list.                                             */
    /*                                                                  */
    /*   The new page list links all the memory allocated by the low    */
    /*   level external allocator, or sub-divided pages or free pages   */
    /*   so they can be quickly found.                                  */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE_LIST : public FIND_LIST
    {
		//
		//   Private data.
		//
 		LIST						  NewPageList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        NEW_PAGE_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromNewPageList( LIST *HeadOfList )
			{ NewPageList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfNewPageList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInNewPageList( LIST *HeadOfList )
			{ NewPageList.Insert( HeadOfList ); }

		STATIC INLINE PAGE *LastInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> Last()) ); }

		INLINE PAGE *NextInNewPageList( VOID )
			{ return ComputePageAddress( ((CHAR*) NewPageList.Next()) ); }

        ~NEW_PAGE_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(FIND_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE_LIST( CONST NEW_PAGE_LIST & Copy );

        VOID operator=( CONST NEW_PAGE_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\page.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here allow the allocation bit vector    */
    /*   to be rapidly searched for free storage.                       */
    /*                                                                  */
    /********************************************************************/

CONST BIT32 AllocatedMask			  = 0x2;
CONST BIT32 FullSearchMask			  = 0xaaaaaaaa;
CONST BIT32 FullWordShift			  = (MaxBitsPerWord - OverheadBits);
CONST BIT32 SubDividedMask			  = 0x1;
CONST BIT32 WordSearchMask			  = (AllocatedMask << FullWordShift);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*                                                                  */
    /*   All page descriptions are actually created and deleted by      */
    /*   a separate class called 'NEW_PAGE'.  Nonetheless, as a         */
    /*   step the appropriate constructors and destructors are          */
    /*   invoked to support the standard C++ programming methodology.   */
    /*                                                                  */
    /********************************************************************/

PAGE::PAGE
		( 
		VOID						  *NewAddress,
		CACHE						  *NewCache,
		SBIT32						  NewPageSize, 
		CACHE						  *NewParentPage,
		SBIT32						  NewVersion 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER SBIT16 NumberOfElements = (NewCache -> GetNumberOfElements());
	REGISTER SBIT16 SizeOfElements = (NewCache -> GetSizeOfElements());

	//
	//   Create a page description.
	//
	Address = (CHAR*) NewAddress;
	PageSize = NewPageSize;
	Version = NewVersion;

	Allocated = 0;
	Available = NumberOfElements;
	FirstFree = 0;

	//
	//   Set up the pointers to related classes.
	//
	Cache = NewCache;
	ParentPage = NewParentPage;

	//
	//   Zero the bit vector.
	//
	for ( Count=0;Count < SizeOfElements;Count ++ )
		{ Vector[ Count ] = 0; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the actual size.                                       */
    /*                                                                  */
    /*   Almost all allocation sizes are derived from the associated    */
    /*   caches.  However, there are a few special pages that contain   */
    /*   a single allocation of some weird size.                        */
    /*                                                                  */
    /********************************************************************/

SBIT32 PAGE::ActualSize( VOID )
	{
	return
		(
		(ParentPage == ((CACHE*) GlobalRoot))
			? PageSize
			: (Cache -> GetAllocationSize())
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete an allocation.                                          */
    /*                                                                  */
    /*   We need to delete the memory allocation described by the       */
    /*   parameters.  However, as we are of an untrusting nature        */
    /*   we carefully check the request to ensure it is valid.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Delete( SEARCH_PAGE *Details )
    {
	//
	//   We know that no one would deallocate memory
	//   they had not previously allocated (yea - right).
	//   So here we check for this case.
	//
	if ( (*Details -> VectorWord) & Details -> AllocationMask )
		{
		//
		//   Nasty: it is possible for the user to give us an
		//   address that points to the middle of the element
		//   to be freed instead of the beginning.  This is no
		//   problem for us but we have to ponder whether the
		//   caller knew what they were doing.  If this is the 
		//   case we fail the request.
		//
		if ( Details -> Found )
			{
			//
			//   We have found that the element is allocated
			//   (as one might expect) so lets deallocate it 
			//   and update the various counters.
			//
			(*Details -> VectorWord) &= 
				~(Details -> AllocationMask | Details ->SubDivisionMask);

			//
			//   We may need to push back the pointer to the 
			//   first free element.  This will ensure that
			//   we can quickly locate the freed element for  
			//   later so we can reuse it.
			//
			if ( FirstFree > Details -> VectorOffset )
				{ FirstFree = ((SBIT16) Details -> VectorOffset); }

			//
			//   If the page was full and now has an empty
			//   slot then add it to the bucket list so that
			//   the free space can be found.
			//
			if ( Full() )
				{ Cache -> InsertInBucketList( this ); }

			//
			//   Update the allocation information.
			//
			Allocated --;
			Available ++;

			//
			//   If the page is now empty then delete 
			//   the page to conserve space.
			//
			if ( Empty() ) 
				{
				//
				//   We immediately delete empty pages
				//   except at the top level where it is
				//   under user control.
				//
				if ( ! Cache -> TopCache() )
					{ Cache -> DeletePage( this ); }
				else
					{
					REGISTER SBIT32 MaxFreePages = 
						(Cache -> GetHeap() -> GetMaxFreePages());

					((BUCKET*) Cache) -> ReleaseSpace( MaxFreePages );
					}
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete all simple allocations.                                 */
    /*                                                                  */
    /*   Although this routine may seem insignificant its effects are   */
    /*   dramatic.  When called this function deletes all the none      */
    /*   sub-allocated elements and updates the control values.         */
    /*                                                                  */
    /********************************************************************/

VOID PAGE::DeleteAll( VOID )
    {
	REGISTER BOOLEAN PageFull = Full();

	//
	//   Simply reset the allocation counts.
	//
	Allocated = 0;
	Available = (Cache -> GetNumberOfElements());
	FirstFree = 0;

	//
	//   We know that if this cache does not have any
	//   child allocations that it is safe to simply
	//   zero the bit vector.  If not we have to do it
	//   the long way.
	//
	if ( Cache -> GetNumberOfChildren() > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   We examine each word of the bit vector 
		//   and delete all the elements that are
		//   not sub-divided into smaller sizes.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{
			REGISTER BIT32 *Word = & Vector[ Count ];
			REGISTER BIT32 AllAllocations = ((*Word) & FullSearchMask);
			REGISTER BIT32 AllSubDivided = ((*Word) & (AllAllocations >> 1));
			REGISTER BIT32 FinalMask = (AllSubDivided | (AllSubDivided << 1));

			//
			//   Delete all normal allocations.
			//
			(*Word) &= FinalMask;

			//
			//   If the final mask is not zero then
			//   we still have some allocations active.
			//   We need to count these and update the
			//   control information.
			//
			if ( FinalMask != 0 )
				{
				REGISTER SBIT32 Total = 0;

				//
				//   Count the allocations.
				//
				for ( /* void */;FinalMask != 0;FinalMask >>= OverheadBits )
					{ Total += (FinalMask & 1); }

				//
				//   Update the control information.
				//
				Allocated = ((SBIT16) (Allocated + Total));
				Available = ((SBIT16) (Available - Total));
				}
			}
		}
	else
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Zero the bit vector.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{ Vector[ Count ] = 0; }
		}

	//
	//   If the page was full and now has empty
	//   slots then add it to the bucket list so 
	//   that the free space can be found.
	//
	if ( (PageFull) && (! Full()) )
		{ Cache -> InsertInBucketList( this ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find an allocation page.                                       */
    /*                                                                  */
    /*   When we receive a request to delete an allocation we don't     */
    /*   have a clue about where to find it.  All we have is a hash     */
    /*   table (see 'FIND') of allocated pages.  So we mask off the     */
    /*   low order bits of the address and try to find the top level    */
    /*   external allocation.  If this works we see if the area we      */
    /*   are looking at has been sub-divided and if so we try the       */
    /*   same trick again until we get the the origibal allocation      */
    /*   page.                                                          */
    /*                                                                  */
    /********************************************************************/

PAGE *PAGE::FindPage( VOID *Memory,SEARCH_PAGE *Details,BOOLEAN Recursive )
    {
	//
	//   We navigate through the pages trying to find
	//   the allocation page associated with the address.
	//   If we find a page that has no children then 
	//   we can assume we have arrived and exit early 
	//   unless the caller has requested all the realated 
	//   details.
	//
	if ( (Cache -> GetNumberOfChildren() > 0) || (Details != NULL) )
		{
		AUTO BOOLEAN Found;
		REGISTER SBIT32 Displacement = 
			((SBIT32) (((CHAR*) Memory) - Address));
		REGISTER SBIT32 ArrayOffset = 
			(Cache -> ComputeOffset( Displacement,& Found ));
		REGISTER SBIT32 VectorOffset = 
			(ArrayOffset / OverheadBitsPerWord);
		REGISTER SBIT32 WordOffset = 
			(ArrayOffset - (VectorOffset * OverheadBitsPerWord));
		REGISTER SBIT32 WordShift = 
			(((OverheadBitsPerWord-1) - WordOffset) * OverheadBits);
		REGISTER BIT32 AllocationMask = 
			(AllocatedMask << WordShift);
		REGISTER BIT32 SubDivisionMask = 
			(SubDividedMask << WordShift);
		REGISTER BIT32 *VectorWord = 
			& Vector[ VectorOffset ];

		//
		//  We will recursively search and find the target 
		//  address if requested otherwise we will just 
		//  return the details of the next level in the tree.
		//
		if 
				(
				(Recursive)
					&&
				((*VectorWord) & AllocationMask)
					&&
				((*VectorWord) & SubDivisionMask)
				)
			{
			REGISTER PAGE *Page = (Cache -> FindChildPage( Memory ));

			//
			//   We have found the element and checked it. 
			//   So lets pass this request on to the
			//   child page.  However, there is a slight
			//   chance of a race condition here.  It
			//   might be that the original page was
			//   deleted and a new page is currently
			//   being created.  If this is the case
			//   then we will not find the page in the 
			//   hash table so we just exit and fail the 
			//   call.
			//
			if ( Page != ((PAGE*) NULL) )
				{ return (Page -> FindPage( Memory,Details,Recursive )); }
			else
				{ return NULL; }
			}

		//
		//   We see if the caller is interested in the
		//   details relating to this address at the
		//   current level in the tree.
		//
		if ( Details != NULL )
			{
			//
			//   We have computed the details relating
			//   to this address at the current level
			//   in the tree so load them into the
			//   caller supplied structure.
			//
			Details -> Address = Memory;
			Details -> Cache = Cache;
			Details -> Found = Found;
			Details -> Page = this;

			Details -> AllocationMask = AllocationMask;
			Details -> SubDivisionMask = SubDivisionMask;
			Details -> VectorWord = VectorWord;

			Details -> ArrayOffset = ArrayOffset;
			Details -> VectorOffset = VectorOffset;
			Details -> WordShift = WordShift;
			}
		}

	return this;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate available memeory elements from a page.  This is      */
    /*   done by scanning the bit vector looking for unallocated        */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate and that we need to
	//   allocated at least one element.
	//
	if ( (! Full()) && ((*Actual) < Requested) )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slots.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER SBIT32 ArrayOffset = (FirstFree * OverheadBitsPerWord);
			REGISTER BIT32 AvailableMask = WordSearchMask;
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];
			REGISTER SBIT32 WordOffset = 0;

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			while ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 Value = (*VectorWord);

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = (ArrayOffset + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bits indicating that this
						//   element is in use.
						//
						(*VectorWord) |= AvailableMask;

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Add the element to the allocation array
						//   so it can be returned to the caller.
						//
						Array[ (Requested - ((*Actual) ++) - 1) ] =
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);

						//
						//   When we have got what we need we exit.
						//
						if ( ((*Actual) >= Requested) )
							{ return True; }
						}
					else
						{ break; }
					}
				else
					{ Failure( "Bit vector is corrupt in MultipleNew" ); }
				}
			}
		}

	return ((*Actual) >= Requested);
    }

    /********************************************************************/
    /*                                                                  */
    /*   A single memory allocation.                                    */
    /*                                                                  */
    /*   Allocate an available memeory element from the page.  This     */
    /*   is done by scanning the bit vector looking for unallocated     */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

VOID *PAGE::New( BOOLEAN SubDivided )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate.
	//
	if ( ! Full() )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slot.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			if ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 AvailableMask = WordSearchMask;
				REGISTER BIT32 Value = (*VectorWord);
				REGISTER SBIT32 WordOffset = 0;

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = 
						((FirstFree * OverheadBitsPerWord) + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bit indicating that this
						//   element is in use.  If the allocation 
						//   is to be sub-divided then trun on this
						//   bit as well.
						//
						(*VectorWord) |=
							(
							AvailableMask
								|
							(SubDivided ? (AvailableMask >> 1) : 0)
							);

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Return the address of the allocated 
						//   memory to the caller.
						//
						return
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);
						}
					}
				else
					{ Failure( "Bit vector is corrupt in New" ); }
				}
			}
#ifdef DEBUGGING

		if ( ! Full() )
			{ Failure( "Available count corrupt in New" ); }
#endif
		}

	return ((VOID*) AllocationFailure);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Walk( SEARCH_PAGE *Details )
    {
	REGISTER BOOLEAN FreshPage = False;

	//
	//   We have been handed the details of an allocation.
	//   We need to walk along this allocation and find
	//   the next non-subdivided allocation.
	do
		{
		//
		//   We need to setup the heap walk if the address
		//   is null so we skip the heap walk code.
		//
		if ( Details -> Address != NULL )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 End = Details -> Cache -> GetNumberOfElements();
			REGISTER SBIT32 Start = Details -> ArrayOffset;
			REGISTER PAGE *Page = Details -> Page;

			//
			//   Walk the current page looking for a suitable
			//   memory allocation to report to the user.  When
			//   we reach the end of the page we need to get
			//   another page to walk.
			//
			for 
					(
					Count = ((FreshPage) ? 0 : 1);
					(Start + Count) < End;
					Count ++
					)
				{
				//
				//   Compute the new address.
				//
				Details -> Address = 
					(
					Page -> Cache -> ComputeAddress
						( 
						Page -> Address,
						(Start + Count)
						)
					);

				//
				//   Compute the new allocation details.
				//
				Page -> FindPage
					( 
					Details -> Address,
					Details,
					False 
					);

				//
				//   We skip all sub-divided allocations as they 
				//   will get reported elsewhere.
				//
				if (! ((*Details -> VectorWord) & Details -> SubDivisionMask) )
					{ return True; }
				}
			}

		//
		//   Update the flag to show that we have
		//   had to go and get a new page.
		//
		FreshPage = True;
		}
	while ( Details -> Cache -> Walk( Details ) );

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current page structure.                            */
    /*                                                                  */
    /********************************************************************/

PAGE::~PAGE( VOID )
	{
#ifdef DEBUGGING
	//
	//   Destroy the page structure.
	//
	Address = NULL;
	PageSize = 0;
	ParentPage = NULL;

	Allocated = 0;
	Available = 0;
	FirstFree = 0;

#endif
	//
	//   We update the version number whenever a page is created
	//   or destroyed.  We use the version number to ensure that
	//   a page has not been deleteed and/or recreated between
	//   releasing one lock and claiming a another other lock.
	//
	Version ++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\blendedheap.hpp ===
#ifndef _BLENDED_HEAP_HPP_
#define _BLENDED_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A blended heap.                                                */
    /*                                                                  */
    /*   A blended heap tries to provide good performance and           */
    /*   thoughtfull memory layout for a modest cost in terms of        */
    /*   additional memory usage.                                       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE BLENDED_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        BLENDED_HEAP
			( 
			int						  MaxFreeSpace = 1048576,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~BLENDED_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BLENDED_HEAP( const BLENDED_HEAP & Copy );

        void operator=( const BLENDED_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\blendedheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "BlendedHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 4096;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 2048;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,       64,       32,      512 },
		{        8,       32,       32,      512 },
		{       12,       32,       64,      512 },
		{       16,       16,       64,      512 },
		{       20,       16,       64,      512 },
		{       24,       12,       96,      512 },

		{       32,       12,      128,      512 },
		{       40,        8,      128,      512 },
		{       48,        8,      256,      512 },

		{       64,        8,      256,      512 },
		{       80,        4,      512,      512 },
		{       96,        4,      512,      512 },

		{      128,        4,     4096,     4096 },
		{      160,        4,     4096,     4096 },
		{      192,        4,     4096,     4096 },
		{      224,        4,     4096,     4096 },

		{      256,        4,     4096,     4096 },
		{      320,        2,     4096,     4096 },
		{      384,        2,     4096,     4096 },
		{      448,        2,     4096,     4096 },
		{      512,        2,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        2,     4096,     4096 },
		{     2048,        2,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,    65536,    65536 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::BLENDED_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::~BLENDED_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\page.hpp ===
#ifndef _PAGE_HPP_
#define _PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "NewPageList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control the number of bits in      */
    /*   a page descriptions bit vector and its minimum size.           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxBitsPerWord			  = (sizeof(BIT32) * 8);
CONST SBIT32 MinVectorSize			  = 1;
CONST SBIT32 OverheadBits			  = 2;
CONST SBIT32 OverheadBitsPerWord	  = (MaxBitsPerWord / OverheadBits);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   The page descriptions supported by this class are at the       */
    /*   heart of the memory allocator.  These pages are linked in      */
    /*   various ways so they can be quickly found.  The following      */
    /*   structure contains the results of a search for a specific      */
    /*   memory address and its related page information.               */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	CACHE							  *Cache;
	BOOLEAN							  Found;
	PAGE							  *Page;

	BIT32							  AllocationMask;
	BIT32							  SubDivisionMask;
	BIT32							  *VectorWord;

	SBIT32							  ArrayOffset;
	SBIT32							  VectorOffset;
	SBIT32							  WordShift;
	}
SEARCH_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The page allocation mechanism.                                 */
    /*                                                                  */
    /*   The memory manager allocates storage in large chunks from      */
    /*   the external memory allocator.  It then sub-divides these      */
    /*   chunks into various sized pages and keeps track of these       */
    /*   allocations using a bit vector in each page description.       */
    /*                                                                  */
    /********************************************************************/

class PAGE : public NEW_PAGE_LIST
    {
		//
		//   Private data.
		//
		//   The page description contains various details
		//   about the page.  The 'Address' is the starting 
		//   address of the allocation page.  The 'PageSize'
		//   is typically empty but contains a value is the 
		//   page size is weird and not realted to the
		//   assocated bucket.  The 'Version' is a unique
		//   version number and is changed everytime a new
		//   page description is created or deleted.  This
		//   version number allows a thread to see if anyone
		//   has been significantly playing with a page  
		//   description since it last held the associated lock.
		//
		CHAR                          *Address;
		SBIT32						  PageSize;
		SBIT32						  Version;

		//
		//   We keep track of the number of elements that
		//   are currently 'Allocated' and 'Available' on
		//   the page.  Additionally, 'FirstFree' is the
		//   index of the first word in the bit vector that
		//   has at least one available slot.
		//
		SBIT16                        Allocated;
		SBIT16                        Available;
		SBIT16						  FirstFree;

		//
		//   We sometimes need to interact with other classes.
		//   The 'Cache' class typically owns a number of pages
		//   and keeps all the information about this size of
		//   allocation.  The 'ParentPage' is a pointer to 
		//   another cache from where this page was sub-allocated
		//   and where the space will need to be returned when
		//   it becomes free.
		//
		CACHE						  *Cache;
		CACHE						  *ParentPage;

		//
		//   The 'Vector' is the variable sized bit vector that
		//   contains allocation information.  Each allocation
		//   is recorded using 2 bits.  The first bit indicates
		//   whether the allocation is in use and the second bit
		//   indicates whether an active allocation has been 
		//   sub-divided into smaller chunks.  Any unused bits
		//   at the end of the final word are set to zero, assumed
		//   to be zero and should never be non-zero.
		//
		BIT32                         Vector[MinVectorSize];

   public:
		//
		//   Public functions.
		//
		//   The page description contains all the information
		//   relating to an allocation.  There is no information
		//   stored with the allocation itself.  A significant
		//   portion of the external API can find its way to
		//   this class if the many layers of caches fail to
		//   deal with the request first.
		//
        PAGE
			( 
			VOID					  *NewAddress,
			CACHE					  *NewCache,
			SBIT32					  NewPageSize,
			CACHE					  *NewParentPage,
			SBIT32					  NewVersion 
			);

		SBIT32 ActualSize( VOID );

		BOOLEAN Delete( SEARCH_PAGE *Details );

		VOID DeleteAll( VOID );

		PAGE *FindPage
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			BOOLEAN					  Recursive 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Available, 
			VOID					  *Array[],
			SBIT32					  Requested
			);

		VOID *New( BOOLEAN SubDivided );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The page class is so central to the entire memory
		//   allocator that a number of other classes need to
		//   get at certain data from time to time.  Thus, it 
		//   is necessary for both brevity and performance to
		//   provide inline function for certain critical 
		//   information relating to a page.
		//
		INLINE BOOLEAN Empty( VOID )
			{ return (Allocated <= 0); }

		INLINE BOOLEAN Full( VOID )
			{ return (Available <= 0); }

		INLINE VOID *GetAddress( VOID )
			{ return ((VOID*) Address); }

		INLINE CACHE *GetCache( VOID )
			{ return Cache; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE CACHE *GetParentPage( VOID )
			{ return ParentPage; }

		INLINE SBIT32 GetVersion( VOID )
			{ return Version; }

		INLINE BOOLEAN ValidPage( VOID )
			{ return ((BOOLEAN) ~(Version & 0x1)); }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE( CONST PAGE & Copy );

        VOID operator=( CONST PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\heap\newpage.hpp ===
#ifndef _NEW_PAGE_HPP_
#define _NEW_PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Page.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here relate to various failure          */
    /*   conditions or situations where information is unknown.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 NoSizeKey				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Create and delete pages.                                       */
    /*                                                                  */
    /*   We would normally expect a class to manage its own memory.     */
    /*   However, this is quite difficult for the 'PAGE' class as it    */
    /*   is also responsible for managing the memory for the memory     */
    /*   allocator.  So here we remove a potentially nasty chore        */
    /*   and isolate it in a class of its own.                          */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE : public ENVIRONMENT, public COMMON
    {
		//
		//   Private structures.
		//
		//   All the pages descriptions created by this
		//   class and managed by the memory allocator
		//   are linked in three list.  One of these lists
		//   is managed by this class and is called the
		//   'NewPageList'.  All pages are linked into 
		//   of three sub-lists.  The 'ExternalList' is
		//   a list of pages externally allocated pages.
		//   The 'FullList' is a list of sub-allocated
		//   space from the 'ExternalList' which is 
		//   partially or completely filled with alocations.
		//   Finally, the 'FreeList' is a collection of
		//   empty page descriptions all of the same size.
		//   
		//
		typedef struct
			{
			SBIT32                    Elements;
			LIST					  ExternalList;
			LIST					  FreeList;
			LIST					  FullList;
			SBIT32                    Size;
			}
		NEW_PAGES;
		
		//
		//   Private data.
		//
		//   We manage a collection of data structures in
		//   this class.  The fundamental data structure
		//   is a stack of externally allocated pages that
		//   typically contain page descriptions that are
		//   linked together into linked lists.  The maximum
		//   size of this stack is given by 'MaxStack'. 
		//   A few additional pages are consumed to allocate
		//   stacks for caches in other classes.
		//
		SBIT32						  MaxCacheStack;
		SBIT32						  MaxNewPages;
		SBIT32						  MaxStack;

		//
		//   We keep track of various values to save having
		//   to recompute them.  The 'NaturalSize' is the 
		//   natural allocation size of our host (i.e. the OS).
		//   The 'RootSize' is some multiple of the 
		//   'NaturalSize' that this class uses to consume 
		//   memory.  The 'ThreadSafe' flag indicates whether
		//   we need to use locks.  The "TopOfStack' is the
		//   stack which contains pointers to the externally
		//   allocated space.  The 'Version' is the global
		//   version number that is used to stamp each page
		//   whenever it is allocated or deallocated.  The
		//   version number allows the code to ensure that
		//   a page description has not been changed while
		//   it was not holding the associated lock.
		//   
		SBIT32						  NaturalSize;
		SBIT32						  RootCoreSize;
		SBIT32						  RootStackSize;
		BOOLEAN						  ThreadSafe;
		SBIT32						  TopOfStack;
		SBIT32						  Version;

		//
		//   We keep pointers to all the interesting data
		//   structures we may need to update.  The
		//   'CacheStack' points to block of memory that
		//   is being sliced into small stacks for caches
		//   in other classes.  The 'NewPages' points to
		//   an array of linked lists of page descriptions.
		//   Each collection of page descriptions is 
		//   identical except for the size of the assocated
		//   bit vector.
		//
		CHAR						  *CacheStack;
 		NEW_PAGES					  *NewPages;
		VOID                          **Stack;

		//
		//   We sometimes need to interact with some of
		//   the other class.  The 'Find" class is a hash
		//   table of all the currently allocated pages.
		//   The 'Rockall' class contains the external
		//   API which includes the external memory memory
		//   allocation functions.  The 'TopCache' is the
		//   largest cache we support and contains details
		//   about top level allocations sizes.
		//
		FIND						  *Find;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;

		SPINLOCK                      Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The public functions provide support for creating
		//   new page descriptions and caches for other 
		//   classes.  Although a lot of the fuinctionality
		//   of the heap is masked from this class various
		//   features such as deleting the entire heap
		//   (i.e. 'DeleteAll') are still visable.
		//
        NEW_PAGE
			(
			FIND					  *NewFind,
			SBIT32					  NewPageSizes[],
			ROCKALL					  *NewRockall,
			SBIT32					  Size,
			BOOLEAN					  NewThreadSafe 
			);

		PAGE *CreatePage( CACHE *Cache,SBIT32 NewSize = NoSize );

		VOID DeleteAll( BOOLEAN Recycle );

		VOID DeletePage( PAGE *Page );

		SBIT16 FindSizeKey( SBIT16 NumberOfElements );

		VOID *NewCacheStack( SBIT32 Size  );

		VOID ResizeStack( VOID );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~NEW_PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The public inline functions are typically either
		//   small or highly performance sensitive.  The
		//   functions here mainly relate to locking and
		//   updating various data structures.
		//
		INLINE VOID ClaimNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE VOID ReleaseNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE VOID UpdateNewPage( CACHE *NewTopCache )
			{ TopCache = NewTopCache; }

	private:
		//
		//   Private functions.
		//
		//   We support the overloading of the external
		//   memory allocation routines.  This is somewhat
		//   unusual and means that we need to verify
		//   that these functions do not supply us with
		//   total rubbish.
		//
		VOID *VerifyNewArea( SBIT32 AlignMask,SBIT32 Size );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE( CONST NEW_PAGE & Copy );

        VOID operator=( CONST NEW_PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Size;
			int						  StartGuard;
			}
		DEBUG_HEADER;

		typedef struct
			{
			char					  MidGuard[ sizeof(int) ];
			int						  EndGuard[1];
			}
		DEBUG_TRAILER;

		typedef struct
			{
			DEBUG_HEADER			  DebugHeader;
			DEBUG_TRAILER			  DebugTrailer;
			}
		DEBUG_GUARD;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void HeapLeaks( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~DEBUG_HEAP( void );

	private:
		//
		//   Private functions.
		//
		//   A debug heap verifies each allocation using a 
		//   collection of private functions.
		//
		DEBUG_HEADER *ComputeHeaderAddress( void *Address )
			{
			register int HeaderSize = sizeof(DEBUG_HEADER);

			return ((DEBUG_HEADER*) (((char*) Address) - HeaderSize)); 
			}

		void *ComputeDataAddress( DEBUG_HEADER *Header )
			{ return ((void*) & Header[1]); }

		void ResetGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

		void TestGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\debugheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DebugHeap.hpp"
#include "Heap.hpp"

void Failure( char* a);

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

CONST int GuardMask					  = (sizeof(int)-1);
CONST int GuardSize					  = sizeof(int);

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We make much use of the guard value in the
	//   debug heap so here we try to claim the 
	//   address but not commit it so we will cause
	//   an access violation if the program ever
	//   tries to access it.
	//
	VirtualAlloc
		( 
		((void*) GuardValue),
		GuardSize,
		MEM_RESERVE,
		PAGE_NOACCESS 
		);

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap initialization failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We make sure the memory is allocated and that the guard        */
    /*   words have not been damanged.  If so we reset the contents     */
    /*   of the allocation and delete the allocation.                   */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Delete( void *Address,int Size )
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to delete
	//   a null pointer.  This is really a very poor  
	//   style but we support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
			{
			REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Delete the allocation.  This really ought 
			//   to work given we have already checked that 
			//   the allocation is valid unless there is a  
			//   race condition.
			//
			if ( ! ROCKALL::Delete( ((void*) Header),NewSize ) )
				{ Failure( "Delete requested failed due to race" ); }

			//
			//   We ensure that the heap has not become corrupt
			//   during the deletion process.
			//
			if ( ROCKALL::Corrupt() ) 
				{ Failure( "Delete failed to complete" ); }
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::DeleteAll( bool Recycle )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   Delete the heap and force all the allocated
	//   memory to be returned to the operating system
	//   regardless of what the user requested.  Any
	//   attempt to access the deallocated memory will 
	//   be trapped by the operating system.
	//
	ROCKALL::DeleteAll( (Recycle && false) );

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "DeleteAll failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Details( void *Address,int *Space )
	{ return Verify( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		CONST INT DebugBufferSize = 8192;
#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO CHAR Buffer[ DebugBufferSize ];

			//
			//   Format the string to be printed.
			//
			(void) sprintf
				(
				Buffer,
				"Memory leak \t%d \t0x%x \t%d\n",
				Active,
				(((SBIT32) Address) + sizeof(DEBUG_HEADER)),
				Space
				);

			//
			//   Force null termination.
			//
			Buffer[ (DebugBufferSize-1) ] = '\0';

			//
			//   Write the string to the debug window.
			//
			OutputDebugString( Buffer );
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   We make sure all the memory is allocated and that the guard    */
    /*   words have not been damaged.  If so we reset the contents      */
    /*   of the allocations and then delete all the allocations.        */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER int Count;
	REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

	//
	//   Examine each memory allocation and delete it
	//   after carefully checking it.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		AUTO int TotalSize;
		AUTO VOID *Address = Array[ Count ];
		AUTO DEBUG_HEADER *Header =
			(
			(Address == ((void*) AllocationFailure))
				? ((DEBUG_HEADER*) Address)
				: ComputeHeaderAddress( Address )
			);

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Update the address in the array to the
			//   address originally allocated.
			//
			Array[ Count ] = ((VOID*) Header);
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	//
	//   Delete the allocation.  This really ought 
	//   to work given we have already checked that 
	//   the allocations are valid unless there is a  
	//   race condition.
	//
	if ( ! ROCKALL::MultipleDelete( Actual,Array,NewSize ) )
		{ Failure( "Delete requested failed due to race" ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "MultipleDelete failed to complete" ); }

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate a collection of memory elements and setup the         */
    /*   guard information so we can check they have not been           */
    /*   damaged later.                                                 */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	REGISTER bool Result = false;

	//
	//   The requested number of elements and the size  
	//   must be greater than zero.  We require the 
	//   caller to allocate a positive amount of memory.
	//
	if ( (Requested > 0) && (Size >= 0) )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Result = 
			(
			ROCKALL::MultipleNew
				( 
				Actual,
				Array,
				Requested,
				NewSize,
				& TotalSize 
				)
			);

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER int Count;

			//
			//   If the real size is requested then return 
			//   it to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ 
				REGISTER void **Current = & Array[ Count ];

				//
				//   Set up the guard words and ensure
				//   the allocation has not been written
				//   since being freed.
				//
				SetGuardWords
					( 
					((DEBUG_HEADER*) (*Current)),
					((Space == NULL) ? Size : (*Space)), 
					TotalSize
					);

				//
				//   Compute the external address and place
				//   it back in the array.
				//
				(*Current) = ComputeDataAddress( ((DEBUG_HEADER*) (*Current)) );

				//
				//   Zero the memory if the needed.
				//
				if ( Zero )
					{ 
					ZeroMemory
						( 
						(*Current),
						((Space == NULL) ? Size : (*Space)) 
						); 
					}
				}
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "Multiple new failed to complete" ); }
		}
	else
		{ Failure( "Allocation size must greater than zero" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We add some space on to the original allocation size for       */
    /*   various information and then call the allocator.  We then      */
    /*   set the guard words so we can check for overruns.              */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::New( int Size,int *Space,bool Zero )
    {
	REGISTER void *Address = ((void*) AllocationFailure);

	//
	//   The size must be greater than or equal to zero.  
	//   We do not know how to allocate a negative amount
	//   of memory.
	//
	if ( Size >= 0 )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Address = ROCKALL::New( NewSize,& TotalSize,false );

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( Address != ((void*) AllocationFailure) ) 
			{
			//
			//   If the real size is requested then return it
			//   to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			SetGuardWords
				( 
				((DEBUG_HEADER*) Address),
				((Space == NULL) ? Size : (*Space)), 
				TotalSize
				); 

			//
			//   Compute the external address and place
			//   it back in the variable.
			//
			Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

			//
			//   Zero the allocation if needed.
			//
			if ( Zero )
				{ 
				ZeroMemory
					( 
					Address,
					((Space == NULL) ? Size : (*Space)) 
					); 
				} 
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "New failed to complete" ); }
		}
	else
		{ Failure( "Allocation size can not be negative" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::NewArea( int AlignMask,int Size,bool User )
    {
	REGISTER void *Memory = ROCKALL::NewArea( AlignMask,Size,User );

	//
	//   If we managed to get a new page then write
	//   the guard value over it to allow us to
	//   verify it has not been overwritten later.
	//
	if ( Memory != ((void*) AllocationFailure) )
		{
		REGISTER int Count;

		//
		//   Write the guard value into all of the new
		//   heap page to allow it to be checked for
		//   corruption.
		//
		for ( Count=0;Count < Size;Count += GuardSize )
			{ (((int*) Memory)[ (Count / GuardSize) ]) = GuardValue; }
		}
	
	return Memory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We need to resize an allocation.  We ensure the original       */
    /*   allocation was undamaged and then expand it.  We also          */
    /*   update the guard words to reflect the changes.                 */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to resize a null
	//   pointer.  This is really a very poor style but we 
	//   support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   The new size must be greater than or equal to  
		//   zero.  We do not know how to allocate a negative 
		//   amount of memory.
		//
		if ( NewSize >= 0 )
			{
			REGISTER int Size = 
				(((NewSize + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

			//
			//   Ask for the details of the allocation.  This 
			//   will fail if the memory is not allocated.
			//
			if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
				{
				REGISTER void *OriginalAddress = ((void*) Header);
				REGISTER int OriginalSize = TotalSize;

				//
				//   Test the guard words to make sure they have
				//   not been damaged.
				//
				TestGuardWords( Header,TotalSize );

				//
				//   Reallocate the memory plus some additional 
				//   memory for the guard words.
				//
				Address =
					(
					ROCKALL::Resize
						( 
						OriginalAddress,
						Size,
						Move,
						& TotalSize,
						true,
						false
						)
					);

				//
				//   If we were able to allocate some memory 
				//   then set the guard words so we can detect 
				//   any corruption later.
				//
				if ( Address != ((void*) AllocationFailure) )
					{
					REGISTER SBIT32 SpaceUsed = Header -> Size;

					//
					//   Delete the user information by writing 
					//   guard words over the allocation.  This
					//   should cause the application to crash
					//   if the area is read and allows us to
					//   check to see if it is written later.
					//
					if ( (! NoDelete) && (Address != OriginalAddress) )
						{
						ResetGuardWords( Header,OriginalSize );

						if ( ! ROCKALL::Delete( OriginalAddress ) )
							{ Failure( "Delete failed due to race" ); }
						}

					//
					//   If the real size is requested then 
					//   return it to the caller.
					//
					if ( Space != NULL )
						{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

					//
					//   Update the guard words so we can see 
					//   if someone damages the allocation.  If
					//   the caller requested the size information 
					//   then we must assume that it could be 
					//   used so we need to adjust the guard words.
					//
					UpdateGuardWords
						( 
						((DEBUG_HEADER*) Address),
						((Space == NULL) ? NewSize : (*Space)), 
						TotalSize
						); 

					//
					//   Compute the external address and place
					//   it back in the variable.
					//
					Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 ActualSize = 
							((Space == NULL) ? Size : (*Space));
						REGISTER SBIT32 Difference = 
							(ActualSize - SpaceUsed);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) Address);

							ZeroMemory( & Array[ SpaceUsed ],Difference ); 
							} 
						}	
					}
				}
			else
				{ Failure( "Resize requested on unallocated memory" ); }
			}
		else
			{ Failure( "Allocation size must be positive" ); }
		}
	else
		{ Address = New( NewSize,Space,Zero ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the reallocation process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Resize failed to complete" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the guard words.                                         */
    /*                                                                  */
    /*   We need to reset the guard words just before we delete a       */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::ResetGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   Write guard words over the allocated space as
	//   the allocation is about to be freed.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ (((int*) Header)[ (Count / GuardSize) ]) = GuardValue; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Set the guard words.                                           */
    /*                                                                  */
    /*   We need to set the guard words just after an allocation so     */
    /*   we can check them later.                                       */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize) 
				&& 
			(Size >= 0) 
			)
		{
		REGISTER int Count;

		//
		//   We know that the entire allocation should be
		//   set to the guard value so check that it has
		//   not been overwritten.
		//
		for ( Count=0;Count < TotalSize;Count += GuardSize )
			{ 
			if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
				{ Failure( "Guard words have been damaged" ); }
			}

		//
		//   Write the header information.
		//
		Header -> Size = Size;
		}
	else
		{ Failure( "Guard word area is too small or unaligned" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Test the guard words.                                          */
    /*                                                                  */
    /*   We need to test the guard words a various times to ensure      */
    /*   are still valid.                                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::TestGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before testing the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Header -> Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Header -> Size >= 0) 
			)
		{
		REGISTER int Count;
		REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
		REGISTER int EndIndex = ((Header -> Size + GuardMask) & ~GuardMask);
		REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
		REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
		REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

		//
		//   Test the guard word just before the allocation
		//   to see if it has been overwritten.
		//
		if ( Header -> StartGuard != GuardValue )
			{ Failure( "Leading guard word has been damaged" ); }

		//
		//   Test the guard bytes just after the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=Header -> Size;(Count & GuardMask) != 0;Count ++ )
			{
			REGISTER int ByteIndex = (Count & GuardMask);

			//
			//   Test each byte up to the next word boundary.
			//
			if 
					( 
					Trailer -> MidGuard[ ByteIndex ] 
						!= 
					((char*) & GuardValue)[ ByteIndex ]
					)
				{ Failure( "Trailing guard byte has been damaged" ); }
			}

		//
		//   Test the guard words following the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
			{ 
			if ( Trailer -> EndGuard[ (Count / GuardSize) ] != GuardValue )
				{ Failure( "Trailing guard word has been damaged" ); }
			}
		}
	else
		{ Failure( "Guard information has been damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory Trunction.                                              */
    /*                                                                  */
    /*   We truncate the heap and make sure that this does not          */
    /*   corrupt the heap in some way.                                  */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Truncate( int MaxFreeSpace )
	{
	REGISTER bool Result;

	//
	//   We truncate the heap and release all available
	//   memory regardless of what the caller requested.
	//
	Result = ROCKALL::Truncate( 0 );

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap truncation failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unmodified guard words.                                        */
    /*                                                                  */
    /*   We need to inspect the guard words to ensure they have not     */
    /*   changed after being freed.                                     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   We know that the entire allocation should be
	//   set to the guard value so check that it has
	//   not been overwritten.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ 
		if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
			{ Failure( "Guard words on unallocated memory have been damaged" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the guard words.                                        */
    /*                                                                  */
    /*   We need to update the guard words after a resize so we can     */
    /*   check them later.                                              */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Size >= 0) 
			)
		{
		//
		//   We only copy the smaller of the new size 
		//   and the old size.  So check just the
		//   correct number of guard words.
		//
		if ( Header -> Size > Size )
			{
			REGISTER int Count;
			REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
			REGISTER int EndIndex = ((Size + GuardMask) & ~GuardMask);
			REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
			REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
			REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

			//
			//   Update the guard bytes just after the 
			//   allocation.
			//
			for ( Count=Size;(Count & GuardMask) != 0;Count ++ )
				{
				REGISTER int ByteIndex = (Count & GuardMask);

				Trailer -> MidGuard[ ByteIndex ] =
					((char*) & GuardValue)[ ByteIndex ];
				}

			//
			//   Write guard words over part of the space 
			//   as the allocation is being shrunk.
			//
			for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
				{ Trailer -> EndGuard[ (Count / GuardSize) ] = GuardValue; }

			//
			//   Update the header information.
			//
			Header -> Size = Size; 

			//
			//   We know that the entire allocation should 
			//   be set to the guard value so check that it 
			//   has not been overwritten.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{
			//
			//   We know that the entire allocation should be
			//   set to the guard value so check that it has
			//   not been overwritten.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Update the header information.
			//
			Header -> Size = Size; 
			}
		}
	else
		{ Failure( "Guard word information area is damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Verify( void *Address,int *Space )
    {
	AUTO bool Result;
	AUTO int TotalSize;
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   Extract information about the memory allocation.
	//
	Result = 
		(
		ROCKALL::Verify
			( 
			((void*) Header),
			& TotalSize 
			)
		);

	//
	//   If we managed to extract the information then
	//   check the guard words for good measure.
	//
	if ( Result )
		{
		//
		//   If we are about to return the actual 
		//   amount of spce available then we must 
		//   update the size of the guard area.
		//
		if ( Space == NULL )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{ 
			//
			//   Compute the amount of available space.
			//   
			(*Space) = (TotalSize - sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			UpdateGuardWords( Header,(*Space),TotalSize );
			}
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the verification process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Heap verify failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Walk( bool *Active,void **Address,int *Space )
    {
	AUTO DEBUG_HEADER *Header =
		(
		((*Address) == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) (*Address))
			: ComputeHeaderAddress( (*Address) )
		);

	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Active,((VOID**) & Header),Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ TestGuardWords( Header,(*Space) ); }
		else
			{ UnmodifiedGuardWords( Header,(*Space) ); }

		//
		//   Compute the new heap address.
		//
		(*Address) = ComputeDataAddress( Header );

		//
		//   Compute the amount of available space.
		//   
		(*Space) -= sizeof(DEBUG_GUARD);

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::~DEBUG_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the its lifetime.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Destructor failed to complete" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\defaultheap.hpp ===
#ifndef _DEFAULT_HEAP_HPP_
#define _DEFAULT_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef _DEBUG
#include "DebugHeap.hpp"
typedef DEBUG_HEAP DEFAULT_HEAP;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP DEFAULT_HEAP;
#endif
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   The default heap is available for everyone as soon as the      */
    /*   memory allocator DLL has loaded.                               */
    /*                                                                  */
    /********************************************************************/

extern ROCKALL_DLL_LINKAGE DEFAULT_HEAP DefaultHeap;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\fastheap.hpp ===
#ifndef _FAST_HEAP_HPP_
#define _FAST_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A fast heap.                                                   */
    /*                                                                  */
    /*   A fast heap tries to provide very good performance even        */
    /*   if that comes at a significant cost in terms of additional     */
    /*   memory usage.                                                  */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE FAST_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        FAST_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~FAST_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FAST_HEAP( const FAST_HEAP & Copy );

        void operator=( const FAST_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\fastheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "FastHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 8192;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,      256,       32,     4096 },
		{        8,      128,       32,     4096 },
		{       12,      128,       64,     4096 },
		{       16,      128,       64,     4096 },
		{       20,       64,       64,     4096 },
		{       24,       64,       96,     4096 },

		{       32,       64,      128,     4096 },
		{       40,       64,      128,     4096 },
		{       48,       64,      256,     4096 },

		{       64,       64,      256,     4096 },
		{       80,       64,      512,     4096 },
		{       96,       64,      512,     4096 },

		{      128,       32,     4096,     4096 },
		{      160,       16,     4096,     4096 },
		{      192,       16,     4096,     4096 },
		{      224,       16,     4096,     4096 },

		{      256,       16,     4096,     4096 },
		{      320,        8,     4096,     4096 },
		{      384,        8,     4096,     4096 },
		{      448,        8,     4096,     4096 },
		{      512,        4,     4096,     4096 },
		{      576,        4,     4096,     4096 },
		{      640,        4,     8192,     8192 },
		{      704,        4,     4096,     4096 },
		{      768,        4,     4096,     4096 },
		{      832,        4,     8192,     8192 },
		{      896,        4,     8192,     8192 },
		{      960,        4,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::FAST_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::~FAST_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\interfacepch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\interfacepch.hpp ===
#ifndef _ROCKALL_PCH_HPP_
#define _ROCKALL_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "HeapPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\defaultheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   Create a single static instance of the default heap so         */
    /*   that is available as soon as the DLL has finished loading.     */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
DEFAULT_HEAP DefaultHeap( 4194304,true,true,true );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\rockall.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The interface default constructor creates a null heap for      */
    /*   internal use by selected classes.                              */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL( void )
	{
	//
	//   A heap constructed by this constructor should
	//   never be used.  Hence, we zero key pointers to
	//   ensure grave disorder will result if anyone tries.
	//
	Array = NULL;
	Caches = NULL;
	Find = NULL;
	Heap = NULL;
	NewPage = NULL;

	GlobalDelete = True;
	GuardWord = GuardValue;
	NumberOfCaches = 0;
	TotalSize = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe 
		)
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	TRY
#endif
		{
		REGISTER int AlignMask = ((int) (NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Find = NULL;
		Heap = NULL;
		NewPage = NULL;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			((GlobalDelete) ? 0 : sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) NewArea( ((SBIT32) AlignMask),TotalSize,False ));

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the caches.
				//
				//   The first step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((BOOLEAN) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the global find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC ROCKALL Rockall;

						//
						//   Select the global find table 
						//   and call the constructor.
						//
						Find = ((FIND*) GlobalFind);

						PLACEMENT_NEW( Find,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((ROCKALL*) & Rockall),
							((BOOLEAN) True),
							((BOOLEAN) (GlobalDelete || ThreadSafe))
							);
						}
					else
						{
						//
						//   A global find has table already
						//   exists so just use it.
						//
						Find = ((FIND*) GlobalFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}
				else
					{
					Find = (FIND*) NewMemory;
					NewMemory += sizeof(FIND);

					//
					//   We create a local find hash table
					//   if we are do not need to provide
					//   a single heap image.
					//
					PLACEMENT_NEW( Find,FIND ) 
						( 
						((SBIT32) FindSize),
						((SBIT32) FindCacheSize),
						((SBIT32) FindCacheThreshold),
						((ROCKALL*) this),
						((BOOLEAN) True),
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((FIND*) Find),
					((SBIT32*) NewPageSizes),
					((ROCKALL*) this),
					((SBIT32) Size3),
					((BOOLEAN) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((FIND*) Find),
					((NEW_PAGE*) NewPage),
					((ROCKALL*) this),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					ThreadSafe
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   the area back to the operating system.                         */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Details( ((VOID*) Address),((SBIT32*) Space) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   The default is to ask the operating system for the             */
    /*   allocation granularity.                                        */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER LONG Address = ((LONG) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Verify( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Verify( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::~ROCKALL( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the find hash table destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the global find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( Find,FIND ); }

				Spinlock.ReleaseLock();
				}
			else
				{ PLACEMENT_DELETE( Find,FIND ); }


			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Deallocate the heap structures.
			//
			DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			NewPage = NULL;
			Heap = NULL;
			Find = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\smallheap.hpp ===
#ifndef _SMALL_HEAP_HPP_
#define _SMALL_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A small heap.                                                  */
    /*                                                                  */
    /*   A small heap tries to significantly reduce memory usage        */
    /*   even if that comes at a significant cost in terms of           */
    /*   performance.                                                   */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMALL_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        SMALL_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~SMALL_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMALL_HEAP( const SMALL_HEAP & Copy );

        void operator=( const SMALL_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\windowsheap.hpp ===
#ifndef WINDOWS_HEAP_HPP 
#define WINDOWS_HEAP_HPP 1                         
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Windows.h"

#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The shadow interface.                                          */
    /*                                                                  */
    /*   The shadow interface closely resembles the NT heap interface   */
    /*   and so enables the easy porting of applications.               */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
	( 
	DWORD						  Flags,
	DWORD						  InitialSize,
	DWORD						  MaximumSize 
	);

extern "C" LPVOID WindowsHeapAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	DWORD						  Size 
	);

extern "C" UINT WindowsHeapCompact
	( 
	HANDLE						  Heap,
	DWORD						  Flags 
	);

extern "C" BOOL WindowsHeapFree
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapLock
	( 
	HANDLE						  Heap 
	);

extern "C" LPVOID WindowsHeapReAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory,
	DWORD						  Size 
	);

extern "C" VOID WindowsHeapReset
	(
	HANDLE						  Heap 
	);

extern "C" DWORD WindowsHeapSize
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapUnlock
	(
	HANDLE						  Heap 
	);

extern "C" BOOL WindowsHeapValidate
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapWalk
	( 
	HANDLE						  Heap,
	LPPROCESS_HEAP_ENTRY		  Walk 
	);

extern "C" BOOL WindowsHeapDestroy
	(
	HANDLE						  Heap 
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\posixheap.hpp ===
#ifndef _POSIX_HEAP_HPP_
#define _POSIX_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DefaultHeap.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   The standard posix interface.                                  */
    /*                                                                  */
    /*   The Posix interface allows Rockall to be linked into Unix      */
    /*   applications with a minimal amount of fuss.  Although the      */
    /*   function names are not identical to the posix names (so as     */
    /*   to avoid name clashes) functionally they are close enough      */
    /*    to be simple replacements.                                    */
    /*                                                                  */
    /********************************************************************/

inline void *Calloc( int Size )
	{ return DefaultHeap.New( Size,NULL,true ); }

inline bool Free( void *Address,int Size = NoSize )
	{ return DefaultHeap.Delete( Address,Size ); }

inline void *Malloc( int Size )
	{ return DefaultHeap.New( Size ); }

inline void *Realloc( void *Address,int NewSize )
	{ return DefaultHeap.Resize( Address,NewSize ); }
#ifdef POSIX_EXTENSIONS

    /********************************************************************/
    /*                                                                  */
    /*   Extensions to the posix interface.                             */
    /*                                                                  */
    /*   The Posix interface is fairly restricted and only gives        */
    /*   access to a small portion of Rockall.  The functions that      */
    /*   follow expose additional Rockall functionality.                */
    /*                                                                  */
    /********************************************************************/

inline void DeleteAll( bool Recycle = true )
	{ DefaultHeap.DeleteAll( Recycle ); }

inline bool MultipleFree
		( 
		int				Actual,
		void			*Array[],
		int				Size = NoSize
		)
	{ return DefaultHeap.MultipleDelete( Actual,Array,Size ); }

inline bool MultipleMalloc
		( 
		int				*Actual,
		void			*Array[],
		int				Requested,
		int				Size
		)
	{ return DefaultHeap.MultipleNew( Actual,Array,Requested,Size ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\smpheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Common.hpp"
#include "List.hpp"
#include "New.hpp"
#include "Prefetch.hpp"
#include "Sharelock.hpp"
#include "SmpHeap.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 8192;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 MinThreadStack			  = 4;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Structures local to the class.                                 */
    /*                                                                  */
    /*   The structures supplied here describe the layout of the        */
    /*   per thread caches.                                             */
    /*                                                                  */
    /********************************************************************/

typedef struct CACHE_STACK
	{
	BOOLEAN							  Active;

	SBIT32							  MaxSize;
	SBIT32							  FillSize;
	SBIT32							  Space;
	SBIT32							  Top;

	VOID							  **Stack;
	}
CACHE_STACK;

typedef struct THREAD_CACHE : public LIST
	{
	BOOLEAN							  Flush;

	CACHE_STACK						  *Caches;
	CACHE_STACK						  **SizeToCache1;
	CACHE_STACK						  **SizeToCache2;
	}
THREAD_CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,      256,       32,     4096 },
		{        8,      128,       32,     4096 },
		{       12,      128,       64,     4096 },
		{       16,      128,       64,     4096 },
		{       20,       64,       64,     4096 },
		{       24,       64,       96,     4096 },

		{       32,       64,      128,     4096 },
		{       40,       64,      128,     4096 },
		{       48,       64,      256,     4096 },

		{       64,       64,      256,     4096 },
		{       80,       64,      512,     4096 },
		{       96,       64,      512,     4096 },

		{      128,       32,     4096,     4096 },
		{      160,       32,     4096,     4096 },
		{      192,       32,     4096,     4096 },
		{      224,       32,     4096,     4096 },

		{      256,       32,     4096,     4096 },
		{      320,       16,     4096,     4096 },
		{      384,       16,     4096,     4096 },
		{      448,       16,     4096,     4096 },
		{      512,       16,     4096,     4096 },
		{      576,        8,     4096,     4096 },
		{      640,        8,     8192,     8192 },
		{      704,        8,     4096,     4096 },
		{      768,        8,     4096,     4096 },
		{      832,        8,     8192,     8192 },
		{      896,        8,     8192,     8192 },
		{      960,        8,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC PREFETCH Prefetch;
STATIC SHARELOCK Sharelock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::SMP_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			False,			// Recycle forced off.
			SingleImage,
			Stride1,
			Stride2,
			True			// Locking forced on.
			)
	{
	//
	//   Compute the number of cache descriptions
	//   and the largest allocation size for each
	//   cache description table.
	//
	MaxCaches1 = (ComputeSize( ((CHAR*) Caches1),sizeof(CACHE_DETAILS) ));
	MaxCaches2 = (ComputeSize( ((CHAR*) Caches2),sizeof(CACHE_DETAILS) ));

	MaxSize1 = Caches1[ (MaxCaches1-1) ].AllocationSize;
	MaxSize2 = Caches2[ (MaxCaches2-1) ].AllocationSize;

	//
	//   Create the linked list headers and a thread 
	//   local store variable to point at each threads
	//   private cache.
	//
	ActiveList = ((LIST*) SpecialNew( sizeof(LIST) ));
	FreeList = ((LIST*) SpecialNew( sizeof(LIST) ));
	Tls = ((THREAD_LOCAL_STORE*) SpecialNew( sizeof(THREAD_LOCAL_STORE) ));

	//
	//   We may only activate the the heap if we manage
	//   to allocate space we requested and the stride
	//   size of the cache descriptions is a power of two. 
	//
	if
			(
			(ActiveList != NULL) 
				&&
			(COMMON::ConvertDivideToShift( Stride1,((SBIT32*) & ShiftSize1) ))
				&&
			(COMMON::ConvertDivideToShift( Stride2,((SBIT32*) & ShiftSize2) ))
				&& 
			(FreeList != NULL) 
				&& 
			(Tls != NULL)
			)
		{
		//
		//   Activate the heap.
		//
		Active = True;

		//
		//   Execute the constructors for each linked list
		//   and for the thread local store.
		//
		PLACEMENT_NEW( ActiveList,LIST );
		PLACEMENT_NEW( FreeList,LIST );
		PLACEMENT_NEW( Tls,THREAD_LOCAL_STORE );
		}
	else
		{ Active = False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create new thread cache.                                       */
    /*                                                                  */
    /*   Create a new thread cache to store all the cache stacks.       */
    /*   Each thread cache is private to a thread and is accessed       */
    /*   without taking locks.                                          */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::CreateThreadCache( void )
	{
	REGISTER THREAD_CACHE *ThreadCache = NULL;

	//
	//   We need to have a look in the free list
	//   in the vain hope we will find a prebuilt
	//   thread cache ready for use.
	//
	Sharelock.ClaimExclusiveLock();

	if ( ! FreeList -> EndOfList() )
		{
		//
		//   We have found a free one.
		//
		ThreadCache = ((THREAD_CACHE*) FreeList -> First());

		//
		//   Unlink it from the free list and put
		//   it back in the active list.
		//
		ThreadCache -> Delete( FreeList );
		ThreadCache -> Insert( ActiveList );
		}

	Sharelock.ReleaseExclusiveLock();

	//
	//   If we could not find a free thread cache
	//   then we have allocate the space and build
	//   a new one.  This requires quite a bit of
	//   effort so we try to avoid this as far as
	//   we are able.
	//
	if ( ThreadCache == NULL )
		{
		REGISTER SBIT32 MaxCaches = (MaxCaches1 + MaxCaches2);
		REGISTER SBIT32 MaxSizeToCache1 = (MaxSize1 / Stride1);
		REGISTER SBIT32 MaxSizeToCache2 = (MaxSize2 / Stride2);

		//
		//   Create the space for a new thread 
		//   cache from the heaps special memory
		//   area.
		//
		ThreadCache = 
			(
			(THREAD_CACHE*) SpecialNew
				( 
				sizeof(THREAD_CACHE)
					+
				(MaxCaches * sizeof(CACHE_STACK))
					+
				(MaxSizeToCache1 * sizeof(CACHE_STACK*))
					+
				(MaxSizeToCache2 * sizeof(CACHE_STACK*))
				)
			);

		//
		//   Clearly, if we are unable to allocate the 
		//   required space we have big problems.  All
		//   we can do is exit and continue without a
		//   cache.
		//
		if ( ThreadCache != NULL )
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 Count2;

			//
			//   Setup the thread cache flags.
			//
			ThreadCache -> Flush = False;

			//
			//   Setup the thread cache tables.
			//
			ThreadCache -> SizeToCache1 = 
				((CACHE_STACK**) & ThreadCache[1]);
			ThreadCache -> SizeToCache2 = 
				((CACHE_STACK**) & ThreadCache -> SizeToCache1[ MaxSizeToCache1 ]);
			ThreadCache -> Caches = 
				((CACHE_STACK*) & ThreadCache -> SizeToCache2[ MaxSizeToCache2 ]);

			//
			//   Create a mapping from each allocation size 
			//   to the associated cache stack for the first
			//   cache description table.
			//
			for ( Count1=0,Count2=0;Count1 < MaxSizeToCache1;Count1 ++ )
				{
				//
				//   We make sure that the current cache size
				//   is large enough to hold an element of the
				//   given size.  If not we move on to the next
				//   cache.
				//
				if 
						( 
						((Count1 + 1) * Stride1)
							> 
						(Caches1[ Count2 ].AllocationSize) 
						)
					{ Count2 ++; }

				//
				//   Store a pointer so that a request for
				//   this size of allocation goes directly
				//   to the correct cache.
				//
				ThreadCache -> SizeToCache1[ Count1 ] = 
					& ThreadCache -> Caches[ Count2 ];
				}

			//
			//   Create a mapping from each allocation size 
			//   to the associated cache stack for the second
			//   cache description table.
			//
			for ( Count1=0,Count2=0;Count1 < MaxSizeToCache2;Count1 ++ )
				{
				//
				//   We make sure that the current cache size
				//   is large enough to hold an element of the
				//   given size.  If not we move on to the next
				//   cache.
				//
				if 
						( 
						((Count1 + 1) * Stride2)
							> 
						(Caches2[ Count2 ].AllocationSize) 
						)
					{ Count2 ++; }

				//
				//   Store a pointer so that a request for
				//   this size of allocation goes directly
				//   to the correct cache.
				//
				ThreadCache -> SizeToCache2[ Count1 ] = 
					& ThreadCache -> Caches[ (MaxCaches1 + Count2) ];
				}

			//
			//   When we setup each cache stack it is
			//   not active but will load in details
			//   about is maximum size, the size of
			//   the elements it will hold and the
			//   initial fill size.
			//
			for ( Count1=0;Count1 < MaxCaches1;Count1 ++ )
				{ 
				REGISTER CACHE_STACK *CacheStack =
					& ThreadCache -> Caches[ Count1 ];
				REGISTER CACHE_DETAILS *Details = 
					& Caches1[ Count1 ];

				//
				//   Setup the inital values from
				//   the cache descriptions.
				//
				CacheStack -> Active = False;
				CacheStack -> MaxSize = Details -> CacheSize;
				CacheStack -> FillSize = 1;
				CacheStack -> Space = Details -> AllocationSize;
				CacheStack -> Top = 0;
				CacheStack -> Stack = NULL;
				}

			//
			//   When we setup each cache stack it is
			//   not active but will load in details
			//   about is maximum size, the size of
			//   the elements it will hold and the
			//   initial fill size.
			//
			for ( Count1=0;Count1 < MaxCaches2;Count1 ++ )
				{ 
				REGISTER CACHE_STACK *CacheStack =
					& ThreadCache -> Caches[ MaxCaches1 + Count1 ];
				REGISTER CACHE_DETAILS *Details = 
					& Caches2[ Count1 ];

				//
				//   Setup the inital values from
				//   the cache descriptions.
				//
				CacheStack -> Active = False;
				CacheStack -> MaxSize = Details -> CacheSize;
				CacheStack -> FillSize = 1;
				CacheStack -> Space = Details -> AllocationSize;
				CacheStack -> Top = 0;
				CacheStack -> Stack = NULL;
				}

			//
			//   Now we have completed creating the 
			//   thread cache we have to insert it
			//   into the active list.
			//
			Sharelock.ClaimExclusiveLock();

			ThreadCache -> Insert( ActiveList );

			Sharelock.ReleaseExclusiveLock();
			}
		}

	//
	//   Create a cache for the current thread and
	//   update the TLS pointer.
	//
	Tls -> SetPointer( ((VOID*) ThreadCache) ); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Activate a cache stack.                                        */
    /*                                                                  */
    /*   Activate a cache stack and prepare it for use.                 */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::ActivateCacheStack( CACHE_STACK *CacheStack )
	{
	//
	//   We verify that we have not already created a 
	//   stack for the current cache.  If so we create
	//   one if there is available memory.
	//
	if ( ! CacheStack -> Active )
		{
		//
		//   If the cache size is smaller than the
		//   minimum size it is not worth building
		//   a cache.
		//
		if ( CacheStack -> MaxSize >= MinThreadStack )
			{
			//
			//   Create a new cache stack.
			//
			CacheStack -> Stack = 
				(
				(VOID**) SpecialNew
					( 
					(CacheStack -> MaxSize * sizeof(VOID*))
					)
				);

			//
			//   The key step in this function is the  
			//   allocation of space for the cache.  
			//   If this step fails we will be unable  
			//   to do anything and will silently exit.
			//
			if ( CacheStack -> Stack != NULL )
				{
				//
				//   Setup the cache sizes.
				//
				CacheStack -> Active = True;
				CacheStack -> Top = 0;
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   When we delete an allocation we try to put it in the per       */
    /*   thread cache so it can be reallocated later.                   */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Delete( void *Address,int Size )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER THREAD_CACHE *ThreadCache = 
			((THREAD_CACHE*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a cache for the current thread.  
		//   If not we build one for next time.
		//
		if ( ThreadCache != NULL )
			{
			AUTO int Space;

			//
			//   When the heap is deleted or truncated 
			//   we have to flush the per thread caches
			//   the next time we are called to clean
			//   out any stale contents.
			//
			if ( ThreadCache -> Flush )
				{ FlushThreadCache( ThreadCache ); }

			//
			//   We would like to put the deleted 
			//   allocation back in the cache.
			//   However, we don't have any information
			//   about it so we need to get its size
			//   and verify it will fit in the cache.
			//
			if
					(
					ROCKALL::Details( Address,& Space )
						&&
					((Space > 0) && (Space < MaxSize2))
					)
				{
				REGISTER CACHE_STACK *CacheStack = 
					(FindCache( Space,ThreadCache ));

				//
				//   We try to put the deleted element  
				//   back into the per thread cache.  If
				//   the cache is not active then we 
				//   activate it for next time.
				//
				if ( CacheStack -> Active )
					{
					//
					//   Just to be sure lets just check
					//   to make sure this is the size
					//   that we expect.
					//
					if ( CacheStack -> Space == Space )
						{
						//
						//   Flush the cache if it is full.
						//
						if ( CacheStack -> Top >= CacheStack -> MaxSize )
							{
							//
							//   Flush the top half of the 
							//   cache.
							//
							CacheStack -> Top /= 2;

							ROCKALL::MultipleDelete
								( 
								(CacheStack -> MaxSize - CacheStack -> Top),
								& CacheStack -> Stack[ CacheStack -> Top ],
								CacheStack -> Space
								);
							}

						//
						//   Push the item back onto the new 
						//   stack so it can be reallocated.
						//
						CacheStack -> Stack[ (CacheStack -> Top ++) ] = Address;

						return True;
						}
					}
				else
					{
					//
					//   Activate the cache stack for next 
					//   time.
					//
					ActivateCacheStack( CacheStack ); 
					}
				}
			}
		else
			{
			//
			//   Create a thread cache for next time.
			//
			CreateThreadCache(); 
			}
		}

	//
	//   If all else fails call the heap directly and
	//   return the result.
	//
	return (ROCKALL::Delete( Address,Size ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::DeleteAll( bool Recycle )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Flush all the local caches.
		//
		FlushAllThreadCaches();

		//
		//   Delete the current cache.
		//
		DeleteThreadCache();
		}

	//
	//   Delete all outstanding allocations.
	//
	ROCKALL::DeleteAll( Recycle );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a local cache.                                            */
    /*                                                                  */
    /*   Find the local cache that allocates elements of the supplied   */
    /*   size for this thread.                                          */
    /*                                                                  */
    /********************************************************************/

CACHE_STACK *SMP_HEAP::FindCache( int Size,THREAD_CACHE *ThreadCache )
	{
	if ( Size <= MaxSize1 )
		{ return (ThreadCache -> SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (ThreadCache -> SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush all local caches.		                                */
    /*                                                                  */
    /*   Flush the local per thread caches by setting each caches       */
    /*   flush flag (the actual flush occurs sometime later).           */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushAllThreadCaches( void )
	{
	REGISTER THREAD_CACHE *Current;

	//
	//   Claim a process wide lock.
	//
	Sharelock.ClaimShareLock();

	//
	//   Walk the list of active caches and set
	//   the flush flag.
	//
	for 
			( 
			Current = ((THREAD_CACHE*) ActiveList -> First());
			(Current != NULL);
			Current = ((THREAD_CACHE*) Current -> Next())
			)
		{ Current -> Flush = True; }

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush a local cache.                                           */
    /*                                                                  */
    /*   Flush a local per thread cache and return all the outstanding  */
    /*   allocations to the main heap.                                  */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushThreadCache( THREAD_CACHE *ThreadCache )
	{
	//
	//   We would hope that there is a cache to flush
	//   but just to be sure we verify it.
	//
	if ( ThreadCache != NULL )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 MaxCaches = (MaxCaches1 + MaxCaches2);

		//
		//   Reset the flags.
		//
		ThreadCache -> Flush = False;

		//
		//   Flush all the caches.
		//
		for ( Count=0;Count < MaxCaches;Count ++ )
			{ FlushCacheStack( & ThreadCache -> Caches[ Count ] ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush a cache stack.                                           */
    /*                                                                  */
    /*   Flush a cache stack back to the main memory manager to         */
    /*   release the cached space.                                      */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushCacheStack( CACHE_STACK *CacheStack )
    {
	//
	//   There is a chance that this cache is not active. 
	//   If so we skip the cache flush.
	//
	if ( CacheStack -> Active )
		{
		REGISTER SBIT32 Top = CacheStack -> Top;

		//
		//   We flush the cache if it has any allocated 
		//   space.  If not we just exit.
		//
		if ( Top != 0 )
			{
			//
			//   Zero the top of stack.
			//
			CacheStack -> FillSize = 1;
			CacheStack -> Top = 0;

			//
			//   We simply flush any allocated memory
			//   back to the heap.  This looks easy 
			//   doesn't it.  However, if the 'DeleteAll()'
			//   function was called then this memory
			//   might exist.  However, if 'Truncate()'
			//   was called it should.  Moreover, some of
			//   the allocations might not even be from
			//   this heap.  What a mess.  We avoid all
			//   this by disabling 'Recycle' and skiping
			//   any complaints about unallocated memory.
			//
			ROCKALL::MultipleDelete
				( 
				Top,
				CacheStack -> Stack,
				CacheStack -> Space
				);
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate space for the current thread from the local        */
    /*   per thread cache.  If we run out of space we bulk load         */
    /*   additional elements from a central shared heap.                */
    /*                                                                  */
    /********************************************************************/

void *SMP_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER THREAD_CACHE *ThreadCache = 
			((THREAD_CACHE*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a cache for the current thread.
		//   If not we build one for next time.
		//
		if ( ThreadCache != NULL )
			{
			//
			//   When the heap is deleted or truncated 
			//   we have to flush the per thread caches
			//   the next time we are called to clean
			//   out any stale contents.
			//
			if ( ThreadCache -> Flush )
				{ FlushThreadCache( ThreadCache ); }

			//
			//   The per thread cache can only slave 
			//   certain allocation sizes.  If the size 
			//   is out of range then pass it along to 
			//   the allocator.
			//
			if ( (Size > 0) && (Size < MaxSize2) )
				{
				REGISTER CACHE_STACK *CacheStack = 
					(FindCache( Size,ThreadCache ));

				//
				//   Although we have created a cache  
				//   description it may not be active. 
				//
				if ( CacheStack -> Active )
					{
					//
					//   We see if we need to refill the
					//   current cache.  If so we increase
					//   the fill size slowly ensure good
					//   overall utilization.
					//
					if ( CacheStack -> Top <= 0 )
						{
						REGISTER SBIT32 MaxFillSize = 
							(CacheStack -> MaxSize / 2);

						//
						//   We slowly increse the fill size
						//   of the cache to make sure we don't
						//   waste too much space.
						//
						if ( CacheStack -> FillSize < MaxFillSize )
							{
							if ( (CacheStack -> FillSize *= 2) > MaxFillSize )
								{ CacheStack -> FillSize = MaxFillSize; }
							}

						//
						//   Refill the current cache stack.
						//
						ROCKALL::MultipleNew
							( 
							((int*) & CacheStack -> Top),
							((void**) CacheStack -> Stack),
							((int) CacheStack -> FillSize),
							((int) CacheStack -> Space)
							);
						}

					//
					//   If there is some space in the 
					//   current cache stack we allocate it.
					//
					if ( CacheStack -> Top > 0 )
						{
						REGISTER VOID *Address = 
							(CacheStack -> Stack[ (-- CacheStack -> Top) ]);

						//
						//   Prefetch the first cache line of  
						//   the allocation if we are running
						//   a Pentium III or better.
						//
						Prefetch.L1( ((CHAR*) Address),1 );

						//
						//   If the caller want to know the
						//   real size them we supply it.
						//
						if ( Space != NULL )
							{ (*Space) = CacheStack -> Space; }

						//
						//   If we need to zero the allocation
						//   we do it here.
						//
						if ( Zero )
							{ ZeroMemory( Address,CacheStack -> Space ); }

						return Address;
						}
					}
				else
					{
					//
					//   Activate the cache stack for next 
					//   time.
					//
					ActivateCacheStack( CacheStack ); 
					}
				}
			}
		else
			{
			//
			//   Create a thread cache for next time.
			//
			CreateThreadCache(); 
			}
		}

	//
	//   If all else fails call the heap directly and
	//   return the result.
	//
	return (ROCKALL::New( Size,Space,Zero ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search all local caches.		                                */
    /*                                                                  */
    /*   Search the local per thread caches by for an address so we     */
    /*   know whether it is available.                                  */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchAllThreadCaches( void *Address,int Size )
	{
	REGISTER LIST *Current;
	REGISTER bool Result = False;

	//
	//   Claim a process wide lock.
	//
	Sharelock.ClaimShareLock();

	//
	//   Walk the list of active caches.
	//
	for 
			( 
			Current = ActiveList -> First();
			((Current != NULL) && (! Result));
			Current = Current -> Next()
			)
		{
		//
		//   Search each per thread cache.
		//
		Result =
			(
			SearchThreadCache
				( 
				Address,
				Size,
				((THREAD_CACHE*) Current)
				)
			); 
		}

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search a local cache.                                          */
    /*                                                                  */
    /*   Search a local per thread cache for a memory allocation.       */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchThreadCache
		( 
		void						  *Address,
		int							  Size,
		THREAD_CACHE				  *ThreadCache 
		)
	{
	//
	//   We would hope that there is a cache to search
	//   but just to be sure we verify it.
	//
	if ( ThreadCache != NULL )
		{
		//
		//   The per thread cache can only slave 
		//   certain allocation sizes.  If the size 
		//   is out of range then skip the search. 
		//
		if ( (Size > 0) && (Size < MaxSize2) )
			{
			REGISTER CACHE_STACK *CacheStack = 
				(FindCache( Size,ThreadCache ));

			return (SearchCacheStack( Address,CacheStack ));
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search a cache stack.                                          */
    /*                                                                  */
    /*   Search a cache stack for an allocation address.                */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchCacheStack( void *Address,CACHE_STACK *CacheStack )
    {
	//
	//   There is a chance that this cache is not active. 
	//   If so we skip the cache flush.
	//
	if ( CacheStack -> Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Search for the address.
		//
		for ( Count=(CacheStack -> Top-1);Count >= 0;Count -- )
			{
			//
			//   If the address matches exit.
			//
			if ( Address == CacheStack -> Stack[ Count ] )
				{ return True; }
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Truncate( int MaxFreeSpace )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Flush all the local caches.
		//
		FlushAllThreadCaches();

		//
		//   Delete the current cache.
		//
		DeleteThreadCache();
		}

	//
	//   Truncate the heap.
	//
	return (ROCKALL::Truncate( MaxFreeSpace ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Verify( void *Address,int *Space )
    {
	AUTO int Size;

	//
	//   Extract information about the memory 
	//   allocation.
	//
	if ( ROCKALL::Verify( Address,& Size ) )
		{
		//
		//   If the caller requested the allocation
		//   size then return it.
		//
		if ( Space != NULL )
			{ (*Space) = Size; }

		//
		//   Although it is very rare there is a 
		//   chance that we failed to build the 
		//   basic heap structures.
		//
		if ( Active )
			{
			//
			//   Search for the allocation in the
			//   local per thread caches.
			//
			return (! SearchAllThreadCaches( Address,Size ));
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Walk( bool *Activity,void **Address,int *Space )
    {
	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Activity,Address,Space ) )
		{
		//
		//   Although it is very rare there is a 
		//   chance that we failed to build the 
		//   basic heap structures.
		//
		if ( Active )
			{
			//
			//   Search for the allocation in the
			//   local per thread caches.
			//
			(*Activity) = (! SearchAllThreadCaches( Address,(*Space) ));
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a local cache.                                          */
    /*                                                                  */
    /*   Delete a local per thread cache and return all the outstanding */
    /*   allocations to the main heap.                                  */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::DeleteThreadCache( void )
	{
	REGISTER THREAD_CACHE *ThreadCache = 
		((THREAD_CACHE*) Tls -> GetPointer());

	//
	//   We would certainly expect to have a cache
	//   to delete but we check just to be sure.
	//
	if ( ThreadCache != NULL )
		{
		//
		//   Flush the cache.
		//
		FlushThreadCache( ThreadCache );

		//
		//   We have finished with the cache so
		//   add it to the list of free caches
		//   so we can find it again later.
		//
		Sharelock.ClaimExclusiveLock();

		ThreadCache -> Delete( ActiveList );
		ThreadCache -> Insert( FreeList );

		Sharelock.ReleaseExclusiveLock();

		//
		//   Delete the threads private cache
		//   pointer so it can no longer find
		//   the cache.
		//
		Tls -> SetPointer( NULL ); 
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::~SMP_HEAP( void )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Deactivate the cache.
		//
		Active = False;

		FlushAllThreadCaches();

		//
		//   Call the list and TLS destructors.
		//
		PLACEMENT_DELETE( Tls,THREAD_LOCAL_STORE );
		PLACEMENT_DELETE( FreeList,LIST );
		PLACEMENT_DELETE( ActiveList,LIST );
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\smpheap.hpp ===
#ifndef _SMP_HEAP_HPP_
#define _SMP_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class LIST;
class THREAD_LOCAL_STORE;

struct CACHE_STACK;
struct THREAD_CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   A SMP heap.                                                    */
    /*                                                                  */
    /*   A SMP heap is optimized for SMP performance.  Each thread      */
    /*   is given its own private cache of memory allocations which     */
    /*   it can access without claiming a lock.                         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMP_HEAP : public ROCKALL
    {
		//
		//   Private data.
		//
		bool						  Active;

		int							  MaxCaches1;
		int							  MaxCaches2;
		int							  MaxSize1;
		int							  MaxSize2;
		int							  ShiftSize1;
		int							  ShiftSize2;

		LIST						  *ActiveList;
		LIST						  *FreeList;
		THREAD_LOCAL_STORE			  *Tls;

   public:
        //
        //   Public functions.
        //
        SMP_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        ~SMP_HEAP( void );

   private:
		//
		//   Private functions.
		//
		void CreateThreadCache( void );

		void ActivateCacheStack( CACHE_STACK *CacheStack );

		CACHE_STACK *FindCache
			( 
			int						  Size,
			THREAD_CACHE			  *ThreadCache 
			);

		void FlushAllThreadCaches( void );

		void FlushThreadCache( THREAD_CACHE *ThreadCache );

		void FlushCacheStack( CACHE_STACK *CacheStack );

		bool SearchAllThreadCaches
			( 
			void					  *Address,
			int						  Size 
			);

		bool SearchThreadCache
			( 
			void					  *Address,
			int						  Size,
			THREAD_CACHE			  *ThreadCache 
			);

		bool SearchCacheStack
			( 
			void					  *Address,
			CACHE_STACK				  *CacheStack 
			);

		void DeleteThreadCache( void );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMP_HEAP( const SMP_HEAP & Copy );

        void operator=( const SMP_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\smallheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "SmallHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::SMALL_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::~SMALL_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\windowsheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#include "Global.hpp"
#include "New.hpp"
#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here are for common values.             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoHeapSize				  = -1;
CONST SBIT32 ResizeDown				  = -64;
CONST SBIT32 StandardSize			  = (1024 * 1024);

    /********************************************************************/
    /*                                                                  */
    /*   Data structures local to the class.                            */
    /*                                                                  */
    /*   We need to keep various information along with the heap        */
    /*   so here we supply a structure to hold it all.                  */
    /*                                                                  */
    /********************************************************************/

typedef struct
    {
	DWORD							  Flags;
	DEFAULT_HEAP					  Rockall;
    }
WINDOWS_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Create a new heap.                                             */
    /*                                                                  */
    /*   Create a new heap and prepare it for use.  If any problems     */
    /*   are encountered the request is rejected.                       */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
		( 
		DWORD					  Flags,
		DWORD					  InitialSize,
		DWORD					  MaximumSize 
		)
	{
	//
	//   We do not support all the functionality with
	//   this interface so just reject any calls that
	//   require the unsupported features.
	//
	if ( MaximumSize <= 0 ) 
		{
		REGISTER WINDOWS_HEAP *WindowsHeap = 
#ifdef NO_DEFAULT_HEAP
			((WINDOWS_HEAP*) malloc( sizeof(WINDOWS_HEAP) ));
#else
			((WINDOWS_HEAP*) DefaultHeap.New( sizeof(WINDOWS_HEAP) ));
#endif

		//
		//   If we were unable to allocate space for  
		//   the root of the heap then we exit.
		//
		if ( WindowsHeap != NULL )
			{
			//
			//   Save the flags for later calls.
			//
			WindowsHeap -> Flags = Flags;

			//
			//   Call the heap constructor. 
			//
			PLACEMENT_NEW( & WindowsHeap -> Rockall,DEFAULT_HEAP ) 
				( 
				((SBIT32) (InitialSize + StandardSize)),
				True,
				False,
				((BOOLEAN) ((Flags & HEAP_NO_SERIALIZE) == 0))
				);

			//
			//   Ensure the heap is initialized correctly.
			//
			if ( ! WindowsHeap -> Rockall.Corrupt() )
				{ return ((HANDLE) WindowsHeap); }
			else
				{ free( WindowsHeap ); }
			}
		}

	return NULL;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocate memory. .                                             */
    /*                                                                  */
    /*   Create a new memory allocation and verify it works.  if        */
    /*   not then throw an exception or return a status.                */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapAlloc( HANDLE Heap,DWORD Flags,DWORD Size )
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.New
			( 
			Size,
			NULL,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compact the heap.                                              */
    /*                                                                  */
    /*   Compact the heap by returning any unallocated space to the     */
    /*   operating system.  This can prove to be very expensive if      */
    /*   the space is later reclaimed.                                  */
    /*                                                                  */
    /********************************************************************/

extern "C" UINT WindowsHeapCompact( HANDLE Heap,DWORD Flags )
	{
	//
	//   We instruct the heap to return any available
	//   space to the operating system.  If we later
	//   choose to regain this space it is very expensive
	//   so lets hope the user knew what he was doing.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.Truncate();

	return 1;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Free memory.                                                   */
    /*                                                                  */
    /*   Free a memory allocation so that the space may be recycled     */
    /*   for subsequent memory allocation requests.                     */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapFree( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	//
	//   We release the memory allocation if it belongs to us.
	//   If not then we simply fail the request.  Regardless,
	//   we are not negatively effected either way.
	//
	return ((BOOL) ((WINDOWS_HEAP*) Heap) -> Rockall.Delete( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Lock the heap.                                                 */
    /*                                                                  */
    /*   Lock the heap by claiming all of the associated heap locks.    */
    /*   All the locks associated with a heap help make the heap        */
    /*   scale well but are a big performance hit for this type of      */
    /*   request.                                                       */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapLock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.LockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reallocate memory.                                             */
    /*                                                                  */
    /*   Reallocate a portion of memory and possibly copy the data      */
    /*   to the enlarged memory area.                                   */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapReAlloc
		( 
		HANDLE					  Heap,
		DWORD					  Flags,
		LPVOID					  Memory,
		DWORD					  Size 
		)
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.Resize
			( 
			Memory,
			Size,
			((AllFlags & HEAP_REALLOC_IN_PLACE_ONLY) ? 0 : ResizeDown),
			false,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the heap.                                                */
    /*                                                                  */
    /*   Delete all outstanding memory allocations while leaving        */
    /*   the structure of the heap in place ready for new memory        */
    /*   allocation requests.                                           */
    /*                                                                  */
    /********************************************************************/

extern "C" VOID WindowsHeapReset( HANDLE Heap )
	{
	//
	//   We have been asked to delete all the outstanding 
	//   memory allocations.  This is significant and costly
	//   process.  Nonetheless, the overhead is the same as
	//   around 20-30 delete requested so it can be worthwhile
	//   in a number of cases.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.DeleteAll(); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocation size.                                               */
    /*                                                                  */
    /*   Although Rockall optionally supplies the allocation size       */
    /*   when a new allocation is requested.  Nonetheless, this has     */
    /*   to be done the hard way with other interfaces.                 */
    /*                                                                  */
    /********************************************************************/

extern "C" DWORD WindowsHeapSize( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	AUTO INT Size;

	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	if ( ((WINDOWS_HEAP*) Heap) -> Rockall.Details( Memory,& Size ) )
		{ return Size; }
	else
		{ return ((DWORD) NoHeapSize); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unlock the heap.                                               */
    /*                                                                  */
    /*   Unlock the heap and release all the associated heap locks.     */
    /*   The multiple locks that need to be released make this quite    */
    /*   an expensive request.                                          */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapUnlock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.UnlockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Validate the heap.                                             */
    /*                                                                  */
    /*   Validate the heap or a specific heap allocation to ensure      */
    /*   all is well.  We have to go to quite a bit of trouble to       */
    /*   figure this out so this call can be quite expensive.           */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapValidate( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{ 
	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	return (((WINDOWS_HEAP*) Heap) -> Rockall.Verify( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   Walk the heap and provide information about every allocated    */
    /*   and unallocated portion of memory.  Needless to say this is    */
    /*   typically a long process and the request is not cheap.         */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapWalk( HANDLE Heap,LPPROCESS_HEAP_ENTRY Walk )
	{
	AUTO bool Active;
	REGISTER BOOL Result =
		( 
		((WINDOWS_HEAP*) Heap) -> Rockall.Walk
			( 
			& Active,
			((void**) & Walk -> lpData),
			((int*) & Walk -> cbData)
			) 
		);

	//
	//   If we managed to find the next element we
	//   fill in all the other fields as needed.
	//
	if ( Result )
		{
		//
		//   Fill in all the addition fields just 
		//   to be compatible with the existing 
		//   functionality.
		//
		Walk -> cbOverhead = 0;
		Walk -> iRegionIndex = 0;
		Walk -> wFlags = 
			(
			(Active) 
				? ((WORD) PROCESS_HEAP_ENTRY_BUSY)
				: ((WORD) PROCESS_HEAP_UNCOMMITTED_RANGE)
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a heap.                                                 */
    /*                                                                  */
    /*   Delete a heap and release all the associated space.            */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapDestroy( HANDLE Heap )
	{
	if ( ! ((WINDOWS_HEAP*) Heap) -> Rockall.Corrupt() )
		{
		//
		//   We do not appear to have damaged the heap
		//   so it should be safe to delete it.
		//
		PLACEMENT_DELETE( & ((WINDOWS_HEAP*) Heap) -> Rockall,DEFAULT_HEAP );

#ifdef NO_DEFAULT_HEAP
		free( ((WINDOWS_HEAP*) Heap) );
#else
		DefaultHeap.Delete( ((WINDOWS_HEAP*) Heap) );
#endif

		return TRUE;
		}
	else
		{ return FALSE; }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void DeleteArea( void *Memory,int Size,bool User );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\zoneheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Assembly.hpp"
#include "Prefetch.hpp"
#include "Spinlock.hpp"
#include "ZoneHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 AlignmentMask			  = (sizeof(double)-1);
CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 1024;
CONST SBIT32 Stride2				  = 1024;
CONST SBIT32 ZonePageSize			  = 4096;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     4096,        8,    65536,    65536 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 2,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC PREFETCH Prefetch;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::ZONE_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	AUTO ZONE NewZone = { NULL,NULL };

	//
	//   Setup the heap structures.
	//
	MaxSize = ZonePageSize;
	ThreadLocks = ThreadSafe;
	Zone = NewZone;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete all the heap allocations and return all the space       */
    /*   back to the operating system.                                  */
    /*                                                                  */
    /********************************************************************/

void ZONE_HEAP::DeleteAll( bool Recycle )
    {
	AUTO ZONE Update = { NULL,NULL };

	//
	//   Delete all outstanding allocations.
	//
	ROCKALL::DeleteAll( Recycle );

	//
	//   Delete the stale zone pointers.
	//
	WriteZone( & Update );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   We simply call 'New' to create each element
	//   for a zone heap.
	//
	for ( (*Actual)=0;(*Actual) < Requested;(*Actual) ++ )
		{
		REGISTER VOID **Current = & Array[ (*Actual) ];

		//
		//   Create an allocation.
		//
		(*Current) = (ZONE_HEAP::New( Size,Space,Zero ));

		//
		//   Exit if there is no more space.
		//
		if ( (*Current) == NULL )
			{ return false; }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

void *ZONE_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   We would really hope that nobody would ask
	//   for a negative amount of memory but just to
	//   be sure we verify that this is not the case.
	//
	if ( Size >= 0 )
		{
		AUTO SBIT32 NewSize = ((Size + AlignmentMask) & ~AlignmentMask);
		AUTO ZONE Original;
		AUTO ZONE Update;

		//
		//   We would hope to create the allocation on the
		//   first try but there is a possibility that it
		//   may take serveral tries.
		do
			{
			//
			//   Extract a copy of the current zone pointers
			//   into local variables.
			//
			Original = Zone;
			Update = Original;

			//
			//   We need to ensure that there is enough space 
			//   in the zone for the current allocation.
			//
			if 
					( 
					(Update.Start == NULL)
						||
					((Update.Start += NewSize) > Update.End)
					)
				{
				//
				//   We do not have enough space.  If the size
				//   seems reasonable then get a new block from
				//   Rockall.  If not just pass the request along 
				//   to Rockall.
				//
				if ( NewSize <= (MaxSize / 2) )
					{
					STATIC SPINLOCK Spinlock;

					//
					//   We need to create a new zone page
					//   so claim a lock.
					//
					Spinlock.ClaimLock();

					//
					//   We may find that the zone has
					//   already been updated.  If so
					//   just exit.
					//
					if ( Update.End == Zone.End )
						{
						//
						//   Try to allocate a new zone
						//   block.
						//
						Update.Start = ((CHAR*) ROCKALL::New( MaxSize ));

						//
						//   Verify we were able to create
						//   a new zone page.
						//
						if ( Update.Start != NULL )
							{ Update.End = (Update.Start + MaxSize); }
						else
							{ Update.End = NULL; }

						//
						//   Update the zone.
						//
						WriteZone( & Update );
						}

					//
					//   Release the lock.
					//
					Spinlock.ReleaseLock();

					//
					//   If we were unable to get more
					//   space then exit.
					//
					if ( Update.Start == NULL )
						{ return NULL; }
					}
				else
					{ return (ROCKALL::New( Size,Space,Zero )); }
				}
			}
		while ( ! UpdateZone( & Original,& Update ) );

		//
		//   Prefetch the first cache line of  
		//   the allocation if we are running
		//   a Pentium III or better.
		//
		Prefetch.L1( ((CHAR*) Original.Start),1 );

		//
		//   If the caller wants to know the real 
		//   size them we supply it.
		//
		if ( Space != NULL )
			{ (*Space) = NewSize; }

		//
		//   If we need to zero the allocation
		//   we do it here.
		//
		if ( Zero )
			{ ZeroMemory( Original.Start,NewSize ); }

		//
		//   Exit and return the address.
		//
		return (Original.Start);
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the zone.                                               */
    /*                                                                  */
    /*   Ww update the zone when we do an allocation.  We do this       */
    /*   atomically if there are multiple threads.                      */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::UpdateZone( ZONE *Original,ZONE *Update )
    {
	//
	//   Do we need to allow for multiple threads.  If 
	//   so we need to do the update atomically.  If 
	//   not then a simple assignment is fine.
	//
	if ( ThreadLocks )
		{
		REGISTER SBIT64 FinalValue =
			(
			ASSEMBLY::AtomicCompareExchange64
				(
				((SBIT64*) & Zone),
				(*((SBIT64*) Update)),
				(*((SBIT64*) Original))
				) 
			);

		return (FinalValue == (*((SBIT64*) Original)));
		}
	else
		{
		Zone = (*Update);

		return True;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::~ZONE_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\align.hpp ===
#ifndef _ALIGN_HPP_
#define _ALIGN_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Alignment of structures to cache line boundaries.              */
    /*                                                                  */
    /*   This class aligns data structures to cache line boundaries.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class ALIGN
    {
        //
        //   Private data.
        //
        TYPE                          *Aligned;
        CHAR                          *Allocated;

    public:
        //
        //   Public functions.
        //
        ALIGN( VOID );

        ~ALIGN( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE *operator&( VOID )
			{ return Aligned; }

	private:
        //
        //   Disabled operations.
        //
        ALIGN( CONST ALIGN & Copy );

        VOID operator=( CONST ALIGN & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */        
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::ALIGN( VOID )
    {
    REGISTER CHAR *Address;

	//
	//   Allocate space for the data structure.
	//
	Allocated = new CHAR[ (CacheLineSize + sizeof(TYPE)) ];

	//
	//   Call the constructor to initialize the structure.
	//
    Address = ((CHAR*) ((((LONG) Allocated) + CacheLineMask) & ~CacheLineMask));

    Aligned = PLACEMENT_NEW( Address,TYPE );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the memory allocation.  This call is not thread safe   */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::~ALIGN( VOID )
    { 
	//
	//   Call the destructor for the allocated type.
	//
    PLACEMENT_DELETE( Aligned,TYPE );

	//
	//   Delete the data structure.
	//
	delete [] Allocated; 
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\assembly.hpp ===
#ifndef _ASSEMBLY_HPP_
#define _ASSEMBLY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The assembly constants indicate the location of the thread     */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

#define PcTeb                         0x18
#define IDTeb                         0x24

#ifdef WINDOWS_95
CONST SBIT32 TebSlot				  = 0x88;
#else
CONST SBIT32 TebSlot				  = 0xE10;
#endif

#ifndef ASSEMBLY_PREFETCH_SUPPORT
#define prefetcht0					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x08
#define prefetcht1					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x10
#define prefetcht2					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x18
#define prefetchnta					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x00
#endif

#pragma warning( disable : 4035 )

    /********************************************************************/
    /*                                                                  */
    /*   Assembly language for ultra high performance.                  */
    /*                                                                  */
    /*   We have coded a few functions in assembly language for         */
    /*   ultra high performance.                                        */
    /*                                                                  */
    /********************************************************************/

class ASSEMBLY
    {
    public:
        //
        //   Public inline functions.
        //
		ASSEMBLY( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 AtomicAdd
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		eax,Value					// Load the value.
				lock	xadd dword ptr[ecx],eax		// Increment the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchangeAdd
					( 
					((LPLONG) Address),
					((LONG) Value) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicCompareExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		edx,NewValue				// Load the new value.
				mov		eax,Value					// Load the value.
				lock	cmpxchg	dword ptr[ecx],edx	// Update the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedCompareExchange
					( 
					((VOID**) Address),
					((VOID*) NewValue),
					((VOID*) Value)
					)
				);
#endif
			}
#ifdef ASSEMBLY_X86

		STATIC INLINE SBIT64 AtomicCompareExchange64
				( 
				VOLATILE SBIT64		  *Address,
				SBIT64				  NewValue,
				SBIT64				  Value 
				)
			{
			__asm
				{
				mov		esi, Address				// Load the adrress.
				mov		ebx, dword ptr NewValue[0]	// Load the new value.
				mov		ecx, dword ptr NewValue[4]	// Load the new value.
				mov		eax, dword ptr Value[0]		// Load the value.
				mov		edx, dword ptr Value[4]		// Load the value.
				lock	cmpxchg8b [esi]				// Update the value.
				}
			}
#endif

		STATIC INLINE SBIT32 AtomicDecrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,-1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Decrement value.
				dec		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedDecrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 AtomicExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,NewValue				// Load the value.
				lock	xchg dword ptr[ecx],eax		// Exchange new value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchange
					( 
					((LONG*) Address),
					((LONG) NewValue) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicIncrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Increment value.
				inc		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedIncrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 GetThreadId( VOID )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,fs:[PcTeb]				// Load TEB base address.
				mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
				}
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
			}

		STATIC INLINE VOID PrefetchL1( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht0	[eax]					// Prefetch into the L1.
#else
				prefetcht0							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL2( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht1	[eax]					// Prefetch into the L2.
#else
				prefetcht1							// Prefetch into the L2.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL3( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht2	[eax]					// Prefetch into the L3.
#else
				prefetcht2							// Prefetch into the L3.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchNta( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetchnta	[eax]					// Prefetch into the L1.
#else
				prefetchnta							// Prefetch into the L1.
#endif
				}
#endif
			}

#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
		STATIC INLINE VOID *GetTlsAddress( SBIT32 TlsOffset )
			{
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				}
			}
#endif
#endif

		STATIC INLINE VOID *GetTlsValue( SBIT32 TlsIndex,SBIT32 TlsOffset )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		eax,[eax]					// Load TLS value.
				}
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
			}

		STATIC INLINE VOID SetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset,
				VOID				  *NewPointer 
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		edx,NewPointer				// Load new TLS value.
				mov		[eax],edx					// Store new TLS value.
				}
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
			}

		~ASSEMBLY( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        ASSEMBLY( CONST ASSEMBLY & Copy );

        VOID operator=( CONST ASSEMBLY & Copy );
    };

#pragma warning( default : 4035 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\interface\zoneheap.hpp ===
#ifndef _ZONE_HEAP_HPP_
#define _ZONE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

#pragma warning( disable : 4100 )

    /********************************************************************/
    /*                                                                  */
    /*   A zone heap.                                                   */
    /*                                                                  */
    /*   A zone heap simply allocates a large amount of space and       */
    /*   allocates space by advancing a pointer down an array.          */
    /*   There is no way to free space except by deleting it all.       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ZONE_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			char					  *Start;
			char					  *End;
			}
		ZONE;

		//
		//   Private data.
		//
		int 						  MaxSize;
		bool						  ThreadLocks;
		ZONE						  Zone;

   public:
        //
        //   Public functions.
        //
        ZONE_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
				( 
				void				  *Address,
				int					  Size = NoSize 
				)
			{ return false; }

		virtual bool Details
				( 
				void				  *Address,
				int					  *Space = NULL 
				)
			{ return false; }

		virtual bool MultipleDelete
				( 
				int					  Actual,
				void				  *Array[],
				int					  Size = NoSize
				)
			{ return false; }

		virtual bool MultipleNew
				( 
				int					  *Actual,
				void				  *Array[],
				int					  Requested,
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *New
				( 
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *Resize
				( 
				void				  *Address,
				int					  NewSize,
				int					  Move = -64,
				int					  *Space = NULL,
				bool				  NoDelete = false,
				bool				  Zero = false
				)
			{ return NULL; }

		virtual bool Verify
				( 
				void				  *Address = NULL,
				int					  *Space = NULL 
				)
			{ return false; }

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
				(
				bool				  *Active,
				void				  **Address,
				int					  *Space
				)
			{ return false; }

        ~ZONE_HEAP( void );

	private:
		//
		//   Private functions.
		//
		bool UpdateZone( ZONE *Original,ZONE *Update );

		//
		//   Private inline functions.
		//
		void WriteZone( ZONE *Update )
			{
			auto ZONE Original = Zone;

			while ( ! UpdateZone( & Original,Update ) ) 
				{ Original = Zone; }
			}

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ZONE_HEAP( const ZONE_HEAP & Copy );

        void operator=( const ZONE_HEAP & Copy );
    };

#pragma warning( default : 4100 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\barrier.hpp ===
#ifndef _BARRIER_HPP_
#define _BARRIER_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A control barrier.                                             */
    /*                                                                  */
    /*   This class synchronizs a collection of threads.                */
    /*                                                                  */
    /********************************************************************/

class BARRIER
    {
        //
        //   Private data.
        //
        HANDLE                        Semaphore;
	    SPINLOCK					  Spinlock;
        VOLATILE LONG                 Waiting;

    public:
        //
        //   Public functions.
        //
        BARRIER( VOID );

        VOID Synchronize( SBIT32 Expecting );

        ~BARRIER( VOID );

	private:
        //
        //   Disabled operations.
        //
        BARRIER( CONST BARRIER & Copy );

        VOID operator=( CONST BARRIER & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\barrier.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Barrier.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new barrier and initialize it.  This call is not      */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

BARRIER::BARRIER( VOID )
    {
    Waiting = 0;

    if ( (Semaphore = CreateSemaphore( NULL,0,MaxCpus,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for BARRIER" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Synchronize Threads.                                           */
    /*                                                                  */
    /*   Synchronize a collection of threads.                           */
    /*                                                                  */
    /********************************************************************/

VOID BARRIER::Synchronize( SBIT32 Expecting )
    {
	//
	//   We make sure we are expecting at least two threads.
	//   If not then do nothing.
	//
	if ( Expecting > 1 )
		{
		//
		//   Cliam the lock.
		//
		Spinlock.ClaimLock();

		//
		//   We see if the required number of threads has
		//   arrived.
		//
		if ( Expecting > (++ Waiting) )
			{
			//
			//   We are about to sleep so drop the lock.
			//
			Spinlock.ReleaseLock();

			//
			//   The threads sleep here waiting for everyone 
			//   else to arrive.
			//
			if 
					( 
					WaitForSingleObject( Semaphore,INFINITE ) 
						!= 
					WAIT_OBJECT_0 
					)
				{ Failure( "Sleep failed in Synchronize()" ); }
			}
		else
			{
			REGISTER SBIT32 Wakeup = (Expecting-1);

			//
			//   The count of threads that have arrived is
			//   updated and the number of threads that are
			//   about to leave is updated.
			//
			Waiting -= Expecting;

			//
			//   We are about to wake up all the sleepers so 
			//   drop the lock.
			//
			Spinlock.ReleaseLock();

			//
			//   Wakeup any sleeping threads and exit.
			//
			if ( Wakeup > 0 )
				{
				if ( ! ReleaseSemaphore( Semaphore,Wakeup,NULL ) )
					{ Failure( "Wakeup failed in Synchronize()" ); }
				}
			}
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a barrier.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

BARRIER::~BARRIER( VOID )
    {
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for BARRIER" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\common.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Common.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Convert a divisor to a shift.                                  */
    /*                                                                  */
    /*   We know that we can convert any divide operation into a        */
    /*   shift when the divisor is a power of two.  This function       */
    /*   figures out whether we can do this and what the how far        */
    /*   we would need to shift.                               .        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift )
	{
	if ( Divisor > 0 )
		{
		REGISTER SBIT32 Count;

		for ( Count=0;(Divisor & 1) == 0;Count ++ )
			{ Divisor >>= 1; }

		if (Divisor == 1)
			{
			(*Shift) = Count;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Force to the next power of two.                                */
    /*                                                                  */
    /*   We know that we can do certain optimizations if certain        */
    /*   values are a power of two.  Here we force the issue by         */
    /*   rounding up the value to the next power of two.                */
    /*                                                                  */
    /********************************************************************/

SBIT32 COMMON::ForceToPowerOfTwo( SBIT32 Value )
	{
	//
	//   We ensure the value is positive if not we 
	//   simply return the identity value.
	//
	if ( Value > 1 )
		{
		//
		//   We only have to compute the next power of
		//   two if the value is not already a power
		//   of two.
		//
		if ( ! PowerOfTwo( Value ) )
			{
			REGISTER SBIT32 Count;

			for ( Count=0;Value > 0;Count ++ )
				{ Value >>= 1; }

			return (1 << Count);
			}
		else
			{ return Value; }
		}
	else
		{ return 1; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert all characters to lower case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to lower case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Ensure value is a power of two.                                */
    /*                                                                  */
    /*   We need to ensure that certain values are an exact power       */
    /*   of two.  If this is true then the value will be positive       */
    /*   and only 1 bit will be set.  So we shift right until we        */
    /*   find the first bit on and then the value should be one.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::PowerOfTwo( SBIT32 Value )
	{ return ((Value & (Value-1)) == 0); }
#ifndef DISABLE_ATOMIC_FLAGS

    /********************************************************************/
    /*                                                                  */
    /*   Atomically set flags.                                          */
    /*                                                                  */
    /*   We need to atomically set some flags to prevent them being     */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags |= NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Atomically unset flags.                                        */
    /*                                                                  */
    /*   We need to atomically unset some flags to prevent them being   */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags &= ~NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert all characters to upper case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to upper case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\autolock.hpp ===
#ifndef _AUTOLOCK_HPP_
#define _AUTOLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Automatic sharelock control.                                   */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a share lock for the duration of a block     */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_EXCLUSIVE_LOCK
    {
		//
		//   Private data.
		//
		SHARELOCK					  *Sharelock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_EXCLUSIVE_LOCK( SHARELOCK *NewSharelock,SBIT32 Sleep = INFINITE )
			{ (Sharelock = NewSharelock) -> ClaimExclusiveLock( Sleep ); }

        ~AUTO_EXCLUSIVE_LOCK( VOID )
			{ Sharelock -> ReleaseExclusiveLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_EXCLUSIVE_LOCK( CONST AUTO_EXCLUSIVE_LOCK & Copy );

        VOID operator=( CONST AUTO_EXCLUSIVE_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Automatic sharelock control.                                   */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a share lock for the duration of a block     */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_SHARE_LOCK
    {
		//
		//   Private data.
		//
		SHARELOCK					  *Sharelock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_SHARE_LOCK( SHARELOCK *NewSharelock,SBIT32 Sleep = INFINITE )
			{ (Sharelock = NewSharelock) -> ClaimShareLock( Sleep ); }

        ~AUTO_SHARE_LOCK( VOID )
			{ Sharelock -> ReleaseShareLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_SHARE_LOCK( CONST AUTO_SHARE_LOCK & Copy );

        VOID operator=( CONST AUTO_SHARE_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Automatic spinlock control.                                    */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a spin lock for the duration of a block      */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_SPIN_LOCK
    {
		//
		//   Private data.
		//
		SPINLOCK					  *Spinlock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_SPIN_LOCK( SPINLOCK *NewSpinlock,SBIT32 Sleep = INFINITE )
			{ (Spinlock = NewSpinlock) -> ClaimLock( Sleep ); }

        ~AUTO_SPIN_LOCK( VOID )
			{ Spinlock -> ReleaseLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_SPIN_LOCK( CONST AUTO_SPIN_LOCK & Copy );

        VOID operator=( CONST AUTO_SPIN_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\common.hpp ===
#ifndef _COMMON_HPP_
#define _COMMON_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A collection of common functions.                              */
    /*                                                                  */
    /*   This class contains common functions that are needed           */
    /*   throughout the application.                                    */
    /*                                                                  */
    /********************************************************************/

class COMMON : public ASSEMBLY
    {
    public:
        //
        //   Public functions.
        //
		COMMON( VOID )
			{ /* void */ }

		STATIC BOOLEAN ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift );

		STATIC SBIT32 ForceToPowerOfTwo( SBIT32 Value );

		STATIC CHAR *LowerCase( CHAR *Text );

		STATIC CHAR *LowerCase( CHAR *Text,SBIT32 Size );

		STATIC BOOLEAN PowerOfTwo( SBIT32 Value );
#ifndef DISABLE_ATOMIC_FLAGS

		STATIC VOID SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC VOID UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC CHAR *UpperCase( CHAR *Text );

		STATIC CHAR *UpperCase( CHAR *Text,SBIT32 Size );
#endif

		~COMMON( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        COMMON( CONST COMMON & Copy );

        VOID operator=( CONST COMMON & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\delay.hpp ===
#ifndef _DELAY_HPP_
#define _DELAY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The delay constants specify the initial size of the array      */
    /*   containing the list of allocations to be deleted.              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 BlockSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Delayed memory deletion.                                       */
    /*                                                                  */
    /*   This class provides general purpose memory delayed memory      */
    /*   deletion mechanism.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class DELAY : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Used;

        TYPE                          **Block;

    public:
        //
        //   Public functions.
        //
        DELAY( SBIT32 NewMaxSize = BlockSize );

        VOID DeferedDelete( TYPE *Memory );

        ~DELAY( VOID );

		//
		//   Public inline functions.
		//
        INLINE CONST TYPE **AllocationList( VOID )
			{ return ((CONST TYPE**) Block); };

        INLINE SBIT32 SizeOfBlock( VOID ) 
			{ return Used; }

    private:
        //
        //   Disabled operations.
        //
        DELAY( CONST DELAY & Copy );

        VOID operator=( CONST DELAY & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new block and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::DELAY( SBIT32 NewMaxSize ) 
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Used = 0;

        Block = new TYPE* [ NewMaxSize ];
#ifdef DEBUGGING
        }
    else
        { Failure( "Max size in constructor for DELAY" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Defered delete for an allocated memory block.                  */
    /*                                                                  */
    /*   An allocated memory block is registered for deletion by        */
    /*   the class destructor.                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID DELAY<TYPE,LOCK>::DeferedDelete
		( 
		TYPE						  *Memory 
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Make sure we have enough space to register this memory 
	//   block for later deletion.  If not allocate more space 
	//   and copy the existing data into the enlarged space.
	//
    if ( Used >= MaxSize )
        {
        REGISTER SBIT32 Count;
        REGISTER TYPE **NewBlock = new TYPE* [ (MaxSize *= ExpandStore) ];

        for ( Count=0;Count < Used;Count ++ )
            { NewBlock[ Count ] = Block[ Count ]; }

        delete [] Block;

        Block = NewBlock;
        }

	//
	//   Register the allocated memory block.
	//
    Block[ Used ++ ] = Memory;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an allocation.  This call is not thread safe and       */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::~DELAY( VOID )
    {
    REGISTER SBIT32 Count;

	//
	//   Delete the allocated memory blocks.
	//
    for ( Count = (Used - 1);Count >= 0;Count -- )
        { delete Block[ Count ]; }

    delete [] Block;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\environment.hpp ===
#ifndef _ENVIRONMENT_HPP_
#define _ENVIRONMENT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Environment configuration values.                              */
    /*                                                                  */
    /*   This class provides a information about the environment.       */
    /*   The information can be accessed repeatedly with very little    */
    /*   cost as the data is slaved in static memory.                   */
    /*                                                                  */
    /********************************************************************/

class ENVIRONMENT : public ASSEMBLY
    {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		//
		//   Private structures.
		//
		typedef struct
			{
			CHAR					  *Name;
			SBIT32                    SizeOfName;
			CHAR                      *Value;
			SBIT32                    SizeOfValue;
			} 
		VARIABLE;

#endif
        //
        //   Private data.
        //
        STATIC SBIT32		          Activations;

		STATIC SBIT32                 AllocationGranularity;
        STATIC SBIT16                 NumberOfProcessors;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		STATIC CHAR                   *ProgramName;
		STATIC CHAR                   *ProgramPath;
#endif
		STATIC SBIT32                 SizeOfMemory;
		STATIC SBIT32                 SizeOfPage;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC SBIT32                 MaxVariables;
		STATIC SBIT32                 VariablesUsed;
		STATIC VARIABLE               *Variables;
#endif

    public:
        //
        //   Public functions.
        //
        ENVIRONMENT( VOID );
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC CONST CHAR *ReadEnvironmentVariable( CONST CHAR *Name );
#endif

        ~ENVIRONMENT( VOID );

		//
		//   Public inline functions.
		//
		STATIC INLINE  SBIT32 AllocationSize(VOID ) 
			{ return AllocationGranularity; };
	
		STATIC INLINE SBIT32 CacheAlignSize( SBIT32 Size )
			{ return ((Size + CacheLineMask) & ~CacheLineMask); }

		STATIC INLINE CONST CHAR *DirectorySeperator( VOID ) 
			{ return "\\"; };

        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return NumberOfProcessors; }

		STATIC INLINE SBIT32 MemorySize( VOID ) 
			{ return SizeOfMemory; };

		STATIC INLINE SBIT32 PageSize( VOID ) 
			{ return SizeOfPage; };
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC INLINE CONST CHAR *ProgramFileName( VOID ) 
			{ return ((CONST CHAR*) ProgramName); };

		STATIC INLINE CONST CHAR *ProgramFilePath( VOID ) 
			{ return ((CONST CHAR*) ProgramPath); };
#endif

	private:
        //
        //   Disabled operations.
        //
        ENVIRONMENT( CONST ENVIRONMENT & Copy );

        VOID operator=( CONST ENVIRONMENT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\features.hpp ===
#ifndef _FEATURES_HPP_
#define _FEATURES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Active project list.	 							            */
    /*                                                                  */
    /*   The active project list contains all of the projects that      */
    /*   are currently selected.                                        */
    /*                                                                  */
    /********************************************************************/

#define ROCKALL_II					  1

    /********************************************************************/
    /*                                                                  */
    /*   Active fetaure lists.	 							            */
    /*                                                                  */
    /*   The active features list contain all of the features that      */
    /*   are currently selected for each project.                       */
    /*                                                                  */
    /********************************************************************/

#ifdef PIPELINE_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_II
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_HEAP_STATISTICS        1
#endif
#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_GLOBAL_NEW			  1
#endif

#ifdef WEB_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The complete feature list.							            */
    /*                                                                  */
    /*   The code supports a significant number of optional features    */
    /*   which are listed in this file.  Any feature can be activated   */
    /*   by copying the approriate setting.  Please be sure to keep     */
    /*   all the flags up to date and leave at list one copy of each    */
    /*   flag below.                                                    */
    /*                                                                  */
    /********************************************************************/

#ifdef ACTIVATE_ALL_OPTIONS
	//
	//   Standard options for all code.
	//
#define ASSEMBLY_X86				  1
#define DEBUGGING                     1

#define DISABLE_GLOBAL_NEW			  1
#define DISABLE_PRECOMPILED_HEADERS	  1
#define DISABLE_STRUCTURED_EXCEPTIONS 1

	//
	//   Standard options for the library code.
	//
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#define ENABLE_RECURSIVE_LOCKS		  1

#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_STRING_LOCKS		  1

	//
	//   Rockall specific options.
	//
#define COMPILING_ROCKALL_DLL		  1
#define COMPILING_ROCKALL_LIBRARY	  1
#define ENABLE_ALLOCATION_STATISTICS  1
#define ENABLE_HEAP_STATISTICS        1
#define NO_DEFAULT_HEAP				  1

	//
	//   Pipeline Server specific options.
	//
#define ENABLE_BUFFER_LOCK			  1
#define ENABLE_ZERO_WRITE_BUFFER	  1

#define PRINT_ACTIVE_PACKETS		  1

	//
	//   Pipeline Server demo specific options.
	//
#define ENABLE_DATABASE				  1
#define ENABLE_READING				  1
#define ENABLE_TRANSACTIONS			  1
#define ENABLE_WRITING				  1

	//
	//   Web Server specific options.
	//
#define DISABLE_ASYNC_IO			  1
#define DISABLE_BUFFER_COPY			  1
#define DISABLE_WEB_LOCKS			  1
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\hash.hpp ===
#ifndef _HASH_HPP_
#define _HASH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Include files for inherited classes.                           */
    /*                                                                  */
    /*   The include files for inherited classes are required in the    */
    /*   specification of this class.                                   */
    /*                                                                  */
    /********************************************************************/

#include "Common.hpp"
#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Macros exported from this class.                               */
    /*                                                                  */
    /*   This class has three template parameters so to make it more    */
    /*   readable a macro is specified here to simplify the code.       */
    /*                                                                  */
    /********************************************************************/

#define HASH_TEMPLATE				  class KEY,class TYPE,class LOCK 

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the map.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HashSize				  = 1024;
CONST SBIT32 MinHashFree			  = (100/25);
CONST SBIT32 ValueSize				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Hash table.                                                    */
    /*                                                                  */
    /*   This class provides general purpose hash table functions to    */
    /*   safely map sparse integer keys into some pointer or value.     */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE=NO_LOCK> class HASH : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            KEY                       Key;
            SBIT32                    Next;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxHash;
        SBIT32                        MaxValues;
        SBIT32                        ValuesUsed;

		SBIT32						  Active;
        VECTOR<SBIT32>                Hash;
		SBIT32						  HashMask;
		SBIT32						  HashShift;
        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Values;

    public:
        //
        //   Public functions.
        //
        HASH
			( 
			SBIT32                    NewMaxHash = HashSize, 
			SBIT32                    NewMaxValues = ValueSize, 
			SBIT32                    Alignment = 1 
			);

        VOID AddToHash( CONST KEY & Key, CONST TYPE & Value );

        VIRTUAL SBIT32 ComputeHashKey( CONST KEY & Key );

		BOOLEAN FindInHash( CONST KEY & Key, TYPE *Value );

		VIRTUAL BOOLEAN MatchingKeys( CONST KEY & Key1, CONST KEY & Key2 );

        VOID RemoveFromHash( CONST KEY & Key );

        ~HASH( VOID );

	private:
        //
        //   Private functions.
        //
		BOOLEAN FindHashKeyValue( CONST KEY & Key, SBIT32 **HashIndex );

		VOID Resize( VOID );

        //
        //   Disabled operations.
        //
        HASH( CONST HASH & Copy );

        VOID operator=( CONST HASH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new hash and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::HASH
		( 
		SBIT32						  NewMaxHash,
		SBIT32                        NewMaxValues,
		SBIT32                        Alignment
		) :
		//
		//   Call the constructors for the contained classes.
		//
		Hash( (COMMON::ForceToPowerOfTwo( NewMaxHash )),1,CacheLineSize ),
		FreeStack( (NewMaxValues / 2) ),
		Values( NewMaxValues,Alignment,CacheLineSize )
    {
    if 
			( 
			(NewMaxHash > 0) 
				&& 
			(
			COMMON::ConvertDivideToShift
				( 
				(COMMON::ForceToPowerOfTwo( NewMaxHash )),
				& HashMask 
				)
			)
				&&
			(NewMaxValues > 0) 
			)
        {
		REGISTER SBIT32 Count;

		//
		//   Setup the hash table size information.
		//
        MaxHash = (COMMON::ForceToPowerOfTwo( NewMaxHash ));
        MaxValues = NewMaxValues;
        ValuesUsed = 0;

		//
		//   Zero the control values compute the
		//   hash table shift values.
		//
		Active = 0;
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		for( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
        }
    else
        { Failure( "Max sizes in constructor for HASH" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add to the hash table.                                         */
    /*                                                                  */
    /*   We add an key to the hash table if it does not already exist.  */
    /*   Then we add (or update) the current value.  If the is not      */
    /*   space we expand the size of the 'Values' table.                */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::AddToHash
        (
		CONST KEY					  & Key,
        CONST TYPE					  & Value 
        )
    {
	AUTO SBIT32 *HashIndex;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	if ( ! FindHashKeyValue( Key, & HashIndex ) )
		{
		AUTO SBIT32 NewIndex;
		REGISTER VALUE *NewValue;

		//
		//   Extract a free element from the stack.
		//   If the stack is empty then allocated one
		//   from the array.
		//
		if ( ! FreeStack.PopStack( & NewIndex ) )
			{
			//
			//   If the array is full then resize it.
			//   We need to be careful here as a resize
			//   can change the address of the 'Values'
			//   array.
			//
			if ( (NewIndex = ValuesUsed ++) >= MaxValues  )
				{ Values.Resize( (MaxValues *= ExpandStore) ); }
			}

		//
		//   Add the new element into the hash table
		//   and link it into any overflow chains.
		//
		NewValue = & Values[ NewIndex ];

		Active ++;

		//
		//   Link in the new element.
		//
		NewValue -> Key = Key;
		NewValue -> Next = (*HashIndex);
		(*HashIndex) = NewIndex;
		NewValue -> Value = Value;
		}
	else
		{ Values[ (*HashIndex) ].Value = Value; }

	//
	//   If the hash table has grown too big we
	//   resize it.
	//
	if ( (Active + (MaxHash / MinHashFree)) > MaxHash )
		{ Resize(); }

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the hash key.       .                                  */
    /*                                                                  */
    /*   Compute a hash value from the supplied key.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> SBIT32 HASH<KEY,TYPE,LOCK>::ComputeHashKey
        (
		CONST KEY					  & Key
        )
	{
	//
	//   When the key is larger than an integer the we need 
	//   to do a bit more work.
	//
	if ( sizeof(KEY) > sizeof(SBIT32) )
		{
		REGISTER SBIT32 HighWord = ((SBIT32) (Key >> 32));
		REGISTER SBIT32 LowWord = ((SBIT32) Key);

		//
		//   We compute the hash key using both the high
		//   and low order words.
		//
		return
			(
			(HighWord * 2964557531)
				+
			(LowWord * 2964557531)
				+
			(HighWord + LowWord)
			);
		}
	else
		{ return ((((SBIT32) Key) * 2964557531) + ((SBIT32) Key)); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a key in the hash table.                                  */
    /*                                                                  */
    /*   Find a key in the hash table and return the associated value.  */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindInHash
        (
		CONST KEY					  & Key,
        TYPE						  *Value 
        )
    {
	AUTO SBIT32 *Index;
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the key in the hash table.
	//
	if ( (Result = FindHashKeyValue( Key,& Index )) )
		{ (*Value) = Values[ (*Index) ].Value; }

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the hash key value.                                       */
    /*                                                                  */
    /*   Find the value associated with the supplied hash key.          */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindHashKeyValue
        (
		CONST KEY					  & Key,
		SBIT32                        **Index
        )
	{
	REGISTER SBIT32 *Current;
	REGISTER VALUE *List;

	//
	//   Find the bucket in the hash table that should
	//   contain this key.
	//
	(*Index) = & Hash[ ((ComputeHashKey( Key ) >> HashShift) & HashMask) ];

	//
	//   Walk the overflow chain and look for the key.
	//
	for ( Current = (*Index);(*Current) != EndOfList;Current = & List -> Next )
		{
		List = & Values[ (*Current) ];

		//
		//   If the keys match we are out of here.
		//
		if ( MatchingKeys( Key,List -> Key ) )
			{
			(*Index) = Current;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hask keys.       .                                 */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::MatchingKeys
        (
		CONST KEY					  & Key1,
		CONST KEY					  & Key2
        )
	{ return (Key1 == Key2); }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a key from the hash table.                              */
    /*                                                                  */
    /*   The supplied key is removed from the hash table (if it exists) */
    /*   and the associated value is deleted.                           */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::RemoveFromHash
        (
		CONST KEY					  & Key
        )
    {
	AUTO SBIT32 *Index;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Find the key in the hash table..  If it 
	//   exists then delete it.
	//
	if ( FindHashKeyValue( Key,& Index ) )
		{
		Active --;

		FreeStack.PushStack( (*Index) );

		(*Index) = Values[ (*Index) ].Next;
		}

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the hash table.                                         */
    /*                                                                  */
    /*   The hash table is resized if it becomes more than 75% full     */
    /*   and all the keys are rehashed.                                 */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::Resize( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 List = EndOfList;

	//
	//   Walk the hash table and link all the active
	//   values into a single linked list.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{
		REGISTER SBIT32 Start = Hash[ Count ];

		//
		//   We know that some of the hash buckets may
		//   be empty so we skip these.
		//
		if ( Start != EndOfList )
			{
			REGISTER SBIT32 Last = Start;

			//
			//   Walk along the overflow chain until
			//   we find the end.
			//
			while ( Values[ Last ].Next != EndOfList )
				{ Last = Values[ Last ].Next; }
			
			//
			//   Add the list on the front of the new
			//   global list.
			//   
			Values[ Last ].Next = List;
			List = Start;
			}
		}

	//
	//   Resize the hash table.
	//
	Hash.Resize( (MaxHash *= ExpandStore) );

    if ( COMMON::ConvertDivideToShift( MaxHash,& HashMask ) )
        {
		REGISTER SBIT32 Count;

		//
		//   Update the shift values.
		//
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		//
		//   Zero the resized table.
		//  
		for ( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
		}
	else
		{ Failure( "Hash size in Resize" ); }

	//
	//   Rehash all the existing values.
	//
	while ( List != EndOfList )
		{
		AUTO SBIT32 *Index;
		REGISTER VALUE *Current = & Values[ List ];
		REGISTER SBIT32 Next = Current -> Next;

		if ( ! FindHashKeyValue( Current -> Key,& Index ) )
			{
			Current -> Next = (*Index);
			(*Index) = List;
			List = Next;
			}
		else
			{ Failure( "Duplicate hash key in Risize" ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the hash.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::~HASH( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\environment.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The enviroment class slaves various information to speed       */
    /*   up access to it.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 EnvironmentCacheSize	  = 16;
CONST SBIT32 SizeOfName				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
SBIT32 ENVIRONMENT::Activations = 0;
SBIT32 ENVIRONMENT::AllocationGranularity = 0;
SBIT16 ENVIRONMENT::NumberOfProcessors = 0;
SBIT32 ENVIRONMENT::SizeOfMemory = 0;
SBIT32 ENVIRONMENT::SizeOfPage = 0;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
CHAR *ENVIRONMENT::ProgramName = NULL;
CHAR *ENVIRONMENT::ProgramPath = NULL;
SBIT32 ENVIRONMENT::MaxVariables = 0;
SBIT32 ENVIRONMENT::VariablesUsed = 0;
ENVIRONMENT::VARIABLE *ENVIRONMENT::Variables = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new environment and initialize it if needed.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::ENVIRONMENT( VOID )
    {
    if ( AtomicIncrement( & Activations ) == 1 )
        {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		AUTO CHAR ProgramFullName[ SizeOfName ];
#endif
		AUTO MEMORYSTATUS MemoryStatus;
		AUTO SYSTEM_INFO SystemInformation;

		//
		//   Initialize the class members to reasonable default values.
		//
		GetSystemInfo( & SystemInformation );

		GlobalMemoryStatus( & MemoryStatus );

		AllocationGranularity = 
			((SBIT32) SystemInformation.dwAllocationGranularity);
		NumberOfProcessors = 
			((SBIT16) SystemInformation.dwNumberOfProcessors);
		SizeOfMemory = 
			((SBIT32) MemoryStatus.dwTotalPhys);
		SizeOfPage = 
			((SBIT32) SystemInformation.dwPageSize);
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		//
		//   Slave interesting values like the program name and path variable.
		//
		ProgramName = NULL;
		ProgramPath = NULL;

		MaxVariables = 0;
		VariablesUsed = 0;
		Variables = NULL;

		//
		//   Get the complete file name for the current program.
		//
		if ( GetModuleFileName( NULL,ProgramFullName,SizeOfName ) > 0 )
			{
			REGISTER SBIT16 Count = (SBIT16) strlen( (char*) ProgramFullName );
			REGISTER CHAR *Characters = & ProgramFullName[ Count ];

			//
			//   Scan backwards looking for the first directory seperator.  
			//   There is guaranteed to be at least one.
			//
			for 
				( 
				/* void */;
				((Count > 0) && ((*Characters) != (*DirectorySeperator())));
				Count --, Characters -- 
				);

			(*(Characters ++)) = '\0';

			//
			//   Allocate space for the directory path and copy the  
			//   path into the newly allocated area.
			//
			ProgramPath = new CHAR [ (strlen( ((char*) ProgramFullName) )+1) ];

			if ( ProgramPath != NULL )
				{
				(VOID) strcpy
					( 
					((char*) ProgramPath),
					((char*) ProgramFullName)
					); 
				}

			//
			//   Scan the program name backwards looking for a '.'.
			//
			for 
				( 
				Count = (SBIT16) strlen( (char*) Characters );
				((Count > 0) && (Characters[ Count ] != '.'));
				Count -- 
				);

			//
			//   Remove any trailing suffix from the program name 
			//   (i.e. '*.EXE').
			//
			if ( Count > 0 )
				{ Characters[ Count ] = '\0'; }

			//
			//   Allocate space for the program name and copy the name 
			//   into the newly allocated area.
			//
			ProgramName = new CHAR [ (strlen( ((char*) Characters) )+1) ];

			if ( ProgramName != NULL )
				{
				(void) strcpy
					( 
					((char*) ProgramName),
					((char*) Characters) 
					);
				}
			}
#endif
		}
	}
#ifndef DISABLE_ENVIRONMENT_VARIABLES

    /********************************************************************/
    /*                                                                  */
    /*   Read an environment variable.                                  */
    /*                                                                  */
    /*   When we read an environment value we want to make sure that    */
    /*   it never changes and gets slaved in memory.  This routine      */
    /*   implements this functionality.                                 */
    /*                                                                  */
    /********************************************************************/

CONST CHAR *ENVIRONMENT::ReadEnvironmentVariable( CONST CHAR *Name )
	{
	if ( Activations > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 SizeOfName = (SBIT32) strlen( (char*) Name );
		REGISTER VARIABLE *Variable;
		STATIC SPINLOCK Spinlock;

		//
		//   The environment variables can only be scanned by one CPU at 
		//   a time because a second CPU might reallocate the storage 
		//   and cause the first CPU to fail.
		//
		Spinlock.ClaimLock();

		//
		//   Examine all existing environment variables looking for a 
		//   match. If a match is found return it to the caller.
		//
		for 
				( 
				Count = VariablesUsed, Variable = Variables;
				Count > 0; 
				Count --, Variable ++ 
				)
			{
			if 
					( 
					(SizeOfName == Variable -> SizeOfName) 
						&& 
					(strcmp( (char*) Name,(char*) Variable -> Name ) == 0) 
					)
				{
				Spinlock.ReleaseLock();

				return (Variable -> Value);
				}
			}

		//
		//  If we have filled up our array so we need to make it bigger.
		//  So lets check for this now.
		//
		if ( VariablesUsed >= MaxVariables )
			{
			REGISTER VARIABLE *PreviousAllocation = Variables;

			if ( MaxVariables > 0 )
				{
				Variables = 
					(
					(VARIABLE*) realloc
						( 
						(VOID*) Variables,
						((MaxVariables *= ExpandStore) * sizeof(VARIABLE)) 
						)
					);
				}
			else
				{ Variables = new VARIABLE [ EnvironmentCacheSize ]; }

			//
			//   Lets make sure we were successful.  If not we restore 
			//   the previous pointer as it is still valid.
			//
			if ( Variables == NULL )
				{
				Variables = PreviousAllocation;

				Failure( "Expand memory in ReadEnvironmentVariable" );
				}
			}

		//
		//  We know that we have enough memory to allocate another element and 
		//  that we are the only CPU in this section of code so just add the 
		//  new variable.
		//
		Variable = & Variables[ VariablesUsed ++ ];

		Variable -> SizeOfName = 
			(SBIT32) strlen( (char*) Name );
		Variable -> SizeOfValue = 
			(SBIT32) GetEnvironmentVariable( (char*) Name,"",0 );

		Variable -> Name = new CHAR [ (Variable -> SizeOfName + 1) ];
		(VOID) strcpy( (char*) Variable -> Name,(char*) Name );

		if ( Variable -> SizeOfValue > 0 )
			{
			Variable -> Value = new CHAR [ (Variable -> SizeOfValue + 1) ];

			(VOID) GetEnvironmentVariable
				( 
				(char*) Name,
				(char*) Variable -> Value,
				(int) (Variable -> SizeOfValue + 1)
				);
			}
		else
			{ Variable -> Value = NULL; }

		Spinlock.ReleaseLock();

		return (Variable -> Value);
		}
	else
		{ return NULL; }
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an environment.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::~ENVIRONMENT( VOID )
	{
    if ( AtomicDecrement( & Activations ) == 0 )
		{
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		REGISTER SBIT32 Count;

		//
		//   Delete all of the environment variable names
		//   and values.
		//
		for ( Count = 0;Count < VariablesUsed;Count ++ )
			{
			REGISTER VARIABLE *Variable = & Variables[ Count ];

			delete [] Variable -> Name;

			if ( Variable -> Value != NULL )
				{ delete [] Variable -> Value; }
			}


		//
		//   Delete the environment array.
		//
		delete [] Variables;
		Variables = NULL;

		//
		//   Delete the program name and path.
		//
		if ( ProgramPath != NULL )
			{
			delete [] ProgramPath;
			ProgramPath = NULL;
			}

		if ( ProgramName != NULL )
			{
			delete [] ProgramName;
			ProgramName = NULL;
			}
#endif
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\global.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Debug printing.                                                */
    /*                                                                  */
    /*   We sometimes need to print message during debugging. We        */
    /*   do this using the following 'printf' like function.            */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... )
	{
	AUTO CHAR Buffer[ DebugBufferSize ];
#ifdef ENABLE_DEBUG_FILE
	STATIC FILE *DebugFile = NULL;
#endif


	//
	//   Start of variable arguments.
	//
	va_list Arguments;

	va_start(Arguments, Format);

	//
	//   Format the string to be printed.
	//
	(VOID) _vsnprintf( Buffer,(DebugBufferSize-1),Format,Arguments );

	//
	//   Force null termination.
	//
	Buffer[ (DebugBufferSize-1) ] = '\0';

#ifdef ENABLE_DEBUG_FILE
	//
	//   Write to the debug file.
	//
	if ( DebugFile == NULL )
		{
		if ( (DebugFile = fopen( "C:\\DebugFile.TXT","a" )) == NULL )
			{ Failure( "Debug file could not be opened" ); }
		}

	fputs( Buffer,DebugFile );

	fflush( DebugFile );
#else
	//
	//   Write the string to the debug file.
	//
	OutputDebugString( Buffer );
#endif

	//
	//   End of variable arguments.
	//
	va_end( Arguments );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Software failure.                                              */
    /*                                                                  */
    /*   We know that when this function is called the application      */
    /*   has failed so we simply try to cleanly exit in the vain        */
    /*   hope that the failure can be caught and corrected.             */
    /*                                                                  */
    /********************************************************************/

VOID Failure( char *Message )
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	throw ((FAULT) Message);
#else
	RaiseException( 1,0,1,((CONST DWORD*) Message) );
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\global.hpp ===
#ifndef _GLOBAL_HPP_
#define _GLOBAL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Features.hpp"
#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The standard macros.                                           */
    /*                                                                  */
    /*   The following are standard macros used by various              */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

#define FIELDOFFSET( Type,Field )	  ((SBIT16) & (((Type *)0) -> Field))
#define TO_DO( Message ) message ( "---- To do ---->>>> " Message )

#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#define TRY							  try
#else
#define TRY							  __try
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The standard constants.                                        */
    /*                                                                  */
    /*   The following are standard constants used by various           */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

	//
	//   The hardware cache line size.
	//
CONST SBIT32 CacheLineSize			  = 32;
CONST SBIT32 CacheLineMask			  = (CacheLineSize - 1);
CONST SBIT32 NoAlignment			  = 1;

	//
	//   The end of a linked list.
	//
CONST INT EndOfList					  = -1;

	//
	//   The boolean constants.
	//
CONST BOOLEAN False					  = 0;
CONST BOOLEAN True					  = 1;

	//
	//   Various misc constants.
	//
CONST INT DebugBufferSize			  = 8192;
CONST INT ExpandStore				  = 2;
CONST INT MaxCpus					  = 32;
CONST INT NoFlags					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... );

VOID Failure( char *Message );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\librarypch.hpp ===
#ifndef _LIBRARY_PCH_HPP_
#define _LIBRARY_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Align.hpp"
#include "Assembly.hpp"
#include "Autolock.hpp"
#include "Barrier.hpp"
#include "Common.hpp"
#include "Delay.hpp"
#include "Environment.hpp"
#include "Global.hpp"
#include "Hash.hpp"
#include "List.hpp"
#include "Lock.hpp"
#include "Map.hpp"
#include "New.hpp"
#include "Pool.hpp"
#include "Prefetch.hpp"
#include "Queue.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Standard.hpp"
#include "String.hpp"
#include "System.hpp"
#include "Thread.hpp"
#include "Tls.hpp"
#include "Unique.hpp"
#include "Vector.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\librarypch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\list.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new linked list element.                              */
    /*                                                                  */
    /********************************************************************/

LIST::LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an element.                                             */
    /*                                                                  */
    /*   Delete the current element.                                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Delete( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == HeadOfList )
		{
#endif
		//
		//   Relink the forward chain.
		//
		if ( Forward != NULL )
			{ Forward -> Backward = Backward; }
		else
			{ HeadOfList -> Backward = Backward; }

		//
		//   Relink the backward chain.
		//
		if ( Backward != NULL )
			{ Backward -> Forward = Forward; }
		else
			{ HeadOfList -> Forward = Forward; }

		//
		//   Reset the list elements.
		//
		Forward = NULL;
		Backward = NULL;
#ifdef DEBUGGING
		Head = NULL;
		}
	else
		{ Failure( "No active linked list element in Delete" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a list element at the head of the list.                 */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Insert( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == NULL )
		{
#endif
		//
		//   Insert the new element at the front of the list.
		//
		if ( (Forward = HeadOfList -> Forward) == NULL )
			{ 
			HeadOfList -> Forward = this;
			HeadOfList -> Backward = this; 
			}
		else
			{ 
			HeadOfList -> Forward -> Backward = this; 
			HeadOfList -> Forward = this;
			}

		//
		//   Set the other pointers as needed.
		//
		Backward = NULL;
#ifdef DEBUGGING
		Head = HeadOfList;
		}
	else
		{ Failure( "List element already in use in Insert" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a new list element before the current element.          */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertBefore( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a previous element we must
				//   make it point at the new element.  If
				//   not we are the first element in the 
				//   list so update the head.
				//
				if ( Backward != NULL )
					{ Backward -> Forward = NewList; }
				else
					{ HeadOfList -> Forward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Backward = Backward;
				NewList -> Forward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Backward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertBefore" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertBefore" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert an element.                                             */
    /*                                                                  */
    /*   Insert a new list element after the current element.           */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertAfter( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a next element we must
				//   make it point at the new element.  If
				//   not we are the last element in the 
				//   list so update the head.
				//
				if ( Forward != NULL )
					{ Forward -> Backward = NewList; }
				else
					{ HeadOfList -> Backward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Forward = Forward;
				NewList -> Backward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Forward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertAfter" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertAfter" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset a list element.                                          */
    /*                                                                  */
    /*   Reset a list element without any questions.                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Reset( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a linked list element.                                 */
    /*                                                                  */
    /********************************************************************/

LIST::~LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\list.hpp ===
#ifndef _LIST_HPP_
#define _LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A generic linked list.                                         */
    /*                                                                  */
    /*   There are a significant number of situations where objects     */
    /*   need to be linked together.  The objects may be of the same    */
    /*   or diffrent types so the class specified here is intended      */
    /*   to be used as base class so as to make supporting this easy.   */
    /*                                                                  */
    /********************************************************************/

class LIST
    {
		//
		//   Private data.
		//
 		LIST						  *Backward;
 		LIST						  *Forward;
#ifdef DEBUGGING
		LIST						  *Head;
#endif

   public:
        //
        //   Public functions.
        //
        LIST( VOID );

		VOID Delete( LIST *HeadOfList );

		VOID Insert( LIST *HeadOfList );

		VOID InsertBefore( LIST *HeadOfList,LIST *NewList );

		VOID InsertAfter( LIST *HeadOfList,LIST *NewList );

		VOID Reset( VOID );

        ~LIST( VOID );

		//
		//   Public line functions.
		//
		INLINE BOOLEAN StartOfList( VOID )
			{ return (Backward == NULL); }

		INLINE LIST *First( VOID )
			{ return Forward; }

		INLINE LIST *Last( VOID )
			{ return Backward; }

		INLINE LIST *Next( VOID )
			{ return Forward; }

		INLINE LIST *Previous( VOID )
			{ return Backward; }

		INLINE BOOLEAN EndOfList( VOID )
			{ return (Forward == NULL); }

	private:
        //
        //   Disabled operations.
        //
        LIST( CONST LIST & Copy );

        VOID operator=( CONST LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\lock.hpp ===
#ifndef _LOCKS_HPP_
#define _LOCKS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Full lock structure.                                           */
    /*                                                                  */
    /*   This class provides an full locking mechanism for a            */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class FULL_LOCK
    {
        //
        //   Private data.
        //
		SHARELOCK                     ShareLock;

    public:
        //
        //   Public inline functions.
        //
        FULL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) ShareLock.ClaimExclusiveLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) ShareLock.ClaimShareLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) ShareLock.ReleaseExclusiveLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) ShareLock.ReleaseShareLock(); }

        ~FULL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        FULL_LOCK( CONST FULL_LOCK & Copy );

        VOID operator=( CONST FULL_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   No lock structure.                                             */
    /*                                                                  */
    /*   This class provides a default locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class NO_LOCK
    {
    public:
        //
        //   Public inline functions.
        //
        NO_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ /* void */ }

        INLINE VOID ClaimSharedLock( VOID )
			{ /* void */ }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ /* void */ }

		INLINE VOID ReleaseSharedLock( VOID )
 			{ /* void */ }

        ~NO_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        NO_LOCK( CONST NO_LOCK & Copy );

        VOID operator=( CONST NO_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Partial lock structure.                                        */
    /*                                                                  */
    /*   This class provides a partial locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class PARTIAL_LOCK
    {
        //
        // Private structures.
        //
		SPINLOCK                      Spinlock;

    public:
        //
        //   Public inline functions.
        //
        PARTIAL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

        ~PARTIAL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PARTIAL_LOCK( CONST PARTIAL_LOCK & Copy );

        VOID operator=( CONST PARTIAL_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\map.hpp ===
#ifndef _MAP_HPP_
#define _MAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The map constants specify the initial size of the map.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MapSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Maps and map management.                                       */
    /*                                                                  */
    /*   This class provides general purpose mapping functions to       */
    /*   safely convert handles into some pointer or value.             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class MAP : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            BOOLEAN                   Available;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxMap;
        SBIT32                        MapUsed;

        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Map;

    public:
        //
        //   Public functions.
        //
        MAP( SBIT32 NewMaxMap = MapSize, SBIT32 Alignment = 1 );

        SBIT32 NewHandle( CONST TYPE & Value );

		BOOLEAN FindHandle
			( 
			SBIT32                        Handle, 
			TYPE                          *Value 
			);

		VOID DeleteHandle( SBIT32 Handle );

        ~MAP( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 MaxHandles( VOID )
			{ return MapUsed; }

	private:
        //
        //   Disabled operations.
        //
        MAP( CONST MAP & Copy );

        VOID operator=( CONST MAP & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new map and prepare it for use.  This call is         */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::MAP
		( 
		SBIT32						  NewMaxMap,
		SBIT32						  Alignment 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		FreeStack( NewMaxMap ), 
		Map( NewMaxMap,Alignment,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxMap > 0 )
        {
#endif
        MaxMap = NewMaxMap;
        MapUsed = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Max map size in constructor for MAP" ); }
#endif
    }

	/********************************************************************/
    /*                                                                  */
    /*   Create a new handle.                                           */
    /*                                                                  */
    /*   We create a new handle for the supplied value.                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 MAP<TYPE,LOCK>::NewHandle
		( 
		CONST TYPE					  & Value 
		)
    {
	AUTO SBIT32 Handle;
	REGISTER VALUE *NewValue;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Expand the mapping table if it is too
	//   small be resizing it.
	//
	if ( ! FreeStack.PopStack( & Handle ) )
		{
		if ( (Handle = MapUsed ++) >= MaxMap )
			{ Map.Resize( (MaxMap *= ExpandStore) ); }
		}

	//
	//   Link in the new mapping.
	//
	NewValue = & Map[ Handle ];

	NewValue -> Available = True;
	NewValue -> Value = Value;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();

	return Handle;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the value associated with a handle.                       */
    /*                                                                  */
    /*   We find the value associated with the supplied handle.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN MAP<TYPE,LOCK>::FindHandle
        ( 
        SBIT32                        Handle, 
        TYPE                          *Value 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the handle and return the associated value.
	//
	Result = 
		( 
		((Handle >= 0) && (Handle < MaxMap))
			&& 
		(Map[ Handle ].Available) 
		);

	if ( Result )
		{ (*Value) = Map[ Handle ].Value; }

	//
	//   Release any lock claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a handle.                                               */
    /*                                                                  */
    /*   We delete the supplied handle and the associated value.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID MAP<TYPE,LOCK>::DeleteHandle
		( 
        SBIT32                        Handle
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the handle is valid then delete any
	//   associated value.
	//
	if ( (Handle >= 0) && (Handle < MaxMap) && (Map[ Handle ].Available) )
		{
		Map[ Handle ].Available = False;
		FreeStack.PushStack( Handle );
		}
	else
		{ Failure( "No mapping in DeleteMapHandle()" ); } 

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the map.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::~MAP( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\new.hpp ===
#ifndef _NEW_HPP_
#define _NEW_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())
#ifndef DISABLE_GLOBAL_NEW

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation operator.                                */
    /*                                                                  */
    /*   The memory allocation operator 'new' is overloaded to          */
    /*   provide a consistent interface.                                */
    /*                                                                  */
    /********************************************************************/

INLINE VOID *operator new( size_t Size )
    {
    REGISTER VOID *Store = malloc( Size );

    if ( Store == NULL )
        { Failure( "Out of system memory" ); }

    return Store;
    }

    /********************************************************************/
    /*                                                                  */
    /*   The memory deallocation operator.                              */
    /*                                                                  */
    /*   The memory deallocation operator releases allocated memory.    */
    /*                                                                  */
    /********************************************************************/

INLINE VOID operator delete( VOID *Store )
    { free( Store ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\pool.hpp ===
#ifndef _POOL_HPP_
#define _POOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Delay.hpp"
#include "Lock.hpp"
#include "New.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinPoolSize			  = 64;
CONST SBIT16 PoolStackSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class POOL : public LOCK
    {
		//
		//   Private type definitions.
		//
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        DELAY< VECTOR<TYPE_SIZE> >    Delay;
		STACK<POINTER>				  Stack;

    public:
        //
        //   Public functions.
        //
        POOL( SBIT32 NewMinSize = MinPoolSize );

        TYPE **MultiplePopPool
            ( 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID MultiplePushPool
            ( 
            CONST TYPE					  *Type[], 
            CONST SBIT32				  Size 
            );

        TYPE *PopPool( VOID );

        VOID PushPool( CONST TYPE *Type );

        ~POOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 MaxSize );

        //
        //   Disabled operations.
        //
        POOL( CONST POOL & Copy );

        VOID operator=( CONST POOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::POOL( SBIT32 NewMinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMinSize )
    {
#ifdef DEBUGGING
    if ( NewMinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        MaxSize = 0;
        MinSize = NewMinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "Min size in constructor for POOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID POOL<TYPE,LOCK>::ExpandSize
		( 
		SBIT32						  NewSize 
		)
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	REGISTER SBIT32 ActualSize =
		((NewSize <= MinSize) ? MinSize : NewSize);
	REGISTER VECTOR<TYPE> *NewBlock =
		(
		(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
			( 
			ActualSize, 
			CacheLineSize,
			CacheLineSize
			)
		);

	//
	//   We need to keep a note of the number of elements 
	//   we have allocated thus far.
	//
    MaxSize += ActualSize;

	//
	//   We put the address of each element we allocate on
	//   a stack to enable high speed allocation and 
	//   deallocation.
	//
    for 
			( 
			Count1 = 0;
			Count1 < ActualSize;
			Count1 += PoolStackSize 
			)
        {
		AUTO POINTER NewCalls[ PoolStackSize ];

		//
		//   We add elements to the stack in blocks
		//   to reduce the number of call to the
		//   stack code.
		//
        for 
				( 
				Count2 = 0;
				((Count1 + Count2) < ActualSize)
					&&
				(Count2 < PoolStackSize);
				Count2 ++ 
				)
            {
			REGISTER TYPE *NewCall =
				(
                & (*NewBlock)[ (Count1 + Count2) ]
				);
                 
            NewCalls[ Count2 ] = (POINTER) NewCall;
            }

		//
		//   Add the next block for free work packets to
		//   the global free stack.
		//
        Stack.MultiplePushStack
            ( 
            NewCalls,
            Count2 
            );
        }

    //
    //   Add the newly allocated block to the list of
    //   things to be deleted when this class is deleted.
    //
    Delay.DeferedDelete( ((VECTOR<TYPE_SIZE>*) NewBlock) );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We allocate a multiple elements from the allocation pool.      */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE **POOL<TYPE,LOCK>::MultiplePopPool
        ( 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	AUTO TYPE *Type[ PoolStackSize ];
	REGISTER SBIT32 Count;

	//
	//   Compute the actual request size.
	//
	Requested = ((Requested <= PoolStackSize) ? Requested : PoolStackSize);

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Extract as may elements from the stack as possible.
	//   If the stack is empty then allocate more.
	//
	while ( ! Stack.MultiplePopStack( Requested,(POINTER*) Type,Size ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructors.
	//
	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We push multiple existing elements into the pool for reuse.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::MultiplePushPool
        ( 
        CONST TYPE					  *Type[],
        CONST SBIT32				  Size 
        )
	{
	REGISTER SBIT32 Count;
	
	//
	//   Call the destructors.
	//
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Type[ Count ],TYPE ); }


	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the elements back onto the free stack.
	//
	Stack.MultiplePushStack( (POINTER*) Type,Size ); 

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We allocate a new element from the allocation pool.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE *POOL<TYPE,LOCK>::PopPool( VOID )
    {
	AUTO TYPE *Type;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   We pop an element off the stack if the
	//   stack is empty we create more elements.
	//
	while ( ! Stack.PopStack( (POINTER*) & Type ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructor.
	//
	(VOID) PLACEMENT_NEW( Type, TYPE );

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We push an existing element into the pool for reuse.           */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::PushPool
		( 
		CONST TYPE					  *Type 
		)
	{
	//
	//   Call the destructor.
	//
	PLACEMENT_DELETE( Type,TYPE );

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the element back onto the free stack.
	//
	Stack.PushStack( (POINTER) Type );

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::~POOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\prefetch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Prefetch.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
BOOLEAN PREFETCH::Active =
	(
	(BOOLEAN) IsProcessorFeaturePresent
		( 
		PF_XMMI_INSTRUCTIONS_AVAILABLE
		)
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\prefetch.hpp ===
#ifndef _PREFETCH_HPP_
#define _PREFETCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch a cache line.				                            */
    /*                                                                  */
    /*   Support of data prefetch on the Pentium III or better.         */
    /*                                                                  */
    /********************************************************************/

class PREFETCH : public ASSEMBLY
    {
#ifdef ASSEMBLY_X86
        //
        //   Staic private data.
        //
        STATIC BOOLEAN		          Active;

#endif
    public:
        //
        //   Public inline functions.
        //
        PREFETCH( VOID )
			{ /* void */ }

		STATIC INLINE VOID L1( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L2( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L3( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID Nta( CHAR *Address,SBIT32 Size );

        ~PREFETCH( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PREFETCH( CONST PREFETCH & Copy );

        VOID operator=( CONST PREFETCH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L1( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL1( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L2.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L2 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L2( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL2( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L3.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L3 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L3( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL3( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::Nta( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchNta( Address ); }
		}
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\queue.hpp ===
#ifndef _QUEUE_HPP_
#define _QUEUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Common.hpp"
#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The queue constants specify the initial size of the queue.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 QueueSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Queues and queue management.                                   */
    /*                                                                  */
    /*   This class provides general purpose queues along with some     */
    /*   basic management.  The queues are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a queue at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class QUEUE : public COMMON, public LOCK
    {
        //
        //   Private data.
        //
        SBIT32						  MaxSize;

		BOOLEAN						  Align;
        SBIT32						  Mask;

        SBIT32						  Back;
        SBIT32						  Front;

        VECTOR<TYPE>                  Queue;

    public:
        //
        //   Public functions.
        //
        QUEUE( SBIT32 NewMaxSize = QueueSize,BOOLEAN NewAlign = True );

        BOOLEAN MultiplePopBackOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        BOOLEAN MultiplePopFrontOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        VOID MultiplePushBackOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        VOID MultiplePushFrontOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        BOOLEAN PeekBackOfQueue( TYPE *Data );

        BOOLEAN PeekFrontOfQueue( TYPE *Data );

        BOOLEAN PopBackOfQueue( TYPE *Data );

        BOOLEAN PopFrontOfQueue( TYPE *Data );

        VOID PushBackOfQueue( CONST TYPE & Data );

        VOID PushFrontOfQueue( CONST TYPE & Data );

		SBIT32 SizeOfQueue( VOID );

        ~QUEUE( VOID );

		//
		//   Public inline functions.
		//
        INLINE BOOLEAN MultiplePopQueue
				( 
				SBIT32				  Requested, 
				TYPE				  Data[], 
				SBIT32				  *Size 
				)
			{ return MultiplePopFrontOfQueue( Requested,Data,Size ); }

        INLINE VOID MultiplePushQueue
				( 
				CONST TYPE			  Data[], 
				CONST SBIT32		  Size 
				)
			{ MultiplePushBackOfQueue( Data,Size ); }

        INLINE BOOLEAN PeekQueue( TYPE *Data )
			{ return PeekFrontOfQueue( Data ); }

        INLINE BOOLEAN PopQueue( TYPE *Data )
			{ return PopFrontOfQueue( Data ); }

        INLINE VOID PushQueue( CONST TYPE & Data )
			{ PushBackOfQueue( Data ); }

	private:
		//
		//   Private functions.
		//
		VOID ExpandQueue( VOID );

        //
        //   Disabled operations.
        //
        QUEUE( CONST QUEUE & Copy );

        VOID operator=( CONST QUEUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new queue and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::QUEUE
		( 
		SBIT32						  NewMaxSize,
		BOOLEAN						  NewAlign 
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		Align = NewAlign;
        Mask = 0x7fffffff;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Compute the alignment mask.
		//
		if 
				(
				((sizeof(TYPE) > 0) && (sizeof(TYPE) <= CacheLineSize))
					&&
				(PowerOfTwo( sizeof(TYPE) ))
				)
			{ Mask = ((CacheLineSize / sizeof(TYPE))-1); }
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for QUEUE" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand a queue.                                                */
    /*                                                                  */
    /*   When a queue becomes full we need to expand it and to copy     */
    /*   the tail end of the queue into the correct place.              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::ExpandQueue( VOID )
    {
    REGISTER SBIT32 Count;
    REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

	//
	//   Expand the queue (it will be at least doubled).
	//
    Queue.Resize( NewSize );

	//
	//   Copy the tail end of the queue to the correct
	//   place in the expanded queue.
	//
    for ( Count = 0;Count < Back;Count ++ )
        { Queue[ (MaxSize + Count) ] = Queue[ Count ]; }

	//
	//   Update the control information.
	//
    Back += MaxSize;
    MaxSize = NewSize;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the back of the queue.                 */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopBackOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing a cache  
	//   line at the same time.  Here we modify the request  
	//   to pop exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = (Back & Mask);

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && (Front <= (Back - Requested))) 
                || 
            ((Front > Back) && ((Back - Requested) >= 0)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ -- Back ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
				 if ( Back <= 0 )
					{ Back = MaxSize; }

                Data[ Count ] = Queue[ -- Back ];
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the front of the queue.                */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopFrontOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing cache  
	//   lines at the same time.  Here we modify the request  
	//   to access exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = ((Mask + 1) - (Front & Mask));

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front + Requested) <= Back)) 
                || 
            ((Front > Back) && ((Front + Requested) < MaxSize)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ Front ++ ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;
        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
                Data[ Count ] = Queue[ Front ++ ];

                if ( Front >= MaxSize )
                    { Front = 0; }
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the back of the queue.                */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushBackOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Back + Size) < MaxSize)) 
                || 
            ((Front > Back) && (Front > (Back + Size))) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ Back ++ ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the front of the array.
            //
            Queue[ Back ++ ] = Data[ Count ];

             if ( Back >= MaxSize )
                { Back = 0; }

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the front of the queue.               */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushFrontOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front - Size) >= 0)) 
                || 
            ((Front > Back) && ((Front - Size) > Back)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ -- Front ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count = 0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the back of the array.
            //
			 if ( Front <= 0 )
				{ Front = MaxSize; }

			Queue[ -- Front ] = Data[ Count ];

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the back of the queue.                                    */
    /*                                                                  */
    /*   We return the end of the queue but check to make sure          */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the last element.
	//
    if ( Front != Back )
		{
		//
		//   The 'Back' index points at the next free cell.
		//   So the last element is 'Back - 1'.  However,
		//   when 'Back' is zero we need to wrap.
		//
		if ( Back > 0 )
			{ (*Data) = Queue[ (Back - 1) ]; }
		else
			{ (*Data) = Queue[ (MaxSize - 1) ]; }
	
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the front of the queue.                                   */
    /*                                                                  */
    /*   We return the front of the queue but check to make sure        */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the first element.
	//
    if ( Front != Back )
		{ 
		(*Data) = Queue[ Front ];
		
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the back of the queue.                        */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
         if ( Back <= 0 )
            { Back = MaxSize; }

       (*Data) = Queue[ -- Back ];

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the front of the queue.                       */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
        (*Data) = Queue[ Front ++ ];

        if ( Front >= MaxSize )
            { Front = 0; }

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the back of the queue.                       */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushBackOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Queue[ Back ++ ] = Data;

     if ( Back >= MaxSize )
        { Back = 0; }

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the front of the queue.                      */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushFrontOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the back of the array.
    //
     if ( Front <= 0 )
        { Front = MaxSize; }

    Queue[ -- Front ] = Data;

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the queue.                               */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*   This is only used when the size is needed in all other cases   */
    /*   we just try to remove the elements in the queue.               */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 QUEUE<TYPE,LOCK>::SizeOfQueue( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Compute the size of the queue.
	//
	Size = (Back - Front);

	if ( Size < 0 )
		{ Size += MaxSize; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseSharedLock();

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::~QUEUE( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\slist.hpp ===
#ifndef _SLIST_HPP_
#define _SLIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A lockless list.                                               */
    /*                                                                  */
    /*   An SList is a lockless list suitable for high contention       */
    /*   SMP access.                                                    */
    /*                                                                  */
    /********************************************************************/

class SLIST : public ASSEMBLY
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
	        SLIST                     *Address;
	        SBIT16                    Size;
	        SBIT16                    Version;
			}
		SLIST_HEADER;

        //
        //   Private data.
        //
        VOLATILE SBIT64	              Header;

    public:
        //
        //   Public functions.
        //
        SLIST( VOID );

		BOOLEAN Pop( SLIST **Element );

		VOID PopAll( SLIST **List );

		VOID Push( SLIST *Element );

        ~SLIST( VOID );

	private:
        //
        //   Disabled operations.
        //
        SLIST( CONST SLIST & Copy );

        VOID operator=( CONST SLIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\sharelock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The Windows NT kernel requires a maximum wakeup count when     */
    /*   creating a semaphore.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxShareLockUsers		  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::SHARELOCK( SBIT32 NewMaxSpins, SBIT32 NewMaxUsers )
    {
	//
	//   Check the configurable values.
	//
	if ( NewMaxSpins > 0 )
		{ MaxSpins = NewMaxSpins; }
	else
		{ Failure( "Maximum spins invalid in constructor for SHARELOCK" ); }

	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{ MaxUsers = NewMaxUsers; }
	else
		{ Failure( "Maximum share invalid in constructor for SHARELOCK" ); }

	//
	//   Set the initial state.
	//
	Exclusive = 0;
	TotalUsers = 0;
#ifdef ENABLE_RECURSIVE_LOCKS

	Owner = NULL;
	Recursive = 0;
#endif
	Semaphore = NULL;
    Waiting = 0;

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the statistics.
	//
    TotalExclusiveLocks = 0;
    TotalShareLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Sleep waiting for the lock.                                    */
    /*                                                                  */
    /*   We have decided it is time to sleep waiting for the lock       */
    /*   to become free.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::SleepWaitingForLock( SBIT32 Sleep )
    {
	//
	//   We do not create the semaphore until somebody tries
	//   to sleep on it for the first time.
	//
	if ( Semaphore == NULL )
		{ UpdateSemaphore(); }

	//
	//   We would normally hope to find a semaphore avaiable
	//   ready for a sleep but the OS may decline the request 
	//   If this is the case we exit without sleeping.
	//
	if ( Semaphore != NULL )
		{
		//
		//   We have been spinning waiting for the lock but it
		//   has not become free.  Hence, it is now time to 
		//   give up and sleep for a while.
		//
		(VOID) AtomicIncrement( & Waiting );

		//
		//   Just before we go to sleep we do one final check
		//   to make sure that the lock is still busy and that
		//   there is someone to wake us up when it becomes free.
		//
		if ( TotalUsers > 0 )
			{
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have slept on this lock.
			//
			(VOID) AtomicIncrement( & TotalSleeps );

#endif
			//
			//   When we sleep we awoken when the lock becomes free
			//   or when we timeout.  If we timeout we simply exit
			//   after decrementing various counters.
			//
			if 
					( 
					WaitForSingleObject( Semaphore, Sleep ) 
						!= 
					WAIT_OBJECT_0 
					)
				{ 
#ifdef ENABLE_LOCK_STATISTICS
				//
				//   Count the number of times we have timed out 
				//   on this lock.
				//
				(VOID) AtomicIncrement( & TotalTimeouts );

#endif
				return False; 
				}
			}
		else
			{
			//
			//   Lucky - the lock was just freed so lets
			//   decrement the sleep count and exit without
			//   sleeping.
			// 
			(VOID) AtomicDecrement( & Waiting );
			}
		}
	
	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the spin limit.                                         */
    /*                                                                  */
    /*   Update the maximum number of spins while waiting for the lock. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxSpins( SBIT32 NewMaxSpins )
    {
	if ( NewMaxSpins > 0 )
		{ 
		MaxSpins = NewMaxSpins; 

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the sharing limit.                                      */
    /*                                                                  */
    /*   Update the maximum number of users that can share the lock.    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxUsers( SBIT32 NewMaxUsers )
    {
	//
	//   We need to verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{
		ClaimExclusiveLock();

		//
		//   Update the maximum number of users.
		//
		MaxUsers = NewMaxUsers;
		
		ReleaseExclusiveLock();

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the semahore.                                           */
    /*                                                                  */
    /*   We only create the semaphore on first use.  So when we need    */
    /*   need to create a new semaphore any thread that is trying       */
    /*   to sleep on it comes here.                                     */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::UpdateSemaphore( VOID )
    {
	STATIC SBIT32 Active = 0;

	//
	//   We verify that there is still no semaphore
	//   otherwise we exit.
	//
	while ( Semaphore == NULL )
		{
		//
		//   We increment the active count and if we
		//   are first we are selected for special duty.
		//
		if ( (AtomicIncrement( & Active ) == 1) && (Semaphore == NULL) )
			{
			//
			//   We try to create a new semaphore.  If
			//   we fail we still exit.
			//   
			Semaphore = CreateSemaphore( NULL,0,MaxShareLockUsers,NULL );

			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			return;
			}
		else
			{ 
			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			Sleep( 1 ); 
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for an exclusive lock.                                    */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForExclusiveLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( TotalUsers != 1 )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) && (TotalUsers > 0);
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(VOID) AtomicDecrement( & Exclusive );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(VOID) AtomicIncrement( & Exclusive );
				}
			}
		else
			{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(VOID) AtomicDecrement( & Exclusive );

			return False; 
			} 
		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for a shared lock.                                        */
    /*                                                                  */
    /*   Wait for the lock to become free and then claim it.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForShareLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) 
							&& 
						((Exclusive > 0) || (TotalUsers >= MaxUsers));
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }
				}
			}
		else
			{ return False; }

		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::~SHARELOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Sharelock: %d exclusive, %d shared, %d timeouts, " 
		"%d locks per wait, %d spins per wait, %d waits per sleep.\n",
		TotalExclusiveLocks,
		TotalShareLocks,
		TotalTimeouts,
		((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);
#endif
	//
	//   Close the semaphore handle.
	//
    if ( (Semaphore != NULL) && (! CloseHandle( Semaphore )) )
        { Failure( "Close semaphore in destructor for SHARELOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\smpool.hpp ===
#ifndef _SMPOOL_HPP_
#define _SMPOOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Block.hpp"
#include "Exclusive.hpp"
#include "Queue.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinSMPoolSize			  = 128;
CONST SBIT16 SMPoolStackSize		  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class SMPOOL
    {
		//
		//   Private structures.
		//
		typedef EXCLUSIVE< QUEUE<POINTER> > LOCKED_QUEUE;
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        BLOCK< VECTOR<TYPE_SIZE> >    Block;
        LOCKED_QUEUE                  FreeQueue;
		VECTOR< STACK<POINTER> >      Stacks;

    public:
        //
        //   Public functions.
        //
        SMPOOL( SBIT32 MinSize = MinSMPoolSize );

        TYPE *PopPool( SBIT16 Cpu );

        TYPE **MultiplePopPool
            ( 
            SBIT16                        Cpu, 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID PushPool( SBIT16 Cpu, TYPE *Pool );

        VOID MultiplePushPool
            ( 
            SBIT16                        Cpu, 
            TYPE                          *Pool[], 
            SBIT32                        Size 
            );

        ~SMPOOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 NewSize );

        //
        //   Disabled operations.
        //
        SMPOOL( CONST SMPOOL & Copy );

        VOID operator=( CONST SMPOOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::SMPOOL( SBIT32 MinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		FreeQueue( MinSize ), 
		Stacks( NumberOfCpus(), CacheLineSize )
    {
#ifdef DEBUGGING
    if ( MinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        this -> MaxSize = 0;
        this -> MinSize = MinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "MinSize in constructor for SMPOOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation if the free queue is      */
    /*   empty.                                                         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::ExpandSize( SBIT32 NewSize )
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	STATIC SPINLOCK Spinlock;

	Spinlock.ClaimLock();

	if ( FreeQueue.SizeOfQueue() <= 0 )
		{
		REGISTER SBIT32 ActualSize =
			(NewSize <= MinSize) ? MinSize : NewSize;
		REGISTER VECTOR<TYPE> *NewBlock =
			(
			(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
				( 
				ActualSize, 
				CacheLineSize 
				)
			);

		//
		//   We need to keep a note of the number of elements 
		//   we have allocated thus far.
		//
		MaxSize += ActualSize;

		//
		//   We put the address of each element we allocate on
		//   a stack to enable high speed allocation and 
		//   deallocation.
		//
		for 
				( 
				Count1 = 0;
				Count1 < ActualSize;
				Count1 += SMPoolStackSize 
				)
			{
			AUTO POINTER NewCalls[ SMPoolStackSize ];

			//
			//   We add elements to the stack in blocks
			//   to reduce the number of call to the
			//   stack code.
			//
			for 
					( 
					Count2 = 0;
					((Count1 + Count2) < ActualSize)
						&&
					(Count2 < SMPoolStackSize);
					Count2 ++ 
					)
				{
				REGISTER TYPE *NewCall =
					(
					& (*NewBlock)[ (Count1 + Count2) ]
					);
                 
				NewCalls[ Count2 ] = (POINTER) NewCall;
				}

			//
			//   Add the next block for free work packets to
			//   the global free queue.
			//
			Stack.MultiplePushStack
				( 
				NewCalls,
				Count2 
				);
			}

		//
		//   Add the newly allocated block to the list of
		//   things to be deleted when this class is deleted.
		//
		Block.DeferedDelete( (VECTOR<TYPE_SIZE>*) NewBlock );
		}
	
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We remove a single item from the pool.  This call assumes      */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE *SMPOOL<TYPE>::PopPool( SBIT16 Cpu )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool;

	while ( ! Stack -> PopStack( (POINTER*) & NewPool ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	(VOID) PLACEMENT_NEW( NewPool, TYPE );

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We remove multiple items from the pool.  This call assumes     */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE **SMPOOL<TYPE>::MultiplePopPool
        ( 
        SBIT16                        Cpu, 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool[ SMPoolStackSize ];

	Requested = (Requested <= SMPoolStackSize) ? Requested : SMPoolStackSize;

	while ( ! Stack -> MultiplePopStack( Requested,(POINTER*) NewPool,Size ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We add a single item to the pool.  This call assumes           */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::PushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool
        )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];

	PLACEMENT_DELETE( Pool, TYPE );

	Stack -> PushStack( (POINTER) Pool );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We add a multiple items to the pool.  This call assumes        */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::MultiplePushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool[],
        SBIT32                        Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Pool[ Count ], TYPE ); }

	Stack -> MultiplePushStack( (POINTER*) Pool,Size );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::~SMPOOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\sharelock.hpp ===
#ifndef _SHARELOCK_HPP_
#define _SHARELOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Sharelock and Semaphore locking.                               */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  A lock can be obtained in         */
    /*   either exclusive mode or shared mode.  If the lock is not      */
    /*   available the caller waits by spinning or if that fails        */
    /*   by sleeping.                                                   */
    /*                                                                  */
    /********************************************************************/

class SHARELOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32                        MaxSpins;
		SBIT32                        MaxUsers;

        VOLATILE SBIT32               Exclusive;
        VOLATILE SBIT32               TotalUsers;

#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalExclusiveLocks;
        VOLATILE SBIT32               TotalShareLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SHARELOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE VOID ChangeExclusiveLockToSharedLock( VOID );

        INLINE BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimShareLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseExclusiveLock( VOID );

        INLINE VOID ReleaseShareLock( VOID );

        BOOLEAN UpdateMaxSpins( SBIT32 NewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 NewMaxUsers );

        ~SHARELOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 ActiveUsers( VOID ) 
			{ return (SBIT32) TotalUsers; }

    private:
        //
        //   Private functions.
        //
		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN SleepWaitingForLock( SBIT32 Sleep );

		VOID UpdateSemaphore( VOID );

        BOOLEAN WaitForExclusiveLock( SBIT32 Sleep );

        BOOLEAN WaitForShareLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SHARELOCK( CONST SHARELOCK & Copy );

        VOID operator=( CONST SHARELOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Change an exclusive lock to a shared lock.                     */
    /*                                                                  */
    /*   Downgrade the existing exclusive lock to a shared lock.        */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ChangeExclusiveLockToSharedLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Simply decrement the exclusive count.
		//   This allows the lock to be shared.
		//
		(VOID) AtomicDecrement( & Exclusive );
#ifdef ENABLE_RECURSIVE_LOCKS
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Change a shared lock to an exclusive lock.                     */
    /*                                                                  */
    /*   Upgrade the existing shared lock to an exclusive lock.         */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ChangeSharedLockToExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif		
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared.
		//
		(VOID) AtomicIncrement( & Exclusive );

		//
		//   If the total number of users is one then
		//   we have the lock exclusively otherwise we
		//   may need to wait.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim an exclusive lock.                                       */
    /*                                                                  */
    /*   Claim an exclusive lock if available else wait or exit.        */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.
		//
		(VOID) AtomicIncrement( & Exclusive );
		(VOID) AtomicIncrement( & TotalUsers );

		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a shared lock.                                           */
    /*                                                                  */
    /*   Claim a shared lock if available else wait or exit.            */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimShareLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
		(VOID) AtomicIncrement( & TotalUsers );

		if ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif

	return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release an exclusive lock.                                     */
    /*                                                                  */
    /*   Release an exclusive lock and if needed wakeup any sleepers.   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseExclusiveLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Release an exclusive lock.
		//
#ifdef DEBUGGING
		if
				(
				(AtomicDecrement( & TotalUsers ) < 0)
					||
				(AtomicDecrement( & Exclusive ) < 0)
				)
			{ Failure( "Negative lock count in ReleaseExclusiveLock" ); }
#else
			AtomicDecrement( & TotalUsers );
			AtomicDecrement( & Exclusive );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock.                                         */
    /*                                                                  */
    /*   Release a shared lock and if needed wakeup any sleepers.       */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseShareLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
#endif
#ifdef DEBUGGING
		//
		//   Release a shared lock.
		//
		if ( AtomicDecrement( & TotalUsers ) < 0 )
			{ Failure( "Negative lock count in ReleaseShareLock" ); }
#else
		AtomicDecrement( & TotalUsers );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\slist.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "SList.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new slist and initialize it.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SLIST::SLIST( VOID )
    {
	//
	//   Zero the list head.
	//
	Header = 0;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an element.                                                */
    /*                                                                  */
    /*   Pop an element from the list.                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SLIST::Pop( SLIST **Element )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update;
	REGISTER SLIST_HEADER *NewElement;
	REGISTER SLIST_HEADER *NewHeader = ((SLIST_HEADER*) & Update);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		Update = Original;

		//
		//   We need to be sure that there is an element
		//   to extract.  If not we exit.
		//
		if ( (NewElement = ((SLIST_HEADER*) NewHeader -> Address)) != NULL )
			{
			//
			//   Create a new list head.
			//
			NewHeader -> Address = NewElement -> Address;
			NewHeader -> Size --;
			NewHeader -> Version ++;
			}
		else
			{ return False; }
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );

	//
	//   Update the parameter and exit.
	//
	(*Element) = ((SLIST*) NewElement);

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop all elements.                                              */
    /*                                                                  */
    /*   Pop all the elements from the list.                            */
    /*                                                                  */
    /********************************************************************/

VOID SLIST::PopAll( SLIST **List )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update = NULL;
	REGISTER SLIST_HEADER *OldHeader = ((SLIST_HEADER*) & Original);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );

	//
	//   Update the parameter and exit.
	//
	(*List) = ((SLIST*) OldHeader -> Address);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an element.                                               */
    /*                                                                  */
    /*   Push an element onto the list.                                 */
    /*                                                                  */
    /********************************************************************/

VOID SLIST::Push( SLIST *Element )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update;
	REGISTER SLIST_HEADER *NewElement = ((SLIST_HEADER*) Element);
	REGISTER SLIST_HEADER *NewHeader = ((SLIST_HEADER*) & Update);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		Update = Original;

		//
		//   The current list head is copied to 
		//   the new element pointer.
		//
		NewElement -> Address = NewHeader -> Address;

		//
		//   Update the list head.
		//
		NewHeader -> Address = Element;
		NewHeader -> Size ++;
		NewHeader -> Version ++;
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a SList.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SLIST::~SLIST( VOID )
    {
	//
	//   The list should be empty.
	//
    if ( Header != 0 )
	{ Failure( "Non-empty list in destructor for SLIST" ); }
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\spinlock.hpp ===
#ifndef _SPINLOCK_HPP_
#define _SPINLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The spinlock constants indicate when the lock is open and      */
    /*   when it is closed.                                             */
    /*                                                                  */
    /********************************************************************/

CONST LONG LockClosed				  = 1;
CONST LONG LockOpen					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Spinlock and Semaphore locking.                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  When a lock is taken a memory     */
    /*   location is exchanged.  All other threads that want this       */
    /*   lock wait by spinning and sometimes sleeping on a semaphore    */
    /*   until it becomes free again.  The only other choice is not     */
    /*   to wait at all and move on to do something else.  This         */
    /*   module should normally be used in conjunction with cache       */
    /*   aligned memory in minimize cache line misses.                  */
    /*                                                                  */
    /********************************************************************/

class SPINLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32						  MaxSpins;
		SBIT32						  MaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Spinlock;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SPINLOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseLock( VOID );

        ~SPINLOCK( VOID );

    private:
        //
        //   Private functions.
        //
        INLINE BOOLEAN ClaimSpinlock( VOLATILE SBIT32 *Spinlock );

		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

		VOID UpdateSemaphore( VOID );

        BOOLEAN WaitForLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SPINLOCK( CONST SPINLOCK & Copy );

        VOID operator=( CONST SPINLOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   A guaranteed atomic exchange.                                  */
    /*                                                                  */
    /*   An attempt is made to claim the spinlock.  This action is      */
    /*   guaranteed to be atomic.                                       */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimSpinlock( VOLATILE SBIT32 *Spinlock )
    {
    return 
		(
		AtomicCompareExchange( Spinlock,LockClosed,LockOpen ) 
			== 
		LockOpen
		); 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the spinlock.                                            */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Claim the spinlock.
		//
		if ( ! ClaimSpinlock( & Spinlock ) )
			{
			//
			//   We have to wait.  If we are not 
			//   allowed to sleep or we have timed
			//   out then exit.
			//
			if ( (Sleep == 0) || (! WaitForLock( Sleep )) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
#ifdef DEBUGGING

		//
		//   Release the spinlock.
		//
		if ( AtomicExchange( & Spinlock, LockOpen ) == LockClosed )
			{
#else
			(VOID) AtomicExchange( & Spinlock, LockOpen );
#endif

			//
			//   Wakeup anyone who is asleep waiting.
			//
			if ( Waiting > 0 )
				{ WakeAllSleepers(); }
#ifdef DEBUGGING
			}
		else
			{ Failure( "Spinlock released by not held in ReleaseLock" ); } 
#endif
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\system.hpp ===
#ifndef _SYSTEM_HPP_
#define _SYSTEM_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard system include files.                             */
    /*                                                                  */
    /*   The standard system include files contain various definitions  */
    /*   used throughout the system.                                    */
    /*                                                                  */
    /********************************************************************/

#include <conio.h>
#include <iostream.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <new.h>
#include <process.h>
#include <time.h>
#include <winsock2.h>
#include <windows.h>

    /********************************************************************/
    /*                                                                  */
    /*   Automatically set the debugging flag if needed.                */
    /*                                                                  */
    /*   There are various standards for enabling dedugging code.       */
    /*   Here we translate on to the standard used in this              */
    /*   application.                                                   */
    /*                                                                  */
    /********************************************************************/

#ifdef _M_IX86
#define ASSEMBLY_X86				  1
#endif

#ifdef _DEBUG
#define DEBUGGING                     1
#endif

#ifdef UNICODE
#undef CreateSemaphore
#undef OutputDebugString

#define CreateSemaphore				  CreateSemaphoreA
#define OutputDebugString			  OutputDebugStringA
#endif
#ifndef ALL_COMPLAINTS

    /********************************************************************/
    /*                                                                  */
    /*   Automatically disable anoying warnings.                        */
    /*                                                                  */
    /*   Some of the VC compiler warning are not very helpful so        */
    /*   we disable them here.                                          */
    /*                                                                  */
    /********************************************************************/

#pragma warning( disable : 4073 )
#pragma warning( disable : 4100 )
#pragma warning( disable : 4121 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4511 )
#pragma warning( disable : 4512 )
#pragma warning( disable : 4514 )
#pragma warning( disable : 4701 )
#pragma warning( disable : 4702 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4710 )
#pragma warning( disable : 4711 )
#pragma warning( disable : 4800 )
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\stack.hpp ===
#ifndef _STACK_HPP_
#define _STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the stack.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 StackSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Stacks and stack management.                                   */
    /*                                                                  */
    /*   This class provides general purpose stacks along with some     */
    /*   basic management.  The stacks are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a stack at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class STACK : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Top;

        VECTOR<TYPE>                  Stack;

    public:
        //
        //   Public functions.
        //
        STACK( SBIT32 NewMaxSize = StackSize );

        BOOLEAN MultiplePopStack
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        BOOLEAN MultiplePopStackReversed
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        VOID MultiplePushStack
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        VOID MultiplePushStackReversed
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        BOOLEAN PeekStack( TYPE *Data );

        BOOLEAN PopStack( TYPE *Data );

        VOID PushStack( CONST TYPE & Data );

        BOOLEAN ReadStack( SBIT32 Index, TYPE *Data );

        VOID ReverseStack( VOID );

        BOOLEAN UpdateStack
            ( 
            CONST SBIT32				  Index, 
            CONST TYPE					  & Data 
            );

        ~STACK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 SizeOfStack( VOID ) 
			{ return Top; }

	private:
        //
        //   Disabled operations.
        //
        STACK( CONST STACK & Copy );

        VOID operator=( CONST STACK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new stack and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::STACK( SBIT32 NewMaxSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Top = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for STACK" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack.                            */
    /*                                                                  */
    /*   We remove multiple items from a stack and check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStack
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = ((*Size) - 1);Count >= 0;Count -- )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack in reverse order.           */
    /*                                                                  */
    /*   We remove multiple items from a stack in reverse order and     */
    /*   check to make sure that the stack is not empty.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStackReversed
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = 0;Count < (*Size);Count ++ )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack.                                 */
    /*                                                                  */
    /*   We add multiple items to a stack and check to make sure that   */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStack
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements.
	//
    for ( Count = 0;Count < Size;Count ++ )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack in reverse order.                */
    /*                                                                  */
    /*   We add multiple items to a stack in reverse order and check    */
    /*   to make sure that the stack has not overflowed.  If the stack  */
    /*   has overflowed we double its size.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStackReversed
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements in reverse order.
	//
    for ( Count = (Size-1);Count >= 0;Count -- )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek at the top of stack.                                      */
    /*                                                                  */
    /*   We return the top of stack with a pop but check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PeekStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the stack is not empty return a copy
	//   of the top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ (Top - 1) ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from a stack.                             */
    /*                                                                  */
    /*   We remove a single item from a stack and check to make sure    */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PopStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

    //
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the
	//   top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ -- Top ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to a stack.                                  */
    /*                                                                  */
    /*   We add a single item to a stack and check to make sure that    */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::PushStack
		( 
		CONST TYPE					  & Data
		)
    {    
	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is full then expand it.
	//
    while ( Top >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push a new element.
	//
    Stack[ Top ++ ] = Data;

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Read a stack value.                                            */
    /*                                                                  */
    /*   We return a single item from the stack but check to make       */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::ReadStack
        ( 
        SBIT32                        Index, 
        TYPE                          *Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the element exists then return a copy of
	//   it to the caller.
	//
    if ( Index < Top )
		{ 
		(*Data) = Stack[ Index ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Reverse the stack.                                             */
    /*                                                                  */
    /*   We reverse the order of the stack to make effectively          */
    /*   make it a queue.                .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::ReverseStack( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 MidPoint = (Top / 2);

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Swap all elements around the mid point.
	//
	for ( Count=0;Count < MidPoint;Count ++ )
		{
		REGISTER TYPE *Low = & Stack[ Count ];
		REGISTER TYPE *High = & Stack[ (Top - Count - 1) ];
		REGISTER TYPE Temp = (*Low);

		(*Low) = (*High);
		(*High) = Temp;
		}

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update a stack value.                                          */
    /*                                                                  */
    /*   We update a single item on the stack but check to make         */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::UpdateStack
        ( 
        CONST SBIT32				  Index, 
        CONST TYPE					  & Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the element exists then update it.
	//
    if ( Index < Top )
		{ 
		Stack[ Index ] = Data;

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::~STACK( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\spinlock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::SPINLOCK( SBIT32 NewMaxSpins,SBIT32 NewMaxUsers )
    {
	//
	//   Set the initial state.
	//
	MaxSpins = NewMaxSpins;
	MaxUsers = NewMaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;
#endif
    Spinlock = LockOpen;
	Semaphore = NULL;
    Waiting = 0;
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the semahore.                                           */
    /*                                                                  */
    /*   We only create the semaphore on first use.  So when we need    */
    /*   need to create a new semaphore any thread that is trying       */
    /*   to sleep on it comes here.                                     */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::UpdateSemaphore( VOID )
    {
	STATIC SBIT32 Active = 0;

	//
	//   We verify that there is still no semaphore
	//   otherwise we exit.
	//
	while ( Semaphore == NULL )
		{
		//
		//   We increment the active count and if we
		//   are first we are selected for special duty.
		//
		if ( (AtomicIncrement( & Active ) == 1) && (Semaphore == NULL) )
			{
			//
			//   We try to create a new semaphore.  If
			//   we fail we still exit.
			//   
			Semaphore = CreateSemaphore( NULL,0,MaxUsers,NULL );

			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			return;
			}
		else
			{ 
			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			Sleep( 1 ); 
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for the spinlock.                                         */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SPINLOCK::WaitForLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER SBIT32 Sleeps = 0;
    REGISTER SBIT32 Spins = 0;
    REGISTER SBIT32 Waits = 0;

#endif
    do
        {
        REGISTER SBIT32 Count;
        
		//
		//   If there are already more threads waiting 
		//   than the number of CPUs then the odds of 
		//   getting the lock by spinning are slim, when 
		//   there is only one CPU the chance is zero, so 
		//   just bypass this step.
		//
		if ( (Cpus > 1) && (Cpus > Waiting) )
			{
			//
			//   Wait by spinning and repeatedly testing the
			//   spinlock.  We exit when the lock becomes free 
			//   or the spin limit is exceeded.
			//
			for 
				( 
					Count = MaxSpins;
					(Count > 0) && (Spinlock != LockOpen);
					Count -- 
				);
#ifdef ENABLE_LOCK_STATISTICS

			//
			//   Update the statistics.
			//
			Spins += (MaxSpins - Count);
			Waits ++;
#endif
			}
		else
			{ Count = 0; }

		//
		//   We have exhusted our spin count so it is time to
		//   sleep waiting for the lock to clear.
		//
        if ( Count == 0 )
            {
			//
			//   We do not create the semaphore until  
			//   somebody tries to sleep on it for the 
			//   first time.
			//
			if ( Semaphore == NULL )
				{ UpdateSemaphore(); }

			//
			//   We would normally hope to find a semaphore 
			//   avaiable ready for a sleep but the OS may  
			//   decline the request.  If this is the case 
			//   try the lock again.
			//
			if ( Semaphore != NULL )
				{
				//
				//   The lock is still closed so lets go to sleep on 
				//   a semaphore.  However, we must first increment
				//   the waiting count and test the lock one last time
				//   to make sure it is still busy and there is someone
				//   to wake us up later.
				//
				(VOID) AtomicIncrement( & Waiting );

				if ( ! ClaimSpinlock( & Spinlock ) )
					{
					if 
							( 
							WaitForSingleObject( Semaphore, Sleep ) 
								!= 
							WAIT_OBJECT_0 
							)
						{
#ifdef ENABLE_LOCK_STATISTICS
						//
						//   Count the number of times we have  
						//   timed out on this lock.
						//
						(VOID) AtomicIncrement( & TotalTimeouts );

#endif
						return False; 
						}
#ifdef ENABLE_LOCK_STATISTICS

					//
					//   Update the statistics.
					//
					Sleeps ++;
#endif
					}
				else
					{
					//
					//   Lucky - got the lock on the last attempt.
					//   Hence, lets decrement the sleep count and
					//   exit.
					// 
					(VOID) AtomicDecrement( & Waiting );
                
					break; 
					}
				}
            }
        }
    while ( ! ClaimSpinlock( & Spinlock ) );
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    TotalSleeps += Sleeps;
    TotalSpins += Spins;
    TotalWaits += Waits;
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::~SPINLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Spinlock: %d locks, %d timouts, "
		"%d locks per wait, %d spins per wait, %d waits per sleep.\n",
		TotalLocks,
		TotalTimeouts,
		(TotalLocks / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);

#endif
	//
	//   Close the semaphore handle.
	//
    if ( (Semaphore != NULL) && (! CloseHandle( Semaphore )) )
        { Failure( "Close semaphore in destructor for SPINLOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\standard.hpp ===
#ifndef _STANDARD_HPP_
#define _STANDARD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard data types.                                       */
    /*                                                                  */
    /*   The standard data types should be used in preference to the    */
    /*   data types defined in the C++ language.  This is to allow      */
    /*   for easier porting.  If no suitable standard type exists       */
    /*   then one should be created and documented here.                */
    /*                                                                  */
    /********************************************************************/

#define AUTO                          auto
#define CONST						  const
#define CONSTANT                      const
#define EXTERN                        extern
#define GLOBAL                        extern
#define INLINE                        __forceinline
#define LOCAL                         auto
#define REGISTER                      register
#define STATIC                        static
#define VIRTUAL                       virtual
#define VOLATILE                      volatile

    /********************************************************************/
    /*                                                                  */
    /*   The standard C++ types.                                        */
    /*                                                                  */
    /*   The C++ standard reserves various lower case keywords.  This   */
    /*   system uses a similar standard.  All upper case words are      */
    /*   either constants or types.  All words begining with a single   */
    /*   upper case letter are variables.                               */
    /*                                                                  */
    /********************************************************************/

typedef unsigned char                 BOOLEAN;

typedef char                          CHAR;
typedef short int                     SHORT;
typedef int                           INT;
typedef long int                      LONG;

typedef signed char                   SCHAR;
typedef signed short int              SSHORT;
typedef signed int                    SINT;
typedef signed long int               SLONG;

typedef unsigned char                 UCHAR;
typedef unsigned short int            USHORT;
typedef unsigned int                  UINT;
typedef unsigned long int             ULONG;

typedef unsigned char                 *FAULT;
typedef void                          *POINTER;

    /********************************************************************/
    /*                                                                  */
    /*   The optional standard types.                                   */
    /*                                                                  */
    /*   Some of the standard types are specified in other headers.     */
    /*   We need to be careful not to redefine these specifications     */
    /*   if they already exist.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef CDECL
#define	CDECL						  _cdecl
#endif

#ifndef VOID
#define	VOID						  void
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The fixed length types.                                        */
    /*                                                                  */
    /*   The above types are intended to shadow the standard C++ types  */
    /*   built into the language.  However, these types don't assure    */
    /*   any level of accuracy.  Each of following types is defined     */
    /*   to provide a minimum level of precision.                       */
    /*                                                                  */
    /********************************************************************/

typedef unsigned __int8               BIT8;
typedef unsigned __int16              BIT16;
typedef unsigned __int32              BIT32;
typedef unsigned __int64              BIT64;

typedef signed __int8                 SBIT8;
typedef signed __int16                SBIT16;
typedef signed __int32                SBIT32;
typedef signed __int64                SBIT64;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\string.hpp ===
#ifndef _STRING_HPP_
#define _STRING_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Spinlock.hpp"
#include "Unique.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A string class.                                                */
    /*                                                                  */
    /*   A typical string class manages variable length text strings.   */
    /*   Although we support the same in this class we ensure that      */
    /*   there is only one copy of every unique string.  There is a     */
    /*   cost associated with this at string creation time but a big    */
    /*   win when the strings are heavily compared, copied or           */
    /*   replicated.                                                    */
    /*                                                                  */
    /********************************************************************/

class STRING
    {
        //
        //   Private data.
        //
        DETAIL						  *Detail;

        //
        //   Static private data.
        //
#ifdef DISABLE_STRING_LOCKS
		STATIC UNIQUE<NO_LOCK>		  *Unique;
#else
		STATIC SPINLOCK				  Spinlock;
		STATIC UNIQUE<FULL_LOCK>	  *Unique;
#endif

    public:
		//
		//   Public inline functions.
		//
        STRING( VOID )
			{ DefaultString(); }

        STRING( CHAR *String )
			{ CreateString( String,strlen( String ) ); }

        STRING( CHAR *String,SBIT32 Size )
			{ CreateString( String,Size ); }

        STRING( CONST STRING & Update )
			{ Detail = Unique -> CopyString( DefaultString(),Update.Detail ); }

        INLINE VOID operator=( CONST STRING & Update )
			{ Detail = Unique -> CopyString( Detail,Update.Detail ); }

        INLINE BOOLEAN operator==( CONST STRING & String )
			{ return (Detail == String.Detail); }

        INLINE BOOLEAN operator!=( CONST STRING & String )
			{ return (Detail != String.Detail); }

        INLINE BOOLEAN operator<( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) < 0); }

        INLINE BOOLEAN operator<=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) <= 0); }

        INLINE BOOLEAN operator>( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) > 0); }

        INLINE BOOLEAN operator>=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) >= 0); }

		INLINE SBIT32 Size( VOID )
			{ return Unique -> Size( Detail ); }

		INLINE CHAR *Value( VOID )
			{ return Unique -> Value( Detail ); }

		INLINE SBIT32 ValueID( VOID )
			{ return ((SBIT32) Detail); }

        ~STRING( VOID )
			{ DeleteString(); }

	private:
		//
		//   Private functions.
		//
		VOID CreateStringTable( VOID );

		//
		//   Private inline functions.
		//
		DETAIL *CreateString( CHAR *String,SBIT32 Size )
			{
			VerifyStringTable();

			return (Detail = Unique -> CreateString( String,Size ));
			}

        DETAIL *DefaultString( VOID )
			{
			VerifyStringTable();

			return (Detail = Unique -> DefaultString()); 
			}

        VOID DeleteString( VOID )
			{
			if ( Unique != NULL )
				{ Unique -> DeleteString( Detail ); }
			}

		VOID VerifyStringTable( VOID )
			{
			if ( Unique == NULL )
				{ CreateStringTable(); }
			}
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\string.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Delay.hpp"
#include "String.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                       