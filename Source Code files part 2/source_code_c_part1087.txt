object
        LeQueryOpen,            // Query open
        LeQueryOutOfDate,       // query whether object is current

        LeQueryReleaseStatus,   // returns release status
        LeQueryReleaseError,    // assynchronusrelease error
        LeQueryReleaseMethod,   // the method/proc which is in assynchronus
                                // operation.
        LeRequestData,          // requestdata
        LeObjectLong,           // objectLong
        LeChangeData            // change native data of existing object
};



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeObjectLong (lpobj, wFlags, lpData)
//
//   
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//   
//  Arguments:
// 
//      lpobj       -   object handle
//      wFlags      -   get, set flags
//      lpData      -   long pointer to data
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeObjectLong (lpobj, wFlags, lpData)
LPOBJECT_LE lpobj;
WORD        wFlags;
LPLONG      lpData;
{
    LONG    lData;
    
    Puts("LeObjectLong");

    if (!FarCheckObject((LPOLEOBJECT) lpobj))
        return OLE_ERROR_OBJECT;

    if ((lpobj->head.ctype != CT_EMBEDDED) && (lpobj->head.ctype != CT_LINK))
        return OLE_ERROR_OBJECT;
    
    if (wFlags & OF_HANDLER) {
        lData = lpobj->lHandlerData;
        if (wFlags & OF_SET) 
            lpobj->lHandlerData = *lpData;

        if (wFlags & OF_GET) 
            *lpData = lData;
    }
    else {
        lData = lpobj->lAppData;
        if (wFlags & OF_SET) 
            lpobj->lAppData = *lpData;

        if (wFlags & OF_GET) 
            *lpData = lData;
    }
    
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpobj)
//
//   
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//   
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_BUSY    -   object is busy
//      OLE_OK      -   not busy
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpobj)
LPOBJECT_LE lpobj;
{

    // probe async will clean up the channels
    // if the server died.


    PROBE_ASYNC (lpobj);
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseError (lpobj)
//   
//  returns the errors of an asynchronous command.
//   
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_ERROR_..    -   if there is any error
//      OLE_OK          -   no error
//   
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE.
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS   FAR PASCAL LeQueryReleaseError (lpobj)
LPOBJECT_LE lpobj;
{
    return lpobj->mainErr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpobj)
//   
//  returns the method/command of the asynchronous command which
//  resulted in the OLE_RELEASE call back.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//      OLE_RELEASE_METHOD
//   
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE. Using this api, clients can decide which previous
//        asynchronous command resulted in OLE_RELEASE.
//   
//////////////////////////////////////////////////////////////////////////////
OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpobj)
LPOBJECT_LE lpobj;
{
    return lpobj->oldasyncCmd;
}



//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID  FARINTERNAL LeQueryProtocol (lpobj, lpprotocol)
//   
//  Given an oject, returns the new object handle for the new protocol.
//  Does the conversion of objects from one protocol to another one.
//
//  Arguments:
// 
//      lpobj       -   object handle
//      lpprotocol  -   ptr to new protocol string
//
//  Returns:
//      lpobj       -   New object handle
//      null        -   if the protocol is not supported.
//   
//   
//////////////////////////////////////////////////////////////////////////////

LPVOID FARINTERNAL  LeQueryProtocol (lpobj, lpprotocol)
LPOBJECT_LE lpobj;
LPSTR       lpprotocol;
{
    if (lpobj->bOldLink)
        return NULL;
    
    if (!lstrcmp (lpprotocol, PROTOCOL_EDIT))
        return lpobj;

    if  (!lstrcmp (lpprotocol, PROTOCOL_EXECUTE)) {
        if (UtilQueryProtocol (lpobj, lpprotocol))
            return lpobj;
        
        return NULL;
    }
    
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS EmbLnkDelete (lpobj)
//   
//  Routine for the object termination/deletion. Schedules differnt
//  asynchronous commands depending on different conditions.
//  Arguments:
//
//  Sends "StdClose" only if it is Ok to close the document. Sends
//  "StdExit" only if the server has to be unlaunched.  Deletes the object
//  only if the original command is OLE_DELETE.  No need to call back the
//  client if the deletion is internal.
//
//  While delete, this routine is entered several times. EAIT_FOR_ASYNC_MSG
//  results in going back to from where it is called and the next DDE message
//  brings back the control to this routine.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//   
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmbLnkDelete (lpobj)
LPOBJECT_LE    lpobj;
{
    HOBJECT     hobj;

    switch (lpobj->subRtn) {

        case    0:

            SKIP_TO (!QueryClose (lpobj), step1);
            // Send "StdCloseDocument"
            SendStdClose (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            step1:
            SETSTEP (lpobj, 1);
            
            // End the doc conversation
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case    2:


            // delete the doc edit block. It is Ok even if the object
            // is not actually getting deleted.
            DeleteDocEdit (lpobj);

            // if need to unluanch the app, send stdexit.
            SKIP_TO (!QueryUnlaunch (lpobj), step3);
            SendStdExit (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    3:

            step3:
            SETSTEP (lpobj, 3);

            // Do not set any errors.
            // Terminate the server conversation.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    4:

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            if (lpobj->asyncCmd != OLE_DELETE) {

                // if this delete is called because of unlauncinh of
                // object because of some error, no need to
                // call end asynchronous. It  should have been already
                // called from somewhere else.

                if (lpobj->asyncCmd == OLE_SERVERUNLAUNCH){
                    // send the async cmd;
                    CLEARASYNCCMD (lpobj);
                } else
                    EndAsyncCmd (lpobj);
                return OLE_OK;
            }



            // for real delete delete the atoms and space.
            DeleteObjectAtoms (lpobj);

            if (lpobj->lpobjPict)
                (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);

            if (lpobj->hnative)
                GlobalFree (lpobj->hnative);

            if (lpobj->hLink)
                GlobalFree (lpobj->hLink);

            if (lpobj->hhostNames)
                GlobalFree (lpobj->hhostNames);

            if (lpobj->htargetDevice)
                GlobalFree (lpobj->htargetDevice);

            if (lpobj->hdocDimensions)
                GlobalFree (lpobj->hdocDimensions);
            
            DeleteExtraData (lpobj);

            DocDeleteObject ((LPOLEOBJECT) lpobj);
            // send the async cmd;
            EndAsyncCmd (lpobj);

            if (lpobj->head.iTable != INVALID_INDEX)
                DecreaseHandlerObjCount (lpobj->head.iTable);

            hobj = lpobj->head.hobj;
            ASSERT (hobj, "Object handle NULL in delete")

            GlobalUnlock (hobj);
            GlobalFree (hobj);

            return OLE_OK;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeRelease (lpobj)
//
//  Deletes the given object. This is can be asynchronous operation.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_WAIT_FOR_RELASE: If any DDE_TRANSACTIONS have been queued
//      OLE_OK             : If deletion successfully
//      OLE_ERROR_...      : If any error
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeRelease (lpobj)
LPOBJECT_LE    lpobj;
{


    // For delete allow if the object has been aborted.

    PROBE_ASYNC (lpobj);
    
    // reset the flags so that we do not delete the object based on the old
    // flags
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_DELETE, EMBLNKDELETE);
    return  EmbLnkDelete (lpobj);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Clones a given object.
//
//  Arguments:
//
//      lpobjsrc:       ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//   
//  Note: If the object being cloned is connected to the server, then
//        the cloned object is not connected to the server. For linked
//        objects, OleConnect has to be called.
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_LE  FAR *  lplpobj;
{

    LPOBJECT_LE    lpobj = NULL;
    int            retval = OLE_ERROR_MEMORY;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobjsrc);

    PROBE_CREATE_ASYNC(lpobjsrc);
    
    if (!(lpobj = LeCreateBlank(lhclientdoc, lpobjname, 
                        lpobjsrc->head.ctype)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;
    lpobj->head.iTable  = lpobjsrc->head.iTable; //!!! dll loading
    lpobj->head.lpvtbl  = lpobjsrc->head.lpvtbl;

    // set the atoms.
    lpobj->app          = DuplicateAtom (lpobjsrc->app);
    lpobj->topic        = DuplicateAtom (lpobjsrc->topic);
    lpobj->item         = DuplicateAtom (lpobjsrc->item);
    lpobj->aServer      = DuplicateAtom (lpobjsrc->aServer);

    lpobj->bOleServer   = lpobjsrc->bOleServer;
    lpobj->verb         = lpobjsrc->verb;
    lpobj->fCmd         = lpobjsrc->fCmd;

    lpobj->aNetName     = DuplicateAtom (lpobjsrc->aNetName);
    lpobj->cDrive       = lpobjsrc->cDrive;
    lpobj->dwNetInfo    = lpobjsrc->dwNetInfo;

    if (lpobjsrc->htargetDevice)
        lpobj->htargetDevice = DuplicateGlobal (lpobjsrc->htargetDevice, 
                                    GMEM_MOVEABLE);
    
    if (lpobjsrc->head.ctype == CT_EMBEDDED) {
        if (lpobjsrc->hnative) {
            if (!(lpobj->hnative = DuplicateGlobal (lpobjsrc->hnative, 
                                        GMEM_MOVEABLE)))
                goto errRtn;
        }
        
        if (lpobjsrc->hdocDimensions) 
            lpobj->hdocDimensions = DuplicateGlobal (lpobjsrc->hdocDimensions,
                                            GMEM_MOVEABLE);     
        if (lpobjsrc->hlogpal) 
            lpobj->hlogpal = DuplicateGlobal (lpobjsrc->hlogpal, 
                                            GMEM_MOVEABLE);     
        SetEmbeddedTopic (lpobj);                                       
    }
    else {
        lpobj->bOldLink     = lpobjsrc->bOldLink;
        lpobj->optUpdate    = lpobjsrc->optUpdate;
    }
    
    retval = OLE_OK;
    // if picture is needed clone the picture object.
    if ((!lpobjsrc->lpobjPict) ||
         ((retval = (*lpobjsrc->lpobjPict->lpvtbl->Clone)(lpobjsrc->lpobjPict,
                                    lpclient, lhclientdoc, lpobjname,
                                    (LPOLEOBJECT FAR *)&lpobj->lpobjPict)) 
                    == OLE_OK)) {
        SetExtents (lpobj);
        *lplpobj = lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }
    
    return retval;

errRtn:

    // This oledelete should not result in any async communication.
    if (lpobj)
        OleDelete ((LPOLEOBJECT)lpobj);

    return retval;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopyFromLink (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Creates an embedded object from a lonked object. If the linked object
//  is not activated, then launches the server, gets the native data and
//  unlaunches the server. All these operations are done silently.
//
//  Arguments:
//
//      lpobjsrc:       ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//      OLE_WAITF_FOR_RELEASE : if DDE transcation is queued
//   
//  Note: Could result in asynchronous operation if there is any
//        DDE operaion involved in getting any data from the server.
//
//        Also, If there is any error in getting the native data, the
//        client is expected delete the object after the OLE_RELEASE
//        call back
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopyFromLink (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_LE  FAR *  lplpobj;
{

    LPOBJECT_LE    lpobj;
    int            retval;


    *lplpobj = NULL;
    PROBE_OLDLINK (lpobjsrc);
    if (lpobjsrc->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;

    PROBE_ASYNC (lpobjsrc);
    PROBE_SVRCLOSING(lpobjsrc);
    
    if ((retval = LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname,
                    (LPOBJECT_LE FAR *)&lpobj)) != OLE_OK)
        return retval;


    // we successfully cloned the object. if picture object has native data
    // then grab it and put it in LE object. otherwise activate and get native
    // data also.
    
    if (lpobj->lpobjPict 
            && (*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, NULL) == cfNative){
        // Now we know that the picture object is of native format, and it
        // means that it is a generic object. So grab the handle to native
        // data and put it in LE object.

        lpobj->hnative = ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData; 
        ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData = NULL;
        (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);
        lpobj->lpobjPict = NULL;
        SetEmbeddedTopic (lpobj);
        *lplpobj = lpobj;
        return OLE_OK;
    } else {
    
        // if necessary launch, get native data and unlaunch the app.
        lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_NATIVE | (QueryOpen(lpobjsrc) ? ACT_TERMDOC : ACT_UNLAUNCH);
        InitAsyncCmd (lpobj, OLE_COPYFROMLNK, LNKOPENUPDATE);
        if ((retval = LnkOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            LeRelease (lpobj);
        else
            *lplpobj = lpobj;
        
        return retval;
        
        // we will be changing the topic in end conversation.
    }
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeEqual (lpobj1, lpobj2)
//
//  Checks whethere two objects are equal. Checks for equality
//  of links, native data and picture data.
//
//  Arguments:
//
//      lpobj1:      first object
//      lpobj2:      second object
//
//  Returns:
//      OLE_OK              : equal
//      OLE_ERROR_NOT_EQUAL : if not equal
//      OLE_ERROR_.....     : any errors
//   
//  Note: If any of the objects are connectd to the servers, leequal operaion
//        may not make much sense because the data might be changing from the
//        the server
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeEqual (lpobj1, lpobj2)
LPOBJECT_LE lpobj1;
LPOBJECT_LE lpobj2;
{
    
    if (lpobj1->app != lpobj2->app)
        return OLE_ERROR_NOT_EQUAL;
    
    // type of the objects is same. Otherwise this routine won't be called
    if (lpobj1->head.ctype == CT_LINK) {
        if (AreTopicsEqual (lpobj1, lpobj2) && (lpobj1->item == lpobj2->item))
            return OLE_OK;
            
        return OLE_ERROR_NOT_EQUAL;
    }
    else {
        ASSERT (lpobj1->head.ctype == CT_EMBEDDED, "Invalid ctype in LeEqual")
            
        if (lpobj1->item != lpobj2->item)  
            return OLE_ERROR_NOT_EQUAL;
        
        if (CmpGlobals (lpobj1->hnative, lpobj2->hnative))
            return OLE_OK;
        else
            return OLE_ERROR_NOT_EQUAL;
    }   
    
    //### we may have to compare the picture data also
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopy (lpobj)
//
//  Copies the object to the clipboard. Even for linked objects
//  we do not render the objectlink. It is up to the client app
//  to render object link
//
//  Arguments:
//
//      lpobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//   
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopy (lpobj)
LPOBJECT_LE    lpobj;
{
    HANDLE      hlink    = NULL;
    HANDLE      hnative  = NULL;
    
    PROBE_OLDLINK (lpobj);
    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);
    
    if (lpobj->head.ctype == CT_EMBEDDED){
        if (!(hnative = DuplicateGlobal (lpobj->hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
        SetClipboardData (cfNative, hnative);
    }
    
    hlink = GetLink (lpobj);
    if (!(hlink = DuplicateGlobal (hlink, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    SetClipboardData (cfOwnerLink, hlink);
    
    // copy network name if it exists
    if (lpobj->head.ctype == CT_LINK  && lpobj->aNetName) {
        HANDLE hNetName;
        
        if (hNetName = GetNetNameHandle (lpobj))
            SetClipboardData (cfNetworkName, hNetName);
    }
        
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->CopyToClipboard)(lpobj->lpobjPict);

    return OLE_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeQueryBounds (lpobj, lpRc)
//
//  Returns the bounding rectangle of the object. Returns topleft
//  as zero always and the units are himetric units.
//
//  Arguments:
//
//      lpobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//   
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL LeQueryBounds (lpobj, lpRc)
LPOBJECT_LE    lpobj;
LPRECT         lpRc;
{
    Puts("LeQueryBounds");

    // MM_HIMETRIC units

    lpRc->left     =  0;
    lpRc->top      =  0;
    lpRc->right    =  (int) lpobj->head.cx;
    lpRc->bottom   =  (int) lpobj->head.cy;

    if (lpRc->right || lpRc->bottom)
        return OLE_OK;

    if (!lpobj->lpobjPict)
        return OLE_ERROR_BLANK;
    
    return (*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, lpRc);
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
//
//  Draws the object. Calls the picture object for drawing the object
//
//
//  Arguments:
//
//       lpobj:       source object
//       hdc:         handle to dest dc. Could be metafile dc
//       lprc:        rectangle into which the object should be drawn
//                    should be in himetric units and topleft
//                    could be nonzero.
//       hdctarget:   Target dc for which the object should be drawn
//                    (Ex: Draw metafile on the dest dc using the attributes
//                         of traget dc).
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_BLANK     : no picture
//   
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_LE     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{   
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->Draw) (lpobj->lpobjPict, 
                                        hdc, lprc, lpWrc, hdcTarget);
    return OLE_ERROR_BLANK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpobj, cfFormat)
//
//  Enumerates the object formats.
//
//
//  Arguments:
//
//       lpobj      :  source object
//       cfFormat   :  ref fprmat
//
//  Returns:
//      NULL        :  no more formats or if we do not understand the
//                     given format.
//
//  Note: Even if the object is connected, we do not enumerate all the formats
//        the server can render. Server protocol can render the format list
//        only on system channel. Object can be connected only on the doc
//        channel
//
//////////////////////////////////////////////////////////////////////////////

OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpobj, cfFormat)
LPOBJECT_LE    lpobj;
OLECLIPFORMAT  cfFormat;
{
    Puts("LeEnumFormat");
    
    ASSERT((lpobj->head.ctype == CT_LINK)||(lpobj->head.ctype == CT_EMBEDDED),
        "Invalid Object Type");  

    // switch is not used because case won't take variable argument
    if (cfFormat == NULL) {
        if (lpobj->head.ctype == CT_EMBEDDED) 
            return cfNative;
        else
            return (lpobj->bOldLink ? cfLink : cfObjectLink);
    }

    if (cfFormat == cfNative) {
        if (lpobj->head.ctype == CT_EMBEDDED) 
            return cfOwnerLink;
        else
            return NULL;    
    }

    if (cfFormat == cfObjectLink) {
        if (lpobj->aNetName)
            return cfNetworkName;
        else
            cfFormat = NULL;
    }
    else if  (cfFormat == cfOwnerLink || cfFormat == cfLink 
                        || cfFormat == cfNetworkName)
        cfFormat = NULL;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, cfFormat);
    
    return NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeRequestData (lpobj, cfFormat)
//
//  Requests data from the server for a given format, if the server
//  is connected. If the server is not connected returns error.
//
//
//  Arguments:
//
//       lpobj:       source object
//       cfFormat:    ref fprmat
//
//  Returns:
//       OLE_WAIT_FOR_RELEASE : If the data request data is sent to
//                              the server.
//       OLE_ERROR_NOT_OPEN   : Server is not open for data
//
//  Note: If the server is ready, sends request to the server. When the
//        the data comes back from the server OLE_DATA_READY is sent in
//        the callback and the client can use Getdata to get the data.
//
//
//////////////////////////////////////////////////////////////////////////////



OLESTATUS FARINTERNAL LeRequestData (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{

    // Assumes all the creates are in order
    PROBE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen (lpobj))
        return  OLE_ERROR_NOT_OPEN;

    if (cfFormat == cfOwnerLink || cfFormat == cfObjectLink)
        return OLE_ERROR_FORMAT;
    
    if (!(cfFormat == cfNative && lpobj->head.ctype == CT_EMBEDDED)
            && (cfFormat != (OLECLIPFORMAT) GetPictType (lpobj))) {
        DeleteExtraData (lpobj);
        lpobj->cfExtra = cfFormat;
    }

    InitAsyncCmd (lpobj, OLE_REQUESTDATA, REQUESTDATA);
    lpobj->pDocEdit->bCallLater = FALSE;    
    return RequestData(lpobj, cfFormat);
}


OLESTATUS  RequestData (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{
    switch (lpobj->subRtn) {

        case 0:
            RequestOn (lpobj, cfFormat);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            ASSERT (TRUE, "unexpected step in Requestdata");
            return OLE_ERROR_GENERIC;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeGetData (lpobj, cfFormat, lphandle)
//
//  Returns the data handle for a given format
//
//  Arguments:
//
//       lpobj:       source object
//       cfFormat:    ref fprmat
//       lphandle:    handle return
//
//  Returns:
//      NULL                : no more formats or if we do not understand the
//                            given format.
//
//  Note: Even if the object is connected, we do not get the data from the
//        server. Getdata can not be used for getting data in any other
//        format other than the formats available with the object on
//        the client side.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeGetData (lpobj, cfFormat, lphandle)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);
    
    *lphandle = NULL;

    // The assumption made here is that the native data can be in either
    // LE object or picture object.
    if ((cfFormat == cfNative) && (lpobj->hnative)) {
        ASSERT ((lpobj->head.ctype == CT_EMBEDDED) || (!lpobj->lpobjPict) ||
            ((*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, NULL)
                        != cfNative), "Native data at wrong Place");
        *lphandle = lpobj->hnative;
        return OLE_OK;
    }
    
    if (cfFormat == cfOwnerLink && lpobj->head.ctype == CT_EMBEDDED) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;
        
        return OLE_ERROR_BLANK;
    }

    if ((cfFormat == cfObjectLink || cfFormat == cfLink) &&
            lpobj->head.ctype == CT_LINK) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;
        
        return OLE_ERROR_BLANK;
    }
    
    if (cfFormat == cfNetworkName) {
        if (lpobj->aNetName && (*lphandle = GetNetNameHandle (lpobj)))
            return OLE_WARN_DELETE_DATA;

        return OLE_ERROR_BLANK;
    }
    
    if (cfFormat == lpobj->cfExtra) {
        if (*lphandle = lpobj->hextraData)
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (!lpobj->lpobjPict && cfFormat)
        return OLE_ERROR_FORMAT;
    
    return (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, cfFormat, lphandle);
}




OLESTATUS FARINTERNAL LeQueryOutOfDate (lpobj)
LPOBJECT_LE    lpobj;
{
    return OLE_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Converts a given  linked/embedded object to static object.
//
//  Arguments:
//          lpobj      : source object
//          lpprotocol : protocol
//          lpclient   : client callback for the new object
//          lhclientdoc: client doc
//          lpobjname  : object name
//          lplpobj    : object return
//
//
//  Returns:
//      OLE_OK          :  successful
//      OLE_ERROR_....  :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS       retVal;

    PROBE_ASYNC (lpobj);
    
    *lplpobj = NULL;
    
    if (lstrcmp (lpprotocol, PROTOCOL_STATIC))
        return OLE_ERROR_PROTOCOL;

    if (!lpobj->lpobjPict || 
            ((*lpobj->lpobjPict->lpvtbl->QueryType) (lpobj->lpobjPict, NULL)
                    == OLE_ERROR_GENERIC)) {
        // Either no picture object or non-standard picture object.
        // Create a metafile Object.
    
        HDC             hMetaDC;
        RECT            rc; 
        HANDLE          hMF = NULL, hmfp = NULL;
        LPMETAFILEPICT  lpmfp;
    
        OleQueryBounds ((LPOLEOBJECT) lpobj, &rc);
        if (!(hMetaDC = CreateMetaFile (NULL)))
            goto Cleanup;
        
        SetWindowOrg (hMetaDC, rc.left, rc.top);
        SetWindowExt (hMetaDC, rc.right - rc.left, rc.bottom - rc.top);
        retVal = OleDraw ((LPOLEOBJECT) lpobj, hMetaDC, &rc, &rc, NULL);
        hMF = CloseMetaFile (hMetaDC);
        if ((retVal != OLE_OK) ||  !hMF)
            goto Cleanup;
        
        if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof (METAFILEPICT))))
            goto Cleanup;
            
        if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)))
            goto Cleanup;
        
        lpmfp->hMF  = hMF;
        lpmfp->mm   = MM_ANISOTROPIC;
        lpmfp->xExt = rc.right - rc.left;
        lpmfp->yExt = rc.top - rc.bottom;
        GlobalUnlock (hmfp);
        
        if (*lplpobj = (LPOLEOBJECT) MfCreateObject (hmfp, lpclient, TRUE, 
                                        lhclientdoc, lpobjname, CT_STATIC))
            return OLE_OK;

Cleanup:        
        if (hMF) 
            DeleteMetaFile (hMF);
        
        if (hmfp)
            GlobalFree (hmfp);
        
        return OLE_ERROR_MEMORY;
    }

    
    // Picture object is one of the standard objects
    if ((retVal = (*lpobj->lpobjPict->lpvtbl->Clone) (lpobj->lpobjPict, 
                                lpclient, lhclientdoc, 
                                lpobjname, lplpobj)) == OLE_OK) {
        (*lplpobj)->ctype = CT_STATIC;
        DocAddObject ((LPCLIENTDOC) lhclientdoc, *lplpobj, lpobjname);
    }
    
    return retVal;
}



// internal method used for changing picture/native data
OLESTATUS FARINTERNAL LeChangeData (lpobj, hnative, lpoleclient, fDelete)
LPOBJECT_LE     lpobj;
HANDLE          hnative;
LPOLECLIENT     lpoleclient;
BOOL            fDelete;
{
    if (!fDelete) {
        if (!(hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }

    // In case of a CopyFromLink, eventhough the object type is CT_LINK, the
    // native data should go to LE object rather than the picture object, as
    // we are going to change the object type to embedded after the required
    // data is recieved.
        
    if ((lpobj->head.ctype == CT_LINK) 
            && (lpobj->asyncCmd != OLE_COPYFROMLNK)
            && (lpobj->asyncCmd != OLE_CREATEFROMFILE)) {
        if (lpobj->lpobjPict)
            return  (*lpobj->lpobjPict->lpvtbl->SetData) 
                            (lpobj->lpobjPict, cfNative, hnative);
    }
    else { // It must be embedded.
        if (lpobj->hnative)
            GlobalFree (lpobj->hnative);
        lpobj->hnative = hnative;
        return OLE_OK;
    }
    
    return OLE_ERROR_BLANK;
}



////////////////////////////////////////////////////////////////////////////////
//
//  LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
//
//  Create a blank object. Global block is used for the object and it is
//  locked once sucessful. Unlocking is done only while deletion. Object
//  is added to the corresponding doc.
//
//  'LE' signature is used for object validation.
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        ctype;
{
    HOBJECT        hobj;
    LPOBJECT_LE    lpobj;

    if (!(ctype == CT_LINK || ctype == CT_EMBEDDED || ctype == CT_OLDLINK))
        return NULL;

    if (!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, 
                        sizeof (OBJECT_LE))))
        return NULL;

    if (!(lpobj = (LPOBJECT_LE) GlobalLock (hobj))) {
        GlobalFree (hobj);
        return NULL;
    }

    if (ctype == CT_OLDLINK) {
        ctype = CT_LINK;
        lpobj->bOldLink = TRUE;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = ctype;
    lpobj->head.iTable   = INVALID_INDEX;

    lpobj->head.lpvtbl  = (LPOLEOBJECTVTBL)&vtblLE;
 
    if (ctype == CT_LINK){
        lpobj->optUpdate = oleupdate_always;

    }else {
        lpobj->optUpdate = oleupdate_onclose;
    }
    lpobj->head.hobj = hobj;
    DocAddObject ((LPCLIENTDOC) lhclientdoc, (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}


void FARINTERNAL SetExtents (LPOBJECT_LE lpobj)
{   
    RECT    rc = {0, 0, 0, 0};

    if (lpobj->lpobjPict) {
        if ((*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, 
                                        (LPRECT)&rc) == OLE_OK) {   
            // Bounds are in MM_HIMETRIC units  
            lpobj->head.cx = (LONG) (rc.right - rc.left);  
            lpobj->head.cy = (LONG) (rc.bottom - rc.top);  
        }
        return;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeSaveToStream (lpobj, lpstream)
//
//  Save the object to the stream. Uses the stream functions provided
//  in the lpclient.
//
//  Format: (!!! Document the fomrat here).
//
//
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeSaveToStream (lpobj, lpstream)
LPOBJECT_LE    lpobj;
LPOLESTREAM    lpstream;
{

//    PROBE_OBJECT_BLANK(lpobj);
    
    PROBE_CREATE_ASYNC(lpobj);
    
    if (lpobj->head.ctype == CT_LINK && lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    return LeStreamWrite (lpstream, lpobj);
}



////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
//
//  Create an object, loading the object from the stream.
//
//  Arguments:
//      lpstream            : stream table
//      lpclient            : client callback table
//      lhclientdoc         : Doc handle foe which the object should be created
//      lpobjname           : Object name
//      lplpoleobject       : object return
//      ctype               : Type of object
//      aClass              : class atom
//      cfFormat            : render format
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                ctype;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_LE lpobj = NULL;
    OLESTATUS   retval = OLE_ERROR_STREAM;
    LONG        type;   // this not same as ctype
    LONG        ver;
    char        chVerb [2];

    *lplpoleobject = NULL;        

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, ctype)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    lpobj->app = aClass; 
    // if the entry is present, then it is
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);

    if (LeStreamRead (lpstream, lpobj) == OLE_OK) {

        // Get exe name from aClass and set it as aServer
        SetExeAtom (lpobj);
        if (!GetBytes (lpstream, (LPSTR) &ver, sizeof(LONG))) {
            if (!GetBytes (lpstream, (LPSTR) &type, sizeof(LONG))) {
                if (type == CT_NULL) 
                    retval = OLE_OK;
                else if (aClass = GetAtomFromStream (lpstream)) {
                    retval = DefLoadFromStream (lpstream, NULL, lpclient, 
                                        lhclientdoc, lpobjname,
                                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict,
                                        CT_PICTURE, aClass, cfFormat);
                }
            }
        }
        
        if (retval == OLE_OK) {
            SetExtents (lpobj);
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            if (lpobj->lpobjPict)
                lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
            
            if ((lpobj->head.ctype != CT_LINK)
                    || (!InitDocConv (lpobj, !POPUP_NETDLG))
                    || (lpobj->optUpdate >= oleupdate_oncall))
                return OLE_OK;
            
            lpobj->fCmd = ACT_ADVISE;
            
            // If it's auto update, then get the latest data.
            if (lpobj->optUpdate == oleupdate_always)  
                lpobj->fCmd |= ACT_REQUEST;         

            FarInitAsyncCmd (lpobj, OLE_LOADFROMSTREAM, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);
        }
    }

    // This delete will not run into async command. We did not even
    // even connect.
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



//

OLESTATUS INTERNAL LeStreamRead (lpstream, lpobj)
LPOLESTREAM lpstream;
LPOBJECT_LE lpobj;
{
    DWORD          dwBytes;
    LPSTR          lpstr;
    OLESTATUS      retval = OLE_OK;

    if (!(lpobj->topic = GetAtomFromStream(lpstream))
            && (lpobj->head.ctype != CT_EMBEDDED))
        return OLE_ERROR_STREAM;
    
    // !!! This atom could be NULL. How do we distinguish the
    // error case

    lpobj->item = GetAtomFromStream(lpstream);

    if (lpobj->head.ctype == CT_EMBEDDED)  {
        if (GetBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpobj->hnative = GlobalAlloc (GMEM_MOVEABLE, dwBytes)))
            return OLE_ERROR_MEMORY;
        else if (!(lpstr = GlobalLock (lpobj->hnative))) {
            GlobalFree (lpobj->hnative);
            return OLE_ERROR_MEMORY;
        }
        else {
            if (GetBytes(lpstream, lpstr, dwBytes))
                retval = OLE_ERROR_STREAM;
            GlobalUnlock (lpobj->hnative);
        }
        
        if (retval == OLE_OK)
            SetEmbeddedTopic (lpobj);
    }
    else {
        if (lpobj->aNetName = GetAtomFromStream (lpstream)) {
            if (HIWORD(dwVerFromFile) == OS_MAC) {
                // if it is a mac file this field will have "ZONE:MACHINE:"
                // string. Lets prepend this to the topic, so that server 
                // app or user can fix the string
                    
                ATOM    aTemp;

                aTemp = wAtomCat (lpobj->aNetName, lpobj->topic);
                GlobalDeleteAtom (lpobj->aNetName);
                lpobj->aNetName = NULL;
                GlobalDeleteAtom (lpobj->topic);
                lpobj->topic = aTemp;
            }
            else 
                SetNetDrive (lpobj);
        }
            
        if (HIWORD(dwVerFromFile) != OS_MAC) { 
            if (GetBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
                return OLE_ERROR_STREAM;
        }
        
        if (GetBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    return retval;
}



OLESTATUS INTERNAL LeStreamWrite (lpstream, lpobj)
LPOLESTREAM lpstream;
LPOBJECT_LE lpobj;
{
    LPSTR   lpstr;
    DWORD   dwBytes = 0L;
    LONG    nullType = CT_NULL;
    int     error;
    
    if (PutAtomIntoStream(lpstream, lpobj->app))
        return OLE_ERROR_STREAM;
   
    if (lpobj->head.ctype == CT_EMBEDDED) { 
        // we set the topic at load time, no point in saving it
        if (PutBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->topic))
            return OLE_ERROR_STREAM;
    }
    
#ifdef OLD
    if (PutAtomIntoStream(lpstream, lpobj->topic))
        return OLE_ERROR_STREAM;            
#endif          
            
    if (PutAtomIntoStream(lpstream, lpobj->item))
        return OLE_ERROR_STREAM;

    // !!! deal with objects > 64k

    if (lpobj->head.ctype == CT_EMBEDDED) {
        
        if (!lpobj->hnative)
            return OLE_ERROR_BLANK;

        // assumption low bytes are first
        dwBytes = GlobalSize (lpobj->hnative);

        if (PutBytes (lpstream, (LPSTR)&dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
        
        if (!(lpstr = GlobalLock (lpobj->hnative)))
            return OLE_ERROR_MEMORY;

        error = PutBytes (lpstream, lpstr, dwBytes);
        GlobalUnlock (lpobj->hnative);

        if (error)
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->aNetName))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
            return OLE_ERROR_STREAM;
        
        if (PutBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->SaveToStream) (lpobj->lpobjPict, 
                                                    lpstream);

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &nullType, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    return OLE_OK;
}


/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
LPOBJECT_LE lpobj;
LPLONG      lptype;
{
    Puts("LeQueryType");

    if ((lpobj->head.ctype == CT_EMBEDDED)
            || (lpobj->asyncCmd == OLE_COPYFROMLNK)
            || (lpobj->asyncCmd == OLE_CREATEFROMFILE)) 
        *lptype = CT_EMBEDDED;
    else if ((lpobj->head.ctype == CT_LINK) 
                || (lpobj->head.ctype == CT_OLDLINK))
        *lptype = CT_LINK;
    else 
        return OLE_ERROR_OBJECT;
    
    return OLE_OK;
}



// ContextCallBack: internal function. Calls callback function of <hobj>
// with flags.

int FARINTERNAL ContextCallBack (lpobj, flags)
LPOLEOBJECT         lpobj;
OLE_NOTIFICATION    flags;
{
    LPOLECLIENT     lpclient;
    
    Puts("ContextCallBack");

    if (!FarCheckObject(lpobj))
        return FALSE;

    if (!(lpclient = lpobj->lpclient))
        return FALSE;

    ASSERT (lpclient->lpvtbl->CallBack, "Client Callback ptr is NULL");
    
    return ((*lpclient->lpvtbl->CallBack) (lpclient, flags, lpobj));
}


void FARINTERNAL DeleteExtraData (lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->hextraData == NULL)
        return;

    switch (lpobj->cfExtra) {
        case CF_BITMAP:
            DeleteObject (lpobj->hextraData);           
            break;
            
        case CF_METAFILEPICT:
        {
            LPMETAFILEPICT  lpmfp;
            
            if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (lpobj->hextraData)))
                break;
            
            DeleteMetaFile (lpmfp->hMF);
            GlobalUnlock (lpobj->hextraData);
            GlobalFree (lpobj->hextraData);
            break;
        }
            
        default:
            GlobalFree (lpobj->hextraData);
    }
    
    lpobj->hextraData = NULL;
}


void   INTERNAL DeleteObjectAtoms(lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->app) {
        GlobalDeleteAtom (lpobj->app);
        lpobj->app = NULL;
    }
    
    if (lpobj->topic) {
        GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = NULL;
    }
    
    if (lpobj->item) {
        GlobalDeleteAtom (lpobj->item);
        lpobj->item  = NULL;
    }
    
    if (lpobj->aServer) {
        GlobalDeleteAtom (lpobj->aServer);
        lpobj->aServer = NULL;
    }
    
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
}


// LeGetUpdateOptions: Gets the update options.

OLESTATUS   FARINTERNAL LeGetUpdateOptions (lpobj, lpOptions)
LPOBJECT_LE         lpobj;
OLEOPT_UPDATE   FAR *lpOptions;
{
    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_OBJECT;

    *lpOptions = lpobj->optUpdate;
    return OLE_OK;
}




OLESTATUS FARINTERNAL  LnkPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, sfFormat)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
OLECLIPFORMAT       sfFormat;
{
    LPOBJECT_LE lpobj  = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD    
    if (!bWLO) {
        // we are not running under WLO
        if (!(hInfo = GetClipboardData (sfFormat))) {
            if (hInfo = GetClipboardData (cfLink))
                lpobj->bOldLink = TRUE;
        }
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!IsClipboardFormatAvailable (sfFormat))
        lpobj->bOldLink = TRUE;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    if ((retval = SetNetName(lpobj)) != OLE_OK) {    
        // see whether network name is on the clipboard and try to use it
        HANDLE  hNetName;
        LPSTR   lpNetName;
        
        if (!IsClipboardFormatAvailable (cfNetworkName))
            goto errRtn;
        
        if (!(hNetName = GetClipboardData (cfNetworkName))) 
            goto errRtn;
    
        if (!(lpNetName = GlobalLock (hNetName)))
            goto errRtn;
        
        GlobalUnlock (hNetName);
        if (!(lpobj->aNetName = GlobalAddAtom (lpNetName)))
            goto errRtn;
        
        SetNetDrive (lpobj);
    }

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname, 
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);
    
    if (retval == OLE_OK) {
        SetExtents (lpobj);
                // why do we have to update the link, do we show it?

        // Reconnect if we could and advise for updates
        *lplpoleobject = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
        
        if (!InitDocConv (lpobj, !POPUP_NETDLG))
             return OLE_OK;             // document is not loaded , it is OK.

        lpobj->fCmd = ACT_ADVISE | ACT_REQUEST;
        FarInitAsyncCmd (lpobj, OLE_LNKPASTE, LNKOPENUPDATE);
        return LnkOpenUpdate (lpobj);

    } 
    else {
errRtn:
        if (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

    return retval;
}



// !!! EmbPaste and LnkPaste Can be combined
OLESTATUS FARINTERNAL  EmbPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_LE lpobj = NULL;
    HANDLE      hnative;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!IsClipboardFormatAvailable (cfOwnerLink))
        return OLE_ERROR_CLIPBOARD;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD    
    if (!bWLO) {
        // we are not running under WLO
        hInfo = GetClipboardData (cfOwnerLink);
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    SetEmbeddedTopic (lpobj);

    hnative = GetClipboardData (cfNative);
    if (!(lpobj->hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
        goto errRtn;

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    } 
    else {
errRtn:
        // Note:  This oledelete should not result in any async commands.
        if  (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

#ifdef EXCEL_BUG    
    // Some server apps (ex: Excel) copy picture (to clipboard) which is
    // formatted for printer DC. So, we want to update the picture if the
    // server app is running, and the it's a old server
        
    if ((retval == OLE_OK) && (!lpobj->bOleServer)) {
        lpobj->fCmd =  LN_EMBACT | ACT_NOLAUNCH | ACT_REQUEST | ACT_UNLAUNCH;
        FarInitAsyncCmd (lpobj, OLE_EMBPASTE, EMBOPENUPDATE);
        if ((retval = EmbOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            return OLE_OK;
    }
#endif

    return retval;
}



BOOL INTERNAL SetLink (lpobj, hinfo, lpLpClass)
LPOBJECT_LE     lpobj;
HANDLE          hinfo;
LPSTR FAR *     lpLpClass;
{
    LPSTR   lpinfo;
    char    chVerb[2];
    // If there exits a conversation, then terminate it.

    if (!(lpinfo = GlobalLock (hinfo)))
        return FALSE;
    
    *lpLpClass = lpinfo;
    
#if FIREWALLS
     if (lpobj->pDocEdit)
        ASSERT (!lpobj->pDocEdit->hClient, "unexpected client conv exists");
#endif

    lpobj->app = GlobalAddAtom (lpinfo);
    SetExeAtom (lpobj);
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);

//  lpobj->aServer = GetAppAtom (lpinfo);
        
    lpinfo += lstrlen (lpinfo) + 1;
    lpobj->topic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        lpobj->item = GlobalAddAtom (lpinfo);
    else
        lpobj->item = NULL;
    
    if (lpobj->hLink) {             // As the atoms have already changed, 
        GlobalFree (lpobj->hLink);  // lpobj->hLink becomes irrelevant.
        lpobj->hLink = NULL;
    }
    
    if (lpinfo)
        GlobalUnlock(hinfo);

    if (!lpobj->app)
        return FALSE;

    if (!lpobj->topic && (lpobj->head.ctype == CT_LINK))
        return FALSE;
    
    lpobj->hLink = DuplicateGlobal (hinfo, GMEM_MOVEABLE);
    return TRUE;
}



HANDLE INTERNAL GetLink (lpobj)
LPOBJECT_LE    lpobj;
{
    HANDLE  hLink = NULL;
    LPSTR   lpLink;
    int     len;
    WORD    size;

    if (lpobj->hLink)
        return lpobj->hLink;

    size = 4;    // three nulls and one null at the end
    size += GlobalGetAtomLen (lpobj->app);
    size += GlobalGetAtomLen (lpobj->topic);
    size += GlobalGetAtomLen (lpobj->item);

    if (!(hLink = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;
    
    if (!(lpLink = GlobalLock (hLink))) {
        GlobalFree (hLink);
        return NULL;
    }
    
    len = (int) GlobalGetAtomName (lpobj->app, lpLink, size);
    lpLink += ++len;

    len = (int) GlobalGetAtomName (lpobj->topic, lpLink, (size -= len));
    lpLink += ++len;

    if (!lpobj->item) 
        *lpLink = NULL;
    else {
        len = (int) GlobalGetAtomName (lpobj->item, lpLink, size - len);
        lpLink += len;
    }
    
    *++lpLink = NULL;     // put another null the end
    GlobalUnlock (hLink);
    return (lpobj->hLink = hLink);

}


void FARINTERNAL SetEmbeddedTopic (lpobj)
LPOBJECT_LE    lpobj;
{
    LPCLIENTDOC lpdoc;
    char        buf[MAX_STR];
    char        buf1[MAX_STR];
    LPSTR       lpstr, lptmp;
    int         len;
    
    if (lpobj->topic) 
        GlobalDeleteAtom (lpobj->topic);

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
    
    lpobj->cDrive       = NULL;
    lpobj->dwNetInfo    = NULL;
    lpobj->head.ctype   = CT_EMBEDDED;
    
    lpdoc = (LPCLIENTDOC) lpobj->head.lhclientdoc;
    lpstr = (LPSTR) buf;
    lptmp = (LPSTR) buf1;
    ASSERT(lpdoc->aDoc, "lpdoc->aDoc is null");
    GlobalGetAtomName (lpdoc->aDoc, lpstr, sizeof(buf));
    
    // strip the path
    lpstr += (len = lstrlen(lpstr)); 
    while (--lpstr != (LPSTR) buf) {
        if ((*lpstr == '\\') || (*lpstr == ':')) {
            lpstr++;
            break;
        }
    }
    
    GlobalGetAtomName (lpdoc->aClass, lptmp, sizeof(buf1));
    lstrcat (lptmp, "%");
    lstrcat (lptmp, lpstr);
    lstrcat (lptmp, "%");
    lpstr = lptmp;
    lptmp += lstrlen (lptmp);
    
    if (lpobj->head.aObjName) {
        GlobalGetAtomName (lpobj->head.aObjName, lptmp, sizeof(buf)-(len+1));
    }
    
    if ((embStr[EMB_ID_INDEX] += 1) > '9') {
        embStr[EMB_ID_INDEX] = '0';
        if ((embStr[EMB_ID_INDEX - 1] += 1) > '9') {
            embStr[EMB_ID_INDEX - 1] = '0';
            if ((embStr[EMB_ID_INDEX - 2] += 1) > '9')
                embStr[EMB_ID_INDEX - 2] = '0';
        }
    }
    
    lstrcat (lptmp, embStr);

    lpobj->topic = GlobalAddAtom (lpstr);
    
    // Topic, item have changed, lpobj->hLink is out of date.
    if (lpobj->hLink) {             
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
}


/////////////////////////////////////////////////////////////////////
//                                                                 //
// Routines related to the asynchronous processing.                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

void NextAsyncCmd (lpobj, mainRtn)
LPOBJECT_LE lpobj;
WORD        mainRtn;
{
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;

}

void  InitAsyncCmd (lpobj, cmd, mainRtn)
LPOBJECT_LE lpobj;
WORD        cmd;
WORD        mainRtn;
{
        lpobj->asyncCmd = cmd;
        lpobj->mainErr  = OLE_OK;
        lpobj->mainRtn  = mainRtn;
        lpobj->subRtn   = 0;
        lpobj->subErr   = 0;
        lpobj->bAsync   = 0;
        lpobj->endAsync = 0;
        lpobj->errHint  = 0;
}

void  FARINTERNAL FarInitAsyncCmd (lpobj, cmd, mainRtn)
LPOBJECT_LE lpobj;
WORD        cmd;
WORD        mainRtn;
{
    return (InitAsyncCmd(lpobj, cmd, mainRtn));
}


OLESTATUS EndAsyncCmd (lpobj)
LPOBJECT_LE lpobj;
{

    OLESTATUS   olderr;


    if (!lpobj->endAsync) {
        lpobj->asyncCmd = OLE_NONE;
        return OLE_OK;
    }


    // this is an asynchronous operation. Send callback with or without
    // error.

    switch (lpobj->asyncCmd) {

        case    OLE_DELETE:
            break;

        case    OLE_COPYFROMLNK:
        case    OLE_CREATEFROMFILE:
            // change the topic name to embedded.
            SetEmbeddedTopic (lpobj);
            break;

        case    OLE_LOADFROMSTREAM:
        case    OLE_LNKPASTE:
        case    OLE_RUN:
        case    OLE_SHOW:
        case    OLE_ACTIVATE:
        case    OLE_UPDATE:
        case    OLE_CLOSE:
        case    OLE_RECONNECT:
        case    OLE_CREATELINKFROMFILE:
        case    OLE_CREATEINVISIBLE:                        
        case    OLE_CREATE:
        case    OLE_CREATEFROMTEMPLATE:
        case    OLE_SETUPDATEOPTIONS:
        case    OLE_SERVERUNLAUNCH:
        case    OLE_SETDATA:
        case    OLE_REQUESTDATA:
        case    OLE_OTHER:
            break;

        case    OLE_EMBPASTE:
            lpobj->mainErr = OLE_OK;
            break;
            
        default:
            DEBUG_OUT ("unexpected maincmd", 0);
            break;

    }

    lpobj->bAsync   = FALSE;
    lpobj->endAsync = FALSE;
    lpobj->oldasyncCmd = lpobj->asyncCmd;
    olderr          = lpobj->mainErr;
    lpobj->asyncCmd = OLE_NONE;  // no async command in progress.

    if (lpobj->head.lpclient)
        ContextCallBack (lpobj, OLE_RELEASE);

    lpobj->mainErr  = OLE_OK;
    return olderr;
}


BOOL   ProcessErr   (lpobj)
LPOBJECT_LE  lpobj;
{

    if (lpobj->subErr == OLE_OK)
        return FALSE;

    if (lpobj->mainErr == OLE_OK)
        lpobj->mainErr = lpobj->subErr;

    lpobj->subErr = OLE_OK;
    return TRUE;
}


void ScheduleAsyncCmd (lpobj)
LPOBJECT_LE  lpobj;
{

    // replacs this with direct proc jump later on.
#ifdef  FIREWALLS
    ASSERT (lpobj->bAsync, "Not an asynchronous command");
#endif
    lpobj->bAsync = FALSE;

    // if the object is active and we do pokes we go thru this path
    // !!! We may have to go thru the endasynccmd.

    if ((lpobj->asyncCmd == OLE_OTHER) 
            || ((lpobj->asyncCmd == OLE_SETDATA) && !lpobj->mainRtn)) {
        lpobj->endAsync = TRUE;
        lpobj->mainErr = lpobj->subErr;     
        EndAsyncCmd (lpobj);
        if (lpobj->bUnlaunchLater) {
            lpobj->bUnlaunchLater = FALSE;
            CallEmbLnkDelete(lpobj);
        }
        
        return;
    }
    
    switch (lpobj->mainRtn) {

        case EMBLNKDELETE:
            EmbLnkDelete (lpobj);
            break;

        case LNKOPENUPDATE:
            LnkOpenUpdate (lpobj);
            break;

        case DOCSHOW:
            DocShow (lpobj);
            break;


        case EMBOPENUPDATE:
            EmbOpenUpdate (lpobj);
            break;


        case EMBLNKCLOSE:
            EmbLnkClose (lpobj);
            break;

        case LNKSETUPDATEOPTIONS:
            LnkSetUpdateOptions (lpobj);
            break;

        case LNKCHANGELNK:
            LnkChangeLnk (lpobj);
            break;

        case REQUESTDATA:
            RequestData (lpobj, NULL);
            break;

        default:
            DEBUG_OUT ("Unexpected asyn command", 0);
            break;
    }

    return;
}

void SetNetDrive (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR];
    
    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))
            && (buf[1] == ':')) {
        AnsiUpperBuff ((LPSTR) buf, 1);
        lpobj->cDrive = buf[0];
    }
}

HANDLE GetNetNameHandle (lpobj)
LPOBJECT_LE lpobj;
{
    HANDLE  hNetName;
    LPSTR   lpNetName;
    WORD    size;
    
    if (!(size = GlobalGetAtomLen (lpobj->aNetName)))
        return NULL;

    size++;
    if (!(hNetName = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;
    
    if (lpNetName = GlobalLock (hNetName)) {
        GlobalUnlock (hNetName);
        if (GlobalGetAtomName(lpobj->aNetName, lpNetName, size)) 
            return hNetName;
    }

    // error case
    GlobalFree (hNetName);
    return NULL;
}

BOOL AreTopicsEqual (lpobj1, lpobj2)
LPOBJECT_LE lpobj1;
LPOBJECT_LE lpobj2;
{
    char    buf1[MAX_STR];
    char    buf2[MAX_STR];
    
    if (lpobj1->aNetName != lpobj2->aNetName)
        return FALSE;
    
    if (!lpobj1->aNetName) {
        if (lpobj1->topic == lpobj2->topic)
            return TRUE;
        
        return FALSE;
    }
    
    if (!GlobalGetAtomName (lpobj1->topic, buf1, MAX_STR))
        return FALSE;
    
    if (!GlobalGetAtomName (lpobj2->topic, buf2, MAX_STR))
        return FALSE;
    
    if (!lstrcmpi (&buf1[1], &buf2[1]))
        return TRUE;
    
    return FALSE;
}
    

ATOM FARINTERNAL wAtomCat (
ATOM        a1, 
ATOM        a2)
{
    char    buf[MAX_STR+MAX_STR];
    LPSTR   lpBuf = (LPSTR)buf;
    
    if (!GlobalGetAtomName (a1, lpBuf, MAX_STR+MAX_STR))
        return NULL;
    
    lpBuf += lstrlen(lpBuf);
    
    if (!GlobalGetAtomName(a2, lpBuf, MAX_STR))
        return NULL;
    
    return GlobalAddAtom ((LPSTR) buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\generic.c ===
/****************************** Module Header ******************************\
* Module Name: GENERIC.C
*
* Handles all API routines for the generic sub-dll of the ole dll.
* Since the data format is unknown, all the routines are written with the
* assumption that all the relevant data is placed in a single global data 
* segment. Note that this assumption is not valid for metafiles, bitmaps, and
* and there can always be some other formats with such idiosyncracies. To
* accommodate those cases the rendering dll writer should replace the relevant
* routines after the creation of the generic object. If for a given class this
* assumption (about data format) is valid then the dll writer need to replace
* only the Draw and QueryBounds functions. 
*
* Created: November-1990
*
* Copyright (c) 1990, 1991 Microsoft Corporation
*
* History:
*
*  Srinik, Raor  (11/05/90) Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

char aMacText[4] = {'T', 'E', 'X', 'T'};
char aMacRtf[4]  = "RTF";

extern OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#pragma alloc_text(_TEXT, GenSaveToStream, GenLoadFromStream, GetBytes, PutBytes, PutStrWithLen, PutAtomIntoStream, GenQueryBounds)


OLEOBJECTVTBL    vtblGEN  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        GenRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // plat
        GenGetData,         // Get the object data
        GenSetData,         // Set the object data
        ErrSetTargetDevice, //
    
        ErrSetBounds,       // set viewport bounds
        GenEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        GenRelease,         // delete
        ErrSetHostNames,    //

        GenSaveToStream,    // write to file
        GenClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Link

        GenEqual,           // compares the given objects for data equality

        GenCopy,            // copy to clip

        GenDraw,            // draw the object
            
        ErrActivate,        // open
        ErrExecute,         // excute 
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name

        GenQueryType,       // Object type
        GenQueryBounds,     // QueryBounds        
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current
            
        ErrQueryRelease,     // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        GenChangeData      // change data of the existing object
};


OLESTATUS  FARINTERNAL GenRelease (lpobj)
LPOBJECT_GEN     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hData) {
        GlobalFree (lpobj->hData);
        lpobj->hData = NULL;
    }
    
    if (lpobj->aClass)
        GlobalDeleteAtom (lpobj->aClass);
    
    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL GenSaveToStream (lpobj, lpstream)
LPOBJECT_GEN    lpobj;
LPOLESTREAM     lpstream;
{
    LPSTR       lpData;
    OLESTATUS   retVal = OLE_OK;
    DWORD       dwClipFormat = NULL;     
    char        formatName[MAX_STR];
    
    if (!lpobj->hData)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutAtomIntoStream (lpstream, lpobj->aClass))
        return OLE_ERROR_STREAM;

    if (lpobj->cfFormat < 0xC000) 
        // then it is a predefined format
        dwClipFormat = lpobj->cfFormat;

    if (PutBytes (lpstream, (LPSTR) &dwClipFormat, sizeof(DWORD)))
        return OLE_ERROR_STREAM;
    
    if (!dwClipFormat) {
        if (!GetClipboardFormatName (lpobj->cfFormat, (LPSTR) formatName,
                        sizeof(formatName)))
            return OLE_ERROR_FORMAT;
        
        if (PutStrWithLen (lpstream, formatName))
            return OLE_ERROR_STREAM;
    }
            
    if (!lpobj->sizeBytes) 
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
        return OLE_ERROR_STREAM;
    
    if (!(lpData = GlobalLock (lpobj->hData)))
        return OLE_ERROR_MEMORY;
    
    if (PutBytes (lpstream, lpData, lpobj->sizeBytes))
        retVal = OLE_ERROR_STREAM;
        
    GlobalUnlock (lpobj->hData);
    return retVal;
}


OLESTATUS FARINTERNAL  GenClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_GEN        lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_GEN  FAR * lplpobj;
{
    if (!lpobjsrc->hData)
        return OLE_ERROR_BLANK;
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = GenCreateObject (lpobjsrc->hData, lpclient, 
                            FALSE, lhclientdoc, 
                            lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else {
        (*lplpobj)->cfFormat = lpobjsrc->cfFormat;
        (*lplpobj)->aClass = DuplicateAtom (lpobjsrc->aClass);
        return OLE_OK;
    }
}



OLESTATUS FARINTERNAL  GenEqual (lpobj1, lpobj2)
LPOBJECT_GEN lpobj1;
LPOBJECT_GEN lpobj2;
{
    if (CmpGlobals (lpobj1->hData, lpobj2->hData))
        return OLE_OK; 
        
    return  OLE_ERROR_NOT_EQUAL;
}



OLESTATUS FARINTERNAL GenCopy (lpobj)
LPOBJECT_GEN lpobj;
{
    HANDLE  hData;
    
    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (!(hData = DuplicateGlobal (lpobj->hData, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    
    SetClipboardData (lpobj->cfFormat, hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_GEN    lpobj = NULL;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    HANDLE          hData;
    LPSTR           lpData;    
    DWORD           dwClipFormat; 
    char            formatName[MAX_STR];
    LONG            length;
    
    if (!(*lplpobj = (LPOLEOBJECT) (lpobj = GenCreateBlank(lhclientdoc, 
                                                    lpobjname, objType, 
                                                    aClass)))) {
        if (aClass)
            GlobalDeleteAtom(aClass);
        return OLE_ERROR_MEMORY;
    }

    if (GetBytes (lpstream, (LPSTR) &dwClipFormat, sizeof (DWORD))) 
        goto errLoad;

    // If object is from MAC then we will keep the data intact if the data
    // format is either TEXT or RTF 
    if (HIWORD(dwVerFromFile) == OS_MAC) {
        if (dwClipFormat ==  *((DWORD *) aMacText))
            lpobj->cfFormat = CF_TEXT;
        else if (dwClipFormat == *((DWORD *) aMacRtf))
            lpobj->cfFormat = RegisterClipboardFormat ((LPSTR) "Rich Text Format");
        else 
            lpobj->cfFormat = NULL;
    }
    else {
        // object is created on windows
        if (!dwClipFormat) {
            // this is new file format. format name string follows
            if (GetBytes (lpstream, (LPSTR) &length, sizeof (LONG))
                    || GetBytes (lpstream, (LPSTR)formatName, length)
                    || (!(lpobj->cfFormat = RegisterClipboardFormat ((LPSTR) formatName))))
                goto errLoad;
        }
        else if ((lpobj->cfFormat = (WORD) dwClipFormat) >= 0xc000) {
            // if format is not predefined and file format is old, then use
            // what value is passed to you through "cfFormat" argument
            lpobj->cfFormat = cfFormat;
        }
    }
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof (DWORD))) 
        goto errLoad;

    lpobj->head.lpclient = lpclient;
    
    retVal = OLE_ERROR_MEMORY;
    if (!(hData = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)))
        goto errLoad;
    
    if (!(lpData = GlobalLock (hData)))
        goto errMem;
    
    if (GetBytes (lpstream, lpData, lpobj->sizeBytes)) {
        retVal = OLE_ERROR_STREAM;
        GlobalUnlock (hData);
        goto errMem;
    }
    
    lpobj->hData = hData;
    GlobalUnlock (hData);
    
    // if the object is from MAC then we want delete this and create blank
    // metafile object, which draws a rectangle
    if ((HIWORD(dwVerFromFile) == OS_MAC) && !lpobj->cfFormat) {
        LPOBJECT_MF lpobjMf;
        
        OleDelete ((LPOLEOBJECT)lpobj);  // delete generic object
            
        // Now create a dummy metafile object which draws a rectangle of size
        // 1" x 1". Note that 1" = 2540 HIMETRIC units
        lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, objType);
        lpobjMf->head.cx = lpobjMf->mfp.xExt = 2540;
        lpobjMf->head.cy = - (lpobjMf->mfp.yExt = 2540);
        if ((retVal = wCreateDummyMetaFile (lpobjMf, lpobjMf->mfp.xExt,
                                    lpobjMf->mfp.yExt)) != OLE_OK) {
            OleDelete ((LPOLEOBJECT) lpobjMf);
            return retVal;
        }
        
        *lplpobj = (LPOLEOBJECT) lpobjMf; 
    }
    
    return OLE_OK;

errMem:
    GlobalFree (hData);
    
errLoad:        
    OleDelete ((LPOLEOBJECT)lpobj);
    *lplpobj = NULL;
    return OLE_ERROR_STREAM;
}




LPOBJECT_GEN INTERNAL GenCreateObject (hData, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE      hData;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_GEN     lpobj;
    
    if (!hData)
        return NULL;
    
    if (lpobj = GenCreateBlank (lhclientdoc, lpobjname, objType, NULL)) {
        if (GenChangeData (lpobj, hData, lpclient, fDelete) != OLE_OK) {
            GenRelease (lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewData will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL GenChangeData (lpobj, hSrcData, lpclient, fDelete)
LPOBJECT_GEN    lpobj;
HANDLE          hSrcData;
LPOLECLIENT     lpclient;
BOOL            fDelete;
{
    HANDLE      hDestData;
    
    if (!fDelete) {
        if (!(hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE))) 
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself
        if (!(hDestData = GlobalReAlloc(hSrcData,0L,GMEM_MODIFY|GMEM_SHARE))){
            hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
            GlobalFree (hSrcData);
            if (!hDestData)
                return OLE_ERROR_MEMORY;
        }
    }
    
    lpobj->head.lpclient = lpclient;
    if (lpobj->hData)
        GlobalFree (lpobj->hData);
    lpobj->hData = hDestData;
    lpobj->sizeBytes = GlobalSize (hDestData);
    
    return OLE_OK;
}



LPOBJECT_GEN FARINTERNAL GenCreateBlank(lhclientdoc, lpobjname, objType, aClass)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
ATOM        aClass;
{
    HOBJECT         hobj;
    LPOBJECT_GEN    lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_GEN)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_GEN) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblGEN;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    lpobj->aClass           = aClass;
    
    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
            (LPOLEOBJECT) lpobj, lpobjname);
        
    return lpobj;
}


OLESTATUS FARINTERNAL GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj, lpClass, cfFormat, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LPSTR               lpClass;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    HANDLE  hData = NULL;

    *lplpobj = NULL;
    if (!cfFormat) 
        return OLE_ERROR_FORMAT;
    
    if (!(hData = GetClipboardData(cfFormat)))
        return OLE_ERROR_MEMORY;

    if (!(*lplpobj = (LPOLEOBJECT) GenCreateObject (hData, lpclient, 
                                        FALSE, lhclientdoc, 
                                        lpobjname, objType)))
        return OLE_ERROR_MEMORY;
    
    ((LPOBJECT_GEN)(*lplpobj))->cfFormat = cfFormat;
    ((LPOBJECT_GEN)(*lplpobj))->aClass = GlobalAddAtom (lpClass);
    return OLE_OK;

}



OLESTATUS FARINTERNAL GenQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    return OLE_ERROR_GENERIC;;
}



OLESTATUS FARINTERNAL GenSetData (lpobj, cfFormat, hData)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{

    if (lpobj->cfFormat != cfFormat)
        return OLE_ERROR_FORMAT;
    
    if (!hData)
        return OLE_ERROR_BLANK;
    
    GlobalFree (lpobj->hData);
    lpobj->hData = hData;
    lpobj->sizeBytes = GlobalSize (hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenGetData (lpobj, cfFormat, lphandle)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != lpobj->cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hData))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;

}


OLECLIPFORMAT FARINTERNAL GenEnumFormat (lpobj, cfFormat)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return lpobj->cfFormat;
    
    return NULL;
}


OLESTATUS FARINTERNAL GenQueryBounds (lpobj, lpRc)
LPOBJECT_GEN    lpobj;
LPRECT          lpRc;
{
    lpRc->right     = 0;
    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->bottom    = 0;
    return OLE_ERROR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\mf.c ===
/****************************** Module Header ******************************\
* Module Name:MF.C (Extensible Compound Documents - Metafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*
*   Raor, Srinik    (../../1990,91)  Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

WORD    wGDIds = NULL;

OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#pragma alloc_text(_TEXT, MfSaveToStream, MfLoadFromStream, GetBytes, PutBytes, PutStrWithLen, MfQueryBounds, OleIsDcMeta, GetGDIds, IsMetaDC)

OLEOBJECTVTBL    vtblMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        MfRelease,         // Release
        ErrShow,           // show
        ErrPlay,           // play
        MfGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
        ErrSetBounds,      // set viewport bounds
        MfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //   
        MfRelease,         // delete
        ErrSetHostNames,   //
            
        MfSaveToStream,    // write to file
        MfClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Lnk

        MfEqual,           // compares the given objects for data equality

        MfCopy,            // copy to clip

        MfDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute 
        ErrClose,          // stop 
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type
            
        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
        ObjQueryType,      // Object type
        MfQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        MfChangeData       // change data of the existing object
};




OLESTATUS FARINTERNAL  MfRelease (lpobj)
LPOBJECT_MF lpobj;
{
    HOBJECT hobj;

    if (lpobj->mfp.hMF) {
        DeleteMetaFile (lpobj->mfp.hMF);
        lpobj->mfp.hMF = NULL;
    }
    
    if (lpobj->hmfp)
        GlobalFree (lpobj->hmfp);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);
    
    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  MfSaveToStream (lpobj, lpstream)
LPOBJECT_MF lpobj;
LPOLESTREAM lpstream;
{
    OLESTATUS   retVal = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    
    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) 
        return  OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (!(hBits = GetMetaFileBits (lpobj->mfp.hMF)))
        return OLE_ERROR_MEMORY;

    if (lpBits = (LPSTR) GlobalLock (hBits)) {
        if (!PutBytes (lpstream, (LPSTR)&lpobj->mfp, sizeof(METAFILEPICT)))
            if (!PutBytes (lpstream, (LPSTR)lpBits, 
                        lpobj->sizeBytes - sizeof(METAFILEPICT)))
                retVal = OLE_OK;

        GlobalUnlock(hBits);
    } 
    else
        retVal = OLE_ERROR_MEMORY;

    lpobj->mfp.hMF = SetMetaFileBits (hBits);
    return retVal;
}




OLESTATUS FARINTERNAL  MfClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_MF         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_MF  FAR *  lplpobj;
{
    LPOBJECT_MF lpobjMf;
    HANDLE      hmf;

    *lplpobj = NULL;
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(hmf = CopyMetaFile (lpobjsrc->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, 
                        lpobjsrc->head.ctype)) {
        lpobjMf->mfp            = lpobjsrc->mfp;
        lpobjMf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjMf->mfp.hMF        = hmf;
        lpobjMf->head.lpclient  = lpclient;
        lpobjMf->head.mm        = lpobjMf->mfp.mm;
        MfSetExtents (lpobjMf);

        *lplpobj = lpobjMf;
        return OLE_OK;
    }
    
    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  MfEqual (lpobj1, lpobj2)
LPOBJECT_MF lpobj1;
LPOBJECT_MF lpobj2;
{
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    OLESTATUS   retval = OLE_ERROR_NOT_EQUAL;
    
    if (!(hBits1 = GetMetaFileBits (lpobj1->mfp.hMF))) 
        goto errEqual;
    
    if (!(hBits2 = GetMetaFileBits (lpobj2->mfp.hMF)))
        goto errEqual;
    
    if (CmpGlobals (hBits1, hBits2))
        retval = OLE_OK;
    
errEqual:   
    if (hBits1)
        lpobj1->mfp.hMF = SetMetaFileBits (hBits1);
    
    if (hBits2)
        lpobj2->mfp.hMF = SetMetaFileBits (hBits2);     
    
    return retval;
}


OLESTATUS FARINTERNAL  MfCopy (LPOBJECT_MF lpobj)
{
    HANDLE          hMF;

    if (!(hMF = CopyMetaFile (lpobj->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    return (MfCopyToClip (lpobj, hMF));
}



OLESTATUS FARINTERNAL MfQueryBounds (lpobj, lpRc)
LPOBJECT_MF     lpobj;
LPRECT          lpRc;
{
    Puts("MfQueryBounds");

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;
    
    // Bounds are given in MM_HIMETRIC mode. 
        
    lpRc->left      = 0;  
    lpRc->top       = 0;  
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL  MfEnumFormat (lpobj, cfFormat)
LPOBJECT_MF     lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return CF_METAFILEPICT;

    return NULL;
}


OLESTATUS FARINTERNAL MfGetData (lpobj, cfFormat, lphandle)
LPOBJECT_MF     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_METAFILEPICT) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = GetHmfp (lpobj)))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;
}


LPOBJECT_MF FARINTERNAL  MfCreateObject (hMeta, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE          hMeta;
LPOLECLIENT     lpclient;
BOOL            fDelete;
LHCLIENTDOC     lhclientdoc;
LPSTR           lpobjname;
LONG            objType;
{
    LPOBJECT_MF     lpobj;

    if (lpobj = MfCreateBlank (lhclientdoc, lpobjname, objType)) {
        if (MfChangeData (lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            MfRelease (lpobj);
            lpobj = NULL;
        }
    }
    
    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL MfChangeData (lpobj, hMeta, lpclient, fDelete)
LPOBJECT_MF lpobj;
HANDLE      hMeta;
LPOLECLIENT lpclient;
BOOL        fDelete;
{
    HANDLE          hNewMF;
    LPMETAFILEPICT  lpMetaPict;
    
    if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMeta)) == NULL) {
        if (fDelete)
            GlobalFree (hMeta);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hMeta);
    
    if (!fDelete) {
        if (!(hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
            return OLE_ERROR_MEMORY;
    }
    else {
        hNewMF = lpMetaPict->hMF;
    }
   
    return MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hNewMF, fDelete);
}


OLESTATUS INTERNAL MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hMF, fDelete)
LPOBJECT_MF     lpobj;
LPOLECLIENT     lpclient;
HANDLE          hMeta;
LPMETAFILEPICT  lpMetaPict;
HANDLE          hMF;
BOOL            fDelete;
{
    OLESTATUS   retVal;
    DWORD       size;
    HANDLE      hOldMF;

    hOldMF = lpobj->mfp.hMF;

    ASSERT(lpMetaPict->mm == MM_ANISOTROPIC, "Wrong mapping mode")
    if (lpMetaPict->mm != MM_ANISOTROPIC) 
        retVal = OLE_ERROR_METAFILE;
    else if (!(size = MfGetSize (&hMF))) 
        retVal = OLE_ERROR_BLANK;
    else {
        lpobj->mfp     = *lpMetaPict;
        lpobj->mfp.hMF = hMF;
        lpobj->sizeBytes = size + sizeof(METAFILEPICT);
        lpobj->head.lpclient = lpclient;
        lpobj->head.mm = lpobj->mfp.mm;
        if (lpobj->hmfp) {
            GlobalFree (lpobj->hmfp);
            lpobj->hmfp = NULL; 
        }
        MfSetExtents (lpobj);  
        if (hOldMF)
            DeleteMetaFile (hOldMF);
        retVal =  OLE_OK;
    }

    if (retVal != OLE_OK)
        DeleteMetaFile (hMF);

    if (fDelete)
        GlobalFree (hMeta);
    return retVal;
}


LPOBJECT_MF FARINTERNAL MfCreateBlank(lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT     hobj;
    LPOBJECT_MF lpobj;

    if(!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_MF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_MF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblMF;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                    (LPOLEOBJECT) lpobj, lpobjname);
                
    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  MfLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpobj, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
{
    LPOBJECT_MF lpobj = NULL;
    OLESTATUS   retVal = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    DWORD       dwSizeMfp = NULL;
    
    // Class name would've been read by this time.
        
    *lplpobj = NULL;        
    
    if (!(lpobj = MfCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG))) 
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;
    
    if (!lpobj->sizeBytes) {
        retVal = OLE_ERROR_BLANK;
        goto errLoad;
    }

    // if we are reading a MAC object we want to skip this
    if (HIWORD(dwVerFromFile) == OS_WIN16) {
        if (GetBytes (lpstream, (LPSTR) &lpobj->mfp, sizeof(METAFILEPICT)))
            goto errLoad;
        
        dwSizeMfp = sizeof(METAFILEPICT);
    }
    
    retVal = OLE_ERROR_MEMORY;
    if (!(hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes - dwSizeMfp)))
        goto errLoad;
    
    if (!(lpBits = (LPSTR)GlobalLock (hBits))) 
        goto errMem;
    
    if (GetBytes (lpstream, (LPSTR)lpBits, lpobj->sizeBytes - dwSizeMfp)) {
        retVal = OLE_ERROR_MEMORY;
        GlobalUnlock (hBits);
        goto errMem;
    }
    
    lpobj->head.mm = lpobj->mfp.mm;
    GlobalUnlock (hBits);
    
    if (HIWORD(dwVerFromFile) == OS_WIN16) {
        if (!(lpobj->mfp.hMF = SetMetaFileBits (hBits)))
            goto errMem;
    }
    else {
        // if we are reading a MAC object we want to delete the original
        // presentation data and show some rectangle

        GlobalFree (hBits);
        lpobj->mfp.xExt = (int) lpobj->head.cx;
        lpobj->mfp.yExt = (int) lpobj->head.cy;
        
        if ((retVal = wCreateDummyMetaFile (lpobj, lpobj->mfp.xExt,
                                    lpobj->mfp.yExt)) != OLE_OK)
            goto errLoad;
    }
        
    MfSetExtents (lpobj);

    *lplpobj = (LPOLEOBJECT) lpobj;
    return OLE_OK;

errMem: 
    GlobalFree (hBits);
    
errLoad:    
    OleDelete ((LPOLEOBJECT)lpobj);
    return retVal;
}




OLESTATUS FARINTERNAL  MfPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HANDLE      hMeta;

    *lplpoleobject = NULL;
    
    if((hMeta = GetClipboardData (CF_METAFILEPICT)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) MfCreateObject (hMeta, lpclient, 
                                                FALSE, lhclientdoc, 
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}




OLESTATUS INTERNAL MfCopyToClip (lpobj, hMF)
LPOBJECT_MF lpobj;
HANDLE      hMF;
{
    LPMETAFILEPICT  lpMeta;
    HANDLE          hMeta;
    
    if (!(hMeta = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return OLE_ERROR_MEMORY;

    if (lpMeta = (LPMETAFILEPICT) GlobalLock(hMeta)){
        *lpMeta = lpobj->mfp;
        if (hMF)
            lpMeta->hMF = hMF;
        else
            lpobj->mfp.hMF = NULL;
        GlobalUnlock (hMeta);
        SetClipboardData(CF_METAFILEPICT, hMeta);
        return OLE_OK;
    }
    
    GlobalFree(hMeta);
    return OLE_ERROR_MEMORY;
}



void FARINTERNAL MfSetExtents (LPOBJECT_MF lpobj)
{
    if (lpobj->mfp.xExt > 0) { 
        // The extents are assumed to be in MM_HIMETIRC units       
        lpobj->head.cx = (LONG) lpobj->mfp.xExt;
        lpobj->head.cy = (LONG) - lpobj->mfp.yExt;
    }
}


DWORD INTERNAL MfGetSize (lphmf)
LPHANDLE lphmf;
{
    HANDLE hBits;
    DWORD  size;
    
    if ((hBits = GetMetaFileBits (*lphmf)) == NULL)
        return NULL;
    
    size = GlobalSize(hBits);        
    *lphmf = SetMetaFileBits (hBits);       
    return size;
}



HANDLE INTERNAL GetHmfp (lpobj)
LPOBJECT_MF lpobj;
{
    HANDLE          hmfp;
    LPMETAFILEPICT  lpmfp = NULL;
    
    if (lpobj->hmfp)
        return lpobj->hmfp;
    
    if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return NULL;
    
    if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))) {
        GlobalFree (hmfp);
        return NULL;
    }   
    
    *lpmfp = lpobj->mfp;
    GlobalUnlock (hmfp);
    return (lpobj->hmfp = hmfp);
}


BOOL FAR PASCAL OleIsDcMeta (hdc)
HDC         hdc;
{
    if (!bWLO && (wWinVer == 0x0003)) {
        
        WORD    wDsAlias, wGDIcs = HIWORD(SaveDC);
        WORD    wOffset = LOWORD(((DWORD)SaveDC));
        WORD FAR PASCAL AllocCStoDSAlias (WORD);
        WORD FAR PASCAL FreeSelector (WORD);
        
        if (!wGDIds) {
            wDsAlias = AllocCStoDSAlias (wGDIcs);
            wGDIds = GetGDIds (MAKELONG(wOffset, wDsAlias));
            FreeSelector (wDsAlias);
        }
        
        return IsMetaDC (hdc, wGDIds);
    }
    else
        return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

OLESTATUS FARINTERNAL wCreateDummyMetaFile (
LPOBJECT_MF     lpobj,
int             xExt,
int             yExt)
{
    HDC hMetaDC;
    
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return OLE_ERROR_MEMORY;
        
    SetWindowOrg (hMetaDC, 0, 0);
    SetWindowExt (hMetaDC, xExt, yExt);
    Rectangle (hMetaDC, 0, 0, xExt, yExt);
    if (!(lpobj->mfp.hMF = CloseMetaFile (hMetaDC)))
        return OLE_ERROR_MEMORY;
    lpobj->mfp.mm    = MM_ANISOTROPIC;
    lpobj->sizeBytes = MfGetSize (&lpobj->mfp.hMF) + sizeof(METAFILEPICT);
    return OLE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\net.c ===
/****************************** Module Header ******************************\
* Module Name: net.c 
*
* PURPOSE: Contains routines  network support
*
* Created: Feb 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  02\12\1190  Orginal
*
\***************************************************************************/

#include <windows.h>
#include <winnet.h>

#include "dll.h"

#define MAX_DRIVE   26

char    szNULL[] = "";
char    szSS[] = "SS";
char    szOffset[] = "OFFSET";


BOOL FAR PASCAL GetTaskVisibleWindow (HWND, DWORD);
void INTERNAL RemoveNetName (LPOBJECT_LE);

// Gets the drive letter from topic (if one exists) and then gets the remote
// name for that drive and then saves it in the object.

OLESTATUS FARINTERNAL SetNetName (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR];
    WORD    cbBuf = sizeof(buf);
    WORD    driveType;
    char    szDrive[3];
    
    if (lpobj->head.ctype == CT_EMBEDDED) 
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->topic, buf, cbBuf))
        return OLE_ERROR_BLANK;
    
    if (buf[1] != ':') {
        RemoveNetName (lpobj);
        return OLE_OK;
    }

    szDrive[2] = NULL;
    szDrive[1] = ':';
    szDrive[0] = buf[0];
    AnsiUpperBuff ((LPSTR) szDrive, 1);
        
    if (!(driveType = GetDriveType (szDrive[0] - 'A'))) {
        // drive is non existent
        return OLE_ERROR_DRIVE;
    }

    if  (driveType == DRIVE_REMOTE) {
         if (WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf)
                    != WN_SUCCESS)
             return OLE_ERROR_DRIVE;
            
         lpobj->cDrive = szDrive[0];
         if (lpobj->aNetName)
             GlobalDeleteAtom (lpobj->aNetName);
         lpobj->aNetName = GlobalAddAtom(buf);
         lpobj->dwNetInfo = MAKELONG((WNetGetCaps (WNNC_NET_TYPE)),
                                     (WNetGetCaps (WNNC_DRIVER_VERSION)));
    } 
    else {
        RemoveNetName (lpobj);
    }

    return OLE_OK;
}


// If netname exists for the given object, then it makes sure that drive 
// in topic corresponds to the netname. If it's not the drive letter will
// be fixed by calling FixNet()

OLESTATUS FARINTERNAL CheckNetDrive (lpobj, fNetDlg)
LPOBJECT_LE lpobj;
BOOL        fNetDlg;
{
    char    buf[MAX_NET_NAME];   
    char    netName[MAX_NET_NAME];
    WORD    cbBuf = sizeof(buf);
    char    szDrive[3];
    
    if (lpobj->head.ctype == CT_EMBEDDED) 
        return OLE_OK;

    if (!lpobj->aNetName)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->aNetName, netName, sizeof(netName)))
        return OLE_ERROR_MEMORY;
    
    szDrive[2] = NULL;
    szDrive[1] = ':';
    if (!(szDrive[0] = lpobj->cDrive)) {
        if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf)))
            szDrive[0] = lpobj->cDrive = buf[0];
    }
    
    if ((WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf) 
            == WN_SUCCESS)  && (!lstrcmp(netName, buf)))
        return OLE_OK;

    return FixNet (lpobj, netName, fNetDlg);
}


// Find if there is a drive connected to the given server. If so, get the 
// drive letter and set it in topic. If not try to make connection, and if 
// that attempt is successful the set the drive letter in topic.

OLESTATUS INTERNAL FixNet (lpobj, lpNetName, fNetDlg)
LPOBJECT_LE lpobj;
LPSTR       lpNetName;
BOOL        fNetDlg;
{
    int         nDrive = 2;     // drive 'C'
    OLESTATUS   retVal;
    
    if (SetNextNetDrive(lpobj, &nDrive, lpNetName))
        return OLE_OK;
    
    if (fNetDlg != POPUP_NETDLG)
        return OLE_ERROR_NETWORK;
    
    if ((retVal = ConnectNet (lpobj, lpNetName)) == OLE_OK) {
        if (!ChangeTopic (lpobj))
            return OLE_ERROR_BLANK;
    }
    
    return retVal;
}



BOOL FARINTERNAL SetNextNetDrive (lpobj, lpnDrive, lpNetName)
LPOBJECT_LE lpobj;
int FAR *   lpnDrive;
LPSTR       lpNetName;
{
    char    buf[MAX_STR];
    WORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (!lpNetName[0]) {
        if (!GlobalGetAtomName(lpobj->aNetName, lpNetName, MAX_STR))
            return FALSE;
    }
    
    szDrive[2] = NULL;
    szDrive[1] = ':';
    while (*lpnDrive < MAX_DRIVE) {
        if (GetDriveType (++*lpnDrive) == DRIVE_REMOTE) {
            szDrive[0] = (char) ('A' + *lpnDrive);
            cbBuf = sizeof(buf);            
            if ((WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf)
                        == WN_SUCCESS) && (!lstrcmp(lpNetName, buf))) {
                lpobj->cDrive = szDrive[0];
                return ChangeTopic (lpobj);
            }
        }
    }
    
    return FALSE;
}


BOOL FARINTERNAL ChangeTopic (lpobj)
LPOBJECT_LE lpobj;
{
    char buf[MAX_STR];   
  
    if (!GlobalGetAtomName(lpobj->topic, buf, sizeof(buf)))
        return FALSE;
    if (lpobj->topic)
        GlobalDeleteAtom(lpobj->topic);
    buf[0] = lpobj->cDrive;
    lpobj->topic = GlobalAddAtom (buf);
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
    
    return TRUE;
}



OLESTATUS INTERNAL ConnectNet (lpobj, lpNetName)
LPOBJECT_LE lpobj;
LPSTR       lpNetName;
{
    FARPROC     lpConnectDlg;
    FARPROC     lpGetTaskVisWnd;
    OLESTATUS   retVal = OLE_ERROR_MEMORY;
    HWND        hCurTask;
    HWND        hwndParent = NULL;
    
    if (!(lpConnectDlg = MakeProcInstance ((FARPROC) ConnectDlgProc, 
                                    hInstDLL)))
        return OLE_ERROR_MEMORY;


    hCurTask = GetCurrentTask();
    ASSERT (hCurTask, "Current task handle in NULL");
    
    if (!(lpGetTaskVisWnd = MakeProcInstance (GetTaskVisibleWindow,hInstDLL)))
        goto errRtn;
    
    // Get the container task's main window, and use that as parent for
    // the dlg box.
    EnumTaskWindows (hCurTask, lpGetTaskVisWnd,
        (DWORD) ((WORD FAR *) &hwndParent));

    if (lpobj->cDrive = (char) DialogBoxParam (hInstDLL, "CONNECTDLG", 
                                    hwndParent, lpConnectDlg, 
                                    (DWORD) lpNetName)) 
        retVal = OLE_OK;
    else
        retVal = OLE_ERROR_NETWORK;

    FreeProcInstance (lpGetTaskVisWnd);
    
errRtn: 
    FreeProcInstance (lpConnectDlg);
    return retVal;
}



int FAR PASCAL ConnectDlgProc(HWND hDlg, WORD wMsg, WORD wParam, DWORD lParam)
{
    char            szPassword[32];
    char            szTitle[64];
    
    switch (wMsg) {
        case WM_INITDIALOG: 
            SetProp (hDlg, szSS, HIWORD (lParam));
            SetProp (hDlg, szOffset, LOWORD (lParam));
            FillDrives (hDlg);
            SetDlgItemText (hDlg, IDD_PATH, (LPSTR) lParam);
            break;
            
        case WM_COMMAND:
            switch (wParam) {

                case IDOK:
                {
                    WORD    cch = 128;
                    char    szMessage[128];
                    char    szDrive[3];    
                    LPSTR   lpNetName;
                    
                    GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                    GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, 
                                sizeof(szPassword));
                    lpNetName = (LPSTR) MAKELONG(((WORD) GetProp (hDlg, szOffset)), ((WORD) GetProp (hDlg, szSS)));
                    wParam = WNetAddConnection (lpNetName, 
                                (LPSTR) szPassword, szDrive);
                            
                    if (wParam == WN_SUCCESS)  {
                        RemoveProp (hDlg, szSS);
                        RemoveProp (hDlg, szOffset);
                        EndDialog (hDlg, szDrive[0]);
                        return TRUE;
                    }

                    LoadString (hInstDLL, IDS_NETERR, szTitle, 
                        sizeof(szTitle));
                    if (WNetGetErrorText (wParam, szMessage, &cch) 
                                    != WN_SUCCESS) 
                        LoadString (hInstDLL, IDS_NETCONERRMSG, 
                            szMessage, sizeof(szMessage));
                        
                    if (MessageBox (hDlg, szMessage, szTitle, 
                            MB_RETRYCANCEL | MB_SYSTEMMODAL) == IDCANCEL) 
                        goto error;

                    if (wParam == WN_ALREADY_CONNECTED)
                        FillDrives (hDlg);
                    SetDlgItemText (hDlg, IDD_PASSWORD, szNULL);
                    break;
                }

                case IDCANCEL:
error:                  
                    RemoveProp (hDlg, szSS);
                    RemoveProp (hDlg, szOffset);
                    EndDialog(hDlg, NULL);
                    return TRUE;

                case IDD_DRIVE:
                    break;

                case IDD_PATH:
                    if (HIWORD(lParam) == EN_KILLFOCUS) {
                        LPSTR   lpNetName;
                        
                        lpNetName = (LPSTR) MAKELONG(((WORD)GetProp (hDlg, szOffset)), ((WORD) GetProp (hDlg, szSS)));
                        
                        SendDlgItemMessage (hDlg, IDD_PATH, WM_SETTEXT, 0,
                                    (DWORD) lpNetName);
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }
    
    return FALSE;
}


VOID INTERNAL FillDrives (hDlg)
HWND    hDlg;
{
    HWND    hwndCB;
    int     nDrive = 3;
    char    szDrive[3];

    hwndCB = GetDlgItem(hDlg, IDD_DRIVE); 
    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    szDrive[2] = NULL;
    szDrive[1] = ':';
    while (nDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + nDrive); 
        if (!GetDriveType (nDrive))
            SendMessage(hwndCB, CB_ADDSTRING, 0, (DWORD)(LPSTR)szDrive);
        nDrive++;
    }
    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
}


BOOL FAR PASCAL GetTaskVisibleWindow (hWnd, lpTaskVisWnd)
HWND    hWnd;
DWORD   lpTaskVisWnd; 
{
    if (IsWindowVisible (hWnd)) {
        *(WORD FAR *) lpTaskVisWnd = hWnd;
         return FALSE;
    }
    
    return TRUE;
}

void INTERNAL RemoveNetName (LPOBJECT_LE lpobj)
{
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
      
    lpobj->cDrive = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\ole.c ===
/******************************* Module Header *******************************
* Module Name: OLE.C 
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* PURPOSE: API routines for handling generic objects (which may be static,
*    linked, or embedded).  These routines will be made into a DLL.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik  (../../90, 91)    Designed/coded.
*
*****************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

extern DLL_ENTRY        lpDllTable[];
extern char             packageClass[];
extern OLECLIPFORMAT    cfFileName;
extern DWORD            dwOleVer;

DWORD           dwVerFromFile;
HANDLE          hInfo = NULL;
CLIENTDOC       lockDoc = {{'C', 'D'}, 0L, 0L, 0, 0, 0, 0L, 0L};
LHCLIENTDOC     lhLockDoc = (LHCLIENTDOC) ((LPCLIENTDOC) &lockDoc);
BOOL            gbCreateInvisible = FALSE;
BOOL            gbLaunchServer;


OLESTATUS INTERNAL LockServer (LPOBJECT_LE);

#pragma alloc_text(_DDETEXT, OleLockServer, OleUnlockServer, LockServer, IsServerValid, DeleteSrvrEdit, InitSrvrConv, LeLaunchApp)


//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
//   
//  Tells whether the object supports the specified protocol. 
//
//  Arguments:
//
//      lpobj       -   object pointer
//      lpprotocol  -   protocol string
//
//  Returns:
//
//      long ptr to object if the protocol is supported
//      NULL if not.
//
//  Effects:     
//
//////////////////////////////////////////////////////////////////////////////


LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
LPOLEOBJECT lpobj;
LPSTR       lpprotocol;
{
    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->QueryProtocol) (lpobj, lpprotocol);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FAR PASCAL  OleDelete (lpobj)
//   
//  Deletes the given object and all memory associated with its sub-parts.  
//  The calling function should cease to use 'lpobj', as it is now invalid. 
//  If handler dll is used reference count is reduced by one, and if it 
//  reaches zero the hanlder dll will be freed up.
//
//  Arguments:
//
//      lpobj   -   object pointer
//
//  Returns:
//
//      OLE_OK 
//      OLE_ERROR_OBJECT
//      OLE_WAIT_FOR_RELEASE
//
//  Effects:     
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL  OleDelete (lpobj)
LPOLEOBJECT    lpobj;
{
    Puts("OleDelete");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->Delete) (lpobj);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRelease (lpobj)
*
* OleRelease: 
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRelease (lpobj)
LPOLEOBJECT    lpobj;
{
    Puts("OleRelease");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->Release) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
*
* oleSaveToStream: This will read <hobj> to the stream based on the <hfile>
* structure.  It will return TRUE on success.  This is the only object
* function for which it is not an error to pass a NULL <hobj>.  In the case
* of NULL, this function will simply put a placemarker for an object.
* See oleLoadFromStream.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
LPOLEOBJECT    lpobj;
LPOLESTREAM    lpstream;
{
    Puts("OleSaveToStream");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpstream);

    return ((*lpobj->lpvtbl->SaveToStream) (lpobj, lpstream));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotcol, lpclient, lhclientdoc, lpobjname, lplpobj)
*
*  oleLoadFromStream: This will read an object out of the stream based on the
*  <hfile> structure.  It will return a HANDLE to the object it creates.
*  On error, the return value is NULL, but since NULL is also a valid object
*  in the file, the <error> parameter should be checked as well.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    LONG            len;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    char            class[100];
    ATOM            aClass;
    BOOL            bEdit = FALSE, bStatic = FALSE;
    LONG            ctype;
    int             objCount;
    int             iTable = INVALID_INDEX;
    
    Puts("OleLoadFromStream");

    *lplpobj = NULL;

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpstream);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleLoadFromStream\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
            
    if (!(bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)))
        if (!(bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)))
            return OLE_ERROR_PROTOCOL;

    if (GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (GetBytes (lpstream, (LPSTR)&ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (ctype == CT_NULL) 
        return (bStatic ? OLE_OK: OLE_ERROR_PROTOCOL);
            
    if (((ctype != CT_PICTURE) && (ctype != CT_STATIC) && bStatic) ||
            ((ctype != CT_LINK) && (ctype != CT_OLDLINK) 
                && (ctype != CT_EMBEDDED) && bEdit))
        return OLE_ERROR_PROTOCOL;

    if ((ctype == CT_STATIC) && ((HIWORD(dwVerFromFile)) != OS_WIN16))
        return OLE_ERROR_STATIC_FROM_OTHER_OS;
            
    //** Get Class 
    if (GetBytes(lpstream, (LPSTR)&len, sizeof(len)))
        return OLE_ERROR_STREAM;

    if (len == 0)
        return OLE_ERROR_STREAM;
    
    if (GetBytes(lpstream, (LPSTR)&class, len))
        return OLE_ERROR_STREAM;

    aClass = GlobalAddAtom (class);
    
    if ((ctype == CT_PICTURE) || (ctype == CT_STATIC)) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);

    //!!! It's the DLL's responsibility to delete the atom. But in case of 
    // failure we delete the atom if our DefLoadFromStream().
        
    else if ((iTable = LoadDll (class)) == INVALID_INDEX) {
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);
    }
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Load) (lpstream, lpprotocol, lpclient, 
                       lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;        
    }

    return retVal;
}



OLESTATUS FAR PASCAL  OleClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS   retVal;
    
    Puts("OleClone");

    if (!CheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleClone\n");
#endif

    PROBE_READ(lpobjname);  
    
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    PROBE_WRITE(lplpobj);

    *lplpobj = NULL;   
    
    retVal = (*lpobjsrc->lpvtbl->Clone) (lpobjsrc, lpclient, 
                        lhclientdoc, lpobjname, lplpobj);
                    
    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;
    
    return retVal;
}


OLESTATUS FAR PASCAL  OleCopyFromLink (lpobjsrc, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobjsrc;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS   retVal;
    
    Puts("OleCopyFromLnk");

    if (!CheckObject(lpobjsrc))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCopyFromLink\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    
    *lplpobj = NULL;
        
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;
    
    retVal = (*lpobjsrc->lpvtbl->CopyFromLink) (lpobjsrc, lpclient, 
                        lhclientdoc, lpobjname, lplpobj);
    
    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;


    return retVal;

}



OLESTATUS FAR PASCAL  OleEqual (lpobj1, lpobj2)
LPOLEOBJECT lpobj1;
LPOLEOBJECT lpobj2;
{
    if (!CheckObject(lpobj1))
        return OLE_ERROR_OBJECT;

    if (!CheckObject(lpobj2))
        return OLE_ERROR_OBJECT;

    if (lpobj1->ctype != lpobj2->ctype)
        return OLE_ERROR_NOT_EQUAL;
    
    return ((*lpobj1->lpvtbl->Equal) (lpobj1, lpobj2));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryFromClip: Returns OLE_OK if a linked object can be created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotocol, optRender, cfFormat)
LPSTR           lpprotocol;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleQueryLinkFromClip");
    return LeQueryCreateFromClip (lpprotocol, optRender, cfFormat, CT_LINK);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryCreateFromClip: Returns true if a non-linked object can be
* created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotocol, optRender, cfFormat)
LPSTR           lpprotocol;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleQueryCreateFromClip");
    return (LeQueryCreateFromClip (lpprotocol, optRender, 
                        cfFormat, CT_EMBEDDED));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotcol, lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
*
*
*  oleCreateLinkFromClip: This function creates the LP to an object from the
*  clipboard.  It will try to create a linked object.  Return value is OLE_OK
*  is the object is successfully created it
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT  FAR *  lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    int         objCount;
    int         iTable = INVALID_INDEX;
    OLESTATUS   retVal;
    LPSTR       lpInfo;
    
    Puts("OleCreateLinkFromClip");
    
    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);   
    PROBE_WRITE(lplpobj);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromClip\n");
#endif

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    *lplpobj = NULL;
    
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;
    
    if (IsClipboardFormatAvailable (cfFileName))
        return CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, 
                        lplpobj, optRender, cfFormat, CT_LINK);
                    
    if (!(hInfo = GetClipboardData (cfObjectLink)))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpInfo = GlobalLock(hInfo)))
        return OLE_ERROR_CLIPBOARD;

    iTable = LoadDll (lpInfo);
    GlobalUnlock (hInfo);


    if (iTable == INVALID_INDEX)
        retVal = DefCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc,
                        lpobjname, lplpobj, optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Link) (lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj, optRender, cfFormat);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;                         
        else
            (*lplpobj)->iTable = iTable;
    }
    
    hInfo = NULL;
    return retVal;
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateFromClip (lpprotcol, lpclient, lplpoleobject, optRender, cfFormat)
*
*
* oleCreateFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create an embedded object if
*  OwnerLink and Native are available, otherwise it will create a static
*  picture.  Return value is OLE_OK if the object is successfully
*  created it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;
    LONG            ctype;
    int             iTable = INVALID_INDEX;
    LPSTR           lpInfo;
    LPSTR           lpClass = NULL;
    int             objCount;   
    OLECLIPFORMAT   cfEnum = NULL;

    Puts("OleCreateFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromClip\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    *lplpobj = NULL;

    if (!lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (optRender == olerender_none) 
            return OLE_ERROR_OPTION;

        if ((optRender == olerender_format) && (cfFormat != CF_METAFILEPICT)
                && (cfFormat != CF_DIB) && (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;
        
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT)   
                && !IsClipboardFormatAvailable (CF_DIB)     
                && !IsClipboardFormatAvailable (CF_BITMAP))         
            return OLE_ERROR_FORMAT;

        return CreatePictFromClip (lpclient, lhclientdoc, 
                        lpobjname, lplpobj, optRender, 
                        cfFormat, NULL, CT_STATIC);
    }
    else if (!lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {   
        if (IsClipboardFormatAvailable (cfFileName))
            return CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, 
                            lplpobj, optRender, cfFormat, CT_EMBEDDED);
                
        if (!(hInfo = GetClipboardData (cfOwnerLink)))
            return OLE_ERROR_CLIPBOARD;
        
        while (TRUE) {
            cfEnum = EnumClipboardFormats (cfEnum);
            if (cfEnum == cfNative) {
                ctype = CT_EMBEDDED;
                break;
            }
            else if (cfEnum == cfOwnerLink) {
                ctype = CT_LINK;
                break;
            }
        }
        
        if (!(lpInfo = GlobalLock(hInfo)))
            return OLE_ERROR_CLIPBOARD;
        
        iTable = LoadDll (lpInfo);
        GlobalUnlock (hInfo);
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (iTable == INVALID_INDEX)
        retVal = DefCreateFromClip (lpprotocol, lpclient, lhclientdoc, 
                        lpobjname, lplpobj, optRender, cfFormat, ctype);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Clip) (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, ctype);
                        
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else 
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}




/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
*
*
* oleCopyToClipboard: This routine executes the standard "Copy" menu item
* on the typical "Edit" menu. Returns TRUE if successful.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleCopyToClipboard");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->CopyToClipboard) (lpobj));
}


OLESTATUS FAR PASCAL OleSetHostNames (lpobj, lpclientName, lpdocName)
LPOLEOBJECT lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    Puts ("OleSetHostNames");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    PROBE_READ(lpclientName);
    PROBE_READ(lpdocName);
    
    return ((*lpobj->lpvtbl->SetHostNames) (lpobj, lpclientName, lpdocName));
}



OLESTATUS   FAR PASCAL OleSetTargetDevice (lpobj, hDevInfo)
LPOLEOBJECT lpobj;
HANDLE      hDevInfo;
{
    Puts("OleSetTargetDevice");
    
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    return ((*lpobj->lpvtbl->SetTargetDevice) (lpobj, hDevInfo));
}



OLESTATUS   FAR PASCAL OleSetColorScheme (lpobj, lplogpal)
LPOLEOBJECT     lpobj;
LPLOGPALETTE    lplogpal;
{
    Puts("OleSetColorScheme");
    
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    return ((*lpobj->lpvtbl->SetColorScheme) (lpobj, lplogpal));
}



OLESTATUS FAR PASCAL  OleSetBounds(lpobj, lprc)
LPOLEOBJECT     lpobj;
LPRECT          lprc;
{
    Puts("OleSetBounds");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lprc);

    return ((*lpobj->lpvtbl->SetBounds) (lpobj, lprc));

}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lpRc)
*
* Returns the bounds of the object in question in MM_HIMETRIC mode. 
*           width  = lprc->right - lprc->left;  in HIMETRIC units
*           height = lprc->top - lprc->bottom;  in HIMETRIC units
*
* Returns OLE_OK or OLE_ERROR_MEMORY. 
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lprc)
LPOLEOBJECT    lpobj;
LPRECT         lprc;
{

    Puts("OleQueryBounds");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lprc);
    
    return (*lpobj->lpvtbl->QueryBounds) (lpobj, lprc);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpsize)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpdwSize)
LPOLEOBJECT    lpobj;
DWORD FAR *    lpdwSize;
{
    Puts("OleQuerySize");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpdwSize);

    *lpdwSize = NULL; 
    return (*lpobj->lpvtbl->QuerySize) (lpobj, lpdwSize);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, lphdcTarget)
*
* oleObjectDraw: This displays the given object on the device context <hcd>.
* The <htargetdc> parameter is not currently used. Returns same as Draw().
*
* Expects rectangle coordinates in MM_HIMETRIC units.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOLEOBJECT     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{

    Puts("OleObjectDraw");

    if (!FarCheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    PROBE_READ(lprc);
    if (lpWrc)
        PROBE_READ(lpWrc);
    
    return ((*lpobj->lpvtbl->Draw) (lpobj, hdc, lprc, lpWrc, hdcTarget));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
*
* returns TRUE is an object has been activated.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleQueryOpen");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOpen) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleActivate (lpobj)
*
* Activates an object. For embeded objects always a new instance is
* loaded and the instance is destroyed once the data is transferred
* at close time. For linked objects, an instance of the render is created
* only if one does not exist.
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleActivate (lpobj, verb, fShow, fActivate, hWnd, lprc)
LPOLEOBJECT lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    Puts("OleActivate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    /* PROBE_READ(lprc); */
    
    return (*lpobj->lpvtbl->Activate) (lpobj, verb, fShow, fActivate, hWnd, lprc);
}




OLESTATUS FAR PASCAL OleClose (lpobj)
LPOLEOBJECT lpobj;
{

    Puts("OleClose");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

     return (*lpobj->lpvtbl->Close) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleUpdate (lpobj)
*
* If there exists a link, sends advise for getting the latest rendering
* infromation. If there is no link, loads an instance, advises for the
* render information and closes the instance once the data is available.
* (If possible should not show the window).
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleUpdate (lpobj)
LPOLEOBJECT lpobj;
{

    Puts("OleUpdate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Update) (lpobj);

}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleReconnect (lpobj)
*
* Reconnects to the renderer if one does not exist already.
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleReconnect (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleReconnect");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Reconnect) (lpobj);
}


OLESTATUS FAR PASCAL OleGetLinkUpdateOptions (lpobj, lpOptions)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE FAR * lpOptions;
{
    Puts("OleGetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lpOptions);
    
    return (*lpobj->lpvtbl->GetLinkUpdateOptions) (lpobj, lpOptions);
}



OLESTATUS FAR PASCAL OleSetLinkUpdateOptions (lpobj, options)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE       options;
{
    Puts("OleSetLinkUpdateOptions");
        
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetLinkUpdateOptions) (lpobj, options);

}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleEnumFormats (lpobj, cfFormat)
*
* Returns OLE_YES if the object is of type LINK or EMBEDDED.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLECLIPFORMAT FAR PASCAL OleEnumFormats (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleEnumFormats");

    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->EnumFormats) (lpobj, cfFormat);
}

OLESTATUS FAR PASCAL OleRequestData (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!cfFormat)
        return OLE_ERROR_FORMAT;
    
    return (*lpobj->lpvtbl->RequestData) (lpobj, cfFormat);
}


OLESTATUS FAR PASCAL OleGetData (lpobj, cfFormat, lphandle)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lphandle);
    
    return (*lpobj->lpvtbl->GetData) (lpobj, cfFormat, lphandle);
}


OLESTATUS FAR PASCAL OleSetData (lpobj, cfFormat, hData)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    Puts("OleSetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetData) (lpobj, cfFormat, hData);
}



OLESTATUS FAR PASCAL OleQueryOutOfDate (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOutOfDate) (lpobj);
}


OLESTATUS FAR PASCAL OleLockServer (lpobjsrc, lplhsrvr)
LPOLEOBJECT     lpobjsrc;
LHSERVER FAR *  lplhsrvr;
{
    LPOBJECT_LE lpobj;
    OLESTATUS   retVal = OLE_OK;
    ATOM        aCliClass, aSvrClass;
    
    Puts ("OleLockServer");
    
    if (!FarCheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;    

    if (lpobjsrc->ctype == CT_STATIC)
        return OLE_ERROR_STATIC;
    
    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(((LPOBJECT_LE)lpobjsrc));
    FARPROBE_WRITE(lplhsrvr);

    aCliClass = ((LPCLIENTDOC)(lpobjsrc->lhclientdoc))->aClass;
    aSvrClass = ((LPOBJECT_LE)lpobjsrc)->app;

    // See whether the server is already locked
    lpobj = (LPOBJECT_LE) (lockDoc.lpHeadObj);
    while (lpobj) {
        if ((lpobj->app == aSvrClass) && (lpobj->topic == aCliClass)) {
            if (!lpobj->head.cx) {
                // The unlocking process of server handle has started. This
                // is an asynchronous process. We want to let it complete. 
                // Let's try the next handle
                    
                ;
            }
            else {
                if (!IsServerValid (lpobj)) {
                    DeleteSrvrEdit (lpobj); 
                    retVal = LockServer (lpobj);
                }
                else {
                    // Lock count
                    lpobj->head.cx++;   
                }

                if (retVal == OLE_OK) 
                    *lplhsrvr = (LHSERVER) lpobj;
            
                return retVal;
            }
        }
        
        lpobj = (LPOBJECT_LE) (lpobj->head.lpNextObj);            
    }
    
    
    if (!(lpobj = LeCreateBlank(lhLockDoc, NULL, OT_EMBEDDED)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient    = NULL;
    lpobj->head.lpvtbl      = lpobjsrc->lpvtbl;
    lpobj->app              = DuplicateAtom (aSvrClass);
    lpobj->topic            = DuplicateAtom (aCliClass);
    lpobj->aServer          = DuplicateAtom(((LPOBJECT_LE)lpobjsrc)->aServer);
    lpobj->bOleServer       = ((LPOBJECT_LE)lpobjsrc)->bOleServer;
    
    if ((retVal = LockServer (lpobj)) == OLE_OK) {
        // Change signature
        lpobj->head.objId[0] = 'S';
        lpobj->head.objId[1] = 'L';
        *lplhsrvr = (LHSERVER) lpobj;
    }
    else {
        LeRelease (lpobj);
    }
    
    return retVal;
}


OLESTATUS INTERNAL LockServer (lpobj)
LPOBJECT_LE lpobj;
{
    HANDLE hInst;
    
    if (!InitSrvrConv (lpobj, NULL)) {
        if (!lpobj->bOleServer)
            lpobj->fCmd = ACT_MINIMIZE;
        else
            lpobj->fCmd = NULL;
        
        if (!(hInst = LeLaunchApp (lpobj))) 
            return OLE_ERROR_LAUNCH;
        
        if (!InitSrvrConv (lpobj, hInst))
            return OLE_ERROR_COMM;

    }

    // lock count
    lpobj->head.cx++; 
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleUnlockServer (lhsrvr)
LHSERVER lhsrvr;
{
    LPOBJECT_LE lpobj;
    OLESTATUS   retval;
    
    Puts ("OleUnlockServer");

    if (!FarCheckPointer ((lpobj = (LPOBJECT_LE)lhsrvr), WRITE_ACCESS))
        return OLE_ERROR_HANDLE;
    
    if (lpobj->head.objId[0] != 'S' || lpobj->head.objId[1] != 'L')
        return OLE_ERROR_HANDLE;

    if (!lpobj->head.cx)
        return OLE_OK;
    
    if (--lpobj->head.cx)
        return OLE_OK;
    
    //change signature 
    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    
    if ((retval = LeRelease (lpobj)) == OLE_WAIT_FOR_RELEASE)
        DocDeleteObject ((LPOLEOBJECT)lpobj);
    
    return retval;
}


OLESTATUS FAR PASCAL OleObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;    
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleObjectConvert\n");
#endif
    
    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    


    return (*lpobj->lpvtbl->ObjectConvert) (lpobj, lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj);
}


//OleCreateFromTemplate: Creates an embedded object from Template

OLESTATUS FAR PASCAL OleCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromTemplate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lptemplate);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromTemplate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;


    // !!! we found the class name. At this point, we need to load
    // the right library and call the right entry point;

    iTable = LoadDll ((LPSTR)buf);
    if (iTable == INVALID_INDEX)
        retval = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromTemplate) (lpprotocol, 
                                lpclient, lptemplate, 
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreate: Creates an embedded object from the class.

OLESTATUS FAR PASCAL OleCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX)
        retval = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpoleobject, 
                        optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].Create) (lpprotocol, 
                            lpclient, lpclass, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
//
// Creates an embedded object from the class.
//
//  Arguments:
//
//     lpprotocol   -   
//     lpclient -   
//     lpclass  -   
//     lhclientdoc  -   
//     lpobjname    -   
//     lplpoleobject    -   
//     optRender    -   
//     cfFormat -
//     bLaunchServer -
//
//  Returns:
//
//      OLE_ERROR_HANDLE    -   
//      OLE_ERROR_NAME      -   
//      OLE_ERROR_PROTOCOL  -   
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                bLaunchServer;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreateInvisible");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX) {
        retval = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat, bLaunchServer);
    }
    else {
        objCount = lpDllTable[iTable].cObj;
        
        if (!(lpDllTable[iTable].CreateInvisible)) {
            // dll didn't export this function. Lets call DllCreate, so that
            // handler will get a chance to replace the methods. The flag is
            // used to tell the internal functions that this call infact wants
            // to achieve the effect of CreateInvisble.
            gbCreateInvisible = TRUE;
            gbLaunchServer = bLaunchServer;
            retval = (*lpDllTable[iTable].Create) (lpprotocol, 
                                    lpclient, lpclass,
                                    lhclientdoc, lpobjname, lplpoleobject, 
                                    optRender, cfFormat);
            gbCreateInvisible = FALSE;
        }
        else {
            retval   = (*lpDllTable[iTable].CreateInvisible) (lpprotocol, 
                                    lpclient, lpclass, 
                                    lhclientdoc, lpobjname, lplpoleobject, 
                                    optRender, cfFormat, bLaunchServer);
        }
        
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateFromFile: Creates an embedded object from file

OLESTATUS FAR PASCAL OleCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    if (lpclass)
        PROBE_READ(lpclass);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;
        
        if (!lstrcmp (lpclass, packageClass))
            iTable = INVALID_INDEX;
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateFromFile (lpprotocol, 
                            lpclient, lpclass, lpfile,
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromFile) (lpprotocol, 
                                lpclient, lpclass, lpfile,
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateLinkFromFile: Creates a linked object from file

OLESTATUS FAR PASCAL OleCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR+6];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateLinkFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    if (lpclass)
        PROBE_READ(lpclass);
    if (lpitem)
        PROBE_READ(lpitem);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass)) {
            lstrcpy (buf, lpfile);
            lstrcat (buf, "/Link");
            return  CreateEmbLnkFromFile (lpclient, packageClass, buf, 
                                NULL, lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat, OT_EMBEDDED);
        }
        else        
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateLinkFromFile (lpprotocol, 
                            lpclient, lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);

    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateLinkFromFile) (lpprotocol, 
                                lpclient, lpclass, lpfile, lpitem,
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



// Routines related to asynchronous operations.
OLESTATUS   FAR PASCAL  OleQueryReleaseStatus (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckPointer (lpobj, WRITE_ACCESS))
        return OLE_ERROR_OBJECT;

    // make sure that it is a long pointer to L&E object or a lock handle
    if (!(lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
            && !(lpobj->objId[0] == 'S' && lpobj->objId[1] == 'L'))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryReleaseStatus) (lpobj);
}


OLESTATUS   FAR PASCAL  OleQueryReleaseError  (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseError) (lpobj);
}

OLE_RELEASE_METHOD FAR PASCAL OleQueryReleaseMethod (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseMethod) (lpobj);
}


OLESTATUS FAR PASCAL OleRename (lpobj, lpNewName)
LPOLEOBJECT lpobj;
LPSTR       lpNewName;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Rename) (lpobj, lpNewName); 
}


OLESTATUS FAR PASCAL OleExecute (lpobj, hCmds, wReserved)
LPOLEOBJECT lpobj;
HANDLE      hCmds;
WORD        wReserved;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Execute) (lpobj, hCmds, wReserved); 
}


OLESTATUS FAR PASCAL OleQueryName (lpobj, lpBuf, lpcbBuf)
LPOLEOBJECT lpobj;
LPSTR       lpBuf;
WORD FAR *  lpcbBuf;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->QueryName) (lpobj, lpBuf, lpcbBuf); 
}

OLESTATUS FAR PASCAL OleQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    Puts("OleQueryType");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lptype);
    
    return (*lpobj->lpvtbl->QueryType) (lpobj, lptype);
}



DWORD FAR PASCAL OleQueryClientVersion ()
{
    return dwOleVer;
}


OLESTATUS INTERNAL LeQueryCreateFromClip (lpprotocol, optRender, cfFormat, cType)
LPSTR               lpprotocol;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                cType;
{
    OLESTATUS   retVal = TRUE;
    BOOL        bEdit = FALSE, bStatic = FALSE;

    PROBE_MODE(bProtMode);
    PROBE_READ(lpprotocol);
    
    if (bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return OLE_OK;
        
        if (cType == CT_LINK)
            retVal = IsClipboardFormatAvailable (cfObjectLink);
#ifdef OLD      
                        || IsClipboardFormatAvailable (cfLink) ;
#endif
        else if (cType == CT_EMBEDDED) 
            retVal = IsClipboardFormatAvailable (cfOwnerLink);

        if (!retVal)
            return OLE_ERROR_FORMAT;
        
        if (optRender == olerender_none) 
            return OLE_OK;
    }
    else if (bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (cType == CT_LINK)
            return OLE_ERROR_PROTOCOL;
        
        if (optRender == olerender_none) 
            return OLE_ERROR_FORMAT;  
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }
    
    if (optRender == olerender_draw) {
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT) &&
                !IsClipboardFormatAvailable (CF_DIB)      &&
                !IsClipboardFormatAvailable (CF_BITMAP)   &&
                !(bEdit && QueryHandler((cType == CT_LINK) ? cfObjectLink : cfOwnerLink)))
            return OLE_ERROR_FORMAT;
    }
    else if (optRender == olerender_format) {
        if (!IsClipboardFormatAvailable (cfFormat))
            return OLE_ERROR_FORMAT;
        
        if (bStatic && (cfFormat != CF_METAFILEPICT) 
                && (cfFormat != CF_DIB) && (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;
            
    }
    else {
        return OLE_ERROR_FORMAT;
    }
        
    return OLE_OK;
}



BOOL INTERNAL CheckObject(lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckPointer(lpobj, WRITE_ACCESS))
        return FALSE;
    
    if (lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
        return TRUE;
    
    return FALSE;
}

BOOL FARINTERNAL FarCheckObject(lpobj)
LPOLEOBJECT lpobj;
{
    return (CheckObject (lpobj));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\ole.asm ===
;\
    ;   ole.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains pointer vaildation routine
    ;       
    ;   History:  sriniK   02/01/1991 original
    ;             srinik   02/21/1991 added GetGDIds, IsMetaDC
   ;/               

.286p
.MODEL SMALL
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax                                              
            and     word ptr [bp+8], -1
            jnz     check_write_access

            verr    word ptr [bp+6]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+6]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+6] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+4], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp



;**************************** _GetGdiDS ****************************
;
;   WORD    GetGDIds (lpGdiFunc)
;
;   Args:
;       lpGdiFunc   long pointer to one of the GDI functions, with selector
;                   part being aliased to a data selector
;   returns: 
;       GDI DS value
;
        public  _GetGDIds

_GetGDIds   proc

            push    bp
            mov     bp, sp
            
            mov     ax, word ptr [bp+6] ; data selector
            push    ds
            mov     ds, ax
            mov     bx, word ptr [bp+4] 
            mov     ax, word ptr ds:[bx+1]
            pop     ds

            pop     bp
            ret

_GetGDIds   endp




;**************************** _IsMetaDC ****************************
;
;   WORD    IsMetaDC (hdc, wGDIds)
;
;   Args:
;       hdc     handle device context
;       wGDIds  GDI's data segment selector
;
;   returns: 
;       TRUE    if hdc is metafile dc
;       FALSE   otherwise
;
; ilObjHead       struc                                                       
;                       dw      ?           ; pointer to next obj in chain    
;       ilObjType       dw      ?           ; defines type of object
;       ilObjCount      dd      ?           ; the count of the object         
;       ilObjMetaList   dw      ?           ; handle to the list of metafile  
; ilObjHead       ends                                                  
;

        public  _IsMetaDC

OBJ_METAFILE    equ     10

_IsMetaDC   proc

            push    bp
            mov     bp, sp
            
            mov     ax, [bp+6] ; data selector
            push    ds
            mov     ds, ax
            mov     di, [bp+4] ; hdc
            mov     di, [di]
            cmp     word ptr [di+2], OBJ_METAFILE
            jz      metafile
            xor     ax, ax
metafile:
            pop     ds
            pop     bp
            ret

_IsMetaDC   endp

            end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\pict.h ===
/****************************** Module Header ******************************\
* Module Name: pict.h
*
* PURPOSE: Private definitions file for presentation object related files
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*
\***************************************************************************/


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfRelease (LPOBJECT_MF);
OLESTATUS FARINTERNAL MfSaveToStream (LPOBJECT_MF, LPOLESTREAM);
OLESTATUS FARINTERNAL MfClone (LPOBJECT_MF, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_MF FAR *);
OLESTATUS FARINTERNAL MfEqual (LPOBJECT_MF, LPOBJECT_MF);
OLESTATUS FARINTERNAL MfCopy (LPOBJECT_MF);
OLESTATUS FARINTERNAL MfQueryBounds (LPOBJECT_MF, LPRECT);
OLESTATUS FARINTERNAL MfGetData (LPOBJECT_MF, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL MfSetData (LPOBJECT_MF, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL MfChangeData (LPOBJECT_MF, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    MfCopyToClip (LPOBJECT_MF, HANDLE);
void      FARINTERNAL MfSetExtents (LPOBJECT_MF);
DWORD     INTERNAL    MfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHmfp (LPOBJECT_MF);
OLESTATUS INTERNAL    MfUpdateStruct (LPOBJECT_MF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL MfEnumFormat (LPOBJECT_MF, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DIB.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

/* The DIB file will be of the following format:                        */
/*                                                                      */
/*      0004                                                            */
/*      "DIB"                                                           */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAPINFOHEADER + RBGQUAD + bit array)     */
/*      BITMAPINFOHEADER structure                                      */
/*      RBGQUAD array                                                   */
/*      array of DI bits                                                */
/*                                                                      */

OLESTATUS FARINTERNAL DibRelease (LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibSaveToStream (LPOBJECT_DIB, LPOLESTREAM);
OLESTATUS FARINTERNAL DibClone (LPOBJECT_DIB, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_DIB FAR *);
OLESTATUS FARINTERNAL DibEqual (LPOBJECT_DIB, LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibCopy (LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibQueryBounds (LPOBJECT_DIB, LPRECT);
OLESTATUS FARINTERNAL DibGetData (LPOBJECT_DIB, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL DibChangeData (LPOBJECT_DIB, HANDLE, LPOLECLIENT, BOOL);
BOOL      INTERNAL    DibStreamRead (LPOLESTREAM,LPOBJECT_DIB);
void      INTERNAL    DibUpdateStruct (LPOBJECT_DIB, LPOLECLIENT, HANDLE, LPBITMAPINFOHEADER, DWORD);

OLECLIPFORMAT FARINTERNAL DibEnumFormat (LPOBJECT_DIB, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


/* The BM file will be of the following format:                         */
/*                                                                      */
/*      0007                                                            */
/*      "BITMAP"                                                        */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAP + bits)                              */
/*      BITMAP structure                                                */
/*      bitmap bits                                                     */
/*                                                                      */

OLESTATUS FARINTERNAL BmRelease (LPOBJECT_BM);
OLESTATUS FARINTERNAL BmSaveToStream (LPOBJECT_BM, LPOLESTREAM);
OLESTATUS FARINTERNAL BmClone (LPOBJECT_BM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_BM FAR *);
OLESTATUS FARINTERNAL BmEqual (LPOBJECT_BM, LPOBJECT_BM);
OLESTATUS FARINTERNAL BmCopy (LPOBJECT_BM);
OLESTATUS FARINTERNAL BmQueryBounds (LPOBJECT_BM, LPRECT);
OLESTATUS FARINTERNAL BmGetData (LPOBJECT_BM, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL BmChangeData (LPOBJECT_BM, HBITMAP, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    BmStreamWrite (LPOLESTREAM, LPOBJECT_BM);
BOOL      INTERNAL    BmStreamRead (LPOLESTREAM, LPOBJECT_BM);
void      INTERNAL    BmUpdateStruct (LPOBJECT_BM, LPOLECLIENT, HBITMAP, LPBITMAP, DWORD);

OLECLIPFORMAT FARINTERNAL BmEnumFormat (LPOBJECT_BM, OLECLIPFORMAT);
LPOBJECT_BM   INTERNAL    BmCreateObject (HBITMAP, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPSTR, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in GENERIC.C                                                   //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////




/* The GENERIC file will be of the following format:                    */
/*                                                                      */
/*      0007                                                            */
/*      "GENERIC"                                                       */
/*      4 bytes of cfFormat                                             */

OLESTATUS FARINTERNAL GenRelease (LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenSaveToStream (LPOBJECT_GEN, LPOLESTREAM);
OLESTATUS FARINTERNAL GenEqual (LPOBJECT_GEN, LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenCopy (LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenQueryBounds (LPOBJECT_GEN, LPRECT);
OLESTATUS FARINTERNAL GenGetData (LPOBJECT_GEN, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL GenSetData (LPOBJECT_GEN, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL GenChangeData (LPOBJECT_GEN, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    GenDeleteData (HANDLE);
OLESTATUS FARINTERNAL GenQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL GenClone(LPOBJECT_GEN, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_GEN FAR *);

OLECLIPFORMAT FARINTERNAL GenEnumFormat (LPOBJECT_GEN, OLECLIPFORMAT);
LPOBJECT_GEN  INTERNAL    GenCreateObject (HANDLE, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPSTR, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL ErrPlay (LPOLEOBJECT, WORD, BOOL, BOOL);
OLESTATUS FARINTERNAL ErrShow (LPOLEOBJECT, BOOL);
OLESTATUS FARINTERNAL ErrSetHostNames (LPOLEOBJECT, LPSTR, LPSTR);
OLESTATUS FARINTERNAL ErrSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS FARINTERNAL ErrSetColorScheme (LPOLEOBJECT, LPLOGPALETTE);
OLESTATUS FARINTERNAL ErrSetBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL ErrQueryOpen (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrActivate (LPOLEOBJECT, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS FARINTERNAL ErrClose (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrUpdate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrReconnect (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL ErrQueryOutOfDate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS FARINTERNAL ErrSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);
LPVOID    FARINTERNAL ErrQueryProtocol (LPOLEOBJECT, LPSTR);
OLESTATUS FARINTERNAL ErrQueryRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrAbort (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL ErrRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS FARINTERNAL ErrExecute (LPOLEOBJECT, HANDLE, WORD);

OLESTATUS FARINTERNAL ErrObjectConvert (LPOLEOBJECT, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *); 

OLESTATUS FARINTERNAL ErrObjectLong (LPOLEOBJECT, WORD, LPLONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DRAW.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                    

OLESTATUS FARINTERNAL DibDraw (LPOBJECT_DIB, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL BmDraw (LPOBJECT_BM, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL GenDraw (LPOBJECT_GEN, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL MfDraw (LPOBJECT_MF, HDC, LPRECT, LPRECT, HDC);
void      INTERNAL    MfInterruptiblePaint (LPOBJECT_MF, HDC);
int       FARINTERNAL MfCallbackFunc (HDC, LPHANDLETABLE, LPMETARECORD, int, BYTE FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\pbhandlr.c ===
/****************************** Module Header ******************************\
* Module Name: Pbhandlr.C -- Native data based handler (for Pbrush server) 
*
* PURPOSE: Contains handler routines for Pbrush server. This handler makes
*   use of most of the standard library methods. It replaces only the "Draw",
*   "QueryBounds", "CopyToClipboard" methods of the OLE object. Note that this
*   handler draws the picture from the native data.
*
* Created: December 1990
*
* Copyright (c) 1990  Microsoft Corporation
*
* History:
*   SriniK  (../12/1990)    Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"


OLESTATUS FAR PASCAL _loadds PbDraw (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FAR PASCAL _loadds PbQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FAR PASCAL _loadds PbCopyToClipboard (LPOLEOBJECT);
OLESTATUS FAR PASCAL _loadds PbGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLECLIPFORMAT FAR PASCAL _loadds PbEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);

extern OLESTATUS  FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);


void    PbGetExtents (LPSTR, LPPOINT);
void    PbReplaceFunctions (LPOLEOBJECT);
HANDLE  PbGetPicture (LPOLEOBJECT);
BOOL    IsStandardPict (LPOLEOBJECT);

extern void FARINTERNAL DibGetExtents(LPSTR, LPPOINT);

OLEOBJECTVTBL   vtblDLL;

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;

OLESTATUS (FAR PASCAL *DefQueryBounds)      (LPVOID, LPRECT);
OLESTATUS (FAR PASCAL *DefDraw)             (LPVOID, HDC, LPRECT, LPRECT, HDC);
OLESTATUS (FAR PASCAL *DefCopyToClipboard)  (LPVOID);
OLECLIPFORMAT (FAR PASCAL *DefEnumFormats)  (LPVOID, OLECLIPFORMAT);
OLESTATUS (FAR PASCAL *DefGetData)          (LPVOID, OLECLIPFORMAT, HANDLE FAR *);


OLESTATUS FAR PASCAL PbLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (objType == OT_LINK) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfNative);
    else
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS   retVal;
    
    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {       
        if (objType == OT_EMBEDDED) 
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_none, NULL, objType);
        else
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_format, cfNative, objType);
    }
    else {
        retVal = DefCreateFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, objType);
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);
        
    return retVal;
}



OLESTATUS FAR PASCAL PbCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;

    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);
    }
    else {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);       
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, NULL);

    else 
        retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, NULL);
    else 
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, NULL);

    else 
        retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}


OLESTATUS FAR PASCAL PbCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);

    else 
        retVal = DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, fActivate)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, NULL, fActivate);
    else 
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat, fActivate);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}


void PbReplaceFunctions (lpobj)
LPOLEOBJECT lpobj;
{
    if (IsStandardPict (lpobj))
        return;
    
    vtblDLL = *lpobj->lpvtbl;
    lpobj->lpvtbl = (LPOLEOBJECTVTBL) &vtblDLL;
    
    DefDraw                         = lpobj->lpvtbl->Draw;
    DefQueryBounds                  = lpobj->lpvtbl->QueryBounds;
    DefCopyToClipboard              = lpobj->lpvtbl->CopyToClipboard;
    DefEnumFormats                  = lpobj->lpvtbl->EnumFormats;
    DefGetData                      = lpobj->lpvtbl->GetData;   
    
    lpobj->lpvtbl->Draw             = PbDraw;
    lpobj->lpvtbl->QueryBounds      = PbQueryBounds;
    lpobj->lpvtbl->CopyToClipboard  = PbCopyToClipboard;
    lpobj->lpvtbl->EnumFormats      = PbEnumFormats;    
    lpobj->lpvtbl->GetData          = PbGetData;        
}



OLESTATUS  FAR PASCAL _loadds PbQueryBounds (lpobj, lprc)
LPOLEOBJECT lpobj;
LPRECT      lprc;
{
    OLESTATUS   retVal;
    HANDLE      hData;
    LPSTR       lpData;
    POINT       point;

    if ((retVal = (*DefQueryBounds) (lpobj, lprc)) == OLE_OK) {
        if (lprc->top || lprc->bottom || lprc->right || lprc->left)
            return OLE_OK;
    }
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return retVal;

    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    DibGetExtents ((lpData+sizeof(BITMAPFILEHEADER)), &point);
    GlobalUnlock (hData);    
    
    lprc->left     = 0;
    lprc->top      = 0;
    lprc->right    = point.x;
    lprc->bottom   = point.y;
    
    return OLE_OK;      
}


OLESTATUS  FAR PASCAL _loadds PbDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOLEOBJECT     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    HANDLE  hData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return (*DefDraw) (lpobj, hdc, lprc, lpWrc, hdcTarget);

    return wDibDraw (hData, hdc, lprc, lpWrc, hdcTarget, TRUE);
}


OLECLIPFORMAT FAR PASCAL _loadds PbEnumFormats (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    OLECLIPFORMAT   retFormat = NULL;

    if (cfFormat == CF_METAFILEPICT)
        return NULL;
    
    if (!(retFormat =  (*DefEnumFormats) (lpobj, cfFormat))) 
        return CF_METAFILEPICT;
    
    return retFormat;
}


OLESTATUS  FAR PASCAL _loadds PbGetData (lpobj, cfFormat, lpHandle)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE FAR *    lpHandle;
{
    OLESTATUS retval;
    
    retval = (*DefGetData) (lpobj, cfFormat, lpHandle);

    if (retval == OLE_OK || retval == OLE_BUSY || retval  == OLE_ERROR_BLANK)
        return retval;
    
    if (cfFormat == CF_METAFILEPICT) {
        if (*lpHandle = PbGetPicture (lpobj))
            return OLE_WARN_DELETE_DATA;
        
        return OLE_ERROR_MEMORY;
    }

    return OLE_ERROR_FORMAT;
}



OLESTATUS  FAR PASCAL _loadds PbCopyToClipboard (lpobj)
LPOLEOBJECT     lpobj;
{
    OLESTATUS   retVal;
    HANDLE      hPict;
    
    if ((retVal = (*DefCopyToClipboard) (lpobj)) == OLE_OK) {
        if (hPict = PbGetPicture (lpobj))
            SetClipboardData (CF_METAFILEPICT, hPict);        
        else
            retVal = OLE_ERROR_MEMORY;
    }
    
    return retVal;
}

HANDLE PbGetPicture (lpobj)
LPOLEOBJECT lpobj;
{
    HANDLE          hMF, hMfp, hData;
    RECT            rc = {0, 0, 0, 0};
    POINT           point;
    HDC             hMetaDC;
    LPMETAFILEPICT  lpmfp;
    OLESTATUS       retVal;
    LPSTR           lpData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return NULL;
    
    if (!hData)
        return NULL;
            
    if (!(lpData = GlobalLock (hData)))
        return NULL;

    lpData += sizeof(BITMAPFILEHEADER);
    rc.right  = (int) ((LPBITMAPINFOHEADER)lpData)->biWidth;
    rc.bottom = (int) ((LPBITMAPINFOHEADER)lpData)->biHeight;
    DibGetExtents(lpData, &point);
    GlobalUnlock (hData);    
    
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return NULL;
    
    SetWindowOrg (hMetaDC, 0, 0);
    SetWindowExt (hMetaDC, rc.right, rc.bottom);
    retVal = PbDraw (lpobj, hMetaDC, &rc, NULL, NULL);
    hMF = CloseMetaFile (hMetaDC);

    if (retVal != OLE_OK) 
        goto error;

    if (hMF && (hMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT)))
            && (lpmfp = (LPMETAFILEPICT) GlobalLock (hMfp))) {
        lpmfp->hMF = hMF;
        lpmfp->xExt = point.x;
        lpmfp->yExt = -point.y;
        lpmfp->mm   = MM_ANISOTROPIC;
        GlobalUnlock (hMfp);
        return hMfp;
    }

error:  

    if (hMF)
        DeleteMetaFile (hMF);
    
    if (hMfp)
        GlobalFree (hMfp);

    return NULL;
}


// normal handler can't do this. since this handler is part of olecli.dll, we
// we are doing this.

BOOL IsStandardPict (lpobj)
LPOLEOBJECT lpobj;
{
    LPOBJECT_LE lpLEobj;
    LONG        type;
    
    lpLEobj = (LPOBJECT_LE) lpobj;
    if (!lpLEobj->lpobjPict)
        return FALSE;
    
    if ((*lpLEobj->lpobjPict->lpvtbl->QueryType) (lpLEobj->lpobjPict, &type)
            == OLE_ERROR_GENERIC)
        return FALSE;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\block.c ===
/****************************** Module Header ******************************\
* Module Name: Block.c
*
* Purpose: Includes OleServerBlock(), OleServerUnblock() and related routines.
*
* Created: Dec. 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Srinik (../12/1990)    Designed, coded
*
\***************************************************************************/


#include "cmacs.h"
#include "windows.h"
#include "dde.h"
#include "ole.h"
#include "srvr.h"


OLESTATUS FAR PASCAL OleBlockServer (lhsrvr)
LHSERVER  lhsrvr;
{
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_BLOCK(lpsrvr);
    lpsrvr->bBlock = TRUE;
    return OLE_OK;
}


// On return from this routine, if *lpStatus is TRUE it means that more
// messages are to be unblocked.

OLESTATUS FAR PASCAL OleUnblockServer (lhsrvr, lpStatus)
LHSERVER    lhsrvr;
BOOL FAR *  lpStatus;
{
    HANDLE  hq;
    PQUE    pq;
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_WRITE(lpStatus);

    *lpStatus = lpsrvr->bBlock;
    if (hq = lpsrvr->hqHead) {
        if (!(pq = (PQUE) LocalLock (hq)))
            return OLE_ERROR_MEMORY;
        lpsrvr->bBlockedMsg = TRUE;
        lpsrvr->hqHead = pq->hqNext;
        SendMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
        LocalUnlock (hq);
        LocalFree (hq);

        // Server could've got freed up as a result of the above SendMessage
        // Validate server handle before trying to access it.
        if (CheckServer (lpsrvr)) {
            lpsrvr->bBlockedMsg = FALSE;

            if (!lpsrvr->hqHead) {
                lpsrvr->hqTail = NULL;
                *lpStatus = lpsrvr->bBlock = FALSE;
            }
        }
        else {
            *lpStatus = FALSE;
        }
    }
    else {
        *lpStatus = lpsrvr->bBlock = FALSE;
    }

    return OLE_OK;
}


BOOL INTERNAL AddMessage (hwnd, msg, wParam, lParam, wType)
HWND        hwnd;
unsigned    msg;
WORD        wParam;
LONG        lParam;
int         wType;
{
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    BOOL    bBlocked = TRUE;

    if ((msg <= WM_DDE_INITIATE) || (msg > WM_DDE_LAST))
        return FALSE;


    if (!(lpsrvr = (LPSRVR) GetWindowLong ((wType == WT_DOC) ? GetParent (hwnd) : hwnd, 0)))
        return FALSE;

    if (lpsrvr->bBlockedMsg || !lpsrvr->bBlock)
        return FALSE;

#ifdef LATER
    if ((msg == WM_DDE_INITIATE) && (lpsrvr->useFlags == OLE_SERVER_MULTI))
        return TRUE;
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqHead = lpsrvr->hqTail = hq;
    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqTail);
        lpsrvr->hqTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);

    while (bBlocked && !OleUnblockServer ((LHSERVER) lpsrvr, &bBlocked))
            ;

    return FALSE;
}



// dispatches the queued message, till all the messages are posted
// does yielding  if necessary. if bPeek is true, may allow some of
// incoming messages to get in.


BOOL INTERNAL  UnblockPostMsgs (hwnd, bPeek)
HWND    hwnd;
BOOL    bPeek;
{
    HANDLE  hq = NULL;
    PQUE    pq = NULL;
    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent (hwnd))
           hwnd = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
    ASSERT (lpsrvr->hqPostHead, "Unexpectedly blocked queue is empty");
#endif


    while (hq = lpsrvr->hqPostHead) {

        if (!(pq = (PQUE) LocalLock (hq))) {

#ifdef  FIREWALLS
        ASSERT (FALSE, "Local lock failed for blocked messages");
#endif
            break;
        }
        if (IsWindowValid (pq->hwnd)) {
            if (!PostMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam)) {
                LocalUnlock (hq);
                break;
            }
        }

        lpsrvr->hqPostHead = pq->hqNext;
        LocalUnlock (hq);
        LocalFree (hq);
    }


    if (!lpsrvr->hqPostHead)
        lpsrvr->hqPostTail = NULL;

    return TRUE;
}


// Moves a message which can not be posted to a server to
// the internal queue. We use this when we have to enumerate
// the properties. When we change the properties stuff to
// some other form, this may not be necassry.

BOOL INTERNAL BlockPostMsg (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    HWND    hwndTmp;
    HWND    hwndParent;

    hwndParent = (HWND)wParam;
    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwndParent))
           hwndParent = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLong (hwndParent, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqPostHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqPostTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqPostHead = lpsrvr->hqPostTail = hq;

        // create a timer.
        if (!SetTimer (lpsrvr->hwnd, 1, 100, NULL))
            return FALSE;

    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqPostTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqPostTail);
        lpsrvr->hqPostTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);
    return FALSE;
}


BOOL INTERNAL IsBlockQueueEmpty (hwnd)
HWND    hwnd;
{

    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwnd))
            hwnd= hwndTmp;
    lpsrvr = (LPSRVR) GetWindowLong (hwnd, 0);
    return (!lpsrvr->hqPostHead);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

#define KB_64   65536

extern ATOM  aPackage;
extern OLEOBJECTVTBL    vtblMF, vtblBM, vtblDIB, vtblGEN;

// QuerySize API support
DWORD           dwObjSize = NULL;
OLESTREAMVTBL   dllStreamVtbl;
OLESTREAM       dllStream;


#pragma alloc_text(_DDETEXT, UtilMemClr, MapStrToH, MapExtToClass, FileExists)

BOOL PutStrWithLen(lpstream, lpbytes)
LPOLESTREAM   lpstream;
LPSTR         lpbytes;
{
    LONG     len;

    len = (LONG) lstrlen(lpbytes) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, lpbytes, len);

}

BOOL GetStrWithLen(lpstream, lpbytes)
LPOLESTREAM   lpstream;
LPSTR         lpbytes;
{
    if (GetBytes (lpstream, lpbytes, sizeof(LONG)))
        return TRUE;

    return GetBytes (lpstream, lpbytes + sizeof(LONG), (*(LONG FAR *)lpbytes));
}

ATOM GetAtomFromStream(lpstream)
LPOLESTREAM lpstream;
{
    BOOL    err = TRUE;
    LONG    len;
    char    str[MAX_STR+1];


    if (GetBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return NULL;

    if (len == 0)
        return NULL;

    if (GetBytes(lpstream, (LPSTR)str, len))
        return NULL;

    return GlobalAddAtom(str);

}

BOOL PutAtomIntoStream(lpstream, at)
LPOLESTREAM     lpstream;
ATOM            at;
{
    LONG    len = 0;
    char    buf[MAX_STR + 1];

    if (at == 0)
        return  (PutBytes (lpstream, (LPSTR)&len, sizeof(len)));


    len = GlobalGetAtomName (at,(LPSTR)buf, MAX_STR) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, buf, len);
}


// DuplicateAtom: Bump the use count up on a global atom.

ATOM FARINTERNAL DuplicateAtom (ATOM atom)
{
    char buffer[MAX_ATOM+1];

    Puts("DuplicateAtom");

    if (!atom)
        return NULL;

    GlobalGetAtomName (atom, buffer, MAX_ATOM);
    return GlobalAddAtom (buffer);
}



BOOL GetBytes(lpstream, lpstr, len)
LPOLESTREAM     lpstream;
LPSTR           lpstr;
LONG            len;
{

    ASSERT (lpstream->lpstbl->Get , "stream get function is null");
    return (((*lpstream->lpstbl->Get)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL PutBytes(lpstream, lpstr, len)
LPOLESTREAM     lpstream;
LPSTR           lpstr;
LONG            len;
{

    ASSERT (lpstream->lpstbl->Put , "stream get function is null");
    return (((*lpstream->lpstbl->Put)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL FARINTERNAL UtilMemCmp (lpmem1, lpmem2, dwCount)
LPSTR   lpmem1;
LPSTR   lpmem2;
DWORD   dwCount;
{
    WORD HUGE * hpmem1;
    WORD HUGE * hpmem2;
    WORD FAR  * lpwMem1;
    WORD FAR  * lpwMem2;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwMem1 = (WORD FAR *) lpmem1;
        lpwMem2 = (WORD FAR *) lpmem2;
        
        while (words--) {
            if (*lpwMem1++ != *lpwMem2++)
                return FALSE;
        }

        if (bytes) {
            if (* (char FAR *) lpwMem1 != *(char FAR *) lpwMem2)
                return FALSE;
        }

    }
    else {
        hpmem1 = (WORD HUGE *) lpmem1;
        hpmem2 = (WORD HUGE *) lpmem2;
    
        while (words--) {
            if (*hpmem1++ != *hpmem2++)
                return FALSE;
        }

        if (bytes) {
            if (* (char HUGE *) hpmem1 != * (char HUGE *) hpmem2)
                return FALSE;
        }
    }
    
    return TRUE;
}


void FARINTERNAL UtilMemCpy (lpdst, lpsrc, dwCount)
LPSTR   lpdst;
LPSTR   lpsrc;
DWORD   dwCount;
{
    WORD HUGE * hpdst;
    WORD HUGE * hpsrc;
    WORD FAR  * lpwDst;
    WORD FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwDst = (WORD FAR *) lpdst;
        lpwSrc = (WORD FAR *) lpsrc;
        
        while (words--) 
            *lpwDst++ = *lpwSrc++;

        if (bytes) 
            * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else {
        hpdst = (WORD HUGE *) lpdst;
        hpsrc = (WORD HUGE *) lpsrc;
    
        while (words--) 
            *hpdst++ = *hpsrc++;

        if (bytes) 
            *(char HUGE *) hpdst = * (char HUGE *) hpsrc;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE FARINTERNAL DuplicateGlobal (hdata, flags)
HANDLE  hdata;
WORD    flags;
{
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if (!hdata)
        return NULL;
    
    if(!(lpsrc = GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (flags, (size = GlobalSize(hdata)));

    if(!(lpdst = GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup) {
        GlobalFree (hdup);
        hdup = NULL;
    }
    
    return hdup;
}


BOOL FARINTERNAL CmpGlobals (hdata1, hdata2)
HANDLE  hdata1;
HANDLE  hdata2;
{
    LPSTR       lpdata1 = NULL;
    LPSTR       lpdata2 = NULL;
    DWORD       size1;
    DWORD       size2;
    BOOL        retval = FALSE;


    size1 = GlobalSize (hdata1);
    size2 = GlobalSize (hdata2);

    if (size1 != size2)
        return FALSE;

    if (!(lpdata1 = GlobalLock (hdata1)))
        goto errRtn;

    if (!(lpdata2 = GlobalLock (hdata2)))
        goto errRtn;

    retval = UtilMemCmp (lpdata1, lpdata2, size1);

errRtn:
    if (lpdata1)
        GlobalUnlock (hdata1);

    if (lpdata2)
        GlobalUnlock (hdata2);

    return retval;
}


int  FARINTERNAL GlobalGetAtomLen (aItem)
ATOM    aItem;
{
    // !!! Change this
    char    buf[MAX_STR];

    if (!aItem)
        return NULL;
    
    return (GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR));

}


BOOL FARINTERNAL MapExtToClass (lptemplate, lpbuf, len)
LPSTR   lptemplate;
LPSTR   lpbuf;
int     len;
{
    LONG    cb;    
    
    while (*lptemplate && *lptemplate != '.')
        lptemplate++;
        
    cb = len;   
    if (*(lptemplate+1) == NULL)
        return FALSE;

    if (RegQueryValue (HKEY_CLASSES_ROOT, lptemplate, lpbuf, &cb)) 
        return FALSE;

    return TRUE;
}


// Get exe name from aClass and set it as aServer
void INTERNAL SetExeAtom (lpobj)
LPOBJECT_LE lpobj;
{
    char    key[MAX_STR];
    
    // if old link object assume the class same as the exe file name.
    if (lpobj->bOldLink)
        lpobj->aServer = DuplicateAtom (lpobj->app);
    else {
        if (GlobalGetAtomName (lpobj->app, key, sizeof(key)))
            lpobj->aServer = GetAppAtom ((LPSTR)key);
    }
}
    

ATOM FARINTERNAL GetAppAtom (lpclass)
LPSTR   lpclass;
{
    char    buf1[MAX_STR];
    

    if (!QueryApp (lpclass, PROTOCOL_EDIT, buf1)) {
        return NULL;
    }
    
    return GlobalAddAtom ((LPSTR)buf1);
}


BOOL FARINTERNAL QueryVerb (lpobj, verb, lpbuf, cbmax)
LPOBJECT_LE lpobj;
WORD        verb;
LPSTR       lpbuf;
LONG        cbmax;
{
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    // do not need 256 bytes buffer
    char    class[MAX_STR];
    int     len;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR)class, sizeof(class)))
        return FALSE;

    lstrcpy (key, (LPSTR)class);
    lstrcat (key, "\\protocol\\StdFileEditing\\verb\\");
    len = lstrlen (key);
    key [len++] = (char) ('0' + verb);
    key [len++] = 0;

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cbmax))
        return FALSE;        
    return TRUE;
}




BOOL QueryApp (lpclass, lpprotocol, lpbuf)
LPSTR   lpclass;
LPSTR   lpprotocol;
LPSTR   lpbuf;
{
    LONG    cb = MAX_STR;
    char    key[MAX_STR];

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cb))  
        return FALSE;        
    return TRUE;
}


HANDLE MapStrToH (lpstr)
LPSTR   lpstr;
{

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    hdata = GlobalAlloc (GMEM_DDESHARE, lstrlen (lpstr) + 1);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    lstrcpy (lpdata, lpstr);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}


HANDLE FARINTERNAL CopyData (lpsrc, dwBytes)
LPSTR       lpsrc;
DWORD       dwBytes;
{
    HANDLE  hnew;
    LPSTR   lpnew;
    BOOL    retval = FALSE;

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwBytes)){
        if (lpnew = GlobalLock (hnew)){
            UtilMemCpy (lpnew, lpsrc, dwBytes);
            GlobalUnlock (hnew);
            return hnew;
        } 
        else
            GlobalFree (hnew);
    }
    
    return NULL;
}

void  UtilMemClr (pstr, size)
PSTR    pstr;
WORD    size;
{

    while (size--)
        *pstr++ = 0;

}


OLESTATUS FAR PASCAL ObjQueryName (lpobj, lpBuf, lpcbBuf)
LPOLEOBJECT lpobj;
LPSTR       lpBuf;
WORD FAR *  lpcbBuf;
{
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED 
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    PROBE_WRITE(lpBuf);
    if (!*lpcbBuf)
        return OLE_ERROR_SIZE;
    
    if (!CheckPointer(lpBuf+*lpcbBuf-1, WRITE_ACCESS))
        return OLE_ERROR_SIZE;

    ASSERT(lpobj->aObjName, "object name ATOM is NULL\n");
    *lpcbBuf = GlobalGetAtomName (lpobj->aObjName, lpBuf, *lpcbBuf);
    return OLE_OK;
}


OLESTATUS FAR PASCAL ObjRename (lpobj, lpNewName)
LPOLEOBJECT lpobj;
LPSTR       lpNewName;
{
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED 
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    PROBE_READ(lpNewName);
    if (!lpNewName[0])
        return OLE_ERROR_NAME;
    
    if (lpobj->aObjName)
        GlobalDeleteAtom (lpobj->aObjName);
    lpobj->aObjName = GlobalAddAtom (lpNewName);
    return OLE_OK;
}




BOOL QueryHandler(cfFormat)
WORD cfFormat;
{
    HANDLE  hInfo = NULL;
    LPSTR   lpInfo = NULL;
    BOOL    fRet = FALSE, fOpen = FALSE;
    LONG    cb = MAX_STR;
    char    str[MAX_STR];
    HKEY    hKey;
    
    // we don't have the client app window handle, use the screen handle
    fOpen = OpenClipboard (NULL);

    if (!(hInfo = GetClipboardData (cfFormat)))
        goto errRtn;
        
    if (!(lpInfo = GlobalLock(hInfo)))
        goto errRtn;
    
    // First string of lpInfo is CLASS. See whether any handler is installed
    // for this class.

    lstrcpy (str, lpInfo);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler");       
    if (RegOpenKey (HKEY_CLASSES_ROOT, str, &hKey))
        goto errRtn;
    RegCloseKey (hKey);
    fRet = TRUE;

errRtn: 
    if (lpInfo)
        GlobalUnlock (hInfo);
    
    if (fOpen)
        CloseClipboard();
    return fRet;
}

OLESTATUS INTERNAL FileExists (lpobj)
LPOBJECT_LE lpobj;
{
    char        filename[MAX_STR];
    OFSTRUCT    ofstruct;
    
    if (!GlobalGetAtomName (lpobj->topic, filename, MAX_STR))
        return OLE_ERROR_MEMORY;
    
    // For package with link we append "/LINK" to the filename. We don't want
    // to check for it's existence here.
    if (lpobj->app != aPackage) {
        // when OF_EXIST is specified, file is opened and closed immediately
        if (OpenFile (filename, &ofstruct, OF_EXIST) == -1)
            return OLE_ERROR_OPEN;
    }
    
    return OLE_OK;
}


BOOL  FARINTERNAL UtilQueryProtocol (lpobj, lpprotocol)
LPOBJECT_LE lpobj;
LPSTR       lpprotocol;
{
    char    buf[MAX_STR];
    ATOM    aExe;
        
    if (!GlobalGetAtomName (lpobj->app, (LPSTR) buf, MAX_STR))
        return FALSE;
        
    if (!QueryApp (buf, lpprotocol, (LPSTR) buf))  
        return FALSE;
        
    aExe = GlobalAddAtom (buf);
    if (aExe)
        GlobalDeleteAtom (aExe);
    if (aExe != lpobj->aServer)
        return FALSE;
    
    return TRUE;
}

WORD FARINTERNAL FarCheckPointer (lp, iAccessType)
LPVOID  lp;
int     iAccessType;
{
    return (CheckPointer (lp, iAccessType));
}


DWORD PASCAL FAR DllPut (lpstream, lpstr, dwSize)
LPOLESTREAM lpstream;
LPSTR       lpstr;
DWORD       dwSize;
{
    dwObjSize += dwSize;
    return dwSize;
}



OLESTATUS FARINTERNAL ObjQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    Puts("ObjQueryType");

    if (lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    *lptype = lpobj->ctype;
    return OLE_OK;
}

OLESTATUS FARINTERNAL ObjQuerySize (lpobj, lpdwSize)
LPOLEOBJECT    lpobj;
DWORD FAR *    lpdwSize;
{
    Puts("ObjQuerySize");

    *lpdwSize = dwObjSize = NULL;    
    
    if ((*lpobj->lpvtbl->SaveToStream) (lpobj, &dllStream) == OLE_OK) {
        *lpdwSize = dwObjSize;
        return OLE_OK;
    }

    return OLE_ERROR_BLANK;
}

BOOL FARINTERNAL IsObjectBlank (lpobj)
LPOBJECT_LE lpobj;
{
    LPOLEOBJECT lpPictObj;
    BOOL        retval;
    
    // Cleaner way is to provide a method like QueryBlank()
        
    if (!lpobj->hnative)
        return TRUE;
    
    if (!(lpPictObj = lpobj->lpobjPict))
        return FALSE;
    
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblMF)
        retval = (BOOL) (((LPOBJECT_MF)lpPictObj)->hmfp);
    else if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblBM)
        retval = (BOOL) (((LPOBJECT_BM)lpPictObj)->hBitmap);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblDIB)
        retval = (BOOL) (((LPOBJECT_DIB)lpPictObj)->hDIB);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblGEN)
        retval = (BOOL) (((LPOBJECT_GEN)lpPictObj)->hData); 
    
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\give2gdi.asm ===
;\
    ;   give2gdi.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains code which changes memory metafile ownership to GDI
    ;
    ;   History:  sriniK   05/22/1991 
   ;/               


include cmacros.inc
include windows.inc

.286


;**************************** Data Segment ********************************

sBegin  data 
        assumes ds, data
        
szGDI   db  'GDI', 0
szWEP   db  'WEP', 0

sEnd    data


;*************************** Code Segment *********************************

externFP    GlobalRealloc
externFP    GlobalSize
externFP    GetModuleHandle
externFP    GetProcAddress

createSeg   Give2GDI, Give2GDI, para, public, code

sBegin      Give2GDI
            assumes cs,Give2GDI
            assumes ds,data
            assumes es,nothing

;**************************** Public Functions ****************************

cProc       GiveToGDI, <PUBLIC,FAR>
;
;
;   HANDLE  FAR PASCAL GiveToGDI(HANDLE hMem)
;
;   Assign ownership of the given global memory block to GDI
;
;   returns a handle to the memory block if successful, otherwise returns NULL
;

            parmW   hMem

            localD  lpGDIWEP
cBegin
            ;*************************************************************
            ;**     Get address of retf in fixed GDI code segment       **
            ;*************************************************************

            push    ds
            push    dataOFFSET szGDI
            cCall   GetModuleHandle

            push    ax
            push    ds
            push    dataOFFSET szWEP
            cCall   GetProcAddress

            mov     [word ptr lpGDIWEP[0]], ax
            mov     [word ptr lpGDIWEP[2]], dx

            ;*************************************************************
            ;**     Kludge a call to GlobalReAlloc with GDI as caller   **
            ;*************************************************************

            push    0                       ; Params for WEP

            push    cs                      ; GDI's WEP returns here
            push    offset  ReturnHere
            
            push    hMem                    ; Params to GlobalReAlloc
            push    0
            push    0
            push    [GMEM_MOVEABLE or GMEM_SHARE or GMEM_MODIFY]

            push    [word ptr lpGDIWEP[2]]  ; GlobalReAlloc returns here
            push    [word ptr lpGDIWEP[0]]  ; GlobalReAlloc returns here
            
            push    0                       ; Params for WEP

            push    seg    GlobalReAlloc    ; GDI's WEP returns here
            push    offset GlobalReAlloc

            jmp     lpGDIWEP                ; Dive off the end
ReturnHere:
            ;*************************************************************
            ;**     Return handle to reallocated block                  **
            ;*************************************************************

            mov     ax,hMem
cEnd

;*************************************************************************

sEnd        Give2GDI
end

;*************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\olever.h ===
#include <ver.h>

#ifndef DEBUG
#define OLEVER_DEBUG        0
#else
#define OLEVER_DEBUG        1
#endif


#ifndef OFFICIAL
#define OLEVER_PRIVATEBUILD 1
#else
#define OLEVER_PRIVATEBUILD 0
#endif


#ifndef FINAL
#define OLEVER_PRERELEASE   1
#else
#define OLEVER_PRERELEASE   0
#endif

#define OLEVER_FILEFLAGS    (OLEVER_PRIVATEBUILD|OLEVER_PRERELEASE|OLEVER_DEBUG)

#ifdef NT
#define OLEVER_FILEOS           VOS_WINDOWS32
#define OLEVER_FILEVERSION      1,03, 001
#define OLEVER_PRODUCTVERSION   3,10,0,043
#elseif PWIN
#define OLEVER_FILEOS           VOS_DOS_WINDOWS16
#define OLEVER_FILEVERSION      1,10
#define OLEVER_PRODUCTVERSION   3,10,0,043
#else
#define OLEVER_FILEOS           VOS_DOS_WINDOWS16
#define OLEVER_FILEVERSION      1,03, 001
#define OLEVER_PRODUCTVERSION   3,10,0,043
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\doc.c ===
/****************************** Module Header ******************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
\***************************************************************************/

#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern  ATOM     cfBinary;
extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  FARPROC  lpTerminateDocClients;
extern  FARPROC  lpSendRenameMsg;
extern  FARPROC  lpFindItemWnd;
extern  FARPROC  lpEnumForTerminate;

extern  HANDLE   hdllInst;
extern  HANDLE   hddeRename;
extern  HWND     hwndRename;


extern  BOOL     fAdviseSaveDoc;

// ### Do we have to create a seperate window for each doc conversation.
// EDF thinks so.

/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
*
* OleRegisterServerDoc: Registers the Document with the server lib.
*
* Parameters:
*       1. Server long handle(server with which the document should
*          be registered)
*       2. Document name.
*       3. Handle to the doc of the server app (private to the server app).
*       4. Ptr for returning the Doc handle of the lib (private to the lib).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
LHSRVR          lhsrvr;    // handle we passed back as part of registration.
LPCSTR           lpdocname; // document name
LPOLESERVERDOC  lpoledoc;  // Private doc handle of the server app.
LHDOC FAR *     lplhdoc;   // where we will be passing our doc private handle
{

    LPSRVR  lpsrvr = NULL;
    LPDOC   lpdoc  = NULL;
    HANDLE  hdoc   = NULL;


    Puts ("OleRegisterServerDoc");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    // server's termination has already started.
    if (lpsrvr->bTerminate)
        return OLE_ERROR_TERMINATE;

    PROBE_READ((LPSTR)lpdocname);
    PROBE_WRITE(lplhdoc);

    // we are using the null from inside the server lib
    if (lpoledoc)
        PROBE_WRITE(lpoledoc);

    hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (DOC));

    if (!(hdoc && (lpdoc = (LPDOC)GlobalLock (hdoc))))
        goto errReturn;

    // set the signature, handle and the doc atom.
    lpdoc->sig[0]   = 'S';
    lpdoc->sig[1]   = 'D';
    lpdoc->hdoc     = hdoc;
    lpdoc->aDoc     = GlobalAddAtom (lpdocname);
    lpdoc->lpoledoc = lpoledoc;


    if (!(lpdoc->hwnd = CreateWindow ("DocWndClass", "Doc",
        WS_CHILD,0,0,0,0,lpsrvr->hwnd,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the struct in the window.
    SetWindowLong (lpdoc->hwnd, 0, (LONG)lpdoc);
    SetWindowWord (lpdoc->hwnd, WW_LE, WC_LE);
    SetWindowWord (lpdoc->hwnd, WW_HANDLE,
        (WORD) (GetWindowWord (lpsrvr->hwnd, WW_HANDLE)));
    *lplhdoc = (LONG)lpdoc;

    return OLE_OK;

errReturn:
    if (lpdoc){
        if (lpdoc->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpdoc->aDoc)
            GlobalDeleteAtom (lpdoc->aDoc);

        GlobalUnlock(hdoc);
    }

    if (hdoc)
        GlobalFree (hdoc);

    return OLE_ERROR_MEMORY;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServerDoc (lhdoc)
*
* OleRevokeServerDoc: Unregisters the document which has been registered.
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the document is successfully unregisterd.
*        ( It is Ok for the app to free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Doc class release entry point when the doc
*        can be released. App should wait till the Release is called
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS  FAR PASCAL  OleRevokeServerDoc (lhdoc)
LHDOC   lhdoc;
{
    HWND    hwndSrvr;
    LPSRVR  lpsrvr;
    HWND    hwndDoc;
    LPDOC   lpdoc;

    Puts ("OleRevokeServerDoc");

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // ### this code is very similar to the srvr code.
    // we should optimize.

    hwndDoc = lpdoc->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndDoc, "No doc window")
#endif

    hwndSrvr = GetParent (hwndDoc);
    lpsrvr = (LPSRVR) GetWindowLong (hwndSrvr, 0);
#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "No srvr window")
    ASSERT (lpsrvr, "No srvr structure")
#endif

    // delete all the items(objects) for this doc
    DeleteAllItems (lpdoc->hwnd);

    // we are terminating.
    lpdoc->bTerminate = TRUE;
    lpdoc->termNo = 0;

    // send ack if Revoke is done as a result of StdClose
    if (lpdoc->fAckClose) {
        // Post the acknowledge to the client
        if (!PostMessageToClient (lpdoc->hwndClose, WM_DDE_ACK, lpdoc->hwnd,
                            MAKELONG (0x8000, lpdoc->hDataClose)))
            // if the window died or post failed, delete the atom.
            GlobalFree (lpdoc->hDataClose);
    }

    // Post termination for each of the doc clients.
    EnumProps (hwndDoc, lpTerminateDocClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndDoc, TRUE);

#ifdef  WAIT_DDE
    if (lpdoc->termNo)
        WaitForTerminate((LPSRVR)lpdoc);
#endif

    return ReleaseDoc (lpdoc);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
*
* OleRenameServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*       2. New name for document
*
* return values:
*        returns OLE_OK if the document is successfully renamed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
LHDOC   lhdoc;
LPCSTR   lpNewName;
{
    LPDOC       lpdoc;
    OLESTATUS   retVal = OLE_OK;
    HANDLE      hdata;
    HWND        hStdWnd;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ((LPSTR)lpNewName);

    if (!(hdata = MakeGlobal ((LPSTR)lpNewName)))
        return OLE_ERROR_MEMORY;

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = GlobalAddAtom (lpNewName);

    // if StdDocName item is present send rename to relevant clients
    if (hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))) {
        if (!MakeDDEData (hdata, (int)cfBinary, (LPHANDLE)&hddeRename,FALSE))
            retVal = OLE_ERROR_MEMORY;
        else {
            EnumProps (hStdWnd, lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);

        }
    }


    hwndRename = hStdWnd;
    // Post termination for each of the doc clients.
    EnumProps (lpdoc->hwnd, lpEnumForTerminate);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (lpdoc->hwnd, TRUE);

    // If it was an embedded object, from now on it won't be
    lpdoc->fEmbed = FALSE;

    if (!hStdWnd || retVal != OLE_OK)
        GlobalFree(hdata);

    // Do link manager stuff
    return retVal;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
*
* OleSavedServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager is successfully notified
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
LHDOC   lhdoc;
{
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    fAdviseSaveDoc = TRUE;
    EnumChildWindows (lpdoc->hwnd, lpFindItemWnd,
        MAKELONG (NULL, ITEM_SAVED));

    if (lpdoc->fEmbed && !fAdviseSaveDoc)
        return OLE_ERROR_CANT_UPDATE_CLIENT;

    return OLE_OK;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
*
* OleRevertServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager has been successfully informed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
LHDOC   lhdoc;
{
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}



// TerminateDocClients: Call back for the document window for
// enumerating all the clients. Posts terminate for each of
// the clients.

BOOL    FAR PASCAL  TerminateDocClients (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{
    LPDOC   lpdoc;

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
    if (IsWindowValid ((HWND)hdata)){
        lpdoc->termNo++;
        // irrespective of the post, incremet the count, so
        // that client does not die.
        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL);
    }
    else
        ASSERT(FALSE, "TERMINATE: Client's Doc channel is missing");
    return TRUE;
}


// ReleaseDoc: If there are no more matching terminates pending
// Call the server for its release. (Server might be waiting for the
// docs to be terminated. Called thru OleRevokeServer).


int INTERNAL    ReleaseDoc (lpdoc)
LPDOC      lpdoc;
{

    HWND        hwndSrvr;
    HANDLE      hdoc;
    LPSRVR      lpsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT.

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // Call Release for the app to release its space.


    if (lpdoc->lpoledoc){

#ifdef FIREWALLS
    if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOC")
    else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
    else
        ASSERT (lpdoc->lpoledoc->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif
        (*lpdoc->lpoledoc->lpvtbl->Release) (lpdoc->lpoledoc);

    }

    if (lpdoc->aDoc) {
        GlobalDeleteAtom (lpdoc->aDoc);
        lpdoc->aDoc = NULL;
    }

    hwndSrvr = GetParent (lpdoc->hwnd);
    DestroyWindow (lpdoc->hwnd);

    lpsrvr = (LPSRVR)GetWindowLong (hwndSrvr, 0);

    // if the server is waiting for us, inform the server
    // we are done
    if (!lpsrvr->bTerminate) {
        // if we are not in terminate mode, then send advise to the server
        // if server can be revoked. raor (04/09)

        if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
            if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVER")
            else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                            WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                    "Invalid pointer to Release method")
#endif

            (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
        }

    } else
        ReleaseSrvr (lpsrvr);

    GlobalUnlock (hdoc = lpdoc->hdoc);
    GlobalFree (hdoc);

    return OLE_OK;
}


//RevokeAllDocs : revokes all the documents attached to a given
//server.

int INTERNAL RevokeAllDocs (lpsrvr)
LPSRVR  lpsrvr;
{

    HWND    hwnd;
    HWND    hwndnext;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        OleRevokeServerDoc ((LHDOC)GetWindowLong (hwnd, 0));
        hwnd =  hwndnext;
    }
    return OLE_OK;
}



// FindDoc: Given a document, searches for the document
// in the given server document tree. returns true if the
// document is available.


LPDOC INTERNAL FindDoc (lpsrvr, lpdocname)
LPSRVR  lpsrvr;
LPSTR   lpdocname;
{

    ATOM    aDoc;
    HWND    hwnd;
    LPDOC   lpdoc;

    aDoc = (ATOM)GlobalFindAtom (lpdocname);
    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
        if (lpdoc->aDoc == aDoc)
            return lpdoc;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}



// DocWndProc: document window procedure.
// ### We might be able to merge this code with
// the server window proc.


long FAR PASCAL DocWndProc (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPDOC       lpdoc;
    WORD        status = NULL;
    HWND        hwndClient;
    BOOL        fack;
    HANDLE      hdata  = NULL;
    OLESTATUS   retval;
    LPSRVR      lpsrvr;

    if (AddMessage (hwnd, msg, wParam, lParam, WT_DOC))
        return 0L;

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);

    switch (msg){


       case WM_CREATE:
            DEBUG_OUT ("doc create window", 0)
            break;

       case WM_DDE_INITIATE:

            DEBUG_OUT ("doc: DDE init",0);
            if (lpdoc->bTerminate){
                DEBUG_OUT ("doc: No action due to termination process",0)
                break;
            }

            // if we are the documnet then respond.

            if (! (lpdoc->aDoc == (ATOM)(HIWORD(lParam))))
                break;

            // We can enterain this client. Put this window in the client list
            // and acknowledge the initiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpdoc->cClients++;
            lpsrvr = (LPSRVR) GetWindowLong (GetParent(lpdoc->hwnd), 0);

            lpsrvr->bnoRelease = FALSE;

            // post the acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SendMessage ((HWND)wParam, WM_DDE_ACK, (WORD)hwnd, lParam);

            break;

       case WM_DDE_EXECUTE:

            DEBUG_OUT ("doc: execute", 0)
#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                DEBUG_OUT ("doc: execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (HIWORD (lParam));
                break;

            }

            retval = DocExecute (hwnd, HIWORD (lParam), (HWND)wParam);
            SET_MSG_STATUS (retval, status);

#ifdef OLD
            // if we posted the terminate because of execute, do not send
            // ack.

            if (lpdoc->bTerminate) {
                // !!! We got close but, we are posting the
                // the terminate. Excel does not complain about
                // this. But powerpoint complains.
#ifdef  POWERPNT_BUG
                GlobalFree (HIWORD(lParam));
#endif
                break;
            }
#endif
            if (!lpdoc->bTerminate) {
                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                                MAKELONG(status, HIWORD(lParam))))
                    // the window either died or post failed, delete the data
                    GlobalFree (HIWORD(lParam));
            }

            break;

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("doc: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd,(HWND)wParam);
            ASSERT(hwndClient || lpdoc->termNo, "Client is missing from the server")
#endif
            // We do not need this client any more. Delete him from the
            // client list.

            DeleteClient (lpdoc->hwnd, (HWND)wParam);
            lpdoc->cClients--;

            if (lpdoc->bTerminate){
                lpsrvr = (LPSRVR) GetWindowLong (GetParent(lpdoc->hwnd), 0);
                if (!--lpdoc->termNo)
                    // Release this Doc and may be the server also
                    // if the server is waiting to be released also.
                    ReleaseDoc (lpdoc);
            } else {
                if (lpdoc->termNo == 0){

                    // If client intiated the terminate. Post matching terminate

                    PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                                    hwnd, NULL);
                } else
                    lpdoc->termNo--;

                //Client initiated the termination. So, we shoudl take him
                // out from any of our items client lists.
                DeleteFromItemsList (lpdoc->hwnd, (HWND)wParam);

                lpsrvr = (LPSRVR)GetWindowLong (GetParent (lpdoc->hwnd), 0);

                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }

            }
            break;

       case WM_DESTROY:
            DEBUG_OUT ("doc: Destroy window",0)
            break;

       case WM_DDE_POKE: {
            int iStdItem;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam)) {
                // we are getting pke message after we have posted the
                // the termination or the client got deleted.
            PokeErr:
                FreePokeData ((HANDLE) (LOWORD (lParam)));
#ifdef OLD
                GlobalFree ((HANDLE) (LOWORD (lParam)));
#endif
                // !!! Are we supposed to delete the atoms also.
            PokeErr1:
                if (HIWORD(lParam))
                    GlobalDeleteAtom (HIWORD(lParam));
                break;

            }

            if (iStdItem = GetStdItemIndex (HIWORD(lParam)))
                retval = PokeStdItems (lpdoc, (HWND)wParam,
                                MAKELONG((LOWORD(lParam)), iStdItem));
            else
                retval = PokeData (lpdoc, (HWND)wParam, lParam);

            SET_MSG_STATUS (retval, status);
            // !!! If the fRelease is false and the post fails
            // then we are not freeing the hdata. Are we supposed to

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                        MAKELONG(status, HIWORD(lParam))))
                goto PokeErr1;

            break;
       }

       case WM_DDE_ADVISE:

            fack = TRUE;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr;

            if (IsAdviseStdItems (HIWORD(lParam)))
                retval = AdviseStdItems (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);
            else
                // advise data will not have any OLE_BUSY
                retval = AdviseData (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);

            SET_MSG_STATUS (retval, status);

            if (fack) {
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                                MAKELONG(status, HIWORD(lParam))))
                    goto PokeErr;

            }
            else if ((ATOM)(HIWORD (lParam)))
                GlobalDeleteAtom ((ATOM)(HIWORD (lParam)));

            break;

       case WM_DDE_UNADVISE:
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr;

            retval = UnAdviseData (lpdoc, (HWND)wParam, lParam);
            SET_MSG_STATUS (retval, status);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                        MAKELONG(status, HIWORD(lParam))))
                goto PokeErr;

            break;

       case WM_DDE_REQUEST:

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam))
                goto PokeErr1;

            retval = RequestData (lpdoc, (HWND)wParam, lParam, (HANDLE FAR *)&hdata);

            if(retval == OLE_OK) {
                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, hwnd,
                            MAKELONG(hdata, HIWORD(lParam)))) {
                    GlobalFree (hdata);
                    goto PokeErr1;
                }
                break;
             }

             if (retval == OLE_BUSY)
                status = 0x4000;
             else
                status = 0;

             // if request failed, then acknowledge with error.
             if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                             MAKELONG(status, HIWORD(lParam))))
                 goto PokeErr1;


             break;

       default:
            DEBUG_OUT("doc:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

//DocExecute: Interprets the execute command for the
//document conversation.


OLESTATUS INTERNAL DocExecute(hwnd, hdata, hwndClient)
HWND        hwnd;
HANDLE      hdata;
HWND        hwndClient;
{

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;
    LPDOC           lpdoc;
    LPOLESERVERDOC  lpoledoc;
    LPCLIENT        lpclient = NULL;

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    WORD            verb;
    WORD            wCmdType;

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = DuplicateData(hdata)))
        goto    errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto    errRtn;

    DEBUG_OUT (lpdata, 0)

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpdoc, "doc: doc does not exist");
#endif
    lpoledoc = lpdoc->lpoledoc;

    retval = OLE_ERROR_SYNTAX;

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        LPSRVR  lpsrvr;

        if (lpsrvr =  (LPSRVR) GetWindowLong (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {
#ifdef FIREWALLS
                if (!CheckPointer (lpoledoc, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOC")
                else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
                else
                    ASSERT (lpoledoc->lpvtbl->Execute,
                        "Invalid pointer to Execute method")
#endif

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }
        }

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpoledoc->lpvtbl->Close,"Invalid pointer to Close method")
#endif
        lpdoc->fAckClose  = TRUE;
        lpdoc->hwndClose  = hwndClient;
        lpdoc->hDataClose = hdata;
        retval = (*lpoledoc->lpvtbl->Close) (lpoledoc);
        lpdoc->fAckClose  = FALSE;
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


        if(!(lpnextarg = ScanNumArg(lpverb, (LPINT)&verb)))
            goto errRtn;

#ifdef  FIREWALLS
        ASSERT (verb < 9 , "Unexpected verb number");
#endif

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;


        retval = DocDoVerbItem (lpdoc, lpitemname, verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    retval = DocShowItem (lpdoc, lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   return retval;
}

int INTERNAL   DocShowItem (lpdoc, lpitemname, fAct)
LPDOC   lpdoc;
LPSTR   lpitemname;
BOOL    fAct;

{
    LPCLIENT   lpclient;
    int        retval;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->Show,
                "Invalid pointer to Show method")
#endif

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.

    return (*lpclient->lpoleobject->lpvtbl->Show)(lpclient->lpoleobject, fAct);
}


int INTERNAL   DocDoVerbItem (lpdoc, lpitemname, verb, fShow, fAct)
LPDOC   lpdoc;
LPSTR   lpitemname;
WORD    verb;
BOOL    fShow;
BOOL    fAct;
{
    LPCLIENT   lpclient;
    int        retval = OLE_ERROR_PROTOCOL;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->DoVerb,
                "Invalid pointer to Run method")
#endif

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = (*lpclient->lpoleobject->lpvtbl->DoVerb)(lpclient->lpoleobject, verb, fShow, fAct);

    return retval;
}



// FreePokeData: Frees the poked dats.
void  INTERNAL FreePokeData (hdde)
HANDLE  hdde;
{
    DDEPOKE FAR * lpdde;

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            GlobalUnlock (hdde);
            FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

BOOL INTERNAL FreeGDIdata (hData, cfFormat)
HANDLE          hData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\olesvr.asm ===
;\
    ;   ole.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains pointer vaildation routine
    ;       
    ;   History:  sriniK   02/26/1991 original
   ;/               

.286p
.MODEL SMALL
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax                                              
            and     word ptr [bp+8], -1
            jnz     check_write_access

            verr    word ptr [bp+6]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+6]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+6] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+4], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp
            end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\srvr.c ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD is reserved

#define OLE_VERSION 0x1001L


extern ATOM    aOLE;
extern ATOM    aSysTopic;
extern ATOM    aStdExit;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdShowItem;
extern ATOM    aProtocols;
extern ATOM    aTopics;
extern ATOM    aFormats;
extern ATOM    aStatus;
extern ATOM    cfNative;
extern ATOM    aEditItems;
extern ATOM    aStdClose;


extern HANDLE  hdllInst;
extern BOOL    bProtMode;

extern FARPROC lpTerminateClients;

#ifdef FIREWALLS
BOOL    bShowed = FALSE;
void    ShowVersion (void);
#endif


DWORD FAR PASCAL  OleQueryServerVersion ()
{
    return OLE_VERSION;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr)
*
* OleRegisterServer: Registers the server with the server library.
*
* Parameters:
*       1. Ptr to the server class.
*       2. Ptr to the olesrvr. This is private to the server app.
*          (Typically this is the ptr to the private storage area of
*           server app server related info).
*       3. Ptr to the LHSRVR. Place where to pass back the long
*          handle of the server in DLL (This is private to the DLL).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr, hInst, useFlags)
LPCSTR          lpclass;            // class name
LPOLESERVER     lpolesrvr;          // ole srvr(private to srvr app)
LHSRVR FAR *    lplhsrvr;           // where we pass back our private handle
HANDLE          hInst;
OLE_SERVER_USE  useFlags;
{

    HANDLE  hsrvr  = NULL;
    LPSRVR  lpsrvr = NULL;
    ATOM    aExe = NULL;

    Puts ("OleRegisterServer");

    if (!bProtMode)
       return OLE_ERROR_PROTECT_ONLY;

    PROBE_READ((LPSTR)lpclass);
    PROBE_WRITE(lpolesrvr);
    PROBE_WRITE(lplhsrvr);

    // add the app atom to global list
    if (!ValidateSrvrClass ((LPSTR)lpclass, &aExe))
        return OLE_ERROR_CLASS;

    hsrvr = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (SRVR));
    if (! (hsrvr && (lpsrvr = (LPSRVR)GlobalLock (hsrvr))))
        goto errReturn;

    // set the signature handle and the app atom.
    lpsrvr->sig[0]      = 'S';
    lpsrvr->sig[1]      = 'R';
    lpsrvr->hsrvr       = hsrvr;
    lpsrvr->aClass      = GlobalAddAtom (lpclass);
    lpsrvr->lpolesrvr   = lpolesrvr;
    lpsrvr->relLock     = TRUE;     // set the release lock.
    lpsrvr->aExe        = aExe;
    lpsrvr->useFlags    = useFlags;

#ifdef   FIREWALLS
    ASSERT ((useFlags == OLE_SERVER_SINGLE  || useFlags == OLE_SERVER_MULTI), "invalid server options");
#endif

    // Create the servre window and do not show it.
    if (!(lpsrvr->hwnd = CreateWindow ("SrvrWndClass", "Srvr",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the srever struct in the window.
    SetWindowLong (lpsrvr->hwnd, 0, (LONG)lpsrvr);

    // Set the signature.
    SetWindowWord (lpsrvr->hwnd, WW_LE, WC_LE);
    SetWindowWord (lpsrvr->hwnd, WW_HANDLE, (WORD)hInst);
    *lplhsrvr = (LONG)lpsrvr;

    return OLE_OK;

errReturn:
    if (lpsrvr){
        if (lpsrvr->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpsrvr->aClass)
            GlobalDeleteAtom (lpsrvr->aClass);

        if (lpsrvr->aExe)
            GlobalDeleteAtom (lpsrvr->aExe);

        GlobalUnlock (hsrvr);
    }

    if (hsrvr)
        GlobalFree (hsrvr);

    return OLE_ERROR_MEMORY;

}


// ValidateSrvrClass checks whether the given server class is valid by
// looking in the win.ini.

BOOL INTERNAL    ValidateSrvrClass (lpclass, lpAtom)
LPSTR       lpclass;
ATOM FAR *  lpAtom;
{

    char    buf[MAX_STR];
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    LPSTR   lptmp;
    LPSTR   lpbuf;
    char    ch;

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\StdFileEditing\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, buf, &cb))
        return FALSE;

    if (!buf[0])
        return FALSE;

    // Get exe name without path and then get an atom for that

    lptmp = lpbuf = (LPSTR)buf;


#if	defined(FE_SB)						//[J1]
    while ( ch = *lptmp ) {					//[J1]
	lptmp = AnsiNext( lptmp );				//[J1]
#else								//[J1]
    while ((ch = *lptmp++) && ch != '\0') {
#endif								//[J1]

        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  GlobalAddAtom (lpbuf);

    return TRUE;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
*
* OlerevokeServer: Unregisters the server which has been registered.
*
* Parameters:
*       1. DLL server handle.
*
*
* return values:
*        returns OLE_OK if the server is successfully unregisterd.
*        ( It is Ok for the app free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Server class release entry point when the server
*        can be released.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
LHSRVR  lhsrvr;
{

    HWND         hwndSrvr;
    LPSRVR       lpsrvr;

    Puts ("OleRevokeServer");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    if (lpsrvr->bTerminate  && lpsrvr->termNo)
        return OLE_WAIT_FOR_RELEASE;

    hwndSrvr = lpsrvr->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "Illegal server handle ")
#endif

    // Terminate the conversation with all clients.
    // If there are any clients to be terminated
    // return back with OLE_STARTED and srvr relase
    // will be called for releasing the server finally.

    // we are terminating.
    lpsrvr->bTerminate  = TRUE;
    lpsrvr->termNo      = 0;

    // send ack if Revoke is done as a result of StdExit
    if (lpsrvr->fAckExit) {
        // Post the acknowledge to the client
        if (!PostMessageToClient (lpsrvr->hwndExit, WM_DDE_ACK, lpsrvr->hwnd,
                            MAKELONG (0x8000, lpsrvr->hDataExit)))
            // if the window died or post failed, delete the atom.
            GlobalFree (lpsrvr->hDataExit);
    }

    // revoks all the documents registered with this server.
    RevokeAllDocs (lpsrvr);

    // enumerate all the clients which are in your list and post the
    // termination.
    EnumProps (hwndSrvr, lpTerminateClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndSrvr, TRUE);

    // reset the release lock. Now it is ok to release the server
    // when all the doc clients and server clients have sent back the
    // termination.

    lpsrvr->relLock = FALSE;
    return ReleaseSrvr (lpsrvr);

}


// ReleaseSrvr: Called when ever a matching WM_TERMINATE is received
// from doc clients or the server clients of a particular server.
// If there are no more terminates pending, it is ok to release the server.
// Calls the server app "release" proc for releasing the server.

int INTERNAL    ReleaseSrvr (lpsrvr)
LPSRVR      lpsrvr;
{

    HANDLE  hsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT

    if (lpsrvr->bTerminate){
        // only if we are  revoking server then see whether it is ok to
        // call Release.

        // First check whethere any docs are active.
        // Doc window is a child window for server window.

        if (lpsrvr->termNo || GetWindow (lpsrvr->hwnd, GW_CHILD))
            return OLE_WAIT_FOR_RELEASE;

        // if the block queue is not empty, do not quit
        if (!IsBlockQueueEmpty(lpsrvr->hwnd))
            return OLE_WAIT_FOR_RELEASE;

    }

    if (lpsrvr->relLock)
        return OLE_WAIT_FOR_RELEASE;  // server is locked. So, delay releasing

    // Inform server app it is time to clean up and post WM_QUIT.

#ifdef FIREWALLS
    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVER")
    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVERVTBL")
    else
        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif

    (*lpsrvr->lpolesrvr->lpvtbl->Release)(lpsrvr->lpolesrvr);

    if (lpsrvr->aClass)
        GlobalDeleteAtom (lpsrvr->aClass);
    if (lpsrvr->aExe)
        GlobalDeleteAtom (lpsrvr->aExe);
    DestroyWindow (lpsrvr->hwnd);
    GlobalUnlock (hsrvr = lpsrvr->hsrvr);
    GlobalFree (hsrvr);
    return OLE_OK;
}


//TerminateClients: Call back for the enum properties.

BOOL    FAR PASCAL  TerminateClients (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{
    LPSRVR  lpsrvr;

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);

    // If the client already died, no terminate.
    if (IsWindowValid ((HWND)hdata)) {
        lpsrvr->termNo++;

        // irrespective of the post, incremet the count, so
        // that client does not die.

        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL);
    }
    else
        ASSERT (FALSE, "TERMINATE: Client's System chanel is missing");

    return TRUE;
}


long FAR PASCAL SrvrWndProc (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPSRVR      lpsrvr;
    WORD        status = NULL;
    HWND        hwndClient;
    HANDLE      hdata;
    OLESTATUS   retval;

    if (AddMessage (hwnd, msg, wParam, lParam, WT_SRVR))
        return 0L;

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);


    switch (msg){

       case  WM_TIMER:
            UnblockPostMsgs (hwnd, FALSE);

            // if no more blocked message empty the queue.
            if (IsBlockQueueEmpty (hwnd))
                KillTimer (hwnd, wParam);

            if (lpsrvr->bTerminate && IsBlockQueueEmpty(lpsrvr->hwnd))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);
            break;

       case WM_CREATE:
            DEBUG_OUT ("Srvr create window", 0)
            break;

       case WM_DDE_INITIATE:
#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

            DEBUG_OUT ("Srvr: DDE init",0);
            if (lpsrvr->bTerminate){
                DEBUG_OUT ("Srvr: No action due to termination process",0)
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple server.

            if (!(lpsrvr->aClass == (ATOM)(LOWORD(lParam)) ||
                  (lpsrvr->aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance ())))

                break;

            if (!HandleInitMsg (lpsrvr, lParam)) {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam)))) {

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    SendMsgToChildren (hwnd, msg, wParam, lParam);

                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the intiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpsrvr->cClients++;
            lpsrvr->bnoRelease = FALSE;
            // add the atoms and post acknowledge

            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));

            SendMessage ((HWND)wParam, WM_DDE_ACK, (WORD)hwnd, lParam);
            break;

       case WM_DDE_EXECUTE:
#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif
            DEBUG_OUT ("srvr: execute", 0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpsrvr->bTerminate) {
                DEBUG_OUT ("Srvr: sys execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (HIWORD(lParam));
                break;
            }


            retval = SrvrExecute (hwnd, HIWORD (lParam), (HWND)wParam);
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->bTerminate) {
                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                            MAKELONG (status, HIWORD(lParam))))
                    // if the window died or post failed, delete the atom.
                    GlobalFree (HIWORD(lParam));
            }

            break;

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("Srvr: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            DeleteClient (lpsrvr->hwnd, (HWND)wParam);
            lpsrvr->cClients--;

            if (lpsrvr->bTerminate){
                if ((--lpsrvr->termNo == 0) && (IsBlockQueueEmpty (lpsrvr->hwnd)))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);

                    // if we released the server, then
                    // by the time we come here,, we have destroyed the window

            }else {
                // If client intiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                            hwnd, NULL);

                // callback release tell the srvr app, it can exit if needs.
                // Inform server app it is time to clean up and post WM_QUIT.
                // only if no docs present.
#if 0
                if (lpsrvr->cClients == 0
                        && (GetWindow (lpsrvr->hwnd, GW_CHILD) == NULL)) {
#endif
                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }
            }
            break;


       case WM_DDE_REQUEST:
            if (lpsrvr->bTerminate || !IsWindowValid ((HWND) wParam))
                goto RequestErr;

            if(RequestDataStd (lParam, (HANDLE FAR *)&hdata) != OLE_OK){
                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                    MAKELONG(0x8000, HIWORD(lParam))))

            RequestErr:
                if (HIWORD(lParam))
                    GlobalDeleteAtom (HIWORD(lParam));
            } else {

                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, hwnd,
                            MAKELONG(hdata, HIWORD(lParam)))) {
                    GlobalFree (hdata);
                    goto RequestErr;
                }
            }
            break;



       case WM_DESTROY:
            DEBUG_OUT ("Srvr: Destroy window",0)
            break;

       default:
            DEBUG_OUT ("Srvr:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

BOOL    INTERNAL    HandleInitMsg (lpsrvr, lParam)
LPSRVR  lpsrvr;
LONG    lParam;
{


    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) ||
            (aOLE == (ATOM)(HIWORD(lParam)))))

        return FALSE;


    // single instance MDI accept
    if (lpsrvr->useFlags == OLE_SERVER_SINGLE)
        return TRUE;


    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (lpsrvr->hwnd, GW_CHILD) && !lpsrvr->cClients)
        return TRUE;

    return FALSE;

}


// AddClient: Adds the client as property to the server
// window. Key is the string generated from the window
// handle and the data is the window itself.


BOOL    INTERNAL AddClient  (hwnd, hkey, hdata)
HWND    hwnd;
HANDLE  hkey;
HANDLE  hdata;
{
    char    buf[6];

    MapToHexStr ((LPSTR)buf, hkey);
    return SetProp (hwnd, (LPSTR)buf, hdata);

}


//DeleteClient: deletes the client from the server clients list.

BOOL    INTERNAL DeleteClient (hwnd, hkey)
HWND    hwnd;
HANDLE  hkey;
{

    char    buf[6];

    MapToHexStr ((LPSTR)buf, hkey);
    return RemoveProp (hwnd, (LPSTR)buf);


}

// FindClient: Finds  whether a given client is
// in the server client list.

HANDLE  INTERNAL FindClient (hwnd, hkey)
HWND    hwnd;
HANDLE  hkey;
{

    char    buf[6];


    MapToHexStr ((LPSTR)buf, hkey);
    return GetProp (hwnd, (LPSTR)buf);
}



// SrvrExecute: takes care of the WM_DDE_EXEXCUTE for the
// server.


OLESTATUS INTERNAL SrvrExecute (hwnd, hdata, hwndClient)
HWND        hwnd;
HANDLE      hdata;
HWND        hwndClient;
{
    ATOM            aCmd;
    BOOL            fActivate;

    LPSTR           lpdata = NULL;
    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;

    LPSTR           lpdocname;
    LPSTR           lptemplate;

    LPOLESERVERDOC  lpoledoc = NULL;
    LPDOC           lpdoc    = NULL;
    LPSRVR          lpsrvr;
    LPOLESERVER     lpolesrvr;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    char            buf[MAX_STR];
    WORD            wCmdType;

    // !!! this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    if (!(hdup = DuplicateData (hdata)))
        goto errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto errRtn;

    DEBUG_OUT (lpdata, 0)

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpsrvr, "Srvr: srvr does not exist");
#endif

    lpolesrvr = lpsrvr->lpolesrvr;

#ifdef   FIREWALLS
    ASSERT ((CheckPointer (lpolesrvr, WRITE_ACCESS)),
        "Srvr: lpolesrvr does not exist");
#endif

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    retval = OLE_ERROR_SYNTAX;
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
            retval = OLE_ERROR_PROTOCOL;
        else {
#ifdef FIREWALLS
            if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpolesrvr->lpvtbl->Execute,
                    "Invalid pointer to Exit method")
#endif

            retval =  (*lpolesrvr->lpvtbl->Execute) (lpolesrvr, hdata);
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit){
        if (*lpdocname)
            goto errRtn1;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Exit, "Invalid pointer to Exit method")
#endif
        lpsrvr->fAckExit  = TRUE;
        lpsrvr->hwndExit  = hwndClient;
        lpsrvr->hDataExit = hdata;
        retval = (*lpolesrvr->lpvtbl->Exit) (lpolesrvr);
        lpsrvr->fAckExit = FALSE;
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        retval = DocShowItem (lpdoc, lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;


#ifdef FIREWALLS
        if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpdoc->lpoledoc->lpvtbl->Close,
                "Invalid pointer to Close method")
#endif

        retval = (*lpdoc->lpoledoc->lpvtbl->Close)(lpdoc->lpoledoc);
        goto end2;
    }


    if (aCmd == aStdOpen) {
        // find if any document is already open.
        // if the doc is open, then no need to call srvr app.
        if (FindDoc (lpsrvr, lpdocname)){
            retval = OLE_OK;
            goto end1;

        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((lpsrvr->useFlags == OLE_SERVER_MULTI) &&
            GetWindow (lpsrvr->hwnd, GW_CHILD))
            goto errRtn;



    // No Doc. register the document. lpoledoc is being probed
    // for validity. So, pass some writeable ptr. It is not
    // being used to access anything yet

    if (OleRegisterServerDoc ((LHSRVR)lpsrvr, lpdocname,
        (LPOLESERVERDOC)NULL, (LHDOC FAR *)&lpdoc))
            goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Documnet does not exit.

    if(aCmd == aStdOpen) {

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Open, "Invalid pointer to Open method")
#endif

        retval = (*lpolesrvr->lpvtbl->Open)(lpolesrvr, (LHDOC)lpdoc,
                lpdocname, (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }
    else {
        lpdoc->fEmbed = TRUE;
    }



    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate) {
#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Create,
                "Invalid pointer to Create method")
#endif
        retval =  (*lpolesrvr->lpvtbl->Create) (lpolesrvr, (LHDOC)lpdoc,
                                    lpclassname, lpdocname,
                                    (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdEdit){

        GlobalGetAtomName (lpsrvr->aClass, (LPSTR)buf, MAX_STR);

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Edit, "Invalid pointer to Edit method")
#endif

        retval = (*lpolesrvr->lpvtbl->Edit) (lpolesrvr, (LHDOC)lpdoc,
                                (LPSTR)buf, lpdocname,
                                (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreateFromTemplate){
        lptemplate = lpnextarg;
        if(!(lpnextarg = ScanArg(lpnextarg)))
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->CreateFromTemplate,
                "Invalid pointer to CreateFromTemplate method")
#endif
        retval = (*lpolesrvr->lpvtbl->CreateFromTemplate)(lpolesrvr,
             (LHDOC)lpdoc, lpclassname, lpdocname, lptemplate,
             (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;

    }


    DEBUG_OUT ("Unknown command", 0);

end:

    if (retval != OLE_OK)
        goto errRtn;

    // Successful execute. remember the server app private doc handle here.

    lpdoc->lpoledoc = lpoledoc;

end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
        retval = OLE_ERROR_SYNTAX;

errRtn:

   if ( retval != OLE_OK){
        // delete the oledoc structure
        if (lpdoc)
            OleRevokeServerDoc ((LHDOC)lpdoc);
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   if (retval == OLE_OK)
        lpsrvr->bnoRelease = TRUE;

   return retval;
}




void SendMsgToChildren (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    hwnd = GetWindow(hwnd, GW_CHILD);
    while (hwnd) {
        SendMessage (hwnd, msg, wParam, lParam);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}


OLESTATUS INTERNAL   RequestDataStd (lparam, lphdde)
LONG        lparam;
LPHANDLE    lphdde;
{

    char    buf[MAX_STR];
    ATOM    item;
    HANDLE  hnew = NULL;

    if (!(item =  (ATOM)(HIWORD (lparam))))
        goto errRtn;

    GlobalGetAtomName (item, (LPSTR)buf, MAX_STR);

    if (item == aEditItems){
        hnew = MakeGlobal ((LPSTR)"StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (item == aProtocols) {
        hnew = MakeGlobal ((LPSTR)"Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (item == aTopics) {
        hnew = MakeGlobal ((LPSTR)"Doc");
        goto   PostData;
    }

    if (item == aFormats) {
        hnew = MakeGlobal ((LPSTR)"Picture\tBitmap");
        goto   PostData;
    }

    if (item == aStatus) {
        hnew = MakeGlobal ((LPSTR)"Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
errRtn:
    return OLE_ERROR_MEMORY;
}


BOOL INTERNAL QueryRelease (lpsrvr)
LPSRVR  lpsrvr;
{

    HWND    hwnd;
    LPDOC   lpdoc;


    // Incase the terminate is called immediately after
    // the Std at sys level clear this.

    if (lpsrvr->bnoRelease) {
        lpsrvr->bnoRelease = FALSE;
        return FALSE;
    }


    if (lpsrvr->cClients)
        return FALSE;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // if either the server or the doc has any clients
    // return FALSE;

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
        if (lpdoc->cClients)
            return FALSE;

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;

}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

BOOL    INTERNAL  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HANDLE  hTask;
    char    buf[MAX_STR];


    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
    hTask = GetCurrentTask();

    while (hwnd) {
        if (hTask == GetWindowTask (hwnd)) {
            GetClassName (hwnd, (LPSTR)buf, MAX_STR);
            if (lstrcmp ((LPSTR)buf, SRVR_CLASS) == 0)
                cnt++;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
#ifdef  FIREWALLS
     ASSERT (cnt > 0, "srvr window instance count is zero");
#endif
    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\item.c ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/


#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern HANDLE   hdllInst;
extern FARPROC  lpFindItemWnd;
extern FARPROC  lpItemCallBack;
extern FARPROC  lpSendDataMsg;
extern FARPROC  lpSendRenameMsg;
extern FARPROC  lpDeleteClientInfo;
extern FARPROC  lpEnumForTerminate;


extern  ATOM    cfNative;
extern  ATOM    cfBinary;
extern  ATOM    aClose;
extern  ATOM    aChange;
extern  ATOM    aSave;
extern  ATOM    aEditItems;
extern  ATOM    aStdDocName;

extern  WORD    cfLink;
extern  WORD    cfOwnerLink;

extern  BOOL    bWin30;

HWND            hwndItem;
HANDLE          hddeRename;
HWND            hwndRename;

WORD            enummsg;
WORD            enuminfo;
LPOLEOBJECT     enumlpoleobject;
OLECLIENTVTBL   clVtbl;
BOOL            bClientUnlink;

BOOL            fAdviseSaveDoc;
BOOL            fAdviseSaveItem;

char *  stdStrTable[STDHOSTNAMES+1] = {NULL,
                                       "StdTargetDevice",
                                       "StdDocDimensions",
                                       "StdColorScheme",
                                       "StdHostNames"};


extern HANDLE (FAR PASCAL *lpfnSetMetaFileBitsBetter) (HANDLE);

void ChangeOwner (HANDLE hmfp);

// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes OLESTATUS).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding child windows handle.

HWND  INTERNAL SearchItem (lpdoc, lpitemname)
LPDOC               lpdoc;
LPSTR               lpitemname;
{
    ATOM    aItem;

    Puts ("SearchItem");

    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
        aItem = (ATOM) (LOWORD((DWORD)lpitemname));
    else if (!lpitemname[0])
        aItem = NULL;
    else
        aItem = GlobalFindAtom (lpitemname);

    hwndItem = NULL;

    // !!! We should avoid hwndItem static. It should not cause
    // any problems since while enumerating we will not be calling
    // any window procs  or no PostMessages are entertained.

    EnumChildWindows (lpdoc->hwnd, lpFindItemWnd,
        MAKELONG (aItem, ITEM_FIND));

    return hwndItem;

}

// FindItem: Given the itemname and the document handle,
// searches for the the item (object) in the document tree.
// Items are child windows for the document window.

// !!! change the child windows to somekind of
// linked lists at the item level. This will free up
// the space taken by the item windows.

int  INTERNAL FindItem (lpdoc, lpitemname, lplpclient)
LPDOC               lpdoc;
LPSTR               lpitemname;
LPCLIENT FAR *      lplpclient;
{
    LPCLIENT    lpclient;
    HWND        hwnd;
    char        buf[MAX_STR];

    Puts ("FindItem");

    hwnd = SearchItem (lpdoc, lpitemname);

    if (!HIWORD(lpitemname)){
        if (LOWORD(lpitemname))
            GlobalGetAtomName ((ATOM)LOWORD((DWORD)lpitemname),
                        (LPSTR)buf, MAX_STR);
        else
            buf[0] = NULL;

        lpitemname = (LPSTR)buf;
    }

    if (hwnd) {
        // we found the item window
        lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
            ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
                "In Item the client handle missing")
            ASSERT ((CheckPointer(lpclient->lpoleobject, WRITE_ACCESS)),
                "In Item object handle missing")

#endif
            *lplpclient = lpclient;
            return OLE_OK;

    }

    // Item (object)window is not create yet. Let us create one.
    return RegisterItem ((LHDOC)lpdoc, lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given document.

int  INTERNAL RegisterItem (lhdoc, lpitemname, lplpclient, bSrvr)
LHDOC               lhdoc;
LPSTR               lpitemname;
LPCLIENT FAR *      lplpclient;
BOOL                bSrvr;
{


    LPDOC           lpdoc;
    HANDLE          hclient  = NULL;
    LPCLIENT        lpclient = NULL;
    int             retval   = OLE_ERROR_MEMORY;
    LPOLESERVERDOC  lpoledoc;
    LPOLEOBJECT     lpoleobject = NULL;


    Puts ("CreateItem");

    lpdoc = (LPDOC)lhdoc;

#ifdef FIREWALLS
    ASSERT ((CheckPointer (lplpclient, WRITE_ACCESS)), "invalid lplpclient");
#endif

    // First create the callback client structure.

    hclient = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (CLIENT));
    if(!(hclient && (lpclient = (LPCLIENT)GlobalLock (hclient))))
        goto errRtn;

    lpclient->hclient       = hclient;
    hclient                 = NULL;

    if (!HIWORD(lpitemname)) {
        ASSERT (!bSrvr, "invalid lpitemname in RegisterItem\n");
        lpclient->aItem = LOWORD((DWORD)lpitemname);
    }
    else if (!lpitemname[0])
        lpclient->aItem = NULL;
    else
        lpclient->aItem = GlobalAddAtom (lpitemname);

    lpclient->oleClient.lpvtbl = &clVtbl;
    lpclient->oleClient.lpvtbl->CallBack = (int (CALLBACK *)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT))lpItemCallBack;

    lpoledoc = lpdoc->lpoledoc;

    // Call the server app to create its own object structure and link
    // it to the given document.

    // Call the server if the item is not one of the standard items.

    if (bSrvr) {
        retval = (*lpoledoc->lpvtbl->GetObject)(lpoledoc, lpitemname,
                    (LPOLEOBJECT FAR *)&lpoleobject, (LPOLECLIENT)lpclient);
        if (retval != OLE_OK)
            goto errRtn;
    }

    lpclient->lpoleobject   = lpoleobject;

    lpclient->hwnd = CreateWindow ("ItemWndClass", "ITEM",
                        WS_CHILD,0,0,0,0,lpdoc->hwnd,NULL, hdllInst, NULL);

    if (lpclient->hwnd == NULL)
        goto errRtn;

    // save the ptr to the item in the window.
    SetWindowLong (lpclient->hwnd, 0, (LONG)lpclient);
    *lplpclient = lpclient;
    return OLE_OK;

errRtn:

    if (lpclient)
        RevokeObject ((LPOLECLIENT)lpclient, FALSE);

    else {
        if(hclient)
            GlobalFree (hclient);
    }

    return retval;

}


OLESTATUS  FAR PASCAL OleRevokeObject (lpoleclient)
LPOLECLIENT    lpoleclient;
{
    return RevokeObject (lpoleclient, TRUE);

}
// OleRevokeObject: Revokes an object (unregisres an object
// from the document tree.

OLESTATUS  INTERNAL RevokeObject (lpoleclient, bUnlink)
LPOLECLIENT    lpoleclient;
BOOL           bUnlink;
{

    HANDLE      hclient;
    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)lpoleclient;

    PROBE_WRITE(lpoleclient);
    if (lpclient->lpoleobject) {
       // first call the object for deletetion.

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")

        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT(lpclient->lpoleobject->lpvtbl->Release,
                "Invalid pointer to Release method")
#endif

        (*lpclient->lpoleobject->lpvtbl->Release)(lpclient->lpoleobject);

    }

    if (ISATOM(lpclient->aItem)) {
        GlobalDeleteAtom (lpclient->aItem);
        lpclient->aItem = NULL;
    }

    if (lpclient->hwnd) {
        SetWindowLong (lpclient->hwnd, 0, (LONG)NULL);

        // another static for enumerating the properties.
        // we need to change these .
        bClientUnlink = bUnlink;

        EnumProps(lpclient->hwnd, lpDeleteClientInfo);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);
        DestroyWindow (lpclient->hwnd);
    }

    GlobalUnlock (hclient = lpclient->hclient);
    GlobalFree (hclient);
    return OLE_OK;

}

BOOL    FAR PASCAL  DeleteClientInfo (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    PCLINFO     pclinfo = NULL;
    HWND        hwndDoc;
    LPDOC       lpdoc;

#ifdef FIREWALLS
    ASSERT (hclinfo, "Client info null in item property list");
#endif


    // delete the printer dev info block
    if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);


        if (bClientUnlink) {
            // terminate the conversation for the client.
            TerminateDocClients ((hwndDoc = GetParent(hwnd)), NULL, pclinfo->hwnd);
            lpdoc = (LPDOC)GetWindowLong (hwndDoc, 0);
            // for some reason this delete is gving circular lists for properties

            //DeleteClient (hwndDoc, pclinfo->hwnd);
            //lpdoc->cClients--;
        }
        LocalUnlock (hclinfo);
    }
    LocalFree (hclinfo);
    RemoveProp (hwnd, lpstr);
    return TRUE;
}




// Call back for the Object windows numeration. data  field
// has the command and the extra information


BOOL    FAR PASCAL FindItemWnd (hwnd, data)
HWND    hwnd;
LONG    data;
{

    LPCLIENT    lpclient;
    int         cmd;
    HANDLE      hclinfo;
    PCLINFO    pclinfo;


    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    // ASSERT (lpclient, "In Item the client handle missing")
#endif

    cmd = HIWORD(data);
    switch (cmd) {
        case    ITEM_FIND:
            if (lpclient->aItem == (ATOM)(LOWORD (data))) {
                // we found the window we required. Remember the
                // object window.

                hwndItem = hwnd;
                return FALSE; // terminate enumeration.

            }
            break;

        case    ITEM_SAVED:
            if (lpclient->lpoleobject) {
                if (ItemCallBack ((LPOLECLIENT) lpclient, OLE_SAVED,
                        lpclient->lpoleobject) == OLE_ERROR_CANT_UPDATE_CLIENT)
                    fAdviseSaveDoc = FALSE;
            }
            break;

        case    ITEM_DELETECLIENT:

            // delete the client from our list if we have one

            hclinfo = FindClient (hwnd, (HWND) (LOWORD(data)));
            if (hclinfo){
                // delete the printer dev info block
                if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
                    if(pclinfo->hdevInfo)
                        GlobalFree (pclinfo->hdevInfo);
                    LocalUnlock (hclinfo);
                }
                LocalFree (hclinfo);
                DeleteClient ( hwnd, (HWND) (LOWORD(data)));
            }
            break;

        case    ITEM_DELETE:
            // delete the client it self.
            RevokeObject ((LPOLECLIENT)lpclient, FALSE);
            break;

    }
    return TRUE;        // continue enumeration.
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.


void INTERNAL   DeleteFromItemsList (hwndDoc, hwndClient)
HWND    hwndDoc;
HWND    hwndClient;
{

    EnumChildWindows (hwndDoc, lpFindItemWnd,
        MAKELONG (hwndClient, ITEM_DELETECLIENT));

}


// DeleteAllItems: Deletes all the objects of a given
// document window.


void INTERNAL   DeleteAllItems (hwndDoc)
HWND    hwndDoc;
{

    EnumChildWindows (hwndDoc, lpFindItemWnd,
            MAKELONG (NULL, ITEM_DELETE));

}


// Object widnow proc:

long FAR PASCAL ItemWndProc(hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

    switch (msg) {
       case WM_DESTROY:
            DEBUG_OUT("Item: Destroy window",0)

#ifdef  FIREWALLS
            ASSERT (!lpclient, "while destroy Item client is not null")
#endif
            break;
       default:
            DEBUG_OUT("item:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }
    return 0L;

}

// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

OLESTATUS    INTERNAL PokeData (lpdoc, hwndClient, lparam)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
{
    int             retval = OLE_ERROR_MEMORY;
    LPCLIENT        lpclient;
    DDEPOKE FAR *   lpPoke = NULL;
    HANDLE          hPoke = NULL;
    HANDLE          hnew   = NULL;
    int             format;
    BOOL            fRelease = FALSE;

    // Get the object handle first. Look in the registration
    // tree and if one is not created otherwise create one.

    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);

    if (retval != OLE_OK)
        goto errRtn;

    hPoke = (HANDLE)(LOWORD (lparam));
    if(!(hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke))))
        goto errRtn;

    GlobalUnlock (hPoke);

    format   = lpPoke->cfFormat;
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    if (!(hnew = MakeItemData (lpPoke, hPoke, format)))
        goto errRtn;

    // Now send the data to the object

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetData,
                "Invalid pointer to SetData method")
#endif

    retval = (*lpclient->lpoleobject->lpvtbl->SetData) (lpclient->lpoleobject,
                                                format, hnew);

    // We free the data if server returns OLE_ERROR_SETDATA_FORMAT.
    // Otherwise server must've deleted it.

    if (retval == OLE_ERROR_SETDATA_FORMAT) {
        if (!FreeGDIdata (hnew, format))
            GlobalFree (hnew);
    }


errRtn:
    if (retval == OLE_OK && fRelease) {
        if (hPoke)
            GlobalFree (hPoke);
    }

    return retval;
}




OLESTATUS  INTERNAL UnAdviseData (lpdoc, hwndClient, lparam)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
{


    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    int             retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    if (!(HIWORD (lparam)))
        buf[0] = NULL;
    else
        GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    if (buf[0] == NULL) {
        // Unadvise for null should terminate all the advises
        DeleteFromItemsList (lpdoc->hwnd, hwndClient);
        return OLE_OK;
    }

    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;


    // Find the client structure to be attcahed to the object.
    if ((hclinfo = FindClient (lpclient->hwnd, hwndClient)) == NULL ||
        (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL ){
            retval = OLE_ERROR_MEMORY;
            goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);
    return retval;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseStdItems (lpdoc, hwndClient, lparam, lpfack)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
BOOL FAR *  lpfack;
{

    HANDLE              hopt   = NULL;
    DDEADVISE FAR       *lpopt;
    OLESTATUS           retval = OLE_ERROR_MEMORY;


    hopt = (HANDLE) (LOWORD (lparam));
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errrtn;

#ifdef  FIREWALLS
    ASSERT ((ATOM) (HIWORD (lparam) == aStdDocName), "AdviseStdItem is not Documentname");
#endif

    *lpfack = lpopt->fAckReq;
    retval = SetStdInfo (lpdoc, hwndClient, (LPSTR)"StdDocumentName",  NULL);

    if (lpopt)
        GlobalUnlock (hopt);

errrtn:

    if (retval == OLE_OK)
        // !!! make sure that we have to free the data for error case
        GlobalFree (hopt);
    return retval;
}



//AdviseData: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseData (lpdoc, hwndClient, lparam, lpfack)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
BOOL FAR *  lpfack;
{


    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    int             format = NULL;
    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    int             retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;



    hopt = (HANDLE) (LOWORD (lparam));
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    if (!(HIWORD (lparam)))
        buf[0] = NULL;
    else
        GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    if (!IsFormatAvailable (lpclient, lpopt->cfFormat)){
        retval = OLE_ERROR_DATATYPE;       // this format is not supported;
        goto errRtn;
    }

    *lpfack = lpopt->fAckReq;

    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->hwnd, hwndClient)))
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));

    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
        retval = OLE_ERROR_MEMORY;
        goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if (lpopt->cfFormat == (int)cfNative)
        pclinfo->bnative = TRUE;
    else
        pclinfo->format = lpopt->cfFormat;

    // Remeber the data transfer options.
    pclinfo->options |= (0x0001 << options);
    pclinfo->bdata   = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = NULL;


    // if the entry exists already, delete it.
    DeleteClient (lpclient->hwnd, hwndClient);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient (lpclient->hwnd, hwndClient, hclinfo))
        goto errRtn;


errRtn:
    if (lpopt)
        GlobalUnlock (hopt);

    if (pclinfo)
        LocalUnlock (hclinfo);

    if (retval == OLE_OK) {
        // !!! make sure that we have to free the data
        GlobalFree (hopt);

    }else {
        if (hclinfo)
            LocalFree (hclinfo);
    }
    return retval;

}

BOOL INTERNAL IsFormatAvailable (lpclient, cfFormat)
LPCLIENT        lpclient;
OLECLIPFORMAT   cfFormat;
{
      OLECLIPFORMAT  cfNext = 0;


      do{

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->EnumFormats,
                "Invalid pointer to EnumFormats method")
#endif

        cfNext = (*lpclient->lpoleobject->lpvtbl->EnumFormats)
                                (lpclient->lpoleobject, cfNext);
        if (cfNext == cfFormat)
            return TRUE;

      }while (cfNext != 0);

      return FALSE;
}

//ScanItemOptions: Scan for the item options like Close/Save etc.

OLESTATUS INTERNAL ScanItemOptions (lpbuf, lpoptions)
LPSTR   lpbuf;
int far *lpoptions;
{

    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/')
    {
#if	defined(FE_SB)						//[J1]
	   lpbuf = AnsiNext( lpbuf );				//[J1]
#else								//[J1]
           lpbuf++;
#endif
    }								//[J1]

    // no modifier same as /change

    if (*lpbuf == NULL)
        return OLE_OK;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknow modifier
    return OLE_ERROR_SYNTAX;

}

//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

OLESTATUS INTERNAL   RequestData (lpdoc, hwndClient, lparam, lphdde)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
LPHANDLE    lphdde;
{

    OLESTATUS   retval = OLE_OK;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    char        buf[6];

    // If edit environment Send data if we can
    if ((HIWORD (lparam)) == aEditItems)
        return RequestDataStd (lparam, lphdde);

    // Get the object.
    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    retval = OLE_ERROR_DATATYPE;
    if (!IsFormatAvailable (lpclient, (int)(LOWORD (lparam))))
        goto errRtn;

    // Now ask the item for the given format  data

#ifdef FIREWALLS
    ASSERT (lpclient->lpoleobject->lpvtbl->GetData,
        "Invalid pointer to GetData method")
#endif

    MapToHexStr ((LPSTR)buf, hwndClient);
    SendDevInfo (lpclient, (LPSTR)buf);

    retval = (*lpclient->lpoleobject->lpvtbl->GetData) (lpclient->lpoleobject,
                (int)(LOWORD (lparam)), (LPHANDLE)& hdata);

    if (retval != OLE_OK)
        goto errRtn;

    if (LOWORD(lparam) == CF_METAFILEPICT)
        ChangeOwner (hdata);

    // Duplicate the DDE data
    if(MakeDDEData(hdata, (int)(LOWORD (lparam)), lphdde, TRUE)){
        // !!! Why do we have to duplicate the atom
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
    else
        return OLE_ERROR_MEMORY;

errRtn:
    return retval;

}

//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

BOOL    INTERNAL MakeDDEData (hdata, format, lph, fResponse)
HANDLE      hdata;
LPHANDLE    lph;
int         format;
BOOL        fResponse;
{
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL        bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    if (!hdata) {
        *lph = NULL;
        return TRUE;
    }

    if (bnative = !(format == CF_METAFILEPICT || format == CF_DIB ||
                            format == CF_BITMAP))
       size = GlobalSize (hdata) + sizeof (DDEDATA);
    else
       size = sizeof (LONG) + sizeof (DDEDATA);


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
        goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fRelease = TRUE;  // release the data
    lpdata->cfFormat = format;
    lpdata->fResponse = fResponse;

    if (!bnative)
        // If not native, stick in the handle what the server gave us.
        *(LPHANDLE)lpdata->Value = hdata;

    else {
        // copy the native data junk here.
        lpdst = (LPSTR)lpdata->Value;
        if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
            goto errRtn;

         size -= sizeof (DDEDATA);
         UtilMemCpy (lpdst, lpsrc, size);
         GlobalUnlock (hdata);
         GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
        GlobalUnlock (hdde);

    if (hdde)
        GlobalFree (hdde);

    if (bnative)
         GlobalFree (hdata);

    return FALSE;
}


// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

int FAR PASCAL  ItemCallback (lpoleclient, msg, lpoleobject)
LPOLECLIENT     lpoleclient;
WORD            msg;        // notification message
LPOLEOBJECT     lpoleobject;
{

    LPCLIENT    lpclient;
    int         retval = OLE_OK;
    HANDLE      hdata  = NULL;
    LPSTR       lpdata = NULL;
    LPDOC       lpdoc;
    HWND        hStdWnd;

    lpclient  = (LPCLIENT)lpoleclient;
    lpdoc = (LPDOC)GetWindowLong (GetParent (lpclient->hwnd), 0);

    if (msg == OLE_RENAMED) {
#ifdef FIREWALLS
        if (!CheckPointer (lpoleobject, WRITE_ACCESS))
          ASSERT (0, "Invalid lpoleobject")
        else if (!CheckPointer (lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpoleobject->lpvtbl->GetData,
                "Invalid pointer to GetData method")
#endif

        if (IsFormatAvailable (lpclient, cfLink)) {

            // Get the link data.

            retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                (int)cfLink, (LPHANDLE)&hdata);
        }
        else {
            if(IsFormatAvailable (lpclient, cfOwnerLink)) {

                // Get the link data.
                retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                    (int)cfOwnerLink, (LPHANDLE)& hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY")
#endif


            } else
                retval = OLE_ERROR_DATATYPE;
        }

        if (retval != OLE_OK)
            goto errrtn;

        if (!(lpdata = (LPSTR)GlobalLock (hdata)))
            goto errrtn;

        if (lpdoc->aDoc) {
            GlobalDeleteAtom (lpdoc->aDoc);
            lpdoc->aDoc = NULL;
        }

        // Move the string to the beginning and still terminated by null;
        lstrcpy (lpdata, lpdata + lstrlen (lpdata) + 1);
        lpdoc->aDoc = GlobalAddAtom (lpdata);

        // Now make the DDE data block
        GlobalUnlock (hdata);
        lpdata = NULL;

        // find if any StdDocName item is present at all
        if (!(hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))))
            GlobalFree (hdata);
        else {

            // hdata is freed by Makeddedata
            if (!MakeDDEData (hdata, (int)cfBinary, (LPHANDLE)&hddeRename,
                        FALSE)) {
                retval = OLE_ERROR_MEMORY;
                goto errrtn;
            }

            EnumProps(hStdWnd, lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);
        }

        // static. Avoid this. This may not cause any problems for now.
        // if there is any better way, change it.
        hwndRename = hStdWnd;

        // Post termination for each of the doc clients.
        EnumProps (lpdoc->hwnd, lpEnumForTerminate);

        lpdoc->fEmbed = FALSE;

        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpdoc->hwnd, FALSE);
        return OLE_OK;

     errrtn:
        if (lpdata)
            GlobalUnlock (hdata);

        if (hdata)
            GlobalFree (hdata);

        return retval;

    } else {

        // !!! any better way to do instead of putting in static
        // (There may not be any problems since we are not allowing
        // any messages to get thru while we are posting messages).


        if ((enummsg = msg) == OLE_SAVED)
            fAdviseSaveItem = FALSE;

        enumlpoleobject = lpoleobject;

#ifdef  FIREWALLS
        ASSERT (lpclient->hwnd && IsWindowValid (lpclient->hwnd), " Not valid object")
#endif

        // Enumerate all the clients and send DDE_DATA if necessary.
        EnumProps(lpclient->hwnd, lpSendDataMsg);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);

        if ((msg == OLE_SAVED) && lpdoc->fEmbed && !fAdviseSaveItem)
            return OLE_ERROR_CANT_UPDATE_CLIENT;

        return OLE_OK;
    }
}


BOOL    FAR PASCAL  EnumForTerminate (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{

    LPDOC   lpdoc;

    lpdoc = (LPDOC)GetWindowLong (hwnd , 0);

    // This client is in the rename list. So, no terminate
    if(hwndRename && FindClient (hwndRename, (HWND)hdata))
        return TRUE;


    if (PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL))
        lpdoc->termNo++;

    //DeleteClient (hwnd, (HWND)hdata);
    //lpdoc->cClients--;
    return TRUE;
}


BOOL    FAR PASCAL  SendRenameMsg (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    ATOM        aData    = NULL;
    HANDLE      hdde     = NULL;
    PCLINFO     pclinfo = NULL;
    HWND        hwndClient;

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errrtn;

    // Make the item atom with the options.
    aData =  DuplicateAtom (aStdDocName);
    hdde  = DuplicateData (hddeRename);

    hwndClient  = pclinfo->hwnd;
    LocalUnlock (hclinfo);

    // Post the message
    if (!PostMessageToClientWithBlock (hwndClient, WM_DDE_DATA, (HWND)GetParent (hwnd),
            MAKELONG (hdde, aData)))
        goto errrtn;

    return TRUE;

errrtn:

    if (hdde)
        GlobalFree (hdde);
    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

BOOL    FAR PASCAL  SendDataMsg (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    PCLINFO     pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM        aData   = NULL;
    int         retval;
    HANDLE      hdata;
    LPCLIENT    lpclient;


    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errRtn;

    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
        "In Item the client handle missing")
#endif

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
        goto errRtn;

    if (pclinfo->options & (0x0001 << enummsg)) {
        fAdviseSaveItem = TRUE;
        SendDevInfo (lpclient, lpstr);

        // send message if the client needs data for every change or
        // only for the selective ones he wants.

        // now look for the data option.
        if (pclinfo->bnative){
            // prepare native data
            if (pclinfo->bdata){

                // Wants the data with DDE_DATA message
                // Get native data from the server.

#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif

                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            (int)cfNative, (LPHANDLE)& hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                // Prepare the DDE data block.
                if(!MakeDDEData (hdata, (int)cfNative, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }


            // Make the item atom with the options.
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            // Post the message
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (HWND)GetParent (hwnd), MAKELONG (hdde, aData)))
                goto errRtn;
            hdde = NULL;
            aData = NULL;
        }

        // Now post the data for the disply format
        if (pclinfo->format){
            if (pclinfo->bdata){
#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif
                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            pclinfo->format, (LPHANDLE)& hdata);

#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                if (pclinfo->format == CF_METAFILEPICT)
                    ChangeOwner (hdata);

                if(!MakeDDEData (hdata, pclinfo->format, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }

            // atom is deleted. So, we need to duplicate for every post
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            // now post the message to the client;
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (HWND)GetParent (hwnd), MAKELONG (hdde, aData)))
                goto errRtn;

            hdde = NULL;
            aData = NULL;

        }

    }


errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hdde)
        GlobalFree (hdde);

    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}


// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
BOOL    INTERNAL IsAdviseStdItems (aItem)
ATOM   aItem;
{

    if ( aItem == aStdDocName)
        return TRUE;
    else
        return FALSE;
}

// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme

int INTERNAL GetStdItemIndex (aItem)
ATOM   aItem;
{
    char    str[MAX_STR];

    if (!aItem)
        return NULL;

    if (!GlobalGetAtomName (aItem, (LPSTR) str, MAX_STR))
        return NULL;

    if (!lstrcmpi (str, stdStrTable[STDTARGETDEVICE]))
        return STDTARGETDEVICE;
    else if (!lstrcmpi (str, stdStrTable[STDHOSTNAMES]))
        return STDHOSTNAMES;
    else if (!lstrcmpi (str, stdStrTable[STDDOCDIMENSIONS]))
        return STDDOCDIMENSIONS;
    else if (!lstrcmpi (str, stdStrTable[STDCOLORSCHEME]))
        return STDCOLORSCHEME;

    return NULL;
}


// PokeStdItems: Pokes the data for the standard items.
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.


OLESTATUS    INTERNAL PokeStdItems (lpdoc, hwndClient, lparam)
LPDOC   lpdoc;
HWND    hwndClient;
LONG    lparam;
{
    int             index;
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hdata  = NULL;
    HANDLE          hnew   = NULL;
    LPOLESERVERDOC   lpoledoc;
    LPHOSTNAMES     lphostnames;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    int             format;
    BOOL            fRelease;
    RECT            rcDoc;

    index = HIWORD(lparam);
    hdata = (HANDLE)(LOWORD (lparam));
    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
        goto errRtn;

    format   = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

#ifdef FIREWALSS
    ASSERT (format == (int)cfBinary, "Format is not binary");
#endif

    // we have extracted the data successfully.
    lpoledoc = lpdoc->lpoledoc;
#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
#endif

    if (index == STDHOSTNAMES){
        lphostnames = (LPHOSTNAMES)lpdata->Value;
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetHostNames,
            "Invalid pointer to SetHostNames method")
#endif
        retval = (*lpoledoc->lpvtbl->SetHostNames)(lpdoc->lpoledoc,
                       (LPSTR)lphostnames->data,
                       ((LPSTR)lphostnames->data) +
                        lphostnames->documentNameOffset);
        goto end;
    }

    if (index == STDDOCDIMENSIONS){
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetDocDimensions,
            "Invalid pointer to SetDocDimensions method")
#endif
        rcDoc.left   = 0;
        rcDoc.top    = ((LPRECT)(lpdata->Value))->top;
        rcDoc.bottom = 0;
        rcDoc.right  = ((LPRECT)lpdata->Value)->left;

        retval = (*lpoledoc->lpvtbl->SetDocDimensions)(lpdoc->lpoledoc,
                                            (LPRECT)&rcDoc);

        goto end;

    }

    if (index == STDCOLORSCHEME) {
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetColorScheme,
            "Invalid pointer to SetColorScheme method")
#endif
        retval = (*lpoledoc->lpvtbl->SetColorScheme)(lpdoc->lpoledoc,
                                            (LPLOGPALETTE) lpdata->Value);
        goto end;
    }
#ifdef FIREWALLS
    ASSERT (index == STDTARGETDEVICE, "Unknown standard item");
#endif

    // case of the printer decvice info

    if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
        goto errRtn;

    // Go thru the all the items lists for this doc and replace the
    // printer device info information.
    // Free the block we duplicated.
    retval = SetStdInfo (lpdoc, hwndClient,
                (LPSTR) (MAKELONG(STDTARGETDEVICE,0)),hnew);


end:
errRtn:
    if (hnew)
        // can only be global memory block
        GlobalFree (hnew);

    if (lpdata) {
        GlobalUnlock (hdata);
        if (retval == OLE_OK && fRelease)
            GlobalFree (hdata);
    }
    return retval;
}


// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


int INTERNAL   SetStdInfo (lpdoc, hwndClient, lpitemname, hdata)
LPDOC   lpdoc;
HWND    hwndClient;
LPSTR   lpitemname;
HANDLE  hdata;
{
    HWND        hwnd;
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    LPCLIENT    lpclient;
    OLESTATUS   retval   = OLE_OK;


    // first create/find the StdTargetDeviceItem.

    if ((hwnd = SearchItem (lpdoc, lpitemname))
                == NULL){
         retval = RegisterItem ((LHDOC)lpdoc, lpitemname,
                          (LPCLIENT FAR *)&lpclient, FALSE);

         if (retval != OLE_OK)
            goto errRtn;

         hwnd = lpclient->hwnd;

      }

#ifdef  FIREWALLS
      ASSERT (retval == OLE_OK, "No StdTragetDevice or StdDocname item");
#endif


    if(hclinfo = FindClient (hwnd, hwndClient)){
        if (pclinfo = (PCLINFO) LocalLock (hclinfo)){
            if (pclinfo->hdevInfo)
                GlobalFree (pclinfo->hdevInfo);
            pclinfo->bnewDevInfo = TRUE;
            if (hdata)
                pclinfo->hdevInfo = DuplicateData (hdata);
            else
                pclinfo->hdevInfo = NULL;
            pclinfo->hwnd = hwndClient;
            LocalUnlock (hclinfo);

            // We do not have to reset the client because we did not
            // change the handle it self.
        }
    } else {
        // Create the client structure to be attcahed to the object.
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
        if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
            goto errRtn;

        pclinfo->bnewDevInfo = TRUE;
        if (hdata)
            pclinfo->hdevInfo = DuplicateData (hdata);
        else
            pclinfo->hdevInfo = NULL;

        pclinfo->hwnd = hwndClient;
        LocalUnlock (hclinfo);


        // Now add this client to item client list
        // !!! This error recovery is not correct.
        if (!AddClient (hwnd, hwndClient, hclinfo))
            goto errRtn;

    }
    return OLE_OK;
errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hclinfo)
        LocalFree (hclinfo);
    return OLE_ERROR_MEMORY;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

void INTERNAL    SendDevInfo (lpclient, lppropname)
LPCLIENT    lpclient;
LPSTR       lppropname;
{

    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    HANDLE      hdata;
    OLESTATUS   retval;
    HWND        hwnd;
    LPDOC       lpdoc;



    lpdoc = (LPDOC)GetWindowLong (GetParent (lpclient->hwnd), 0);

    // find if any StdTargetDeviceInfo item is present at all
    hwnd = SearchItem (lpdoc, (LPSTR) (MAKELONG(STDTARGETDEVICE, 0)));
    if (hwnd == NULL)
        return;

    hclinfo = GetProp (hwnd, lppropname);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
        if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
            goto end;

        // if we cached it, do not send it again.
        if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == lpclient->hdevInfo)
            goto end;

        pclinfo->bnewDevInfo = FALSE;
        if(!(hdata = DuplicateData (pclinfo->hdevInfo)))
            goto end;
    } else {

        // already screen
        if (!lpclient->hdevInfo)
            goto end;

        //for screen send NULL.
        hdata = NULL;
    }


    // Now send the targetdevice info
#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetTargetDevice,
                "Invalid pointer to SetTargetDevice method")
#endif
    retval = (*lpclient->lpoleobject->lpvtbl->SetTargetDevice)
                    (lpclient->lpoleobject, hdata);

    if (retval == OLE_OK) {
        if (pclinfo)
            lpclient->hdevInfo = pclinfo->hdevInfo;
        else
            lpclient->hdevInfo = NULL;

    }
    // !!! error case who frees the data?'

end:
    if (pclinfo)
        LocalUnlock (hclinfo);

    return;
}

void ChangeOwner (hmfp)
HANDLE hmfp;
{
    LPMETAFILEPICT  lpmfp;

    if (lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)) {
        if (bWin30)
            GiveToGDI (lpmfp->hMF);
        else {
            if (lpfnSetMetaFileBitsBetter)
                (*lpfnSetMetaFileBitsBetter) (lpmfp->hMF);
        }

        GlobalUnlock (hmfp);
    }
}


HANDLE INTERNAL MakeItemData (lpPoke, hPoke, cfFormat)
DDEPOKE FAR *   lpPoke;
HANDLE          hPoke;
OLECLIPFORMAT   cfFormat;
{
    HANDLE  hnew;
    LPSTR   lpnew;
    DWORD   dwSize;

    if (cfFormat == CF_METAFILEPICT)
        return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);

    if (cfFormat == CF_BITMAP)
        return DuplicateBitmap (*(LPHANDLE)lpPoke->Value);

    if (cfFormat == CF_DIB)
        return DuplicateData (*(LPHANDLE)lpPoke->Value);

    // Now we are dealing with normal case
    if (!(dwSize = GlobalSize (hPoke)))
        return NULL;

    dwSize = dwSize - sizeof (DDEPOKE) + sizeof(BYTE);

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpnew = GlobalLock (hnew)) {
            UtilMemCpy (lpnew, (LPSTR) lpPoke->Value, dwSize);
            GlobalUnlock (hnew);
        }
        else {
            GlobalFree (hnew);
            hnew = NULL;
        }
    }

    return hnew;
}



HANDLE INTERNAL DuplicateMetaFile (hSrcData)
HANDLE hSrcData;
{
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
        return NULL;

    GlobalUnlock (hSrcData);

    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
        return NULL;

    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
        goto errMfp;

    GlobalUnlock (hDstMfp);

    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = hMF;
    return hDstMfp;
errMfp:
    if (hMF)
        DeleteMetaFile (hMF);

    if (hDstMfp)
        GlobalFree (hDstMfp);

     return NULL;
}



HBITMAP INTERNAL DuplicateBitmap (hold)
HBITMAP     hold;
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }

    return hnew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*
\***************************************************************************/

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define SRVR_CLASS          ((LPSTR)"SrvrWndClass")
#define DOC_CLASS           ((LPSTR)"DocWndClass")
#define ITEM_CLASS          ((LPSTR)"ItemWndClass")


#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_LE         4       // signature
#define   WW_HANDLE     6       // instance handle

#define   WC_LE         0x4c45  // LE chars

// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0 
#define WRITE_ACCESS    1   

#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window 
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return OLE_ERROR_SERVER_BLOCKED;    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (retval == OLE_OK)                 \
        status |= 0x8000;                  \
    if (retval == OLE_BUSY)                \
        status |= 0x4000;                  \
}


typedef   LHSERVER         LHSRVR;
typedef   LHSERVERDOC       LHDOC;

typedef struct _QUE {   // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    unsigned    msg;        //      window 
    WORD        wParam;     //      procedure parameters
    LONG        lParam;     //***
    HANDLE      hqNext;     // handle to next node
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;


typedef struct _SRVR { /*srvr*/     // private data
    LPOLESERVER     lpolesrvr;          // corresponding server
    char            sig[2];             // signature "SR"
    HANDLE          hsrvr;              // global handle
    ATOM            aClass;             // class atom
    ATOM            aExe;
    HWND            hwnd;               // corresponding window
    BOOL            bTerminate;         // Set if we are terminating.
    int             termNo;             // termination count
    BOOL            relLock;            // ok to release the server.
    BOOL            bnoRelease;         // Block release. call
    WORD            useFlags;           // instance usage flags
    int             cClients;           // no of clients;
    BOOL            bBlock;             // blocked if TRUE 
    BOOL            bBlockedMsg;        // msg from block queue if TRUE
    HANDLE          hqHead;             // Head and tail of the blocked
    HANDLE          hqTail;             //   messages queue.

    HANDLE          hqPostHead;         // Head and tail of the blocked post msg
    HANDLE          hqPostTail;         // .
    BOOL            fAckExit;           
    HWND            hwndExit;
    HANDLE          hDataExit;
} SRVR;

typedef  SRVR FAR   *LPSRVR;


LONG    FAR  PASCAL DocWndProc (HWND, WORD, WORD, LONG);
LONG    FAR  PASCAL ItemWndProc (HWND, WORD, WORD, LONG);
LONG    FAR  PASCAL SrvrWndProc (HWND, WORD, WORD, LONG);
BOOL    FAR  PASCAL TerminateClients (HWND, LPSTR, HANDLE);
void                SendMsgToChildren (HWND, WORD, WORD, LONG);


OLESTATUS   INTERNAL    RequestDataStd (LONG, HANDLE FAR *);
BOOL        INTERNAL    ValidateSrvrClass (LPSTR, ATOM FAR *);
ATOM        INTERNAL    GetExeAtom (LPSTR);
BOOL        INTERNAL    AddClient (HWND, HANDLE, HANDLE);
BOOL        INTERNAL    DeleteClient (HWND, HANDLE);
HANDLE      INTERNAL    FindClient (HWND, HANDLE);
BOOL        INTERNAL    MakeSrvrStr(LPSTR, int, LPSTR, HANDLE);
int         INTERNAL    RevokeAllDocs (LPSRVR);
int         INTERNAL    ReleaseSrvr (LPSRVR);
void        INTERNAL    WaitForTerminate (LPSRVR);
OLESTATUS   INTERNAL    SrvrExecute (HWND, HANDLE, HWND);
BOOL        INTERNAL    HandleInitMsg (LPSRVR, LONG);
BOOL        INTERNAL    QueryRelease (LPSRVR);
BOOL        INTERNAL    IsSingleServerInstance (void);

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanBoolArg (LPSTR, BOOL FAR *);
LPSTR   INTERNAL    ScanNumArg (LPSTR, LPINT);
LPSTR   INTERNAL    ScanArg(LPSTR);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);


// doc stuff
typedef struct _DOC { /*doc*/       // private data
    LPOLESERVERDOC  lpoledoc;           // corresponding oledoc
    char            sig[2];             // signature "SD"
    HANDLE          hdoc;               // global handle
    ATOM            aDoc;
    HWND            hwnd;
    BOOL            bTerminate;
    int             termNo;
    int             cClients;           // no of clients;
    BOOL            fEmbed;             // TRUE if embedded document
    BOOL            fAckClose;
    HWND            hwndClose;
    HANDLE          hDataClose;
} DOC;

typedef  DOC  FAR   *LPDOC;


LPDOC       INTERNAL    FindDoc (LPSRVR, LPSTR);
int         INTERNAL    ReleaseDoc (LPDOC);
OLESTATUS   INTERNAL    DocExecute (HWND, HANDLE, HWND);
BOOL        FAR PASCAL  TerminateDocClients (HWND, LPSTR, HANDLE);
int         INTERNAL    DocShowItem (LPDOC, LPSTR, BOOL);
int         INTERNAL    DocDoVerbItem (LPDOC, LPSTR, WORD, BOOL, BOOL);


// client struct definitions.

typedef struct _CLIENT { /*doc*/    // private data
    OLECLIENT   oleClient;          // oleclient structure
    LPOLEOBJECT lpoleobject;        // corresponding oledoc
    HANDLE      hclient;            // global handle
    ATOM        aItem;              // item atom or index for some std items
    HWND        hwnd;               // item window
    HANDLE      hdevInfo;           // latest printer dev info sent
} CLIENT;

typedef  CLIENT FAR   *LPCLIENT;

typedef struct _CLINFO { /*clInfo*/ // client transaction info
    HWND        hwnd;               // client window handle
    BOOL        bnative;            // doe sthis client require native
    int         format;             // dusplay format
    int         options;            // transaction advise time otipns
    BOOL        bdata;              // need wdat with advise?
    HANDLE      hdevInfo;           // device info handle
    BOOL        bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;




BOOL    FAR PASCAL  FindItemWnd (HWND, LONG);
BOOL    FAR PASCAL  SendRenameMsg (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  EnumForTerminate (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  SendDataMsg(HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  DeleteClientInfo (HWND, LPSTR, HANDLE);
int     FAR PASCAL  ItemCallBack (LPOLECLIENT, int, LPOLEOBJECT);

int         INTERNAL    RegisterItem (LHDOC, LPSTR, LPCLIENT FAR *, BOOL);
int         INTERNAL    FindItem (LPDOC, LPSTR, LPCLIENT FAR *);
HWND        INTERNAL    SearchItem (LPDOC, LPSTR);
void        INTERNAL    DeleteFromItemsList (HWND, HWND);
void        INTERNAL    DeleteAllItems (HWND);
OLESTATUS   INTERNAL    PokeData (LPDOC, HWND, LONG);
HANDLE      INTERNAL    MakeItemData (DDEPOKE FAR *, HANDLE, OLECLIPFORMAT);
OLESTATUS   INTERNAL    AdviseData (LPDOC, HWND, LONG, BOOL FAR *);
OLESTATUS   INTERNAL    AdviseStdItems (LPDOC, HWND, LONG, BOOL FAR *);
OLESTATUS   INTERNAL    UnAdviseData (LPDOC, HWND, LONG);
OLESTATUS   INTERNAL    RequestData (LPDOC, HWND, LONG, HANDLE FAR *);
BOOL        INTERNAL    MakeDDEData (HANDLE, int, LPHANDLE, BOOL);
HANDLE      INTERNAL    MakeGlobal (LPSTR);
int         INTERNAL    ScanItemOptions (LPSTR, int far *);
OLESTATUS   INTERNAL    PokeStdItems (LPDOC, HWND, LONG);
int         INTERNAL    GetStdItemIndex (ATOM);
BOOL        INTERNAL    IsAdviseStdItems (ATOM);
int         INTERNAL    SetStdInfo (LPDOC, HWND, LPSTR, HANDLE);
void        INTERNAL    SendDevInfo (LPCLIENT, LPSTR);
BOOL        INTERNAL    IsFormatAvailable (LPCLIENT, OLECLIPFORMAT);
OLESTATUS   INTERNAL    RevokeObject (LPOLECLIENT, BOOL);


BOOL        INTERNAL    AddMessage (HWND, unsigned, WORD, LONG, int);

#define   ITEM_FIND          1      // find the item
#define   ITEM_DELETECLIENT  2      // delete the client from item clients
#define   ITEM_DELETE        3      // delete th item window itself
#define   ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanLastBoolArg (LPSTR);
LPSTR   INTERNAL    ScanArg(LPSTR);
WORD    INTERNAL    ScanCommand(LPSTR, WORD, LPSTR FAR *, ATOM FAR *);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);
WORD    INTERNAL    StrToInt (LPSTR);
BOOL    INTERNAL    CheckServer (LPSRVR);
BOOL    INTERNAL    CheckServerDoc (LPDOC);
BOOL    INTERNAL    PostMessageToClientWithBlock (HWND, WORD, WORD, DWORD);
BOOL    INTERNAL    PostMessageToClient (HWND, WORD, WORD, DWORD);
BOOL    INTERNAL    IsWindowValid (HWND);
BOOL    INTERNAL    IsOleCommand (ATOM, WORD);
BOOL    INTERNAL    UtilQueryProtocol (ATOM, LPSTR);


// routines for queueing messages and posting them
BOOL INTERNAL  UnblockPostMsgs(HWND, BOOL);
BOOL INTERNAL  BlockPostMsg (HWND, WORD, WORD, LONG);
BOOL INTERNAL  IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
HANDLE  FAR PASCAL   GiveToGDI (HANDLE);


// routine in item.c
HBITMAP INTERNAL DuplicateBitmap (HBITMAP);
HANDLE  INTERNAL DuplicateMetaFile (HANDLE);

// routines in doc.c
void    INTERNAL FreePokeData (HANDLE);
BOOL    INTERNAL FreeGDIdata (HANDLE, OLECLIPFORMAT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "cmacs.h"
#include <shellapi.h>

#include "ole.h"
#include "dde.h"
#include "srvr.h"


#ifndef HUGE
#define HUGE    huge
#endif

#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;
extern BOOL    bWLO;
extern BOOL    bWin30;

extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;

extern BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// MapToHexStr: Converts  WORD to hex string.
void INTERNAL MapToHexStr (lpbuf, hdata)
LPSTR       lpbuf;
HANDLE      hdata;
{
    int     i;
    char    ch;

    *lpbuf++ = '@';
    for ( i = 3; i >= 0; i--) {

        ch = (char) ((((WORD)hdata) >> (i * 4)) & 0x000f);
        if(ch > '9')
            ch += 'A' - 10;
        else
            ch += '0';

        *lpbuf++ = ch;
    }

    *lpbuf++ = NULL;

}


void INTERNAL UtilMemCpy (lpdst, lpsrc, dwCount)
LPSTR   lpdst;
LPSTR   lpsrc;
DWORD   dwCount;
{
    WORD HUGE * hpdst;
    WORD HUGE * hpsrc;
    WORD FAR  * lpwDst;
    WORD FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwDst = (WORD FAR *) lpdst;
        lpwSrc = (WORD FAR *) lpsrc;
        
        while (words--) 
            *lpwDst++ = *lpwSrc++;

        if (bytes) 
            * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else {
        hpdst = (WORD HUGE *) lpdst;
        hpsrc = (WORD HUGE *) lpsrc;
    
        while (words--) 
            *hpdst++ = *hpsrc++;

        if (bytes) 
            *(char HUGE *) hpdst = * (char HUGE *) hpsrc;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE  INTERNAL    DuplicateData (hdata)
HANDLE  hdata;
{
    LPSTR   lpsrc = NULL;
    LPSTR   lpdst = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;
    
    if(!(lpsrc =  GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, (size = GlobalSize(hdata)));

    if(!(lpdst =  GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);
    
errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup)
        GlobalFree (hdup);

    return hdup;
}


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

LPSTR   INTERNAL    ScanBoolArg (lpstr, lpflag)
LPSTR   lpstr;
BOOL    FAR *lpflag;
{


    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(ch == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
        if (*lpstr++ != ']')
            return NULL;

        if(*lpstr != NULL)
            return NULL;             //finally should be terminated by null.

    }

    aShow = GlobalFindAtom (lpbool);
    if (aShow == aTrue)
        *lpflag = TRUE;

    else {
        if (aShow ==aFalse)
            *lpflag = FALSE;
        else
            return NULL;;
    }
    return lpstr;
}




//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

LPSTR   INTERNAL    ScanNumArg (lpstr, lpnum)
LPSTR   lpstr;
LPINT   lpnum;
{

    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
        if (ch < '0' || ch >'9')
            return NULL;
        val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

LPSTR   INTERNAL    ScanArg (lpstr)
LPSTR   lpstr;
{


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
        return NULL;

    while(*lpstr && *lpstr != '\"')
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(*lpstr == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
        return NULL;


    if(*lpstr++ == ','){

        if(*lpstr == '\"')
            return ++lpstr;
        // If it is not quote, leave the ptr on the first char
        return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
        return NULL;

    if(*lpstr != NULL)
        return NULL;             //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

WORD INTERNAL  ScanCommand (lpstr, wType, lplpnextcmd, lpAtom)
LPSTR       lpstr;
WORD        wType;
LPSTR FAR * lplpnextcmd;
ATOM FAR *  lpAtom;
{
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;
    

    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(*lpstr == NULL)
       return NULL;

    ch = *lpstr;
    *lpstr++ = NULL;       // set the end of command

    *lpAtom = GlobalFindAtom (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
        return NON_OLE_COMMAND;
    
    if (ch == '(') {

#if	defined(FE_SB)						//[J1]
	ch = *lpstr;						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        ch = *lpstr++;
#endif								//[J1]

        if (ch == ')') {
             if (*lpstr++ != ']')
                return NULL;
        } 
        else {
            if (ch != '\"')
                return NULL;
        }
        
        *lplpnextcmd = lpstr;
        return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
        return NULL;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

ATOM INTERNAL MakeDataAtom (aItem, options)
ATOM    aItem;
int     options;
{
    char    buf[MAX_STR];

    if (options == OLE_CHANGED)
        return DuplicateAtom (aItem);

    if (!aItem)
        buf[0] = NULL;
    else
        GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);

    if (options == OLE_CLOSED)
        lstrcat ((LPSTR)buf, (LPSTR) "/Close");
    else {
        if (options == OLE_SAVED)
           lstrcat ((LPSTR)buf, (LPSTR) "/Save");
    }

    if (buf[0])
        return GlobalAddAtom ((LPSTR)buf);
    else
        return NULL;
}

//DuplicateAtom: Duplicates an atom
ATOM INTERNAL DuplicateAtom (atom)
ATOM    atom;
{
    char buf[MAX_STR];

    Puts ("DuplicateAtom");

    if (!atom)
        return NULL;
    
    GlobalGetAtomName (atom, buf, MAX_STR);
    return GlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

HANDLE  INTERNAL MakeGlobal (lpstr)
LPSTR   lpstr;
{

    int     len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = lstrlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
        goto errRtn;


    UtilMemCpy (lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:

    if (lpdata)
        GlobalUnlock (hdata);


    if (hdata)
        GlobalFree (hdata);

     return NULL;

}



BOOL INTERNAL CheckServer (lpsrvr)
LPSRVR  lpsrvr;
{
    if (!CheckPointer(lpsrvr, WRITE_ACCESS))
        return FALSE;

    if ((lpsrvr->sig[0] == 'S') && (lpsrvr->sig[1] == 'R'))
        return TRUE;
    
    return FALSE;
}


BOOL INTERNAL CheckServerDoc (lpdoc)
LPDOC   lpdoc;
{
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->sig[0] == 'S') && (lpdoc->sig[1] == 'D'))
        return TRUE;
    
    return FALSE;
}


BOOL INTERNAL PostMessageToClientWithBlock (hWnd, wMsg, wParam, lParam)
HWND    hWnd;
WORD    wMsg;
WORD    wParam;
DWORD   lParam;
{
    if (!IsWindowValid (hWnd)) {
        ASSERT(FALSE, "Client's window is missing");
        return FALSE;
    }
    
    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
        return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}



BOOL INTERNAL PostMessageToClient (hWnd, wMsg, wParam, lParam)
HWND    hWnd;
WORD    wMsg;
WORD    wParam;
DWORD   lParam;
{
    if (!IsWindowValid (hWnd)) {
        ASSERT(FALSE, "Client's window is missing");
        return FALSE;
    }

    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
        return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}


BOOL    INTERNAL IsWindowValid (hwnd)
HWND    hwnd;
{

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    if (bWLO) 
        return TRUE;

    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

    if (bWin30 || !lpfnIsTask) {
        lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

        if (!CheckPointer(lptask, READ_ACCESS))
            return FALSE;

        // now check for the signature bytes of task block in kernel
        if (*lptask++ == 'T' && *lptask == 'D')
            return TRUE;
    }
    else {
        // From win31 onwards the API IsTask() can be used for task validation
        if ((*lpfnIsTask)(htask))
            return TRUE;
    }
    
    return FALSE;
}



BOOL INTERNAL UtilQueryProtocol (aClass, lpprotocol)
ATOM    aClass;
LPSTR   lpprotocol;
{
    HKEY    hKey;
    char    key[MAX_STR];
    char    class[MAX_STR];

    if (!aClass)
        return FALSE;
    
    if (!GlobalGetAtomName (aClass, class, MAX_STR))
        return FALSE;
    
    lstrcpy (key, class);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegOpenKey (HKEY_CLASSES_ROOT, key, &hKey))
        return FALSE;
    
    RegCloseKey (hKey);     
    return TRUE;
}


BOOL INTERNAL IsOleCommand (aCmd, wType)
ATOM    aCmd;
WORD    wType;
{
    if (wType == WT_SRVR) {
        if ((aCmd == aStdCreateFromTemplate)
                || (aCmd == aStdCreate)
                || (aCmd == aStdOpen)
                || (aCmd == aStdEdit)               
                || (aCmd == aStdShowItem)
                || (aCmd == aStdClose)
                || (aCmd == aStdExit))
            return TRUE;
    }
    else {
        if ((aCmd == aStdClose)
                || (aCmd == aStdDoVerbItem)
                || (aCmd == aStdShowItem))
            return TRUE;
    }
    
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\srvrmain.c ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/

#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

#ifndef WF_WLO  
#define WF_WLO  0x8000
#endif

// ordinal number of new Win31 API IsTask
#define ORD_IsTask  320

// ordinal number of new Win31 API SetMetaFileBitsBetter
#define ORD_SetMetaFileBitsBetter   196


#ifdef  FIREWALLS
short   ole_flags;
char    szDebugBuffer[80];
void    SetOleFlags(void);
#endif


// public vars.

// atomes used in the systems
ATOM    aStdExit;                      // "StdExit"
ATOM    aStdCreate;                    // "StdNewDicument"
ATOM    aStdOpen;                      // "StdOpenDocument"
ATOM    aStdEdit;                      // "StdOpenDocument"
ATOM    aStdCreateFromTemplate;        // "StdNewFromTemplate"
ATOM    aStdClose;                     // "StdCloseDocument"
ATOM    aStdShowItem;                  // "StdShowItem"
ATOM    aStdDoVerbItem;                // "StddoVerbItem"
ATOM    aSysTopic;                     // "System"
ATOM    aOLE;                          // "OLE"
ATOM    aStdDocName;                   // "StdDocumentName"

ATOM    cfBinary;                      // "Binary format"
ATOM    cfNative;                      // "NativeFormat"
ATOM    cfLink;                        // "ObjectLink"
ATOM    cfOwnerLink;                   // "Ownerlink"

ATOM    aChange;                       // "Change"
ATOM    aSave;                         // "Save"
ATOM    aClose;                        // "Close"
ATOM    aProtocols;                    // "Protocols"
ATOM    aTopics;                       // "Topics"
ATOM    aFormats;                      // "Formats"
ATOM    aStatus;                       // "Status"
ATOM    aEditItems;                    // "Edit items
ATOM    aTrue;                         // "True"
ATOM    aFalse;                        // "False"





// !!! free the proc instances.
FARPROC lpSendRenameMsg;               // Call back enum props for rename
FARPROC lpSendDataMsg;                 // Call back enum props for data
FARPROC lpFindItemWnd;                 // Callback in enum props of
FARPROC lpItemCallBack;                // CallBack for object
FARPROC lpTerminateClients;            // Callback in Doc enum properties
FARPROC lpTerminateDocClients;         // Callback in Doc enum properties
FARPROC lpDeleteClientInfo;            // proc for deleteing each item client
FARPROC lpEnumForTerminate;            // proc for terminating clients not in rename list

FARPROC lpfnSetMetaFileBitsBetter = NULL;
FARPROC lpfnIsTask = NULL;

HANDLE  hdllInst;
BOOL    bProtMode;
BOOL    bWLO = FALSE;
BOOL    bWin30 = FALSE;

VOID FAR PASCAL WEP (int);
#pragma alloc_text(WEP_TEXT, WEP)

int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
HANDLE  hInst;
WORD    wDataSeg;
WORD    cbHeapSize;
LPSTR   lpszCmdLine;
{
    WNDCLASS  wc;

    Puts("LibMain");

#ifdef  FIREWALLS
    SetOleFlags();
#endif

    hdllInst = hInst;

    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE & 0x0000FFFF);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);    
    bWin30    = (!bWLO && ((WORD) GetVersion()) <= 0x0003);
        
    // !!! Put all this stuff thru soemkind of table so that we can
    // save code.

    // register all the atoms.
    aStdExit                = GlobalAddAtom ((LPSTR)"StdExit");
    aStdCreate              = GlobalAddAtom ((LPSTR)"StdNewDocument");
    aStdOpen                = GlobalAddAtom ((LPSTR)"StdOpenDocument");
    aStdEdit                = GlobalAddAtom ((LPSTR)"StdEditDocument");
    aStdCreateFromTemplate  = GlobalAddAtom ((LPSTR)"StdNewfromTemplate");

    aStdClose               = GlobalAddAtom ((LPSTR)"StdCloseDocument");
    aStdShowItem            = GlobalAddAtom ((LPSTR)"StdShowItem");
    aStdDoVerbItem          = GlobalAddAtom ((LPSTR)"StdDoVerbItem");
    aSysTopic               = GlobalAddAtom ((LPSTR)"System");
    aOLE                    = GlobalAddAtom ((LPSTR)"OLEsystem");
    aStdDocName             = GlobalAddAtom ((LPSTR)"StdDocumentName");

    aProtocols              = GlobalAddAtom ((LPSTR)"Protocols");
    aTopics                 = GlobalAddAtom ((LPSTR)"Topics");
    aFormats                = GlobalAddAtom ((LPSTR)"Formats");
    aStatus                 = GlobalAddAtom ((LPSTR)"Status");
    aEditItems              = GlobalAddAtom ((LPSTR)"EditEnvItems");

    aTrue                   = GlobalAddAtom ((LPSTR)"True");
    aFalse                  = GlobalAddAtom ((LPSTR)"False");

    aChange                 = GlobalAddAtom ((LPSTR)"Change");
    aSave                   = GlobalAddAtom ((LPSTR)"Save");
    aClose                  = GlobalAddAtom ((LPSTR)"Close");

    // create the proc instances for the required entry pts.
    lpSendRenameMsg         = MakeProcInstance (SendRenameMsg, hdllInst);
    lpSendDataMsg           = MakeProcInstance (SendDataMsg, hdllInst);
    lpFindItemWnd           = MakeProcInstance (FindItemWnd, hdllInst);
    lpItemCallBack          = MakeProcInstance (ItemCallBack, hdllInst);
    lpTerminateClients      = MakeProcInstance (TerminateClients, hdllInst);
    lpTerminateDocClients   = MakeProcInstance (TerminateDocClients, hdllInst);
    lpDeleteClientInfo      = MakeProcInstance (DeleteClientInfo, hdllInst);
    lpEnumForTerminate      = MakeProcInstance (EnumForTerminate , hdllInst);

    // register the clipboard formats
    cfNative                = RegisterClipboardFormat("Native");
    cfBinary                = RegisterClipboardFormat("Binary");
    cfLink                  = RegisterClipboardFormat("ObjectLink");
    cfOwnerLink             = RegisterClipboardFormat("OwnerLink");



    wc.style        = NULL;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG) +     //Ask for extra space for storing the
                                        //ptr to srvr/doc/iteminfo.
                      sizeof (WORD) +   // for LE chars
                      sizeof (WORD);    // for keeping the hDLLInst.

    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;


    // Srvr window class
    wc.lpfnWndProc  = SrvrWndProc;
    wc.lpszClassName= SRVR_CLASS;
    if (!RegisterClass(&wc))
         return 0;

    // document window class
    wc.lpfnWndProc = DocWndProc;
    wc.lpszClassName = DOC_CLASS;

    if (!RegisterClass(&wc))
        return 0;

    // Item (object) window class
    wc.lpfnWndProc = ItemWndProc;
    wc.lpszClassName = ITEM_CLASS;

    wc.cbWndExtra   = sizeof(LONG); // for items do not need extra stuff.
    if (!RegisterClass(&wc))
        return 0;


    if (!bWin30) {
        HANDLE  hModule;
        
        if (hModule = GetModuleHandle ("GDI")) 
            lpfnSetMetaFileBitsBetter 
                = GetProcAddress (hModule,
                        (LPSTR) MAKELONG(ORD_SetMetaFileBitsBetter, 0));
                                   
        if (hModule = GetModuleHandle ("KERNEL")) 
            lpfnIsTask 
                = GetProcAddress (hModule, (LPSTR) MAKELONG(ORD_IsTask, 0));
    }
    
    if (cbHeapSize != 0)
        UnlockData(0);

    return 1;
}


VOID FAR PASCAL WEP (nParameter)
int nParameter;
{

    Puts("LibExit");

    if (nParameter == WEP_SYSTEM_EXIT)
        DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)

    else {
        if (nParameter == WEP_FREE_DLL)
            DEBUG_OUT ("---L&E DLL EXIT---",0)

        else
            return;
    }

    // free the global atoms.
    if (aStdExit)
        GlobalDeleteAtom (aStdExit);
    if (aStdCreate)
        GlobalDeleteAtom (aStdCreate);
    if (aStdOpen)
        GlobalDeleteAtom (aStdOpen);
    if (aStdEdit)
        GlobalDeleteAtom (aStdEdit);
    if (aStdCreateFromTemplate)
        GlobalDeleteAtom (aStdCreateFromTemplate);
    if (aStdClose)
        GlobalDeleteAtom (aStdClose);
    if (aStdShowItem)
        GlobalDeleteAtom (aStdShowItem);
    if (aStdDoVerbItem)
        GlobalDeleteAtom (aStdDoVerbItem);
    if (aSysTopic)
        GlobalDeleteAtom (aSysTopic);
    if (aOLE)
        GlobalDeleteAtom (aOLE);
    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);

    if (aProtocols)
        GlobalDeleteAtom (aProtocols);
    if (aTopics)
        GlobalDeleteAtom (aTopics);
    if (aFormats)
        GlobalDeleteAtom (aFormats);
    if (aStatus)
        GlobalDeleteAtom (aStatus);
    if (aEditItems)
        GlobalDeleteAtom (aEditItems);

    if (aTrue)
        GlobalDeleteAtom (aTrue);
    if (aFalse)
        GlobalDeleteAtom (aFalse);

    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aClose)
        GlobalDeleteAtom (aClose);

    // !!! for some reason these FreeprocInstances are crashing the system.
#if 0
    FreeProcInstance (lpSendRenameMsg);
    FreeProcInstance (lpSendDataMsg);
    FreeProcInstance (lpFindItemWnd);
    FreeProcInstance (lpItemCallBack);
    FreeProcInstance (lpTerminateClients);
    FreeProcInstance (lpTerminateDocClients);
    FreeProcInstance (lpDeleteClientInfo);
    FreeProcInstance (EnumForTerminate);
#endif

}



#ifdef  FIREWALLS
void SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OleDll",
        "Puts","", (LPSTR)buffer, 80))
        ole_flags = DEBUG_PUTS;
    else
        ole_flags = 0;


    if(GetProfileString ("OleDll",
        "DEBUG_OUT","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_DEBUG_OUT;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\server\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\ras.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external Win16 API
** Public header for external Win16 API clients
**
** Note: The 'dwSize' member of a data structure X must be set to sizeof(X)
**       before calling the associated API, otherwise ERROR_INVALID_SIZE is
**       returned.  The value expected by the API is listed next to each
**       'dwSize' member.
*/

#ifndef _RAS_H_
#define _RAS_H_

#ifndef RC_INVOKED
#pragma pack(2)
#endif

#ifndef NETCONS_INCLUDED
#define UNLEN 20
#define PWLEN 14
#define DNLEN 15
#endif

#ifndef APIENTRY
#define APIENTRY FAR PASCAL
#endif

#ifndef CHAR
#define CHAR char
#endif

#ifndef UINT
#define UINT unsigned int
#endif


#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxDeviceType     16
#define RAS_MaxParamKey       32
#define RAS_MaxParamValue     128
#define RAS_MaxPhoneNumber    128
#define RAS_MaxCallbackNumber 48


#define HRASCONN   const void far*
#define LPHRASCONN HRASCONN FAR*


/* Pass this string to the RegisterWindowMessage() API to get the message
** number that will be used for notifications on the hwnd you pass to the
** RasDial() API.  WM_RASDIALEVENT is used only if a unique message cannot be
** registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD


/* Identifies an active RAS connection.  (See RasConnectEnum)
*/
#define RASCONN struct tagRASCONN

RASCONN
{
    DWORD    dwSize;  /* 30 */
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASCONN RASCONN FAR*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE

RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE FAR*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUS struct tagRASCONNSTATUS

RASCONNSTATUS
{
    DWORD        dwSize;  /* 60 */
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define LPRASCONNSTATUS RASCONNSTATUS FAR*


/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMS struct tagRASDIALPARAMS

RASDIALPARAMS
{
    DWORD dwSize;  /* 256 */
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define LPRASDIALPARAMS RASDIALPARAMS FAR*


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAME struct tagRASENTRYNAME

RASENTRYNAME
{
    DWORD dwSize;  /* 26 */
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASENTRYNAME RASENTRYNAME FAR*


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDial( LPSTR, LPSTR, LPRASDIALPARAMS, LPVOID, HWND,
                   LPHRASCONN );

DWORD APIENTRY RasEnumConnections( LPRASCONN, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntries( LPSTR, LPSTR, LPRASENTRYNAME, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatus( HRASCONN, LPRASCONNSTATUS );

DWORD APIENTRY RasGetErrorString( UINT, LPSTR, DWORD );

DWORD APIENTRY RasHangUp( HRASCONN );


#ifndef RC_INVOKED
#pragma pack()
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\bseerr.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSEERR.H
*       
*      Copy of the Lanman BSEERR.H used for their base error codes.
*      Not used by anyone else.
*
\***************************************************************************/

#ifndef BSEERR_INCLUDED
#define BSEERR_INCLUDED

#define NO_ERROR			0
#define ERROR_INVALID_FUNCTION		1
#define ERROR_FILE_NOT_FOUND		2
#define ERROR_PATH_NOT_FOUND		3
#define ERROR_TOO_MANY_OPEN_FILES	4
#define ERROR_ACCESS_DENIED		5
#define ERROR_INVALID_HANDLE		6
#define ERROR_ARENA_TRASHED		7
#define ERROR_NOT_ENOUGH_MEMORY 	8
#define ERROR_INVALID_BLOCK		9
#define ERROR_BAD_ENVIRONMENT		10
#define ERROR_BAD_FORMAT		11
#define ERROR_INVALID_ACCESS		12
#define ERROR_INVALID_DATA		13
/* 14 is reserved			 */
#define ERROR_INVALID_DRIVE		15
#define ERROR_CURRENT_DIRECTORY 	16
#define ERROR_NOT_SAME_DEVICE		17
#define ERROR_NO_MORE_FILES		18
#define ERROR_WRITE_PROTECT		19
#define ERROR_BAD_UNIT			20
#define ERROR_NOT_READY 		21
#define ERROR_BAD_COMMAND		22
#define ERROR_CRC			23
#define ERROR_BAD_LENGTH		24
#define ERROR_SEEK			25
#define ERROR_NOT_DOS_DISK		26
#define ERROR_SECTOR_NOT_FOUND		27
#define ERROR_OUT_OF_PAPER		28
#define ERROR_WRITE_FAULT		29
#define ERROR_READ_FAULT		30
#define ERROR_GEN_FAILURE		31
#define ERROR_SHARING_VIOLATION 	32
#define ERROR_LOCK_VIOLATION		33
#define ERROR_WRONG_DISK		34
#define ERROR_FCB_UNAVAILABLE		35
#define ERROR_SHARING_BUFFER_EXCEEDED	36
#define ERROR_NOT_SUPPORTED		50
#define ERROR_REM_NOT_LIST		51 /* Remote computer not listening   */
#define ERROR_DUP_NAME			52 /* Duplicate name on network       */
#define ERROR_BAD_NETPATH		53 /* Network path not found	      */
#define ERROR_NETWORK_BUSY		54 /* Network busy		      */
#define ERROR_DEV_NOT_EXIST		55 /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS		56 /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR		57 /* Network adapter hardware error  */
#define ERROR_BAD_NET_RESP		58 /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR		59 /* Unexpected network error	      */
#define ERROR_BAD_REM_ADAP		60 /* Incompatible remote adapter     */
#define ERROR_PRINTQ_FULL		61 /* Print queue full		      */
#define ERROR_NO_SPOOL_SPACE		62 /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED		63 /* Print file was cancelled	      */
#define ERROR_NETNAME_DELETED		64 /* Network name was deleted	      */
#define ERROR_NETWORK_ACCESS_DENIED	65 /* Access denied		      */
#define ERROR_BAD_DEV_TYPE		66 /* Network device type incorrect   */
#define ERROR_BAD_NET_NAME		67 /* Network name not found	      */
#define ERROR_TOO_MANY_NAMES		68 /* Network name limit exceeded     */
#define ERROR_TOO_MANY_SESS		69 /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED		70 /* Sharing temporarily paused      */
#define ERROR_REQ_NOT_ACCEP		71 /* Network request not accepted    */
#define ERROR_REDIR_PAUSED		72 /* Print|disk redirection is paused*/
#define ERROR_FILE_EXISTS		80
#define ERROR_DUP_FCB			81
#define ERROR_CANNOT_MAKE		82
#define ERROR_FAIL_I24			83
#define ERROR_OUT_OF_STRUCTURES 	84
#define ERROR_ALREADY_ASSIGNED		85
#define ERROR_INVALID_PASSWORD		86
#define ERROR_INVALID_PARAMETER 	87
#define ERROR_NET_WRITE_FAULT		88
#define ERROR_NO_PROC_SLOTS		89 /* no process slots available      */
#define ERROR_NOT_FROZEN		90
#define ERR_TSTOVFL			91 /* timer service table overflow    */
#define ERR_TSTDUP			92 /* timer service table duplicate   */
#define ERROR_NO_ITEMS			93 /* no items to operate upon	      */
#define ERROR_INTERRUPT 		95 /* interrupted system call	      */
#define ERROR_DEVICE_IN_USE		99 /* Device in use by another thread */
#define ERROR_TOO_MANY_SEMAPHORES	100
#define ERROR_EXCL_SEM_ALREADY_OWNED	101
#define ERROR_SEM_IS_SET		102
#define ERROR_TOO_MANY_SEM_REQUESTS	103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED		105 /* waitsem found owner died       */
#define ERROR_SEM_USER_LIMIT		106 /* too many procs have this sem   */
#define ERROR_DISK_CHANGE		107
#define ERROR_DRIVE_LOCKED		108 /* drive locked by another process*/
#define ERROR_BROKEN_PIPE		109 /* write on pipe with no reader   */
#define ERROR_OPEN_FAILED		110 /* open/created failed due to     */
                                            /* explicit fail command          */
#define ERROR_BUFFER_OVERFLOW		111 /* buffer passed to system call   */
                                            /* is too small to hold return    */
                                            /* data.                          */
#define ERROR_DISK_FULL 		112 /* not enough space on the disk   */
                                            /* (DOSNEWSIZE/w_NewSize)         */
#define ERROR_NO_MORE_SEARCH_HANDLES	113 /* can't allocate another search  */
                                            /* structure and handle.          */
                                            /* (DOSFINDFIRST/w_FindFirst)     */
#define ERROR_INVALID_TARGET_HANDLE	114 /* Target handle in DOSDUPHANDLE  */
                                            /* is invalid                     */
#define ERROR_PROTECTION_VIOLATION	115 /* Bad user virtual address       */
#define ERROR_VIOKBD_REQUEST		116
#define ERROR_INVALID_CATEGORY		117 /* Category for DEVIOCTL in not   */
                                            /* defined                        */
#define ERROR_INVALID_VERIFY_SWITCH	118 /* invalid value passed for       */
                                            /* verify flag                    */
#define ERROR_BAD_DRIVER_LEVEL		119 /* DosDevIOCTL looks for a level  */
                                            /* four driver. If the driver     */
                                            /* is not level four we return    */
                                            /* this code                      */
#define ERROR_CALL_NOT_IMPLEMENTED	120 /* returned from stub api calls.  */
                                            /* This call will disappear when  */
                                            /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT		121 /* Time out happened from the     */
                                            /* semaphore api functions.       */
#define ERROR_INSUFFICIENT_BUFFER	122 /* Some calls require the	      */
                                       /* application to pass in a buffer     */
                                       /* filled with data.  This error is    */
                                       /* returned if the data buffer is too  */
                                       /* small.  For example: DosSetFileInfo */
                                       /* requires 4 bytes of data.  If a     */
                                       /* two byte buffer is passed in then   */
                                       /* this error is returned.             */
                                       /* error_buffer_overflow is used when  */
                                       /* the output buffer in not big enough.*/
#define ERROR_INVALID_NAME		123 /* illegal character or malformed */
                                            /* file system name               */
#define ERROR_INVALID_LEVEL		124 /* unimplemented level for info   */
                                            /* retrieval or setting           */
#define ERROR_NO_VOLUME_LABEL		125 /* no volume label found with     */
                                            /* DosQFSInfo command             */
#define ERROR_MOD_NOT_FOUND		126 /* w_getprocaddr,w_getmodhandle   */
#define ERROR_PROC_NOT_FOUND		127 /* w_getprocaddr		      */
#define ERROR_WAIT_NO_CHILDREN		128 /* CWait finds to children	      */
#define ERROR_CHILD_NOT_COMPLETE	129 /* CWait children not dead yet    */
#define ERROR_DIRECT_ACCESS_HANDLE	130 /* handle operation is invalid    */
                                            /* for direct disk access         */
                                            /* handles                        */
#define ERROR_NEGATIVE_SEEK		131 /* application tried to seek      */
                                            /* with negitive offset           */
#define ERROR_SEEK_ON_DEVICE		132 /* application tried to seek      */
                                            /* on device or pipe              */
#define ERROR_IS_JOIN_TARGET		133
#define ERROR_IS_JOINED 		134
#define ERROR_IS_SUBSTED		135
#define ERROR_NOT_JOINED		136
#define ERROR_NOT_SUBSTED		137
#define ERROR_JOIN_TO_JOIN		138
#define ERROR_SUBST_TO_SUBST		139
#define ERROR_JOIN_TO_SUBST		140
#define ERROR_SUBST_TO_JOIN		141
#define ERROR_BUSY_DRIVE		142
#define ERROR_SAME_DRIVE		143
#define ERROR_DIR_NOT_ROOT		144
#define ERROR_DIR_NOT_EMPTY		145
#define ERROR_IS_SUBST_PATH		146
#define ERROR_IS_JOIN_PATH		147
#define ERROR_PATH_BUSY 		148
#define ERROR_IS_SUBST_TARGET		149
#define ERROR_SYSTEM_TRACE		150 /* system trace error	      */
#define ERROR_INVALID_EVENT_COUNT	151 /* DosMuxSemWait errors	      */
#define ERROR_TOO_MANY_MUXWAITERS	152
#define ERROR_INVALID_LIST_FORMAT	153
#define ERROR_LABEL_TOO_LONG		154
#define ERROR_TOO_MANY_TCBS		155
#define ERROR_SIGNAL_REFUSED		156
#define ERROR_DISCARDED 		157
#define ERROR_NOT_LOCKED		158
#define ERROR_BAD_THREADID_ADDR 	159
#define ERROR_BAD_ARGUMENTS		160
#define ERROR_BAD_PATHNAME		161
#define ERROR_SIGNAL_PENDING		162
#define ERROR_UNCERTAIN_MEDIA		163
#define ERROR_MAX_THRDS_REACHED 	164
#define ERROR_MONITORS_NOT_SUPPORTED	165
#define ERROR_UNC_DRIVER_NOT_INSTALLED	166

/*	The following error codes refer to demand loading segments     */
#define ERROR_LOCK_FAILED		167
#define ERROR_SWAPIO_FAILED		168
#define ERROR_SWAPIN_FAILED		169
#define ERROR_BUSY			170

#define ERROR_INVALID_SEGMENT_NUMBER	180
#define ERROR_INVALID_CALLGATE		181
#define ERROR_INVALID_ORDINAL		182
#define ERROR_ALREADY_EXISTS		183
#define ERROR_NO_CHILD_PROCESS		184
#define ERROR_CHILD_ALIVE_NOWAIT	185
#define ERROR_INVALID_FLAG_NUMBER	186
#define ERROR_SEM_NOT_FOUND		187

/* following error codes make loader error messages distinct  */
#define ERROR_INVALID_STARTING_CODESEG	188
#define ERROR_INVALID_STACKSEG		189
#define ERROR_INVALID_MODULETYPE	190
#define ERROR_INVALID_EXE_SIGNATURE	191
#define ERROR_EXE_MARKED_INVALID	192
#define ERROR_BAD_EXE_FORMAT		193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE	195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED		197
#define ERROR_INVALID_SEGDPL		198
#define ERROR_AUTODATASEG_EXCEEDS_64k	199
#define ERROR_RING2SEG_MUST_BE_MOVABLE	200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM	201
#define ERROR_INFLOOP_IN_RELOC_CHAIN	202
#define ERROR_ENVVAR_NOT_FOUND		203
#define ERROR_NOT_CURRENT_CTRY		204
#define ERROR_NO_SIGNAL_SENT		205
#define ERROR_FILENAME_EXCED_RANGE	206 /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE	207 /* for FAPI 	 */
#define ERROR_META_EXPANSION_TOO_LONG	208 /* if "*a" > 8.3	 */
#define ERROR_INVALID_SIGNAL_NUMBER	209
#define ERROR_THREAD_1_INACTIVE 	210
#define ERROR_INFO_NOT_AVAIL		211
#define ERROR_LOCKED			212
#define ERROR_BAD_DYNALINK		213
#define ERROR_TOO_MANY_MODULES		214
#define ERROR_NESTING_NOT_ALLOWED	215
#define ERROR_CANNOT_SHRINK		216 /* attempt to shrink ring 2 stack */
#define ERROR_ZOMBIE_PROCESS		217
#define ERROR_STACK_IN_HIGH_MEMORY	218
#define ERROR_INVALID_EXITROUTINE_RING	219
#define ERROR_GETBUF_FAILED		220
#define ERROR_FLUSHBUF_FAILED		221
#define ERROR_TRANSFER_TOO_LONG 	222
#define ERROR_NO_CHILDREN		228
#define ERROR_INVALID_SCREEN_GROUP	229
/*
 * Error codes 230 - 249 are reserved
 */
#define ERROR_BAD_PIPE			230 /* Non-existant pipe or bad operation */
#define ERROR_PIPE_BUSY 		231 /* Pipe is busy		      */
#define ERROR_NO_DATA			232 /* No data on non-blocking read   */
#define ERROR_PIPE_NOT_CONNECTED	233 /* Pipe was disconnected by server*/
#define ERROR_MORE_DATA 		234 /* More data is available	      */

#define ERROR_VC_DISCONNECTED		240
#define ERROR_CIRCULARITY_REQUESTED	250 /* When renaming a dir which      */
                                            /* would cause a circularity      */
#define ERROR_DIRECTORY_IN_CDS		251 /* When renaming a dir	      */
                                            /* which is "in use"              */
#define ERROR_INVALID_FSD_NAME		252 /* when trying to access	      */
                                            /* nonexistent FSD                */
#define ERROR_INVALID_PATH		253 /* bad pseudo device	      */
#define ERROR_INVALID_EA_NAME		254 /* Illegal chars in name	      */
#define ERROR_EA_LIST_INCONSISTENT	255 /* Size or some field bad	      */
#define ERROR_EA_LIST_TOO_LONG		256 /* FEAlist > 64K-1 bytes	      */
#define ERROR_NO_META_MATCH		257 /* string doesn't match expression*/
#define ERROR_FINDNOTIFY_TIMEOUT	258 /* FindNotify request timeout     */
#define ERROR_NO_MORE_ITEMS		259 /* QFSAttach ordinal query	      */
#define ERROR_SEARCH_STRUC_REUSED	260 /* 3xbox findfirst/next
                                               search structure reused        */
#define ERROR_CHAR_NOT_FOUND		261 /* can not find character	      */
#define ERROR_TOO_MUCH_STACK		262 /* Stack request exceeds sys limit*/
#define ERROR_INVALID_ATTR		263 /* invalid FS_ATTRIBUTE	      */
#define ERROR_INVALID_STARTING_RING	264
#define ERROR_INVALID_DLL_INIT_RING	265
#define ERROR_CANNOT_COPY		266 /* doscopy */
#define ERROR_DIRECTORY 		267 /* doscopy */
#define ERROR_OPLOCKED_FILE		268
#define ERROR_OPLOCK_THREAD_EXISTS	269

/* error codes for DosFindNotify */
#define ERROR_VOLUME_CHANGED		270
#define ERROR_FINDNOTIFY_HANDLE_IN_USE	271
#define ERROR_FINDNOTIFY_HANDLE_CLOSED	272
#define ERROR_NOTIFY_OBJECT_REMOVED	273

/* Error to indicate that ShutDown already done */
#define ERROR_ALREADY_SHUTDOWN		274

/* error code for DOSFINDFIRST2/NEXT */
#define ERROR_EAS_DIDNT_FIT		275

/* error codes for EA file format change */
#define ERROR_EA_FILE_CORRUPT		276
#define ERROR_EA_TABLE_FULL		277
#define ERROR_INVALID_EA_HANDLE 	278
#define ERROR_NO_CLUSTER		279
#define ERROR_CREATE_EA_FILE		280
#define ERROR_CANNOT_OPEN_EA_FILE	281

#define ERROR_INVALID_PROCID		303
#define ERROR_INVALID_PDELTA		304
#define ERROR_NOT_DESCENDANT		305
#define ERROR_NOT_SESSION_MANAGER	306
#define ERROR_INVALID_PCLASS		307
#define ERROR_INVALID_SCOPE		308
#define ERROR_INVALID_THREADID		309
#define ERROR_DOSSUB_SHRINK		310
#define ERROR_DOSSUB_NOMEM		311
#define ERROR_DOSSUB_OVERLAP		312
#define ERROR_DOSSUB_BADSIZE		313
#define ERROR_DOSSUB_BADFLAG		314
#define ERROR_DOSSUB_BADSELECTOR	315
#define ERROR_MR_MSG_TOO_LONG		316
#define ERROR_MR_MID_NOT_FOUND		317
#define ERROR_MR_UN_ACC_MSGF		318
#define ERROR_MR_INV_MSGF_FORMAT	319
#define ERROR_MR_INV_IVCOUNT		320
#define ERROR_MR_UN_PERFORM		321
#define ERROR_TS_WAKEUP 		322
#define ERROR_TS_SEMHANDLE		323
#define ERROR_TS_NOTIMER		324
#define ERROR_TS_HANDLE 		326
#define ERROR_TS_DATETIME		327
#define ERROR_SYS_INTERNAL		328
#define ERROR_QUE_CURRENT_NAME		329
#define ERROR_QUE_PROC_NOT_OWNED	330
#define ERROR_QUE_PROC_OWNED		331
#define ERROR_QUE_DUPLICATE		332
#define ERROR_QUE_ELEMENT_NOT_EXIST	333
#define ERROR_QUE_NO_MEMORY		334
#define ERROR_QUE_INVALID_NAME		335
#define ERROR_QUE_INVALID_PRIORITY	336
#define ERROR_QUE_INVALID_HANDLE	337
#define ERROR_QUE_LINK_NOT_FOUND	338
#define ERROR_QUE_MEMORY_ERROR		339
#define ERROR_QUE_PREV_AT_END		340
#define ERROR_QUE_PROC_NO_ACCESS	341
#define ERROR_QUE_EMPTY 		342
#define ERROR_QUE_NAME_NOT_EXIST	343
#define ERROR_QUE_NOT_INITIALIZED	344
#define ERROR_QUE_UNABLE_TO_ACCESS	345
#define ERROR_QUE_UNABLE_TO_ADD 	346
#define ERROR_QUE_UNABLE_TO_INIT	347
#define ERROR_VIO_INVALID_MASK		349
#define ERROR_VIO_PTR			350
#define ERROR_VIO_APTR			351
#define ERROR_VIO_RPTR			352
#define ERROR_VIO_CPTR			353
#define ERROR_VIO_LPTR			354
#define ERROR_VIO_MODE			355
#define ERROR_VIO_WIDTH 		356
#define ERROR_VIO_ATTR			357
#define ERROR_VIO_ROW			358
#define ERROR_VIO_COL			359
#define ERROR_VIO_TOPROW		360
#define ERROR_VIO_BOTROW		361
#define ERROR_VIO_RIGHTCOL		362
#define ERROR_VIO_LEFTCOL		363
#define ERROR_SCS_CALL			364
#define ERROR_SCS_VALUE 		365
#define ERROR_VIO_WAIT_FLAG		366
#define ERROR_VIO_UNLOCK		367
#define ERROR_SGS_NOT_SESSION_MGR	368
#define ERROR_SMG_INVALID_SGID		369
#define ERROR_SMG_INVALID_SESSION_ID	369
#define ERROR_SMG_NOSG			370
#define ERROR_SMG_NO_SESSIONS		370
#define ERROR_SMG_GRP_NOT_FOUND 	371
#define ERROR_SMG_SESSION_NOT_FOUND	371
#define ERROR_SMG_SET_TITLE		372
#define ERROR_KBD_PARAMETER		373
#define ERROR_KBD_NO_DEVICE		374
#define ERROR_KBD_INVALID_IOWAIT	375
#define ERROR_KBD_INVALID_LENGTH	376
#define ERROR_KBD_INVALID_ECHO_MASK	377
#define ERROR_KBD_INVALID_INPUT_MASK	378
#define ERROR_MON_INVALID_PARMS 	379
#define ERROR_MON_INVALID_DEVNAME	380
#define ERROR_MON_INVALID_HANDLE	381
#define ERROR_MON_BUFFER_TOO_SMALL	382
#define ERROR_MON_BUFFER_EMPTY		383
#define ERROR_MON_DATA_TOO_LARGE	384
#define ERROR_MOUSE_NO_DEVICE		385
#define ERROR_MOUSE_INV_HANDLE		386
#define ERROR_MOUSE_INV_PARMS		387
#define ERROR_MOUSE_CANT_RESET		388
#define ERROR_MOUSE_DISPLAY_PARMS	389
#define ERROR_MOUSE_INV_MODULE		390
#define ERROR_MOUSE_INV_ENTRY_PT	391
#define ERROR_MOUSE_INV_MASK		392
#define NO_ERROR_MOUSE_NO_DATA		393
#define NO_ERROR_MOUSE_PTR_DRAWN	394
#define ERROR_INVALID_FREQUENCY 	395
#define ERROR_NLS_NO_COUNTRY_FILE	396
#define ERROR_NLS_OPEN_FAILED		397
#define ERROR_NLS_NO_CTRY_CODE		398
#define ERROR_NO_COUNTRY_OR_CODEPAGE	398
#define ERROR_NLS_TABLE_TRUNCATED	399
#define ERROR_NLS_BAD_TYPE		400
#define ERROR_NLS_TYPE_NOT_FOUND	401
#define ERROR_VIO_SMG_ONLY		402
#define ERROR_VIO_INVALID_ASCIIZ	403
#define ERROR_VIO_DEREGISTER		404
#define ERROR_VIO_NO_POPUP		405
#define ERROR_VIO_EXISTING_POPUP	406
#define ERROR_KBD_SMG_ONLY		407
#define ERROR_KBD_INVALID_ASCIIZ	408
#define ERROR_KBD_INVALID_MASK		409
#define ERROR_KBD_REGISTER		410
#define ERROR_KBD_DEREGISTER		411
#define ERROR_MOUSE_SMG_ONLY		412
#define ERROR_MOUSE_INVALID_ASCIIZ	413
#define ERROR_MOUSE_INVALID_MASK	414
#define ERROR_MOUSE_REGISTER		415
#define ERROR_MOUSE_DEREGISTER		416
#define ERROR_SMG_BAD_ACTION		417
#define ERROR_SMG_INVALID_CALL		418
#define ERROR_SCS_SG_NOTFOUND		419
#define ERROR_SCS_NOT_SHELL		420
#define ERROR_VIO_INVALID_PARMS 	421
#define ERROR_VIO_FUNCTION_OWNED	422
#define ERROR_VIO_RETURN		423
#define ERROR_SCS_INVALID_FUNCTION	424
#define ERROR_SCS_NOT_SESSION_MGR	425
#define ERROR_VIO_REGISTER		426
#define ERROR_VIO_NO_MODE_THREAD	427
#define ERROR_VIO_NO_SAVE_RESTORE_THD	428
#define ERROR_VIO_IN_BG 		429
#define ERROR_VIO_ILLEGAL_DURING_POPUP	430
#define ERROR_SMG_NOT_BASESHELL 	431
#define ERROR_SMG_BAD_STATUSREQ 	432
#define ERROR_QUE_INVALID_WAIT		433
#define ERROR_VIO_LOCK			434
#define ERROR_MOUSE_INVALID_IOWAIT	435
#define ERROR_VIO_INVALID_HANDLE	436
#define ERROR_VIO_ILLEGAL_DURING_LOCK	437
#define ERROR_VIO_INVALID_LENGTH	438
#define ERROR_KBD_INVALID_HANDLE	439
#define ERROR_KBD_NO_MORE_HANDLE	440
#define ERROR_KBD_CANNOT_CREATE_KCB	441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID	443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT	444
#define ERROR_KBD_FOCUS_REQUIRED	445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE	446
#define ERROR_KBD_KEYBOARD_BUSY 	447
#define ERROR_KBD_INVALID_CODEPAGE	448
#define ERROR_KBD_UNABLE_TO_FOCUS	449
#define ERROR_SMG_SESSION_NON_SELECT	450
#define ERROR_SMG_SESSION_NOT_FOREGRND	451
#define ERROR_SMG_SESSION_NOT_PARENT	452
#define ERROR_SMG_INVALID_START_MODE	453
#define ERROR_SMG_INVALID_RELATED_OPT	454
#define ERROR_SMG_INVALID_BOND_OPTION	455
#define ERROR_SMG_INVALID_SELECT_OPT	456
#define ERROR_SMG_START_IN_BACKGROUND	457
#define ERROR_SMG_INVALID_STOP_OPTION	458
#define ERROR_SMG_BAD_RESERVE		459
#define ERROR_SMG_PROCESS_NOT_PARENT	460
#define ERROR_SMG_INVALID_DATA_LENGTH	461
#define ERROR_SMG_NOT_BOUND		462
#define ERROR_SMG_RETRY_SUB_ALLOC	463
#define ERROR_KBD_DETACHED		464
#define ERROR_VIO_DETACHED		465
#define ERROR_MOU_DETACHED		466
#define ERROR_VIO_FONT			467
#define ERROR_VIO_USER_FONT		468
#define ERROR_VIO_BAD_CP		469
#define ERROR_VIO_NO_CP 		470
#define ERROR_VIO_NA_CP 		471
#define ERROR_INVALID_CODE_PAGE 	472
#define ERROR_CPLIST_TOO_SMALL		473
#define ERROR_CP_NOT_MOVED		474
#define ERROR_MODE_SWITCH_INIT		475
#define ERROR_CODE_PAGE_NOT_FOUND	476
#define ERROR_UNEXPECTED_SLOT_RETURNED	477
#define ERROR_SMG_INVALID_TRACE_OPTION	478
#define ERROR_VIO_INTERNAL_RESOURCE	479
#define ERROR_VIO_SHELL_INIT		480
#define ERROR_SMG_NO_HARD_ERRORS	481
#define ERROR_CP_SWITCH_INCOMPLETE	482
#define ERROR_VIO_TRANSPARENT_POPUP	483
#define ERROR_CRITSEC_OVERFLOW		484
#define ERROR_CRITSEC_UNDERFLOW 	485
#define ERROR_VIO_BAD_RESERVE		486
#define ERROR_INVALID_ADDRESS		487
#define ERROR_ZERO_SELECTORS_REQUESTED	488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA	489
#define ERROR_INVALID_SELECTOR		490
#define ERROR_SMG_INVALID_PROGRAM_TYPE	491
#define ERROR_SMG_INVALID_PGM_CONTROL	492
#define ERROR_SMG_INVALID_INHERIT_OPT	493
#define ERROR_VIO_EXTENDED_SG		494
#define ERROR_VIO_NOT_PRES_MGR_SG	495
#define ERROR_VIO_SHIELD_OWNED		496
#define ERROR_VIO_NO_MORE_HANDLES	497
#define ERROR_VIO_SEE_ERROR_LOG 	498
#define ERROR_VIO_ASSOCIATED_DC 	499
#define ERROR_KBD_NO_CONSOLE		500
#define ERROR_MOUSE_NO_CONSOLE		501
#define ERROR_MOUSE_INVALID_HANDLE	502
#define ERROR_SMG_INVALID_DEBUG_PARMS	503
#define ERROR_KBD_EXTENDED_SG		504
#define ERROR_MOU_EXTENDED_SG		505
#define ERROR_SMG_INVALID_ICON_FILE	506


#define ERROR_USER_DEFINED_BASE 	0xFF00

#define ERROR_I24_WRITE_PROTECT 	0
#define ERROR_I24_BAD_UNIT		1
#define ERROR_I24_NOT_READY		2
#define ERROR_I24_BAD_COMMAND		3
#define ERROR_I24_CRC			4
#define ERROR_I24_BAD_LENGTH		5
#define ERROR_I24_SEEK			6
#define ERROR_I24_NOT_DOS_DISK		7
#define ERROR_I24_SECTOR_NOT_FOUND	8
#define ERROR_I24_OUT_OF_PAPER		9
#define ERROR_I24_WRITE_FAULT		10
#define ERROR_I24_READ_FAULT		11
#define ERROR_I24_GEN_FAILURE		12
#define ERROR_I24_DISK_CHANGE		13
#define ERROR_I24_WRONG_DISK		15
#define ERROR_I24_UNCERTAIN_MEDIA	16
#define ERROR_I24_CHAR_CALL_INTERRUPTED 17
#define ERROR_I24_NO_MONITOR_SUPPORT	18
#define ERROR_I24_INVALID_PARAMETER	19
#define ERROR_I24_DEVICE_IN_USE 	20

#define ALLOWED_FAIL			0x0001
#define ALLOWED_ABORT			0x0002
#define ALLOWED_RETRY			0x0004
#define ALLOWED_IGNORE			0x0008
#define ALLOWED_ACKNOWLEDGE		0x0010
#define ALLOWED_DISPATCH		0x8000

#define I24_OPERATION			0x01
#define I24_AREA			0x06
#define I24_CLASS			0x80

/* Values for error CLASS */
#define ERRCLASS_OUTRES 		1   /* Out of Resource		      */
#define ERRCLASS_TEMPSIT		2   /* Temporary Situation	      */
#define ERRCLASS_AUTH			3   /* Permission problem	      */
#define ERRCLASS_INTRN			4   /* Internal System Error	      */
#define ERRCLASS_HRDFAIL		5   /* Hardware Failure 	      */
#define ERRCLASS_SYSFAIL		6   /* System Failure		      */
#define ERRCLASS_APPERR 		7   /* Application Error	      */
#define ERRCLASS_NOTFND 		8   /* Not Found		      */
#define ERRCLASS_BADFMT 		9   /* Bad Format		      */
#define ERRCLASS_LOCKED 		10  /* Locked			      */
#define ERRCLASS_MEDIA			11  /* Media Failure		      */
#define ERRCLASS_ALREADY		12  /* Collision with Existing Item   */
#define ERRCLASS_UNK			13  /* Unknown/other		      */
#define ERRCLASS_CANT			14
#define ERRCLASS_TIME			15

/* Values for error ACTION */
#define ERRACT_RETRY			1   /* Retry			      */
#define ERRACT_DLYRET			2   /* Delay Retry, retry after pause */
#define ERRACT_USER			3   /* Ask user to regive information */
#define ERRACT_ABORT			4   /* abort with clean up	      */
#define ERRACT_PANIC			5   /* abort immediately	      */
#define ERRACT_IGNORE			6   /* ignore			      */
#define ERRACT_INTRET			7   /* Retry after User Intervention  */

/* Values for error LOCUS */
#define ERRLOC_UNK			1   /* No appropriate value	      */
#define ERRLOC_DISK			2   /* Random Access Mass Storage     */
#define ERRLOC_NET			3   /* Network			      */
#define ERRLOC_SERDEV			4   /* Serial Device		      */
#define ERRLOC_MEM			5   /* Memory			      */

/* Abnormal termination codes */
#define TC_NORMAL		0
#define TC_HARDERR		1
#define TC_GP_TRAP		2
#define TC_SIGNAL		3

#define ERROR_SWAPPER_NOT_ACTIVE	32768
#define ERROR_INVALID_SWAPID		32769
#define ERROR_IOERR_SWAP_FILE		32770
#define ERROR_SWAP_TABLE_FULL		32771
#define ERROR_SWAP_FILE_FULL		32772
#define ERROR_CANT_INIT_SWAPPER 	32773
#define ERROR_SWAPPER_ALREADY_INIT	32774
#define ERROR_PMM_INSUFFICIENT_MEMORY	32775
#define ERROR_PMM_INVALID_FLAGS 	32776
#define ERROR_PMM_INVALID_ADDRESS	32777
#define ERROR_PMM_LOCK_FAILED		32778
#define ERROR_PMM_UNLOCK_FAILED 	32779
#define ERROR_PMM_MOVE_INCOMPLETE	32780
#define ERROR_UCOM_DRIVE_RENAMED	32781
#define ERROR_UCOM_FILENAME_TRUNCATED	32782
#define ERROR_UCOM_BUFFER_LENGTH	32783
#define ERROR_MON_CHAIN_HANDLE		32784
#define ERROR_MON_NOT_REGISTERED	32785
#define ERROR_SMG_ALREADY_TOP		32786
#define ERROR_PMM_ARENA_MODIFIED	32787
#define ERROR_SMG_PRINTER_OPEN		32788
#define ERROR_PMM_SET_FLAGS_FAILED	32789
#define ERROR_INVALID_DOS_DD		32790
#define ERROR_CPSIO_CODE_PAGE_INVALID	65026
#define ERROR_CPSIO_NO_SPOOLER		65027
#define ERROR_CPSIO_FONT_ID_INVALID	65028
#define ERROR_CPSIO_INTERNAL_ERROR	65033
#define ERROR_CPSIO_INVALID_PTR_NAME	65034
#define ERROR_CPSIO_NOT_ACTIVE		65037
#define ERROR_CPSIO_PID_FULL		65039
#define ERROR_CPSIO_PID_NOT_FOUND	65040
#define ERROR_CPSIO_READ_CTL_SEQ	65043
#define ERROR_CPSIO_READ_FNT_DEF	65045
#define ERROR_CPSIO_WRITE_ERROR 	65047
#define ERROR_CPSIO_WRITE_FULL_ERROR	65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD	65049
#define ERROR_CPSIO_SWIT_LOAD		65074
#define ERROR_CPSIO_INV_COMMAND 	65077
#define ERROR_CPSIO_NO_FONT_SWIT	65078

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\common.h ===
#ifndef REG_COMMON
#define REG_COMMON

#ifdef NOHELP

#define MyHelp( x , y , z)

#endif

#include <shellapi.h>


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define OPENDLG			4096
#define MAINICON		4097
#define MAINMENU		4098
#define SDKMAINMENU		4099

#define ID_HELP			0x0400
#define ID_HELPBUTTON		0x0401

#define ID_MERGEFILE		0x0410
#define ID_EXIT			(ID_MERGEFILE+1)

#define ID_ADD			0x0420
#define ID_COPY			(ID_ADD+1)
#define ID_MODIFY		(ID_ADD+2)
#define ID_DELETE		(ID_ADD+3)
#define ID_EDITVAL		(ID_ADD+4)

#define ID_FINISHMERGE		0x0430
#define ID_IDLIST		(ID_FINISHMERGE+1)

#define ID_FIRSTREGEDIT		0x0500
#define ID_FIRSTSDKREGED	0x0600

/* The help ID's should be last */
#define ID_HELPINDEX		0x0700
#define ID_HELPSEARCH   	(ID_HELPINDEX+1)
#define ID_HELPUSINGHELP	(ID_HELPINDEX+2)
#define ID_ABOUT		(ID_HELPINDEX+3)

#define IDS_SHORTNAME		0x0100
#define IDS_WIDTH		(IDS_SHORTNAME+1)
#define IDS_HEIGHT		(IDS_SHORTNAME+2)

#define IDS_MEDIUMNAME		0x0110
#define IDS_DESCRIPTION		(IDS_MEDIUMNAME+1)

#define IDS_MERGETITLE		0x0120
#define IDS_REGS		(IDS_MERGETITLE+1)
#define IDS_CUSTREGS		(IDS_MERGETITLE+2)

#define IDS_OUTOFMEMORY		0x0130
#define IDS_LONGNAME		(IDS_OUTOFMEMORY+1)

#define IDS_CANTOPENFILE	0x0140
#define IDS_CANTREADFILE	(IDS_CANTOPENFILE+1)
#define IDS_REGHEADER		(IDS_CANTOPENFILE+2)
#define IDS_BADFORMAT		(IDS_CANTOPENFILE+3)
#define IDS_SUCCESSREAD		(IDS_CANTOPENFILE+4)

#define IDS_HELPFILE		0x0150
#define IDS_HELP		(IDS_HELPFILE+1)
#define IDS_HELPERR		(IDS_HELPFILE+2)
#define IDS_SDKHELPFILE		(IDS_HELPFILE+3)

#define IDS_BADDB		0x0160
#define IDS_BADKEY		(IDS_BADDB+1)
#define IDS_CANTOPENDB		(IDS_BADDB+2)
#define IDS_CANTREADDB		(IDS_BADDB)
#define IDS_CANTWRITEDB		(IDS_BADDB+3)
#define IDS_INVALIDPARM		(IDS_BADKEY)
#define IDS_ENDERROR		(IDS_BADDB+4)

#define IDS_BUSY		0x0170

#define IDS_FIRSTREGEDIT	0x0200
#define IDS_FIRSTSDKREGED	0x0300

#define FLAG_SILENT		0x0001
#define FLAG_NOMESSAGES		0x0002
#define FLAG_VERBOSE		0x0004
#define FLAG_WRITETHROUGH	0x0008
#define FLAG_LEAVECOMMAND	0x0010

#define IDH_SYSMENU		0x2000
#define IDW_MAIN		(IDH_SYSMENU+1)
#define IDW_SDKMAIN		(IDW_MAIN+0x80)

#define IDW_OPENREG		0x3000
#define IDW_OPENEXE		(IDW_OPENREG+1)
#define IDW_SAVEREG		(IDW_OPENREG+2)

#define IDW_MODIFY		0x4000

#define MAX_KEY_LENGTH		64


/*********************************************************/
/******************* Macros ******************************/
/*********************************************************/

#define OFFSET(x) ((PSTR)(LOWORD((DWORD)(x))))


/*********************************************************/
/******************* Globals *****************************/
/*********************************************************/

extern HANDLE hInstance;
extern HWND hWndMain, hWndDlg, hWndHelp;
extern LPSTR lpCmdLine;
extern WORD wCmdFlags, wHelpMenuItem, wHelpId;
extern LONG (FAR PASCAL *lpfnEditor)(HWND, WORD, WORD, LONG);
extern FARPROC lpOldHook;
extern FARPROC lpMainWndDlg;
extern WORD wHelpIndex;


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** cutils1.c *****/
extern HANDLE NEAR PASCAL StringToLocalHandle(LPSTR szStr, WORD wFlags);
extern LPSTR NEAR _fastcall MyStrTok(LPSTR szList, char cEnd);
extern int NEAR PASCAL DoDialogBoxParam(LPCSTR lpDialog, HWND hWnd,
      FARPROC lpfnProc, DWORD dwParam);
extern int NEAR PASCAL DoDialogBox(LPCSTR, HWND, FARPROC);
extern unsigned long NEAR PASCAL MyQueryValue(HKEY hKey, PSTR pSubKey,
      HANDLE *hBuf);
extern HANDLE NEAR PASCAL GetEditString(HWND hWndEdit);
extern HANDLE NEAR _fastcall MyLoadString(WORD wId, WORD *pwSize, WORD wFlags);
extern int NEAR cdecl MyMessageBox(HWND hWnd, WORD wText, WORD wType,
      WORD wExtra, ...);
extern VOID NEAR PASCAL WriteProfileInt(WORD wAppName, WORD wKey, int nVal);
extern int NEAR PASCAL MyGetProfileInt(WORD wAppName, WORD wKey, int nDefault);
extern HANDLE NEAR PASCAL StringToHandle(LPSTR szStr);
extern int FAR PASCAL MessageFilter(int nCode, WORD wParam, LPMSG lpMsg);

#ifndef NOHELP
extern VOID NEAR PASCAL MyHelp(HWND hWnd, WORD wCommand, DWORD wId);
#endif

extern HANDLE NEAR PASCAL GetListboxString(HWND hWndEdit, int nId);
extern unsigned long NEAR PASCAL MyEnumKey(HKEY hKey, WORD wIndex,
      HANDLE *hBuf);
extern WORD NEAR _fastcall GetErrMsg(WORD wRet);
extern VOID NEAR PASCAL RepeatMove(LPSTR lpDest, LPSTR lpSrc, WORD wBytes);

/***** merge.c *****/
extern VOID NEAR PASCAL ProcessFiles(HWND hDlg, HANDLE hCmdLine, WORD wFlags);

/***** filename.c *****/
extern BOOL NEAR PASCAL DoFileOpenDlg(HWND hWnd, WORD wTitle, WORD wFilter,
      WORD wCustomFilter, HANDLE *hCustomFilter, HANDLE *hFileName, BOOL bOpen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\raserror.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raserror.h
** Remote Access external Win16 API
** RAS specific error codes
**
** Note: The constant names have been truncated at 31 characters to keep C6.0a
**       happy.  If there's a switch to get it to accept longer constants it
**       should be used.  I didn't find it.
*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#ifndef ERROR_INVALID_HANDLE
#define ERROR_INVALID_HANDLE 6
#endif

#ifndef ERROR_NOT_ENOUGH_MEMORY
#define ERROR_NOT_ENOUGH_MEMORY 8
#endif

#define RASBASE 600

#define SUCCESS 0

#define PENDING                         (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE       (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN         (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL          (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED      (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO      (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED        (RASBASE+6)
#define ERROR_EVENT_INVALID             (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST     (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST (RASBASE+9)
#define ERROR_INVALID_BUFFER            (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE       (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED       (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECI (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS            (RASBASE+14)
#define ERROR_PORT_NOT_FOUND            (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING     (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING     (RASBASE+17)
#define ERROR_PORT_NOT_OPEN             (RASBASE+18)
#define ERROR_PORT_DISCONNECTED         (RASBASE+19)
#define ERROR_NO_ENDPOINTS              (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK     (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK     (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENT (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK    (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK         (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING        (RASBASE+26)
#define ERROR_KEY_NOT_FOUND             (RASBASE+27)
#define ERROR_DISCONNECTION             (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION      (RASBASE+29)
#define ERROR_HARDWARE_FAILURE          (RASBASE+30)
#define ERROR_USER_DISCONNECTION        (RASBASE+31)
#define ERROR_INVALID_SIZE              (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE        (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT     (RASBASE+34)
#define ERROR_UNKNOWN                   (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED     (RASBASE+36)
#define ERROR_BAD_STRING                (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT           (RASBASE+38)
#define ERROR_CANNOT_GET_LANA           (RASBASE+39)
#define ERROR_NETBIOS_ERROR             (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES   (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET        (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILUR (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED     (RASBASE+44)
#define ERROR_AUTH_INTERNAL             (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS    (RASBASE+46)
#define ERROR_ACCT_DISABLED             (RASBASE+47)
#define ERROR_PASSWD_EXPIRED            (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION      (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING     (RASBASE+50)
#define ERROR_FROM_DEVICE               (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE     (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND           (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED         (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND   (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUN (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED  (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG       (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND      (RASBASE+59)
#define ERROR_NO_RESPONSES              (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND          (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED       (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE       (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY         (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED       (RASBASE+65)
#define ERROR_DEVICE_NOT_READY          (RASBASE+66)
#define ERROR_READING_INI_FILE          (RASBASE+67)
#define ERROR_NO_CONNECTION             (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE     (RASBASE+69)
#define ERROR_READING_SECTIONNAME       (RASBASE+70)
#define ERROR_READING_DEVICETYPE        (RASBASE+71)
#define ERROR_READING_DEVICENAME        (RASBASE+72)
#define ERROR_READING_USAGE             (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS     (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS     (RASBASE+75)
#define ERROR_LINE_BUSY                 (RASBASE+76)
#define ERROR_VOICE_ANSWER              (RASBASE+77)
#define ERROR_NO_ANSWER                 (RASBASE+78)
#define ERROR_NO_CARRIER                (RASBASE+79)
#define ERROR_NO_DIALTONE               (RASBASE+80)
#define ERROR_IN_COMMAND                (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME       (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE        (RASBASE+83)
#define ERROR_WRITING_DEVICENAME        (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS     (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS     (RASBASE+86)
#define ERROR_WRITING_USAGE             (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF        (RASBASE+88)
#define ERROR_READING_DEFAULTOFF        (RASBASE+89)
#define ERROR_EMPTY_INI_FILE            (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE    (RASBASE+91)
#define ERROR_PORT_OR_DEVICE            (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO          (RASBASE+93)
#define ERROR_DCB_NOT_FOUND             (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTE (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_ST (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING  (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY      (RASBASE+98)
#define ERROR_RECV_BUF_FULL             (RASBASE+99)
#define ERROR_CMD_TOO_LONG              (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS           (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE       (RASBASE+102)
#define ERROR_INTERACTIVE_MODE          (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER       (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE        (RASBASE+105)
#define ERROR_WRITING_INITBPS           (RASBASE+106)
#define ERROR_INVALID_WIN_HANDLE        (RASBASE+107)
#define ERROR_NO_PASSWORD               (RASBASE+108)
#define ERROR_NO_USERNAME               (RASBASE+109)
#define ERROR_CANNOT_START_STATE_MACHIN (RASBASE+110)
#define ERROR_GETTING_COMMSTATE         (RASBASE+111)
#define ERROR_SETTING_COMMSTATE         (RASBASE+112)
#define ERROR_COMM_FUNCTION             (RASBASE+113)
#define ERROR_CONFIGURATION_PROBLEM     (RASBASE+114)
#define ERROR_X25_DIAGNOSTIC            (RASBASE+115)
#define ERROR_TOO_MANY_LINE_ERRORS      (RASBASE+116)
#define ERROR_OVERRUN                   (RASBASE+117)
#define ERROR_ACCT_EXPIRED              (RASBASE+118)
#define ERROR_CHANGING_PASSWORD         (RASBASE+119)
#define ERROR_NO_ACTIVE_ISDN_LINES      (RASBASE+120)
#define ERROR_NO_ISDN_CHANNELS_AVAILABL (RASBASE+121)

#define RASBASEEND                           (RASBASE+121)


#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\rasapi16\rasapi16.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** rasapi16.c
** Remote Access external APIs
** Windows NT WOW 16->32 thunks, 16-bit side
**
** 04/02/94 Steve Cobb
**
** This is Win16 code and all included headers are Win16 headers.  By it's
** nature, this code is sensitive to changes in either the Win16 or Win32
** versions of RAS.H and the system definitions used therein.  Numerous name
** conflicts make it unfeasible to include the Win32 headers here.  Win32
** definitions needed for mapping are defined locally with a "Win32: <header>"
** comment indicating the location of the duplicated Win32 definition.
*/

#include <bseerr.h>
#include <windows.h>
#include <ras.h>
#include <raserror.h>

//#define BREAKONENTRY

LPVOID AlignedAlloc( HGLOBAL FAR* ph, DWORD cb );
VOID   AlignedFree( HGLOBAL h );
DWORD  MapErrorCode( DWORD dwError );


/*---------------------------------------------------------------------------
** Win32 definitions
**---------------------------------------------------------------------------
*/

/* The Win32 RAS structures are packed on 4-byte boundaries.
*/
#pragma pack(4)


/* Win32: ras.h - RASCONNA
** Pads to different size.
*/
#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASCONNA RASCONNA FAR*

/* Win32: ras.h - RASCONNSTATUSA
** The size of the RASCONNSTATE enum is different.
** Pads to different size.
*/
#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD dwSize;
    DWORD rasconnstate;
    DWORD dwError;
    CHAR  szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR  szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define LPRASCONNSTATUSA RASCONNSTATUSA FAR*

/* Win32: lmcons.h - UNLEN, PWLEN, and DNLEN
*/
#define NTUNLEN 256
#define NTPWLEN 256
#define NTDNLEN 15

/* Win32: ras.h - RASDIALPARAMSA
** The credential constants are different.
*/
#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ NTUNLEN + 1 ];
    CHAR  szPassword[ NTPWLEN + 1 ];
    CHAR  szDomain[ NTDNLEN + 1 ];
};

#define LPRASDIALPARAMSA RASDIALPARAMSA FAR*


/* Win32: ras.h - RASENTRYNAMEA
** Pads to different size.
*/
#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASENTRYNAMEA RASENTRYNAMEA FAR*


#pragma pack()


/* Win32: <rasui>\extapi\src\wow.c - RASAPI32.DLL WOW entry point prototypes
*/
typedef DWORD (FAR PASCAL* RASDIALWOW)( LPSTR, LPRASDIALPARAMS, DWORD, LPRASCONN );
typedef DWORD (FAR PASCAL* RASENUMCONNECTIONSWOW)( LPRASCONN, LPDWORD, LPDWORD );
typedef DWORD (FAR PASCAL* RASENUMENTRIESWOW)( LPSTR, LPSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
typedef DWORD (FAR PASCAL* RASGETCONNECTSTATUSWOW)( HRASCONN, LPRASCONNSTATUS );
typedef DWORD (FAR PASCAL* RASGETERRORSTRINGWOW)( DWORD, LPSTR, DWORD );
typedef DWORD (FAR PASCAL* RASHANGUPWOW)( HRASCONN );


/*---------------------------------------------------------------------------
** Globals
**---------------------------------------------------------------------------
*/

/* The handle of the RASAPI32.DLL module returned by LoadLibraryEx32W.
*/
DWORD HRasApi32Dll = NULL;

/* The unique RasDial notification message as registered in the system at
** startup (WM_RASDIALEVENT is just a default).
*/
UINT UnRasDialEventMsg = WM_RASDIALEVENT;


/*---------------------------------------------------------------------------
** Standard DLL entry points
**---------------------------------------------------------------------------
*/

int FAR PASCAL
LibMain(
    HINSTANCE hInst,
    WORD      wDataSeg,
    WORD      cbHeapSize,
    LPSTR     lpszCmdLine )

    /* Standard DLL startup routine.
    */
{
#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    /* Don't even load on anything but NT WOW.
    */
    if (!(GetWinFlags() & WF_WINNT))
        return FALSE;

    /* Load the Win32 RAS API DLL.
    */
    HRasApi32Dll = LoadLibraryEx32W( "RASAPI32.DLL", NULL, 0 );

    if (!HRasApi32Dll)
        return FALSE;

    /* Register a unique message for RasDial notifications.
    */
    {
        UINT unMsg = RegisterWindowMessage( RASDIALEVENT );

        if (unMsg > 0)
            UnRasDialEventMsg = unMsg;
    }

    return TRUE;
}


int FAR PASCAL
WEP(
    int nExitType )

    /* Standard DLL exit routine.
    */
{
#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    if (HRasApi32Dll)
        FreeLibrary32W( HRasApi32Dll );

    return TRUE;
}


/*---------------------------------------------------------------------------
** 16->32 thunks
**---------------------------------------------------------------------------
*/

DWORD APIENTRY
RasDial(
    LPSTR           reserved,
    LPSTR           lpszPhonebookPath,
    LPRASDIALPARAMS lprasdialparams,
    LPVOID          reserved2,
    HWND            hwndNotify,
    LPHRASCONN      lphrasconn )
{
    DWORD            dwErr;
    RASDIALWOW       proc;
    LPRASDIALPARAMSA prdpa;
    HGLOBAL          hrdpa;
    LPHRASCONN       phrc;
    HGLOBAL          hhrc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASDIALWOW )GetProcAddress32W(
            HRasApi32Dll, "RasDialWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    (void )reserved;
    (void )reserved2;

    /* Account for the increased user name and password field lengths on NT.
    */
    if (!(prdpa = (LPRASDIALPARAMSA )AlignedAlloc(
             &hrdpa, sizeof(RASDIALPARAMSA) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prdpa->dwSize = sizeof(RASDIALPARAMSA);
    lstrcpy( prdpa->szEntryName, lprasdialparams->szEntryName );
    lstrcpy( prdpa->szPhoneNumber, lprasdialparams->szPhoneNumber );
    lstrcpy( prdpa->szCallbackNumber, lprasdialparams->szCallbackNumber );
    lstrcpy( prdpa->szUserName, lprasdialparams->szUserName );
    lstrcpy( prdpa->szPassword, lprasdialparams->szPassword );
    lstrcpy( prdpa->szDomain, lprasdialparams->szDomain );

    if (!(phrc = (LPHRASCONN )AlignedAlloc(
             &hhrc, sizeof(HRASCONN) )))
    {
        AlignedFree( hrdpa );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *phrc = *lphrasconn;

    dwErr =
        CallProc32W(
            /* 16 */ (DWORD )lpszPhonebookPath,
            /*  8 */ (DWORD )prdpa,
            /*  4 */ (DWORD )hwndNotify | 0xFFFF0000,
            /*  2 */ (DWORD )UnRasDialEventMsg,
            /*  1 */ (DWORD )phrc,
            (LPVOID )proc,
            (DWORD )(16 + 8 + 1),
            (DWORD )5 );

    *lphrasconn = *phrc;

    AlignedFree( hrdpa );
    AlignedFree( hhrc );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasEnumConnections(
    LPRASCONN lprasconn,
    LPDWORD   lpcb,
    LPDWORD   lpcConnections )
{
    DWORD                 dwErr;
    RASENUMCONNECTIONSWOW proc;
    LPRASCONNA            prca;
    HGLOBAL               hrca;
    LPDWORD               pcb;
    HGLOBAL               hcb;
    LPDWORD               pcConnections;
    HGLOBAL               hcConnections;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASENUMCONNECTIONSWOW )GetProcAddress32W(
            HRasApi32Dll, "RasEnumConnectionsWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad sizes on this side before setting up a substitute buffer.
    */
    if (!lprasconn || lprasconn->dwSize != sizeof(RASCONN))
        return ERROR_INVALID_SIZE;

    if (!lpcb)
        return ERROR_INVALID_PARAMETER;

    if (!(pcb = (LPDWORD )AlignedAlloc( &hcb, sizeof(DWORD) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    *pcb = (*lpcb / sizeof(RASCONN)) * sizeof(RASCONNA);

    if (!(pcConnections = (LPDWORD )AlignedAlloc(
            &hcConnections, sizeof(DWORD) )))
    {
        AlignedFree( hcb );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (lpcConnections)
        *pcConnections = *lpcConnections;

    if (!(prca = (LPRASCONNA )AlignedAlloc( &hrca, *pcb )))
    {
        AlignedFree( hcb );
        AlignedFree( hcConnections );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prca->dwSize = sizeof(RASCONNA);

    dwErr =
        CallProc32W(
            /* 4 */ (DWORD )prca,
            /* 2 */ (DWORD )pcb,
            /* 1 */ (DWORD )pcConnections,
            (LPVOID )proc,
            (DWORD )(4 + 2 + 1),
            (DWORD )3 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    *lpcb = (*pcb / sizeof(RASCONNA)) * sizeof(RASCONN);

    if (lpcConnections)
        *lpcConnections = *pcConnections;

    if (MapErrorCode( dwErr ) != ERROR_BUFFER_TOO_SMALL)
    {
        DWORD      i;
        LPRASCONNA lprcaSub = prca;
        LPRASCONN  lprcCaller = lprasconn;

        for (i = 0; i < *pcConnections; ++i)
        {
            lprcCaller->dwSize = sizeof(RASCONN);
            lprcCaller->hrasconn = lprcaSub->hrasconn;
            lstrcpy( lprcCaller->szEntryName, lprcaSub->szEntryName );

            ++lprcaSub;
            ++lprcCaller;
        }
    }

    AlignedFree( hcb );
    AlignedFree( hcConnections );
    AlignedFree( hrca );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasEnumEntries(
    LPSTR          reserved,
    LPSTR          lpszPhonebookPath,
    LPRASENTRYNAME lprasentryname,
    LPDWORD        lpcb,
    LPDWORD        lpcEntries )
{
    DWORD             dwErr;
    RASENUMENTRIESWOW proc;
    LPRASENTRYNAMEA   prena;
    HGLOBAL           hrena;
    LPDWORD           pcb;
    HGLOBAL           hcb;
    LPDWORD           pcEntries;
    HGLOBAL           hcEntries;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASENUMENTRIESWOW )GetProcAddress32W(
            HRasApi32Dll, "RasEnumEntriesWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad sizes on this side before setting up a substitute buffer.
    */
    if (!lprasentryname || lprasentryname->dwSize != sizeof(RASENTRYNAME))
        return ERROR_INVALID_SIZE;

    if (!lpcb)
        return ERROR_INVALID_PARAMETER;

    if (!(pcb = (LPDWORD )AlignedAlloc( &hcb, sizeof(DWORD) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    *pcb = (*lpcb / sizeof(RASENTRYNAME)) * sizeof(RASENTRYNAMEA);

    if (!(pcEntries = (LPDWORD )AlignedAlloc(
            &hcEntries, sizeof(DWORD) )))
    {
        AlignedFree( hcb );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (lpcEntries)
        *pcEntries = *lpcEntries;

    if (!(prena = (LPRASENTRYNAMEA )AlignedAlloc( &hrena, *pcb )))
    {
        AlignedFree( hcb );
        AlignedFree( hcEntries );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prena->dwSize = sizeof(RASENTRYNAMEA);

    dwErr =
        CallProc32W(
            /* 16 */ (DWORD )reserved,
            /*  8 */ (DWORD )lpszPhonebookPath,
            /*  4 */ (DWORD )prena,
            /*  2 */ (DWORD )pcb,
            /*  1 */ (DWORD )pcEntries,
            (LPVOID )proc,
            (DWORD )(16 + 8 + 4 + 2 + 1),
            (DWORD ) 5 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    *lpcb = (*pcb / sizeof(RASENTRYNAMEA)) * sizeof(RASENTRYNAME);

    if (lpcEntries)
        *lpcEntries = *pcEntries;

    if (MapErrorCode( dwErr ) != ERROR_BUFFER_TOO_SMALL)
    {
        DWORD           i;
        LPRASENTRYNAMEA lprenaSub = prena;
        LPRASENTRYNAME  lprenCaller = lprasentryname;

        for (i = 0; i < *pcEntries; ++i)
        {
            lprenCaller->dwSize = sizeof(RASENTRYNAME);
            lstrcpy( lprenCaller->szEntryName, lprenaSub->szEntryName );

            ++lprenaSub;
            ++lprenCaller;
        }
    }

    AlignedFree( hcb );
    AlignedFree( hcEntries );
    AlignedFree( hrena );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasGetConnectStatus(
    HRASCONN        hrasconn,
    LPRASCONNSTATUS lprasconnstatus )
{
    DWORD                  dwErr;
    RASGETCONNECTSTATUSWOW proc;
    LPRASCONNSTATUSA       prcsa;
    HGLOBAL                hrcsa;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASGETCONNECTSTATUSWOW )GetProcAddress32W(
            HRasApi32Dll, "RasGetConnectStatusWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad size on this side before setting up a substitute buffer.
    */
    if (!lprasconnstatus || lprasconnstatus->dwSize != sizeof(RASCONNSTATUS))
        return ERROR_INVALID_SIZE;

    if (!(prcsa = (LPRASCONNSTATUSA )AlignedAlloc(
            &hrcsa, sizeof(RASCONNSTATUSA) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prcsa->dwSize = sizeof(RASCONNSTATUSA);

    dwErr =
        CallProc32W(
            /* 2 */ (DWORD )hrasconn,
            /* 1 */ (DWORD )prcsa,
            (LPVOID )proc,
            (DWORD )1,
            (DWORD )2 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    lprasconnstatus->rasconnstate = (RASCONNSTATE )prcsa->rasconnstate;
    lprasconnstatus->dwError = prcsa->dwError;
    lstrcpy( lprasconnstatus->szDeviceType, prcsa->szDeviceType );
    lstrcpy( lprasconnstatus->szDeviceName, prcsa->szDeviceName );

    AlignedFree( hrcsa );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasGetErrorString(
    UINT  uErrorCode,
    LPSTR lpszBuf,
    DWORD cbBuf )
{
    DWORD                dwErr;
    RASGETERRORSTRINGWOW proc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASGETERRORSTRINGWOW )GetProcAddress32W(
            HRasApi32Dll, "RasGetErrorStringWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    dwErr =
        CallProc32W(
            /* 4 */ (DWORD )uErrorCode,
            /* 2 */ (DWORD )lpszBuf,
            /* 1 */ (DWORD )cbBuf,
            (LPVOID )proc,
            (DWORD )2,
            (DWORD )3 );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasHangUp(
    HRASCONN hrasconn )
{
    DWORD        dwErr;
    RASHANGUPWOW proc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASHANGUPWOW )GetProcAddress32W(
            HRasApi32Dll, "RasHangUpWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    dwErr =
        CallProc32W(
            /* 1 */ (DWORD )hrasconn,
            (LPVOID )proc,
            (DWORD )0,
            (DWORD )1 );

    return MapErrorCode( dwErr );
}


/*---------------------------------------------------------------------------
** Utilities
**---------------------------------------------------------------------------
*/

LPVOID
AlignedAlloc(
    HGLOBAL FAR* ph,
    DWORD        cb )

    /* Returns address of block of 'cb' bytes aligned suitably for all
    ** platforms, or NULL if out of memory.  If successful, callers '*ph' is
    ** set to the handle of the block, used with AllignedFree.
    */
{
    LPVOID pv = NULL;
    *ph = NULL;

    if (!(*ph = GlobalAlloc( GPTR, cb )))
        return NULL;

    if (!(pv = (LPVOID )GlobalLock( *ph )))
    {
        GlobalFree( *ph );
        *ph = NULL;
    }

    return pv;
}


VOID
AlignedFree(
    HGLOBAL h )

    /* Frees a block allocated with AlignedAlloc identified by the 'h'
    ** returned from same.
    */
{
    if (h)
    {
        GlobalUnlock( h );
        GlobalFree( h );
    }
}


DWORD
MapErrorCode(
    DWORD dwError )

    /* Map Win32 error codes to Win16.  (Win32: raserror.h)
    */
{
    /* These codes map, but the codes are different in Win16 and Win32.
    ** ERROR_NO_ISDN_CHANNELS_AVAILABLE truncated to 31 characters.  See
    ** raserror.h.
    */
    switch (dwError)
    {
        case 709: return ERROR_CHANGING_PASSWORD;
        case 710: return ERROR_OVERRUN;
        case 713: return ERROR_NO_ACTIVE_ISDN_LINES;
        case 714: return ERROR_NO_ISDN_CHANNELS_AVAILABL;
    }

    /* Pass everything else thru including codes that don't match up to
    ** anything on Win16 (e.g. RAS errors outside the 600 to 706 range).
    ** Reasoning is that an unmapped code is more valuable that some generic
    ** error like ERROR_UNKNOWN.
    */
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\cutils1.c ===
#include <windows.h>
#include "common.h"

#define BLOCKLEN 100

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

extern HANDLE hInstance;
extern FARPROC lpOldHook;
extern HWND hWndMain, hWndHelp;
extern WORD wHelpMain;

extern char *pszLongName;
extern char *pszOutOfMemory;

HANDLE NEAR PASCAL StringToLocalHandle(LPSTR szStr, WORD wFlags)
{
   HANDLE hStr;
   LPSTR lpStr;

   if(!(hStr=LocalAlloc(wFlags, lstrlen(szStr) + 1)))
      goto Error1;
   if(!(lpStr=LocalLock(hStr)))
      goto Error2;
   lstrcpy(lpStr, szStr);
   LocalUnlock(hStr);
   goto Error1;

Error2:
   LocalFree(hStr);
   hStr = NULL;
Error1:
   return(hStr);
}

LPSTR NEAR _fastcall MyStrTok(LPSTR szList, char cEnd)
{
   LPSTR szTemp;

   /* if there are no more tokens return NULL */
   if(!*szList)
      return NULL;

   /* find delimiter or end of string */
   while(*szList && *szList!=cEnd)
      szList = AnsiNext(szList);

   /* if we found a delimiter insert string terminator and skip */
   if(*szList) {
      szTemp = szList;
      szList = AnsiNext(szTemp);
      *szTemp = '\0';
   }

   /* return token */
   return(szList);
}

int NEAR PASCAL DoDialogBoxParam(LPCSTR lpDialog, HWND hWnd, FARPROC lpfnProc,
      DWORD dwParam)
{
   int result = -1;

   if(!(lpfnProc = MakeProcInstance(lpfnProc, hInstance)))
      goto Error1;
   result = DialogBoxParam(hInstance, lpDialog, hWnd, lpfnProc, dwParam);
   FreeProcInstance(lpfnProc);

Error1:
   return(result);
}

int NEAR PASCAL DoDialogBox(LPCSTR lpDialog, HWND hWnd, FARPROC lpfnProc)
{
   return(DoDialogBoxParam(lpDialog, hWnd, lpfnProc, 0L));
}

unsigned long NEAR PASCAL MyQueryValue(HKEY hKey, PSTR pSubKey, HANDLE *hBuf)
{
   HANDLE hTemp;
   PSTR pBuf;
   WORD wBufSize = BLOCKLEN;
   unsigned long result = ERROR_OUTOFMEMORY;
   LONG lSize;

   if(!(*hBuf=LocalAlloc(LMEM_MOVEABLE, wBufSize)))
      goto Error1;
   if(!(pBuf=LocalLock(*hBuf)))
      goto Error2;

   while((lSize=wBufSize, (result=RegQueryValue(hKey, pSubKey, pBuf, &lSize))
         ==ERROR_SUCCESS) && (WORD)lSize>wBufSize-10) {
      LocalUnlock(*hBuf);
      wBufSize += BLOCKLEN;
      if(!(hTemp=LocalReAlloc(*hBuf, wBufSize, LMEM_MOVEABLE))) {
         result = ERROR_OUTOFMEMORY;
         goto Error2;
      }
      pBuf = LocalLock(*hBuf=hTemp);
   }
   LocalUnlock(*hBuf);
   if(result!=ERROR_SUCCESS || !lSize)
      goto Error2;
   goto Error1;

Error2:
   LocalFree(*hBuf);
   *hBuf = NULL;
Error1:
   return(result);
}

HANDLE NEAR PASCAL GetEditString(HWND hWndEdit)
{
   HANDLE hEdit = NULL;
   PSTR pEdit;
   WORD wLen;

   wLen = LOWORD(SendMessage(hWndEdit, WM_GETTEXTLENGTH, 0, 0L)) + 1;
   if(!(hEdit=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pEdit=LocalLock(hEdit)))
      goto Error2;

   SendMessage(hWndEdit, WM_GETTEXT, wLen, (DWORD)((LPSTR)pEdit));
   LocalUnlock(hEdit);
   goto Error1;

Error2:
   LocalFree(hEdit);
   hEdit = NULL;
Error1:
   return(hEdit);
}

HANDLE NEAR _fastcall MyLoadString(WORD wId, WORD *pwSize, WORD wFlags)
{
   char szString[258]; /* RC limits strings to 256 chars */
   WORD wSize;

   wSize = LoadString(hInstance, wId, szString, sizeof(szString));
   if(pwSize)
      *pwSize = wSize;
   return(StringToLocalHandle(szString, wFlags));
}

int NEAR cdecl MyMessageBox(HWND hWnd, WORD wText, WORD wType, WORD wExtra, ...)
{
   HANDLE hText, hRText;
   PSTR pText, pRText;
   WORD wSize;
   int result = 0;

   if(wText == IDS_OUTOFMEMORY)
      goto Error1;

   if(!(hText=MyLoadString(wText, &wSize, LMEM_MOVEABLE)))
      goto Error1;

   /* We allocate enough room for a bunch of numbers and the strings
    */
   if(!(hRText=LocalAlloc(LMEM_MOVEABLE, 2*wSize + wExtra)))
      goto Error2;
   if(!(pRText=LocalLock(hRText)))
      goto Error3;

   pText = LocalLock(hText);
   wvsprintf(pRText, pText, (LPSTR)(&wExtra+1));
   result = MessageBox(hWnd, pRText, pszLongName, wType);

   LocalUnlock(hText);
   LocalUnlock(hRText);
Error3:
   LocalFree(hRText);
Error2:
   LocalFree(hText);
Error1:
   if(!result) {
      MessageBox(hWnd, pszOutOfMemory, pszLongName,
            MB_ICONHAND | MB_SYSTEMMODAL | MB_OK);
   }

   return(result);
}

VOID NEAR PASCAL WriteProfileInt(WORD wAppName, WORD wKey, int nVal)
{
   HANDLE hAppName, hKey;
   char buf[10];

   if(!(hAppName=MyLoadString(wAppName, NULL, LMEM_MOVEABLE)))
      goto Error1;
   if(!(hKey=MyLoadString(wKey, NULL, LMEM_MOVEABLE)))
      goto Error2;

   wsprintf(buf, "%d", nVal);
   WriteProfileString(LocalLock(hAppName), LocalLock(hKey), buf);

   LocalUnlock(hKey);
   LocalUnlock(hAppName);
Error2:
   LocalFree(hKey);
Error1:
   LocalFree(hAppName);
}

int NEAR PASCAL MyGetProfileInt(WORD wAppName, WORD wKey, int nDefault)
{
   HANDLE hAppName, hKey;

   if(!(hAppName=MyLoadString(wAppName, NULL, LMEM_MOVEABLE)))
      goto Error1;
   if(!(hKey=MyLoadString(wKey, NULL, LMEM_MOVEABLE)))
      goto Error2;

   nDefault = GetProfileInt(LocalLock(hAppName), LocalLock(hKey), nDefault);

   LocalUnlock(hKey);
   LocalUnlock(hAppName);
Error2:
   LocalFree(hKey);
Error1:
   LocalFree(hAppName);
   return(nDefault);
}

HANDLE NEAR PASCAL StringToHandle(LPSTR szStr)
{
   HANDLE hStr;
   LPSTR lpStr;

   if(!(hStr=GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,
         (DWORD)(lstrlen(szStr)+1))))
      goto Error1;
   if(!(lpStr=GlobalLock(hStr)))
      goto Error2;
   lstrcpy(lpStr, szStr);
   GlobalUnlock(hStr);
   goto Error1;

Error2:
   GlobalFree(hStr);
   hStr = NULL;
Error1:
   return(hStr);
}

int FAR PASCAL MessageFilter(int nCode, WORD wParam, LPMSG lpMsg)
{
   switch(nCode) {
   case MSGF_MENU:
   case MSGF_DIALOGBOX:
      if(lpMsg->message==WM_KEYDOWN && lpMsg->wParam==VK_F1
            && !(lpMsg->lParam&(1L<<30)))
         PostMessage(hWndHelp, WM_COMMAND, ID_HELP,
               MAKELONG(lpMsg->hwnd, nCode));
      break;

   default:
      DefHookProc(nCode, wParam, (DWORD)lpMsg, &lpOldHook);
      return(FALSE);
   }

   return(FALSE);
}

#ifndef NOHELP

// #define ONLYID
VOID NEAR PASCAL MyHelp(HWND hWnd, WORD wCommand, DWORD wId)
{
#ifdef ONLYID
   if(wCommand != HELP_QUIT)
      MyMessageBox(hWnd, IDS_HELP, MB_OK, 0, wId);
#else
   HANDLE hHelpFile;
   PSTR pHelpFile;

   if(!(hHelpFile=MyLoadString(wHelpMain==IDW_SDKMAIN ?
	 IDS_SDKHELPFILE : IDS_HELPFILE, NULL, LMEM_MOVEABLE)))
      return;

   if(!WinHelp(hWndMain, pHelpFile=LocalLock(hHelpFile), wCommand, wId))
      MyMessageBox(hWnd, IDS_HELPERR, MB_OK, 0);
   else
      WinHelp(hWndMain, pHelpFile, HELP_SETINDEX, wHelpIndex);

   LocalUnlock(hHelpFile);
   LocalFree(hHelpFile);
#endif
}

#endif

HANDLE NEAR PASCAL GetListboxString(HWND hWndEdit, int nId)
{
   HANDLE hEdit = NULL;
   PSTR pEdit;
   WORD wLen;

   wLen = LOWORD(SendMessage(hWndEdit, LB_GETTEXTLEN, nId, 0L)) + 1;
   if(!(hEdit=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pEdit=LocalLock(hEdit)))
      goto Error2;

   SendMessage(hWndEdit, LB_GETTEXT, nId, (DWORD)((LPSTR)pEdit));
   LocalUnlock(hEdit);
   goto Error1;

Error2:
   LocalFree(hEdit);
   hEdit = NULL;
Error1:
   return(hEdit);
}

unsigned long NEAR PASCAL MyEnumKey(HKEY hKey, WORD wIndex, HANDLE *hBuf)
{
   HANDLE hTemp;
   PSTR pBuf;
   WORD wBufSize = BLOCKLEN, wSize;
   unsigned long result = ERROR_OUTOFMEMORY;

   if(!(*hBuf=LocalAlloc(LMEM_MOVEABLE, wBufSize)))
      goto Error1;
   if(!(pBuf=LocalLock(*hBuf)))
      goto Error2;

   while((result=RegEnumKey(hKey, wIndex, pBuf, (DWORD)wBufSize))
         ==ERROR_SUCCESS && (wSize=lstrlen(pBuf))>wBufSize-10) {
      LocalUnlock(*hBuf);
      wBufSize += BLOCKLEN;
      if(!(hTemp=LocalReAlloc(*hBuf, wBufSize, LMEM_MOVEABLE))) {
         result = ERROR_OUTOFMEMORY;
         goto Error2;
      }
      pBuf = LocalLock(*hBuf=hTemp);
   }
   LocalUnlock(*hBuf);
   if(result!=ERROR_SUCCESS || !wSize)
      goto Error2;
   goto Error1;

Error2:
   LocalFree(*hBuf);
   *hBuf = NULL;
Error1:
   return(result);
}

static WORD wErrMsgs[] = {
   0, IDS_BADDB, IDS_BADKEY, IDS_CANTOPENDB, IDS_CANTREADDB, IDS_CANTWRITEDB,
   IDS_OUTOFMEMORY, IDS_INVALIDPARM
} ;

WORD NEAR _fastcall GetErrMsg(WORD wRet)
{
   return(wRet>=sizeof(wErrMsgs)/sizeof(wErrMsgs[0]) ?
      IDS_INVALIDPARM : wErrMsgs[wRet]);
}

VOID NEAR PASCAL RepeatMove(LPSTR lpDest, LPSTR lpSrc, WORD wBytes)
{
/* WARNING: This assumes that the buffers are in different segments, or
 * the offset of the dest is less than the offset of the src
 */

/* Save DS, and load up ES:DI, DS:SI, and CX with the parameters */
_asm	push    ds
_asm	les     di,lpDest
_asm	lds     si,lpSrc
_asm	mov     cx,wBytes
_asm	cld

/* Do a movsb if CX is odd, and then do movsw for CX/2 */
_asm	shr	CX,1
_asm	jnc	repm1
_asm	movsb
_asm	repm1:
_asm	jcxz	repm2
_asm	rep	movsw
_asm	repm2:

/* Restore DS and return */
_asm	pop     ds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\dbase.c ===
#include <windows.h>
#include "RegEdit.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define NUMACTIONS (ID_LASTACTIONRADIO-ID_FIRSTACTIONRADIO+1)
#define EDITSPERACTION (ID_LASTEDIT-ID_FIRSTACTIONEDIT+1)
#define OFFSET_COMMAND 0
#define OFFSET_FIRSTDDE 1
#define OFFSET_DDEEXEC 1
#define OFFSET_DDEIFEXEC 2
#define OFFSET_DDEAPP 3
#define OFFSET_DDETOPIC 4
#define BLOCKLEN 100

char szNull[] = "";

static char szShell[] = "shell";
static char szCommand[] = "command";
static char szDDEExec[] = "ddeexec";
static char szDDEIfExec[] = "ddeexec\\ifexec";
static char szDDEApplication[] = "ddeexec\\application";
static char szDDETopic[] = "ddeexec\\topic";
static char *ppCommands[] = {
   szCommand, szDDEExec, szDDEIfExec, szDDEApplication, szDDETopic
} ;
static char szOpen[] = "open";
static char szPrint[] = "print";
static char *ppActionIds[] = {
   szOpen, szPrint
} ;
static char szSystem[] = "System";

char cUsesDDE[NUMACTIONS];

HANDLE *pLocalVals = NULL;

WORD NEAR PASCAL CreateId(HANDLE hId)
{
   HKEY hKeyNew;
   PSTR pId, pTemp;
   WORD wErrMsg = IDS_INVALIDID;

   pId = LocalLock(hId);
   if(!*pId || *pId=='.')
      goto Error1;
   for(pTemp=pId; *pTemp; ++pTemp)
/* this excludes '\\' and all other chars except 33-127 */
      if(*pTemp=='\\' || *pTemp<=' ')
         goto Error1;

   wErrMsg = IDS_EXISTS;
   if(RegOpenKey(HKEY_CLASSES_ROOT, pId, &hKeyNew) == ERROR_SUCCESS)
      goto Error2;

   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, pId, &hKeyNew)))
      goto Error1;
   wErrMsg = NULL;

Error2:
   RegCloseKey(hKeyNew);
Error1:
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL MyGetClassName(HANDLE hId, HANDLE *hName)
{
   WORD wErrMsg;

   wErrMsg = GetErrMsg((WORD)MyQueryValue(HKEY_CLASSES_ROOT, LocalLock(hId),
	 hName));
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL DeleteClassId(HANDLE hId)
{
   WORD wErrMsg;

   wErrMsg = GetErrMsg((WORD)RegDeleteKey(HKEY_CLASSES_ROOT, LocalLock(hId)));
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL MergeData(HWND hWndName, HANDLE hId)
{
   HANDLE hName;
   HANDLE *phTemp;
   WORD wErrMsg = IDS_OUTOFMEMORY;
   HKEY hKeyId, hKeyShell, hKeyAction;
   int i, j;

   if(!(hName=GetEditString(hWndName)))
      goto Error2;
   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, LocalLock(hId),
	 &hKeyId)))
      goto Error3;
   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyId, szShell, &hKeyShell)))
      goto Error4;
   if(wErrMsg=GetErrMsg((WORD)RegSetValue(hKeyId, szNull, (DWORD)REG_SZ,
         LocalLock(hName), 0L)))
      goto Error5;

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyShell, ppActionIds[i],
            &hKeyAction)))
         goto Error5;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if(*phTemp && (j<OFFSET_FIRSTDDE || cUsesDDE[i])) {
            PSTR pTemp;

            pTemp = LocalLock(*phTemp);
            if((j==OFFSET_DDETOPIC && !lstrcmpi(pTemp, szSystem)) ||
                  (j==OFFSET_DDEAPP && !lstrcmpi(pTemp,
		  GetAppName(*(phTemp+OFFSET_COMMAND-OFFSET_DDEAPP)))))
               RegDeleteKey(hKeyAction, ppCommands[j]);
            else
               wErrMsg = GetErrMsg((WORD)RegSetValue(hKeyAction, ppCommands[j],
                     (DWORD)REG_SZ, pTemp, 0L));
            LocalUnlock(*phTemp);
            if(wErrMsg)
               goto Error5;
         } else {
            RegDeleteKey(hKeyAction, ppCommands[j]);
         }
      }

      RegCloseKey(hKeyAction);
   }
   wErrMsg = NULL;

Error5:
   LocalUnlock(hName);
   RegCloseKey(hKeyShell);
Error4:
   RegCloseKey(hKeyId);
Error3:
   LocalUnlock(hId);
   LocalFree(hName);
Error2:
   return(wErrMsg);
}

WORD NEAR PASCAL ResetClassList(HWND hWndIdList, HWND hWndNameList)
{
   HANDLE hClassId, hClassName;
   HKEY hKeyClasses;
   int i;
   WORD wErrMsg;

/* Reset the name list */
   SendMessage(hWndIdList, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndNameList, LB_RESETCONTENT, 0, 0L);

   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, szNull,
         &hKeyClasses)))
      goto Error1;

   for(i=0; MyEnumKey(hKeyClasses, i, &hClassId)==ERROR_SUCCESS && !wErrMsg;
         ++i) {
      int nId;
      PSTR pClassId;

      pClassId = LocalLock(hClassId);
      if(*pClassId=='.' || (wErrMsg=MyGetClassName(hClassId, &hClassName)))
         goto Error2;

      wErrMsg = IDS_OUTOFMEMORY;
      if((nId=(int)SendMessage(hWndNameList, LB_ADDSTRING, 0,
            (DWORD)((LPSTR)LocalLock(hClassName))))==LB_ERR
            || SendMessage(hWndIdList, LB_INSERTSTRING, nId,
            (DWORD)((LPSTR)pClassId))==LB_ERR)
         goto Error3;

      wErrMsg = NULL;
Error3:
      LocalUnlock(hClassName);
      LocalFree(hClassName);
Error2:
      LocalUnlock(hClassId);
      LocalFree(hClassId);
   }

   SendMessage(hWndNameList, LB_SETTOPINDEX, 0, 0L);
   SendMessage(hWndNameList, LB_SETCURSEL, 0, 0L);

   RegCloseKey(hKeyClasses);
Error1:
   return(wErrMsg);
}

WORD NEAR PASCAL GetLocalCopies(HWND hWndName, HANDLE hId)
{
   HKEY hKeyId, hKeyShell, hSubKey;
   HANDLE hName, *phTemp;
   WORD wErrMsg = IDS_OUTOFMEMORY;
   int i, j;

   if(!pLocalVals) {
      HANDLE hLocalVals;

      if(!(hLocalVals=LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
            NUMACTIONS*EDITSPERACTION*sizeof(HANDLE)))
            || !(pLocalVals=(HANDLE *)LocalLock(hLocalVals)))
         goto Error1;
   }

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      cUsesDDE[i] = 0;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if(*phTemp) {
            LocalFree(*phTemp);
            *phTemp = NULL;
         }
      }
   }
   SendMessage(hWndName, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));
   if(!hId)
      return(NULL);

   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, LocalLock(hId),
         &hKeyId)))
      goto Error3;
   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyId, szShell, &hKeyShell)))
      goto Error4;

   if(wErrMsg=GetErrMsg((WORD)MyQueryValue(hKeyId, szNull, &hName)))
      goto Error5;
   SendMessage(hWndName, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hName)));
   LocalUnlock(hName);
   LocalFree(hName);

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyShell, ppActionIds[i],
            &hSubKey)))
         goto Error5;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if((wErrMsg=(WORD)MyQueryValue(hSubKey, ppCommands[j], phTemp))
               !=(WORD)ERROR_BADKEY && (wErrMsg=GetErrMsg(wErrMsg)))
            goto Error5;

         if(j>=OFFSET_FIRSTDDE) {
            if(*phTemp)
               cUsesDDE[i] = 1;
            else if(j == OFFSET_DDETOPIC) {
               *phTemp = StringToLocalHandle(szSystem, LMEM_MOVEABLE);
            } else if(j == OFFSET_DDEAPP) {
               HANDLE hTemp;

               if(hTemp = *(phTemp-(OFFSET_DDEAPP+OFFSET_COMMAND)))
                  *phTemp = StringToLocalHandle(GetAppName(hTemp),
                        LMEM_MOVEABLE);
            }
         }
      }

      RegCloseKey(hSubKey);
   }

   wErrMsg = NULL;
Error5:
   RegCloseKey(hKeyShell);
Error4:
   RegCloseKey(hKeyId);
Error3:
   LocalUnlock(hId);
Error1:
   return(wErrMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\filename.c ===
#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>
#include "common.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define MYMAXPATH 255

extern HANDLE hInstance;
extern HWND hWndHelp;
extern WORD wHelpId;

static VOID NEAR PASCAL ReplaceChar(LPSTR lpStr, char cOld, char cNew)
{
   for( ; *lpStr; lpStr=AnsiNext(lpStr))
      if(*lpStr == cOld)
         *lpStr = cNew;
}

int FAR PASCAL MyOpenDlgProc(HWND hWnd, WORD message, WORD wParam, DWORD lParam)
{
   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hWnd;
      return(FALSE);

   case WM_INITDIALOG:
      return(TRUE);

   case WM_COMMAND:
      switch(wParam) {
      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hWnd)
            break;
      case psh15:
         MyHelp(hWnd, HELP_CONTEXT, wHelpId);
         break;
      }
      break;
   }

   return(FALSE);
}

HANDLE NEAR PASCAL MyLoadGlobalString(HANDLE wString, WORD *wSize)
{
   HANDLE hlString, hString;

   if(!(hlString=MyLoadString(wString, wSize, LMEM_MOVEABLE)))
      goto Error1;
   hString = StringToHandle(LocalLock(hlString));
   LocalUnlock(hlString);
   LocalFree(hlString);

Error1:
   return(hString);
}

BOOL NEAR PASCAL DoFileOpenDlg(HWND hWnd, WORD wTitle, WORD wFilter,
      WORD wCustomFilter, HANDLE *hCustomFilter, HANDLE *hFileName, BOOL bOpen)
{
   HANDLE hOfn, hFilter, hTitle;
   LPOPENFILENAME lpOfn;
   LPSTR lpFileName, lpFilter;
   BOOL result = FALSE;
#ifdef USECUSTOMFILTER
   HANDLE hpFilter;
   LPSTR lpCustomFilter;
   WORD wSize;
#endif

   if(!(hOfn=GlobalAlloc(GMEM_FIXED, sizeof(OPENFILENAME))))
      goto Error1;
   if(!(lpOfn=(LPOPENFILENAME)GlobalLock(hOfn)))
      goto Error2;

   if(!(hFilter=MyLoadGlobalString(wFilter, NULL)))
      goto Error3;
   lpFilter = GlobalLock(hFilter);
   ReplaceChar(AnsiNext(lpFilter), *lpFilter, '\0');

   if(!(hTitle=MyLoadGlobalString(wTitle, NULL)))
      goto Error4;

   if(!(*hFileName=GlobalAlloc(GMEM_MOVEABLE, MYMAXPATH)))
      goto Error5;
   if(!(lpFileName=GlobalLock(*hFileName)))
      goto Error6;
   *lpFileName = '\0';

#ifdef USECUSTOMFILTER
   if(*hCustomFilter) {
      lpCustomFilter = GlobalLock(*hCustomFilter);
   } else {
      if(!(*hCustomFilter=MyLoadGlobalString(wCustomFilter, &wSize)))
         goto Error7;
      if(hpFilter=GlobalReAlloc(*hCustomFilter, 2*wSize, GMEM_MOVEABLE))
         *hCustomFilter = hpFilter;
      lpCustomFilter = GlobalLock(*hCustomFilter);
      ReplaceChar(AnsiNext(lpCustomFilter), *lpCustomFilter, '\0');
   }
#endif

   lpOfn->lStructSize = sizeof(OPENFILENAME);
   lpOfn->hwndOwner = hWnd;
   lpOfn->hInstance = hInstance;
   lpOfn->lpstrFilter = AnsiNext(lpFilter);
#ifdef USECUSTOMFILTER
   lpOfn->lpstrCustomFilter = AnsiNext(lpCustomFilter);
   lpOfn->nMaxCustFilter = GlobalSize(*hCustomFilter) - 1;
#else
   lpOfn->lpstrCustomFilter = NULL;
   lpOfn->nMaxCustFilter = 0;
#endif
   lpOfn->nFilterIndex = 0;
   lpOfn->lpstrFile = lpFileName;
   lpOfn->nMaxFile = MYMAXPATH;
   lpOfn->lpstrFileTitle = NULL;
   lpOfn->nMaxFileTitle = 0;
   lpOfn->lpstrInitialDir = NULL;
   lpOfn->lpstrTitle = GlobalLock(hTitle);
   lpOfn->Flags = OFN_HIDEREADONLY
#ifndef NOHELP
	 | OFN_SHOWHELP
#endif
	 | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK;
   lpOfn->lpstrDefExt = NULL;
   lpOfn->lCustData = 0;
   lpOfn->lpfnHook = (UINT (CALLBACK *)(HWND, UINT, WPARAM, LPARAM))MakeProcInstance(MyOpenDlgProc, hInstance);
   lpOfn->lpTemplateName = NULL;

   result = bOpen ? GetOpenFileName(lpOfn) : GetSaveFileName(lpOfn);

   if(lpOfn->lpfnHook)
      FreeProcInstance(lpOfn->lpfnHook);

   GlobalUnlock(hTitle);
#ifdef USECUSTOMFILTER
   GlobalUnlock(*hCustomFilter);
Error7:
#endif
   GlobalUnlock(*hFileName);
Error6:
   if(!result)
      GlobalFree(*hFileName);
Error5:
   GlobalFree(hTitle);
Error4:
   GlobalUnlock(hFilter);
   GlobalFree(hFilter);
Error3:
   GlobalUnlock(hOfn);
Error2:
   GlobalFree(hOfn);
Error1:
   return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\merge.c ===
#include <windows.h>
#include "common.h"

#define BLOCKLEN 100

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

LPSTR lpMerge;
char szDotClasses[] = "\\.classes\\";
char szHkeyClassesRoot[] = "HKEY_CLASSES_ROOT\\";

extern HWND hWndHelp;

extern unsigned long NEAR PASCAL MySetValue(HKEY hKey, PSTR pSubKey, PSTR pVal);

NEAR PASCAL
ImportWin40RegFile(
    VOID
    );

static PSTR NEAR PASCAL GetFileLine(void)
{
   static HANDLE hFile = NULL;
   static PSTR pFile;
   static WORD wLen;

   LPSTR lpStart;
   HANDLE hTemp;
   WORD wLineLen;
   char cFile;

/* We need a place to put the file line */
   if(!hFile) {
      if(!(hFile=LocalAlloc(LMEM_MOVEABLE, wLen=BLOCKLEN)))
         goto Error1;
      if(!(pFile=LocalLock(hFile)))
         goto Error2;
   }

/* If we have read the whole file, then clean up and return */
   if(!*lpMerge)
      goto Error3;

   for(lpStart=lpMerge; ; ) {
      cFile = *lpMerge;
      lpMerge = AnsiNext(lpMerge);

      switch(cFile) {
      case('\n'):
      case('\r'):
      case('\0'):
/* EOL so return */
         goto CopyLine;
      }
   }

CopyLine:
   wLineLen = lpMerge - lpStart - 1;
/* Make the buffer larger if necessary */
   if(wLineLen >= wLen) {
      LocalUnlock(hFile);
      wLen = wLineLen + BLOCKLEN;
      if(!(hTemp=LocalReAlloc(hFile, wLen, LMEM_MOVEABLE)))
         goto Error2;
      if(!(pFile=LocalLock(hFile=hTemp)))
         goto Error2;
   }
   RepeatMove(pFile, lpStart, wLineLen);
   pFile[wLineLen] = '\0';
   return(pFile);


Error3:
   LocalUnlock(hFile);
Error2:
   LocalFree(hFile);
   hFile = NULL;
Error1:
   return(NULL);
}

static VOID NEAR PASCAL MergeFileData(void)
{
  static struct tagKEYANDROOT
    {
      PSTR szKey;
      HKEY hKeyRoot;
    } krClasses[] =
    {
      szHkeyClassesRoot, HKEY_CLASSES_ROOT,
      szDotClasses, HKEY_CLASSES_ROOT
    } ;
#define NUM_KEYWORDS (sizeof(krClasses)/sizeof(krClasses[0]))

  PSTR pLine;
  PSTR pLast;
  HKEY hKeyRoot, hSubKey;
  int i;

  /* Get the initial line if this is the first time through */
  if(!(pLine=GetFileLine()))
      return;
  /* Otherwise, open a key so that we only do one write to the disk */
  if(RegCreateKey(HKEY_CLASSES_ROOT, NULL, &hSubKey) != ERROR_SUCCESS)
      return;

  do
    {
      for (i=0; i<NUM_KEYWORDS; ++i)
	{
	  char cTemp;
	  int nCmp, nLen;

	  cTemp = pLine[nLen=lstrlen(krClasses[i].szKey)];
	  pLine[nLen] = '\0';
	  nCmp = lstrcmp(krClasses[i].szKey, pLine);
	  pLine[nLen] = cTemp;
	  if (!nCmp)
	    {
	      pLine += nLen;
	      hKeyRoot = krClasses[i].hKeyRoot;
	      goto MergeTheData;
	    }
	}
      continue;

MergeTheData:
      /* This is a line that needs to get merged.
       * Find a space (and then skip spaces) or "= " */
      for(pLast=pLine; *pLast; pLast=AnsiNext(pLast))
	{
	  if(*pLast == ' ')
	    {
	      *pLast = '\0';
	      while(*(++pLast) == ' ')
		  /* find the first non-space */ ;
	      break;
	    }
	}

      /* There is an error if we don't have "= " */
      if(*pLast=='=' && *(++pLast)==' ')
	 ++pLast;

      /* Set the value */
      MySetValue(hKeyRoot, pLine, pLast);
    } while(pLine=GetFileLine()) ;

  RegCloseKey(hSubKey);
}


VOID NEAR PASCAL ProcessFiles(HWND hDlg, HANDLE hCmdLine, WORD wFlags)
{
   HANDLE hMerge, hHeader;
   PSTR pHeader;
   int hFile;
   LONG lSize;
   LPSTR lpFileName, lpTemp;
   OFSTRUCT of;
   WORD wErrMsg;

   lpFileName = GlobalLock(hCmdLine);
/* We need to process all file names on the command line */
   while(lpTemp=MyStrTok(lpFileName, ' ')) {
/* Open the file */
      wErrMsg = IDS_CANTOPENFILE;
      if((hFile=OpenFile(lpFileName, &of, OF_READ)) == -1)
         goto Error2;

/* Determine the file size; limit it to just less than 64K */
      wErrMsg = IDS_CANTREADFILE;
      if((lSize=_llseek(hFile, 0L, 2))==-1 || lSize>0xfff0)
         goto Error3;
      _llseek(hFile, 0L, 0);

/* Allocate a block of memory for the file */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hMerge=GlobalAlloc(GHND, lSize+2)))
         goto Error3;
      if(!(lpMerge=GlobalLock(hMerge)))
         goto Error4;

/* Read in the file */
      wErrMsg = IDS_CANTREADFILE;
      if(_lread(hFile, lpMerge, LOWORD(lSize)) != LOWORD(lSize))
         goto Error5;

/* Look for the header */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hHeader=MyLoadString(IDS_REGHEADER, NULL, LMEM_MOVEABLE)))
         goto Error5;
      pHeader = LocalLock(hHeader);

      wErrMsg = IDS_BADFORMAT;
      while(*lpMerge == ' ')
         ++lpMerge;
      while(*pHeader)
         if(*lpMerge++ != *pHeader++)
            goto Error6;
      if(*lpMerge=='4')
       {
        ImportWin40RegFile();
        wErrMsg = IDS_SUCCESSREAD;
        goto Error6;
       }
      while(*lpMerge == ' ')
         ++lpMerge;
      if(*lpMerge!='\r' && *lpMerge!='\n')
         goto Error6;

/* Merge the data */
      MergeFileData(); /* This makes the changes */

      wErrMsg = IDS_SUCCESSREAD;
Error6:
      LocalUnlock(hHeader);
      LocalFree(hHeader);
Error5:
      GlobalUnlock(hMerge);
Error4:
      GlobalFree(hMerge);
Error3:
      _lclose(hFile);
Error2:
/* Display the status message */
      if(!(wFlags&FLAG_SILENT) || wErrMsg!=IDS_SUCCESSREAD)
         MyMessageBox(hDlg, wErrMsg, MB_OK | MB_ICONEXCLAMATION,
	       lstrlen(lpFileName), lpFileName);

      lpFileName = lpTemp;
      while(*lpFileName == ' ')
         ++lpFileName;
   }

   GlobalUnlock(hCmdLine);

   GlobalFree(hCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#ifdef WIN32
#define WSPRINTF(x)                     wsprintf ##x
#else
#define WSPRINTF(x)                     sprintf ##x
#endif

#ifdef WIN32
#define STRCMP(string1, string2)        lstrcmp(string1, string2)
#else
#define STRCMP(string1, string2)        _fstrcmp(string1, string2)
#endif

#ifdef WIN32
#define STRCPY(string1, string2)        lstrcpy(string1, string2)
#else
#define STRCPY(string1, string2)        _fstrcpy(string1, string2)
#endif

#ifdef WIN32
#define STRLEN(string)                  lstrlen(string)
#else
#define STRLEN(string)                  _fstrlen(string)
#endif

#ifdef WIN32
#define STRCHR(string, character)       StrChr(string, character)
#else
#ifdef DBCS
#define STRCHR(string, character)       DBCSStrChr(string, character)
#else
#define STRCHR(string, character)       _fstrchr(string, character)
#endif
#endif

#ifdef WIN32
#define CHARNEXT(string)                CharNext(string)
#else
#define CHARNEXT(string)                (string + 1)
#endif

#ifdef WIN32
#define CHARUPPERSTRING(string)         CharUpper(string)
#else
#define CHARUPPERSTRING(string)         _fstrupr(string)
#endif

#ifdef WIN32
#define FILE_HANDLE                     HANDLE
#else
#define FILE_HANDLE                     int
#endif

#ifdef WIN32
#define FILE_NUMBYTES                   DWORD
#else
#define FILE_NUMBYTES                   unsigned
#endif

#if 1 //def WIN32
#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = (FILE_HANDLE) OpenFile(pfilename, &OFStruct, OF_READ)) !=    \
        (FILE_HANDLE) HFILE_ERROR)
#else
#define OPENREADFILE(pfilename, handle)                                     \
    (_dos_open(pfilename, _O_RDONLY, &handle) == 0)
#endif

#ifdef WIN32
#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENWRITEFILE(pfilename, handle)                                    \
    (HFILE_ERROR!=(handle=_lcreat(pfilename, 0)))
#endif

#ifdef WIN32
#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)
#else
#define READFILE(handle, buffer, count, pnumbytes)                          \
    (count==(*pnumbytes=_hread(handle, buffer, count)))
#endif

#ifdef WIN32
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)
#else
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    (count==(*pnumbytes=_hwrite(handle, buffer, count)))
#endif

#ifdef WIN32
#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))
#else
#define SEEKCURRENTFILE(handle, count)                                      \
    (_llseek(handle, count, SEEK_CUR))
#endif

#ifdef WIN32
#define CLOSEFILE(handle)               CloseHandle(handle)
#else
#define CLOSEFILE(handle)               _lclose(handle)
#endif

#ifdef WIN32
#define GETFILESIZE(handle)             GetFileSize(handle, NULL)
#else
DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    );
#define GETFILESIZE(handle)             GetFileSize(handle)
#endif

#endif // _INC_REG1632

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regedit.c ===
#define WIN31
#include <windows.h>
#include "RegEdit.h"

HWND hWndNames, hWndIds;
WORD fMode;

extern char cUsesDDE[];
extern HANDLE *pLocalVals;


WORD NEAR PASCAL StoreValue(HWND hWndEdit, HANDLE *pValue)
{
   HANDLE hTemp = NULL;

   if(!SendMessage(hWndEdit, EM_GETMODIFY, 0, 0L))
      return(0);

   SendMessage(hWndEdit, EM_SETMODIFY, 0, 0L);

   if(SendMessage(hWndEdit, WM_GETTEXTLENGTH, 0, 0L))
      if(!(hTemp=GetEditString(hWndEdit)))
	 return(IDS_OUTOFMEMORY);

   if(*pValue)
      LocalFree(*pValue);
   *pValue = hTemp;

   return(NULL);
}


VOID NEAR PASCAL SetValue(HWND hDlg, int i, HWND hWndEdit, HANDLE hValue,
      BOOL bEnable)
{
   if(bEnable) {
      if(i >= ID_FIRSTDDEEDIT)
	 EnableWindow(GetWindow(hWndEdit, GW_HWNDPREV), TRUE);
      EnableWindow(hWndEdit, TRUE);
      if(hValue) {
	 SendMessage(hWndEdit, WM_SETTEXT, 0, (LONG)(LPSTR)LocalLock(hValue));
	 LocalUnlock(hValue);
      } else
	 goto ClearEdit;
   } else {
      if(GetFocus() == hWndEdit)
	 SendMessage(hDlg, WM_NEXTDLGCTL, GetDlgItem(hDlg, ID_CLASSID), 1L);
      EnableWindow(GetWindow(hWndEdit, GW_HWNDPREV), FALSE);
      EnableWindow(hWndEdit, FALSE);
ClearEdit:
      SendMessage(hWndEdit, WM_SETTEXT, 0, (LONG)(LPSTR)"");
   }
}


int FAR PASCAL EditDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static HANDLE hCustExes = NULL;

   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hDlg;
      return(FALSE);

   case WM_DESTROY:
      GetLocalCopies(GetDlgItem(hDlg, ID_CLASSNAME), NULL);
      break;

   case WM_COMMAND:
      switch(wParam) {
      case ID_SAVEACTION:
         wParam = IsDlgButtonChecked(hDlg, ID_OPENRADIO)
               ? ID_OPENRADIO : ID_PRINTRADIO;
/* We fall through here */
      case ID_OPENRADIO:
      case ID_PRINTRADIO:
       {
         WORD wOld, wNew, wTemp, wErrMsg = NULL;
         BOOL bCheck;
         HWND hWndEdit;
         int i;

         wOld = (ID_LASTEDIT-ID_FIRSTACTIONEDIT+1) *
               (IsDlgButtonChecked(hDlg, ID_OPENRADIO) ? 0 : 1);
         wNew = wParam==ID_OPENRADIO ? 0 : 1;
         bCheck = cUsesDDE[wNew];
         wNew *= ID_LASTEDIT-ID_FIRSTACTIONEDIT+1;

         for(i=ID_FIRSTACTIONEDIT; i<=ID_LASTEDIT; ++i, ++wOld, ++wNew) {
	    if(wTemp=StoreValue(hWndEdit=GetDlgItem(hDlg, i), pLocalVals+wOld))
	       wErrMsg = wTemp;

	    SetValue(hDlg, i, hWndEdit, pLocalVals[wNew], i<ID_FIRSTDDEEDIT ||
		  (bCheck && (i!=(ID_FIRSTDDEEDIT+1) || SendDlgItemMessage(hDlg,
		  ID_FIRSTDDEEDIT, WM_GETTEXTLENGTH, 0, 0L))));
         }

         CheckDlgButton(hDlg, ID_USESDDE, bCheck);
         EnableWindow(GetDlgItem(hDlg, ID_GROUPDDE), bCheck);
         CheckRadioButton(hDlg, ID_OPENRADIO, ID_PRINTRADIO, wParam);

         if(wErrMsg)
            MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
         break;
       }

      case ID_USESDDE:
       {
         WORD wOld;

         wOld = IsDlgButtonChecked(hDlg, ID_OPENRADIO) ? 0 : 1;
         cUsesDDE[wOld] = (char)(!IsDlgButtonChecked(hDlg, ID_USESDDE));
         SendMessage(hDlg, WM_COMMAND, ID_SAVEACTION, 0L);
         break;
       }

      case ID_FIRSTDDEEDIT:
	 if(HIWORD(lParam) == EN_CHANGE) {
	    BOOL bCheck, bEnabled;
	    HWND hWndEdit;
	    WORD wNew;

	    hWndEdit = GetDlgItem(hDlg, ID_FIRSTDDEEDIT+1);
	    bEnabled = IsWindowEnabled(hWndEdit);
	    bCheck = (BOOL)SendMessage(LOWORD(lParam), WM_GETTEXTLENGTH, 0, 0L);
	    if((bCheck && bEnabled) || (!bCheck && !bEnabled))
	       break;

	    wNew = ID_FIRSTDDEEDIT+1-ID_FIRSTACTIONEDIT;
	    if(!IsDlgButtonChecked(hDlg, ID_OPENRADIO))
	       wNew += ID_LASTEDIT-ID_FIRSTACTIONEDIT+1;

	    if(StoreValue(hWndEdit, pLocalVals+wNew))
	       break;
	    SetValue(hDlg, ID_FIRSTDDEEDIT+1, hWndEdit, pLocalVals[wNew],
		  bCheck);
	 }
	 break;

      case IDOK:
       {
         HANDLE hId;
	 HWND hWndName;
         WORD wErrMsg = IDS_INVALIDNAME;
	 WORD wErrCtl = ID_CLASSNAME;

         if(!SendMessage(hWndName=GetDlgItem(hDlg, ID_CLASSNAME),
	       WM_GETTEXTLENGTH, 0, 0L))
	    goto Error1_1;

         wErrMsg = IDS_OUTOFMEMORY;
	 wErrCtl = NULL;
	 /* Update our memory handles for the current action */
         SendMessage(hDlg, WM_COMMAND, ID_SAVEACTION, 0L);

	 /* Get the current class id */
         if(!(hId=GetEditString(GetDlgItem(hDlg, ID_CLASSID))))
            goto Error1_1;

         if((fMode&(FLAG_NEW|FLAG_COPY)) && (wErrMsg=CreateId(hId))) {
	    PSTR pId;

	    MyMessageBox(hDlg, wErrMsg, MB_OK, lstrlen(pId=LocalLock(hId)),
		  (LPSTR)pId);
	    SetFocus(GetDlgItem(hDlg, ID_CLASSID));

	    LocalUnlock(hId);
	    LocalFree(hId);
            break;
	 }

	 /* Merge the data with the given class */
         if(wErrMsg=MergeData(hWndName, hId))
            goto Error1_2;
         EndDialog(hDlg, hId);
         break;

Error1_2:
         LocalFree(hId);
Error1_1:
         MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
	 if(wErrCtl)
	    SetFocus(GetDlgItem(hDlg, wErrCtl));
         break;
       }

      case IDCANCEL:
         EndDialog(hDlg, FALSE);
         break;

      case ID_BROWSE:
       {
         HANDLE hPath, hLocPath;
         LPSTR lpPath;
         HWND hWndEdit, hWndApp;

         wHelpId = IDW_OPENEXE;
         if(!DoFileOpenDlg(hDlg, IDS_BROWSETITLE, IDS_EXES, IDS_CUSTEXES,
               &hCustExes, &hPath, TRUE))
            break;
         lpPath = GlobalLock(hPath);

         hWndApp = GetDlgItem(hDlg, ID_FIRSTDDEEDIT+2);
         if(IsDlgButtonChecked(hDlg, ID_USESDDE) &&
               !SendMessage(hWndApp, WM_GETTEXTLENGTH, 0, 0L) &&
               (hLocPath=StringToLocalHandle(lpPath, LMEM_MOVEABLE))) {
            SendMessage(hWndApp, WM_SETTEXT, 0,
                  (DWORD)((LPSTR)GetAppName(hLocPath)));
            SendMessage(hWndApp, EM_SETMODIFY, 1, 0L);
            LocalFree(hLocPath);
         }
            
         hWndEdit = GetDlgItem(hDlg, ID_COMMAND);
         SendMessage(hWndEdit, WM_SETTEXT, 0, (DWORD)lpPath);
         SendMessage(hWndEdit, EM_SETMODIFY, 1, 0L);

         GlobalUnlock(hPath);
         GlobalFree(hPath);
         break;
       }

      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hDlg)
            break;
      case ID_HELPBUTTON:
         MyHelp(hDlg, HELP_CONTEXT, IDW_MODIFY+fMode);
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_INITDIALOG:
    {
      HANDLE hId, hTitle;
      HWND hWndId, hWndName;
      WORD wErrMsg;

      hId = GetListboxString(hWndIds,
            (WORD)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L));

      hWndName = GetDlgItem(hDlg, ID_CLASSNAME);
      if(fMode&FLAG_NEW) {
         if(wErrMsg=GetLocalCopies(hWndName, NULL))
            goto Error2_1;
         cUsesDDE[0] = cUsesDDE[1] = 1;
      } else {
         wErrMsg = IDS_OUTOFMEMORY;
         if(!hId || (wErrMsg=GetLocalCopies(hWndName, hId)))
            goto Error2_1;
      }

      hWndId = GetDlgItem(hDlg, ID_CLASSID);
      SendMessage(hWndId, EM_LIMITTEXT, MAX_KEY_LENGTH-1, 0L);
      if(fMode&(FLAG_NEW|FLAG_COPY)) {
         DestroyWindow(GetDlgItem(hDlg, ID_STATCLASSID));

         wErrMsg = IDS_OUTOFMEMORY;
         if(!(hTitle=MyLoadString(fMode&FLAG_NEW ? IDS_ADD : IDS_COPY, NULL,
               LMEM_MOVEABLE)))
            goto Error2_1;
         SendMessage(hDlg, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hTitle)));
         LocalUnlock(hTitle);
         LocalFree(hTitle);

         SetFocus(hWndId);
      } else {
         DestroyWindow(hWndId);
         hWndId = GetDlgItem(hDlg, ID_STATCLASSID);
         SetWindowWord(hWndId, GWW_ID, ID_CLASSID);

         SendMessage(hWndId, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hId)));
         LocalUnlock(hId);

         SetFocus(GetDlgItem(hDlg, ID_CLASSNAME));
      }

      CheckRadioButton(hDlg, ID_OPENRADIO, ID_PRINTRADIO, ID_OPENRADIO);
      SendMessage(hDlg, WM_COMMAND, ID_OPENRADIO, 0L);

      if(hId)
         LocalFree(hId);
      return(FALSE);

Error2_1:
      MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
      PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
      if(hId)
         LocalFree(hId);
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


int FAR PASCAL MainWndDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static int nTop;

   switch(message) {
   case WM_COMMAND:
      switch(wParam) {
      case ID_NAMELIST:
         if(HIWORD(lParam) == LBN_DBLCLK)
            SendMessage(hWndMain, WM_COMMAND, ID_MODIFY, 0L);
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_SIZE:
    {
      RECT rcList, rcWnd;
      int hgtWnd, hgt;

      hgtWnd = HIWORD(lParam) + 1;
      hgt = hgtWnd - nTop;
      SetWindowPos(hWndNames, NULL, -1, nTop, LOWORD(lParam)+2, hgt,
            SWP_NOZORDER);
      GetWindowRect(hWndNames, &rcList);
      ScreenToClient(hDlg, (POINT *)(&rcList) + 1);
      if(rcList.bottom != hgtWnd) {
         GetWindowRect(hDlg, &rcWnd);
         SetWindowPos(hDlg, NULL, 0, 0, rcWnd.right-rcWnd.left,
               rcWnd.bottom-rcWnd.top-hgtWnd+rcList.bottom,
               SWP_NOMOVE | SWP_NOZORDER);
      }
      break;
    }

   case WM_INITDIALOG:
    {
      RECT rcTemp;

      GetWindowRect(GetDlgItem(hDlg, ID_NAMELIST), &rcTemp);
      ScreenToClient(hDlg, (POINT *)&rcTemp);
      nTop = rcTemp.top;
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


long FAR PASCAL MainWnd(HWND hWnd, WORD iMessage, WORD wParam, LONG lParam)
{
   HCURSOR oldCursor;

   switch(iMessage) {
   case WM_ACTIVATE:
      if(wParam)
	 break;
      goto DoDefault;

   case WM_CREATE:
    {
      WORD wErrMsg = IDS_OUTOFMEMORY;

      if(!(lpMainWndDlg=MakeProcInstance(MainWndDlg, hInstance)))
         goto Error1_1;
      if(!(hWndDlg=CreateDialog(hInstance, MAKEINTRESOURCE(MAINWND), hWnd,
            lpMainWndDlg)))
         goto Error1_1;

      hWndNames = GetDlgItem(hWndDlg, ID_NAMELIST);
      hWndIds = GetDlgItem(hWndDlg, ID_IDLIST);

      if(wErrMsg=ResetClassList(hWndIds, hWndNames))
         goto Error1_1;

      ShowWindow(hWndDlg, SW_SHOW);
      goto DoDefault;

Error1_1:
      MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
      DestroyWindow(hWnd);
      break;
    }

   /* Return 1 to say it's OK to close
    */
   case WM_CLOSE:
   case WM_QUERYENDSESSION:
      return(1L);

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

      switch(wParam) {
      case ID_FINISHMERGE:
       {
         WORD wErrMsg;

         if(wErrMsg=ResetClassList(hWndIds, hWndNames))
            MyMessageBox(GetLastActivePopup(hWnd), wErrMsg, MB_OK, 0);
         break;
       }

      case ID_ADD:
         fMode = FLAG_NEW;
         goto DoDlg;
      case ID_COPY:
         fMode = FLAG_COPY;
         goto DoDlg;
      case ID_MODIFY:
         fMode = 0;
DoDlg:
       {
         HANDLE hId, hName;
         PSTR pId, pName;
         WORD wErrMsg = IDS_OUTOFMEMORY;
         int nNewId;

         if(!(hId=DoDialogBox(MAKEINTRESOURCE(EDITDLG), hWnd, EditDlg)))
            break;
         if(hId == 0xffff)
            goto Error2_1;

         if(wErrMsg=MyGetClassName(hId, &hName))
            goto Error2_2;

         if(wParam == ID_MODIFY) {
            int nClassId;

            nClassId = (WORD)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L);

            SendMessage(hWndNames, WM_SETREDRAW, 0, 0L);
            SendMessage(hWndNames, LB_DELETESTRING, nClassId, 0L);
            SendMessage(hWndIds, LB_DELETESTRING, nClassId, 0L);
            SendMessage(hWndNames, WM_SETREDRAW, 1, 0L);
         }

         pName = LocalLock(hName);
         pId = LocalLock(hId);

         wErrMsg = IDS_OUTOFMEMORY;
         if((nNewId=(int)SendMessage(hWndNames, LB_ADDSTRING, 0,
               (DWORD)((LPSTR)pName)))!=LB_ERR
               && SendMessage(hWndIds, LB_INSERTSTRING, nNewId,
                  (DWORD)((LPSTR)pId))!=LB_ERR)
            wErrMsg = NULL;
         SendMessage(hWndNames, LB_SETCURSEL, nNewId, 0L);

         LocalUnlock(hId);
         LocalUnlock(hName);
         LocalFree(hName);
Error2_2:
         LocalFree(hId);
Error2_1:
         if(wErrMsg)
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         break;
       }

      case ID_DELETE:
       {
         HANDLE hId, hName;
         WORD wErrMsg = IDS_OUTOFMEMORY;
	 PSTR pName;
         int nClassId;

         if((nClassId=(int)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L))
               == LB_ERR)
            break;
         if(!(hId=GetListboxString(hWndIds, nClassId)))
            goto Error4_1;
         if(!(hName=GetListboxString(hWndNames, nClassId)))
            goto Error4_2;
	 pName = LocalLock(hName);

         wErrMsg = NULL;
         if(MyMessageBox(hWnd, IDS_SUREDELETE, MB_ICONEXCLAMATION | MB_YESNO,
               lstrlen(pName), (LPSTR)pName) != IDYES)
            goto Error4_3;
         if(wErrMsg=DeleteClassId(hId))
            goto Error4_3;

         SendMessage(hWndIds, LB_DELETESTRING, nClassId, 0L);
         SendMessage(hWndNames, LB_DELETESTRING, nClassId, 0L);
         if(SendMessage(hWndNames, LB_SETCURSEL, nClassId, 0L) == LB_ERR)
            SendMessage(hWndNames, LB_SETCURSEL, --nClassId, 0L);

Error4_3:
         LocalUnlock(hName);
         LocalFree(hName);
Error4_2:
         LocalFree(hId);
Error4_1:
         if(wErrMsg)
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         break;
       }

      default:
         break;
      }

      SetCursor(oldCursor);
      break;

   default:
DoDefault:
      return(DefWindowProc(hWnd, iMessage, wParam, lParam));
      break;
   }
   return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC 
*/

#define Dereference(x)	x=x;

#ifdef _WIN32
/*XLATOFF*/
#pragma warning (disable:4209)		// turn off redefinition warning (with vmm.h)
/*XLATON*/
#endif // #ifdef _WIN32

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef	DWORD		HKEY;
#endif

#ifdef _WIN32
/*XLATOFF*/
#pragma warning (default:4209)		// turn on redefinition warning (with vmm.h)
/*XLATON*/
#endif // #ifdef _WIN32

#define MAXKEYNAME		256
		// Max length of a key name string
#define MAXVALUENAME_LENGTH	MAXKEYNAME
		// Max length of a value name string
#define MAXDATA_LENGTH          1024L
		// Max length of a value data item
		

#ifndef REG_SZ
#define REG_SZ		0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY	0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 * 	we should make these equates  conditional 
 */


#ifndef	ERROR_SUCCESS			
#define ERROR_SUCCESS			0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND		2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32	0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_LOCAL_MACHINE	// to avoid compilation warnings
#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA		0x80000006
#endif		// ifndef HKEY_LOCAL_MACHINE

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS	7
#endif

#define MAXREGFILES		HKEY_PREDEF_KEYS	

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx		0x100
#define RegCreateKey_Idx	0x101
#define RegCloseKey_Idx		0x102
#define RegDeleteKey_Idx	0x103
#define RegSetValue_Idx		0x104
#define RegQueryValue_Idx	0x105
#define RegEnumKey_Idx		0x106
#define RegDeleteValue_Idx	0x107
#define RegEnumValue_Idx	0x108
#define RegQueryValueEx_Idx	0x109
#define RegSetValueEx_Idx	0x10A
#define RegFlushKey_Idx		0x10B
#define RegLoadKey_Idx		0x10C
#define RegUnLoadKey_Idx	0x10D
#define RegSaveKey_Idx		0x10E
#define RegRestore_Idx		0x10F
#define RegRemapPreDefKey_Idx	0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//	RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD	dwRQR_Err;		// Error code
DWORD	hRQR_RootKey;		// Root key for file
DWORD	dwRQR_Reference;	// Reference data for RegRestore
char	szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
char	szRQR_FileName[256];	// File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE

#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

typedef struct _REGISTRY_ROOT {
    LPSTR lpKeyName;
    HKEY hKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG       5
#define INDEX_HKEY_DYN_DATA             6

//  #define NUMBER_REGISTRY_ROOTS           7
#define NUMBER_REGISTRY_ROOTS           6

//  This is supposed to be enough for one keyname plus one predefined
//  handle name.  The longest predefined handle name is < 25 characters, so
//  this gives us room for growth should more predefined keys be added.

#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const CHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

DWORD
PASCAL
CreateRegistryKey(
    LPHKEY lphKey,
    LPSTR lpFullKeyName,
    BOOL fCreate
    );

VOID
PASCAL
ImportRegFile(
    LPSTR lpFileName
    );

VOID
PASCAL
ExportWin40RegFile(
    LPSTR lpFileName,
    LPSTR lpSelectedPath
    );

VOID
PASCAL
ImportRegFileUICallback(
    UINT Percentage
    );

LONG RegSetValueEx(
    HKEY             hKey,        // handle of key to set value for
    LPCSTR           lpValueName, // address of value to set
    DWORD            Reserved,    // reserved
    DWORD            dwType,      // flag for value type
    CONST BYTE FAR * lpData,      // address of value data
    DWORD            cbData       // size of value data
   );

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regmain.c ===
#define WIN31
#include <windows.h>
#include "RegEdit.h"
#include "SDKRegEd.h"


/*********************************************************/
/******************* Globals *****************************/
/*********************************************************/

char szAppName[] = "Registration Editor" ;
char szSDKRegEd[] = "SDKRegEd";
char *pszLongName;
char *pszOutOfMemory;

extern char szNull[];

HANDLE hInstance;
HWND hWndMain, hWndDlg = NULL, hWndHelp;
LPSTR lpCmdLine;
WORD wCmdFlags, wHelpMenuItem, wHelpId, wHelpMain;
LONG (FAR PASCAL *lpfnEditor)(HWND, WORD, WORD, LONG);
FARPROC lpOldHook;
FARPROC lpMainWndDlg = NULL;
WORD wHelpIndex;
HANDLE hAcc;
BOOL fOpenError = FALSE;


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

unsigned long NEAR PASCAL RetSetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
   return(RegSetValue(hKey, pSubKey, REG_SZ, pVal, 0L));
}

#ifndef REGLOAD
unsigned long NEAR PASCAL WriteThroughSetValue(HKEY hKey, PSTR pSubKey,
      PSTR pVal)
{
   long lRet;

   if (!(lRet=RegSetValue(hKey, pSubKey, REG_SZ, pVal, 0L)))
      lRet = SDKSetValue(hKey, pSubKey, pVal);
   return(lRet);
}
#endif

unsigned long (NEAR PASCAL *lpfnSetValue)(HKEY, PSTR, PSTR) = RetSetValue;


unsigned long NEAR PASCAL MySetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
  return((*lpfnSetValue)(hKey, pSubKey, pVal));
}


VOID NEAR PASCAL GetCommandFlags(void)
{
   wCmdFlags = 0;

   while(1) {
/* skip spaces */
      while(*lpCmdLine == ' ')
	 ++lpCmdLine;
/* check if this is a command line switch */
      if(*lpCmdLine!='/' && *lpCmdLine!='-')
	 break;
      ++lpCmdLine;

/* set known flags */
      while(*lpCmdLine && *lpCmdLine!=' ') {
	 switch(*lpCmdLine) {
	 case('s'): /* for silent */
	 case('S'): /* for silent */
	    wCmdFlags |= FLAG_SILENT;
	    break;

	 case('v'): /* use tree editor */
	 case('V'): /* use tree editor */
	    wCmdFlags |= FLAG_VERBOSE;
	    break;

	 case('u'): /* update, don't overwrite existing path entries */
	 case('U'): /* in shell\open\command or shell\open\print */
	    wCmdFlags |= FLAG_LEAVECOMMAND;
	    break;
	 }

	 lpCmdLine = AnsiNext(lpCmdLine);
      }
   }
}


#ifndef REGLOAD
long FAR PASCAL WndProc(HWND hWnd, WORD wMessage, WORD wParam, LONG lParam)
{
   static HANDLE hCustRegs = NULL;

   HCURSOR oldCursor;

   switch(wMessage) {
   case WM_ACTIVATE:
      if(wParam) {
	 hWndHelp = hWnd;
	 SetFocus(hWndDlg);
      }
      break;

   case WM_CREATE:
    {
      RECT rcWnd, rcClt;

      DragAcceptFiles(hWnd, TRUE);

      lpfnEditor(hWnd, wMessage, wParam, lParam);

      if((rcWnd.right=MyGetProfileInt(IDS_SHORTNAME, IDS_WIDTH, 0))<=0 ||
	    (rcWnd.bottom=MyGetProfileInt(IDS_SHORTNAME, IDS_HEIGHT, 0))<=0) {
	 GetWindowRect(hWndDlg, &rcWnd);
	 rcWnd.right -= rcWnd.left;
	 rcWnd.bottom -= rcWnd.top;
      }
      GetClientRect(hWnd, &rcClt);
      rcClt.right -= rcWnd.right;
      rcClt.bottom -= rcWnd.bottom;
      GetWindowRect(hWnd, &rcWnd);

      SetWindowPos(hWnd, NULL, 0, 0, rcWnd.right-rcWnd.left-rcClt.right,
	    rcWnd.bottom-rcWnd.top-rcClt.bottom, SWP_NOMOVE | SWP_NOZORDER);

      return(DefWindowProc(hWnd, wMessage, wParam, lParam));
    }

   case WM_CLOSE:
   case WM_QUERYENDSESSION:
    {
      HKEY hKeyRoot;
      WORD wErrMsg;
      int nReturn;

      if(!fOpenError) {
	 if(!lpfnEditor(hWnd, wMessage, wParam, lParam))
	    return(0L);

	 if(RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKeyRoot) == ERROR_SUCCESS) {
	    if(wErrMsg=GetErrMsg((WORD)RegCloseKey(hKeyRoot))) {
	       PSTR pError;

	       if(pError=(PSTR)MyLoadString(wErrMsg, NULL, LMEM_FIXED)) {
		  nReturn = MyMessageBox(hWnd, IDS_ENDERROR,
			MB_YESNO|MB_ICONHAND|MB_SYSTEMMODAL, lstrlen(pError),
			(LPSTR)pError);
		  LocalFree((HANDLE)pError);
	       } else
		  /* Notice the flags are ignored for OOM
		   */
		  nReturn = MyMessageBox(hWnd, IDS_OUTOFMEMORY,
			MB_OK|MB_ICONHAND|MB_SYSTEMMODAL, 0);

	       if(nReturn != IDYES)
		  return(0L);
	    }
	 }
      }

      return(DefWindowProc(hWnd, wMessage, wParam, lParam));
    }

   case WM_DESTROY:
      if(hWndDlg)
	 DestroyWindow(hWndDlg);
      if(lpMainWndDlg)
	 FreeProcInstance(lpMainWndDlg);

#ifndef NOHELP
      WinHelp(hWnd, NULL, HELP_QUIT, 0L);
#endif

      DragAcceptFiles(hWnd, FALSE);
      PostQuitMessage(0);
      break;

   case WM_SIZE:
    {
      RECT rcDlg, rcWnd;
      int hgt;

      if(wParam == SIZEICONIC)
	 break;

      if(!hWndDlg) {
	 /* This should only happen during the create message
	  */
	 PostMessage(hWnd, wMessage, wParam, lParam);
	 break;
      }

      if(wParam == SIZENORMAL) {
	 WriteProfileInt(IDS_SHORTNAME, IDS_WIDTH, LOWORD(lParam));
	 WriteProfileInt(IDS_SHORTNAME, IDS_HEIGHT, HIWORD(lParam));
      }

      hgt = HIWORD(lParam);
      SetWindowPos(hWndDlg, NULL, 0, 0, LOWORD(lParam), hgt, SWP_NOZORDER);
      GetWindowRect(hWndDlg, &rcDlg);
      ScreenToClient(hWnd, (POINT *)(&rcDlg) + 1);
      if((WORD)rcDlg.bottom != HIWORD(lParam)) {
	 GetWindowRect(hWnd, &rcWnd);
	 SetWindowPos(hWnd, NULL, 0, 0, rcWnd.right-rcWnd.left,
	       rcWnd.bottom-rcWnd.top-HIWORD(lParam)+rcDlg.bottom,
	       SWP_NOMOVE | SWP_NOZORDER);
      }
      break;
    }

   case WM_DROPFILES:
    {
      int result, i, nFileName;
      HANDLE hFileName;
      WORD wFlags;

      wFlags = (GetKeyState(VK_CONTROL)&0x8000) ? FLAG_SILENT : 0;

      lpfnEditor(hWnd, wMessage, wParam, lParam);

      for(result=DragQueryFile(wParam, (UINT)-1, NULL, 0), i=0; i<result; ++i) {
	 if(!(hFileName=GlobalAlloc(GMEM_MOVEABLE,
	       (DWORD)(nFileName=DragQueryFile(wParam, i, NULL, 0)+1))))
	    continue;
	 DragQueryFile(wParam, i, GlobalLock(hFileName), nFileName);
	 GlobalUnlock(hFileName);
	 SendMessage(hWnd, WM_COMMAND, ID_FINISHMERGE,
	       MAKELONG(hFileName,wFlags));
      }

      DragFinish(wParam);

      return(TRUE);
    }

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      switch(wParam) {
      case ID_HELP:
	 if(HIWORD(lParam)==MSGF_MENU && IsWindowEnabled(hWnd)
	       && wHelpMenuItem) {
	    WORD m = wHelpMenuItem;

/* Get outta menu mode if help for a menu item */
	    SendMessage(hWnd, WM_CANCELMODE, 0, 0L);

	    MyHelp(hWnd, HELP_CONTEXT, m);
	 }
	 break;

      case ID_FINISHMERGE:
       {
     unsigned long (NEAR PASCAL *lpfnSave)(HKEY, PSTR, PSTR);

	 /* If there was a file selected then merge it; otherwise,
	  * just let lpfnEditor do its cleanup (at the end of the switch)
	  */
	 if (LOWORD(lParam)) {
	    lpfnSave = lpfnSetValue;
	    if (HIWORD(lParam)&FLAG_WRITETHROUGH && lpfnSetValue==SDKSetValue)
		lpfnSetValue = WriteThroughSetValue;

	    lpfnEditor(hWnd, WM_COMMAND, ID_MERGEFILE, 0L);

	    ProcessFiles(GetLastActivePopup(hWnd), LOWORD(lParam),
		  HIWORD(lParam));
	    lpfnSetValue = lpfnSave;
	 }
	 break;
       }

      case ID_MERGEFILE:
       {
	 HANDLE hPath;

	 lpfnEditor(hWnd, wMessage, wParam, lParam);

	 wHelpId = IDW_OPENREG;
	 if(!DoFileOpenDlg(hWnd, IDS_MERGETITLE, IDS_REGS, IDS_CUSTREGS,
	       &hCustRegs, &hPath, TRUE))
	    hPath = NULL;
	 SendMessage(hWnd, WM_COMMAND, ID_FINISHMERGE, MAKELONG(hPath, 0));

	 return(TRUE);
       }

      case ID_WRITEFILE:
       {
	 HANDLE hPath;

	 wHelpId = IDW_SAVEREG;
	 if(DoFileOpenDlg(hWnd, IDS_WRITETITLE, IDS_REGS, IDS_CUSTREGS,
	       &hCustRegs, &hPath, FALSE))
	    lParam = (LONG)hPath;
	 else
	    lParam = NULL;
	 break;
       }

      case ID_EXIT:
	 PostMessage(hWnd, WM_CLOSE, 0, 0L);
	 break;

      case ID_HELPINDEX:
	 MyHelp(hWnd, HELP_CONTEXT, wHelpIndex);
	 break;

      case ID_HELPSEARCH:
	 MyHelp(hWnd, HELP_PARTIALKEY, (DWORD)(LPSTR)"");
	 break;

      case ID_HELPUSINGHELP:
	 MyHelp(hWnd, HELP_HELPONHELP, 0);
	 break;

      case ID_ABOUT:
       {
	 HANDLE hShortName, hDesc;

	 if(!(hShortName=MyLoadString(IDS_MEDIUMNAME, NULL, LMEM_MOVEABLE)))
	    goto Error3_1;
	 if(!(hDesc=MyLoadString(IDS_DESCRIPTION, NULL, LMEM_MOVEABLE)))
	    goto Error3_2;

	 ShellAbout(hWnd, LocalLock(hShortName), LocalLock(hDesc),
	       LoadIcon(hInstance, MAKEINTRESOURCE(MAINICON)));

	 LocalUnlock(hDesc);
	 LocalUnlock(hShortName);
	 LocalFree(hDesc);
Error3_2:
	 LocalFree(hShortName);
Error3_1:
	 break;
       }

      default:
	 break;
      }
      SetCursor(oldCursor);
      break;

   case WM_MENUSELECT:
      if(LOWORD(lParam)&MF_POPUP)
	 wHelpMenuItem = 0;
      else if(LOWORD(lParam)&MF_SYSMENU)
	 wHelpMenuItem = IDH_SYSMENU;
      else
	 wHelpMenuItem = wHelpMain+wParam;
      break;

   default:
      break;
   }

   return(lpfnEditor(hWnd, wMessage, wParam, lParam));
}


BOOL NEAR PASCAL CreateMainWindow(void)
{
   WNDCLASS wndclass;

   wndclass.style         = 0;
   wndclass.lpfnWndProc   = (WNDPROC)WndProc;
   wndclass.cbClsExtra    = 0;
   wndclass.cbWndExtra    = 0;
   wndclass.hInstance     = hInstance;
   wndclass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(MAINICON));
   wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
   wndclass.hbrBackground = COLOR_APPWORKSPACE + 1;
   wndclass.lpszClassName = szAppName;

   if(wCmdFlags&FLAG_VERBOSE) {
      wndclass.lpszMenuName  = MAKEINTRESOURCE(SDKMAINMENU);
      lpfnEditor = SDKMainWnd;
      lpfnSetValue = SDKSetValue;
      wHelpMain = IDW_SDKMAIN;
      wHelpIndex = IDW_SDKMAIN + 0x0100 + ID_HELPINDEX;
   } else {
      wndclass.lpszMenuName  = MAKEINTRESOURCE(MAINMENU);
      lpfnEditor = MainWnd;
      wHelpMain = IDW_MAIN;
      wHelpIndex = IDW_MAIN + 0x0100 + ID_HELPINDEX;
   }

   return(RegisterClass(&wndclass)
	 && (hWndMain=CreateWindow(szAppName, pszLongName,
	    WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
	    CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL)));
}
#endif


int PASCAL WinMain (HANDLE hInst, HANDLE hPrevInstance,
      LPSTR lpszCmdLine, int nCmdShow)
{
   HANDLE hTemp, hCmd = NULL;
#ifndef REGLOAD
   FARPROC lpMessageFilter;
   MSG msg;
   VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
#endif

   hInstance = hInst;

   lpCmdLine = lpszCmdLine;
   GetCommandFlags();

   if(!(hTemp=MyLoadString(IDS_LONGNAME, NULL, LMEM_FIXED)))
      return(FALSE);
   pszLongName = LocalLock(hTemp);
   if(!(hTemp=MyLoadString(IDS_OUTOFMEMORY, NULL, LMEM_FIXED)))
      return(FALSE);
   pszOutOfMemory = LocalLock(hTemp);

   if(*lpCmdLine && !(hCmd=StringToHandle(lpCmdLine)))
      return(FALSE);

#ifdef REGLOAD
   if ((hTemp=GetModuleHandle("REGEDIT")) > 1) {
      PSTR pLocal;
      WORD wFileLen = 130;
      WORD wCmdLen = lstrlen(lpCmdLine) + 1;

      while(1) {
	 if(!(pLocal=(PSTR)LocalAlloc(LMEM_FIXED, wFileLen+wCmdLen))) {
	    MyMessageBox(NULL, IDS_OUTOFMEMORY,
		  MB_OK|MB_ICONHAND|MB_SYSTEMMODAL, 0);
	    return(FALSE);
	 }
	 if(GetModuleFileName(hTemp, pLocal, wFileLen) < (int)wFileLen-5)
	    break;

	 LocalFree((HANDLE)pLocal);
	 wFileLen += 130;
      }

      lstrcat(pLocal, " ");
      lstrcat(pLocal, lpCmdLine);

      return(WinExec(pLocal, SW_SHOWNORMAL) > 32);
   }
#else
   if(hPrevInstance) {
      GetInstanceData(hPrevInstance, (PSTR)&hWndMain, sizeof(hWndMain));
      if(hCmd)
	 PostMessage(hWndMain, WM_COMMAND, ID_FINISHMERGE,
	       MAKELONG(hCmd, wCmdFlags | FLAG_WRITETHROUGH));
      else {
	 SetWindowPos(hWndMain, NULL, 0, 0, 0, 0,
	       SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	 if(IsIconic(hWndMain))
	    ShowWindow(hWndMain, SW_RESTORE);
	 else
	    SetActiveWindow(GetLastActivePopup(hWndMain));
      }
      return(TRUE);
   }
#endif

   if(hCmd) {
      ProcessFiles(NULL, hCmd, wCmdFlags);
      return(TRUE);
   }

#ifdef REGLOAD
   return(TRUE);
#else
   if(!CreateMainWindow())
      return(FALSE);

   if(fOpenError)
      PostMessage(hWndMain, WM_COMMAND, ID_EXIT, 0L);
   else {
      ShowWindow(hWndMain, nCmdShow);
      UpdateWindow(hWndMain);
   }

   if(lpMessageFilter=MakeProcInstance(MessageFilter, hInstance))
      lpOldHook = SetWindowsHook(WH_MSGFILTER, lpMessageFilter);

   hAcc = LoadAccelerators(hInstance, wCmdFlags&FLAG_VERBOSE ?
	 szSDKRegEd : "RegEdit");

   if (lpfnRegisterPenApp = (VOID (FAR PASCAL *)(WORD, BOOL))GetProcAddress(GetSystemMetrics(SM_PENWINDOWS),
	 "RegisterPenApp"))
       (*lpfnRegisterPenApp)(1, TRUE);

   while(GetMessage(&msg, NULL, 0, 0)) {
      if(!hAcc || !TranslateAccelerator(hWndMain, hAcc, &msg)) {
	 if(!hWndDlg || !IsDialogMessage(hWndDlg, &msg)) {
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	 }
      }
   }

   if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)(1, FALSE);

   if(lpMessageFilter) {
      UnhookWindowsHook(WH_MSGFILTER, lpMessageFilter);
      FreeProcInstance(lpMessageFilter);
   }

   return(msg.wParam);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regporte.c ===
#include <windows.h>
#include <shellapi.h>
#include <stdlib.h>
#include <string.h>
#ifndef CHAR
#define CHAR char
#endif // ifndef CHAR
// from winreg.h:
// HKEY_CLASSES_ROOT already defined
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
#define HKEY_USERS                  (( HKEY ) 0x80000003 )
#define HKEY_PERFORMANCE_DATA       (( HKEY ) 0x80000004 )
#define HKEY_CURRENT_CONFIG         (( HKEY ) 0x80000005 )
#define HKEY_DYN_DATA               (( HKEY ) 0x80000006 )

#include "regdef.h" // regdef.h from \\guilo\slm\src\dev\inc)

//from pch.h, remove extern
CHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];
BYTE g_ValueDataBuffer[MAXDATA_LENGTH];

// interface to regmain values
extern LPSTR lpMerge;

#include "reg1632.h"
#include "regporte.h"
#include "regresid.h"


/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

//#include "pch.h"
//#include "regresid.h"
//#include "reg1632.h"

//  When building for the Registry Editor, put all of the following constants
//  in a read-only data section.
#ifdef WIN32
#pragma data_seg(DATASEG_READONLY)
#endif

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    "HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT,
    "HKEY_CURRENT_USER", HKEY_CURRENT_USER,
    "HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE,
    "HKEY_USERS", HKEY_USERS,
//    "HKEY_PERFORMANCE_DATA", HKEY_PERFORMANCE_DATA,
    "HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG,
    "HKEY_DYN_DATA", HKEY_DYN_DATA
};

const CHAR s_RegistryHeader[] = "REGEDIT";

const CHAR s_OldWin31RegFileRoot[] = ".classes";

const CHAR s_Win40RegFileHeader[] = "REGEDIT4\n\n";

const CHAR s_HexPrefix[] = "hex";
const CHAR s_DwordPrefix[] = "dword:";
const CHAR g_HexConversion[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
    '9', 'a', 'b', 'c', 'd', 'e', 'f'};
const CHAR s_FileLineBreak[] = ",\\\n  ";

#ifdef WIN32
#pragma data_seg()
#endif

#define SIZE_FILE_IO_BUFFER             512

typedef struct _FILE_IO {
    CHAR Buffer[SIZE_FILE_IO_BUFFER];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    );

VOID
NEAR PASCAL
ImportWin40RegFile(
    VOID
    );

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(
    LPSTR lpString,
    LPDWORD cbStringData
    );

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    );

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    LPCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    CHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    CHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    CHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    CHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

#ifdef DBCS
#ifndef WIN32
LPSTR
NEAR PASCAL
DBCSStrChr(
    LPSTR string,
    CHAR chr
    );

BOOL
NEAR PASCAL
IsDBCSLeadByte(
    BYTE chr
    );
#endif
#endif

/*******************************************************************************
*
*  CreateRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD
PASCAL
CreateRegistryKey(
    LPHKEY lphKey,
    LPSTR lpFullKeyName,
    BOOL fCreate
    )
{

    LPSTR lpSubKeyName;
    CHAR PrevChar;
    HKEY hRootKey;
    UINT Counter;
    DWORD Result;

    if ((lpSubKeyName = (LPSTR) STRCHR(lpFullKeyName, '\\')) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = '\0';

    }

    CHARUPPERSTRING(lpFullKeyName);

    hRootKey = NULL;

    for (Counter = 0; Counter < NUMBER_REGISTRY_ROOTS; Counter++) {

        if (STRCMP(g_RegistryRoots[Counter].lpKeyName, lpFullKeyName) == 0) {

            hRootKey = g_RegistryRoots[Counter].hKey;
            break;

        }

    }

    if (hRootKey) {

        Result = ERROR_CANTOPEN;

        if (fCreate) {

            if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

        else {

            if (RegOpenKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

    }

    else
        Result = ERROR_BADKEY;

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/
#ifdef WIN95
VOID
PASCAL
ImportRegFile(
    LPSTR lpFileName
    )
{

    CHAR Char;
    LPCCH lpHeader;
    BOOL fNewRegistryFile;
#ifdef WIN32
    OFSTRUCT OFStruct;
#endif

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    if (OPENREADFILE(lpFileName, s_FileIo.hFile)) {

        s_FileIo.FileSizeDiv100 = GETFILESIZE(s_FileIo.hFile) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.LastPercentage = 0;

        //
        //  The following will force GetChar to read in the first block of data.
        //

        s_FileIo.BufferOffset = SIZE_FILE_IO_BUFFER;

        SkipWhitespace();

        lpHeader = s_RegistryHeader;

        while (*lpHeader != '\0') {

            if (MatchChar(*lpHeader))
                lpHeader++;

            else
                break;

        }

        if (*lpHeader == '\0') {

            fNewRegistryFile = MatchChar('4');

            SkipWhitespace();

            if (GetChar(&Char) && IsNewLine(Char)) {

                if (fNewRegistryFile)
                    ImportWin40RegFile();

                else
                    ImportWin31RegFile();

            }

        }

        else
            g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;

}

/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    )
{

    HKEY hKey;
    CHAR Char;
    BOOL fSuccess;
    LPCSTR lpClassesRoot;
    CHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //

    if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;

    }

    while (TRUE) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar('\\'))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != '\0') {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar('\\');

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == ' ' || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= sizeof(KeyName) - 1) {

                    fSuccess = FALSE;
                    break;

                }

                KeyName[Index++] = Char;

            }

            if (fSuccess) {

                KeyName[Index] = '\0';

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar('='))
                    MatchChar(' ');

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                while (GetChar(&Char)) {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= MAXDATA_LENGTH - 1) {

                        fSuccess = FALSE;
                        break;

                    }

                    g_ValueDataBuffer[Index++] = Char;

                }

                if (fSuccess) {

                    g_ValueDataBuffer[Index] = '\0';

                    if (RegSetValue(hKey, KeyName, REG_SZ, g_ValueDataBuffer,
                        Index) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                }

            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}
#endif // ifdef WIN95
/*******************************************************************************
*
*  ImportWin40RegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin40RegFile(
    VOID
    )
{

    HKEY hLocalMachineKey;
    HKEY hUsersKey;
    HKEY hKey;
    CHAR Char;

    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        OutputDebugString("Unable to open HKEY_LOCAL_MACHINE\n\r");
    if (hUsersKey == NULL)
        OutputDebugString("Unable to open HKEY_USERS\n\r");
#endif

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case '[':
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey);

                break;

            case '"':
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case '@':
                //
                //
                //

                if (hKey != NULL)
                    ParseDefaultValue(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case ';':
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define SIZE_FULL_KEYNAME (MAXKEYNAME + 40)

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    )
{

    CHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    CHAR Char;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

        if (Char == ']')
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == ']')
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    }

    if (LastRightBracketIndex != -1) {

        FullKeyName[LastRightBracketIndex] = '\0';

        switch (CreateRegistryKey(lphKey, FullKeyName, TRUE)) {

            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;

        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{

    DWORD Type;
    CHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD cbData;
    LPCSTR lpPrefix;

    cbData = sizeof(ValueName);

    if (!ParseString(ValueName, &cbData))
        goto ParseError;

    SkipWhitespace();

    if (!MatchChar('='))
        goto ParseError;

    SkipWhitespace();

    //
    //  REG_SZ.
    //
    //  "ValueName" = "string of text"
    //

    if (MatchChar('"')) {

        //  LATER:  Line continuations for strings?

        cbData = MAXDATA_LENGTH;

        if (!ParseString(g_ValueDataBuffer, &cbData) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_SZ;

    }

    //
    //  REG_DWORD.
    //
    //  "ValueName" = dword: 12345678
    //

    else if (MatchChar(s_DwordPrefix[0])) {

        lpPrefix = &s_DwordPrefix[1];

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        SkipWhitespace();

        if (!ParseHexDword((LPDWORD) g_ValueDataBuffer) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_DWORD;
        cbData = sizeof(DWORD);

    }

    //
    //  REG_BINARY and other.
    //
    //  "ValueName" = hex: 00 , 11 , 22
    //  "ValueName" = hex(12345678): 00, 11, 22
    //

    else {

        lpPrefix = s_HexPrefix;

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        //
        //  Check if this is a type of registry data that we don't directly
        //  support.  If so, then it's just a dump of hex data of the specified
        //  type.
        //

        if (MatchChar('(')) {

            if (!ParseHexDword(&Type) || !MatchChar(')'))
                goto ParseError;

        }

        else
            Type = REG_BINARY;

        if (!MatchChar(':') || !ParseHexSequence(g_ValueDataBuffer, &cbData) ||
            !ParseEndOfLine())
            goto ParseError;

    }

    if (RegSetValueEx(hKey, ValueName, 0, Type, g_ValueDataBuffer, cbData) !=
        ERROR_SUCCESS)
        g_FileErrorStringID = IDS_IMPFILEERRREGSET;

    return;

ParseError:
    SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseDefaultValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    )
{

    BOOL fSuccess;
    DWORD cbData;

    fSuccess = FALSE;

    SkipWhitespace();

    if (MatchChar('=')) {

        SkipWhitespace();

        if (MatchChar('"')) {

            //  LATER:  Line continuations for strings?

            cbData = MAXDATA_LENGTH;

            if (ParseString(g_ValueDataBuffer, &cbData) && ParseEndOfLine()) {

                if (RegSetValue(hKey, NULL, REG_SZ, g_ValueDataBuffer,
                    cbData) != ERROR_SUCCESS)
                    g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                fSuccess = TRUE;

            }

        }

    }

    if (!fSuccess)
        SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(
    LPSTR lpString,
    LPDWORD lpcbStringData
    )
{

    CHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;

    cbMaxStringData = *lpcbStringData;
    cbStringData = 1;                   //  Account for the null terminator

    while (GetChar(&Char)) {

        if (cbStringData >= cbMaxStringData)
            return FALSE;

        switch (Char) {

            case '\\':
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case '\\':
                        *lpString++ = '\\';
                        break;

                    case '"':
                        *lpString++ = '"';
                        break;

                    default:
                        OutputDebugString("ParseString:  Invalid escape sequence");
                        return FALSE;

                }
                break;

            case '"':
                *lpString = '\0';
                *lpcbStringData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *lpString++ = Char;

#ifdef DBCS
		if (IsDBCSLeadByte((BYTE)Char))
		{
		    if (!GetChar(&Char))
			return FALSE;
		    *lpString++ = Char;
		}
#endif

                break;

        }

        cbStringData++;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    )
{

    DWORD cbHexData;

    cbHexData = 0;

    do {

        if (cbHexData >= MAXDATA_LENGTH)
            return FALSE;

        SkipWhitespace();

        if (MatchChar('\\') && !ParseEndOfLine())
            return FALSE;

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(','));

    *lpcbHexData = cbHexData;

    return TRUE;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    CHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= '0' && Char <= '9')
            Digit = (BYTE) (Char - '0');

        else if (Char >= 'a' && Char <= 'f')
            Digit = (BYTE) (Char - 'a' + 10);

        else if (Char >= 'A' && Char <= 'F')
            Digit = (BYTE) (Char - 'A' + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    CHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == ';')
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();

            break;

        }

    }

    return fFoundOneEndOfLine;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    LPCHAR lpChar
    )
{
#ifdef WIN95

    FILE_NUMBYTES NumberOfBytesRead;
    UINT NewPercentage;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER) {

        if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer,
            sizeof(s_FileIo.Buffer), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            return FALSE;

        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.CharsAvailable = ((int) NumberOfBytesRead);

        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
            ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;
#else
    if (*lpMerge) {
      *lpChar=*lpMerge++;
      return TRUE;
    } else
      return FALSE;
#endif // ifdef WIN95

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{
#ifdef WIN95
#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        OutputDebugString("REGEDIT ERROR: Too many UngetChar's called!\n\r");
#endif // ifdef DEBUG

    s_FileIo.BufferOffset--;
#else
    lpMerge--;
#endif // ifdef WIN95

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    CHAR CharToMatch
    )
{

    BOOL fMatch;
    CHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    CHAR Char
    )
{

    return Char == ' ' || Char == '\t';

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    CHAR Char
    )
{

    return Char == '\n' || Char == '\r';

}
#ifdef WIN95
/*******************************************************************************
*
*  ExportWin40RegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
ExportWin40RegFile(
    LPSTR lpFileName,
    LPSTR lpSelectedPath
    )
{

    HKEY hKey;
    CHAR SelectedPath[SIZE_SELECTED_PATH];

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && CreateRegistryKey(&hKey, lpSelectedPath,
        FALSE) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) {

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        PutLiteral(s_Win40RegFileHeader);

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else {

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPSTR lpFullKeyName
    )
{

    LONG RegError;
    DWORD EnumIndex;
    DWORD cbValueName;
    DWORD cbValueData;
    DWORD Type;
    LPSTR lpSubKeyName;
    int MaximumSubKeyLength;
    HKEY hSubKey;

    //
    //  Write out the section header.
    //

    PutChar('[');
    PutLiteral(lpFullKeyName);
    PutLiteral("]\n");

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE) {

        cbValueName = sizeof(g_ValueNameBuffer);
        cbValueData = MAXDATA_LENGTH;

        if ((RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cbValueName, NULL, &Type, g_ValueDataBuffer, &cbValueData))
            != ERROR_SUCCESS)
            break;

        //
        //  If cbValueName is zero, then this is the default value of
        //  the key, or the Windows 3.1 compatible key value.
        //

        if (cbValueName)
            PutString(g_ValueNameBuffer);

        else
            PutChar('@');

        PutChar('=');

        switch (Type) {

            case REG_SZ:
                PutString((LPSTR) g_ValueDataBuffer);
                break;

            case REG_DWORD:
                if (cbValueData == sizeof(DWORD)) {

                    PutLiteral(s_DwordPrefix);
                    PutDword(*((LPDWORD) g_ValueDataBuffer), TRUE);
                    break;

                }
                //  FALL THROUGH

            case REG_BINARY:
            default:
                PutBinary((LPBYTE) g_ValueDataBuffer, Type, cbValueData);
                break;

        }

        PutChar('\n');

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

    }

    PutChar('\n');

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    //
    //  Write out all of the subkeys and recurse into them.
    //

    lpSubKeyName = lpFullKeyName + STRLEN(lpFullKeyName);
    *lpSubKeyName++ = '\\';
    MaximumSubKeyLength = MAXKEYNAME - STRLEN(lpSubKeyName);

    EnumIndex = 0;

    while (TRUE) {

        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName,
            MaximumSubKeyLength)) != ERROR_SUCCESS)
            break;

        if (RegOpenKey(hKey, lpSubKeyName, &hSubKey) == ERROR_SUCCESS) {

            PutBranch(hSubKey, lpFullKeyName);

            RegCloseKey(hSubKey);

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;

        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;

    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCSTR lpLiteral
    )
{

    while (*lpLiteral != '\0')
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCSTR lpString
    )
{

    CHAR Char;

    PutChar('"');

    while ((Char = *lpString++) != '\0') {

        switch (Char) {

            case '\\':
            case '"':
                PutChar('\\');
                //  FALL THROUGH

            default:
                PutChar(Char);
#ifdef DBCS
		if (IsDBCSLeadByte((BYTE)Char))
			PutChar(*lpString++);
#endif
                break;

        }

    }

    PutChar('"');

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar('(');
        PutDword(Type, FALSE);
        PutChar(')');

    }

    PutChar(':');

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(',');

        Byte = *lpBuffer++;

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int CurrentNibble;
    CHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != '0') {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar('0');

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    CHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != '\n')
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar('\r');

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    FILE_NUMBYTES NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) {

        if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset,
            &NumberOfBytesWritten) || (FILE_NUMBYTES) s_FileIo.BufferOffset !=
            NumberOfBytesWritten)
            g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;

    }

    s_FileIo.BufferOffset = 0;

}
#endif // ifdef WIN95
#ifndef WIN32
/*******************************************************************************
*
*  GetFileSize
*
*  DESCRIPTION:
*     Returns the file size for the given file handle.
*
*     DESTRUCTIVE:  After this call, the file pointer will be set to byte zero.
*
*  PARAMETERS:
*     hFile, file handle opened via MS-DOS.
*     (returns), size of file.
*
*******************************************************************************/

DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    )
{

    DWORD FileSize;

    FileSize = _llseek(hFile, 0, SEEK_END);
    _llseek(hFile, 0, SEEK_SET);

    return FileSize;

}
#endif

#ifdef DBCS
#ifndef WIN32
/*******************************************************************************
*
*  DBCSSTRCHR
*
*  DESCRIPTION:
*     DBCS enabled STRCHR
*
*******************************************************************************/

LPSTR
NEAR PASCAL
DBCSStrChr(
    LPSTR string,
    CHAR chr
    )
{
    LPSTR p;

    p = string;
    while (*p)
    {
	if (IsDBCSLeadByte((BYTE)*p))
	{
	    p++;
	    if (*p == 0)
		break;
	}
	else if (*p == chr)
	    return (p);
	p++;
    }
    if (*p == chr)
	return (p);
    return NULL;
}

/*******************************************************************************
*
*  IsDBCSLeadByte
*
*  DESCRIPTION:
*     Test if the character is DBCS lead byte
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsDBCSLeadByte(
    BYTE chr
    )
{
    static unsigned char far *DBCSLeadByteTable = NULL;

    WORD off,segs;
    LPSTR p;

    if (DBCSLeadByteTable == NULL)
    {
        _asm {
            push ds
            mov ax,6300h
            int 21h
            mov off,si
            mov segs,ds
            pop ds
        }
        FP_OFF(DBCSLeadByteTable) = off;
        FP_SEG(DBCSLeadByteTable) = segs;
    }

    p = DBCSLeadByteTable;
    while (p[0] || p[1])
    {
        if (chr >= p[0] && chr <= p[1])
            return TRUE;
        p += 2;
    }
    return FALSE;
}
#endif    // WIN32
#endif    // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGRESID.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Resource identifiers for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGRESID
#define _INC_REGRESID

#define HEXEDIT_CLASSNAME               "HEX"

//
//
//

#define IDD_REGEXPORT                   100
#define IDD_REGPRINT                    108

#define IDC_FIRSTREGCOMMDLGID           1280
#define IDC_RANGEALL                    1280
#define IDC_RANGESELECTEDPATH           1281
#define IDC_SELECTEDPATH                1282
#define IDC_EXPORTRANGE                 1283
#define IDC_LASTREGCOMMDLGID            1283

//
//
//

#define IDD_EDITSTRINGVALUE             102
#define IDD_EDITBINARYVALUE             103
#define IDD_EDITDWORDVALUE              111

#define IDC_VALUENAME                   1000
#define IDC_VALUEDATA                   1001
#define IDC_HEXADECIMAL                 1002
#define IDC_DECIMAL                     1003

//
//
//

#define IDD_REGCONNECT                  104

#define IDC_REMOTENAME                  1100
#define IDC_BROWSE                      1101

//
//
//

#define IDD_REGPRINTABORT               105

//
//  Dialog box for the Edit-> Find... menu option.
//

#define IDD_REGFIND                     106

#define IDC_FINDWHAT                    1150
#define IDC_WHOLEWORDONLY               1151
//  NOTE: The flags IDC_FOR* must be consecutive.
#define IDC_FORKEYS                     1152
#define IDC_FORVALUES                   1153
#define IDC_FORDATA                     1154
#define IDC_GROUPBOX                    1160

#define IDD_REGDISCONNECT               107
#define IDC_REMOTELIST                  1175

//
//  Dialog box for the find abort.
//

#define IDD_REGFINDABORT                109

//
//  Dialog box for Import Registry File progress display.
//

#define IDD_REGPROGRESS                 110

#define IDC_FILENAME                    100
#define IDC_PROGRESSBAR                 101

//
//  Menu resource identifiers.
//

#define IDM_REGEDIT                     103
#define IDM_KEY_CONTEXT                 104
#define IDM_VALUE_CONTEXT               105
#define IDM_VALUELIST_NOITEM_CONTEXT    106
#define IDM_COMPUTER_CONTEXT            107

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

//
//  Popup menu item identifiers.  Used to determine the context menu help
//  string.
//

#define ID_FIRSTMENUPOPUPITEM           0x0200
#define ID_LASTMENUPOPUPITEM            0x027F

#define IDMP_REGISTRY                   0x0200
#define IDMP_EDIT                       0x0201
#define IDMP_VIEW                       0x0202
#define IDMP_HELP                       0x0203
#define IDMP_NEW                        0x0204

//
//  Main menu items.  If any of these items are selected from a context menu,
//  they will be automatically routed to the main window's command handler.
//

#define ID_FIRSTMAINMENUITEM            0x0280
#define ID_LASTMAINMENUITEM             0x02FF

//  Following are really keyboard accelerators.
#define ID_CYCLEFOCUS                   (ID_FIRSTMAINMENUITEM + 0x0000)

//  IMPORTANT:  Do not change the position of this identifier.  If Regedit is
//  already running and Regedit is then invoked through its commandline
//  interface, then the second instance will send a WM_COMMAND message with this
//  identifier to force a refresh.
#define ID_REFRESH                      (ID_FIRSTMAINMENUITEM + 0x0008)

#define ID_CONNECT                      (ID_FIRSTMAINMENUITEM + 0x0011)
#define ID_IMPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0012)
#define ID_EXPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0013)
#define ID_PRINT                        (ID_FIRSTMAINMENUITEM + 0x0014)
#define ID_EXIT                         (ID_FIRSTMAINMENUITEM + 0x0015)
#define ID_FIND                         (ID_FIRSTMAINMENUITEM + 0x0016)
#define ID_NEWKEY                       (ID_FIRSTMAINMENUITEM + 0x0017)
#define ID_NEWSTRINGVALUE               (ID_FIRSTMAINMENUITEM + 0x0018)
#define ID_NEWBINARYVALUE               (ID_FIRSTMAINMENUITEM + 0x0019)
#define ID_EXECCALC                     (ID_FIRSTMAINMENUITEM + 0x001A)
#define ID_ABOUT                        (ID_FIRSTMAINMENUITEM + 0x001B)
#define ID_STATUSBAR                    (ID_FIRSTMAINMENUITEM + 0x001C)
#define ID_SPLIT                        (ID_FIRSTMAINMENUITEM + 0x001E)
#define ID_FINDNEXT                     (ID_FIRSTMAINMENUITEM + 0x001F)
#define ID_HELPTOPICS                   (ID_FIRSTMAINMENUITEM + 0x0020)
#define ID_NETSEPARATOR                 (ID_FIRSTMAINMENUITEM + 0x0021)
#define ID_NEWDWORDVALUE                (ID_FIRSTMAINMENUITEM + 0x0022)

//
//  Dual menu items.  The routing of these items depends on whether it was
//  selected from the main menu or from a context menu.
//

#define ID_FIRSTDUALMENUITEM            0x0300
#define ID_LASTDUALMENUITEM             0x037F

#define ID_DISCONNECT                   (ID_FIRSTDUALMENUITEM + 0x0000)

//
//  Context menu items.  If any of these items are selected from the main menu,
//  they will be automatically routed to the focus pane's command handler.
//

#define ID_FIRSTCONTEXTMENUITEM         0x0380
#define ID_LASTCONTEXTMENUITEM          0x03FF

//  Following are really keyboard accelerators.
#define ID_CONTEXTMENU                  (ID_FIRSTCONTEXTMENUITEM + 0x0000)

#define ID_MODIFY                       (ID_FIRSTCONTEXTMENUITEM + 0x0010)
#define ID_DELETE                       (ID_FIRSTCONTEXTMENUITEM + 0x0011)
#define ID_RENAME                       (ID_FIRSTCONTEXTMENUITEM + 0x0012)
#define ID_TOGGLE                       (ID_FIRSTCONTEXTMENUITEM + 0x0013)
#define ID_SENDTOPRINTER                (ID_FIRSTCONTEXTMENUITEM + 0x0014)

//
//  String resource identifiers.
//

#define IDS_REGEDIT                     16
#define IDS_NAMECOLUMNLABEL             17
#define IDS_DATACOLUMNLABEL             18
#define IDS_COMPUTER                    19
#define IDS_DEFAULTVALUE                20
//  #define IDS_EMPTYSTRING                 21
#define IDS_EMPTYBINARY                 22
#define IDS_NEWKEYNAMETEMPLATE          23
#define IDS_NEWVALUENAMETEMPLATE        24
#define IDS_COLLAPSE                    25
#define IDS_MODIFY                      26
#define IDS_VALUENOTSET                 27
#define IDS_HELPFILENAME                28
#define IDS_DWORDDATAFORMATSPEC         29
#define IDS_INVALIDDWORDDATA            30

#define IDS_IMPORTREGFILETITLE          32
#define IDS_EXPORTREGFILETITLE          33
#define IDS_REGFILEFILTER               34
#define IDS_REGFILEDEFEXT               35

#define IDS_REGEDITDISABLED             40
#define IDS_SEARCHEDTOEND               41
#define IDS_COMPUTERBROWSETITLE         42

#define IDS_CONFIRMDELKEYTEXT           48
#define IDS_CONFIRMDELKEYTITLE          49
#define IDS_CONFIRMDELVALMULTITEXT      50
#define IDS_CONFIRMDELVALTITLE          51
#define IDS_CONFIRMDELVALTEXT           52

#define IDS_RENAMEKEYERRORTITLE         64
#define IDS_RENAMEPREFIX                65              //  Reserved
#define IDS_RENAMEKEYOTHERERROR         66
#define IDS_RENAMEKEYTOOLONG            67
#define IDS_RENAMEKEYEXISTS             68
#define IDS_RENAMEKEYBADCHARS           69

#define IDS_RENAMEVALERRORTITLE         72
#define IDS_RENAMEVALOTHERERROR         73
#define IDS_RENAMEVALEXISTS             74

#define IDS_DELETEKEYERRORTITLE         80
#define IDS_DELETEPREFIX                81              //  Reserved
#define IDS_DELETEKEYDELETEFAILED       82

#define IDS_DELETEVALERRORTITLE         88
#define IDS_DELETEVALDELETEFAILED       89

#define IDS_OPENKEYERRORTITLE           96
#define IDS_OPENKEYCANNOTOPEN           97

#define IDS_EDITVALERRORTITLE           112
#define IDS_EDITPREFIX                  113             //  Reserved
#define IDS_EDITVALCANNOTREAD           114
#define IDS_EDITVALCANNOTWRITE          115

#define IDS_IMPFILEERRSUCCESS           128
#define IDS_IMPFILEERRFILEOPEN          129
#define IDS_IMPFILEERRFILEREAD          130
#define IDS_IMPFILEERRREGOPEN           131
#define IDS_IMPFILEERRREGSET            132
#define IDS_IMPFILEERRFORMATBAD         133

#define IDS_EXPFILEERRSUCCESS           136
#define IDS_EXPFILEERRBADREGPATH        137
#define IDS_EXPFILEERRFILEOPEN          138
#define IDS_EXPFILEERRREGOPEN           139
#define IDS_EXPFILEERRREGENUM           140
#define IDS_EXPFILEERRFILEWRITE         141

#define IDS_PRINTERRNOMEMORY            144
#define IDS_PRINTERRPRINTER             145

#define IDS_ERRINVALIDREGPATH           148

#define IDS_CONNECTERRORTITLE           152
#define IDS_CONNECTNOTLOCAL             153
#define IDS_CONNECTBADNAME              154
#define IDS_CONNECTROOTFAILED           155
#define IDS_CONNECTACCESSDENIED         156

#define IDS_NEWKEYERRORTITLE            160
#define IDS_NEWKEYPARENTOPENFAILED      161
#define IDS_NEWKEYCANNOTCREATE          162
#define IDS_NEWKEYNOUNIQUE              163

#define IDS_NEWVALUEERRORTITLE          168
#define IDS_NEWVALUECANNOTCREATE        169
#define IDS_NEWVALUENOUNIQUE            170

//  The range IDS_FIRSTMENUPOPUPITEM through IDS_LASTMENUPOPUPITEM is reserved
//  for context menu help.  This must match up with ID_FIRSTMENUPOPUPITEM
//  through ID_LASTMENUPOPUPITEM.
#define IDS_FIRSTMENUPOPUPITEM          ID_FIRSTMENUPOPUPITEM
#define IDS_LASTMENUPOPUPITEM           ID_LASTMENUPOPUPITEM

//  The range IDS_FIRSTMAINMENUITEM through IDS_LASTMAINMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTMAINMENUITEM through
//  ID_LASTMAINMENUITEM.

#define IDS_FIRSTMAINMENUITEM           ID_FIRSTMAINMENUITEM
#define IDS_LASTMAINMENUITEM            ID_LASTMAINMENUITEM

//  The range IDS_FIRSTCONTEXTMENUITEM through IDS_LASTCONTEXTMENUITEM is
//  reserved for context menu help.  This must match up with
//  ID_FIRSTCONTEXTMENUITEM through ID_LASTCONTEXTMENUITEM.

#define IDS_FIRSTCONTEXTMENUITEM        ID_FIRSTCONTEXTMENUITEM
#define IDS_LASTCONTEXTMENUITEM         ID_LASTCONTEXTMENUITEM

//  The range IDS_FIRSTDUALMENUITEM through IDS_LASTDUALMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTDUALMENUITEM through
//  ID_LASTDUALMENUITEM.
#define IDS_FIRSTDUALMENUITEM           ID_FIRSTDUALMENUITEM
#define IDS_LASTDUALMENUITEM            ID_LASTDUALMENUITEM

//
//  Icon resource identifiers.
//

#define IDI_REGEDIT                     100
#define IDI_REGEDDOC                    101
#define IDI_REGFIND                     102

#define IDI_FIRSTIMAGE                  201
//  #define IDI_DIAMOND                     200
#define IDI_COMPUTER                    201
#define IDI_REMOTE                      202
#define IDI_FOLDER                      203
#define IDI_FOLDEROPEN                  204
#define IDI_STRING                      205
#define IDI_BINARY                      206
#define IDI_LASTIMAGE                   IDI_BINARY

//
//  Cursor resource identifiers.
//

#define IDC_SPLIT                       100

//
//  Accelerator resource identifiers.
//

#define IDACCEL_REGEDIT                 100

#endif // _INC_REGRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regedit.h ===
#include "common.h"


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define EDITDLG 200
#define MAINWND 201

#define ID_NAMELIST		(ID_FIRSTREGEDIT)

#define ID_CLASSID		(ID_FIRSTREGEDIT+0x10)
#define ID_STATCLASSID		(ID_CLASSID+1)
#define ID_USESDDE		(ID_CLASSID+2)
#define ID_BROWSE		(ID_CLASSID+3)
#define ID_SAVEACTION		(ID_CLASSID+4)
#define ID_GROUPDDE		(ID_CLASSID+5)

#define ID_FIRSTACTIONRADIO	(ID_FIRSTREGEDIT+0x20)
#define ID_OPENRADIO		(ID_FIRSTACTIONRADIO)
#define ID_PRINTRADIO		(ID_FIRSTACTIONRADIO+1)
#define ID_LASTACTIONRADIO	(ID_PRINTRADIO)

#define ID_FIRSTEDIT		(ID_FIRSTREGEDIT+0x30)
#define ID_CLASSNAME		(ID_FIRSTEDIT)
#define ID_FIRSTACTIONEDIT	(ID_FIRSTEDIT+1)
#define ID_COMMAND		(ID_FIRSTACTIONEDIT)
#define ID_FIRSTDDEEDIT		(ID_FIRSTEDIT+2)
#define ID_LASTEDIT		(ID_FIRSTEDIT+5)

#define CI_SUCCESS 0
#define CI_EXISTS 1
#define CI_CANTCREATE 2

#define IDS_BROWSETITLE		(IDS_FIRSTREGEDIT)
#define IDS_EXES		(IDS_BROWSETITLE+1)
#define IDS_CUSTEXES		(IDS_BROWSETITLE+2)

#define IDS_EXISTS		(IDS_FIRSTREGEDIT+0x10)
#define IDS_INVALIDID		(IDS_EXISTS+1)
#define IDS_INVALIDNAME		(IDS_EXISTS+2)

#define IDS_ADD			(IDS_FIRSTREGEDIT+0x20)
#define IDS_COPY		(IDS_ADD+1)

#define IDS_SUREDELETE		(IDS_FIRSTREGEDIT+0x30)

#define CC_INVALIDNAME -1
#define CC_OUTOFMEMORY -2
#define CC_ALREADYEXISTS -3
#define CC_CANTCREATE -4

#define FLAG_NEW (1)
#define FLAG_COPY (2)


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** regedit.c *****/
extern long FAR PASCAL MainWnd(HWND, WORD, WORD, LONG);

/***** dbase.c *****/
extern WORD NEAR PASCAL CreateId(HANDLE hId);
extern WORD NEAR PASCAL MyGetClassName(HANDLE hId, HANDLE *hName);
extern WORD NEAR PASCAL DeleteClassId(HANDLE hId);
extern WORD NEAR PASCAL MergeData(HWND hWndName, HANDLE hId);
extern WORD NEAR PASCAL ResetClassList(HWND hWndIdList, HWND hWndNameList);
extern WORD NEAR PASCAL GetLocalCopies(HWND hWndName, HANDLE hId);

/***** utils1.c *****/
extern PSTR NEAR PASCAL GetAppName(HANDLE hCommand);
extern HANDLE NEAR cdecl ConstructPath(PSTR pHead, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\regthunk.c ===
/*
 RegThunk.c

 Created by Lee Hart, 4/27/95

 Purpose: Generic Thunks to Win32 Registry APIs that are not
 supported in Win16

*/

#include <windows.h>
#include <shellapi.h>
#include <wownt16.h>

#ifndef CHAR
#define CHAR char
#endif // ifndef CHAR

#include "regporte.h"

LONG RegSetValueEx(
    HKEY             hKey,        // handle of key to set value for
    LPCSTR           lpValueName, // address of value to set
    DWORD            Reserved,    // reserved
    DWORD            dwType,      // flag for value type
    CONST BYTE FAR * lpData,      // address of value data
    DWORD            cbData       // size of value data
   )
{
 DWORD hAdvApi32=LoadLibraryEx32W("ADVAPI32.DLL", NULL, 0);
 DWORD pFn;
 DWORD dwResult = ERROR_ACCESS_DENIED; //random error if fail

 if ((DWORD)0!=hAdvApi32)
  {
   pFn=GetProcAddress32W(hAdvApi32, "RegSetValueExA"); // call ANSI version
   if ((DWORD)0!=pFn)
    {
     dwResult=CallProcEx32W( CPEX_DEST_STDCALL | 6, 0x12, pFn, hKey, lpValueName, Reserved, dwType, lpData, cbData );
    }
  }
 if (hAdvApi32) FreeLibrary32W(hAdvApi32);
 return(dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\shell\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\sdbase.c ===
#include <windows.h>
#include "SDKRegEd.h"

extern HWND hWndIds;
extern HANDLE hPars;

extern char szHkeyClassesRoot[];

DWORD NEAR PASCAL GetTreeMarkers(int nId)
{
   int *pPars;
   int nKeys, nLevel, nTemp;
   DWORD dwMarkers, thisMarker;
   int i, j;

   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);
   pPars = (WORD *)LocalLock(hPars);

   for(i=nId, nLevel= -1; i>=0; i=pPars[i], ++nLevel)
      /* do nothing */ ;

   dwMarkers = 0L;
   for(thisMarker=1; nLevel>0; thisMarker<<=1, --nLevel) {
      for(i=nId, nTemp=nLevel; nTemp>0; i=pPars[i], --nTemp)
         /* do nothing */ ;

      for(j=nId+1; j<nKeys; ++j) {
         if(pPars[j] == i) {
            dwMarkers |= thisMarker;
            break;
         }
      }
      nKeys = j;
   }

   LocalUnlock(hPars);
   return(dwMarkers);
}

int NEAR PASCAL GetLevel(int nId)
{
   int nLevel;
   int *pPars;

   if(!hPars || !(pPars=(WORD *)LocalLock(hPars)))
      return(0);
   for(nLevel= -1; nId>=0; nId=pPars[nId], ++nLevel)
      /* do nothing */ ;
   LocalUnlock(hPars);
   return(nLevel);
}

HANDLE NEAR PASCAL MyGetPartialPath(int index, int nParent)
{
   BOOL bFirst;
   HANDLE hPath;
   PSTR pPath;
   int nLevel, nTemp, i;
   DWORD dwLen;
   WORD wLen = 2;
   int *pPars;

   if(!hPars || !(pPars=(WORD *)LocalLock(hPars)))
      goto Error1;

   for(i=index, nLevel=0; i!=nParent; i=pPars[i], ++nLevel) {
      if((dwLen=SendMessage(hWndIds, LB_GETTEXTLEN, i, 0L)) == LB_ERR)
         goto Error2;
      wLen += LOWORD(dwLen) + 1;
   }

   if(!(hPath=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error2;
   if(!(pPath=LocalLock(hPath)))
      goto Error3;

   if(nParent == 0)
      *pPath++ = '\\';
   *pPath = '\0';
   for(--nLevel, bFirst=TRUE; nLevel>=0; --nLevel) {
      for(i=index, nTemp=nLevel; nTemp>0; i=pPars[i], --nTemp)
         /* do nothing */ ;

      if(bFirst)
         bFirst = FALSE;
      else
         *pPath++ = '\\';
      dwLen = SendMessage(hWndIds, LB_GETTEXT, i, (DWORD)((LPSTR)pPath));
      pPath += LOWORD(dwLen);
   }

   LocalUnlock(hPath);
   goto Error2;

Error3:
   LocalFree(hPath);
   hPath = NULL;
Error2:
   LocalUnlock(hPars);
Error1:
   return(hPath);
}

HANDLE NEAR PASCAL MyGetPath(int i)
{
   return(MyGetPartialPath(i, 0));
}

int NEAR PASCAL FindKey(PSTR pKey)
{
   HANDLE hPath;
   PSTR pLast, pTemp;
   int nLast, index, nCmp;

   pLast = pKey;
   if(*(pKey+1)) {
      for(pTemp=pKey; *pTemp; pTemp=OFFSET(AnsiNext(pTemp))) {
         if(*pTemp == '\\') {
            pLast = pTemp + 1;
         }
      }
   }

   nLast = index = -1;
   do {
      if((index=(int)SendMessage(hWndIds, LB_FINDSTRING, index,
            (DWORD)((LPSTR)pLast)))==LB_ERR ||
            index<=nLast || !(hPath=MyGetPath(index)))
         return(-1);

      nLast = index;
      nCmp = lstrcmpi(pKey, LocalLock(hPath));
      LocalUnlock(hPath);
      LocalFree(hPath);
   } while(nCmp) ;

   return(index);
}

int NEAR PASCAL FindLastExistingKey(int nParent, PSTR pPath)
{
   HANDLE hPath, hTemp;
   PSTR pEnd, pLast, pFullPath;
   int nFound, nResult = -1;
   WORD wLen;

   if(!(hPath=MyGetPath(nParent)))
      goto Error1;
   wLen = lstrlen(LocalLock(hPath));
   LocalUnlock(hPath);
   if(!(hTemp=LocalReAlloc(hPath, wLen+lstrlen(pPath)+2, LMEM_MOVEABLE)))
      goto Error2;
   if(!(pFullPath=LocalLock(hPath=hTemp)))
      goto Error2;

   pEnd = pFullPath + wLen;
   if(nParent) {
      *pEnd++ = '\\';
      *pEnd = '\0';
   }
   lstrcpy(pEnd, pPath);

   for(pLast=pEnd; *pEnd; pEnd=OFFSET(AnsiNext(pEnd))) {
      if(*pEnd == '\\') {
         *pEnd = '\0';
         nFound = FindKey(pFullPath);
         *pEnd = '\\';
         if(nFound == -1)
            goto FoundLast;

         pLast = pEnd + 1;
         nParent = nFound;
      }
   }

/* If we got to the end of the string, try the whole thing */
   if((nFound=FindKey(pFullPath)) >= 0) {
/* The key already exists */
      nParent = nFound;
      pLast = pEnd;
   }
FoundLast:

   nResult = nParent;
   lstrcpy(pPath, pLast);

   LocalUnlock(hPath);
Error2:
   LocalFree(hPath);
Error1:
   return(nResult);
}

#define BIGBLOCK 1024L

static WORD NEAR PASCAL BufferedWrite(int hFile, PSTR pWrite, WORD wBytes)
{
   static HANDLE hBuffer = NULL;
   static WORD wOffset;
   static DWORD dwSize;

   LPSTR lpBuffer;

/* wBytes = 0 means to write out the buffer and clean up */
   if(!wBytes) {
      WORD wErrMsg = NULL;

      if(hBuffer) {
         if(lpBuffer=GlobalLock(hBuffer)) {
            if(_lwrite(hFile, lpBuffer, wOffset) != wOffset)
               wErrMsg = IDS_CANTWRITEFILE;
            GlobalUnlock(hBuffer);
         } else
            wErrMsg = IDS_OUTOFMEMORY;

         GlobalFree(hBuffer);
         hBuffer = NULL;
      }
      return(wErrMsg);
   }

/* hBuffer = NULL means we need to allocate a buffer */
   if(!hBuffer) {
      if(!(hBuffer=GlobalAlloc(GMEM_MOVEABLE, dwSize=BIGBLOCK)))
         return(IDS_OUTOFMEMORY);
      wOffset = 0;
   }

/* If the total is > 64K, flush the buffer */
   if((DWORD)wBytes+(DWORD)wOffset > 0xffffL) {
      if(lpBuffer=GlobalLock(hBuffer)) {
         WORD wTemp;

         wTemp = _lwrite(hFile, lpBuffer, wOffset);
         GlobalUnlock(hBuffer);
         if(wTemp != wOffset)
            return(IDS_CANTWRITEFILE);
      } else
         return(IDS_OUTOFMEMORY);
      wOffset = 0;
   }

/* If the total is greater than the size we have allocated, try to
 * increase the buffer size to fit.  If we cannot, then flush the
 * buffer, and if wBytes is still too big, then write it straight to
 * disk.
 */
   if((DWORD)(wBytes+wOffset) > dwSize) {
      HANDLE hTemp;
      DWORD dwTemp;

      dwTemp = (((wBytes+wOffset)/BIGBLOCK) + 1) * BIGBLOCK;
      if(hTemp=GlobalReAlloc(hBuffer, dwTemp, GMEM_MOVEABLE)) {
         hBuffer = hTemp;
         dwSize = dwTemp;
      } else {
         WORD wTemp;

         if(wOffset) {
            if(!(lpBuffer=GlobalLock(hBuffer)))
               return(IDS_OUTOFMEMORY);
            wTemp = _lwrite(hFile, lpBuffer, wOffset);
            wOffset = 0;
            GlobalUnlock(hBuffer);
            if(wTemp != wOffset)
               return(IDS_CANTWRITEFILE);
         }
         if(wBytes > LOWORD(dwSize)) {
            if(_lwrite(hFile, pWrite, wBytes) == wBytes)
               return(NULL);
            else
               return(IDS_CANTWRITEFILE);
         }
      }
   }

/* If we got to here, then there is room in the buffer */
   if(!(lpBuffer=GlobalLock(hBuffer)))
      return(IDS_OUTOFMEMORY);
   RepeatMove(lpBuffer+wOffset, pWrite, wBytes);
   wOffset += wBytes;
   GlobalUnlock(hBuffer);

   return(NULL);
}

WORD NEAR PASCAL DoWriteFile(int nId, HANDLE hFileName)
{
   HANDLE hHeader;
   PSTR pHeader;
   WORD wErrMsg;
   int *pPars;
   LPSTR lpFileName;
   int hFile, nKeys, i, j;
   OFSTRUCT of;
   WORD wRootLen = lstrlen(szHkeyClassesRoot);

/* Open the file */
   wErrMsg = IDS_CANTOPENFILE;
   lpFileName = GlobalLock(hFileName);
   if((hFile=OpenFile(lpFileName, &of, OF_CREATE)) == -1)
      goto Error1;

   pPars = (WORD *)LocalLock(hPars);
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);

/* Find the first key that does not have nId in its parent chain */
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

   wErrMsg = IDS_OUTOFMEMORY;
   if(!(hHeader=MyLoadString(IDS_REGHEADER, NULL, LMEM_MOVEABLE)))
      goto Error2;
   pHeader = LocalLock(hHeader);
   wErrMsg = BufferedWrite(hFile, pHeader, lstrlen(pHeader));
   LocalUnlock(hHeader);
   LocalFree(hHeader);
   if(wErrMsg || (wErrMsg=BufferedWrite(hFile, "\r\n", 2)))
      goto Error2;
   
/* Write the strings */
   for(j=nId, wErrMsg=NULL; j<i && !wErrMsg; ++j) {
      HANDLE hPath, hValue;
      PSTR pPath, pValue;

/* Get the path and the value */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=MyGetPath(j)))
         goto Error2;
      pPath = LocalLock(hPath);
      if(MyGetValue(j, &hValue))
         goto Error3;
      pValue = LocalLock(hValue);

/* We don't need to write this key if it has subkeys but no value */
      wErrMsg = NULL;
      if(!(*pValue) && pPars[j+1]==j)
         goto Error4;

/* Write HKEY_CLASSES_ROOT<path> = <value>\r\n */
      if((wErrMsg=BufferedWrite(hFile, szHkeyClassesRoot, wRootLen)) ||
	    (wErrMsg=BufferedWrite(hFile, pPath+1, lstrlen(pPath+1))) ||
            (wErrMsg=BufferedWrite(hFile, " = ", 3)))
         goto Error4;

/* Don't write the value if it is of 0 length */
      if(*pValue && (wErrMsg=BufferedWrite(hFile, pValue, lstrlen(pValue))))
         goto Error4;
      wErrMsg = BufferedWrite(hFile, "\r\n", 2);

Error4:
      LocalUnlock(hValue);
      LocalFree(hValue);
Error3:
      LocalUnlock(hPath);
      LocalFree(hPath);
Error2:
      ;
   }

/* One last write with 0 length to clean up */
   wErrMsg = BufferedWrite(hFile, NULL, 0);
   LocalUnlock(hPars);
   _lclose(hFile);

/* Delete the file if there was an error */
   if(wErrMsg)
      OpenFile(lpFileName, &of, OF_DELETE);
Error1:
   GlobalUnlock(hFileName);
   return(wErrMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\sdkreged.c ===
#define WIN31
#include <windows.h>
#include "SDKRegEd.h"

#define RONSPACE 3
#define misParam ((MEASUREITEMSTRUCT FAR *)lParam)
#define disParam ((DRAWITEMSTRUCT FAR *)lParam)

extern char szNull[];
extern char szSDKRegEd[];

static char szEquals[] = " = ";

static WORD wKey=0;
static HANDLE hSearchString = NULL;

static BOOL bDoUpdate = TRUE;

static HWND hStat1, hEdit1, hEdit2;

extern BOOL bChangesMade;
extern HWND hWndIds;
extern HANDLE hAcc;
extern BOOL fOpenError;

#pragma warning(4:4146)     // unary minus operator applied to unsigned type, result still unsigned


VOID NEAR PASCAL MySetSel(HWND hWndList, int index)
{
   if (!bDoUpdate)
       return;

   if(index == -2)
      index = (int)SendMessage(hWndList, LB_GETCURSEL, 0, 0L);
   else
      SendMessage(hWndList, LB_SETCURSEL, index, 0L);

   SendMessage(GetParent(hWndList), WM_COMMAND, GetWindowWord(hWndList, GWW_ID),
         MAKELONG(hWndList, LBN_SELCHANGE));
}

int FAR PASCAL SDKMainWndDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static int xSpace;
   static int nTop, nLeft, nValHgt, nPthHgt;

   switch(message) {
   case WM_COMMAND:
      switch(wParam) {
      case IDCANCEL:
	 SendDlgItemMessage(hDlg, ID_VALUE, EM_SETMODIFY, 0, 0L);
	 goto NewSelection;

      case ID_VALUE:
	 if (HIWORD(lParam) == EN_KILLFOCUS) {
	    hAcc = LoadAccelerators(hInstance, szSDKRegEd);
	    goto NewSelection;
	 } else if (HIWORD(lParam) == EN_SETFOCUS)
	    hAcc = LoadAccelerators(hInstance, "SDKRegEdVal");
	 break;

      case ID_IDLIST:
         if(HIWORD(lParam) == LBN_SELCHANGE) {
            HANDLE hTmp;
            HWND hWndTmp;
	    WORD wErrMsg, wNewKey;

NewSelection:
            wNewKey = (WORD)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L);

            hWndTmp = GetDlgItem(hDlg, ID_VALUE);
	    if (SendMessage(hWndTmp, EM_GETMODIFY, 0, 0L)) {
	       SendMessage(hWndTmp, EM_SETMODIFY, 0, 0L);
	       bDoUpdate = FALSE;

	       wErrMsg = IDS_OUTOFMEMORY;
	       if(hEdit1 = GetEditString(hWndTmp)) {
		  wErrMsg = GetErrMsg((WORD)SDKSetValue(-wKey, szNull,
			LocalLock(hEdit1)));
		  LocalUnlock(hEdit1);
	       }

	       if(wErrMsg) {
		  MyMessageBox(hWndMain, wErrMsg, MB_OK, 0);
		  break;
	       }
	       bDoUpdate = TRUE;

	       InvalidateRect(hWndIds, NULL, TRUE);
	    }
	
            if((wKey=wNewKey)!=(WORD)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L))
               SendMessage(hWndIds, LB_SETCURSEL, wKey, 0L);

            if(!MyGetValue(wKey, &hTmp)) {
               SendMessage(hWndTmp, WM_SETTEXT, 0,
                     (DWORD)((LPSTR)LocalLock(hTmp)));
               LocalUnlock(hTmp);
               LocalFree(hTmp);
            } else
               SendMessage(hWndTmp, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));

            hWndTmp = GetDlgItem(hDlg, ID_FULLPATH);
            if(hTmp=MyGetPath(wKey)) {
               SendMessage(hWndTmp, WM_SETTEXT, 0,
                     (DWORD)((LPSTR)LocalLock(hTmp)));
               LocalUnlock(hTmp);
               LocalFree(hTmp);
            } else
               SendMessage(hWndTmp, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));
         }
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_SIZE:
    {
      HWND hWndTmp;
      RECT rcList, rcWnd;
      int hgtWnd, hgt;

      hgtWnd = HIWORD(lParam) + 1;
      hgt = hgtWnd - nTop;

      SetWindowPos(hWndIds, NULL, -1, nTop, LOWORD(lParam)+2, hgt,
            SWP_NOZORDER);
      GetWindowRect(hWndIds, &rcList);
      ScreenToClient(hDlg, (POINT *)(&rcList) + 1);
      if(rcList.bottom != hgtWnd) {
         GetWindowRect(hDlg, &rcWnd);
         SetWindowPos(hDlg, NULL, 0, 0, rcWnd.right-rcWnd.left,
               rcWnd.bottom-rcWnd.top-hgtWnd+rcList.bottom,
               SWP_NOMOVE | SWP_NOZORDER);
      }

      hWndTmp = GetDlgItem(hDlg, ID_VALUE);
      SetWindowPos(hWndTmp, NULL, 0, 0, LOWORD(lParam)-nLeft,
            nValHgt, SWP_NOMOVE | SWP_NOZORDER);
      InvalidateRect(hWndTmp, NULL, TRUE);

      hWndTmp = GetDlgItem(hDlg, ID_FULLPATH);
      SetWindowPos(hWndTmp, NULL, 0, 0, LOWORD(lParam)-nLeft,
            nPthHgt, SWP_NOMOVE | SWP_NOZORDER);
      InvalidateRect(hWndTmp, NULL, TRUE);
      break;
    }

   case WM_INITDIALOG:
    {
      RECT rcTemp;
      WORD wErrMsg;

      hWndIds = GetDlgItem(hDlg, ID_IDLIST);

      SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
      if(wErrMsg=MyResetIdList(hDlg)) {
         MyMessageBox(hWndMain, wErrMsg, MB_OK, 0);
	 fOpenError = TRUE;
      }
      SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
      InvalidateRect(hWndIds, NULL, TRUE);

      GetWindowRect(hWndIds, &rcTemp);
      ScreenToClient(hDlg, (POINT FAR *)&rcTemp);
      nTop = rcTemp.top;

      GetWindowRect(GetDlgItem(hDlg, ID_VALUE), &rcTemp);
      nValHgt = rcTemp.bottom - rcTemp.top;
      GetWindowRect(GetDlgItem(hDlg, ID_FULLPATH), &rcTemp);
      nPthHgt = rcTemp.bottom - rcTemp.top;
      ScreenToClient(hDlg, (POINT FAR *)&rcTemp);
      nLeft = rcTemp.left;
      break;
    }

   case WM_MEASUREITEM:
    {
      HDC hDC;

      hDC = GetDC(hWndIds);
      misParam->itemHeight = HIWORD(GetTextExtent(hDC, "Ag", 2));
      xSpace = LOWORD(GetTextExtent(hDC, " ", 1));
      ReleaseDC(hWndIds, hDC);
      break;
    }

   case WM_DRAWITEM:
    {
      HDC hDC;
      HANDLE hKeyName, hValue;
      PSTR pKeyName;
      WORD wSize;
      int theLevel;
      RECT rcTextExt;
      DWORD dwMarkers, thisMarker;
      DWORD dwRGBBkGnd, dwRGBText;

      hDC = disParam->hDC;

      if(!(hKeyName=GetListboxString(disParam->hwndItem, disParam->itemID)))
         break;
      pKeyName = LocalLock(hKeyName);
      wSize = lstrlen(pKeyName);

      if(!MyGetValue(disParam->itemID, &hValue)) {
	 PSTR pValue;
	 HANDLE hTemp;
	 WORD wTemp;

	 if(*(pValue = LocalLock(hValue))) {
	    LocalUnlock(hKeyName);
	    wTemp = wSize + sizeof(szEquals) - 1 + lstrlen(pValue);
	    if(hTemp=LocalReAlloc(hKeyName, wTemp+1, LMEM_MOVEABLE)) {
	       hKeyName = hTemp;
	       pKeyName = LocalLock(hKeyName);
	       lstrcat(pKeyName, szEquals);
	       lstrcat(pKeyName, pValue);
	       wSize = wTemp;
	    } else {
	       pKeyName = LocalLock(hKeyName);
	    }
	 }

	 LocalUnlock(hValue);
	 LocalFree(hValue);
      }

      theLevel = GetLevel(disParam->itemID);

      rcTextExt.left   = disParam->rcItem.left + RONSPACE*theLevel*xSpace;
      rcTextExt.top    = disParam->rcItem.top;
      rcTextExt.right  = rcTextExt.left + LOWORD(GetTextExtent(hDC,
            pKeyName, wSize)) + 2*xSpace;
      rcTextExt.bottom = disParam->rcItem.bottom;

      if(disParam->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {
         if(disParam->itemID>0 && (disParam->itemAction&ODA_DRAWENTIRE)) {
            HPEN hPen, hOldPen;
            int theLeft, theMiddle;

            if(theLevel <= 32)
               dwMarkers = GetTreeMarkers(disParam->itemID);
            else
               dwMarkers = 0;

            --theLevel;
            theLeft = disParam->rcItem.left + RONSPACE*theLevel*xSpace + xSpace;
            theMiddle = (rcTextExt.top+rcTextExt.bottom)/2;
            thisMarker = 1L << (LONG)theLevel;

            if(hPen=CreatePen(PS_SOLID, 1, GetTextColor(hDC)))
               hOldPen = SelectObject(hDC, hPen);

            MoveTo(hDC, theLeft, theMiddle);
            LineTo(hDC, theLeft+(RONSPACE-1)*xSpace, theMiddle);
            MoveTo(hDC, theLeft, rcTextExt.top);
            LineTo(hDC, theLeft,
                  (dwMarkers&thisMarker) ? rcTextExt.bottom : theMiddle);
            goto NextLevel;

            for( ; theLevel>=0;
                  --theLevel, thisMarker>>=1, theLeft-=RONSPACE*xSpace) {
               if(dwMarkers&thisMarker) {
                  MoveTo(hDC, theLeft, rcTextExt.top);
                  LineTo(hDC, theLeft, rcTextExt.bottom);
               }
NextLevel:
               ;
            }

            if(hPen) {
               if(hOldPen)
                  SelectObject(hDC, hOldPen);
               DeleteObject(hPen);
            }
         }

         if(disParam->itemState & ODS_SELECTED) {
            dwRGBBkGnd = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
            dwRGBText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
         }

         ExtTextOut(hDC, rcTextExt.left+xSpace, rcTextExt.top+1,
  	       ETO_CLIPPED | ETO_OPAQUE, &rcTextExt, pKeyName, wSize, 0L);

         if(disParam->itemState & ODS_SELECTED) {
            SetBkColor(hDC, dwRGBBkGnd);
            SetTextColor(hDC, dwRGBText);
         }

         if(disParam->itemState & ODS_FOCUS)
            disParam->itemAction |= ODA_FOCUS;
      }

      if(disParam->itemAction & ODA_FOCUS)
         DrawFocusRect(disParam->hDC, &rcTextExt);

      LocalUnlock(hKeyName);
      LocalFree(hKeyName);
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


VOID NEAR _fastcall FillDlgItem(HWND hDlg, WORD wId, HANDLE hTemp)
{
   if(hTemp) {
      SendDlgItemMessage(hDlg, wId, WM_SETTEXT, 0,
            (DWORD)((LPSTR)LocalLock(hTemp)));
      LocalUnlock(hTemp);
      LocalFree(hTemp);
   }
}


int FAR PASCAL GetKeyProc(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hDlg;
      return(FALSE);

   case WM_COMMAND:
      switch(wParam) {
      case IDOK:
       {
         HWND hWndEdit2;

         if(!(hEdit1=GetEditString(GetDlgItem(hDlg, ID_EDIT1))))
            goto Error1;
         if((hWndEdit2=GetDlgItem(hDlg, ID_EDIT2)) &&
               !(hEdit2 = GetEditString(hWndEdit2)))
            goto Error2;
       }

      case IDCANCEL:
         EndDialog(hDlg, wParam);
         break;

Error2:
         LocalFree(hEdit1);
Error1:
         MyMessageBox(hDlg, IDS_OUTOFMEMORY, MB_OK, 0);
         break;

      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hDlg)
            break;
      case ID_HELPBUTTON:
         MyHelp(hDlg, HELP_CONTEXT, wHelpId);
         break;
      }
      break;

   case WM_INITDIALOG:
      FillDlgItem(hDlg, ID_STAT1, hStat1);
      FillDlgItem(hDlg, ID_EDIT1, hEdit1);
      FillDlgItem(hDlg, ID_EDIT2, hEdit2);

      return(TRUE);

   default:
      return(FALSE);
   }

   return(TRUE);
}


long FAR PASCAL SDKMainWnd(HWND hWnd, WORD message, WORD wParam, LONG lParam)
{
   HCURSOR oldCursor;

   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
	 break;
      goto DoDefault;

   case WM_CREATE:
    {
      hWndMain = hWnd;
      if(!(lpMainWndDlg=MakeProcInstance(SDKMainWndDlg, hInstance)))
         goto Error1_1;
      if(!(hWndDlg=CreateDialog(hInstance, MAKEINTRESOURCE(SDKMAINWND), hWnd,
            lpMainWndDlg)))
         goto Error1_1;

      ShowWindow(hWndDlg, SW_SHOW);
      goto DoDefault;
    }

Error1_1:
      /* BUG: There should be a MessageBox here
       */
      DestroyWindow(hWnd);
      break;

   /* We need to return 1 if it is OK to close, 0 otherwise
    */
   case WM_CLOSE:
   case WM_QUERYENDSESSION:
    {
      MySetSel(hWndIds, -2);

      if(bChangesMade) {
         int nReturn;

         nReturn = MyMessageBox(hWnd, IDS_SAVECHANGES, MB_YESNOCANCEL, 0);
         if(nReturn == IDYES) {
	    if(!SendMessage(hWnd, WM_COMMAND, ID_SAVE, 0L))
	       break;
	 } else if(nReturn == IDCANCEL)
            break;
      }
      return(1L);
    }

   case WM_DROPFILES:
      goto DoMergeFile;

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      switch(wParam) {
      case ID_MODIFY:
	 SetFocus(GetDlgItem(hWndDlg, ID_IDLIST));
	 break;

      case ID_EDITVAL:
	 SetFocus(GetDlgItem(hWndDlg, ID_VALUE));
	 break;

      case ID_SAVE:
       {
         WORD wErrMsg;

	 MySetSel(hWndIds, -2);

         if(wErrMsg=MySaveChanges()) {
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
            break;
         }

	 /* Now we reset our local version of the database to make sure
	  * we are all talking about the same thing
	  */
	 PostMessage(hWnd, WM_COMMAND, ID_DORESTORE, 0L);
	 return(1L);
       }

      case ID_RESTORE:
         if(MyMessageBox(hWnd, IDS_SURERESTORE, MB_OKCANCEL, 0)
               != IDOK)
            break;

	 /* Fall through */
      case ID_DORESTORE:
       {
	 WORD wErrMsg;

	 SendMessage(hWnd, WM_ACTIVATEAPP, 0, 0L);
         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if(wErrMsg=MyResetIdList(hWndDlg)) {
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
	    PostMessage(hWnd, WM_COMMAND, ID_EXIT, 0L);
	    fOpenError = TRUE;
         }
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);
	 SendMessage(hWnd, WM_ACTIVATEAPP, 1, 0L);
	 break;
       }

      case ID_MERGEFILE:
DoMergeFile:
	 MySetSel(hWndIds, -2);
	 SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
	 break;

      case ID_FINISHMERGE:
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);
         break;

      case ID_WRITEFILE:
       {
         WORD wErrMsg;

	 MySetSel(hWndIds, -2);

	 if(!LOWORD(lParam))
	    break;

         if(wErrMsg=DoWriteFile(wKey, LOWORD(lParam)))
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         GlobalUnlock(LOWORD(lParam));
         GlobalFree(LOWORD(lParam));
         break;
       }

      case ID_ADD:
       {
         int nResult;
	 WORD wErrMsg;

	 MySetSel(hWndIds, -2);

         if(!(hStat1=MyGetPath(wKey)))
            goto Error6_1;
         hEdit1 = hEdit2 = NULL;
         wHelpId = IDW_ADDKEY;
         if((nResult=DoDialogBox(MAKEINTRESOURCE(AddKey), hWnd, GetKeyProc))
               < 0)
            goto Error6_2;
         else if(nResult == IDCANCEL)
            break;

         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if (wErrMsg=GetErrMsg((WORD)SDKSetValue(-wKey, LocalLock(hEdit1),
	       LocalLock(hEdit2))))
	    MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);

         LocalUnlock(hEdit2);
         LocalFree(hEdit2);
         LocalUnlock(hEdit1);
         LocalFree(hEdit1);
         break;

Error6_2:
         LocalFree(hStat1);
Error6_1:
         MyMessageBox(hWnd, IDS_OUTOFMEMORY, MB_OK, 0);
	 break;
       }

      case ID_DELETE:
      /* Fall through */
      case ID_COPY:
       {
         int nNewKey, nOldKey, nResult;
         PSTR pEdit1, pEdit2;

	 MySetSel(hWndIds, -2);

/* Get the key name to copy to */
         if(!(hEdit1=MyGetPath(wKey)))
            goto Error5_1;
         hStat1 = hEdit2 = NULL;
         wHelpId = wParam==ID_COPY ? IDW_COPYKEY : IDW_DELETE;
         if((nResult=DoDialogBox(wParam==ID_COPY ? MAKEINTRESOURCE(CopyKey) :
               MAKEINTRESOURCE(DeleteKey), hWnd, GetKeyProc)) < 0)
            goto Error5_2;
         else if(nResult == IDCANCEL)
            break;

/* Do the operation and clean up */
         pEdit1 = LocalLock(hEdit1);

         if((nOldKey=FindKey(pEdit1)) < 0) {
            MyMessageBox(hWnd, IDS_SOURCENOTEXIST, MB_OK, lstrlen(pEdit1),
		   (LPSTR)pEdit1);
	    goto Error5_3;
	 }

         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if(wParam == ID_COPY) {
	    /* hEdit2 is only set in the copy dialog; not the delete
	     */
	    pEdit2 = LocalLock(hEdit2);
            if((nNewKey=DoCopyKey(nOldKey, pEdit2)) < 0)
               MyMessageBox(hWnd, -nNewKey, MB_OK, 0);
	    LocalUnlock(hEdit2);
	    LocalFree(hEdit2);
         } else {
	    nNewKey = IDS_NODELROOT;
	    if(!nOldKey || (nNewKey=MyDeleteKey(nOldKey)))
               MyMessageBox(hWnd, nNewKey, MB_OK, 0);
            if(nOldKey >= (int)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L))
               --nOldKey;
            MySetSel(hWndIds, nOldKey);
         }
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);

Error5_3:
         LocalUnlock(hEdit1);
         LocalFree(hEdit1);
         break;

/* WARNING: ID_FIND also uses these error labels */
Error5_2:
         LocalFree(hEdit1);
Error5_1:
         MyMessageBox(hWnd, IDS_OUTOFMEMORY, MB_OK, 0);
	 break;
       }

      case ID_FINDKEY:
       {
         int nResult;

         if(!(hEdit1=StringToLocalHandle(LocalLock(hSearchString),
               LMEM_MOVEABLE)))
            goto Error5_1;
         LocalUnlock(hSearchString);
         hStat1 = hEdit2 = NULL;
         wHelpId = IDW_FINDKEY;
         if((nResult=DoDialogBox(MAKEINTRESOURCE(FindKeyDlg), hWnd,
               GetKeyProc)) < 0)
            goto Error5_2;
         else if(nResult == IDCANCEL)
            break;

         if(hSearchString)
            LocalFree(hSearchString);
         hSearchString = hEdit1;
       }
/* Fall through */
      case ID_FINDNEXT:
       {
         int index = LB_ERR;
         PSTR pSearchString;

         if(!hSearchString)
            goto Error2_1;
         pSearchString = LocalLock(hSearchString);

         if(*pSearchString == '\\') {
            if((index=FindKey(pSearchString)) == -1)
               goto Error2_2;
         } else {
            if((index=(int)SendMessage(hWndIds, LB_FINDSTRING, wKey,
                  (DWORD)((LPSTR)pSearchString)))==LB_ERR)
               goto Error2_2;
         }
         MySetSel(hWndIds, index);

Error2_2:
         LocalUnlock(hSearchString);
Error2_1:
         if(index < 0)
            MessageBeep(0);
         break;
       }

      default:
	 break;
      }
      SetCursor(oldCursor);
      break;

   default:
DoDefault:
      return(DefWindowProc(hWnd, message, wParam, lParam));
      break;
   }

   return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\utils1.c ===
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define BLOCKLEN 100

PSTR NEAR PASCAL GetAppName(HANDLE hCommand)
{
   static char szApp[17];

   PSTR pLast, pCommand, pDot;
   char cSave;

   for(pCommand=LocalLock(hCommand); *pCommand==' ';
         pCommand=AnsiNext(pCommand))
      /* skip spaces */ ;

   for(pDot=pLast=pCommand; ; pCommand=AnsiNext(pCommand)) {
      switch(*pCommand) {
      case ':':
      case '\\':
         pLast = pCommand + 1;
         break;

      case '.':
         pDot = pCommand;
         break;

      case '\0':
      case ' ':
      case '/':
         goto FoundEnd;
      }
   }
FoundEnd:

/* If there was a dot in the name or the name was too long */
   if(pDot > pLast)
      pCommand = pDot;
   if(pCommand-pLast > 8)
      pCommand = pLast+8;

   cSave = *pCommand;
   *pCommand = '\0';
   lstrcpy(szApp, pLast);
   *pCommand = cSave;

   AnsiUpper(szApp);
   pLast = AnsiNext(szApp);
   AnsiLower(pLast);

   LocalUnlock(hCommand);
   return(szApp);
}

HANDLE NEAR cdecl ConstructPath(PSTR pHead, ...)
{
   HANDLE hBuf = NULL;
   PSTR *ppName, pBuf, pTemp;
   WORD wLen;

   if(!pHead)
      goto Error1;

   for(ppName=&pHead, wLen=0; *ppName; ++ppName)
      wLen += lstrlen(*ppName) + 1;

   if(!(hBuf=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pBuf=LocalLock(hBuf)))
      goto Error2;

   for(ppName=&pHead, wLen=0, pTemp=pBuf; *ppName; ++ppName) {
      lstrcpy(pTemp, *ppName);
      pTemp += lstrlen(pTemp);
      *pTemp++ = '\\';
   }
   *(pTemp-1) = '\0';

   LocalUnlock(hBuf);
   goto Error1;

Error2:
   LocalFree(hBuf);
   hBuf = NULL;
Error1:
   return(hBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\shell\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\shell\dragdrop.c ===
/*
 *  dragdrop.c -
 *
 *  Code for Drag/Drop API's.
 *
 *  This code assumes something else does all the dragging work; it just
 *  takes a list of files after all the extra stuff.
 *
 *  The File Manager is responsible for doing the drag loop, determining
 *  what files will be dropped, formatting the file list, and posting
 *  the WM_DROPFILES message.
 *
 *  The list of files is a sequence of zero terminated filenames, fully
 *  qualified, ended by an empty name (double NUL).  The memory is allocated
 *  DDESHARE.
 */

#include <windows.h>
#include "shellapi.h"

void WINAPI DragFinishWOW(HDROP hDrop);

//
// Make sure that we correctly alias wParam of WM_DROPFILES, because that's
// the handle in hDrop
//

BOOL WINAPI DragQueryPoint(HDROP hDrop, LPPOINT lppt)
{
    LPDROPFILESTRUCT lpdfs;
    BOOL fNC;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock((HGLOBAL)hDrop);

    *lppt = lpdfs->pt;
    fNC = lpdfs->fNC;
    GlobalUnlock((HGLOBAL)hDrop);
    return !fNC;
}


void WINAPI DragFinish(HDROP hDrop)
{
    GlobalFree((HGLOBAL)hDrop);

//  The call to 32-bit DragFinish is not needed as GlobalFree is hooked
//  and will allow for the release of an alias (see wow32\wshell.c)
//    DragFinishWOW(hDrop);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\sdkreged.h ===
#include "common.h"


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define SDKMAINWND		300
#define ModifyKey		301
#define AddKey			302
#define CopyKey			303
#define DeleteKey		304
#define FindKeyDlg		305

#define ID_SAVE			(ID_FIRSTSDKREGED)
#define ID_RESTORE		(ID_SAVE+1)
#define ID_WRITEFILE		(ID_SAVE+2)
#define ID_DORESTORE		(ID_SAVE+3)

#define ID_FINDKEY		(ID_FIRSTSDKREGED+0x10)
#define ID_FINDNEXT		(ID_FINDKEY+1)

#define ID_VALUE		(ID_FIRSTSDKREGED+0x20)
#define ID_VALLIST		(ID_VALUE+1)
#define ID_DELLIST		(ID_VALUE+2)
#define ID_FULLPATH		(ID_VALUE+3)

#define ID_STAT1		(ID_FIRSTSDKREGED+0x30)
#define ID_EDIT1		(ID_STAT1+1)
#define ID_EDIT2		(ID_STAT1+2)

#define IDS_NOSUBKEY		(IDS_FIRSTSDKREGED)
#define IDS_ALREADYEXIST	(IDS_NOSUBKEY+1)

#define IDS_WRITETITLE		(IDS_FIRSTSDKREGED+0x10)
#define IDS_CANTWRITEFILE	(IDS_WRITETITLE+1)

#define IDS_SAVECHANGES		(IDS_FIRSTSDKREGED+0x20)
#define IDS_ERRORSAVING		(IDS_SAVECHANGES+1)
#define IDS_SURERESTORE		(IDS_SAVECHANGES+2)
#define IDS_NODELROOT		(IDS_SAVECHANGES+3)

#define IDS_SOURCENOTEXIST	(IDS_FIRSTSDKREGED+0x30)

#define IDW_ADDKEY		(IDW_MODIFY-1)
#define IDW_COPYKEY		(IDW_MODIFY-2)
#define IDW_DELETE		(IDW_MODIFY-3)
#define IDW_FINDKEY		(IDW_MODIFY-4)


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** sdkreged.c *****/
extern long FAR PASCAL SDKMainWnd(HWND, WORD, WORD, LONG);

/***** sdbase.c *****/
extern DWORD NEAR PASCAL GetTreeMarkers(int nId);
extern int NEAR PASCAL GetLevel(int nId);
extern HANDLE NEAR PASCAL MyGetPartialPath(int index, int nParent);
extern HANDLE NEAR PASCAL MyGetPath(int i);
extern int NEAR PASCAL FindKey(PSTR pKey);
extern int NEAR PASCAL FindLastExistingKey(int nParent, PSTR pPath);
extern WORD NEAR PASCAL DoWriteFile(int nId, HANDLE hFileName);

/***** virt.c *****/
extern WORD NEAR PASCAL MyResetIdList(HWND hDlg);
extern WORD NEAR PASCAL MySaveChanges(void);
extern WORD NEAR PASCAL MyDeleteKey(int nId);
extern unsigned long NEAR PASCAL MyGetValue(int nId, HANDLE *hValue);
extern unsigned long NEAR PASCAL SDKSetValue(HKEY, PSTR, PSTR);
extern int NEAR PASCAL DoCopyKey(int nId, PSTR pPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\regedit\virt.c ===
#include <windows.h>
#include "SDKRegEd.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

HANDLE hPars = NULL;
WORD maxKeys = 0;
BOOL bChangesMade = FALSE;

static HWND hWndVals, hWndDels;
char szListbox[] = "listbox";

extern HANDLE hInstance;
extern HWND hWndIds, hWndMain;
extern char szNull[];

extern VOID NEAR PASCAL MySetSel(HWND hWndList, int index);

static int NEAR PASCAL AddKeyToList(PSTR szPath, int index, int nLevel)
{
   PSTR szLast, pNext;
   DWORD dwResult;
   int nResult = -IDS_OUTOFMEMORY;
   WORD *pPars;
   int i, nKeys, nParent, nLevels;

/* Create the list of parents if necessary */
   if(!hPars) {
      if(!(hPars=LocalAlloc(LMEM_MOVEABLE, 8*sizeof(WORD))))
         goto Error1;
      else
         maxKeys = 8;
   }

/* Get the current number of keys, and check index
 * index == -1 means to add to the end of the list
 */
   if((nKeys=(WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L)) == LB_ERR)
      nKeys = 0;
   if(index == 0xffff)
      index = nKeys;
   else if(index > nKeys)
      goto Error1;

   if(!(pPars=(WORD *)LocalLock(hPars)))
      goto Error1;

   szLast = szPath;

   if(*szPath == '\\') {
/* This is a full path name, which will be inserted the first
 * place it can be.  The level and index are ignored: they will
 * need to be determined
 * if this is the root, set the variables and jump to the adding part
 * otherwise, find the existing parent and the new tail
 */
      if(!*(szPath+1)) {
	 /* If the root exists, just return its index
	  */
	 if((nResult=FindKey(szPath)) >= 0)
	    goto Error2;
         nParent = -1;
         nLevels = 0;
         pNext = szPath + 1;
         goto AddNewKey;
      } else {
         ++szLast;
         if((nParent=FindLastExistingKey(0, szLast)) < 0)
            goto Error2;
         index = nParent + 1;
      }
   } else {
/* Not an absolute path
 * nLevel == -1 means the preceding index is the parent, so nLevel is ignored
 * otherwise, find the ancestor of the preceding key with a lower
 * level than nLevel, and that is the parent
 * Finally, check for existing keys, and adjust nParent and index if necessary
 */
      if(nLevel == -1) {
         nParent = index - 1;
      } else {
         for(i=index-1; i>=0; i=pPars[i], --nLevel)
            /* do nothing */ ;
         if(nLevel > 0)
            goto Error2;

         for(i=index-1; nLevel<0; i=pPars[i], ++nLevel)
            /* do nothing */ ;
         nParent = i;
      }

      if(index < nKeys) {
         if((nParent=FindLastExistingKey(nParent, szLast)) < 0)
            goto Error2;
         else if(nParent >= index)
            index = nParent + 1;
      }
   }

/* At this point, index should be set to the intended index,
 * nParent should be set to the parent of the new key,
 * and szLast is the path for the new key (which may have subkeys)
 */
   for(nLevels=0; pNext=OFFSET(MyStrTok(szLast, '\\'));
	 ++nLevels, szLast=pNext) {
AddNewKey:
      if (pNext-szLast > MAX_KEY_LENGTH) {
	 nResult = -IDS_BADKEY;
	 goto CleanUp;
      }

      /* Make sure we have room for the new parents */
      if(nKeys+nLevels+1 > (int)maxKeys) {
         HANDLE hTemp;

         LocalUnlock(hPars);
         if(!(hTemp=LocalReAlloc(hPars,(maxKeys+8)*sizeof(WORD),LMEM_MOVEABLE)))
            goto Error1;
         hPars = hTemp;
         if(!(pPars=(WORD *)LocalLock(hPars)))
            goto Error1;
         maxKeys += 8;
      }

      if((dwResult=SendMessage(hWndIds, LB_INSERTSTRING, index+nLevels,
            (DWORD)((LPSTR)szLast)))==LB_ERR)
         break;
      if((dwResult=SendMessage(hWndVals, LB_INSERTSTRING, index+nLevels,
            (DWORD)((LPSTR)szNull)))==LB_ERR) {
         SendMessage(hWndIds, LB_DELETESTRING, index+nLevels, 0L);
         break;
      }
      SendMessage(hWndVals, LB_SETITEMDATA, index+nLevels, 1L);
   }

/* If the new key already exists, return it */
   if(!nLevels)
      nResult = nParent;
   else if(dwResult != LB_ERR)
      nResult = LOWORD(dwResult);

CleanUp:
   /* update the parent list */
   for(--nKeys; nKeys>=index; --nKeys) {
      if(pPars[nKeys] >= (WORD)index)
         pPars[nKeys+nLevels] = pPars[nKeys] + nLevels;
      else
         pPars[nKeys+nLevels] = pPars[nKeys];
   }
   for(--nLevels; nLevels>=0; --nLevels)
      pPars[index+nLevels] = nParent+nLevels;

Error2:
   LocalUnlock(hPars);
Error1:
   return(nResult);
}

static WORD NEAR PASCAL ListRegs(HWND hWnd, HKEY hKey, int wLevel)
{
   HANDLE hTail;
   PSTR pTail;
   int i;
   HKEY hSubKey;
   WORD wErrMsg = NULL;

   for(i=0; !wErrMsg; ++i) {
      if(MyEnumKey(hKey, i, &hTail) != ERROR_SUCCESS)
         break;
      pTail = LocalLock(hTail);

      if((int)(wErrMsg=-AddKeyToList(pTail, -1, wLevel))>0 ||
            (wErrMsg=GetErrMsg((WORD)RegOpenKey(hKey, pTail, &hSubKey))))
         goto Error1;
      wErrMsg = ListRegs(hWnd, hSubKey, wLevel+1);
      RegCloseKey(hSubKey);

Error1:
      LocalUnlock(hTail);
      LocalFree(hTail);
   }
   return(wErrMsg);
}

WORD NEAR PASCAL MyResetIdList(HWND hDlg)
{
   HKEY hKey;
   int i, nNum;
   WORD wErrMsg = IDS_OUTOFMEMORY;

   if((!hWndVals && !(hWndVals=GetDlgItem(hDlg, ID_VALLIST))) ||
         (!hWndDels && !(hWndDels=GetDlgItem(hDlg, ID_DELLIST))))
      goto Error1;

   bChangesMade = FALSE;

   SendMessage(hWndIds, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndVals, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndDels, LB_RESETCONTENT, 0, 0L);

   if((int)(wErrMsg=-AddKeyToList("\\", 0, 0)) <= 0) {
      if(!(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT,
	    NULL, &hKey)))) {
	 wErrMsg = ListRegs(hWndIds, hKey, 1);
	 RegCloseKey(hKey);

	 nNum = (int)SendMessage(hWndVals, LB_GETCOUNT, 0, 0L);
	 for(i=0; i<nNum; ++i)
	    SendMessage(hWndVals, LB_SETITEMDATA, i, 0L);

      }

      MySetSel(hWndIds, 0);
   }

Error1:
   return(wErrMsg);
}

WORD NEAR PASCAL MySaveChanges(void)
{
   HKEY hKeyTemp;
   HANDLE hPath, hVal;
   WORD wNum, wErrMsg;
   DWORD dwTemp;
   int i;

   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKeyTemp)))
      goto Error1;

   wNum = (WORD)SendMessage(hWndDels, LB_GETCOUNT, 0, 0L);
   for(i=0; !wErrMsg && (WORD)i<wNum; ++i) {
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=GetListboxString(hWndDels, i)))
         break;
      dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT, LocalLock(hPath)+1);
      wErrMsg = dwTemp==ERROR_BADKEY ? NULL : GetErrMsg((WORD)dwTemp);

      LocalUnlock(hPath);
      LocalFree(hPath);
   }

   wNum = GetErrMsg((WORD)RegCloseKey(hKeyTemp));
   if(wErrMsg || (wErrMsg=wNum) ||
         (wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, NULL,
	       &hKeyTemp))))
      goto Error1;

   wNum = (WORD)SendMessage(hWndVals, LB_GETCOUNT, 0, 0L);
   for(i=wNum-1; !wErrMsg && i>=0; --i) {
      if(!SendMessage(hWndVals, LB_GETITEMDATA, i, 0L))
         continue;

      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=MyGetPath(i)))
         break;
      if(!(hVal=GetListboxString(hWndVals, i)))
         goto Error2;

      wErrMsg = GetErrMsg((WORD)RegSetValue(HKEY_CLASSES_ROOT,
	    LocalLock(hPath)+1, REG_SZ, LocalLock(hVal), 0L));

      LocalUnlock(hVal);
      LocalUnlock(hPath);

      LocalFree(hVal);
Error2:
      LocalFree(hPath);
   }

   wNum = GetErrMsg((WORD)RegCloseKey(hKeyTemp));
Error1:
   return(wErrMsg ? wErrMsg : wNum);
}

WORD NEAR PASCAL MyDeleteKey(int nId)
{
   HANDLE hPath;
   WORD *pPars;
   int nKeys, i, j;
   WORD wErrMsg = IDS_OUTOFMEMORY;

/* Get the path and try to delete it */
   if(!(hPath=MyGetPath(nId)))
      goto Error1;
   if(SendMessage(hWndDels, LB_ADDSTRING, 0, (DWORD)((LPSTR)LocalLock(hPath)))
         == LB_ERR)
      goto Error2;

   pPars = (WORD *)LocalLock(hPars);
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);

/* Find the first key that does not have nId in its parent chain */
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

/* Do not delete the root from the list */
   if(!nId)
      ++nId;

/* Delete the string from the listbox */
   for(j=nId; j<i; ++j) {
      SendMessage(hWndIds, LB_DELETESTRING, nId, 0L);
      SendMessage(hWndVals, LB_DELETESTRING, nId, 0L);
   }

/* Update the parent list */
   i -= nId;
   nKeys -= i;
   for(j=nId; j<nKeys; ++j) {
      if(pPars[j+i] >= (WORD)nId)
         pPars[j] = pPars[j+i] - i;
      else
         pPars[j] = pPars[j+i];
   }
   bChangesMade = TRUE;
   wErrMsg = NULL;

   LocalUnlock(hPars);
Error2:
   LocalUnlock(hPath);
   LocalFree(hPath);
Error1:
   return(wErrMsg);
}

unsigned long NEAR PASCAL MyGetValue(int nId, HANDLE *hValue)
{
   unsigned long result;
   HANDLE hPath;

   if(SendMessage(hWndVals, LB_GETITEMDATA, nId, 0L)) {
      if(!(*hValue=GetListboxString(hWndVals, nId)))
         return(ERROR_OUTOFMEMORY);
      result = ERROR_SUCCESS;
   } else {
      if(!(hPath=MyGetPath(nId)))
         return(ERROR_OUTOFMEMORY);
      result = MyQueryValue(HKEY_CLASSES_ROOT, LocalLock(hPath)+1, hValue);
      LocalUnlock(hPath);
      LocalFree(hPath);
   }

   return(result);
}

/* Strip off leading and trailing spaces, and return
 * -1 if there are any invalid characters, otherwise the address
 * of the first non-blank.
 */
PSTR NEAR PASCAL VerifyKey(PSTR lpK)
{
  PSTR lpT;
  char cLast = '\0';

  /* skip some spaces, just to be wierd
   */
  while (*lpK == ' ')
      lpK++;

  /* Special case the string "\"
   */
  if (*(unsigned int *)lpK == (unsigned int)'\\')
      return(lpK);

  /* Note that no extended characters are allowed, so no DBCS
   * characters are allowed in a key
   */
  for (lpT=lpK; ; ++lpT)
    {
      switch (*lpT)
	{
	  case '\0':
	    /* We do not allow a \ as the last char
	     */
	    return(cLast=='\\' ? (PSTR)-1 : lpK);

	  case '\\':
	    /* We do not allow two \'s in a row
	     */
	    if (cLast == '\\')
		return((PSTR)-1);
	    break;

	  default:
	    /* If we get a control or extended character, return -1.
	     */
	    if ((char)(*lpT) <= ' ')
		return((PSTR)-1);
	    break;
	}

      cLast = *lpT;
    }
}

unsigned long NEAR PASCAL SDKSetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
   WORD wNewKey;

   if (hKey == HKEY_CLASSES_ROOT)
      hKey = 0L;
   else
      hKey = -(long)hKey;

   if ((pSubKey=VerifyKey(pSubKey)) == (PSTR)-1)
      return(ERROR_BADKEY);

   if((int)(wNewKey=(WORD)AddKeyToList(pSubKey, (WORD)hKey+1, -1))>=0 &&
         SendMessage(hWndVals, LB_INSERTSTRING, wNewKey, (LONG)(LPSTR)pVal)
	 !=LB_ERR) {
      SendMessage(hWndVals, LB_DELETESTRING, wNewKey+1, 0L);
      SendMessage(hWndVals, LB_SETITEMDATA, wNewKey, 1L);
      MySetSel(hWndIds, wNewKey);
      bChangesMade = TRUE;

      return(ERROR_SUCCESS);
   }

   return(ERROR_OUTOFMEMORY);
}

int NEAR PASCAL DoCopyKey(int nId, PSTR pPath)
{
   WORD *pPars;
   int nParent, result, i, j, nKeys, nNewKey;

   pPars = (WORD *)LocalLock(hPars);

/* Cannot copy the whole tree */
   result = -IDS_NOSUBKEY;
   if(!nId)
      goto Error1;

/* Find the longest path that currently exists
 * return an error if that is the whole string
 * or a subkey of the key to be copied
 */
   if(*pPath == '\\') {
      ++pPath;
      if((result=nParent=FindLastExistingKey(0, pPath)) < 0)
         goto Error1;
   } else {
      if((result=nParent=FindLastExistingKey(pPars[nId], pPath)) < 0)
         goto Error1;
   }
   result = -IDS_NOSUBKEY;
   for(i=nParent; i>=0; i=pPars[i])
      if(i == nId)
         goto Error1;
   result = -IDS_ALREADYEXIST;
   if(!*pPath)
      goto Error1;

/* Find the first key that does not have nId in its parent chain */
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

/* Add the new keys
 * hPars should be unlocked in case it needs to grow
 */
   LocalUnlock(hPars);
   pPars = NULL;
   if(SDKSetValue(-nParent, pPath, szNull) != ERROR_SUCCESS)
      goto Error1;
   nNewKey = (int)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L);

   for(--i, result=nId; i>=nId && result==nId; --i) {
      HANDLE hPart, hValue;
      PSTR pPart;

      if(nNewKey <= nId) {
         int nDiff;

/* Need to update i and nId if keys were added before them */
         nDiff = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L) - nKeys;
         nKeys += nDiff;
         i += nDiff;
         nId += nDiff;
      }

      result = -IDS_OUTOFMEMORY;
      if(!(hPart=MyGetPartialPath(i, nId)))
         goto Error2;
      pPart = LocalLock(hPart);
      if(MyGetValue(i, &hValue) != ERROR_SUCCESS)
         goto Error3;

      if(SDKSetValue(-nNewKey, pPart, LocalLock(hValue)) != ERROR_SUCCESS)
         goto Error4;

      result = nId;
Error4:
      LocalUnlock(hValue);
      LocalFree(hValue);
Error3:
      LocalUnlock(hPart);
      LocalFree(hPart);
Error2:
      ;
   }

Error1:
   if(pPars)
      LocalUnlock(hPars);
   return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\disasm.c ===
/* disasm.c
   Future Features -

   Current bugs -
     Data32 for
       (callf  fword ptr [mem]), (jmpf  fword ptr [mem])
     Floating point insns
     Call not tested
     jecxz disassembled as large_address, not large_data
     lidt/lgdt are 6-byte operands
     segload doesn't set memXxxxx vars
     some 0x0f opcodes should set gpSafe flag
       bt, bts, btr, btc
       SetBcc [mem]
       SHD[l,r]
*/

#include <string.h>
#include <windows.h>	/* wsprintf() */
#include "disasm.h"

#define STATIC /* static */

STATIC byte lookup[256];	/* lookup table for first byte of opcode */

STATIC int dataSize, adrSize,	/* flag to indicate 32 bit data/code */
  segSize;			/* flag if 32 bit code segment */
STATIC char *preSeg = "";	/* segment prefix string */
/* static char *prefix = "";	/* REP/REPE prefix string */

enum {				/* operand decoding classes */
	UNK, 	NOOP, 	BREG, 	VREG, 	SREG,	BWI, 	BRI, 	WRI,
	SMOV, 	IMOV, 	IBYTE, 	IWORD,	JMPW,	JMPB, 	LEA,	JCond,
	GrpF,	Grp1,	Grp2,	Grp3,	Grp4,	Grp5,	IADR,	MOVABS,
	RRM,	RRMW,	IMUL,	POPMEM,	TEST,	ENTER,	FLOP,	ARPL,
	INOUT,	IWORD1, ASCII,	XLAT,
};

STATIC char bregs[8][3] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};
STATIC char wregs[8][3] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
STATIC char dregs[8][4] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};

STATIC char sregs[8][3] = {"es", "cs", "ss", "ds", "fs", "gs", "?", "?"};
STATIC char grp1[8][4] = {"add", "or", "adc", "sbb", "and", "sub", "xor", "cmp"};
STATIC char grp2[8][4] = {"rol", "ror", "rcl", "rcr", "shl", "shr", "shl", "sar"};
STATIC char grp3[8][5] = {"test", "?", "not", "neg", "mul", "imul", "div", "idiv"};
STATIC char grp5[8][6] = {"inc", "dec", "call", "callf", "jmp", "jmpf", "push", "?"};
STATIC char grp6[8][5] = {"sldt", "str", "lldt", "ltr", "verr", "verw", "?", "?"};
STATIC char grp7[8][7] = {"sgdt", "sidt", "lgdt", "lidt", "smsw", "?", "lmsw", "invlpg"};
STATIC char grp8[8][4] = {"?", "?", "?", "?", "bt", "bts", "btr", "btc"};
STATIC char *jcond[] = {"jo", "jno", "jb", "jae", "jz", "jnz", "jbe", "ja",
			"js", "jns", "jp", "jnp", "jl", "jge", "jle", "jg"};

#define opBase 0
STATIC struct {
  char *name;		/* opcode mnemonic */
  byte base, count;	/* first table entry, number of entries */
  byte operand;		/* operand class */
} ops[] = {
  "?UNKNOWN", 0, 0, UNK,	"add", 0x00, 6, BWI,
  "or",  0x08, 6, BWI,		"FGrp", 0x0f, 1, GrpF,
  "adc", 0x10, 6, BWI,		"sbb", 0x18, 6, BWI,
  "and", 0x20, 6, BWI,		"sub", 0x28, 6, BWI,
  "xor", 0x30, 6, BWI,		"cmp", 0x38, 6, BWI,
  "inc", 0x40, 8, VREG,		"dec", 0x48, 8, VREG,
  "push", 0x50, 8, VREG,	"pop", 0x58, 8, VREG,
  "bound", 0x62, 1, RRMW,	"arpl", 0x63, 1, ARPL,
  "push", 0x68, 1, IWORD,	"imul", 0x69, 3, IMUL,
  "push", 0x6a, 1, IBYTE,	"jcond", 0x70, 16, JCond,
  "Grp1", 0x80, 4, Grp1,	"test", 0x84, 2, RRM,
  "xchg", 0x86, 2, RRM,		"mov", 0x88, 4, BWI,
  "mov", 0x8c, 3, SMOV,		"lea", 0x8d, 1, LEA,
  "pop", 0x8f, 1, POPMEM,       "xchg", 0x90, 8, VREG,
  "callf", 0x9a, 1, IADR,	"mov", 0xa0, 4, MOVABS,
  "test", 0xa8, 2, TEST,	"mov", 0xb0, 8, BRI,
  "mov", 0xb8, 8, WRI,		"Grp2", 0xc0, 2, Grp2,
  "retn", 0xc2, 1, IWORD1,	"les", 0xc4, 1, RRMW,
  "lds", 0xc5, 1, RRMW,		"mov", 0xc6, 2, IMOV,
  "enter", 0xc8, 1, ENTER,	"retf", 0xca, 1, IWORD1,
  "int", 0xcd, 1, IBYTE,	"Grp2", 0xd0, 4, Grp2,
  "aam", 0xd4, 1, ASCII,	"aad", 0xd5, 1, ASCII,
  "xlat", 0xd7, 1, XLAT,
  "float", 0xd8, 8, FLOP,	"loopne", 0xe0, 1, JMPB,
  "loope", 0xe1, 1, JMPB,	"loop", 0xe2, 1, JMPB,
  "jcxz", 0xe3, 1, JMPB,	"in", 0xe4, 2, INOUT,
  "out", 0xe6, 2, INOUT,	"call", 0xe8, 1, JMPW,
  "jmp", 0xe9, 1, JMPW,		"jmpf", 0xea, 1, IADR,
  "jmp", 0xeb, 1, JMPB,		"Grp3", 0xf6, 2, Grp3,
  "Grp4", 0xfe, 1, Grp4,	"Grp5", 0xff, 1, Grp5,
};
#define opCnt (sizeof(ops)/sizeof(ops[0]))

#define simpleBase (opBase + opCnt)
STATIC struct {			/* these are single byte opcodes, no decode */
  byte val;
  char *name;
} simple[] = {
  0x06, "push	es",
  0x07, "pop	es",
  0x0e, "push	cs",
  0x16, "push	ss",
  0x17,	"pop	ss",
  0x1e, "push	ds",
  0x1f, "pop	ds",
  0x27, "daa",
  0x2f, "das",
  0x37, "aaa",
  0x3f, "aas",
  0x90, "nop",
  0x9b, "wait",
  0x9e, "sahf",
  0x9f, "lahf",
  0xc3, "retn",
  0xc9, "leave",
  0xcb, "retf",
  0xcc, "int	3",
  0xce, "into",
  0xec, "in	al, dx",
  0xee, "out	dx, al",
  0xf0, "lock",
  0xf2, "repne",
  0xf3, "rep/repe",
  0xf4, "hlt",
  0xf5, "cmc",
  0xf8, "clc",
  0xf9, "stc",
  0xfa, "cli",
  0xfb, "sti",
  0xfc, "cld",
  0xfd, "std",
};
#define simpleCnt (sizeof(simple)/sizeof(simple[0]))

#define dSimpleBase (simpleBase + simpleCnt)
STATIC struct {			/* these are simple opcodes that change */
  byte val;			/* based on current data size */
  char *name, *name32;
} dsimple[] = {
  0x60, "pusha", "pushad",
  0x61, "popa", "popad",
  0x98, "cbw", "cwde",
  0x99, "cwd", "cdq",
  0x9c, "pushf", "pushfd",
  0x9d, "popf", "popfd",
  0xcf, "iret", "iretd",
  0xed, "in	ax, dx", "in	eax, dx",
  0xef, "out	dx, ax", "out	dx, eax",
};
#define dSimpleCnt (sizeof(dsimple)/sizeof(dsimple[0]))

#define STR_S 1				/* string op, source regs */
#define STR_D 2				/* string op, dest regs */
#define STR_D_Read	4		/* string op, reads from dest regs */
#define STR_NO_COND	8		/* rep ignores flags */
#define stringOpBase (dSimpleBase+ dSimpleCnt)
STATIC struct {
  byte val;
  char *name;
  byte flag;		/* should be 'next' to op, to pack nicely */
} stringOp[] = {
  0x6c, "ins", STR_D | STR_NO_COND,
  0x6e, "outs", STR_S | STR_NO_COND,
  0xa4, "movs", STR_S | STR_D | STR_NO_COND,
  0xa6, "cmps", STR_S | STR_D | STR_D_Read,
  0xaa, "stos", STR_D | STR_NO_COND,
  0xac, "lods", STR_S | STR_NO_COND,
  0xae, "scas", STR_D | STR_D_Read,
};
#define stringOpCnt (sizeof(stringOp)/sizeof(stringOp[0]))

STATIC void InitDisAsm86(void) {
  int i, j;
  for (i=0; i<opCnt; i++) {		/* Init complex entries */
    for (j=0; j<(int)ops[i].count; j++)
      lookup[ops[i].base+j] = (byte)i + opBase;
  }

  for (i=0; i<simpleCnt; i++)		/* Init simple entries */
    lookup[simple[i].val] = (byte)(i + simpleBase);

  for (i=0; i<dSimpleCnt; i++)		/* Init simple 16/32 bit entries */
    lookup[dsimple[i].val] = (byte)(i + dSimpleBase);

  for (i=0; i<stringOpCnt; i++)	{	/* Init string op table */
    lookup[stringOp[i].val] = (byte)(i + stringOpBase);
    lookup[stringOp[i].val+1] = (byte)(i + stringOpBase);
  }
} /* InitDisAsm86 */

STATIC byte far *code;		/* this is ugly - it saves passing current */
				/* code position to all the GetByte() funcs */

#define Mid(v) (((v) >> 3) & 7)	/* extract middle 3 bits from a byte */

word gpSafe, gpRegs, gpStack;	/* indicate side effects of instruction */

extern word regs[];		/* this is a lie - this is really a struct - */
extern dword regs32[];		/* and so is this - but array access is more */
				/* convenient in this module */

  /* If you don't want to return memory access info, #def NO_MEM */
#if !defined(NO_MEM)
  /* global vars set by DisAsm() to indicate current instruction's memory */
  /* access type. */
word memSeg, memSize, memOp;	/* segment value, operand size, operation */
word memSeg2, memSize2, memOp2,	/* instruction may have two memory accesses */
  memDouble;
dword memLinear, memLinear2;	/* offset from segment of access */

STATIC dword memReg, memDisp;	/* used to pass information from GetReg()... */
char *memName[] = {		/* used to convert 'enum memOp' to ascii */
  "NOP",
  "Read",
  "Write",
  "RMW",
  "MovStr",
};

#define SetMemSize(s) memSize = s
#define SetMemSeg(s) memSeg = regs[s+9]
#define SetMemOp(o) memOp = o
#define SetMemLinear(l) memLinear = l
#define SetMemSeg2(s) memSeg2 = regs[s+9]
#define SetMemOp2(o) memOp2 = o
#define SetMemLinear2(l) memLinear2 = l
#define ModMemLinear(l) memLinear += l
#define SetMemReg(r) memReg = r
#define SetMemDisp(d) memDisp = d
#define Read_RMW(o) ((o) ? memRead : memRMW)

#else

#define SetMemSeg(s)
#define SetMemSize(s)
#define SetMemOp(o)
#define SetMemLinear(l)
#define SetMemSeg2(s)
#define SetMemOp2(o)
#define SetMemLinear2(l)
#define ModMemLinear(l)
#define SetMemReg(r)
#define SetMemDisp(d)
#define Read_RMW(o)	0

#endif

/******************** Register Decode *******************************/
/* These helper functions return char pointers to register names.
   They are safe to call multiple times, as the return values are not
   stored in a single buffer.  The ?Reg() functions are passed a register
   number.  They mask this with 7, so you can pass in the raw opcode.
   The ?Mid() functions extract the register field from e.g. a ModRM byte.
   The Vxxx() functions look at dataSize to choose between 16 and 32 bit
   registers.  The Xxxx() functions look at the passed in W bit, and then
   the dataSize global, do decide between 8, 16, and 32 bit registers.
*/

STATIC char *BReg(int reg) {			/* Byte Registers */
  reg &= 7;
  SetMemReg(((byte *)regs)[reg]);
  return bregs[reg];
} /* BReg */

STATIC char *BMid(int reg) {
  return BReg(Mid(reg));
} /* BMid */

STATIC char *WReg(int reg) {			/* Word Registers */
  reg &= 7;
  SetMemReg(regs[reg]);
  return wregs[reg];
} /* WReg */

/* STATIC char *WMid(int op) {
  return WReg(Mid(op));
} /* WMid */

STATIC char *DReg(int reg) {			/* DWord Registers */
  reg &= 7;
  SetMemReg(regs32[reg]);
  return dregs[reg];
} /* DReg */

STATIC char *DMid(int op) {
  return DReg(Mid(op));
} /* DMid */

STATIC char *VReg(int reg) {			/* Word or DWord Registers */
  if (dataSize) return DReg(reg);
  return WReg(reg);
} /* VReg */

STATIC char *VMid(int op) {
  return VReg(Mid(op));
} /* VMid */

STATIC char *XReg(int w, int reg) {		/* Byte, Word, DWord Registers */
  if (!w) return BReg(reg);
  return VReg(reg);
} /* XReg */

STATIC char *XMid(int w, int op) {
  return XReg(w, Mid(op));
} /* XMid */

/************************* Opcode Fetch ***************************/

  /* hexData is a global array, containing a hexadecimal dump of the */
  /* opcodes of the last instruction disassembled. */
char hexData[40];		/* We dump the opcode fetched here */
STATIC int hexPos;		/* current position in hexData buffer */

  /* GetByte(), GetWord(), and GetDWord() read from the code segment */
  /* and increment the pointer appropriately.  They also add the current */
  /* value to the hexData display, and set the MemDisp global in case the */
  /* value fetched was a memory displacement */
STATIC byte GetByte(void) {             /* Read one byte from code segment */
  sprintf(hexData+hexPos, " %02x", *code);
  hexPos += 3;
  SetMemDisp(*code);
  return *code++;
} /* GetByte */

STATIC word GetWord(void) {		/* Read two bytes from code seg */
  word w = *(word far *)code;
  sprintf(hexData+hexPos, " %04x", w);
  hexPos += 5;
  code += 2;
  SetMemDisp(w);
  return w;
} /* GetWord */

STATIC long GetDWord(void) {		/* Read four bytes from code seg */
  unsigned long l = *(long far *)code;
  sprintf(hexData+hexPos, " %08lx", l);
  hexPos += 9;
  code += 4;
  SetMemDisp(l);
  return l;
} /* GetDWord */


STATIC char immData[9];			/* Get Immediate values from code */


  /* GetImmByte(), GetImmWord(), and GetImmDWord() all get the proper size */
  /* data object, convert it to hex/ascii, and return the string created. */
  /* They return a pointer to a shared static object, so don't combine */
  /* multiple calls to these functions in a single expression. */
STATIC char *GetImmByte(void) {
  sprintf(immData, "%02x", GetByte());
  return immData;
} /* GetImmByte */

STATIC char *GetSImmByte(void) {
  sprintf(immData, "%02x", (char)GetByte());
  memDisp = (signed char)memDisp;	/* sign extend */
  return immData;
} /* GetSImmByte */

STATIC char *GetImmWord(void) {
  sprintf(immData, "%04x", GetWord());
  return immData;
} /* GetImmWord */

STATIC char *GetImmDWord(void) {
  sprintf(immData, "%08lx", GetDWord());
  return immData;
} /* GetImmDWord */

  /* GetImmAdr() and GetImmData() call GetImm????() as required by the */
  /* 'width' flag passed in, and the adrSize or dataSize global flags. */
  /* They return the proper character string - note that these just call */
  /* GetImm????(), and use the same static buffer, so don't call more than */
  /* once in a single expression */
STATIC char *GetImmAdr(int w) {		/* Get an immediate address value */
  if (!w) return GetImmByte();
  else if (!adrSize) return GetImmWord();
  return GetImmDWord();
} /* GetImmAdr */

STATIC char *GetImmData(int w) {	/* Get an immediate data value */
  if (!w) return GetImmByte();
  else if (!dataSize) return GetImmWord();
  return GetImmDWord();
} /* GetImmData */

/************************* Helper Functions **************************/

STATIC char *JRel(int jsize) {		/* Perform relative jump sizing */
  long rel;
  static char adr[9];
  char *s;

  if (jsize < 2) {
    rel = (char)GetByte();
    s = "short ";
  } else if (!adrSize) {
    rel = (short)GetWord();
    s = "near ";
  } else {
    rel = GetDWord();
    s = "";
  }
  rel += (word)(long)code;
  sprintf(adr, adrSize ? "%s%08lx" : "%s%04lx", (FP)s, rel);
  return adr;
} /* JRel */


enum {
  RegAX, RegCX, RegDX, RegBX, RegSP, RegBP, RegSI, RegDI
};

#define Reg1(r1) (r1) | 0x80
#define Reg2(r1, r2) (r1 | (r2 << 4))
#define RegSS 8

STATIC byte rms[] = {			/* 16 bit addressing modes */
  Reg2(RegBX, RegSI),
  Reg2(RegBX, RegDI),
  Reg2(RegBP|RegSS, RegSI),		/* if base reg is BP, def seg is SS */
  Reg2(RegBP|RegSS, RegDI),
  Reg1(RegSI),
  Reg1(RegDI),
  Reg1(RegBP|RegSS),
  Reg1(RegBX),
};

  /* Based on the second byte of opcode, width flag, adrSize and dataSize, */
  /* determine the disassembly of the current instruction, and what */
  /* memory address was referenced */
  /* needinfo indicates that we need a size override on a memory operand */
  /* for example, "mov [bx], ax" is obviously a 16 bit move, while */
  /* "mov [bx], 0" could be 8, 16, or 32 bit.  We add the proper */
  /* "mov word ptr [bx], 0" information. */
  /* The 'mem' parameter indicates the kind of operation, Read, Write, RMW */

  /* don't bother trying to understand this code without an Intel manual */
  /* and assembler nearby. :-) */
STATIC char *ModRMGeneral(byte op, int w, int needInfo, int mem) {
  static char m[30];			/* write result to this static buf */
  int mod = op >> 6;
  int rm = op & 7;
  char *size, *base, *index, *disp;
  char indexBuf[6];

  base = index = disp = "";
  if (!w) {				/* set mem size, and info string */
    size = "byte ptr ";
    SetMemSize(1);
  } else if (!dataSize) {
    size = "word ptr ";
    SetMemSize(2);
  } else {
    size = "dword ptr ";
    SetMemSize(4);
  }
  if (!needInfo) size = "";		/* never-mind */

  if (adrSize) {			/* do 32 bit addressing */
    if (mod == 3) return XReg(w, rm);	/* register operand */

    if (rm == 4) {			/* [esp+?] is special S-I-B style */
      byte sib = GetByte();
      int scaleVal = sib >> 6, indexVal = Mid(sib), baseVal = sib & 7;

      SetMemLinear(0);
      if (baseVal == 5 && mod == 0)	/* [ebp+{s_i}] becomes [d32+{s_i}] */
	mod = 2;
      else {
	base = DReg(baseVal);
	ModMemLinear(memReg);
      }

      if (indexVal != 4) {		/* [base+esp*X] is undefined */
	sprintf(indexBuf, "%s*%d", (FP)DMid(sib), 1 << scaleVal);
	index = indexBuf;
	ModMemLinear(memReg << scaleVal);
      }
    } else {				/* not S-I-B */
      if (mod == 0 && rm == 5) mod = 2;	/* [ebp] becomes [d32] */
      else base = DReg(rm);
    }

    if (mod==1) disp = GetImmAdr(0);
    else if (mod == 2) disp = GetImmAdr(1);
    if (mod) ModMemLinear(memDisp);

  } else {				/* do 16 bit addressing */
    if (mod == 3) return XReg(w, rm);	/* register operand */
    if (mod == 0 && rm == 6) {		/* [bp] becomes [mem16] */
      disp = GetImmAdr(1);
      SetMemLinear(memDisp);
    } else {
      base = WReg(rms[rm] & 7);
      SetMemLinear(memReg);
      if (!(rms[rm] & 0x80)) {		/* if two-reg effective address */
	index = WReg(rms[rm] >> 4);
	ModMemLinear(memReg);
      }
      if (rms[rm] & RegSS && !preSeg[0]) { /* BP is relative to SS */
	SetMemSeg(memSS);
      }
      if (mod) {			/* (mod3 already returned) */
	disp = GetImmAdr(mod-1);	/* mod==1 is byte, mod==2 is (d)word */
	ModMemLinear(memDisp);
      }
    }
  }
  sprintf(m, "%s%s[%s", (FP)size, (FP)preSeg, (FP)base);
  if (*index) strcat(strcat(m, "+"), index);
  if (*disp) {
    if (*base || *index) strcat(m, "+");
    strcat(m, disp);
  }
  SetMemOp(mem);
  strcat(m, "]");
  return m;
} /* ModRMGeneral */

  /* magic func that sets 'info-required' flag to ModRMGeneral */
STATIC char *ModRMInfo(byte op, int w, int mem) {
  return ModRMGeneral(op, w, 1, mem);
} /* ModRMInfo */

  /* magic func that doesn't require info */
STATIC char *ModRM(byte op, int w, int mem) {
  return ModRMGeneral(op, w, 0, mem);
} /* ModRM */


STATIC char line[80];	/* this is bad - global var where insn is created */

  /* CatX() - combine opcode and 0 to 3 operands, store in line[] */
  /* It places the TAB after the opcode, and ', ' between operands */

STATIC char *Cat0(char *s0) {
  return strcat(line, s0);
#if 0
  if (prefix[0]) {
    char temp[80];
    if (s0 == line) {
      strcpy(temp, s0);
      s0 = temp;
    }
    strcat(strcpy(line, prefix), s0);
    prefix = "";
  } else strcpy(line, s0);
  return line;
#endif
} /* Cat0 */

STATIC char *Cat1(char *s0, char *s1) {
  return strcat(strcat(Cat0(s0), "\t"), s1);
} /* Cat1 */

STATIC char *Cat2(char *s0, char *s1, char *s2) {
  return strcat(strcat(Cat1(s0, s1), ", "), s2);
} /* Cat2 */

STATIC char *Cat3(char *s0, char *s1, char *s2, char *s3) {
  return strcat(strcat(Cat2(s0, s1, s2), ", "), s3);
} /* Cat3 */

#define SetGroup(g) /* group = g */
/* STATIC int group; */

  /* Disassemble the 386 instructions whose first opcode is 0x0f */
  /* Sorry, but this is just too ugly to comment */
STATIC char *DisAsmF(void) {
  byte op0, op1;
  char temp[8];
  char *s0, *s1;
  int mask;

  op0 = GetByte();
  switch (op0 >> 4) {			/* switch on top 4 bits of opcode */
    case 0:
      switch (op0 & 0xf) {
	case 0: /* grp6 */
	  SetGroup(2);
	  op1 = GetByte();
	  dataSize = 0;
	  return Cat1(grp6[Mid(op1)], ModRMInfo(op1, 1, Read_RMW(Mid(op1) >= 2)));
	case 1: /* grp7 */
	  SetGroup(2);
	  op1 = GetByte();
	  dataSize = 0;
	  return Cat1(grp7[Mid(op1)], ModRMInfo(op1, 1, Read_RMW(Mid(op1) & 2)));
	case 2:
	  op1 = GetByte();
	  s1 = VMid(op1);
	  /* dataSize = 0; */
	  return Cat2("lar", s1, ModRMInfo(op1, 1, memRead));
	case 3:
	  op1 = GetByte();
	  s1 = VMid(op1);
	  /* dataSize = 0; */
	  return Cat2("lsl", s1, ModRMInfo(op1, 1, memRead));
	case 6: return "clts";
	case 8: return "invd";
	case 9: return "wbinvd";
      }
      break;

    case 2:	/* Mov C/D/Treg, reg */
      op1 = GetByte();
      switch (op0 & 0xf) {
	case 0:
	case 2:
	  s1 = "c";
	  mask = 1 + 4 + 8;
	  break;
	case 1:
	case 3:
	  s1 = "d";
	  mask = 1 + 2 + 4 + 8 + 64 + 128;
	  break;
	case 4:
	case 6:
	  s1 = "t";
	  mask = 8 + 16 + 32 + 64 + 128;
	  break;
	default:
	  s1 = "??";
	  mask = 0;
      }
      if (!((1 << Mid(op1)) & mask))	/* various legal register combos */
	return "Illegal reg";

      s0 = DReg(op1);
      if (op0 & 2) sprintf(line, "mov\t%sr%d, %s", (FP)s1, Mid(op1), (FP)s0);
      else sprintf(line, "mov\t%s, %sr%d", (FP)s0, (FP)s1, Mid(op1));
      return line;

    case 8: /* long displacement jump on condition */
      return Cat1(jcond[op0&0xf], JRel(2));

    case 9: /* byte set on condition */
      strcpy(temp, "set");
      strcat(temp, jcond[op0&0xf]+1);
      return Cat1(temp, ModRMInfo(GetByte(), 0, memWrite));

    case 0xa:
      switch (op0 & 0xf) {
	case 0: return "push	fs";
	case 1: return "pop	fs";
	case 3: case 0xb:
	  s0 = op0 & 8 ? "bts" : "bt";
	  op1 = GetByte();
	  return Cat2(s0, ModRM(op1, 1, memRMW), VMid(op1));
	case 4: case 0xc:
	  s0 = op0 & 8 ? "shrd" : "shld";
	  op1 = GetByte();
	  s1 = ModRM(op1, 1, memRMW);
	  return Cat3(s0, s1, VMid(op1), GetImmData(0));
	case 5: case 0xd:
	  s0 = op0 & 8 ? "shrd" : "shld";
	  op1 = GetByte();
	  s1 = ModRM(op1, 1, memRMW);
	  return Cat3(s0, s1, VMid(op1), "cl");
	case 6:
	  op1 = GetByte();
	  return Cat2("cmpxchg", ModRM(op1, 0, memRMW), BMid(op1));
	case 7:
	  op1 = GetByte();
	  return Cat2("cmpxchg", ModRM(op1, 1, memRMW), VMid(op1));
	case 8: return "push	gs";
	case 9: return "pop	gs";
	case 0xf:
	  op1 = GetByte();
	  return Cat2("imul", VMid(op1), ModRM(op1, 1, memRead));
      }
      break;

    case 0xb:
      switch (op0 & 0xf) {
	case 2:	case 4: case 5:
	  s0 = (op0 & 2) ? "lss" : (op0 &1) ? "lgs" : "lfs";
	  op1 = GetByte();
	  return Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
	case 3: case 0xb:
	  s0 = (op0 & 8) ? "btc": "btr";
	  op1 = GetByte();
	  return Cat2(s0, ModRM(op1, 1, memRMW), VMid(op1));
	case 6: case 7: case 0xe: case 0xf:
	  s0 = (op0 & 8) ? "movsx" : "movzx";
	  op1 = GetByte();
	  s1 = VMid(op1);
	  dataSize = 0;
	  return Cat2(s0, s1, ModRMInfo(op1, op0&1, memRead));
	case 0xa:
	  SetGroup(2);
	  op1 = GetByte();
	  s0 = grp8[Mid(op1)];
	  s1 = ModRMInfo(op1, 1, memRMW);
	  return Cat2(s0, s1, GetImmData(0));
	case 0xc: case 0xd:
	  op1 = GetByte();
	  s0 = (op0 & 1) ? "bsr" : "bsf";
	  return Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
      }
      break;

    case 0xc:
      if (op0 > 0xc7) return Cat1("bswap", DReg(op0 & 7));
      if (op0 < 0xc2) {
	op1 = GetByte();
	return Cat2("xadd", ModRM(op1, op0&1, memRMW), XMid(op0&1, op1));
      }
      break;
    default:
      break;
  }
  sprintf(line, "?Unknown 0f %02x", op0);
  return line;
} /* DisAsmF */

int IsPrefix(byte op0) {
  switch (op0) {			/* check for prefix bytes */

#define CSEG 0x2e
#define DSEG 0x3e
#define ESEG 0x26
#define SSEG 0x36
#define FSEG 0x64
#define GSEG 0x65
#define REP 0xf3
#define REPNE 0xf2
#define DATA32 0x66
#define ADR32 0x67

    case CSEG:  preSeg = "cs:"; SetMemSeg(memCS); break;
    case DSEG:  preSeg = "ds:"; SetMemSeg(memDS); break;
    case ESEG:  preSeg = "es:"; SetMemSeg(memES); break;
    case SSEG:  preSeg = "ss:"; SetMemSeg(memSS); break;
    case FSEG:  preSeg = "fs:"; SetMemSeg(memFS); break;
    case GSEG:  preSeg = "gs:"; SetMemSeg(memGS); break;
    case REP:   strcpy(line, "repe\t"); gpRegs |= strCX; break;
    case REPNE: strcpy(line, "repne\t"); gpRegs |= strCX; break;
    case ADR32:
      /* printf("Adr32\n"); */
      adrSize = !adrSize; break;
    case DATA32:
      /* printf("Data32\n"); */
      dataSize = !dataSize; break;
    default:
      return 0;
  }
  return 1;
} /* IsPrefix */

  /* like, call this with a pointer to the instruction, it will return */
  /* the opcode bytes used in *len, and a pointer to the disassembled insn */
char *DisAsm86(byte far *codeParm, int *len) {
  byte far *oldcode;
  byte op0, op1;
  byte opclass;
  static int init;
  char operand[40];
  char *(*Reg)(int);
  char *s0, *s1, *s2, *s3;

  if (!init) {
    InitDisAsm86();
    init = 1;
  }
  adrSize = dataSize = segSize;
  preSeg = "";
  hexPos = 0;
  memDouble = 0;
  line[0] = 0;
  gpSafe = gpRegs = gpStack = 0;
  code = oldcode = codeParm;
  do {
    op0 = GetByte();
  } while (IsPrefix(op0));
  opclass = lookup[op0];

  SetMemOp(memNOP);
  if (!preSeg[0]) SetMemSeg(memDS);

  if (opclass >= simpleBase) {		/* is it special */
    if (opclass >= stringOpBase) {	/* string operations? */
      char cmd;

      opclass -= stringOpBase;
      cmd = stringOp[opclass].flag;
      if (cmd & STR_NO_COND) strcpy(line+3, "\t");
      if (cmd & STR_S) {
	gpRegs |= strSI;
	SetMemOp(memRead);
	/* DS already set */
	VReg(RegSI);
	SetMemLinear(memReg);
	if (cmd & STR_D) {
	  gpRegs |= strDI;
	  SetMemOp2(cmd & STR_D_Read ? memRead : memWrite);
	  SetMemSeg2(memES);
	  VReg(RegDI);
	  SetMemLinear2(memReg);
	  memDouble = 1;
	}
      } else {
	gpRegs |= strDI;
	SetMemOp(cmd & STR_D_Read ? memRead : memWrite);
	SetMemSeg(memES);
	VReg(RegDI);
	SetMemLinear(memReg);
      }

      if (op0 & 1) {
	if (dataSize) { s1 = "d"; SetMemSize(4); }
	else { s1 = "w"; SetMemSize(2); }
      } else { s1 = "b"; SetMemSize(1); }


      s0 = strcat(strcpy(operand, stringOp[opclass].name), s1);
    } else if (opclass >= dSimpleBase) {
      opclass -= dSimpleBase;
      s0 = dataSize ? dsimple[opclass].name32 : dsimple[opclass].name;
    } else {
      s0 = simple[opclass-simpleBase].name;
      if (op0 == 7) {			/* pop ES */
	gpRegs = segES;
	gpSafe = 1;
	gpStack = 1;
      } else if (op0 == 0x1f) {		/* pop DS */
	gpRegs = segDS;
	gpSafe = 1;
	gpStack = 1;
      }
    }
    Cat0(s0);
    goto DisAsmDone;
  }

  if (op0 == 0x0f) {			/* is it an extended opcode? */
    s0 = DisAsmF();
    strcpy(line, s0);
    goto DisAsmDone;
  }

  s0 = ops[opclass].name;
  switch (ops[opclass].operand) {
    case NOOP:
      Cat0(s0);
      break;

    case VREG:	/* inc, dec, push, pop, xchg */
      if ((op0 & ~7) == 0x90) Cat2(s0, "ax", VReg(op0&7));
      else Cat1(s0, VReg(op0&7));
      /* Set memop for Push/Pop as modifying stack values */
      break;

    case BWI:	/* byte/word/immediate */
      gpSafe = 1;
      if (!(op0&1)) Reg = BReg;
      else if (!dataSize) Reg = WReg;
      else Reg = DReg;
      if (op0 & 4) {
	Cat2(s0, Reg(0), GetImmData(op0&1));
      } else {
	int i;
	op1 = GetByte();
	if ((op0 & 0xf8) == 0x38) i = memRead;
	else if ((op0 & 0xfe) == 0x88) i = memWrite;
	else i = Read_RMW(op0 & 2);
	s1 = ModRM(op1, op0&1, i);
	s2 = Reg(Mid(op1));
	if (op0 & 2) {
	  s3 = s2; s2 = s1; s1 = s3;
	}
	Cat2(s0, s1, s2);
      }
      break;

    case BRI:	/* byte reg immediate */
      Cat2(s0, BReg(op0 & 7), GetImmData(0));
      break;

    case WRI:	/* word reg immediate */
      Cat2(s0, VReg(op0 & 7), GetImmData(1));
      break;

    case Grp1:	/* group 1 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, Mid(op1) == 7 ? memRead : memRMW);
      Cat2(grp1[Mid(op1)], s1, GetImmData((op0&3)==1));
      break;

    case Grp2:	/* group 2 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, memRMW);
      s2 = (op0 & 0x10) ? (op0 & 2 ? "cl" : "1")  : GetImmData(0);
      Cat2(grp2[Mid(op1)], s1, s2);
      break;

    case Grp3:	/* group 3 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) <2 || Mid(op1) >3));
      s0 = grp3[Mid(op1)];
      if (Mid(op1) < 2) Cat2(s0, s1, GetImmData(op0&1));
      else Cat1(s0, s1);
      break;

    case Grp4:	/* group 4 instructions */
      SetGroup(1);
      op1 = GetByte();
      if (Mid(op1) > 1) Cat0("?");
      else {
	Cat1(grp5[Mid(op1)], ModRMInfo(op1, op0&1, memRMW));
	gpSafe = 1;
      }
      break;

    case Grp5:	/* group 5 instructions */
      op1 = GetByte();
      if (Mid(op1) < 3) {
	gpSafe = 1;
	if (Mid(op1) == 2) {
	  gpStack = -1 << dataSize;
	}
      }
      SetGroup(1);
      Cat1(grp5[Mid(op1)], ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) >= 2)));
      break;

    case SMOV:	/* segment move */
      gpSafe = 1;
      op1 = GetByte();
      dataSize = 0;
      s1 = ModRM(op1, 1, Read_RMW(op0&2));
      s2 = sregs[Mid(op1)];
      if (op0 & 2) {			/* if moving _to_ SREG */
	s3 = s2; s2 = s1; s1 = s3;	/* switch operands */
	switch (Mid(op1)) {
	  case 0: gpRegs = segES; break;
	  case 3: gpRegs = segDS; break;
	  case 4: gpRegs = segFS; break;
	  case 5: gpRegs = segGS; break;
	  default: gpSafe = 0;
	}
      }
      Cat2(s0, s1, s2);
      break;

    case IMOV:	/* immediate move to reg/mem */
      gpSafe = 1;
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, memWrite);
      Cat2(s0, s1, GetImmData(op0&1));
      break;

    case IBYTE:	/* immediate byte to reg */
      sprintf(line, "%s\t%02x", (FP)s0, (char)GetByte());
      break;

    case IWORD:	/* immediate word to reg - size of data */
      Cat1(s0, GetImmData(1));
      break;

    case IWORD1: /* immediate word - always 16 bit */
      Cat1(s0, GetImmWord());
      break;

    case JMPW:
      Cat1(s0, JRel(2));
      break;

    case JMPB:
      Cat1(s0, JRel(1));
      break;

    case LEA:
      op1 = GetByte();
      Cat2(s0, VMid(op1), ModRM(op1, 1, memNOP));
      break;

    case JCond:
      Cat1(jcond[op0&0xf], JRel(1));
      break;

    case IADR:
      s2 = GetImmAdr(1);
      sprintf(line, "%s\t%04x:%s", (FP)s0, GetWord(), (FP)s2);
      break;

    case MOVABS: /* move between accum and abs mem address */
      gpSafe = 1;
      s1 = XReg(op0 & 1, 0);
      sprintf(operand, "[%s%s]", (FP)preSeg, (FP)GetImmAdr(1));
      SetMemLinear(memDisp);
      SetMemSize(!(op0&1) ? 1 : (!dataSize ? 2 : 4));
      SetMemOp(op0&2 ? memWrite : memRead);
      s2 = operand;
      if (op0 & 2) {
	s3 = s2; s2 = s1; s1 = s3;
      }
      Cat2(s0, s1, s2);
      break;

    case IMUL:
      op1 = GetByte();
      s1 = VMid(op1);
      s2 = ModRM(op1, 1, memRead);
      s3 = GetImmData(!(op0&2));
      Cat3(s0, s1, s2, s3);
      break;

    case POPMEM:
      gpSafe = 1;
      gpStack = 1 << dataSize;
      Cat1(s0, ModRMInfo(GetByte(), 1, memWrite));
      break;

    case RRM:	/* test and xchg */
      gpSafe = 1;
      op1 = GetByte();
      s2 = ModRM(op1, op0&1, memRMW);
      Cat2(s0, XMid(op0&1, op1), s2);
      break;

    case RRMW:	/* bound, les, lds */
      op1 = GetByte();
      switch (op0) {
	case 0xc4:	/* les reg, [mem] */
	  gpRegs = segES;
	  gpSafe = 1;
	  break;
	case 0xc5:	/* lds reg, [mem] */
	  gpRegs = segDS;
	  gpSafe = 1;
	  break;
      }
      Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
      break;

    case TEST:	/* test al/ax/eax, imm */
      Cat2(s0, XReg(op0&1, 0), GetImmData(op0&1));
      break;

    case ENTER:
      strcpy(operand, GetImmWord());
      Cat2(s0, operand, GetImmData(0));
      break;

    case FLOP:
      op1 = GetByte();
      Cat1(s0, ModRMInfo(op1, 1, memNOP));
      break;

    case ARPL:
      op1 = GetByte();
      dataSize = 0;
      s1 = ModRM(op1, 1, memRMW);
      s2 = VMid(op1);
      Cat2(s0, s1, s2);
      break;

    case INOUT:
      s1 = XReg(op0&1, 0);
      s2 = GetImmAdr(0);
      if (op0 & 2) {
	s3 = s2; s2 = s1; s1 = s3;
      }
      Cat2(s0, s1, s2);
      break;

    case ASCII:
      Cat0(GetByte() == 10 ? s0 : "?");
      break;

    case XLAT:
      gpSafe = 1;
      SetMemOp(memRead);
      SetMemLinear(regs[RegBX] + (regs[RegAX] & 0xff));
      break;

    default:
      sprintf(line, "?Unknown opcode %02x", op0);
  }
DisAsmDone:
  *len = (int)(code - oldcode);
  return line;
} /* DisAsm86 */

  /* if you're in a 32 bit code segment, call DisAsm386 which sets */
  /* default data and address size to 32 bit */
char *DisAsm386(byte far *code, int *len) {
  adrSize = dataSize = 1;
  return DisAsm86(code, len);
} /* DisAsm386 */

/* #define FOOBAR */
#if defined(FOOBAR)

STATIC int GroupSize(int op) {
  if (op == 0xf) return 256;
/*  op = lookup[op];
  if (op > 0x80) return 1;
  if (ops[op].name[0] == 'G') return 8;
  if (ops[op].name[0] == 'F') return 256; */
  return 1;
} /* IsGroup */

/* #pragma inline */

void testfunc() {
/*  asm {
	.386p
	mov	eax, ss:[si+33h]
	rep	movsb
	mov	eax, ds:[ebp+eax*2+1234h]
  } */
}


byte foo[10];

/* #include <dos.h> */

extern void DisTest(), EndTest();

word regs[] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80, -1, -1,
  0xeeee, 0xcccc, 0x5555, 0xdddd, 0xffff, 0x6666};
dword regs32[] = {0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000};

STATIC char *Tab2Spc(char *temp) {
  char newbuf[80], *s1, *s2;
  s1 = temp;
  s2 = newbuf;
  while ((*s2 = *s1++) != 0) {
    if (*s2++ == 9) {
      s2[-1] = ' ';
      while ((s2-newbuf) & 7) *s2++ = ' ';
    }
  }
  strcpy(temp, newbuf);
  return temp;
} /* Tab2Spc */


void MemTest(void) {
  void far *vp = (void far *)DisTest;
  byte far *cp = vp, far *ep;
  int len;
  char *s;

  vp = (void far *)EndTest;
  ep = vp;

  while (cp < ep) {
    s = DisAsm86(cp, &len);
    Tab2Spc(s);
    printf("\n%04x\t%-28s", (int)cp, s);
    if (memOp) {
      printf("%04x:%04lx(%d) %-6s  ",
	    memSeg, memLinear, memSize, memName[memOp]);
      if (memDouble) {
	printf("%04x:%04lx(%d) %-6s",
	      memSeg2, memLinear2, memSize, memName[memOp2]);
      }
    }
    memSeg = memLinear = memSize = memOp = 0;
    cp += len;
  }
} /* MemTest */

void main(void) {
#if 0
  int i, j, g;
  void far *vp = (void far *)DisTest;
  byte far *cp = vp;
  byte far *ep;
  int len = 3, count;
  char *s;
#endif
  MemTest();
#if 0
  vp = (void far *)EndTest;
  ep = vp;
  printf("DisAsm86\n", (int)foo << len);

  for (i=0; i<9; i++) foo[i] = i;
/* #define CHECK */
#if defined(CHECK)
  for (i=0x0; i<256; i++) {
    foo[0] = i;
    count = GroupSize(i);
    for (j=0; j<count; j++) {
      if (((count > 1) && ((j & 7) == 0)) ||
	  ((count == 1) && ((i & 7) == 0)))
	printf("\n");
      foo[1] = j;
      foo[2] = 0;
      s = DisAsm386(foo, &len);
      if (*s != '?') printf("%02x\t%s\n", i, (FP)s);
      if (group) {
	for (g = 1; g<8; g++) {
	  foo[group] = g << 3;
	  s = DisAsm386(foo, &len);
	  if (*s != '?') printf("%02x %02x\t%s\n", i, foo[group], (FP)s);
	}
	group = 0;
      }
    }
#else
  /* for (i=0; i<10; i++) { */
  while (cp < ep) {
    s = DisAsm86(cp, &len);
    printf("%04x\t%s\n", (word)cp, (FP)s);
    cp += len;
#endif
  }
#endif
} /* main */

void far foobar() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\shell\shell.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   SHELL.ASM
;   Win16 SHELL thunks
;
;   History:
;
;   Created 14-April-1992 by Chandan S. Chauhan (ChandanC)
;
;--

        TITLE   SHELL.ASM
        PAGE    ,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
        LIBINIT equ 1

        .286p

        .xlist
        include wow.inc
        include wowshell.inc
        include cmacros.inc
        .list

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

externFP WOW16Call

ifdef LIBINIT
externFP LocalInit
endif

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  DATA
Reserved    db  16 dup (0)      ;reserved for Windows
SHELL_Identifier        db      'SHELL16 Data Segment'
sEnd    DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


cProc   SHELL16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

        cBegin <nogen>

        IFDEF   LIBINIT
        ; push params and call user initialisation code

        push di                 ;hModule

        ; if we have a local heap declared then initialize it

        jcxz no_heap

        push 0                  ;segment
        push 0                  ;start
        push cx                 ;length
        call LocalInit

no_heap:
        pop di
        mov ax, 1
        ELSE
        mov  ax,1               ;are we dressed for success or WHAT?!
        ENDIF
        ret
        cEnd <nogen>


cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
        parmW   iExit           ;DLL exit code

        cBegin
        mov     ax,1            ;always indicate success
        cEnd


assumes DS,NOTHING

        SHELLThunk      REGOPENKEY
        SHELLThunk      REGCREATEKEY
        SHELLThunk      REGCLOSEKEY
        SHELLThunk      REGDELETEKEY
        SHELLThunk      REGSETVALUE
        SHELLThunk      REGQUERYVALUE
        SHELLThunk      REGENUMKEY
        SHELLThunk      DRAGACCEPTFILES
        SHELLThunk      DRAGQUERYFILE
FUN_DragFinishWOW equ FUN_DragFinish
        SHELLThunk      DRAGFINISHWOW, %(size DRAGFINISH16)
;;;     SHELLThunk      DRAGQUERYPOINT
        SHELLThunk      SHELLEXECUTE            ;internal private for shell
        SHELLThunk      FINDEXECUTABLE          ;internal private for shell
        SHELLThunk      SHELLABOUT              ;internal private for shell
        SHELLThunk      WCI, 0                  ;internal
        SHELLThunk      ABOUTDLGPROC, 0         ;internal
        SHELLThunk      EXTRACTICON
        SHELLThunk      EXTRACTASSOCIATEDICON   ;internal private for shell
        SHELLThunk      DOENVIRONMENTSUBST
        SHELLThunk      FINDENVIRONMENTSTRING, 0
        SHELLThunk      INTERNALEXTRACTICON, 0  ;internal private for shell
        SHELLThunk      HERETHARBETYGARS, 0     ;internal
        SHELLThunk      FINDEXEDLGPROC, 0
        SHELLThunk      REGISTERSHELLHOOK, 0
        SHELLThunk      SHELLHOOKPROC, 0

; New for Win95

        SHELLThunk      EXTRACTICONEX
        SHELLThunk      RESTARTDIALOG
        SHELLThunk      PICKICONDLG
        SHELLThunk      DRIVETYPE
        SHELLThunk      SH16TO32DRIVEIOCTL
        SHELLThunk      SH16TO32INT2526
        SHELLThunk      SHGETFILEINFO
        SHELLThunk      SHFORMATDRIVE
        SHELLThunk      SHCHECKDRIVE
        SHELLThunk      _RUNDLLCHECKDRIVE

sEnd	CODE

end	SHELL16

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\getsym.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "disasm.h"	/* wsprintf() */
#include "drwatson.h"

#define _lread(h, adr, cnt) _lread(h, (LPSTR)(adr), cnt)

/* Last entry in .SYM file */

typedef struct tagMAPEND {
   unsigned chnend;     /* end of map chain (0) */
   char	rel;	        /* release */
   char	ver;	        /* version */
} MAPEND;

/* Structure of .SYM file symbol entry */

typedef struct tagSYMDEF {
   unsigned sym_val;    /* 16 bit symbol addr or const */
   char	nam_len;        /*  8 bit symbol name length */
} SYMDEF;

/* Structure of a .SYM file segment entry */

typedef struct tagSEGDEF {
   unsigned nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
   int sym_cnt;         /* 16 bit count of symbols in sym list  */
   unsigned sym_ptr;    /* 16 bit ptr to symbol list */
   unsigned seg_lsa;    /* 16 bit Load Segment address */
   unsigned seg_in0;    /* 16 bit instance 0 physical address */
   unsigned seg_in1;    /* 16 bit instance 1 physical address */
   unsigned seg_in2;    /* 16 bit instance 2 physical address */
   unsigned seg_in3;    /* 16 bit instance 3 physical address */
   unsigned seg_lin;    /* 16 bit ptr to line number record   */
   char	seg_ldd;        /*  8 bit boolean 0 if seg not loaded */
   char	seg_cin;        /*  8 bit current instance	      */
   char	nam_len;        /*  8 bit Segment name length	      */
} SEGDEF;

/* Structure of a .SYM file MAP entry */

typedef struct tagMAPDEF {
   unsigned map_ptr;    /* 16 bit ptr to next map (0 if end) */
   unsigned lsa	 ;      /* 16 bit Load Segment address */
   unsigned pgm_ent;    /* 16 bit entry point segment value */
   int abs_cnt;         /* 16 bit count of constants in map */
   unsigned abs_ptr;    /* 16 bit ptr to constant chain */
   int seg_cnt;         /* 16 bit count of segments in map */
   unsigned seg_ptr;    /* 16 bit ptr to segment chain */
   char	nam_max;        /*  8 bit Maximum Symbol name length */
   char	nam_len;        /*  8 bit Symbol table name length */
} MAPDEF;

/* should cache last 4 files, last 4 segments, last 4 symbol blocks */

void cdecl Show(char *foo, ...);

#define MAXSYM 64
char *FindSym(unsigned segIndex, unsigned offset, int h) {
  static char sym_name[MAXSYM+5];
  char name[MAXSYM+3];
  int i;
  MAPDEF mod;
  SEGDEF seg;
  SYMDEF sym, *sp;

  if (sizeof(mod) != _lread(h, &mod, sizeof(mod))) return 0;
  if (segIndex > (unsigned)mod.seg_cnt) return 0;
  seg.nxt_seg = mod.seg_ptr;
  for (i=0; i<mod.seg_cnt; i++) {
    _llseek(h, (long)seg.nxt_seg << 4, SEEK_SET);
    _lread(h, &seg, sizeof(seg));
    if (seg.seg_lsa == segIndex) break;
  }
  if (seg.seg_lsa != segIndex) return 0;
  _llseek(h, seg.nam_len, SEEK_CUR);
  sym_name[0] = 0;
  sym.sym_val = 0xffff;
  sym.nam_len = 0;
  for (i=0; i<seg.sym_cnt; i++) {
    unsigned len = sizeof(sym) + sym.nam_len;
    if (len >= sizeof(name)) return 0;
    if (len != _lread(h, name, len)) return 0;
    sp = (SYMDEF *)(name + sym.nam_len);
    if (sp->sym_val > offset)
      break;
    sym = *sp;
  }
  name[sym.nam_len] = 0;
  if (name[0] == 0) return 0;
  if (sym.sym_val == offset) strcpy(sym_name, name);
  else sprintf(sym_name, "%s+%04x", (FP)name, offset-sym.sym_val);
  return sym_name;
} /* FindSym */

char *NearestSym(int segIndex, unsigned offset, char *exeName) {
  char fName[80];
  /* OFSTRUCT reOpen; */
  char *s;
  int h;

  strcpy(fName, exeName);
  strcpy(fName+strlen(fName)-4, ".sym");

  h = _lopen(fName, OF_READ | OF_SHARE_DENY_WRITE);

  if (h == -1) return 0;
  s = FindSym(segIndex, offset, h);
  _lclose(h);
  return s;
} /* NearestSym */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\drwatson.h ===
/* DrWatson.h - global info for Dr. Watson */

enum { 
  eClu, eDeb, eDis, eErr, eInf, eLin, eLoc, eMod,
  ePar, eReg, eSum, eSeg, eSou, eSta, eTas, eTim,
  e32b
};

#define bClu (1L << eClu)
#define bDeb (1L << eDeb)
#define bDis (1L << eDis)
#define bErr (1L << eErr)
#define bInf (1L << eInf)
#define bLin (1L << eLin)
#define bLoc (1L << eLoc)
#define bMod (1L << eMod)
#define bPar (1L << ePar)
#define bReg (1L << eReg)
#define bSum (1L << eSum)
#define bSeg (1L << eSeg)
#define bSou (1L << eSou)
#define bSta (1L << eSta)
#define bTas (1L << eTas)
#define bTim (1L << eTim)
#define b32b (1L << e32b)


#define flag(b) (((char *)&ddFlag)[b >> 3] & 1 << (b & 7))
#define SetFlag(b) ((char *)&ddFlag)[b >> 3] |= 1 << (b&7)
#define ClrFlag(b) ((char *)&ddFlag)[b >> 3] &= ~(1 << (b&7))


#define noClues flag(eClu)        /* Clues dialog box */
#define noDebStr flag(eDeb)       /* OutputDebugString trapping */
#define noDisasm flag(eDis)       /* Simple disassembly */
#define noErr flag(eErr)          /* Error logging */
#define noInfo flag(eInf)         /* System info */
#define noLine flag(eLin)         /* Lookup line# in SYM file */
#define noLocal flag(eLoc)        /* Local vars on stack dump */
#define noModules flag(eMod)      /* Module dump */

#define noParam flag(ePar)        /* Parameter error logging */
#define noReg flag(eReg)          /* Register dump */
#define noSummary flag(eSum)      /* 3 line summary */
#define noSeg flag(eSeg)          /* not visible to users, but available */
#define noSound flag(eSou)        /* But I _like_ the sound effects! */
#define noStack flag(eSta)        /* Stack trace */
#define noTasks flag(eTas)        /* Task dump */
#define noTime flag(eTim)         /* Time start/stop */

#define noReg32 flag(e32b)        /* 32 bit register dump */

#define DefFlag (bDeb | bDis | bErr | bMod | bLin | bLoc | bPar | bSou)

extern unsigned long ddFlag;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\disasm.h ===
/* Disasm.h - definitions for Don's Tiny Disassembler */

typedef unsigned long dword;
typedef unsigned short word;
typedef unsigned char byte;


extern word memOp;	/* actual operation performed */
extern char *memName[];	/* name corresponding to memOp */
enum { memNOP, memRead, memWrite, memRMW, memSegReg, memSegMem};

extern word memSeg;	/* value of segment of memory address */
extern dword memLinear,	/* offset of operand */
  memLinear2;
extern word memSeg2,	/* duplicate of above if dual mem op */
  memSize2, memOp2,
  memDouble;		/* true if two-mem-operand instruction */

extern word memSize;	/* bytes of memory of operation */
enum { MemByte=1, MemWord=2, MemDWord=4, MemQWord=8, MemTword=10,
	Adr4, Adr6=6};

enum { memNoSeg, memES, memCS, memSS, memDS, memFS, memGS};

enum {strCX=1, strSI=2, strDI=4, segDS=8, segES=16, segFS=32, segGS=64};
extern word gpSafe,	/* 1 if may continue instruction */
  gpRegs,		/* regs which instruction modifies as side effect */
  gpStack;		/* amount stack is changed by */

  /* DisAsm86 is my nifty 80x86 disassembler (even handles 32 bit code)	*/
  /* Given current CS:IP, it disassembles the instruction, and returns	*/
  /* the number of code bytes used, and a pointer to a static array of	*/
  /* chars holding the disassembly.  It also sets up a bunch of global	*/
  /* vars indicating what memory operations occurred, to aid in decoding */
  /* the fault type.							*/
extern char *DisAsm86(byte far *cp, int *len);


  /* Same as DisAsm86, but assumes 32 bit code and data */
extern char *DisAsm386(byte far *cp, int *len);

extern char hexData[];

#if !defined(MS_DOS)
#define sprintf wsprintf
#define vsprintf wvsprintf
#define FP void far *
#else
#define FP void *
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\drwatson.c ===
/* sherlock.c - Help deduce cause of Unrecoverable Application Errors
   (C) Copyright 1991, Microsoft Corp
   Written by Don Corbitt, based upon work of Cameron Stevens and others.
   Features -
     Help Script
     Dialog box to change options
     Option to trap Ctrl-Alt-SysRq to break endless loops
     Disassembler should look up symbols for CALL instructions
     Button could call up editor - file extension associations
     Toggle Icon when message occurs
     Write formal spec - (Program is done, so write the spec)
     Disable operation in Real Mode
     Dump stack bytes
     If all is blown, dump message to text monitor
     Data Symbols in disassembly

   Bugs -
     Doesn't buffer file output - this could be slow (but how many GP/hour?)
     Need to watch for invalid memory
     Need to handle Jump to bad address
     What if there aren't any file handles left at fault time???
     Need to handle no file handles available for .SYM file reader
     Should open files (.sym, .log) with proper share flags
     Could dump config.sys and autoexec.bat also
     Can't handle fault in Sherlock - locks up machine - very ugly
     Need to check InDOS flag
     Some errors not detected
       Jump/Call to invalid address
       Load invalid selector
     Run twice in Real Mode causes system hang
     GP Continue doesn't update 32 bit registers for string moves
*/

#define DRWATSON_C
#define STRICT
#include <windows.h>
#include <string.h>     /* strcpy() */
#include <stdarg.h>	/* va_stuff() */
#include <io.h>		/* dup() - why is this spread over 3 files ??? */
#include "toolhelp.h"	/* all the good stuff */
#include "disasm.h"	/* DisAsm86(), memXxxx vars */
#include "drwatson.h"
#include "str.h"        /* Support for string resources */

#define STATIC /*static */

char far foo[1];        /* force far data seg, make single instance */
// Does this make sense considering we have code and strings to
// tell the user they're in error to run two copies of Dr. Watson?


/******************/
/***** Macros *****/
/******************/
#define version "1.00b"

  /* This string is concatenated with other strings in various places */
  /* so it can't be an array variable.  It must stay a #define. */
  /* These strings are not localized. */
#define szAppNameMacro  "Dr. Watson"
#define szAppNameShortMacro "drwatson"
STATIC char szAppName[] = szAppNameMacro;
STATIC char szAppNameShort[] = szAppNameShortMacro;
STATIC char szAppNameShortLog[] = szAppNameShortMacro ".log";
static char szAppNameVers[] = szAppNameMacro " " version;

#define YOO_HOO (WM_USER+22)		/* user activated Dr. Watson */
#define HEAP_BIG_FILE (WM_USER+23)	/* log file is getting large */
#define JUST_THE_FACTS (WM_USER+24)	/* tell me about your problem */
#define BIG_FILE 100000L

  /* Don't like MSC-style FP macros, use my own */
#undef MK_FP
#undef FP_SEG
#undef FP_OFF
#define MK_FP(seg, off) (void far *)(((long)(seg) << 16) | (unsigned short)(off))
#define FP_SEG(fp) (unsigned)((long)(fp) >> 16)
#define FP_OFF(fp) (unsigned)(long)fp

/***************************/
/***** Data Structures *****/
/***************************/

LPSTR aszStrings[STRING_COUNT];

  /* This points to the stack the GP fault handler should use */
char *newsp;

  /* These structures are used by Watson.asm and Disasm.c - don't change */
  /* Also, they can't be static.  They contain the CPU register contents */
  /* at the time the fault occurred. */
struct {
  word ax, cx, dx, bx, sp, bp, si, di, ip, flags;
  word es, cs, ss, ds, fs, gs, intNum;
} regs;

  /* If we have a 32 bit CPU, the full 32 bit values will be stored here. */
  /* The lower 16 bits will still be in the generic regs above.		*/
struct {
  DWORD eax, ecx, edx, ebx, esp, ebp, esi, edi, eip, eflags;
} regs32;

  /* Each of these flags disables a part of the error output report	*/
  /* The error report itself indicates how each section is named.	*/
  /* The word in () can be added to the [Dr. Watson] section of WIN.INI	*/
  /* to disable that section of the report.				*/
  /* clu Clues dialog box */
  /* deb OutputDebugString trapping */
  /* dis Simple disassembly */
  /* err Error logging */
  /* inf System info */
  /* loc Local vars on stack dump */
  /* mod Module dump */
  /* par Parameter error logging */
  /* reg Register dump */
  /* sum 3 line summary */
  /* seg not visible to users, but available */
  /* sou But I _like_ the sound effects! */
  /* sta Stack trace */
  /* tas Task dump */
  /* tim Time start/stop */
  /* 32b 32 bit register dump */

STATIC char syms[] =
  "clu deb dis err inf lin loc mod par reg sum seg sou sta tas tim 32b ";
#define cntFlag (sizeof(syms)/4)
  /* This array is used to decode the flags in WIN.INI.  I only check	*/
  /* the first 3 chars of an entry.  Each entry must be separated by a	*/
  /* space from the previous one.                                       */

unsigned long ddFlag;

int retflag; /* used in watson.asm */

struct {
  char bit, name;
} flBit[] = {
  11, 'O',
  10, 'D',
  9, 'I',
  7, 'S',
  6, 'Z',
  4, 'A',
  2, 'P',
  0, 'C',
};
#define cntFlBit (sizeof(flBit)/sizeof(flBit[0]))

STATIC int disLen = 8;		/* Number of instructions to disassemble */
STATIC int trapZero = 0;	/* Should I trap divide by 0 faults	*/
STATIC int iFeelLucky = 1;	/* Should we restart after GP fault?	*/
	/* 1 = allow continue
	   2 = skip report
	   4 = continue in Kernel
	   8 = continue in User
	   16 = allow sound
	*/
STATIC int imTrying;		/* trying to continue operation */

STATIC struct {
  FARPROC adr;
  WORD code;
	HTASK task;
  DWORD parm;
} lastErr;

STATIC int disStack = 2;	/* Disassemble 2 levels of stack trace	*/
int cpu32;			/* True if cpu has 32 bit regs		*/
STATIC int fh = -1;		/* Handle of open log file		*/
STATIC int level;		/* if >0, in nested FileOpen() call	*/
STATIC int bugCnt, sound;
STATIC int pending;		/* If a pending Clues dialog */
STATIC int whined;		/* If already warned about a large file */
STATIC long pitch, deltaPitch = 250L << 16;
STATIC HINSTANCE hInst;

STATIC char logFile[80];	/* Default log file is "drwatson.log"	*/
				/* and is stored in the windows dir */

STATIC struct {                 /* Help print out value of CPU flags */
  WORD mask;
  LPSTR name;
} wf[] = {
  WF_80x87,    (LPSTR) IDSTRCoprocessor,  // IDSTRs are fixed up to pointers
  WF_CPU086,   (LPSTR) IDSTR8086,         // by LoadStringResources
  WF_CPU186,   (LPSTR) IDSTR80186,
  WF_CPU286,   (LPSTR) IDSTR80286,
  WF_CPU386,   (LPSTR) IDSTR80386,
  WF_CPU486,   (LPSTR) IDSTR80486,
  WF_ENHANCED, (LPSTR) IDSTREnhancedMode,
  WF_PMODE,    (LPSTR) IDSTRProtectMode,
  WF_STANDARD, (LPSTR) IDSTRStandardMode,
  WF_WINNT,    (LPSTR) IDSTRWindowsNT,
};
#define wfCnt (sizeof(wf)/sizeof(wf[0]))

HWND hWnd;			/* Handle to main window */
HANDLE hTask;			/* current task (me) */

/***********************/
/***** Extern Defs *****/
/***********************/

  /* Get base 32 bit linear address of a memory segment - calls DPMI */
extern DWORD SegBase(WORD segVal);

  /* Get segment flags - 0 if error */
extern WORD SegRights(WORD segVal);

  /* Get (segment length -1) */
extern DWORD SegLimit(WORD segVal);

  /* Fills in regs32 structure with value from regs struct and current high */
  /* word of registers - don't do any 32 bit ops before calling this func */
extern void GetRegs32(void);

  /* Fills in non-standard time/date structure using DOS calls.  The C	*/
  /* run-time has a similar function (asctime()), but it pulls in over	*/
  /* 6K of other functions.  This is much smaller and faster, and	*/
  /* doesn't depend on environment variables, etc.			*/
extern void GetTimeDate(void *tdstruc);

  /* Called by ToolHelp as a notify hook */
extern BOOL far /*pascal*/ CallMe(WORD, DWORD);

char *LogParamErrorStr(WORD err, FARPROC lpfn, DWORD param);

extern int FindFile(void *ffstruct, char *name);

  /* This routine is called by ToolHelp when a GP fault occurs.  It 	*/
  /* switches stacks and calls Sherlock() to handle the fault.          */
extern void CALLBACK GPFault(void);

  /* Return name of nearest symbol in file, or 0 */
extern char *NearestSym(int segIndex, unsigned offset, char *exeName);

STATIC void cdecl Show(const LPSTR format, ...);

/************************************/
/***** Segment Helper Functions *****/
/************************************/

/************************************
Name:   LPSTR SegFlags(WORD segVal)
Desc:	Given a selector, SegFlags checks for validity and then returns
	an ascii string indicating whether it is a code or data selector,
	and read or writeable.
Bugs:	Should check other flags (accessed), and call gates.
	Returns pointer to static array, overwritten on each new call.
*************************************/
STATIC LPSTR SegFlags(WORD segVal) {
  static char flag[10];

  if (segVal == 0) return STR(NullPtr);

  segVal = SegRights(segVal);
  if (segVal == 0) return STR(Invalid);

  segVal >>= 8;
  if (!(0x80 & segVal)) return STR(NotPresent);

  if (segVal & 8) {
    lstrcpy(flag, STR(Code));
    lstrcat(flag, segVal & 2 ? STR(ExR) : STR(ExO));
  } else {
    lstrcpy(flag, STR(Data));
    lstrcat(flag, segVal&2 ? STR(RW) : STR(RO));
  }
  return flag;
} /* SegFlags */

/************************************
Name:	char *SegInfo(WORD seg)
Desc:	Given a selector, SegInfo returns an ascii string indicating the
	linear base address, limit, and attribute flags of the selector.
Bugs:	Returns pointer to static array, overwritten on each new call.
*************************************/
STATIC char *SegInfo(WORD seg) {
  static char info[30];
  if (noSeg) return "";

  wsprintf(info, "%8lx:%04lx %-9s",
    SegBase(seg), SegLimit(seg), (FP)SegFlags(seg));
  return info;
} /* SegInfo */

/************************************
Name:	WORD SegNum(WORD segVal)
Desc:	Returns the index of this segment in the module table.  Used to
	translate between a physical segment number and the index as
	seen in e.g. the map file.
Bugs:	Don't know what ToolHelp returns for data or GlobalAlloc segments.
	This is mainly useful for converting a code segment value.
	Check for GT_DATA - will also be valid index.
*************************************/
STATIC WORD SegNum(HGLOBAL segVal) {
  GLOBALENTRY ge;
  ge.dwSize = sizeof(ge);
  if (GlobalEntryHandle(&ge, segVal) && (ge.wType == GT_CODE)) {
    return ge.wData;			/* defined to be 'file segment index' */
  }
  return (WORD)-1;
} /* SegNum */

/************************************
Name:   LPSTR ModuleName(WORD segVal)
Desc:	Returns name of this code segment's module
Bugs:
*************************************/
STATIC LPSTR ModuleName(WORD segVal) {
  static char name[12];
  GLOBALENTRY ge;
  MODULEENTRY me;
  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)segVal) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      strcpy(name, me.szModule);
      return name;
    } /* else Show("ModuleFindHandle() failed\n"); */
  } /* else Show("GlobalEntryHandle() failed\n"); */
  return STR(Unknown);
} /* ModuleName */

/**********************************/
/***** Other Helper Functions *****/
/**********************************/

/************************************
Name:	char *FaultType(void)
Desc:	Returns ascii string indicating what kind of fault caused ToolHelp
	to call our GPFault handler.
Bugs:	May not handle Ctrl-Alt-SysR nicely (we shouldn't trap it)
*************************************/
/* static char *FaultType(void) {
  switch (regs.intNum) {
    case 0: return STR(DivideByZero);
    case 6: return STR(InvalidOpcode);
    case 13: return STR(GeneralProtection);
    default: return STR(Unknown);
  }
} /* FaultType */

/************************************
Name:	char *DecodeFault(int op, word seg, dword offset, word size)
Desc:	Pokes at memory address passed in, trying to determine fault cause
		Segment wrap-around
		Null selector
		Write to read only data
		Write to code segment
		Read from execute only code segment
		Exceed segment limit
		Invalid selector
Bugs:		Jump, string, call, and stack memory adr's aren't set by DisAsm
*************************************/
STATIC LPSTR DecodeFault(int op, word seg, dword offset, word size) {
  int v;
  dword lim;

  switch (op) {
    case memNOP:
      break;			/* since no mem access, no fault */

    case memSegMem:     	/* load seg reg from memory */
      seg = *(short far *)MK_FP(seg, offset);
      /* fall through */
    case memSegReg:		/* load seg reg with value */
      v = SegRights(seg);	/* lets see if this is a selector */
      if (!v) return STR(InvalidSelector);
      break;			/* See no evil... */

    case memRead:
    case memRMW:
    case memWrite:
      if (seg == 0) return STR(NullSelector);

      v = SegRights(seg);
      if (!v) return STR(InvalidSelector);

      v >>= 8;
      if (!(0x80 & v)) return STR(SegmentNotPresent);

      lim = SegLimit(seg);
      if (lim < (offset+size)) return STR(ExceedSegmentBounds);

      if (v & 8) {	/* code segment */
	if ((op == memRMW) || (op == memWrite))
          return /* Write to */ STR(CodeSegment);
        else if (!(v&2)) return /* Read */ STR(ExecuteOnlySegment);

      } else {		/* data segment */
	if (((op == memRMW) || (op == memWrite)) && !(v&2))
          return /* Write to */ STR(ReadOnlySegment);
      }
      break;
    default:
      return 0;			/* obviously unknown condition */
  }
  return 0;
} /* DecodeFault */


LPSTR SafeDisAsm86(void far *code, int *len) {
  unsigned long limit = SegLimit(FP_SEG(code));
  if ((unsigned long)(FP_OFF(code)+10) > limit) {
    *len = 1;
    return STR(SegNotPresentOrPastEnd);
  }
  return DisAsm86(code, (int *)len);
} /* SafeDisAsm86 */


/************************************
Name:   LPSTR FaultCause(void)
Desc:	Decodes the actual cause of the fault.  This is trivial for Div0
	and Invalid Opcode, but much trickier for GP Faults.  I need to
	try to detect at least the following:
		Segment wrap-around
		Null selector
		Write to read only data
		Write to code segment
		Read from execute only code segment
		Exceed segment limit
		Invalid selector
Bugs:
*************************************/
STATIC LPSTR FaultCause(void) {
  int foo;
  LPSTR s, s1;
  static char cause[54];

  switch (regs.intNum) {
    case 0: return STR(DivideByZero);
    case 6: return STR(InvalidOpcode);
    case 20: return STR(ErrorLog);
    case 21: return STR(ParameterErrorLog);
    case 13:
      SafeDisAsm86(MK_FP(regs.cs, regs.ip), &foo);	/* Set global memXxxx vars */

	/* See if first memory access caused fault */
      s = DecodeFault(memOp, memSeg, memLinear, memSize);
      s1 = memName[memOp];

	/* no, see if second memory access caused fault */
      if (!s && memDouble) {
	s = DecodeFault(memOp2, memSeg2, memLinear2, memSize2);
	s1 = memName[memOp2];
      }

      if (s) {
        wsprintf(cause, "%s (%s)", s, s1);
	return cause;
      }
  }
  return STR(Unknown);
} /* FaultCause */

/************************************
Name:   LPSTR CurModuleName(hTask task)
Desc:	Call ToolHelp to find name of faulting module
Bugs:
*************************************/
STATIC LPSTR CurModuleName(HTASK hTask) {
  TASKENTRY te;
  static char name[10];

  te.dwSize = sizeof(te);
  if (!TaskFindHandle(&te, hTask))	/* Thanks, ToolHelp */
    return STR(Unknown);
  strcpy(name, te.szModule);
  return name;
} /* ModuleName */

/************************************
Name:   LPSTR FileInfo(char *name)
Desc:	Find file time, date, and size
Bugs:
*************************************/
STATIC LPSTR FileInfo(char *name) {
  struct {
    char resv[21];
    char attr;
    unsigned time;
    unsigned date;
    long len;
    char name[13];
    char resv1[10];
  } f;
  static char buf[30];

  if (FindFile(&f, name)) return STR(FileNotFound);
  wsprintf(buf, "%7ld %02d-%02d-%02d %2d:%02d",
		f.len,
		(f.date >> 5) & 15, f.date & 31, (f.date >> 9) + 80,
		f.time >> 11, (f.time >> 5) & 63);
  return buf;
} /* FileInfo */

/************************************
Name:   char *CurFileName(void)
Desc:	Call ToolHelp to find filename and path of faulting module
Bugs:
*************************************/
/* STATIC char *CurFileName(void) {
  TASKENTRY te;
  MODULEENTRY me;
  static char name[80];
  te.dwSize = sizeof(te);
  me.dwSize = sizeof(me);
  if (!TaskFindHandle(&te, GetCurrentTask()) ||
      !ModuleFindName(&me, te.szModule))
    return STR(Unknown);
  strcpy(name, me.szExePath);
  return name;
} /* FileName */

/************************************
Name:	char *CurTime(void)
Desc:	Generates string with current time and date.  Similar to asctime(),
        except it doesn't pull in another 6K of run-time library code :-)
Bugs:   Magic structure passed to asm routine
*************************************/
STATIC char *CurTime(void) {
  static char t[48];
  struct {			/* This magic struct is hard-coded to */
    char week, resv;		/* match the assembly language in */
    short year;			/* watson.asm GetTimeDate() */
    char day, month;		/* This means I recommend you don't */
    char minute, hour;		/* change the size or order of the */
    char hund, second;		/* fields! */
  } td;
  GetTimeDate(&td);
  wsprintf(t, "%s %s %2d %02d:%02d:%02d %d",
        aszStrings[IDSTRSun + td.week], aszStrings[IDSTRJan + td.month - 1],
        td.day, td.hour, td.minute, td.second, td.year);
  return t;
} /* CurTime */


/************************************
Name:   LPSTR Tab2Spc(LPSTR temp)
Desc:	Converts tabs found in string 'temp' into the proper number of
	spaces.  I need this since DisAsm86() returns a string with tabs
	in it, and TextOut() didn't like them.  This was easier than
	getting TabbedTextOut() set up to work.  Since I'm no longer dumping
	to the screen, this routine may be superfluous.
Bugs:
*************************************/
STATIC LPSTR Tab2Spc(LPSTR temp) {
  char newbuf[80];
  LPSTR s1, s2;

  s1 = temp;
  s2 = newbuf;
  while ((*s2 = *s1++) != 0) {
    if (*s2++ == 9) {
      s2[-1] = ' ';
      while ((s2-(LPSTR)newbuf) & 7) *s2++ = ' ';
    }
  }
  lstrcpy(temp, newbuf);
  return temp;
} /* Tab2Spc */


/************************************
Name:   void Show(const LPSTR format, ...)
Desc:	Think of this as (minor) shortcut fprintf().  I originally had this
	dumping info to a Windows window, and then changed it to write to
	the file we want.  All output goes through this func, so if you
	want to change something, this is the place.
Bugs:	Now writing to a file handle, opened in text mode so it does the
	  LF->CR/LF translation for me.
	No buffering performed on writes, except for what DOS might do.
	Blows up if stuff passed in expands to longer than 200 chars.
*************************************/
STATIC void cdecl Show(const LPSTR format, ...) {
  char line[CCH_MAX_STRING_RESOURCE];
  char *prev, *cur;
  wvsprintf(line, format, (LPSTR)(&format + 1));
  if (fh != -1) {
    prev = cur = line;
    while (*cur) {			/* expand LF to CR/LF */
      if (cur[0] == '\n' &&		/* at LF */
	 ((prev == cur) ||		/* and first of line */
	  (cur[-1] != '\r'))) {		/* or previous wasn't CR */
	cur[0] = '\r';			/* append CR to text up to LF */
	_lwrite(fh, prev, cur-prev+1);
	cur[0] = '\n';			/* leave LF for next write */
	prev = cur;
      }
      cur++;
    }
    if (prev != cur)			/* write trailing part */
      _lwrite(fh, prev, cur-prev);
  }
} /* Show */

/************************************
Name:	void MyFlush(void)
Desc:	Any routine named MyXxxx() had better be a private hack, and this
	one is.  It just appends an extra CRLF to the output file, and makes
	sure that the info written so far makes it to disk.  This way, if
	a later part of the program blows up, at least you will know this
	much.
Bugs:
*************************************/
STATIC void MyFlush(void) {
  int h;
  Show("\n");
  if (fh != -1) {
    h = dup(fh);
    if (h != -1) _lclose(h);
  }
  if (sound) {
    StopSound();
    SetVoiceSound(1, pitch, 20);
    pitch += deltaPitch;
    StartSound();
  }
} /* MyFlush */

/************************************
Name:	void DisAsmAround(char far *cp, int count)
Desc:	The 'cp' parameter is a pointer to a code segment in memory.  This
	routine backs up a few instructions from the current point, and
	dumps a disassembly showing the context of the selected instruction.
Bugs:	Needs to check for segmentation problems, such as invalid selector.
*************************************/
STATIC void DisAsmAround(byte far *cp, int count) {
  int len, back;
  byte far *oldcp = cp;
  byte far *cp1;
  GLOBALENTRY ge;
  MODULEENTRY me;
  char *szSym = 0;
  long limit;
  unsigned segLim;
  char symBuf[40];

  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)FP_SEG(cp)) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      szSym = NearestSym(ge.wData, FP_OFF(cp), me.szExePath);
      if (!szSym) {		/* if we know module name, but no syms */
	sprintf(symBuf, "%d:%04x", ge.wData, FP_OFF(cp));
	szSym = symBuf;
      }
    }
  }

  cp -= count*2 + 10;     		/* back up */
  if ((FP_OFF(cp) & 0xff00) == 0xff00)	/* if wrapped around, trunc to 0 */
    cp = MK_FP(FP_SEG(cp), 0);
  cp1 = cp;

  limit = SegLimit(FP_SEG(cp));
  segLim = limit > 0xffffL ? 0xffff : (int)limit;
  if (segLim == 0) {
    Show(STR(CodeSegmentNPOrInvalid));
    return;
  }

  back = 0;
  while (cp < oldcp) {			/* count how many instructions to point */
    SafeDisAsm86(cp, &len);
    cp += len;
    back++;
  }
  cp = cp1;
  back -= (count >> 1);
  while (back>0) {			/* step forward until (len/2) remain */
    SafeDisAsm86(cp, &len);		/* before desired instruction point */
    cp += len;
    back--;
  }

  while (count--) {			/* display desired instructions */
    if (cp == oldcp) {
      if (szSym) Show("(%s:%s)\n", (FP)me.szModule, (FP)szSym);
      else Show(STR(NoSymbolsFound));
    }
    Show("%04x:%04x %-22s %s\n",
	 FP_SEG(cp), FP_OFF(cp),	/* address */
	 (FP)hexData,			/* opcodes in hex */
	 (FP)/*Tab2Spc*/(SafeDisAsm86(cp, &len)));/* actual disassembly */
    cp += len;
  }
} /* DisAsmAround */

/************************************
Name:	int MyOpen(void)
Desc:	Tries to open logFile for append.  If this fails, tries to
	create it.
Bugs:	Should set sharing flags?
*************************************/
STATIC int MyOpen(void) {
  if (fh != -1) return fh;		/* Already open */
  fh = _lopen(logFile, OF_WRITE | OF_SHARE_DENY_WRITE);
  if (fh == -1) {
    fh = _lcreat(logFile, 0);
  } else _llseek(fh, 0L, 2);
  if (fh != -1) level++;
  return fh != -1;
} /* MyOpen */

/************************************
Name:	void MyClose(void)
Desc:	close output file, clear handle to -1
Bugs:	Should set sharing flags?
*************************************/
STATIC void MyClose(void) {
  if (--level == 0) {
    if (fh != -1) _lclose(fh);
    fh = -1;
  }
} /* MyClose */

void PutDate(LPSTR msg) {
  MyOpen();
  if (fh == -1) return;
  Show("%s %s - %s\n", (FP)msg, (FP)szAppNameVers, (FP)CurTime());
  MyClose();
} /* PutDate */

int far pascal SherlockDialog(HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam) {
  char line[255];
  int i, len, count;
  HWND hItem;

  lParam = lParam;
  if (wMsg == WM_INITDIALOG) return 1;

  if ((wMsg != WM_COMMAND) ||
      (wParam != IDOK && wParam != IDCANCEL))
    return 0;

  if (wParam == IDOK) {
    MyOpen();
    if (fh != -1) {
      hItem = GetDlgItem(hDlg, 102);
      if (hItem) {
	count = (int)SendMessage(hItem, EM_GETLINECOUNT, 0, 0L);
	for (i=0; i<count; i++) {
	  *(int *)line = sizeof(line) - sizeof(int) -1;
	  len = (int)SendMessage(hItem, EM_GETLINE, i, (long)((void far *)line));
	  line[len] = 0;
	  Show("%d> %s\n", i+1, (FP)line);
	}
      }
      MyClose();
    }
  }
  EndDialog(hDlg, 0);
  return 1;
} /* SherlockDialog */


extern int far pascal SysErrorBox(char far *text, char far *caption,
		int b1, int b2, int b3);
#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */
#define  SEB_CLOSE      8  /* Button with "Close"    */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

#define  SEB_BTN1       1  /* Button 1 was selected */
#define  SEB_BTN2       2  /* Button 1 was selected */
#define  SEB_BTN3       3  /* Button 1 was selected */


/************************************
Name:   int PrepareToParty(LPSTR modName, LPSTR appName)
Desc:	Checks whether we can continue the current app by skipping an
	instruction.  If so, it performs the side effects of the
	instruction.  This must be called after a call to DisAsm86() has
	set the gpXxxx global vars.
	Checks value of iFeelLucky, bit 0 must be set to continue a fault.
Bugs:	Should do more checking, should check for within a device driver,
	shouldn't require that DisAsm86() be called for the failing
	instruction immediately before call.
*************************************/
int PrepareToParty(LPSTR modName, LPSTR appName) {

  if (!(iFeelLucky&1)) return 0;
  if (!gpSafe) return 0;

  /* compare module to KERNEL */
  if (!(iFeelLucky&4) && !lstrcmp(modName, "KERNEL")) return 0;

  /* compare module to USER */
  if (!(iFeelLucky&8) && !lstrcmp(modName, "USER")) return 0;

  /* already asked, trying to continue, skip this fault */
  if (imTrying>0) return 1;

  if (3 != SysErrorBox(STR(GPText), appName, SEB_CLOSE|SEB_DEFBUTTON, 0, SEB_IGNORE))
    return 0;

  imTrying = 100;
  return 1;
} /* PrepareToParty */

STATIC void DumpInfo(void) {
  WORD w = (int)GetVersion();
  DWORD lw = GetWinFlags();
  SYSHEAPINFO si;
  int i;
  MEMMANINFO mm;

  Show(STR(SystemInfoInfo));
  Show(STR(WindowsVersion), w&0xff, w>>8);
  if (GetSystemMetrics(SM_DEBUG)) Show(STR(DebugBuild));
  else Show(STR(RetailBuild));
  {
    HANDLE hUser = GetModuleHandle("USER");
    char szBuffer[80];
    if (LoadString(hUser, 516, szBuffer, sizeof(szBuffer)))
      Show(STR(WindowsBuild), (FP)szBuffer);

    if (LoadString(hUser, 514, szBuffer, sizeof(szBuffer)))
      Show(STR(Username), (FP)szBuffer);

    if (LoadString(hUser, 515, szBuffer, sizeof(szBuffer)))
      Show(STR(Organization), (FP)szBuffer);
  }


  Show(STR(SystemFreeSpace), GetFreeSpace(0));

  if (SegLimit(regs.ss) > 0x10) {
    int far *ip = MK_FP(regs.ss, 0);
    Show(STR(StackBaseTopLowestSize),
	 ip[5], ip[7], ip[6], ip[7]-ip[5]);
  }

  si.dwSize = sizeof(si);
  if (SystemHeapInfo(&si))
    Show(STR(SystemResourcesUserGDI),
	  si.wUserFreePercent, si.hUserSegment,
      si.wGDIFreePercent, si.hGDISegment);

  mm.dwSize = sizeof(mm);
  if (MemManInfo(&mm)) {
    Show(STR(MemManInfo1),
      mm.dwLargestFreeBlock, mm.dwMaxPagesAvailable, mm.dwMaxPagesLockable);
    Show(STR(MemManInfo2),
      mm.dwTotalLinearSpace, mm.dwTotalUnlockedPages, mm.dwFreePages);
    Show(STR(MemManInfo3),
      mm.dwTotalPages, mm.dwFreeLinearSpace, mm.dwSwapFilePages);
    Show(STR(MemManInfo4), mm.wPageSize);
  }
  Show(STR(TasksExecuting), GetNumTasks());
  Show(STR(WinFlags));
  for (i=0; i<wfCnt; i++) if (lw & wf[i].mask)
    Show("  %s\n", (FP)wf[i].name);
  MyFlush();
} /* DumpInfo */

LPSTR GetProcName(FARPROC fn) {
  GLOBALENTRY ge;
  MODULEENTRY me;
  LPSTR szSym = STR(UnknownAddress);
  static char symBuf[80];

  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)FP_SEG(fn)) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      szSym = NearestSym(ge.wData, FP_OFF(fn), me.szExePath);
      if (!szSym) {		/* if we know module name, but no syms */
        sprintf(symBuf, "%s %d:%04x", (FP)me.szModule, ge.wData, FP_OFF(fn));
      } else sprintf(symBuf, "%s %s", (FP)me.szModule, szSym);
      szSym = symBuf;
    }
  }
  return szSym;
} /* GetProcName */

STATIC void DumpStack(int disCnt, int parmCnt, int cnt, int first) {
  STACKTRACEENTRY ste;
  MODULEENTRY me;
  int frame = 0;
  unsigned oldsp = regs.sp+16;

  ste.dwSize = sizeof(ste);
  me.dwSize = sizeof(me);

  Show(STR(StackDumpStack));
  if (StackTraceCSIPFirst(&ste, regs.ss, regs.cs, regs.ip, regs.bp)) do {
    if (frame >= first--) {
      me.szModule[0] = 0;
      ModuleFindHandle(&me, ste.hModule);
      Show(STR(StackFrameInfo),
	frame++,
	(FP)GetProcName((FARPROC)MK_FP(ste.wCS, ste.wIP)),
	ste.wSS, ste.wBP);
      if (!noLocal && (parmCnt-- > 0)) {
	if (oldsp & 15) {
	  int i;
          Show("ss:%04x ", oldsp & ~15);
	  for (i=0; i < (int)(oldsp & 15); i++) Show("   ");
	}
	while (oldsp < ste.wBP) {
	  if (!(oldsp & 15)) Show("\nss:%04x ", oldsp);
	  Show("%02x ", *(byte far *)MK_FP(regs.ss, oldsp++));
	}
	Show("\n");
      }
      if (frame <= disStack && (disCnt-- >0)) {
        Show("\n");
	DisAsmAround(MK_FP(ste.wCS, ste.wIP), 8);
      }
      MyFlush();
    } /* if after first to show */
  } while (StackTraceNext(&ste) && (cnt-- > 0));
} /* DumpStack */

int BeginReport(LPSTR time) {
  int i;

  MyOpen();
  if (fh == -1) {			/* maybe we're out of handles */
    _lclose(4);				/* trash one at random */
    MyOpen();				/* and try again */
  }
  if (fh == -1) return 0;

  for (i=0; i<4; i++) Show("*******************");
  Show(STR(FailureReport), (FP)szAppNameVers, (FP)time);
  MyFlush();
  if (!noSound) {
    sound = OpenSound();
    pitch = 1000L << 16;
  } else sound = 0;
  return 1;
} /* BeginReport */

void EndReport(void) {
  if (fh != -1) {
    if (!whined && _llseek(fh, 0L, 2) > BIG_FILE) {
      PostMessage(hWnd, HEAP_BIG_FILE, 0, 0);
      whined = 1;
    }
    MyClose();
  }
  if (sound) {
    StopSound();
    CloseSound();
    sound = 0;
  }
} /* EndReport */

void ShowParamError(int sync) {
  if (GetCurrentTask() == lastErr.task)
    Show("$param$, %s %s\n",
      sync ? (FP)"" : (FP)STR(LastParamErrorWas),
      (FP)LogParamErrorStr(lastErr.code, lastErr.adr, lastErr.parm));
  lastErr.task = 0;
} /* ShowParamError */

/************************************
Name:	void Sherlock(void)
Desc:	Handles GP faults in applications by dumping as much system
	information as I can think of to a log file.
	This is the big routine.
Bugs:
*************************************/
enum {s_prog, s_fault, s_name, s_instr, s_time, s_last};
int Sherlock(void) {
  int i, faultlen, party;
  LPSTR s[s_last];

  if ((!trapZero || regs.intNum != 0) &&
       regs.intNum != 6 &&
       regs.intNum != 13)
    return 0;

  if (imTrying>0) {
    s[s_prog] = CurModuleName(GetCurrentTask());
    SafeDisAsm86(MK_FP(regs.cs, regs.ip), &faultlen);
    party = PrepareToParty(ModuleName(regs.cs), s[s_prog]);
    imTrying--;
    if (party) goto SkipReport;
  }

  if (++bugCnt > 20) return 0;

  if (!BeginReport(s[s_time] = CurTime()))
    return 0;

  s[s_prog] = CurModuleName(GetCurrentTask());
  s[s_fault] = FaultCause();
  s[s_name] = GetProcName((FARPROC)MK_FP(regs.cs, regs.ip));

  Show(STR(HadAFaultAt),
       (FP)s[s_prog],
       (FP)s[s_fault],
       (FP)s[s_name]);

  if (!noSummary) Show("$tag$%s$%s$%s$",
	 (FP)s[s_prog],
	 (FP)s[s_fault],
	 (FP)s[s_name]);

  s[s_instr] = Tab2Spc(SafeDisAsm86(MK_FP(regs.cs, regs.ip), &faultlen));
  Show("%s$%s\n", (FP)s[s_instr], (FP)s[s_time]);
  ShowParamError(0);
  MyFlush();

  party = PrepareToParty(ModuleName(regs.cs), s[s_prog]);
  if ((bugCnt > 3) || ((party>0) && (iFeelLucky & 2))) {
    goto SkipReport;
  }

  if (!noReg) {
    Show(STR(CPURegistersRegs));
    Show("ax=%04x  bx=%04x  cx=%04x  dx=%04x  si=%04x  di=%04x\n",
	regs.ax, regs.bx, regs.cx, regs.dx, regs.si, regs.di);
    Show("ip=%04x  sp=%04x  bp=%04x  ", regs.ip, regs.sp+16, regs.bp);
    for (i=0; i<cntFlBit; i++)
      Show("%c%c ", flBit[i].name, regs.flags & (1 << flBit[i].bit) ? '+' : '-');
    Show("\n");
    Show("cs = %04x  %s\n", regs.cs, (FP)SegInfo(regs.cs));
    Show("ss = %04x  %s\n", regs.ss, (FP)SegInfo(regs.ss));
    Show("ds = %04x  %s\n", regs.ds, (FP)SegInfo(regs.ds));
    Show("es = %04x  %s\n", regs.es, (FP)SegInfo(regs.es));
    MyFlush();
  }

  if (cpu32 && !noReg32) {
    Show(STR(CPU32bitRegisters32bit));
    Show("eax = %08lx  ebx = %08lx  ecx = %08lx  edx = %08lx\n",
	regs32.eax, regs32.ebx, regs32.ecx, regs32.edx);
    Show("esi = %08lx  edi = %08lx  ebp = %08lx  esp = %08lx\n",
	regs32.esi, regs32.edi, regs32.ebp, regs32.esp);
    Show("fs = %04x  %s\n", regs.fs, (FP)SegInfo(regs.fs));
    Show("gs = %04x  %s\n", regs.gs, (FP)SegInfo(regs.gs));
    Show("eflag = %08lx\n", regs32.eflags);
    MyFlush();
  }

  if (!noDisasm) {
    Show(STR(InstructionDisasm));
    DisAsmAround(MK_FP(regs.cs, regs.ip), disLen);
    MyFlush();
  }

  if (!noInfo)
    DumpInfo();

  if (!noStack)
    DumpStack(disStack, 0x7fff, 0x7fff, 0);

  if (!noTasks) {
    TASKENTRY te;
    MODULEENTRY me;

    te.dwSize = sizeof(te);
    me.dwSize = sizeof(me);

    Show(STR(SystemTasksTasks));
    if (TaskFirst(&te)) do {
      ModuleFindName(&me, te.szModule);
      Show(STR(TaskHandleFlagsInfo),
	    (FP)te.szModule, te.hTask, me.wcUsage,
	    (FP)FileInfo(me.szExePath));
      Show(STR(Filename), (FP)me.szExePath); /* */
    } while (TaskNext(&te));
    MyFlush();
  }

  if (!noModules) {
    MODULEENTRY me;

    Show(STR(SystemModulesModules));
    me.dwSize = sizeof(me);
    if (ModuleFirst(&me)) do {
      Show(STR(ModuleHandleFlagsInfo),
            (FP)me.szModule, me.hModule, me.wcUsage,
	    (FP)FileInfo(me.szExePath));
      Show(STR(File), (FP)me.szExePath); /* */
    } while (ModuleNext(&me));
    MyFlush();
  }

SkipReport:
  if (party>0) {
    int len;
    word far * stack = MK_FP(regs.ss, regs.sp);
    Show(STR(ContinuingExecution), (FP)CurTime());
    MyFlush();
    /* fix up regs */
    if (gpRegs & segDS) regs.ds = 0;
    if (gpRegs & segES) regs.es = 0;
    if (gpRegs & segFS) regs.fs = 0;
    if (gpRegs & segGS) regs.gs = 0;
    regs.ip += faultlen;		/* set at top of func - don't reuse */
    if ((int)gpStack < 0) {
      for (i=0; i<8; i++) stack[i+gpStack] = stack[i];
    } else if (gpStack) {
      for (i=7; i>=0; i--) stack[i+gpStack] = stack[i];
    }
    regs.sp += gpStack << 1;
    if (gpRegs & strCX) {
      len = regs.cx * memSize;
      regs.cx = 0;
    } else len = memSize;
    if (gpRegs & strSI) {		/* doesn't handle 32 bit regs */
      regs.si += len;
      if (regs.si < (word)len)		/* if overflow, set to big value */
	regs.si = 0xfff0;		/* so global vars in heap don't get */
    }					/* trashed when we continue */
    if (gpRegs & strDI) {
      regs.di += len;
      if (regs.di < (word)len) regs.di = 0xfff0;
    }
  }

  EndReport();
  if (!noClues &&			/* if we want clues */
      !pending &&			/* no clues waited for */
      (!party || !(iFeelLucky & 2))) {	/* and we aren't quiet partiers */
    PostMessage(hWnd, JUST_THE_FACTS, (WPARAM)GetCurrentTask(), party);
    pending++;
  }
  if (party < 0) TerminateApp(GetCurrentTask(), NO_UAE_BOX);
  return party;
} /* Sherlock */

void far *bogus;

int CallMeToo(WORD wID, DWORD dwData) {
  NFYLOGPARAMERROR far *lpep;
  LPSTR s[s_last];

  if (wID == NFY_OUTSTR) {
    if (noDebStr)
      return FALSE;
    MyOpen();
    if (fh == -1) return FALSE;
    Show(STR(DebugString), dwData);
    MyClose();
    return TRUE;
  }

  if (wID == NFY_LOGERROR && noErr)
    return FALSE;

  lpep = (void far *)dwData;		/* Get the data for next log entry */
  lastErr.adr = lpep->lpfnErrorAddr;
  lastErr.code = lpep->wErrCode;
  lastErr.parm = (DWORD)(lpep->lpBadParam);
  lastErr.task = GetCurrentTask();
  if ((lastErr.code & 0x3000) == 0x1000)
    lastErr.parm = (WORD)lastErr.parm;
  else if ((lastErr.code & 0x3000) == 0)
    lastErr.parm = (BYTE)lastErr.parm;

  if (wID == NFY_LOGPARAMERROR && noParam) {
    return FALSE;
  }

  if (bugCnt++ > 60)
    return FALSE;
  if (!BeginReport(s[s_time] = CurTime())) /* Can't open file */
    return FALSE;

  switch (wID) {
    case NFY_LOGERROR:
#if 0
      lep = (void far *)dwData;
      cs = ip = 0;
      parm = 0;
      code = lep->wErrCode;
      s[s_fault] = STR(ApplicationError);
#endif
      break;
    case NFY_LOGPARAMERROR:
      s[s_fault] = STR(InvalidParameter);
      break;
    default:
      return FALSE;
  }

  s[s_prog] = CurModuleName(lastErr.task);
  s[s_name] = GetProcName(lastErr.adr);
  s[s_instr] = STR(NA);      /* not interesting */
  Show(STR(HadAFaultAt2),
       (FP)s[s_prog],
       (FP)s[s_fault], lastErr.code,
       (FP)s[s_name]);
  if (!noSummary) Show("$tag$%s$%s (%x)$%s$",
	 (FP)s[s_prog],
	 (FP)s[s_fault], lastErr.code,
	 (FP)s[s_name]);
  Show(STR(ParamIs), lastErr.parm, (FP)s[s_time]);

  ShowParamError(1);
  MyFlush();

  if (!noInfo && bugCnt < 2)
    DumpInfo();

  if (!noStack)
    DumpStack(0, 0, 0x7fff, 4);

  EndReport();
  return TRUE;
} /* CallMe */

  /* Parse SkipInfo= and ShowInfo= lines into flags array */
void ParseInfo(char *s, int val) {
  int i;
  strlwr(s);
  while (*s) {
    for (i=0; i<cntFlag; i++) if (0 == strncmp(s, syms+(i<<2), 3)) {
      if (val) SetFlag(i);
      else ClrFlag(i);
      break;
    }
    while (*s && *s++ != ' ')
      if (s[-1] == ',') break;
    while (*s && *s == ' ') s++;
  }
} /* ParseInfo */


/************************************
Name:   BOOL LoadStringResources(void)
Desc:   Load all string resources into GlobalAlloc'd buffer and
        initialize aszStrings array with pointers to each string.
        Also fixes up string IDs in wf (winflags) array to pointers.
        Note that we don't free the memory allocated, we count on
        kernel to clean up for us on termination.
Bugs:
*************************************/
BOOL LoadStringResources(void)
{
    int n;
    HANDLE h;
    LPSTR lp;
    WORD cbTotal;
    WORD cbUsed;
    WORD cbStrLen;

    //
    // Allocate too much memory for strings (maximum possible) at first,
    // reallocate to the real size when we're done loading strings.
    //

#if (STRING_COUNT * CCH_MAX_STRING_RESOURCE > 65536 - 64)
#error Need to use HUGE pointer for lp and DWORD for cb in LoadStringResources
#endif

    cbTotal = STRING_COUNT;

    cbTotal *= CCH_MAX_STRING_RESOURCE;

    h = GlobalAlloc(GMEM_FIXED, cbTotal);

    if ( ! h ) {
        return FALSE;
    }

    lp = GlobalLock(h);

    cbUsed = 0;

    for ( n = 0; n < STRING_COUNT; n++ ) {

        cbStrLen = LoadString(hInst, n, lp, CCH_MAX_STRING_RESOURCE);

        if ( ! cbStrLen ) {
            return FALSE;
        }

        aszStrings[n] = lp;

        lp += cbStrLen + 1;  // LoadString return doesn't count null terminator
        cbUsed += cbStrLen + 1;

    }

    GlobalReAlloc(h, cbUsed, 0);


    //
    // Fix up winflags array elements from string resource IDs to pointers
    //

    for ( n = 0; n < wfCnt; n++ ) {
        wf[n].name = aszStrings[ (int)(DWORD)wf[n].name ];
    }

    return TRUE;
}



/************************************
Name:	void DumpIni(void)
Desc:	Write profile strings to log file
Bugs:
*************************************/
#if 0
void DumpIni() {
  int i;
  char buf[4];

  buf[3] = 0;
  MyOpen();
  Show("Re-read win.ini\nshowinfo=");        // move to resource file if ever used
  for (i=0; i<cntFlag; i++) {
    if (!flag(i)) {
      memcpy(buf, syms+(i<<2), 3);
      Show("%s ", (FP)buf);
    }
  }
  Show("\nskipinfo=");
  for (i=0; i<cntFlag; i++) {
    if (flag(i)) {
      memcpy(buf, syms+(i<<2), 3);
      Show("%s ", (FP)buf);
    }
  }
  Show("\n");
  MyClose();
} /* DumpIni */

#endif

/************************************
Name:	int ReadWinIni(void)
Desc:	Read profile strings from WIN.INI.
	Return 0 if failure.
Bugs:
*************************************/
STATIC int ReadWinIni(void) {
  char line[80];
  int len;

    /* how many instructions should I disassemble by default? */
  disLen = GetProfileInt(szAppName, "dislen", 8);

    /* should I trap divide by 0 faults? */
  trapZero = GetProfileInt(szAppName, "trapzero", 0);

    /* should we allow restarting apps? */
  iFeelLucky = GetProfileInt(szAppName, "GPContinue", 1);
  /* if (!(iFeelLucky & 16)) noSound = 1; */

    /* how many stack frames should be disassembled? */
  disStack = GetProfileInt(szAppName, "DisStack", 2);

    /* where should I write the log file to? */
  GetProfileString(szAppName, "logfile", szAppNameShortLog, logFile, sizeof(logFile));
  len = strlen(logFile);

  if ((len == 0) ||			// logfile=
      (logFile[len-1] == '\\') ||	// directory only (boo, hiss)
      (logFile[len-1] == '/') ||	
      (logFile[len-1] == ':')) {	// drive only
    if (len && (logFile[len-1] == ':')) {	// drive only, put in root
      strcat(logFile, "\\");
    }
    strcat(logFile, szAppNameShortLog);	// append a file name
  }
  if (!(strchr(logFile, '\\')		// if no path specified, put in WinDir
     || strchr(logFile, ':')
     || strchr(logFile, '/'))) {
    char logname[80];
    int n;
    GetWindowsDirectory(logname, sizeof(logname));
    n = strlen(logname);
    if (n && logname[n-1] != '\\')
      strcat(logname, "\\");
    strcat(logname, logFile);
    strcpy(logFile, logname);
  }

    /* Set default flag values - see DrWatson.h for default values */
  ddFlag = DefFlag;

    /* do I really have to print out all this information? */
  if (GetProfileString(szAppName, "skipinfo", "", line, sizeof(line)))
    ParseInfo(line, 1);

  if (GetProfileString(szAppName, "showinfo", "", line, sizeof(line)))
    ParseInfo(line, 0);

#if 0
  DumpIni();
#endif
  return 1;
} /* ReadWinIni */

/************************************
Name:	int InitSherlock(void)
Desc:	Initialize Sherlock processing.  Install GP fault handler.
	Return 0 if failure.
Bugs:
*************************************/
STATIC int InitSherlock(void) {

    /* do I have 32 bit registers? */
  cpu32 = (GetWinFlags() & (WF_CPU386|WF_CPU486)) != 0;

    /* see what WIN.INI [drwatson] has to say */
  if (!ReadWinIni()) return 0;

  NotifyRegister(hTask, (LPFNNOTIFYCALLBACK)CallMe, NF_NORMAL);

    /* Now get ToolHelp to do the dirty work */
  return InterruptRegister(hTask, GPFault);
} /* InitSherlock */

/************************************
Name:	void Moriarty
Desc:	Destroy any evidence Sherlock was loaded.
Bugs:	Am I freeing all resources I used?
*************************************/
int init;
STATIC void Moriarty(void) {
  if (init) {
    if (!noTime) PutDate(STR(Stop));
    InterruptUnRegister(hTask);
    NotifyUnRegister(hTask);
    init = 0;
  }
} /* Moriary */

/************************************
Name:	WINAPI SherlockWndProc(hWnd, wMessage, wParam, lParam)
Desc:	Handle sherlock icon, close processing
Bugs:	Should pull up dialog boxes for About and GetInfo
*************************************/
LRESULT CALLBACK SherlockWndProc (HWND hWnd, UINT iMessage,
	WPARAM wParam, LPARAM lParam) {
  char msg[200];
  /* int (FAR PASCAL *dfp)(HWND, WORD, WORD, DWORD); */
	FARPROC dfp;

  switch (iMessage) {
    case WM_ENDSESSION:
      if (wParam) Moriarty();
      break;

    case WM_DESTROY: /* Quit Sherlock */
      PostQuitMessage (0);
      break;

    case WM_QUERYOPEN:	/* never open a window??? */
      PostMessage(hWnd, YOO_HOO, 0, 1);
      ReadWinIni();
      break;

    case WM_WININICHANGE:  /* Re-read WIN.INI parameters */
      ReadWinIni();
      break;

    case YOO_HOO:
      if (bugCnt) {
        wsprintf(msg, STR(Faulty), bugCnt, (FP)logFile);
	MessageBox(hWnd, msg, szAppNameVers,
		   MB_ICONINFORMATION | MB_OK | MB_TASKMODAL);
      } else {
        MessageBox(hWnd, STR(NoFault), szAppNameVers,
		   MB_ICONINFORMATION | MB_OK | MB_TASKMODAL);
      }
      break;

    case HEAP_BIG_FILE:
      wsprintf(msg, STR(LogFileGettingLarge),
	      (FP)logFile);
      MessageBox(hWnd, msg, szAppNameVers,
		 MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL);
      break;

    case JUST_THE_FACTS:
      dfp = MakeProcInstance((FARPROC)SherlockDialog, hInst);
      DialogBox(hInst, "SherDiag", hWnd, (DLGPROC)dfp);
      FreeProcInstance(dfp);
      pending = 0;			/* finished all old business */
      break;

    default:
      return DefWindowProc (hWnd,iMessage,wParam,lParam);
  }
  return 0L;
}

/************************************
Name:	WinMain(hInst, hPrevInst, cmdLine, cmdShow)
Desc:	Init Sherlock - this is where it all begins
Bugs:
*************************************/
int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpszCmdLine, int nCmdShow) {
  MSG msg;			/* Message returned from message loop */
  WNDCLASS wndclass;		/* Sherlock window class */
  char watsonStack[4096];

  nCmdShow = nCmdShow;
  lpszCmdLine = lpszCmdLine;
  newsp = watsonStack + sizeof(watsonStack);
  hInst = hInstance;
  hTask = GetCurrentTask();

  /* Check if Sherlock is already running */
  if (!hPrevInstance) {

    if (!LoadStringResources()) {
      MessageBox(NULL, "Dr. Watson could not load all string resources",
                 szAppNameVers, MB_ICONEXCLAMATION | MB_OK | MB_SYSTEMMODAL);
      return 1;
    }

    /* Define a new window class */
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = SherlockWndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon (hInstance, szAppNameShortMacro "Icon");
    wndclass.hCursor = LoadCursor (NULL,IDC_ARROW);
    wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;

    if (!RegisterClass (&wndclass)) {
      MessageBox(NULL, STR(ClassMsg), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
      return 1;
    }
  } else {
    /* Instance is already running, issue warning and terminate */
    MessageBox (NULL, STR(ErrMsg), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
    return 1;
  }

  /* Create window and display in iconic form */
  hWnd = CreateWindow (szAppName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,
		       0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

  ShowWindow (hWnd, SW_SHOWMINNOACTIVE);
  UpdateWindow (hWnd);

  if (!InitSherlock()) {
    MessageBox (/*NULL*/hWnd, STR(Vers), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
    DestroyWindow(hWnd);
    return 1;
  }

  if (!noTime) PutDate(STR(Start));
  init = 1;

  while (GetMessage (&msg, NULL, 0, 0)) {/* Enter message loop */
     TranslateMessage (&msg);
     DispatchMessage (&msg);
     imTrying = 0;
  }

  Moriarty();	/* Remove Sherlock GP Handler from GP Handler chain */

  return msg.wParam;
} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\error.c ===
#include <windows.h>
#include <logerror.h>
#include "str.h"

#ifdef API
#undef API
#endif
#define API _far _pascal _loadds


#define SELECTOROF(lp)	    HIWORD(lp)
#define OFFSETOF(lp)	    LOWORD(lp)

static WORD wErrorOpts = 0;

static char rgch[80];

char *LogErrorStr(WORD err, VOID FAR* lpInfo) {
    void DebugLogError(WORD err, VOID FAR* lpInfo);

	if (err & ERR_WARNING)
            wsprintf(rgch, STR(WarningError), err);
	else
            wsprintf(rgch, STR(FatalError), err);
    return rgch;
}

LPSTR GetProcName(FARPROC fn);

char *LogParamErrorStr(WORD err, FARPROC lpfn, VOID FAR* param) {
    LPSTR rgchProcName;

    rgchProcName = GetProcName(lpfn);


	switch ((err & ~ERR_FLAGS_MASK) | ERR_PARAM)
	{
	case ERR_BAD_VALUE:
	case ERR_BAD_INDEX:
            wsprintf(rgch, STR(ParamErrorBadInt), rgchProcName, (WORD)(DWORD)param);
	    break;

	case ERR_BAD_FLAGS:
	case ERR_BAD_SELECTOR:
            wsprintf(rgch, STR(ParamErrorBadFlags), rgchProcName, (WORD)(DWORD)param);
	    break;

	case ERR_BAD_DFLAGS:
	case ERR_BAD_DVALUE:
	case ERR_BAD_DINDEX:
            wsprintf(rgch, STR(ParamErrorBadDWord), rgchProcName, (DWORD)param);
	    break;

	case ERR_BAD_PTR:
	case ERR_BAD_FUNC_PTR:
	case ERR_BAD_STRING_PTR:
            wsprintf(rgch, STR(ParamErrorBadPtr), rgchProcName,
		    SELECTOROF(param), OFFSETOF(param));
	    break;

	case ERR_BAD_HINSTANCE:
	case ERR_BAD_HMODULE:
	case ERR_BAD_GLOBAL_HANDLE:
	case ERR_BAD_LOCAL_HANDLE:
	case ERR_BAD_ATOM:
	case ERR_BAD_HWND:
	case ERR_BAD_HMENU:
	case ERR_BAD_HCURSOR:
	case ERR_BAD_HICON:
	case ERR_BAD_GDI_OBJECT:
	case ERR_BAD_HDC:
	case ERR_BAD_HPEN:
	case ERR_BAD_HFONT:
	case ERR_BAD_HBRUSH:
	case ERR_BAD_HBITMAP:
	case ERR_BAD_HRGN:
	case ERR_BAD_HPALETTE:
	case ERR_BAD_HANDLE:
            wsprintf(rgch, STR(ParamErrorBadHandle), rgchProcName, (WORD)(DWORD)param);
	    break;

	default:
            wsprintf(rgch, STR(ParamErrorParam), rgchProcName, (DWORD)param);
	    break;
	}
    return rgch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\envect.asm ===
.xlist
include cmacros.inc
;
;~~vvr 091989
;
SYS=1
include	equate.inc
;~~
include vecsys.inc
include int31.inc
.list

page
;======= EnableVectra ========================================================
;
; If we have a Vectra A, A+, or A++ with EX-BIOS, save the current HPEntry
; vector, HPHIL state and set HPentry=6Fh, Turn ON HPHIL.
;
; Entry:
;   DS:		Code segment
;
;
; Exit:
;   CurHPentry, CurHILState
;
; Regs:
;   AX,
;
;=============================================================================

		assumes	cs, code
sBegin		DATA

fFirst		dw	0		; =0: First time in
;
;~~vvr 091989
;
fVectra		db	0	; bit0 =1: We have a Vectra with EX-BIOS
CurHPEntry	db	0	; Current HPEntry vector (usually 6Fh)
CurHILState	db	0	; bit6 =1: HIL is OFF
		db	?	; Word aligned

RealMode_Word_Struc Real_Mode_Call_Struc <>

externA		WinFlags
externA 	__ROMBIOS
WF_PMODE	equ	01h		
sEnd

sBegin CODE
assumes cs, CODE
externW MyCSDS

cProc	EnableVectra, <PUBLIC,NEAR>

cBegin
	push	CX
	push	BX
	push	BP
	push	DS

	mov ds, MyCSDS
	assumes	ds,DATA

	test	[fVectra], 10000000B	; Any previous Vectra check?
	jne	EnVNext			; Yes, proceed
;
;  Check if the PC is a Vectra. If Yes, then call HPSystem to get the
;  current size of the HP state

	or 	[fVectra], 80H	; Mark as gone through the identification
					; ..process
	push	ES			; Save it
	mov	AX, __ROMBIOS
	mov	ES, AX			; ES: Segment of ID code
	cmp	Word Ptr ES:[ID_OFFSET], 'PH'
	pop	ES			; Restore entry ES
	jz	EnVCont1
	jmp	EnVRet  		; Not a Vectra, so no extra HP processing
EnVCont1:
;
;  Check if EX-BIOS is present
;
	
	mov	AX, F16_INQUIRE
	mov	BX, AX
	int	INT_KBD
	cmp	BX, 'HP'		; EX-BIOS present?
	je	EnVCont
	jmp	EnVRet			; No, finish
EnVCont:
	or 	[fVectra], 1 	; Yes, flag we have a Vectra

EnvNext:
	test	[fVectra], 1
	jnz	EnVContinue
	jmp 	EnVRet			; No special processing if not a vectra
EnVContinue:
;
; We need to save the EX-BIOS vector and the HIL state only once since it is
; assumed that these parameters will not be changed while running under 
; Windows, especially by an old app.
;
	xor	BH, BH
	cmp	[CurHPEntry], BH	; first time?
	jnz	EnVSet			; no, don't have to save it again
;
; Save current HP entry and set it to be 6Fh
;
	mov	AX, F16_GET_INT_NUMBER
	int	INT_KBD
	inc	BH			; Flag as the first time
	mov	[CurHPEntry], HPENTRY ; Assume we have HPentry= 6Fh
	cmp	AH, RS_UNSUPPORTED
	je	EnVSet    		; We have a Vectra A, A+ if unsupported
	mov	[CurHPEntry], AH	; Save it if valid
;
EnVSet:
	mov	BL, HPENTRY
	mov	AX, F16_SET_INT_NUMBER
	int	INT_KBD			; BH preserved
;
; Save current HPHIL state and set it ON
;		  
	mov	cx, WinFlags
	and	cx, WF_PMODE 
	cmp	cx, WF_PMODE 			; prot-mode only
	jne	sys_real_mode

sys_prot_mode:
	or	BH, BH			; BH= 0: Not the first time 
	jz 	EnVSetHIL_PM		;	 so don't save state
	HPSysCall V_HPHIL, F_SYSTEM, SF_REPORT_STATE 
	mov	[CurHILState], BH
;
; Bit 14 of BX (Status Word) = 1: HPHIL OFF
;			       0: 	ON
;
EnVSetHIL_PM:
	HPSysCall V_HPHIL, F_IO_CONTROL, SF_HIL_ON 
	jmp	EnVret

sys_real_mode:
	or	BH, BH			; BH= 0: Not the first time 
	jz 	EnVSetHIL		;	 so don't save state
	mov	AH, F_SYSTEM
	mov	AL, SF_REPORT_STATE
	mov	BP, V_HPHIL
	int	HPENTRY			; int 6f to get the state
;
; Bit 14 of BX (Status Word) = 1: HPHIL OFF
;			       0: 	ON
;
	mov	[CurHILState], BH
;
; Turn HIL ON
;
EnVSetHIL:
	mov	AH, F_IO_CONTROL
	mov	AL, SF_HIL_ON
	mov	BP, V_HPHIL
	int	HPENTRY
;
EnVret:	
	pop	DS
	pop	BP
	pop	BX
	pop	CX
;
cEnd	EnableVectra


page
;======= DisableVectra =======================================================
;
; Restore the Vectra environment according to CurHPEntry and CurHILState
; Assume that HPENTRY is always 6Fh
;
; Entry:
;   DS:		Code Segment
;
; Exit:
;
;
; Regs:
;   AX,
;
;=============================================================================

cProc	DisableVectra, <PUBLIC,NEAR>

cBegin
	push	BX
	push	BP
	push	DS

						; make it run in both 
	mov	ds,MyCSDS			; real and prot modes
	assumes	ds,DATA

	test	[fVectra], 1			; are we on a Vectra ?
	jnz	DisVCont
	jmp 	DisVRet				; no 
DisVCont:

; check if we are prot or real mode

	mov	bx, WinFlags			; get mode flag
	and	bx, WF_PMODE 
	cmp	bx, WF_PMODE 			; is it prot_mode ?
	jne	sys_dis_real_mode		; we are in real mode

sys_dis_prot_mode:	

	test	[CurHILState], B_HIL_STATE
	je	DisVHIL_PM
	HPSysCall	V_HPHIL, F_IO_CONTROL, SF_HIL_OFF
	jmp	DisRestHIL
DisVHIL_PM:
	HPSysCall	V_HPHIL, F_IO_CONTROL, SF_HIL_ON
	jmp	DisRestHIL

sys_dis_real_mode:
;
;
; Restore the HIL state according to CurHILState
;
	mov	AH, F_IO_CONTROL
	mov	BP, V_HPHIL
	mov	AL, SF_HIL_ON		; Assume HIL is ON
	test	[CurHILState], B_HIL_STATE
	je	DisVHIL			; 0= correct assumption
	mov	AL, SF_HIL_OFF

DisVHIL:
	push	ds
	int	HPENTRY
	pop	ds
;
; Restore the Saved HPEntry
;
DisRestHIL:

	mov	AX, F16_SET_INT_NUMBER
	mov	BL, [CurHPEntry]
	int	INT_KBD
;
DisVRet:
	pop	DS
	pop	BP
	pop	BX

;
cEnd	DisableVectra

Send	code
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\romstuff.inc ===
;;
;;  macros and equates intended for ROM differences
;;

ifndef ROM
ROM = 0
endif

if ROM

if1
%out Creating Data Segment For ROM System
endif

SDSEG macro
sBegin DATA
endm

AssumeData macro
assumes ds, DATA
endm

DSEG equ DATA
doffset EQU <DataOffset>

else

SDSEG macro
sBegin CODE
endm

AssumeData macro
assumes ds, CODE
endm

DSEG equ CODE
doffset EQU <CodeOffset>

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\str.h ===
//
// str.h for Dr. Watson
//
// Created by DaveHart 31-Aug-95 to allow localization of Dr. Watson
//

#define CCH_MAX_STRING_RESOURCE 512

//
// IDSTR manifests start at zero and are consecutive to allow
// the ID to be an index into an array of string pointers at
// runtime.
//

#define IDSTRNoFault                                     0
#define IDSTRFaulty                                      1
#define IDSTRGPText                                      2
#define IDSTRErrMsg                                      3
#define IDSTRVers                                        4
#define IDSTRClassMsg                                    5
#define IDSTRCoprocessor                                 6
#define IDSTR8086                                        7
#define IDSTR80186                                       8
#define IDSTR80286                                       9
#define IDSTR80386                                       10
#define IDSTR80486                                       11
#define IDSTREnhancedMode                                12
#define IDSTRProtectMode                                 13
#define IDSTRStandardMode                                14
#define IDSTRWindowsNT                                   15
#define IDSTRNullPtr                                     16
#define IDSTRInvalid                                     17
#define IDSTRNotPresent                                  18
#define IDSTRCode                                        19
#define IDSTRExR                                         20
#define IDSTRExO                                         21
#define IDSTRData                                        22
#define IDSTRRW                                          23
#define IDSTRRO                                          24
#define IDSTRUnknown                                     25
#define IDSTRDivideByZero                                26
#define IDSTRInvalidOpcode                               27
#define IDSTRGeneralProtection                           28
#define IDSTRInvalidSelector                             29
#define IDSTRNullSelector                                30
#define IDSTRSegmentNotPresent                           31
#define IDSTRExceedSegmentBounds                         32
#define IDSTRCodeSegment                                 33
#define IDSTRExecuteOnlySegment                          34
#define IDSTRReadOnlySegment                             35
#define IDSTRSegNotPresentOrPastEnd                      36
#define IDSTRErrorLog                                    37
#define IDSTRParameterErrorLog                           38
#define IDSTRFileNotFound                                39
#define IDSTRCodeSegmentNPOrInvalid                      40
#define IDSTRNoSymbolsFound                              41
#define IDSTRSystemInfoInfo                              42
#define IDSTRWindowsVersion                              43
#define IDSTRDebugBuild                                  44
#define IDSTRRetailBuild                                 45
#define IDSTRWindowsBuild                                46
#define IDSTRUsername                                    47
#define IDSTROrganization                                48
#define IDSTRSystemFreeSpace                             49
#define IDSTRStackBaseTopLowestSize                      50
#define IDSTRSystemResourcesUserGDI                      51
#define IDSTRMemManInfo1                                 52
#define IDSTRMemManInfo2                                 53
#define IDSTRMemManInfo3                                 54
#define IDSTRMemManInfo4                                 55
#define IDSTRTasksExecuting                              56
#define IDSTRWinFlags                                    57
#define IDSTRUnknownAddress                              58
#define IDSTRStackDumpStack                              59
#define IDSTRStackFrameInfo                              60
#define IDSTRFailureReport                               61
#define IDSTRLastParamErrorWas                           62
#define IDSTRHadAFaultAt                                 63
#define IDSTRCPURegistersRegs                            64
#define IDSTRCPU32bitRegisters32bit                      65
#define IDSTRInstructionDisasm                           66
#define IDSTRSystemTasksTasks                            67
#define IDSTRTaskHandleFlagsInfo                         68
#define IDSTRFilename                                    69
#define IDSTRSystemModulesModules                        70
#define IDSTRModuleHandleFlagsInfo                       71
#define IDSTRFile                                        72
#define IDSTRContinuingExecution                         73
#define IDSTRDebugString                                 74
#define IDSTRApplicationError                            75
#define IDSTRInvalidParameter                            76
#define IDSTRNA                                          77
#define IDSTRHadAFaultAt2                                78
#define IDSTRParamIs                                     79
#define IDSTRStop                                        80
#define IDSTRLogFileGettingLarge                         81
#define IDSTRStart                                       82
#define IDSTRWarningError                                83
#define IDSTRFatalError                                  84
#define IDSTRParamErrorParam                             85
#define IDSTRParamErrorBadInt                            86
#define IDSTRParamErrorBadFlags                          87
#define IDSTRParamErrorBadDWord                          88
#define IDSTRParamErrorBadHandle                         89
#define IDSTRParamErrorBadPtr                            90

// These must be numerically in order Jan - Dec.

#define IDSTRJan                                         91
#define IDSTRFeb                                         92
#define IDSTRMar                                         93
#define IDSTRApr                                         94
#define IDSTRMay                                         95
#define IDSTRJun                                         96
#define IDSTRJul                                         97
#define IDSTRAug                                         98
#define IDSTRSep                                         99
#define IDSTROct                                         100
#define IDSTRNov                                         101
#define IDSTRDec                                         102

// These must be numerically in order Sun - Sat

#define IDSTRSun                                         103
#define IDSTRMon                                         104
#define IDSTRTue                                         105
#define IDSTRWed                                         106
#define IDSTRThu                                         107
#define IDSTRFri                                         108
#define IDSTRSat                                         109


//
// Since IDSTR's start at zero, STRING_COUNT is one more than the highest ID
//

#define STRING_COUNT                                     110

//
// Macro to fetch string pointer based on name without preceeding IDSTR
//

#define STR(name)      (aszStrings[IDSTR##name])

#ifndef DRWATSON_C
extern LPSTR aszStrings[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\equate.inc ===
page	,132

;**************************************************************************
; This file contains equates, data structures and definitions needed to
; access both the Standard BIOS (STD-BIOS) and the Extended BIOS (EX-BIOS)
; of Vectra using MASM 3.0. Depending on what part of the BIOS you are
; accessing you might not need all the equates.  The equates are organized
; as follows:
;
;  o Usefull macros.
;  o 80286 Support Macros and Equates.
;  o EX-BIOS Equates:
;      1) Generic Structures and equates used by all drivers.
;      2) Equates for Vector Addressed.
;      3) Function and SubFunction Equates common to all drivers.
;      4) Function and Subfunction Equates individual to drivers. These
;         are order by vector number.
;  o Industry Standard (STD-BIOS) Interrupt numbers and function equates.
;  o Industry Standard (STD-BIOS) Data Area
;
; The major reason for organizing the equate file in this form is that
; the programmer can extract only those equates that he needs to create
; a tailored equate file.
;**************************************************************************

;**************************************************************************
; Useful macros. 
;**************************************************************************
;  none at this time


;**************************************************************************
; 80286 Support macros and equates.
;**************************************************************************
;**************************************************************************
; The following macro is used to compensate for a bug in the 80286
; hardware interrupt system.  It seems that during a normal
; POPF instruction cycle interrupts are always enabled regardless
; of the state of the interrupt enable flag prior to the pop or after
; the pop. 
;**************************************************************************
POPPF       macro
            jmp   $+3
            iret
            push  cs
            call $-2
            endm

;**************************************************************************
; EX-BIOS support macros and equates.
;**************************************************************************

; Equates for EX-BIOS interrupt number and vector address.  
HPENTRY                 equ     6FH
F_HPENTRY               equ     HPENTRY

BIOS_SEG		EQU	0F000H		; Vectra BIOS ROM Segment
ID_OFFSET		EQU	0F8H		; Vectra ROM ID Offset
;
;**************************************************************************
;                       SYSCALL [vector_address]
;**************************************************************************
syscall                 macro   vector
 ifnb                    <vector>
                        mov     bp,vector
 endif
                        int     HPENTRY
                        endm

ifndef SYS
;
;**************************************************************************
; HP_VECTOR_TABLE Entry
;**************************************************************************
HP_TABLE_ENTRY          struc   ;<1,2,3>
HP_ENTRY_IP             dw      0
HP_ENTRY_CS             dw      0
HP_ENTRY_DS             dw      0
HP_TABLE_ENTRY          ends
;**********************************************************************
; Structure of Data Header for HP's vectors.
;**********************************************************************
HP_SHEADER              STRUC  ;<1,2,3,4,5,6,7,8,9,0>
DH_ATR                  dw  0   ; Attribute
DH_NAME_INDEX           dw  0   ; Name index of driver.
DH_V_DEFAULT            dw  0   ; Driver vector position in HPtable
DH_P_CLASS              dw  0   ; Parent class
DH_C_CLASS              dw  0   ; Child class
DH_V_PARENT             dw  0   ; Vector used when the driver cannot handle
                                ; an F_ISR function call
DH_V_CHILD              dw  0   ; Vector used when the driver cannot handle
                                ; a regular function call
DH_MAJOR                db  0   ; Driver's major address if any.
DH_MINOR                db  0   ; Driver's minor address if any.
HP_SHEADER              ENDS
                        
;**********************************************************************
; DH_ATR bit record
;**********************************************************************
ATR_HP            equ  1000000000000000B ; 1- The Rest of header is valid
ATR_DEVCFG        equ  0100000000000000B ; 1- Present in DEVCONFG
ATR_ISR           equ  0010000000000000B ; 1- Replace My ISR   (Child)
ATR_ENTRY         equ  0001000000000000B ; 1- Replace My ENTRY (Parent)
ATR_RSVD          equ  0000000000000000B ; 0 - Available on allocation from HP
ATR_FREE          equ  0000001000000000B ; 1 - Available Vector
ATR_SRVC          equ  0000010000000000B ; 2 - Service Vector
ATR_LOG           equ  0000011000000000B ; 3 - Logical Device Start DEVCONFG CHA
ATR_IND           equ  0000100000000000B ; 4 - Filter, show driver (options)
ATR_BOT           equ  0000101000000000B ; 5 - End of Chain
ATR_ESC           equ  0000110000000000B ; 6 - Filter, Pass thru , No options
ATR_TYPE7         equ  0000111000000000B ; 7 - Available
ATR_TYPE_MASK     equ  0000111000000000B
ATR_INP           equ  0000000100000000B ;  1 - Chain ISR ( to Parents )
                                         ;  0 - Chain Entry ( Child)
ATR_SUBADD        equ  0000000000000000B
ATR_MAJOR         equ  0000000000100000B
ATR_MINOR         equ  0000000001000000B
ATR_MID           equ  0000000001100000B
ATR_PSHARE        equ  0000000000010000B
ATR_CSHARE        equ  0000000000001000B
ATR_ROM           equ  0000000000000100B
ATR_YIELD         equ  0000000000000010B ;
ATR_0             equ  0000000000000001B

;**********************************************************************
;  DH_Class
;**********************************************************************
CL_KBDFC           equ  1000000000000000B       ; 1 - HP Softkey Transaltor
CL_KBD             equ  0100000000000000B       ; 1 - Keyboard
CL_CCP             equ  0010000000000000B       ; 1 - Cursor Control pad
CL_CON             equ  0001000000000000B       ; 1 - Console Device
CL_BYTE            equ  0000100000000000B       ; 1 - PRN device
CL_COMM            equ  0000010000000000B       ; 1 - COMM device
CL_INTERFACE       equ  0000001000000000B       ; 1 - interface, HPHIL, HPIB
CL_FILT            equ  0000000100000000B       ; 1 - charachter filter
CL_BLK             equ  0000000010000000B       ; 1 - block device
CL_BOOT            equ  0000000001000000B       ; 1 - boot block device
CL_LGID            equ  0000000000100000B       ; 1 - logical physical gid
                                                ; e.g. ccp to gid translator
CL_PGID            equ  0000000000010000B       ; 1 - physical gid
CL_GID             equ  0000000000001000B       ; 1 - any graphics input device
CL_PTS             equ  0000000000000100B       ; 1 - physical touch screen
CL_ASCII           equ  0000000000000010B       ; 1 - ascii input device
CL_EXTEND          equ  0000000000000001B       ; 0 - set of classes above
                                                ; 1 - alternate class set
CL_ALL             equ  1111111111111111B       ; Member of all classes
CL_NULL            equ  0000000000000000B       ; Member No Classes

;***************************************************************************
; Vector Addresses
;***************************************************************************
V_SCOPY                 equ     0000H           ; Copyright Notice
V_DOLITTLE              equ     0006H           ; Nop Routine
V_PNULL                 equ     000CH           ; No Device 
V_SYSTEM                equ     0012H           ; System Intrinsics
V_SINPUT                equ     002AH           ; Input Inquire routines
V_SQWERTY               equ     0036H           ; Qwerty KBD Translator
V_PSOFTKEY              equ     003CH           ; HP f1-f8 Translator
V_PFUNCTION             equ     0042H           ; IBM F1-F10 Translator
V_PNUM_PAD              equ     0048H           ; Numeric Pad Translator
V_SPCCP                 equ     004EH           ; CCP Translator Driver
V_PVIDEO                equ     0054H           ; Video Intrinsics
V_STRACK                equ     005AH           ; Common cursor control funcs.
V_EVENT_TOUCH           equ     0060H           ; Touch Event Intercept
V_EVENT_TABLET          equ     0066H           ; Tablet Event Intercept
V_EVENT_POINTER         equ     006CH           ; Pointer Event Intercept
V_LCCP_CURSOR           equ     008AH           ; CCP to Cursor Always Filter (Default)
V_RAW                   equ     0090H           ; CCP+Softkey RAW Mode Filter
V_LCCP_NUMPAD           equ     0096H           ; CCP to Numeric Pad Filter
V_OFF                   equ     009CH           ; CCP+Softkey Off Filter
V_LCCP_GID              equ     00A2H           ; CCP to GID Filter ( Not Implemented)
V_LFUNCTION             equ     00A8H           ; Softkey (f1-f8) to Function
                                                ;  key (F1-F8) Filter (Default)
V_L8041                 equ     00AEH           ; 8041 Interface
V_PGID_CCP              equ     00B4H           ; Graphic to CCP Filter
V_LTABLET               equ     00BAH           ; Tablet driver
V_LPOINTER              equ     00C0H           ; Pointer driver
V_LTOUCH                equ     00C6H           ; Touch driver
V_LHPMOUSE              equ     00CCH           ; Microsoft/Mouse System's
                                                ;   Compatible Driver
V_LNULL                 equ     0108H           ; No Driver
 
endif	; SYS
 
V_HPHIL                 equ     0114H           ; HPHIL Driver
;
V_WINDOWS  		equ	168H		; HP Windows protocol driver
V_SCANDOOR		equ	016EH		; Scan Door driver	
;
;~~tqn	060887
;
;*********************************************************************
; Extended Keyboard functions (int 16h)
;*********************************************************************

INT_KBD			equ	16H		; Int 16h vetor 
F16_INQUIRE  	        equ	6F00H		; EX-BIOS presence
F16_GET_INT_NUMBER	equ	6F0DH		; Get HPentry vector
F16_SET_INT_NUMBER	equ	6F0EH		; Set HPentry vector
;
;~~
;*********************************************************************
; Common Function Codes for HP Routines.
;*********************************************************************
F_ISR                   equ     00H*2           ; Interrupt service call
F_SYSTEM                equ     01H*2           ; System func. call,
                                                ;   Subfunction required
F_IO_CONTROL            equ     02H*2           ; Device/Driver Dependent
                                                ;   Functions
F_ITF_TO_ENVOY          equ     F_IO_CONTROL    ; Translation function for
                                                ;   SITF_ENVOY service.
F_PUT_BYTE              equ     03H*2           ; Write one byte of data:
                                                ;   Byte is in AL
F_GET_BYTE              equ     04H*2           ; Read a byte of data:
                                                ;   Byte returned in AL
F_PUT_BUFFER            equ     05H*2           ; Write a buffer of data,
                                                ;   ES,DI pointer, CX count
F_GET_BUFFER            equ     06H*2           ; Read a buffer if data,
                                                ;   ES,DI pointer, CX count
F_PUT_WORD              equ     07H*2           ; Write word of data, BX data
F_GET_WORD              equ     08H*2           ; Read word of data, BX data
F_GETTRM_BUFFER         equ    009H*2           ; Reads buffer of data,
                                                ;   ES,DI pointer, CX count
                                                ; BH upper bound, BL lower bound
F_PUT_BLOCK             equ     F_PUT_BUFFER    ;used for disk applications
F_GET_BLOCK             equ     F_GET_BUFFER

;*********************************************************************
; Common Subfunction codes of the F_SYSTEM Function.
;*********************************************************************
SF_INIT                 equ     00H*2   ;Initialize command
SF_START                equ     01H*2   ;Secondary Init--initialize dependent
                                        ; upon other drivers/data structures         
SF_REPORT_STATE         equ     02H*2   ;Reports state of driver
SF_VERSION_DESC         equ     03H*2   ;Report version and option describe
                                        ;  record
SF_DEF_ATTR             equ     04H*2   ;Reports default Configuration
                                        ;   (Baud Rate)
SF_GET_ATTR             equ     05H*2   ;Reports Current Configuration
                                        ;   ES,DI pointer
SF_SET_ATTR             equ     06H*2   ;Sets Next Configuration ES,DI, CX
SF_OPEN                 equ     07H*2   ;Reserve Driver for exclusive access
SF_CLOSE                equ     08H*2   ;Release  "   from    "        "
SF_TIMEOUT              equ     09H*2   ;Notify Driver Timeout Occurred
SF_INTERVAL             equ     0AH*2   ;Notify Driver Interval Occurred
SF_TEST                 equ     0BH*2   ;Test Function

;*********************************************************************
; Common Subfunction Codes for the F_IO_CONTROL function.
;*********************************************************************
SF_LOCK                 equ     00H*2   ; Lock Device for exclusive access
SF_UNLOCK               equ     01H*2   ; Unlock Device for exclusivce access
;
;~~tqn 060887
;
SF_HIL_ON		equ	26H	; Turn ON HIL  (A++)
SF_HIL_OFF		equ	28H	; Turn OFF HIL (A++)
B_HIL_STATE		equ	01000000B ; HIL OFF state from SF_REPORT_STATE
;
;~~
;*********************************************************************
; HP Routines Return Status: Sucessful codes are positive and failure
; are negative.
;*********************************************************************
RS_BREAK         equ    00CH            ; Break -- IFC
RS_DATA_NREADY   equ    00AH            ; RS232 Data Not Ready=>Retry Operation
RS_OVERRUN       equ    008H            ; RS232 Port Data Overrun =>Retry Operation
RS_DONE          equ    006H            ; indicates all done return child
RS_NOT_SERVICED  equ    004H            ; indicates a chained ISR--not handled
RS_UNSUPPORTED   equ    002H            ; indicates function is NOPed/not valid
                                        ; for this driver
RS_SUCCESSFUL    equ    F_ISR           ; indicates executed just fine
RS_SERVICED      equ    rs_SUCCESSFUL   ; indicates chained ISR done
RS_PASSTHRU      equ    rs_SERVICED     ; indicates launch data to parent


ifndef SYS
;
;************************************************************************
RS_FAIL          equ    0FEH            ; To be used with hardware failure
RS_TIMEOUT       equ    0FCH            ; to indicate remote device timeout
RS_BAD_PARAMETER equ    0FAH            ; to indicate a bad parameter
RS_BUSY          equ    0F8H            ; to indicate driver/device is busy
RS_NO_VECTOR     equ    0F6H            ; out of hp_VT vectors
RS_OFFLINE       equ    0F4H            ; device is offline
RS_OUT_OF_PAPER  equ    0F2H            ; out of paper on printer device
RS_PARITY        equ    0F0H            ; parity error in transmission
RS_FRAME         equ    0EEH            ; framing error

;******************************************************************************
; Function Number Equates for the EX-BIOS routines and its Data Structures.
;******************************************************************************

;*********************************************************************
; V_SYSTEM (0012H) function codes.
;*********************************************************************
F_INS_BASEHPVT          equ     0004H
F_INS_XCHGFIX           equ     0006H
F_INS_XCHGRSVD          equ     0008H
F_INS_XCHGFREE          equ     000AH
F_INS_FIXOWNDS          equ     000CH
F_INS_FIXGETDS          equ     000EH
F_INS_FIXGLBDS          equ     0010H
F_INS_FREEOWNDS         equ     0012H
F_INS_FREEGETDS         equ     0014H
F_INS_FREEGLBDS         equ     0016H
F_INS_FIND              equ     0018H
F_INS_FINDALL           equ     001AH
F_INS_NXTLOGBLK         equ     001CH
F_RAM_GET               equ     001EH
F_RAM_RET               equ     0020H
F_CMOS_GET              equ     0022H
F_CMOS_RET              equ     0024H
F_CMOS_HPDFLTS          equ     0026H
F_CMOS_IBMDFLTS         equ     0028H
F_YIELD                 equ     002AH
F_INS_ADR               equ     002CH
F_RESERVE_STRING3       equ     002EH
F_SND_CLICK_ENABLE      equ     0030H
F_SND_CLICK_DISABLE     equ     0032H
F_SND_CLICK             equ     0034H
F_SND_BEEP_ENABLE       equ     0036H
F_SND_BEEP_DISABLE      equ     0038H
F_SND_BEEP              equ     003AH
F_SND_SET_BEEP          equ     003CH
F_SND_TONE              equ     003EH
F_STR_GET_FREE_INDEX    equ     0040H
F_STR_DEL_BUCKET        equ     0042H
F_STR_PUT_BUCKET        equ     0044H
F_STR_GET_STRING        equ     0046H
F_STR_GET_INDEX         equ     0048H

;**********************************************************************
;  String Bucket Header. This structure is usefull if using the
; following V_SYSTEM functions: F_STR_DEL_BUCKET and F_STR_PUT_BUCKET.
;**********************************************************************
STR_HEADER              STRUC
STR_NXT_HDR             dd      (?)
STR_UPPER_BOUND         dw      (?)
STR_LOWER_BOUND         dw      (?)
STR_LIST_PTR            dd      (?)
STR_SEGMENT             dw      (?)
STR_HEADER              ENDS

;**********************************************************************
;  V_SYSTEM Global Data Segment
;**********************************************************************
HP_GLB_HEADER           STRUC
T_HP_HEADER             dw      (?)
T_USED_AND_RESERVED     dw      6 dup (?)
T_HP_LAST_DS            dw      (?)
T_HP_MAX_DS             dw      (?)
T_HP_NXT_VCTR           dw      (?)
T_SND_FLAG              db      (?) ;
T_SND_CLICK_COUNT       db      (?) ;
T_SND_CLICK_DURA        db      (?) ;
T_SND_CLICK_VOLUME      db      (?) ;
T_SND_BEEP_CYCLE        dw      (?) ;
T_SND_BEEP_DURA         dw      (?) ;
T_SND_BEEP_COUNT        db      (?) ;
                        db      (?) ;  1 reserved byte for volume
T_STR_NEXT_INDEX        dw      (?)
T_STR_ROOT              dd      (?)
T_STR_VCT_HDR           db      size STR_HEADER dup (?) ; Area vector's name and
T_STR_MSG_HDR           db      size STR_HEADER dup (?) ; ROM message strings
T_8259_FLAGS            db      (?)
                        db      31 dup (?) ; reserve 2 paragraph
HP_GLB_HEADER           ENDS

;*********************************************************************
; V_SINPUT (2AH) Function and subfunction codes.
;*********************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
F_INQUIRE               equ     0006H
F_INQUIRE_ALL           equ     0008H ; Reports ID's of devices
F_INQUIRE_FIRST         equ     000AH ; Reports (V_HPHIL1) offset
F_REPORT_ENTRY          equ     000CH ; Reports entrypoint of (V_PGID)

;
; Extra subfunctions under F_IO_CONTROL.
;
SF_DEF_LINKS            equ     0000H ; Sets default cofiguration
SF_GET_LINKS            equ     0002H ; Reports current configuration
SF_SET_LINKS            equ     0004H ; Sets Next Configuation
;
SF_MOUSE_DSIZE		equ	0006H ; Return sizes of HPMouse and HPTrack

;**********************************************************************
; V_LGID Fucntion Codes. This is a common driver for: V_LTABLET, 
; V_LPOINTER and V_LTOUCH.
;**********************************************************************
F_SAMPLE                equ     06
; F_IO_CONTROL:
SF_TRACK_ON             equ     4
SF_TRACK_OFF            equ     6
SF_CREATE_EVENT         equ     8
SF_EVENT_ON             equ     0Ah
SF_EVENT_OFF            equ     0Ch
SF_CLIPPING_ON          equ     0Eh
SF_CLIPPING_OFF         equ     10h
;**********************************************************************
; V_LGID LD_DEVICE_STATE
;**********************************************************************
EVENT_ENABLED           equ     10h
TRACK_ENABLED           equ     08h
CLIP_ENABLED            equ     04h
BUTTON_ERROR            equ     02H
ISR_IN_PROGRESS         equ     01H

;*********************************************************************
; V_PGID Data Structures
;*********************************************************************
DESCRIBE        STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
D_SOURCE        db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 (low nibble) is the address of the device
D_HPHIL_ID      db      ?       ; device id byte returned by an HPHIL device
D_DESC_MASK     db      ?       ; describe header from HPHIL device
D_IO_MASK       db      ?       ; I/O descriptor byte from device
D_XDESC_MASK    db      ?       ; extended describe byte from device
D_MAX_AXIS      db      ?       ; maximum number of axis reported
D_CLASS         db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
D_PROMPTS       db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
D_RESERVED      db      ?       ; reserved for future
D_BURST_LEN     db      ?       ; maximum burst length output to a device
                                ; if devices supports more than 255 bytes then
                                ; 255 bytes is the default maximum
D_WR_REG        db      ?       ; number of write registers supported by a device
D_RD_REG        db      ?       ; number of read registers supported by a device
D_TRANSITION    db      ?       ; transitions reported per button
D_STATE         db      ?       ; current state of buttons
D_RESOLUTION    dw      ?       ; counts / cm (m) returned by HPHIL device
D_SIZE_X        dw      ?       ; Maximum count of in units of resolution
D_SIZE_Y        dw      ?       ;
D_ABS_X         dw      ?       ; data reported from device
D_ABS_Y         dw      ?       ; that reports absolute data
D_REL_X         dw      ?       ; data reported from device
D_REL_Y         dw      ?       ; that is relitive
D_ACCUM_X       dw      ?       ; these are used to accumulate scaling
D_ACCUM_Y       dw      ?       ; remainder
DESCRIBE        ENDS

DESCRIBE_SIZE   	equ     size DESCRIBE
D_CCP_STATE             equ     D_STATE + 1
D_SIZE                  equ     D_SIZE_X
D_SAMPLE_ABSOLUTE       equ     D_ABS_X
D_SAMPLE_RELATIVE       equ     D_REL_X
D_REMAINDER_ACCUM       equ     D_ACCUM_X
D_BUFFER                equ     D_SIZE_X        ; offset where buffer begins
D_CLASS_CURRENT 	equ     0F0H
D_CLASS_DEFAULT 	equ     00FH
; The field LD_SOURCE uses the following to access the defined nibbles
D_ADDR_MASK             equ     00FH
D_TYPE_MASK             equ     0F0H
;*********************************************************************
; V_LGID Data Structures
;*********************************************************************
LDESCRIBE       STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
LD_SOURCE       db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 reserved
LD_HPHIL_ID     db      ?       ; device id byte returned by an HPHIL device
LD_DEVICE_STATE dw      ?       ; status bits for logical device
LD_INDEX        db      ?       ; vector index of invoking driver
LD_MAX_AXIS     db      ?       ; maximum number of axis reported
LD_CLASS        db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
LD_PROMPTS      db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
LD_RESERVED     db      ?       ; reserved for future
LD_RES2         db      ?
LD_RES3         db      ?
LD_RES4         db      ?
LD_TRANSITION   db      ?       ; transitions reported per button
LD_STATE        db      ?       ; current state of buttons
LD_RESOLUTION   dw      ?       ; counts / cm (m) returned by HPHIL device
LD_SIZE_X       dw      ?       ; Maximum count of in units of resolution
LD_SIZE_Y       dw      ?       ;
LD_ABS_X        dw      ?       ; data reported from device
LD_ABS_Y        dw      ?       ; that reports absolute data
LD_REL_X        dw      ?       ; data reported from device
LD_REL_Y        dw      ?       ; that is relitive
LD_ACCUM_X      dw      ?       ; these are used to accumulate scaling
LD_ACCUM_Y      dw      ?       ; remainders
LDESCRIBE       ENDS
LDESCRIBE_SIZE 		equ     size LDESCRIBE

LD_SIZE                 equ     LD_SIZE_X
LD_SAMPLE_ABSOLUTE      equ     LD_ABS_X
LD_SAMPLE_RELATIVE      equ     LD_REL_X
LD_REMAINDER_ACCUM      equ     LD_ACCUM_X
LD_BUFFER               equ     LD_RESOLUTION   ; offset where buffer begins
; the following mask are used in the field LD_CLASS
LD_CLASS_CURRENT        equ     0F0H
LD_CLASS_DEFAULT        equ     00FH

;************************************************************************
; V_LHPMOUSE (00CCH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
SF_MOUSE_COM            equ     0000H   ; This function is used during the 
                                        ; reinit call from DOS.  It is used
                                        ; to set up INT 33H.  This is done  
                                        ; because DOS takes INT 33H when it
                                        ; is initialized.
SF_MOUSE_OVERRIDE       equ     0002H   ; This function is used to force the
                                        ; V_LHPMOUSE driver to install INT 33
                                        ; even when the mouse is not present.
                                        ; This allows a programmer to map
                                        ; devices to the V_LHPMOUSE driver if
                                        ; a mouse is not present.

;************************************************************************
; V_STRACK (05AH) Function and subfunction codes.
;************************************************************************
F_TRACK_INIT            equ     0004H   ; used to perform a soft initialization
                                        ; of the tracking driver.
F_TRACK_ON              equ     0006H   ; enables tracking
F_TRACK_OFF             equ     0008H   ; disables tracking
F_DEF_MASKS             equ     000AH   ; define masks for sprite
F_SET_LIMITS_X          equ     000CH   ; define X limit of screen coordinates
F_SET_LIMITS_Y          equ     000EH   ; define Y limits
F_PUT_SPRITE            equ     0010H   ; Used to put the sprite on the screen
F_REMOVE_SPRITE         equ     0012H   ; removes the sprite from the screen

;************************************************************************
; V_HPHIL (0114H) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
;
SF_CRV_CRV_MAJ_MIN      equ     0004    ; This is used to set a default
                                        ; major and minor addresses
SF_CRV_RECONFIGURE      equ     0006    ; Funtion id used to force the HPHIL
                                        ; link to reconfigure the devices
SF_CRV_WR_PROMPTS       equ     0008    ; Used to write a prompt to a device
SF_CRV_WR_ACK           equ     000A    ; Used to write an acknowledge to a
                                        ; device
SF_CRV_REPEAT           equ     000C    ; Function is used to set a 30 Hz or
                                        ; 60 Hz repeat for keyboards
SF_CRV_DISABLE_REPEAT   equ     000E    ; Used to cancel the repeat rates in 
                                        ; keyboards
SF_CRV_SELF_TEST        equ     0010    ; Used to issue a selftest command
                                        ; to a physical device
SF_CRV_REPORT_STATUS    equ     0012    ; Used to get the status information 
                                        ; that an HPHIL device might wish to
                                        ; report.  For specific information
                                        ; on what is reported, see the specs
                                        ; for the device.
SF_CRV_REPORT_NAME      equ     0014    ; This function is used to return the
                                        ; ascii name that a device has.
SF_ENVOY_REPEAT         equ     0016    ; Used to set the keyboard repeat
                                        ; and delay rates
SF_ENVOY_LED            equ     0018    ; Used to set the keyboard LEDs

;************************************************************************
; V_SCANDOOR (016EH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_STATE_IOCTL particular to this driver.
;
F_STATE_IOCTL		equ	0008H	; Get and set the state

SF_GET_STATE		equ	0000H	; 
SF_SET_STATE		equ	0002H	; 

;**********************************************************************
; V_HPHIL Data Structure - do not tread lightly in this data structure
;**********************************************************************
HPHIL_DATA              struc
                        db      size HP_SHEADER DUP (?) ; dirver header
CRV_STATUS              dw      ?
CRV_ENVOY_STATUS        db      ?     ; status bits used to support
                                      ; the envoy keyboard
CRV_CURRENT_STATE       db      ?     ; current configuration address
CRV_ADDRESS             db      ?     ; configuration address
CRV_POLL_ADDRESS        db      ?     ; address of device whose poll
CRV_POLL_HEADER         db      ?     ; poll header of data being proc
CRV_MAJOR               db      ?     ; default major address
CRV_MINOR               db      ?     ; default minor address
CRV_EXPECTED_CMD        db      ?     ; command expected to return
CRV_KBD_ADDRESS         db      ?     ; address of the keyboard
CRV_MAX_DEVICES         db      ?     ; status byte of itf keycode tra
CRV_KC_STATE            db      ?     ; state of itf kc translation
CRV_POLL_RECORD         db      32 DUP (?)      ; poll record buffer
RQ_ENV_REPEAT           db      ?     ; envoy special command for repe
RQ_ENV_DELAY            db      ?     ; envoy special command for dela
RQ_ENV_LED              db      ?     ; envoy special command for led'
RQ_RequEST              db      ?
RQ_REGISTER             db      ?
RQ_ADDRESS              db      ?
RQ_DATA                 db      ?
RQ_MAX_BURST            dw      ?
RQ_COUNT                dw      ?
RQ_OFFSET               dw      ?
RQ_SEGMENT              dw      ?
RQ_SPECIAL              db      ?
RQ_TIMEOUT              db      ?
HPHIL_DATA      ends
;
endif	; SYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\sherlock\watson.asm ===
; Watson.asm - Helper routines for Sherlock

	memS = 1
	?PLM = 0
	?WIN = 0
        ?QUIET = 1
include	cmacros.inc
include toolhelp.inc
	.286p
	.model	small

	.data?
;newStack db	4096 dup (?)
externW	newsp
externW	cpu32
externW retflag
;newsp	=	(newStack+4096)

externW	regs
	val	= 0
irp	reg, <ax,cx,dx,bx,sp,bp,si,di,ip,flag,es,cs,ss,ds,fs,gs,int>
	r&reg	= val
	val	= val+2
endm


externD	regs32
	val	= 0
irp	reg, <ax, cx, dx, bx, sp, bp, si, di, ip, flags>
	re&reg	= val
	val	= val+4
endm

	.code
externP	Sherlock

cProc   SegLimit, <PUBLIC>,
	parmW	segVal
cBegin
	cmp	[cpu32], 0
	jnz	SegLimit32
	xor	ax, ax
	xor	dx, dx
        lsl     ax, [segVal]
	jmp short	done
SegLimit32:
	.386p
	push	edx			; save EDX.hi
	pop	dx

	push	eax			; save EAX.hi
	pop	ax

	xor	edx, edx		; return 0 if failure
	movzx	eax, [segVal]
	lsl	edx, eax		; EDX = return result

	push	dx			; push ans.lo
	pop	eax			; EAX.lo = ans.lo, EAX.hi restored

	push	edx			; stack is ans.lo, ans.hi, EDX.hi
	pop	dx			; discard ans.lo (already in EAX.lo)
	pop	edx			; DX has ans.hi, EDX.hi restored
	.286p
done:
cEnd

cProc	SegBase, <PUBLIC>
	parmW	segVal
cBegin
	mov	ax, 6
	mov	bx, [segVal]
	or	bx, bx			; DPMI whines on a 0 selector
	jz	baseBad
	int	31h			; call DPMI
	jnc	baseOK
baseBad:
	xor	dx, dx
	xor	cx, cx
baseOK:
	mov	ax, dx
	mov	dx, cx
cEnd

cProc	SegRights, <PUBLIC>
	parmW	segVal
cBegin
	lar	ax, [segVal]
	jz	rightOK
	xor	ax, ax
rightOK:
cEnd

externNP CallMeToo

cProc	CallMe,<PUBLIC,FAR>		; I was a big Blondie fan
;	parmD	foo			; BP+6, BP+8
;	parmW	id			; BP+10
cBegin nogen
	push	bp
	mov	bp, sp
id	equ	word ptr [bp+10]
seg_foo	equ	word ptr [bp+8]
off_foo	equ	word ptr [bp+6]
	xor	ax, ax
	cmp	id, NFY_LOGERROR
	jz	cm_stay
	cmp	id, NFY_LOGPARAMERROR
;        jz      cm_stay
;        cmp     id, NFY_OUTSTR
	jnz	cm_go			; "if I go there will be trouble"
cm_stay:				; "if I stay it will be double"
	mov	ax, DGROUP
	mov	bx, ss
	cmp	ax, bx
	jz	cm_go
	push	ds			; I like The Clash too
	mov	ds, ax
	mov	dx, SEG_foo
	mov	cx, OFF_foo
	mov	bx, id
	mov	[regs+rss], ss		; for stack trace, and to continue
	mov	[regs+rsp], sp
	mov	[regs+rbp], bp
	mov	[regs+rcs], cs
	mov	[regs+rip], offset cm_stay
	mov	ss, ax
	mov	sp, [newsp]
	mov	bp, 0
	push	dx
	push	cx
	push	bx
	cCall	CallMeToo
	mov	bp, [regs+rbp]
	mov	ss, [regs+rss]
	mov	sp, [regs+rsp]
	pop	ds
cm_go:
	pop	bp
	retf	6
cEnd	nogen

; GPFault - called as part of gpfault chain by ToolHelp
;	Ret IP		Far ret back to ToolHelp fault handler
;	Ret CS
;	AX		Saved in case prolog trashes AX
;6	IntNum		Number of interrupt that occurred
;	Resv		Magic value, don't trash
;10	Fault IP	IRET back to faulting instruction
;12	Fault CS
;14	Fault Flags

fint	= 6
fip	= 10
fcs	= 12
fflag	= 14

GPFAULT proc	far ; pascal
public	GPFAULT
	push	ds			; save ds
	push	ax
	push	bp
	mov	bp, sp
	mov	ax, [bp+12]
	cmp	ax, 0			; only save regs if int Div0,
	jz	keeper
	cmp	ax, 6			; invalid opcode
	jz	keeper
	cmp	ax, 13			; GP fault
	jz	keeper
nokeep:	pop	bp			; don't like this fault, chain on
	pop	ax
	pop	ds
	ret

keeper:	push	bx
	mov	bx, ss
	mov	ax, DGROUP		; and address our group
	cmp	ax, bx
	pop	bx
	je	nokeep			; don't go re-entrant
	mov	ds, ax
	pop	[regs+rbp]
	pop	[regs+rax]		;save AX
	pop	[regs+rds]		; and DS in regs[]

irp	reg, <cx,dx,bx, sp, si,di, es,ss>
	mov	[regs+r&reg], reg	; all but ip, flag, intNum,
endm					;   cs, fs, gs, int
	mov	bp, sp			; nothing local on stack
irp	reg, <cs, ip, flag, int>
	mov	bx, [bp+f&reg]
	mov	[regs+r&reg], bx
endm

; Save away 32 bit registers if required
	cmp	[cpu32], 0
	jz	NoSave32
	.386p
	mov	ax, [regs+rax]
irp	reg, <eax, ecx, edx, esi, edi>
	mov	[regs32+r&reg], reg
endm
irp	reg, <bx, sp, bp>
	mov	eax, e&reg
	mov	ax, [regs+r&reg]
	mov	[regs32+re&reg], eax
endm
	pushfd
	pop	[regs32+reflags]
	mov	[regs+rfs], fs
	mov	[regs+rgs], gs
	.286p
NoSave32:
	mov	ax, ds
	mov	ss, ax	
	mov	sp, [newsp]
	mov	bp, 0

	cmp	ax, [regs+rss]		; can't debug ourselves
	jz	oh_no

; Save high halves of registers if required
        cmp     [cpu32], 0
        jz      CallSherlock286
	.386p
	pushad
	call	Sherlock		; Display the info
	mov	retflag, ax
	popad
	mov	eax, [regs32+reax]
	.286p
	
        jmp     short DoneWithSherlock

CallSherlock286:
        pusha
        call    Sherlock                ; Display the info
        mov     retflag, ax
        popa

DoneWithSherlock:
        mov     ax, retflag
        or      ax, ax                  ; 0 - fault, 1 = continue
	jz	oh_no
	mov	es, [regs+rss]
	mov	bx, [regs+rsp]
	mov	ax, [regs+rip]
	mov	es:[bx+10], ax
oh_no:					; restore all regs, then test again
irp	reg, <ax,cx,dx,bx, ss,sp, bp,si,di, es,ds>
	mov	reg, [regs+r&reg]
endm
	jz	oh_no_2
	add	sp, 10
	iret
oh_no_2:
	ret
GPFAULT	endp

	.386p
cProc	GetRegs32, <PUBLIC>
cBegin
cEnd

irp	reg, <sp, bp, si, di>
	mov	eax, [regs32+re&reg]
	mov	ax, reg
	mov	e&reg, eax
endm

irp	reg, <ebx, edx, ecx, eax>
	mov	reg, [regs32+r&reg]
endm
cEnd
	.286p

cProc	GetTimeDate, <PUBLIC>
	parmW	buf
cBegin
	mov	ah, 2ah
	int	21h
	mov	bx, [buf]
	mov	[bx], ax
	mov	[bx+2], cx
	mov	[bx+4], dx
	mov	ah, 2ch
	int	21h
	mov	bx, [buf]
	mov	[bx+6], cx
	mov	[bx+8], dx
cEnd

cProc	FindFile, <PUBLIC>
	parmW	buf
	parmW	_name
	localW	dtaSeg
	localW	dtaOff
cBegin
	mov	ah, 2fh			;get DTA
	int	21h
	mov	[dtaSeg], es
	mov	[dtaOff], bx

	mov	ah, 1ah
	mov	dx, buf
	int	21h			; set DTA to caller's buffer

	mov	ah, 4eh			; find first matching file
	mov	cx, 0
	mov	dx, _name
	int	21h
	sbb	ax, ax
	push	ax

	push	ds			; restore DTA
	mov	ds, [dtaSeg]
	mov	dx, [dtaOff]
	mov	ah, 1ah
	int	21h

	pop	ds
	pop	ax			; return value, 0 == OK
cEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\system.asm ===
;** SYSTEM.ASM **********************************************************
;									*
;   Copyright (C) 1983,1984,1985,1986,1987,1988 by Microsoft Inc.	*
;									*
;************************************************************************
;	History
;	18 oct 88	peterbe		Added fBootDrive and test for it,
;					for diskless workstations.
;************************************************************************

	TITLE SYSTEM - InquireSystem procedure to return info about devices

	include system.inc

;; AT&T Machines running DOS 3.10, revisions 1.0 and 1.01 place
;; this value into SingleDriveLoc

ATT31Loc	EQU    10d0h

ifdef   NEC_98
IOSYSSEG	EQU	0060H
LPTABLEOFF	EQU	006CH
EXLPTABLE	EQU	2C86H		;EXPANDED LPTABLEOFF
SNGDRV_FLG	EQU	0038H

BIOS_FLAG	EQU	ES:BYTE PTR[0100H]	; offset by seg 40h 
BIOS_FLAG1	EQU	ES:BYTE PTR[0080H]	;	"

EX_CPU_TYPE	EQU	00001000B
V30_BIT		EQU	01000000B
BIT286		EQU	00000001B
endif   ; NEC_98

MultHIMEM		EQU	43h	; HIMEM.SYS int 2fh multiplex
MHM_ReqInstall		EQU	00h	; Installation check
MHM_ReqInstall_Ret	EQU	0FFh	; I'm here Return

ifndef  NEC_98
externA 	__ROMBIOS
endif   ; NEC_98

externA 	__0040h

externFP	NoHookDOSCall

ifdef   NEC_98
externFP	GetPrivateProfileInt	; 930206
endif   ; NEC_98

ifdef	HPSYSTEM
ExternNP	<EnableVectra, DisableVectra>	;~~vvr 091989
endif

assumes CS,CODE

sBegin DATA

externB timerTable

;
; InquireSystem(what,which) - returns oem specific information
;	what is the code for the device
;	which specifies which one of those devices
;
;   WHAT = 0	    Timer resolution
;	Return the resolution of the timer specified by the which
;	parameter in DX:AX.  Windows always uses which == 0
;
;   WHAT = 1	    Disk Drive Information (Drive A = 0)
;	which is the disk drive (A = 0)
;	Returns:
;	    ax = 0 means the drive does not exist.  if dx != 0 then the drive
;		maps to the drive in dx instead (A = 1) AND the drive is
;		REMOVEABLE.
;	    ax = 1 means the drive does not exist.  if dx != 0 then the drive
;		maps to the drive in dx instead (A = 1) AND the drive is
;		FIXED.
;	    ax = 2 means the drive is removable media
;	    ax = 3 means the drive is fixed media
;	    ax = 4 means the drive is fixed media and remote
;
;   WHAT = 2	    Enable/Disable one drive logic
;	which = 0 means disable, which <> 0 means enable
;	This code enables/disables the RAM BIOS message:
;	"Please insert disk for drive B:"
;
ifdef   NEC_98
;   WHAT = 3        Coprocessor exception vector information
;       which is unused.
;       Returns:
;         ax = 1 means we must save & restore coprocessor error vector
;                  ( really,always return 1 )
;         dx : coprocessor exception interrrupt vector number
;
endif   ; NEC_98

;
; The following flag deals with some unpleasantness in the fast boot code.
;   The fast boot code delays our INIT call till to late because some code
;   in KERNEL which uses InquireSystem is called first. We fix this problem
;   with this flag......
;
globalB 	SystemIsInited,0

; Following from RAMDRIVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Unfortunately the code in ramdrive is very machine dependent
; necessitating the use of a system flag to store the machine
; configuration. The system flag is initialised during init time
; and used when the caching services are requested. One bit which
; is set and tested during caching is the state of the a20 line
; when the cache code is entered. This is used because there are
; applications which enable the a20 line and leave it enabled 
; throughout the duration of execution.  Since ramdrive is a device
; driver it shouldn't change the state of the environment.
;
; The system flag bit assignments are:
;
;	-------------------------------------------------
;	|  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
;	-------------------------------------------------
;	   |-----|     |     |	   |	 |     |     |
;	      |        |     |	   |	 |     |     -----286 (and AT)
;	      |        |     |	   |	 |     -----------386 (later than B0)
;	     not       |     |	   |	 -----------------PS/2 machine
;	    used       |     |	   -----------------------Olivetti (not used)
;		       |     -----------------------------A20 state (enabled ?)
;		       -----------------------------------DOS 3.x >= 3.3

; The Olivetti guys have defined a flag of their own. This should be removed
; and the bit assigned out here for them should be used. 
;
sys_flg		db	0
;
;	equates used for the system flag
;
M_286		equ	00000001B
M_386		equ	00000010B
M_PS2		equ	00000100B
M_OLI		equ	00001000B
A20_ST		equ	00010000B
DOS_33		equ	00100000B
HAVE_FFFE	equ	01000000B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A20 address line state determination addresses
;
low_mem label	dword
	dw	20h*4
	dw	0

high_mem label	dword
	dw	20h*4 + 10h
	dw	0ffffh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A20 PS2 equates
;
PS2_PORTA   equ 0092h
GATE_A20    equ 010b

; End RAMDRIVE stuff

globalB		numFloppies,0
globalB		fBootDrive,0
globalB		oneDriveFlag,0
globalW		coProcFlag,0
globalD 	HiMem,0
globalW 	DosVer,0

ifdef   NEC_98
savelptable	db	0
NDP_CONTROL	DW	0

EMM_DEVICE_NAME	DB	"EMMXXXX0"
	PUBLIC	EMM_FLAG
EMM_FLAG	DB	0

DRVCNT		DB	10H		;16 DRIVE

		PUBLIC	reflected
reflected	DB  0		; 0 not reflected    	930206
profinit	DB  0		; 0 is no initalized	930206
endif   ; NEC_98

;; SingleDriveLoc defaults to the value of SingleDrive (104h) on other
;; than AT&T machines.	Otherwise the value is changed during
;; the execution of single drive enable/disable.

SingleDriveLoc	dw	SingleDrive

sEnd

sBegin CODE

GlobalW     MyCSDS, _DATA

;-----------------------------------------------------------------------;
; InquireSystem
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 14:57:21  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InquireSystem,<FAR,PUBLIC,NODATA>
	parmW	what
	parmW	which
cBegin
	push	ds
	mov	ds, MyCSDS
	assumes ds,DATA

	cmp	SystemIsInited,0	; Are we ready for this call?
	jnz	DoInq			; Yes
	call	far ptr InitSystem	; No, Set up
DoInq:
	mov	ax,what

;---------------------------------------
;
;  Timer information
;
	or	ax,ax
	jnz	is1
	mov	dx,res_high
	mov	ax,res_low
	jmp	ISDone

;---------------------------------------
;
;  Drive information
;
is1:	dec	ax		; ax = 1?
	jz	DriveInfo
	jmp	is5

DriveInfo:
	mov	ah,19h		; get the current disk
	cCall	NoHookDOSCall
	mov	bx,Which	; try to set to this disk
	cmp	al,bl		; already there?
	jz	DriveData	; yes, drive is good

	push	ax
	mov	dx,bx
	mov	ah,0Eh		; set to new disk
	cCall	NoHookDOSCall
	mov	ah,19h		; get the current disk
	cCall	NoHookDOSCall
	mov	bh,al
	pop	dx
	mov	ah,0Eh		; restore current disk
	cCall	NoHookDOSCall
	cmp	bh,bl		; Drive good?
	jz	DriveData	; yes
	jmp	is9		; no, this drive totally bad

; First check if this is network. We must do this first because
;  the removeable and phantom IOCTL calls return errors if you feed
;  them network drives. If it is network then we know it is non-removable
;  and not phantom.

DriveData:
	cmp	DosVer,0400h
	jb	no_4
	cmp	DosVer,0401h
	ja	no_4
	cCall	Dos4IsRemote,<Which>
	or	ax,ax
	jmp	short well_is_it

no_4:	mov	ax,4409h	; IOCTL is Remote
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	DoRem		; Call didn't work, go ahead
	test	dx,0001000000000000B
well_is_it:
	jz	DoRem		; Drive is local
	mov	cx,REMOTE	; Drive is not removeable
	jmp	short NoRemap	; Drive is not phantom

; Now Check "removeability"

DoRem:
	mov	ax,4408h	; IOCTL is removeable
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	OLDRemove	; Call didn't work, use old method
	mov	cx,FIXED
	test	ax,1
	jnz	DrivePhantom
	mov	cx,REMOVEABLE

; The drive is removable ...
; This code accounts for the fact that the code above on a PS/2
; Mod 50 diskless workstation reports the existence of a floppy
; drive on A: or B: even if it's unplugged.  If this is drive A:
; or B:, we need to test fBootDrive to see if this drive REALLY
; exists.

ifdef   NEC_98
	push	es		; ins <91.01.14> Y.Ueno
	mov	ax, 40h		;	"
	mov	es, ax		;	"
	push	si		;	"
	mov	si, Which	;
	mov	al, byte ptr es:[si+26ch]
	and	al, 0f0h
	cmp	al, 0a0h
	pop	si		;
	pop	es		;
	jne	DrivePhantom	;
	mov	cx,FIXED	;
else    ; NEC_98
	cmp	Which, 2	; this isn't likely, but..
	jae	DrivePhantom	;  there ARE removable hard drives.
	test	fBootDrive,1	; Must be a floppy, does this system have any?
	jnz	DrivePhantom	; if 0,
	jmp	Is9		;  we assume there are none
endif   ; NEC_98

; Now check for phantom drives

DrivePhantom:
	mov	ax,440EH	; IOCTL get logical map
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	OLDPhantom	; Call didn't work, use old method
	or	al,al		; If AL=0, drive is NOT phantom
	jz	NoRemap
	cmp	bl,al		; Drive maps to self?
	jz	NoRemap		; Yes, drive is not phantom
	xor	ah,ah
	mov	dx,ax		; DX is real drive
SetPhantomRet:
	xor	ax,ax		; Set removeable return
	cmp	cx,REMOVEABLE
	jz	IsDoneV
	inc	ax		; Set fixed return
	jmp	short IsDoneV

NoRemap:
	xchg	ax,cx		; AX = type of drive
	xor	dx,dx		; Indicate no remapping
IsDoneV:
	jmp	ISDone


; Check removeability with equipment word

OLDRemove:
ifdef   NEC_98
	mov	cx,FIXED
else    ; NEC_98
	xor	ax,ax
	or	al,numFloppies	; just one floppy on system?
	jnz	OLDR1		; no, continue
	inc	ax		; pretend we have two floppies...
OLDR1:
	cmp	ax,which
	mov	cx,FIXED
	jb	DrivePhantom
	mov	cx,REMOVEABLE
endif   ; NEC_98
	jmp	short DrivePhantom

; Check phantomness with equipment word

OLDPhantom:
ifdef   NEC_98
	jmp	short NoRemap	; No, drive B is real
else    ; NEC_98
	cmp	Which,1		; Drive B is only phantom
	jnz	NoRemap		; Not drive B, so not phantom
	cmp	numFloppies,0	; Single floppy system?
	jnz	NoRemap		; No, drive B is real
	mov	dx,1		; Drive B is really drive A
	jmp	short SetPhantomRet
endif   ; NEC_98

;---------------------------------------------------
;
;  Single Floppy enable/disable
;
is5:	dec	ax		; floppy enable disable?
ifdef   NEC_98
	jnz	is9a		; 	"
else    ; NEC_98
	jnz	is9
endif   ; NEC_98

is5b:	cmp	which,0 	; 0=disable
	jnz	is6

;  Disable various OEM things

	cmp	DosVer,0314h	; Below DOS 3.20?
	jae	nosingdrv1	; No, no ROM area diddle

;;
;;  AT&T MS-DOS 3.10 does not keep information on the last floppy
;;  drive accessed at 504h. The purpose of this section
;;  of code is to locate the bytes and patch them accordingly.
;;

ifndef  NEC_98
	mov	ax,__ROMBIOS		;; is this an AT&T machine ?
	mov	es,ax			;; look for start of 'OLIVETTI'
	cmp	es:[0C050h],'LO'
	jnz	ATTCheckDone		;; No, continue
	mov	SingleDriveLoc,ATT31Loc
ATTCheckDone:

	mov	ax,__0040h
	mov	es,ax
	mov	bx,SingleDriveLoc	;; set to drive A
	xor	ah, ah			;  set to drive A: also! (A=0)
	xchg	ah,es:[bx]
	mov	oneDriveFlag,ah 	; remember previous setting
endif   ; NEC_98
nosingdrv1:
	jmp	short is9

;   Enable various OEM things

is6:	cmp	DosVer,0314h		; Below DOS 3.20?
	jae	nosingdrv2		; No, no ROM diddle
ifndef  NEC_98
	mov	ax,__0040h
	mov	es,ax
	mov	bx,SingleDriveLoc	;; pointer to value
	mov	ah,oneDriveFlag
	mov	es:[bx],ah		;; restore to correct drive
endif   ; NEC_98
nosingdrv2:
ifdef   NEC_98
is9a:
	dec	ax
	jz	is9b	; what == 3 ?
	jmp	is9
is9b:
	push	es
	mov	ax,40h		; get ROM BIOS segment
	mov	es,ax
	test	BIOS_FLAG1,BIT286
	mov	ax,1
	jz	I_V30
	mov	dx,10h		;80286/80386 coprocess error vector
	jmp	short IOK
I_V30:
	mov	dx,16h		;8086/V30 coprocess error vector
IOK:
	pop	es
	jmp	ISDone
endif

is9:	xor	dx,dx
	xor	ax,ax
ISDone:
	pop	ds

cEnd	Inquire


;-----------------------------------------------------------------------;
; Get80x87SaveSize                                                      ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:13p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Get80x87SaveSize,<PUBLIC,FAR>
cBegin nogen
	push	ds
	mov	ds, MyCSDS
	assumes ds, DATA
	mov	ax,CoProcFlag
	pop	ds
	ret	
cEnd nogen


;-----------------------------------------------------------------------;
; Save80x87State                                                        ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:17p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Save80x87State,<PUBLIC,FAR>
;	parmD	savearea
cBegin nogen
	mov	bx,sp
	les	bx,[bx][4]
	fsave	es:[bx]
	ret	4
cEnd nogen


;-----------------------------------------------------------------------;
; Restore80x87State                                                     ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:23p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Restore80x87State,<PUBLIC,FAR>
;	parmD	savearea
cBegin nogen
	mov	bx,sp
	les	bx,[bx][4]
	frstor	es:[bx]
	ret	4
cEnd nogen

if2
%out	Dummy A20 handler still here
endif

	assumes ds,nothing
	assumes es,nothing

cProc	A20_Proc,<PUBLIC,FAR>
;	parmW	enable
cBegin nogen
	mov	ax, 2			; No himem area error code
	ret	2
cEnd nogen


; the following routine is added per DavidW's suggestion that the disable
; calls be made through WEP routine and this WEP will call any clean-up
; to be done by the driver.

ifdef HPSYSTEM

cProc	WEP, <PUBLIC, FAR>
	parmW	dummy
cBegin	
	call	DisableVectra		;~~vvr 091989
	mov	ax, 1			; by convention
cEnd

else

cProc	WEP,<PUBLIC,FAR>
;	parmW	dummy
cBegin nogen
	mov	ax,1
	ret	2
cEnd nogen

endif ;HPSYSTEM


;-----------------------------------------------------------------------;
;									;
; BOOL Dos4IsRemote(int);						;
;									;
; ENTRY:  Word, iPDrive: must be of the form ( logical volume A = 0 )	;
;		Physical Drive Spec.			      B = 1	;
;							      C = 2	;
;							      ect.	;
; EXIT: BOOL  returned in AX True  = Remote				;
;			     False = Local				;
;									;
; DESTROYS: AX. (preserves all registers except AX for return value)	;
;									;
;  Wed 27-Sep-1989 20:08:18  -by-  David N. Weise  [davidw]		;
; Stole this from setup, made it smaller.				;
;									;
; AUTHOR: MC								;
;-----------------------------------------------------------------------;

cProc	Dos4IsRemote,<NEAR,PUBLIC.ATOMIC,NODATA>, <si,di,ds,es>

	ParmW	iPDrive 		; Int Physical drive spec 0 - 25
	localV	local_name,16		; Buffer to hold redirected local name.
	localV	net_name,128		; Buffer to hold remote device name.
					; redirected local device names.
cBegin

; We have to use DOS call int 21h/5f02h because DOS call int 21h/4409h
; is not reliable under DOS versions 4.00 and 4.01.

        xor     cx,cx
	mov	ax,ss			; Load segs for stack vars.
        mov     es,ax
        mov     ds,ax

next_entry:
        mov     bx,cx                 ; CX = redirection list index.
        lea     si,local_name         ; ds:si = local_name
        lea     di,net_name           ; es:di = net_name
        push    cx                    ; save CX
	mov	ax,5F02h	      ; func 5f/02 Get redirection list.
	call	NoHookDOSCall
        pop     cx                    ; restore CX
	mov	ax,0		      ; don't change flags
	jc	IsRemoteDone	      ; error, not supported or end of list.

        cmp     bl,04h                ; Is redirected device a drive ?
        jne     not_a_drive           ; If not, we don't care !

	mov	al,ds:[si]	      ; Grab volume name.
        sub     al,41h                ; Convert to volume number A=0 ect.
	cmp	ax,iPDrive
	jz	remote_found

not_a_drive:
        inc     cx                    ; CX = redirection list index.
        jmp     short next_entry

remote_found:
        mov     ax,1                  ; Indicate Volume is remote !

IsRemoteDone:

cEnd

;-----------------------------------------------------------------------;
; InitSystem
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 14:57:21  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

ifdef   NEC_98
sSysIni         db      "system.ini",0          ; name of file.	930206
sSystem         db      "system",0              ; [system] section.930206
sTimer          db      "reflecttimer", 0       ; 0 : no 1:yes	930206
endif   ; NEC_98

cProc	InitSystem,<PUBLIC,FAR>
cBegin	nogen
	push	ds

	mov	ds, MyCSDS
	assumes ds, DATA

ifdef   NEC_98
  ;930206
	cmp	[profinit],0
	jnz	profinitdone
	inc	[profinit]
	push	es
        ; Get keyboard table type from WIN.INI.
        lea	si, sSystem
        lea	di, sTimer
        lea	bx, sSysIni
        regptr  cssi,cs,si                      ; lpAppName = "keyboard"
        regptr  csdi,cs,di                      ; lpKeyName = "type"
        regptr  csbx,cs,bx                      ; lpFile = "SYSTEM.INI"
	mov	ax, 0				; defualt is not reflect
	cCall	GetPrivateProfileInt,<cssi, csdi, ax, csbx>

	mov	byte ptr [reflected], al
	pop	es
profinitdone:
  ;930206
endif   ; NEC_98

	cmp	SystemIsInited,0	; Have we already done this?
	jnz	no_80x87		; Yes
	inc	SystemIsInited		; We will now init

	mov	ah,30h		; Get DOS version
	int	21h
	xchg	ah,al		; major <-> minor
	mov	DosVer,ax

ifdef	HPSYSTEM
	call	EnableVectra		;~~vvr 091889
endif

ifndef  NEC_98
	int	11h			; get equipment word
	push	ax
	mov	cl,6
	shr	ax,cl
	and	al,00000011b		; isolate drive count
	mov	numFloppies,al
	pop	ax

; Set fBootDrive

	mov	fBootDrive,al		; bit 0 has boot volume installed flag
endif   ; NEC_98

; Set CoProcFlag

	mov	CoProcFlag,0
ifdef   NEC_98
	FINIT
	FINIT
	delay2	14
	xor	ax, ax
	mov	NDP_CONTROL, ax		; clear temp
	FSTCW	NDP_CONTROL
	delay2	14
	and	NDP_CONTROL, 0f3fh	;
	cmp	NDP_CONTROL, 033fh	;
	jne	no_80X87
	FSTSW	NDP_CONTROL
	delay2	14
	inc	ax
	test	NDP_CONTROL, 0b8bfh
	jnz	no_80X87
else    ; NEC_98
	test	al,2			; this is the IBM approved method
	jz	no_80x87		;   to check for an 8087
endif   ; NEC_98
	mov	CoProcFlag,94		; size of save area
	FNINIT
no_80x87:
	mov	ax,1
	pop	ds
	ret

cEnd nogen

ifdef	JAPAN
;-----------------------------------------------------------------------;
; JapanInquireSystem( what, which )
;   Get system information - Japanese specific.
;
; Entry:
;	what - function code as;
;		0 - Inquire interrupt vector modification
;			'which' contains interrupt vector number (0-FF)
;			to get it is can be changed. Returns zero if a
;			vector cannot be changed
;		1 - Get Boot drive
;			Returns boot drive. 0=A,1=B...etc.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	JapanInquireSystem,<PUBLIC,FAR>
	parmW	what
	parmW	which
ifdef   NEC_98
	localW 	WKDRV			; 92.11.17 Win31 NEC
endif   ; NEC_98
cBegin
	mov	ax,what
	test	ax,ax		; what=1?
	jnz	jis2		; jump if not
ifndef  NEC_98
	mov	ax,which	; get vector number to examine
	cmp	al,1bh		; try to change 1b?
	jz	jis1		; jump if so - cannot modify
	cmp	al,1ch		; try to change 1c?
	jz	jis1		; jump if so - channot modify
endif   ; NEC_98
	mov	ax,1		; OK to modify
	jmp	jisx
jis1:
	xor	ax,ax		; cannot modify
	jmp	jisx
jis2:
	dec	ax		; what=2?
	jnz	jis3		; jump if not
ifdef   NEC_98
	mov	ax,3000H	; Get DOS Version
	int	21H		;
	cmp	al,05H
	jb	jis3
	mov	ah,33H		; Get Boot Drive DOS5
	mov	al,05H
	int	21H
	mov	dh,00h
	mov	WKDRV,dx
	mov	ax,WKDRV
	dec	ax
else    ; NEC_98
	mov	ax,2		; drive 'C:' is a default boot drive for
				; industrial standard PC
endif   ; NEC_98
	jmp	jisx
jis3:
	mov	ax,-1		; error!
jisx:
cEnd

endif	;JAPAN


sEnd	CODE		; End of code segment


END	InitSystem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\timer.asm ===
;------------------------------ Module Header ------------------------------;
; Module Name: Timer interface procedures
;
; Created: ??-???-83
;
; Copyright (c) 1983, 1984, 1985, 1986, 1987  Microsoft Corporation
;
; History:
;  10-Jan-87 by ronm  Adusted StackBase to be even
;   9-Jan-87 by ronm  Patches to support HiTime.asm
;---------------------------------------------------------------------------;

	TITLE	Timer interface procedures

include system.inc
include wow.inc
include wowusr.inc
include vint.inc
ifdef   NEC_98
include timer.inc
externA 	__ROMBIOS
endif   ; NEC_98

externFP WOW16Call

; Interrupt vector to use

VECTOR	    equ 08h

assumes CS,CODE

sBegin DATA

		PUBLIC	timerTable
timerTable	LABEL	BYTE
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
	    DW	    -1
	    DW	    -1

ifdef WOW
cTimers         DW  0
endif

enabled 	DB  0		; 0 means int 8 hook not installed
				; 1 means int 8 hook installed
				; >1 means inside our int 8 hook

ifdef   NEC_98
externB		reflected	; 930206
endif   ; NEC_98

if 0
;
;   no longer used
;
	public	StackBase
		EVEN		; Put the stack at a word boundary!
StackBase	DB  64	DUP (-1)

	PUBLIC	prevInt8Proc,prevSSSP,enabled
	PUBLIC	cms, cmsRound

		DB  128 DUP (?)
int8stack	LABEL	BYTE	; Stack to use inside our int 8 hook

prevSSSP	DD  0		; Previous stack when inside our hook
endif

prevInt8Proc	DD  0		; Previous int 8 interrupt handler
cms		DD  0		; msec count.
cmsRound	DW  0		; for rounding off the msec count.
ifdef   NEC_98
		DB  '@@@@'
TIINTFLAG1	DW  0
TIINTFLAG2	DW  0
endif   ; NEC_98

sEnd

sBegin	CODE	    ; Beginning of code segment
assumes CS,CODE

externW  MyCSDS     ; always in CS (even in ROM)

;--- timer hardware service -----------------------
;
noevent:
ifdef   NEC_98
	assumes ds, DATA
	cmp	[reflected],0
	jne	@f

NoReflect:
	push	ax
	mov	al,20h		; eoi
	out	0,al
	pop	ax
	pop	ds
	iret

@@:	assumes ds,nothing
	push	ds
	push	ax
	mov	ax, __ROMBIOS
	mov	ds, ax
	cmp	word ptr ds:[018ah], 1	; Q : timer counter end ?
	pop	ax
	pop	ds
	je	short NoReflect
endif   ; NEC_98
	assumes ds, DATA
	; push address
	push	word ptr prevInt8Proc[2]
	push	word ptr prevInt8Proc[0]

	; restore ds out of stack
	push	bp
	mov	bp, sp
	mov	ds, [bp+6]
	assumes ds,nothing
	pop	bp

	; jump to prev proc popping saved ds
	retf	2

;----------------------------- Private Function ----------------------------;
;
; Entry:	call	far ptr timer_int
;
; Returns:	nothing
;
; Registers Destroyed: none
;
; History:
;  09-Jan-87 by ronm  Added hooks for the high resolution timer fns
;		      in hitime.asm
;  ??-???-?? by ????  Wrote it
;---------------------------------------------------------------------------;

	assumes	ds,nothing
	assumes	es,nothing

cProc	timer_int,<FAR,PUBLIC>

cBegin nogen

; Don't trash any registers.

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA
	add	word ptr [cms][0],(res_low / 1000)
	adc	word ptr [cms][2],0
	add	[cmsRound],(res_low - ((res_low / 1000) * 1000))
	cmp	[cmsRound],1000
	jb	ti0
	sub	[cmsRound],1000
	inc	word ptr [cms][0]
	jnz	ti0
	inc	word ptr [cms][2]
ti0:
ifdef   NEC_98
	push	dx		; clear int share reg.
	push	ax
	mov	dx,879h
	in	al,dx
	pop	ax
	pop	dx
endif   ; NEC_98
	cmp	[enabled],1
	jne	noevent
	inc	[enabled]
ifdef   NEC_98
	cmp	[reflected],0
	je	short ti01
endif   ; NEC_98

	pushf

	; enable IF flag in stack flags to prevInt8Proc if they were
	; on when this routine was entered -- this allows the 286 DOS
	; extender to enable ints after running real mode Int 8 handler.

	FLAGS1 = 3			;	 +0   +2   +4	+6   +8  +10
	FLAGS2 = 11			; BP -> [bp] [fl] [ds] [ip] [cs] [fl]

	push	bp
	mov	bp,sp
	test	byte ptr FLAGS2[bp],02h
	jz	@f
	or	byte ptr FLAGS1[bp],02h
@@:	pop	bp


	call	[prevInt8Proc]	; call previous Int 8 routine

ifdef   NEC_98
	push	ax
	mask	TIMERMASK
	mov	al,36h
	out	timodeset,al		; Timer mode set
	delay	8253,O-O
	mov	ax,0f000h		;count(25msec * 2457.6)
	push	es
	push	ax
	mov	ax,40h
	mov	es,ax
	test	byte ptr es:[101h],80h	; Q : clock 2.5 MHz ?
	pop	ax
	pop	es
	jz	@f			;5MHz,10MHz,12MHz,20MHz 25MHz set
	mov	ax,0c300h		;8MHz,16MHz  set
@@:
	out	ticntset,al
	delay	8253,O-O
	xchg	ah,al
	out	ticntset,al
	unmask	TIMERMASK
	pop	ax
	jmp	short ti1
ti01:
	push	ax
	mov	al,20h			; eoi
	out	0,al
	pop	ax
endif   ; NEC_98

	public	ti1
ti1:

comment ~
        FCLI
	mov	word ptr [prevSSSP][2],ss
	mov	word ptr [prevSSSP][0],sp
	push	ds
	pop	ss
	mov	sp,codeOffset int8stack
        FSTI                     ; Allow interrupts

end comment ~

	push	ax

	mov	al,00001011b	; ask for 8259 status
ifdef   NEC_98
	out	00h,al
	jmp	$+2
	jmp	$+2
	in	al,00h		; get the status
else    ; NEC_98
	out	20h,al
	jmp	$+2
	in	al,20h		; get the status
endif   ; NEC_98
	or	al,al
	jnz	TheEnd		; if other pending EOIs, just exit

	push	bp
	push	es
	push	bx
	push	cx
	push	dx
	push	si
	push	di

	xor	bp,bp		    ; No valid BP chain
	mov	si,doffset TimerTable
nextent:
	cld
	lodsw			    ; Get timer rate
	.errnz	tirate
	inc	ax		    ; -1 means unused entry
	jnz	checkent	    ; no, check used entry
	lodsw			    ; yes, get timer count
	.errnz	2-ticount
	inc	ax		    ; another -1 means end of table
	jz	lastent 	    ; yes, all done
	add	si,4		    ; o.w. skip to next entry
	jmp	nextent
checkent:
	dec	ax		    ; 0 means call at maximum rate
	jz	callent
	dec	word ptr DS:[si]    ; o.w. decrement rate counter
	.errnz	2-ticount
	jz	callent 	    ; zero means timer has gone off
	add	si,6		    ; o.w. skip to next entry
	jmp	nextent
callent:
	mov	DS:[si],ax
	inc	si
	inc	si
	lea	ax,[si-4]	    ; Pass timer handle in AX
	.errnz	4-tiproc
	call	dword ptr DS:[si]
	add	si,4
	jmp	nextent
lastent:
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	es
	pop	bp
TheEnd:
	pop	ax
	dec	[enabled]

comment ~
        FCLI
	mov	ss,word ptr [prevSSSP][2]
	mov	sp,word ptr [prevSSSP][0]
        FSTI

end comment ~

	pop	ds


	iret

cEnd nogen


;============================================================================
; DWORD GetSystemMsecCount(void) - returns msec count.
;

	assumes ds,nothing
	assumes	es,nothing

    DUserThunk  GETSYSTEMMSECCOUNT,0

;LabelFP <PUBLIC, GetSystemMsecCount>
;
;	 push	 ds
;	 mov	 ds, MyCSDS
;	 assumes ds, DATA
;
;	 mov	 ax,word ptr [cms][0]
;	 mov	 dx,word ptr [cms][2]
;	 pop	 ds
;	 retf

;----------------------------- Private Function ----------------------------;
;
; EnableSystemTimers() - enable hardware timer interrupts
;
; Entry:    cCall   far ptr EnableSystemTimers
;
; Returns:  nothing
;
; Registers Destroyed:	??
;
; History:
;  09-Jan-87 by ronm  Patched to support hitime.asm
;  ??-???-?? by ????  Wrote it
;---------------------------------------------------------------------------;


	assumes	ds,nothing
	assumes	es,nothing

cProc	EnableSystemTimers,<FAR,PUBLIC>
cBegin	nogen

; All done if just already enabled

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA

ifdef WOW
        ; see if we're being called by Create to really enable tics
        cmp     cTimers, 1
        je      est_doit
endif

	cmp	enabled,0
	jne	edone

est_doit:
	mov	[enabled],1

ifdef WOW
        ; don't install the tic handler if no systemtimers registered
        cmp     cTimers, 0
        je      edone
endif

; Save away current timer interrupt vector value

	mov	ax,3500h or VECTOR
	int	21h
	mov	word ptr [PrevInt8Proc][0],bx
	mov	word ptr [PrevInt8Proc][2],es

; Setup timer interrupt vector to point to our interrupt routine

	mov	ax,2500h or VECTOR
	push	cs
	pop	ds
	mov	dx,codeOFFSET timer_int
	int	21h
ifdef   NEC_98
	mask	TIMERMASK
	mov	al,36h
	out	timodeset,al		; Timer mode set
	delay	8253,O-O
	mov	ax,0f000h		;count(25msec * 2457.6)
	push	es
	push	ax
	mov	ax,40h
	mov	es,ax
	test	byte ptr es:[101h],80h		; Q : clock 2.5 MHz ?
	pop	ax
	pop	es
	jz	@f			;5MHz,10MHz,12MHz,20MHz 25MHz set
	mov	ax,0c300h		;8MHz,16MHz  set
@@:
	out	ticntset,al
	delay	8253,O-O
	xchg	ah,al
	out	ticntset,al
	unmask	TIMERMASK
	sti
endif   ; NEC_98
edone:
	pop	ds
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; DisableSystemTimers
;
; DisableSystemTimers() - disable system timer interrupts, restoring
; the previous timer interrupt handler.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DisableSystemTimers,<FAR,PUBLIC>
cBegin	nogen

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA

; Do nothing if not enabled

	cmp	[enabled],0
	je	ddone
ifdef   NEC_98
	mask	TIMERMASK
endif   ; NEC_98
	mov	[enabled],0

; Restore the timer interrupt vector to point to previous value

	mov	ax,2500h or VECTOR
	lds	dx,prevInt8Proc
	int	21h
ddone:
	pop	ds
	ret
cEnd	nogen

;-----------------------------------------------------------------------;
; CreateSystemTimer
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CreateSystemTimer,<PUBLIC,FAR>
	ParmW	rate
	ParmD	lpproc
cBegin
	mov	ds,MyCSDS
	assumes ds, DATA
	mov	bx,doffset timerTable
	mov	ax,rate
	or	ax,ax
	jz	ctfirst
	mov	cx,1000 		; change msecs into ticks.
	mul	cx
	mov	cx,res_low
	div	cx
ctfirst:
        FCLI                             ; beginning of critical section
ctloop:
	cmp	ds:[bx].tirate,-1
	jne	ctnext
	cmp	ds:[bx].ticount,-1
	je	ctfail
	mov	cx,OFF_lpproc
	mov	dx,SEG_lpproc
	mov	word ptr ds:[bx].tiproc[0],cx
	mov	word ptr ds:[bx].tiproc[2],dx
	mov	ds:[bx].ticount,ax
	mov	ds:[bx].tirate,ax	   ; Set this last

ifdef WOW
        ; turn on tics if the count is going from 0 -> 1 and they're
        ; supposed to be enabled

        inc     cTimers
        cmp     cTimers, 1
        jne     @f

        cmp     enabled, 0      ; need to turn on tics?
        je      @f              ; -> nope

        push    bx
        call    EnableSystemTimers
        pop     bx
@@:
endif

	jmp	short ctexit

ctnext: add	bx,SIZE tiblock
	jmp	ctloop

ctfail: xor	bx,bx

ctexit: FSTI                                ; end of critical section
	mov	ax,bx
	mov	cx,bx
cEnd

;-----------------------------------------------------------------------;
; KillSystemTimer
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	KillSystemTimer,<PUBLIC,FAR>,<di>
	parmW	htimer
cBegin
	mov	es,MyCSDS
	assumes es,nothing
	mov	di,doffset TimerTable
	mov	ax,htimer

ktloop: cmp	es:[di].tirate,-1
	jne	ktmatch
	cmp	es:[di].ticount,-1
	jne	ktnext
	jmp	short ktexit
ktmatch:
	cmp	di,ax
	jne	ktnext
	cld
	mov	ax,-1
	stosw
	not	ax
	stosw
	stosw
	stosw
ifdef WOW
        dec     es:[cTimers]     ; was this the last one?
        jnz     @f                ;  -> nope

        cmp     es:[enabled], 0  ; are tics on?
        je      @f                ;  -> nope

; Restore the timer interrupt vector to point to previous value

        push    ax

	mov	ax,2500h or VECTOR
        lds     dx,es:[prevInt8Proc]
	int	21h

        pop     ax
@@:
endif

	jmp	short ktexit

ktnext: add	di,SIZE tiblock
	jmp	ktloop

ktexit: mov	cx,ax
cEnd

ifdef   NEC_98
LabelFP <PUBLIC, InquireLongInts>
;------- '88/01/07 -----------------------------------
	MOV	AX,1
;	mov	ax,cs:[AT_DOS30]
;------------------------------------------------------
	mov	cx,ax
	retf
endif   ; NEC_98

sEnd	CODE		; End of code segment

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\system.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;***************************************************************************
;                                                                          *
;   Header file for IBM/PC timer device driver.  Contains all machine      *
;   specific constant and data structure definitions.                      *
;                                                                          *
;***************************************************************************

	.xlist
	include cmacros.inc
ifdef   NEC_98
	include windefs.inc
else    ; NEC_98
;	 include windefs.inc
endif   ; NEC_98
	.list

; picked off romstuff.inc

DSEG equ DATA
doffset EQU <DataOffset>

; Approximate value of timer tic in milliseconds * 1000.

ifdef   NEC_98
res_low     EQU 25000
else    ; NEC_98
res_low     EQU 54925
endif   ; NEC_98
res_high    EQU 0

; equates for disk status

REMOVEABLE  equ 2
FIXED       equ 3
REMOTE	    equ 4

; Offset of Single Diskette indicator from beginning of Bios Data Area, 400h

SingleDrive equ 104h

; Timer structure

tiblock     STRUC
tirate      DW  ?       ; -1 means not used, 0 means call as fast as possible
ticount     DW  ?       ; -1 means end of table.
tiproc      DD  ?       ; far proc to call.
tiblock     ENDS

ifdef   NEC_98
;
;	DELAY MACRO FOR 80386
; This macro is defined in SYSMAC.INC(V23 ROM BIOS)		<880203 ver2.1
;
DELAY	MACRO	DEV,ACT,MOD

	IFIDN	<DEV>,<8237>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8253>
		IFIDN	<ACT>,<O-O>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8255>
		IFIDN	<ACT>,<O-O>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8259>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<I-I>
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<I-O>
		ENDIF
		IFIDN	<ACT>,<>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8251>
		IFIDN	<ACT>,<O-O>
			IFIDN	<MOD>,<INIT>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<ASYNC>
	REPT	5
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<SYNC>
	REPT	10
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
	ENDIF

	IFIDN	<DEV>,<765>
	ENDIF

	IFIDN	<DEV>,<7220>
		IFIDN	<ACT>,<O-O>
			IFIDN	<MOD>,<GRAPH>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	REPT	2
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
		IFIDN	<ACT>,<I-I>
			IFIDN	<MOD>,<GRAPH>
	REPT	3
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	JMP	SHORT	$+2
			ENDIF
		ENDIF
		IFIDN	<ACT>,<O-I>
			IFIDN	<MOD>,<GRAPH>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	REPT	2
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
		IFIDN	<ACT>,<I-O>
			IFIDN	<MOD>,<GRAPH>
	REPT	3
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	JMP	SHORT	$+2
			ENDIF
		ENDIF
	ENDIF

	IFIDN	<DEV>,<7201>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<7210>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<4990>
		REPT	3
		JMP	SHORT	$+2
		ENDM
	ENDIF

	ENDM

; dummy delay
DELAY2	MACRO	CNT
	local	l1
	push	cx
	mov	cx, CNT
l1:
	out	5fh, al
	loop	l1
	pop	cx
	ENDM
endif   ; NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\hello\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\windefs.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.


include vint.inc

EnterCrit   MACRO
        pushf
        FCLI
ENDM

LeaveCrit   MACRO
        POPFF
ENDM

POPFF   MACRO
        local   a
        jmp     $+3
a       label   near
        iret
        push    cs
        call    a
ENDM





;***************************************************************************
;                                                                          *
;   Inquire data structures for Timer, Keyboard, Mouse and Cursor modules  *
;                                                                          *
;***************************************************************************

TIMERINFO       STRUC
tiResolution    DD      0       ; #microseconds each timer tick
TIMERINFO       ENDS

KBINFO          STRUC
kbRanges        DB      4 dup (0)  ; Far East ranges for KANJI
kbStateSize     DW      0       ; #bytes of state info maintained by TOASCII
kbNumFuncKeys   DW      0       ; How many function keys are on the keyboard
kbHasBreak      DW      0       ; true => keyboard supplies make and break
kbRate          DW      0       ; maximum rate of keyboard input events
KBINFO          ENDS


MOUSEINFO       STRUC
msExists        DB      0       ; true => mouse exists
msRelative      DB      0       ; true => relative coordinate
msNumButtons    DW      0       ; number of buttons on the mouse
msRate          DW      0       ; maximum rate of mouse input events
msXThresh       DW      0       ; threshold before acceleration
msYThresh       DW      0       ;
msXRes          DW      0       ; x resolution
msYRes          DW      0       ; y resolution
MOUSEINFO       ENDS


CURSORINFO      STRUC
dpXRate         DW      0       ; horizontal mickey/pixel ratio
dpYRate         DW      0       ; vertical mickey/pixel ratio
CURSORINFO      ENDS


;***************************************************************************
;                                                                          *
; Cursor data structure passed to OEM routines.  Defines a graphics display*
; cursor in terms of a hotspot, an AND mask and an XOR mask.  The hot      *
; spot defines the pixel within the cursor that is the cursor is "pointing"*
; to.  So when displaying a cursor at location X,Y the pixel that          *
; is the hot spot should be painted at that X,Y coordinate.  The "shape"   *
; of the cursor is defined by two pixel masks.  The first mask is ANDed    *
; with the bits in the display bitmap and the second mask is XORed with    *
; the result to determine the bits that will be placed in the display      *
; bitmap.  The bits for the masks are in the byte array that begins        *
; at the csBits field, with the AND mask bits first, followed by the       *
; XOR mask bits.  The csWidthBytes field is the width of ONE mask, in      *
; bytes.  Currently, MS-WIN will only generate cursors whose width and     *
; height are both 16.                                                      *
;                                                                          *
;***************************************************************************

cursorShape     STRUC
csHotX          DW      0
csHotY          DW      0
csWidth         DW      0
csHeight        DW      0
csWidthBytes    DW      0
csColor         DW      0
    ; Beginning of an array of bytes that contain the bits for the AND and
    ; XOR masks.  The first csHeight * csWidthBytes bytes contain the bits
    ; for the AND mask and the next csHeight * csWidthBytes bytes contain
    ; the bits for the XOR mask.
;csBits          DB  2*2*16 DUP (?)
cursorShape     ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\timer.inc ===
;/************************************************************************
;*									*
;* 		< SYSTEM Application Program  >				*
;*									*
;*									*
;*		COPYRIGHT (C) NEC CORPORATION 1989			*
;*									*
;*		NEC CONFIDENTAL AND PROPRIETARY				*
;*									*
;*		All rights reserved by NEC Corporation.			*
;*		this program must be used solely for			*
;*		the purpose for which it was furnished			*
;*		by NEC Corporation.  No part of this program		*
;*		may be reproduced or disclosed to others,		*
;*		in any from, without the prior written			*
;*		permission of NEC Corporation.				*
;*		Use of copyright notice does not evidence		*
;*		publication of this program.				*
;*									*
;*************************************************************************/
;------------------------------ Module Header ------------------------------;
; Module Name: Timer interface procedures
;
; Created: 03-08-90 NEC Y.Ueno

INTMASK		EQU	2
TIMODESET	EQU	77H
TICNTSET	EQU	71H
EOI		EQU	20H
EOIPORT		EQU	0
TIMERMASK	EQU	01H

mask macro	code
	cli				; mask timer int
	in	al,02h
	delay	8259,I-O
	or	al,code
	out	02h,al
	jmp	$+2
	sti
	endm

unmask macro	code
	cli				; mask timer int
	in	al,02h
	delay	8259,I-O
	and	al,not code
	out	02h,al
	jmp	$+2
	sti
	endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\system\vecsys.inc ===
;------------------------------------------------------------------
;
; HPsysCall(Service, Function, Subfunction)
;
; Purpose	General purpose HP system calling routine
;
; Parameters	Service - HP vector
;		Function
;		Subfunction - function numbers
;
; Results	returns AH which is 0 for success
;		
;-------------------------------------------------------------------	
HPSysCall macro	Device, Function, SubFunc
	
	push	ds
	push	bp
	push	ax

	mov	bx, offset RealMode_Word_Struc
	pushf
	pop	RealMode_flags[bx]
	mov	RealMode_BP[bx], Device
	mov	RealMode_AH[bx], Function
	mov	RealMode_AL[bx], SubFunc
	mov	ax, ds
	mov	es, ax				; make es = ds
	mov	di, bx
	mov	bl, 6fh
	xor	bh, bh
	xor	cx, cx
	mov	ax, 0300h
	int	31h
	mov	bx, offset RealMode_Word_Struc
	mov	ax, es
	mov	ds, ax
	mov	bx, RealMode_BX[bx]

	pop	ax
	pop	bp
	pop	ds

	endm 	


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\hello\hello.h ===
/*++
 *
 *  Hello.h
 *  Simple 16-bit Windows App
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  From "Programming Windows" by C. Petzold, p.16-19
 *
 *  Updated 02-May-1991 by Jeff Parsons (jeffpar)
 *  To serve as a bare-bones shell (user-friendly of course)
--*/


#define IDM_BREAKPOINT          100
#define IDM_ENUMWINDOWS         101
#define IDM_ENUMCHILDWINDOWS    102
#define IDM_ENUMTASKWINDOWS     103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\hello\hello.c ===
/*++
 *
 *  Hello.c
 *  Simple 16-bit Windows App
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  From "Programming Windows" by C. Petzold, p.16-19
 *
 *  Updated 02-May-1991 by Jeff Parsons (jeffpar)
 *  To serve as a bare-bones shell (user-friendly of course)
--*/

#include <windows.h>
#include "hello.h"


#define BUTTON_REVERSI	1	// button IDs

#define BUTTON_WIDTH	80	// width and height for all buttons
#define BUTTON_HEIGHT	20


BOOL FAR PASCAL EnumWindowFunc(HWND hwnd, DWORD lParam)
{
    char achTmp[80];

    wsprintf(achTmp, "HELLO: Window %04x enumerated\n", hwnd);
    OutputDebugString(achTmp);

    return TRUE;                // return non-zero to continue enumeration
}


LONG FAR PASCAL WndProc(HWND hwnd, WORD wMsg, int wParam, LONG lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    HANDLE hTask;
    char achTmp[80];
    static char achTextOut[] = "The User-Friendly WOW Shell";

    switch(wMsg) {

    case WM_CREATE:
	CreateWindow("Button",
		     "Reversi",
		     WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
		     8,
		     8 + BUTTON_REVERSI*24,
		     BUTTON_WIDTH,
		     BUTTON_HEIGHT,
		     hwnd,
		     BUTTON_REVERSI,
		     ((LPCREATESTRUCT)lParam)->hInstance, NULL);
	return 0;

    case WM_PAINT:
	hdc = BeginPaint(hwnd, &ps);
	TextOut(hdc, 8, 8, achTextOut, sizeof(achTextOut)-1);
	EndPaint(hwnd, &ps);
	return 0;

    case WM_COMMAND:

	// See if the command is from a menu

	if (LOWORD(lParam) == 0) {

	    switch(wParam) {

	    case IDM_BREAKPOINT:
                _asm int 3

                // Hokey timing test -JTP
		GetParent(hwnd);
		{
		    int i;
		    for (i=0; i<10000; i++)
			GetParent(hwnd);
		}
		return 0;

            case IDM_ENUMWINDOWS:
                OutputDebugString("HELLO: Enumerating windows\n");
                EnumWindows(EnumWindowFunc, 0x10000001);
                return 0;

            case IDM_ENUMCHILDWINDOWS:
                wsprintf(achTmp, "HELLO: Enumerating child windows for hwnd %04x\n", hwnd);
                OutputDebugString(achTmp);
                EnumChildWindows(hwnd, EnumWindowFunc, 0x10000002);
                return 0;

            case IDM_ENUMTASKWINDOWS:
                hTask = GetCurrentTask();
                wsprintf(achTmp, "HELLO: Enumerating task windows for task %04x\n", hTask);
                OutputDebugString(achTmp);
                EnumTaskWindows(hTask, EnumWindowFunc, 0x10000003);
                return 0;
	    }
	}

	// The command must be a button notification
	// (or something else I'm too ignorant to know about -JTP)

	else {

	    if (wParam == BUTTON_REVERSI) {
		// _asm int 3
		WinExec("REVERSI.EXE", SW_SHOWNORMAL);
		// _asm int 3
	    }
	    return 0;
	}
	break;

    case WM_DESTROY:
	PostQuitMessage(0);
	return 0;
    }
    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}


int PASCAL WinMain(HANDLE hInstance,
		   HANDLE hPrevInstance, LPSTR lpszCmd, int iCmd)
{
    HWND hwnd;
    MSG msg;
    WNDCLASS wc;
    static char szApp[] = "WOW";

    if (!hPrevInstance) {
	wc.style	= CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc	= WndProc;
	wc.cbClsExtra	= 0;
	wc.cbWndExtra	= 0;
	wc.hInstance	= hInstance;
	wc.hIcon	= LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor	= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground= GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName = szApp;
	wc.lpszClassName= szApp;
	if (!RegisterClass(&wc))
	    return 0;
    }
    hwnd = CreateWindow(
	szApp,			// window class name
	szApp,			// window caption
	(WS_OVERLAPPEDWINDOW & ~WS_THICKFRAME) | WS_VISIBLE,
	50, 50, 250, 128,
	NULL,			// parent window handle
	NULL,			// window menu handle
	hInstance,		// program instance handle
	NULL			// creation parameters
    );
    if (!hwnd)
	return 0;

    while (GetMessage(&msg, NULL, 0, 0)) {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\hello\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\pmdos.asm ===
;****************************************************************************
;*									    *
;*  PMDOS.ASM - 							    *
;*									    *
;*	Low level DOS routines needed by the Program Manager.		    *
;*									    *
;****************************************************************************

memS=1
?PLM=1
?WIN=1

include cmacros.inc

SelectDisk		equ 0Eh
FCBFindFirstFile	equ 11h
FCBFindNextFile 	equ 12h
FCBDeleteFile		equ 13h
FCBRenameFile		equ 17h
GetCurrentDisk		equ 19h
SetDTAAddress		equ 1Ah
GetFileSize		equ 23h
GetDiskFreeSpace	equ 36h
CreateDir		equ 39h
RemoveDir		equ 3Ah
ChangeCurrentDir	equ 3Bh
CreateFile		equ 3Ch
DeleteFile		equ 41h
GetSetFileAttributes	equ 43h
GetCurrentDir		equ 47h
FindFirstFile		equ 4Eh
FindNextFile		equ 4Fh
RenameFile		equ 56h

externFP DOS3CALL

externFP    AnsiToOem
ifdef	DBCS
externFP    IsDBCSLeadByte
endif

;=============================================================================

createSeg _%SEGNAME, %SEGNAME, WORD, PUBLIC, CODE

sBegin %SEGNAME

assumes CS,%SEGNAME
assumes DS,DATA

cProc	PathType, <FAR, PUBLIC>

    parmD   lpFile

    localV  szOEM, 128

cBegin

    RegPtr lpszOEM, ss, bx
    lea     bx, szOEM
    cCall   AnsiToOem, <lpFile, lpszOEM>

    lea     dx, szOEM
    mov     ax, 4300h
    call    DOS3CALL
    jnc     id_noerror
    xor     ax, ax
    jmp     short id_exit

id_noerror:
    and     cx, 10h
    jnz     id_dir
    mov     ax, 1
    jmp     short id_exit

id_dir:
    mov     ax, 2

id_exit:
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  FileTime*() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc FileTime, <FAR, PUBLIC>

    parmW   hFile

cBegin
    mov     ax, 5700h
    mov     bx, hFile
    cCall   DOS3CALL
    jnc     ft_ok
    sub     ax, ax
    sub     dx, dx
    jmp     short ft_ex
ft_ok:
    mov     ax, cx
ft_ex:
cEnd

;*--------------------------------------------------------------------------*
;*									    *
;*  IsReadOnly() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsReadOnly, <FAR, PUBLIC>

    parmD   lpFile

    localV  szOEM, 128

cBegin

    RegPtr  lpszOEM, ss, bx
    lea     bx, szOEM
    cCall   AnsiToOem,<lpFile,lpszOEM>

    mov     ax, 4300h		; get attributes...
    lea     dx, szOEM		; ...for given file...
    call    DOS3CALL
    jc	    f_exit		; ax == 0 if error...
    and     ax, 1		; test RO bit
    jmp     short t_exit        ; true
f_exit:
    xor     ax, ax              ; false
t_exit:
cEnd



;*--------------------------------------------------------------------------*
;*									    *
;*  GetDOSErrorCode() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetDOSErrorCode, <FAR, PUBLIC>, <SI,DI>

cBegin

    mov     ah,59h		; Get DOS extended error
    sub     bx,bx		; cause ray duncan says so
    push    ds			; function trashes registers
    push    bp			; so we gotta save 'em for cProc
    call    DOS3CALL
    pop     bp			; be nice to C
    pop     ds			; get DS
    mov     dl,bh		; class in byte 2
    mov     dh,ch		; locus in byte 3 (skip the rec. action)

cEnd

;*--------------------------------------------------------------------------*
;*									    *
;*  GetCurrentDrive() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetCurrentDrive, <FAR, PUBLIC>

cBegin
	    mov     ah,GetCurrentDisk
	    call    DOS3CALL
	    sub     ah,ah		; Zero out AH
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  SetCurrentDrive() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; Returns the number of drives in AX.

cProc SetCurrentDrive, <FAR, PUBLIC>

ParmW Drive

cBegin
	    mov     dx,Drive
	    mov     ah,SelectDisk
	    call    DOS3CALL
	    sub     ah,ah		; Zero out AH
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  GetCurrentDirectory() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetCurrentDirectory, <FAR, PUBLIC>, <SI, DI>

parmW wDrive
ParmD lpDest

cBegin
	    push    ds			; Preserve DS

	    mov     ax,wDrive
	    or	    al,al
	    jnz     GCDHaveDrive

	    call    GetCurrentDrive

	    inc     al			; Convert to logical drive number

GCDHaveDrive:
	    les     di,lpDest		; ES:DI = lpDest
	    push    es
	    pop     ds			; DS:DI = lpDest
	    cld

	    mov     dl,al		; DL = Logical Drive Number
	    add     al,'@'		; Convert to ASCII drive letter
	    stosb
	    mov     al,':'
	    stosb
	    mov     al,'\'		; Start string with a backslash
	    stosb
	    mov     byte ptr es:[di],0	; Null terminate in case of error
	    mov     si,di		; DS:SI = lpDest[1]
	    mov     ah,GetCurrentDir
	    call    DOS3CALL
	    jc	    GCDExit		; Skip if error
	    xor     ax,ax		; Return FALSE if no error
GCDExit:
	    pop     ds			; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  SetCurrentDirectory() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc SetCurrentDirectory, <FAR, PUBLIC>, <DS, DI>

ParmD lpDirName

cBegin
	    lds     di,lpDirName	; DS:DI = lpDirName

	    ; Is there a drive designator?
ifdef	DBCS
	    mov     al, byte ptr [di]	; fetch a first byte of path
	    xor     ah,ah
	    cCall   IsDBCSLeadByte, <ax>
	    test    ax,ax		; DBCS lead byte?
	    jnz     SCDNoDrive		; jump if so
endif
	    cmp     byte ptr [di+1],':'
	    jne     SCDNoDrive		; Nope, continue
	    mov     al,byte ptr [di]	; Yup, change to that drive
	    sub     ah,ah
	    and     al, 0DFH	 ;Make drive letter upper case
	    sub     al,'A'
	    push    ax
	    call    SetCurrentDrive

            mov     al,byte ptr [di+2]  ; string just a drive letter and colon?
	    cbw
	    or	    ax,ax
            jz      SCDExit             ; Yup, just set the current drive and done
SCDNoDrive:
	    mov     dx,di
	    mov     ah,ChangeCurrentDir
	    call    DOS3CALL
	    jc	    SCDExit		; Skip on error
	    xor     ax,ax		; Return FALSE if successful
SCDExit:
cEnd


if 0
;*--------------------------------------------------------------------------*
;*									    *
;*  IsRemovableDrive() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsRemovableDrive, <FAR, PUBLIC>

ParmW wDrive

cBegin
	    mov     ax,4408h	; IOCTL: Check If Block Device Is Removable
	    mov     bx,wDrive
	    inc     bx
	    call    DOS3CALL
	    and     ax,1	; Only test bit 0
	    xor     ax,1	; Flip so 1 == Removable
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  IsRemoteDrive() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsRemoteDrive, <FAR, PUBLIC>

ParmW wDrive

cBegin
	    mov     ax,4409h	; IOCTL: Check If Block Device Is Remote
	    mov     bx,wDrive
	    inc     bx
	    call    DOS3CALL
	    xor     ax,ax
	    and     dx,0001000000000000b    ; Test bit 12
	    jz	    IRDRet
	    mov     ax,1
IRDRet:
cEnd
endif

;*--------------------------------------------------------------------------*
;*									    *
;*  DosDelete() -							    *
;*									    *
;*--------------------------------------------------------------------------*

%out assuming SS==DS

cProc DosDelete, <FAR, PUBLIC>

ParmD lpSource

localV	szOEM, 128

cBegin

	    RegPtr  lpszOEM,ss,bx   ; convert path to OEM chars
	    lea     bx, szOEM
	    cCall   AnsiToOem, <lpSource, lpszOEM>

	    lea     dx, szOEM
	    mov     ah,DeleteFile   ;
	    call    DOS3CALL
	    jc	    DDExit
	    xor     ax,ax	    ; Return 0 if successful
DDExit:
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  DosRename() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc DosRename, <FAR, PUBLIC>, <DI>

ParmD lpSource
ParmD lpDest

localV	szOEM1, 128
localV	szOEM2, 128

cBegin
	    RegPtr  lpszOEM1, ss, bx
	    lea     bx, szOEM1
	    cCall   AnsiToOem, <lpSource, lpszOEM1>

	    RegPtr  lpszOEM2, ss, bx
	    lea     bx, szOEM2
	    cCall   AnsiToOem, <lpDest, lpszOEM2>

	    lea     dx, szOEM1
	    lea     di, szOEM2
	    push    ss
	    pop     es
	    mov     ah,RenameFile
	    call    DOS3CALL
	    jc	    DRExit
	    xor     ax,ax	    ; Return 0 if successful
DRExit:
cEnd

;   lmemmove() -
;
;   Shamelessly heisted from the C5.1 runtime library, and modified to
;   work in mixed model Windows programs!
;
;***
;memcpy.asm - contains memcpy and memmove routines
;
;	Copyright (c) 1986-1988, Microsoft Corporation.  All right reserved.
;
;Purpose:
;	memmove() copies a source memory buffer to a destination memory buffer.
;	This routine recognize overlapping buffers to avoid propogation.
;
;   Algorithm:
;
;	void * memmove(void * dst, void * src, size_t count)
;	{
;		void * ret = dst;
;
;		if (dst <= src || dst >= (src + count)) {
;			/*
;			 * Non-Overlapping Buffers
;			 * copy from lower addresses to higher addresses
;			 */
;			while (count--)
;				*dst++ = *src++;
;			}
;		else {
;			/*
;			 * Overlapping Buffers
;			 * copy from higher addresses to lower addresses
;			 */
;			dst += count - 1;
;			src += count - 1;
;
;			while (count--)
;				*dst-- = *src--;
;			}
;
;		return(ret);
;	}
;
;
;Entry:
;	void *dst = pointer to destination buffer
;	const void *src = pointer to source buffer
;	size_t count = number of bytes to copy
;
;Exit:
;	Returns a pointer to the destination buffer in DX:AX
;
;Uses:
;	CX,DX,ES
;
;Exceptions:
;*******************************************************************************

cProc	lmemmove,<FAR,PUBLIC>,<si,di>

	parmD	dst		; destination pointer
	parmD	src		; source pointer
	parmW	count		; number of bytes to copy

cBegin
	push	ds		; Preserve DS
	lds	si,src		; DS:SI = src
	les	di,dst		; ES:DI = dst

	mov	ax,di		; save dst in AX for return value
	mov	cx,count	; cx = number of bytes to move
	jcxz	done		; if cx = 0 Then nothing to copy

;
; Check for overlapping buffers:
;	If segments are different, assume no overlap
;		Do normal (Upwards) Copy
;	Else If (dst <= src) Or (dst >= src + Count) Then
;		Do normal (Upwards) Copy
;	Else
;		Do Downwards Copy to avoid propogation
;
	mov	ax,es		; compare the segments
	cmp	ax,word ptr (src+2)
	jne	CopyUp
	cmp	di,si		; src <= dst ?
	jbe	CopyUp

	mov	ax,si
	add	ax,cx
	cmp	di,ax		; dst >= (src + count) ?
	jae	CopyUp
;
; Copy Down to avoid propogation in overlapping buffers
;
	mov	ax,di		; AX = return value (offset part)

	add	si,cx
	add	di,cx
	dec	si		; DS:SI = src + count - 1
	dec	di		; ES:DI = dst + count - 1
	std			; Set Direction Flag = Down
	rep	movsb
	cld			; Set Direction Flag = Up
	jmp	short done

CopyUp:
	mov	ax,di		; AX = return value (offset part)
;
; There are 4 situations as far as word alignment of "src" and "dst":
;	1. src and dst are both even	(best case)
;	2. src is even and dst is odd
;	3. src is odd and dst is even
;	4. src and dst are both odd	(worst case)
;
; Case #4 is much faster if a single byte is copied before the
; REP MOVSW instruction.  Cases #2 and #3 are effectively unaffected
; by such an operation.  To maximum the speed of this operation,
; only DST is checked for alignment.  For cases #2 and #4, the first
; byte will be copied before the REP MOVSW.
;
	test	al,1		; fast check for dst being odd address
	jz	move

	movsb			; move a byte to improve alignment
	dec	cx
;
; Now the bulk of the copy is done using REP MOVSW.  This is much
; faster than a REP MOVSB if the src and dst addresses are both
; word aligned and the processor has a 16-bit bus.  Depending on
; the initial alignment and the size of the region moved, there
; may be an extra byte left over to be moved.  This is handled
; by the REP MOVSB, which moves either 0 or 1 bytes.
;
move:
	shr	cx,1		; Shift CX for count of words
	rep	movsw		; CF set if one byte left over
	adc	cx,cx		; CX = 1 or 0, depending on Carry Flag
	rep	movsb		; possible final byte
;
; Return the "dst" address in AX/DX:AX
;
done:
	pop	ds		;restore ds
	mov	dx,es		;segment part of dest address

cEnd

sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\wowexec.c ===
/****************************** Module Header ******************************\
* Module Name: wowexec.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* WOWEXEC - 16 Bit Server Task - Does Exec Calls on Behalf of 32 bit CreateProcess
*
*
* History:
* 05-21-91 MattFe       Ported to Windows
* mar-20-92 MattFe      Added Error Message Boxes (from win 3.1 progman)
* apr-1-92 mattfe       added commandline exec and switch to path (from win 3.1 progman)
* jun-1-92 mattfe       changed wowgetnextvdmcommand
* 12-Nov-93 DaveHart    Multiple WOW support and remove captive
*                       GetNextVDMCommand thread from WOW32.
* 16-Nov-93 DaveHart    Reduce data segment size.
\***************************************************************************/
#include "wowexec.h"
#include "wowinfo.h"
#include "shellapi.h"
#ifndef PULONG
#define PULONG
#endif
#include "vint.h"
#include "dde.h"


/*
 * External Prototypes
 */
extern WORD FAR PASCAL WOWQueryDebug( void );
extern WORD FAR PASCAL WowWaitForMsgAndEvent( HWND);
extern void FAR PASCAL WowMsgBox(LPSTR szMsg, LPSTR szTitle, DWORD dwOptionalStyle);
extern DWORD FAR PASCAL WowPartyByNumber(DWORD dw, LPSTR psz);
extern DWORD FAR PASCAL WowKillTask(WORD htask);
extern void FAR PASCAL WowShutdownTimer(WORD fEnable);
HWND FaxInit(HINSTANCE hInst);

/*
 * Global Variables
 */
HANDLE hAppInstance;
HWND ghwndMain = NULL;
HWND ghwndEdit = NULL;
char    szOOMExitTitle[32+1];
char    szOOMExitMsg[64+1];
char    szAppTitleBuffer[32];
LPSTR   lpszAppTitle = szAppTitleBuffer;
char    szWindowsDirectory[MAXITEMPATHLEN+1];
char    szOriginalDirectory[MAXITEMPATHLEN+1];
BOOL    gfSharedWOW = FALSE;
BOOL    gfMeow = FALSE;
WORD    gwFirstCmdShow;



/*
 * Forward declarations.
 */
BOOL InitializeApp(LPSTR lpszCommandLine);
LONG FAR PASCAL WndProc(HWND hwnd, WORD message, WORD wParam, LONG lParam);
WORD NEAR PASCAL ExecProgram(PWOWINFO pWowInfo);
BOOL NEAR PASCAL ExecApplication(PWOWINFO pWowInfo);
void NEAR PASCAL MyMessageBox(WORD idTitle, WORD idMessage, LPSTR psz);
PSTR FAR PASCAL GetFilenameFromPath( PSTR szPath );
void NEAR PASCAL GetPathInfo ( PSTR szPath, PSTR *pszFileName, PSTR *pszExt, WORD *pich, BOOL *pfUnc);
BOOL NEAR PASCAL StartRequestedApp(VOID);
#ifdef DEBUG
BOOL FAR PASCAL PartyDialogProc(HWND hDlg, WORD msg, WORD wParam, LONG lParam);
#endif

#define AnsiNext(x) ((x)+1)

typedef struct PARAMETERBLOCK {
    WORD    wEnvSeg;
    LPSTR   lpCmdLine;
    LPVOID  lpCmdShow;
    DWORD   dwReserved;
} PARAMETERBLOCK, *PPARAMETERBLOCK;

typedef struct CMDSHOW {
    WORD    two;
    WORD    nCmdShow;
} CMDSHOW, *PCMDSHOW;

#define CCHMAX 256+13  // MAX_PATH plus 8.3 plus NULL

#define ERROR_ERROR         0
#define ERROR_FILENOTFOUND  2
#define ERROR_PATHNOTFOUND  3
#define ERROR_MANYOPEN      4
#define ERROR_DYNLINKSHARE  5
#define ERROR_LIBTASKDATA   6
#define ERROR_MEMORY        8
#define ERROR_VERSION       10
#define ERROR_BADEXE        11
#define ERROR_OTHEREXE      12
#define ERROR_DOS4EXE       13
#define ERROR_UNKNOWNEXE    14
#define ERROR_RMEXE         15
#define ERROR_MULTDATAINST  16
#define ERROR_PMODEONLY     18
#define ERROR_COMPRESSED    19
#define ERROR_DYNLINKBAD    20
#define ERROR_WIN32         21


/* FindPrevInstanceProc -
 * A little enumproc to find any window (EnumWindows) which has a
 * matching EXE file path.  The desired match EXE pathname is pointed to
 * by the lParam.  The found window's handle is stored in the
 * first word of this buffer.
 */

BOOL CALLBACK FindPrevInstanceProc(HWND hWnd, LPSTR lpszParam)
{
    char szT[260];
    HANDLE hInstance;

    // Filter out invisible and disabled windows
    //

    if (!IsWindowEnabled(hWnd) || !IsWindowVisible(hWnd))
        return TRUE;

    hInstance = GetWindowWord(hWnd, GWW_HINSTANCE);
    GetModuleFileName(hInstance, szT, sizeof (szT)-1);

    // Make sure that the hWnd belongs to the current VDM process
    //
    // GetWindowTask returns the wowexec htask16 if the window belongs
    // to a different process - thus we filter out windows in
    // 'separate VDM' processes.
    //                                                     - nanduri

    if (lstrcmpi(szT, lpszParam) == 0 &&
        GetWindowTask(hWnd) != GetWindowTask(ghwndMain)) {
        *(LPHANDLE)lpszParam = hWnd;
        return FALSE;
    }
    else {
        return TRUE;
    }
}

HWND near pascal FindPopupFromExe(LPSTR lpExe)
{
    HWND hwnd = (HWND)0;
    BOOL b;

    b = EnumWindows(FindPrevInstanceProc, (LONG)(LPSTR)lpExe);
    if (!b && (hwnd = *(LPHANDLE)(LPSTR)lpExe))  {
        // Find a "main" window that is the ancestor of a given window
        //

        HWND hwndT;

        // First go up the parent chain to find the popup window.  Then go
        // up the owner chain to find the main window
        //

        while (hwndT = GetParent(hwnd))
             hwnd = hwndT;

        while (hwndT = GetWindow(hwnd, GW_OWNER))
             hwnd = hwndT;
    }

    return hwnd;
}

WORD ActivatePrevInstance(LPSTR lpszPath)
{
    HWND hwnd;
    HINSTANCE ret = IDS_MULTIPLEDSMSG;

    if (hwnd = FindPopupFromExe(lpszPath)) {
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd,SW_SHOWNORMAL);
        }
        else {
            HWND hwndT = GetLastActivePopup(hwnd);
            BringWindowToTop(hwnd);
            if (hwndT && hwnd != hwndT)
                BringWindowToTop(hwndT);
        }
        ret = 0;
    }

    return (ret);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ExecProgram() -                                                         */
/*                                                                          */
/* Taken from Win 3.1 Progman -maf                                          */
/*--------------------------------------------------------------------------*/

/* Returns 0 for success.  Otherwise returns a IDS_ string code. */

WORD NEAR PASCAL ExecProgram(PWOWINFO pWowInfo)
{
  WORD    ret;
  PARAMETERBLOCK ParmBlock;
  CMDSHOW CmdShow;
  char  CmdLine[CCHMAX];

  ret = 0;

  // Don't mess with the mouse state; unless we're on a mouseless system.
  if (!GetSystemMetrics(SM_MOUSEPRESENT))
      ShowCursor(TRUE);

  //
  // prepare the dos style cmd line (counted pascal string)
  // pWowInfo->lpCmdLine contains the command tail (excluding argv[0])
  //
  CmdLine[0] = lstrlen(pWowInfo->lpCmdLine) - 2;
  lstrcpy( &CmdLine[1], pWowInfo->lpCmdLine);

  // We have a WOWINFO structure, then use it to pass the correct environment

  ParmBlock.wEnvSeg = HIWORD(pWowInfo->lpEnv);
  ParmBlock.lpCmdLine = CmdLine;
  ParmBlock.lpCmdShow = &CmdShow;
  CmdShow.two = 2;
  CmdShow.nCmdShow = pWowInfo->wShowWindow;

  ParmBlock.dwReserved = NULL;

  ret = LoadModule(pWowInfo->lpAppName,(LPVOID)&ParmBlock) ;

  switch (ret)
    {
      case ERROR_ERROR:
      case ERROR_MEMORY:
          ret = IDS_NOMEMORYMSG;
          break;

      case ERROR_FILENOTFOUND:
          ret = IDS_FILENOTFOUNDMSG;
          break;

      case ERROR_PATHNOTFOUND:
          ret = IDS_BADPATHMSG;
          break;

      case ERROR_MANYOPEN:
          ret = IDS_MANYOPENFILESMSG;
          break;

      case ERROR_DYNLINKSHARE:
          ret = IDS_ACCESSDENIED;
          break;

      case ERROR_VERSION:
          ret = IDS_NEWWINDOWSMSG;
          break;

      case ERROR_RMEXE:
          /* KERNEL has already put up a messagebox for this one. */
          ret = 0;
          break;

      case ERROR_MULTDATAINST:
          ret = ActivatePrevInstance(pWowInfo->lpAppName);
          break;

      case ERROR_COMPRESSED:
          ret = IDS_COMPRESSEDEXE;
          break;

      case ERROR_DYNLINKBAD:
          ret = IDS_INVALIDDLL;
          break;

      case SE_ERR_SHARE:
          ret = IDS_SHAREERROR;
          break;

      case ERROR_WIN32:
          ret = IDS_CANTLOADWIN32DLL;
          break;

      //
      // We shouldn't get any of the following errors,
      // so the strings have been removed from the resource
      // file.  That's why there's the OutputDebugString
      // on checked builds only.
      //

#ifdef DEBUG
      case ERROR_OTHEREXE:
      case ERROR_PMODEONLY:
      case SE_ERR_ASSOCINCOMPLETE:
      case SE_ERR_DDETIMEOUT:
      case SE_ERR_DDEFAIL:
      case SE_ERR_DDEBUSY:
      case SE_ERR_NOASSOC:
          {
              char szTmp[64];
              wsprintf(szTmp, "WOWEXEC: Unexpected error %d executing app, fix that code!\n", (int)ret);
              OutputDebugString(szTmp);
          }
          //
          // fall through to default case, so the execution
          // is the same as on the free build.
          //
#endif

      default:
          if (ret < 32)
              goto EPExit;
          ret = 0;
    }

EPExit:

  if (!GetSystemMetrics(SM_MOUSEPRESENT)) {
      /*
       * We want to turn the mouse off here on mouseless systems, but
       * the mouse will already have been turned off by USER if the
       * app has GP'd so make sure everything's kosher.
       */
      if (ShowCursor(FALSE) != -1)
          ShowCursor(TRUE);
  }

  return(ret);
}

/***************************************************************************\
* ExecApplication
*
* Code Taken From Win 3.1 ExecItem()
*
\***************************************************************************/

#define TDB_PDB_OFFSET  0x60
#define PDB_ENV_OFFSET  0x2C

BOOL NEAR PASCAL ExecApplication(PWOWINFO pWowInfo)
{

    WORD    ret;
    LPSTR   szEnv;
    LPSTR   szEnd;
    BYTE    bDrive;
    WORD    wSegEnvSave;
    HANDLE  hTask;
    LPSTR   lpTask;
    HANDLE  hPDB;
    LPSTR   lpPDB;
    HANDLE  hNewEnv;

    int     nLength;
    int     nNewEnvLength;
    LPSTR   lpstrEnv;
    LPSTR   lpstr;
    LPSTR   lpOriginalEnv;
    BOOL    bBlanks;
    LPSTR   szEnvTmp;


    if (!pWowInfo) {
        return FALSE;
        }

    //
    // Seup the environment from WOWINFO record from getvdmcommand
    //


    // Figure out who we are (so we can edit our PDB/PSP)

    hTask = GetCurrentTask();
    lpTask = GlobalLock( hTask );
    if ( lpTask == NULL ) {
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }

    hPDB = *((LPWORD)(lpTask + TDB_PDB_OFFSET));
    lpPDB = GlobalLock( hPDB );

    // Save our environment block
    wSegEnvSave = *((LPWORD)(lpPDB + PDB_ENV_OFFSET));


    // Now determine the length of the original env

    lpOriginalEnv = (LPSTR)MAKELONG(0,wSegEnvSave);

    do {
        nLength = lstrlen(lpOriginalEnv);
        lpOriginalEnv += nLength + 1;
    } while ( nLength != 0 );

    lpOriginalEnv += 2;         // Skip over magic word, see comment below

    nNewEnvLength = 4 + lstrlen(lpOriginalEnv); // See magic comments below!

    // WOW Apps cannot deal with an invalid TEMP=c:\bugusdir directory
    // Usually on Win 3.1 the TEMP= is checked in ldboot.asm check_temp
    // routine.   However on NT since we get a new environment with each
    // WOW app it means that we have to check it here.   If it is not
    // valid then it is edited in the environment.
    //      - mattfe june 11 93

    szEnv = pWowInfo->lpEnv;
    szEnd = szEnv + pWowInfo->EnvSize;
    szEnd--;

    while ( szEnv < szEnd ) {

       nLength = lstrlen(szEnv) + 1;

       if (  (*szEnv == 'T') &&
         (*(szEnv+1) == 'E') &&
         (*(szEnv+2) == 'M') &&
         (*(szEnv+3) == 'P') &&
         (*(szEnv+4) == '=') )  {

            // Try to set the current directory to the TEMP= dir
            // If it fails then nuke the TEMP= part of the environment
            // in the same way check_TEMP does in ldboot.asm
            // We also scan for blanks, just like check_TEMP

            bBlanks = FALSE;
            szEnvTmp = szEnv+5;
            while (*szEnvTmp != 0) {
                if (*szEnvTmp == ' ') {
                    bBlanks = TRUE;
                    break;
                }
                szEnvTmp++;
            }

            if (bBlanks || (SetCurrentDirectory(szEnv+5) )) {
                while (*szEnv != 0) {
                    *szEnv = 'x';
                    szEnv++;
                }
            }
       break;
       }
       szEnv += nLength;
    }

    // WOW Apps only have a Single Current Directory
    // Find =d:=D:\path where d is the active drive letter
    // Note that the drive info doesn have to be at the start
    // of the environment.

    bDrive = pWowInfo->CurDrive + 'A';
    szEnv = pWowInfo->lpEnv;
    szEnd = szEnv + pWowInfo->EnvSize;
    szEnd--;

    while ( szEnv < szEnd ) {

       nLength = lstrlen(szEnv) + 1;
       if ( *szEnv == '=' ) {
            if ( (bDrive == (*(szEnv+1) & 0xdf)) &&
                 (*(szEnv+2) == ':') && (*(szEnv+3) == '=') ) {
                SetCurrentDirectory(szEnv+4);
            }
       } else {
            nNewEnvLength += nLength;
       }
       szEnv += nLength;
    }

    // Now allocate and make a personal copy of the Env

    hNewEnv = GlobalAlloc( GMEM_MOVEABLE, (DWORD)nNewEnvLength );
    if ( hNewEnv == NULL ) {
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }
    lpstrEnv = GlobalLock( hNewEnv );
    if ( lpstrEnv == NULL ) {
        GlobalFree( hNewEnv );
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }

    // Copy only the non-current directory env variables

    szEnv = pWowInfo->lpEnv;
    lpstr = lpstrEnv;

    while ( szEnv < szEnd ) {
        nLength = lstrlen(szEnv) + 1;

        // Copy everything except the drive letters

        if ( *szEnv != '=' ) {
            lstrcpy( lpstr, szEnv );
            lpstr += nLength;
        }
        szEnv += nLength;
    }
    *lpstr++ = '\0';          // Extra '\0' on the end

    // Magic environment goop!
    //
    // Windows only supports the passing of environment information
    // using the LoadModule API.  The WinExec API just causes
    // the application to inherit the current DOS PDB's environment.
    //
    // Also, the environment block has a little gotcha at the end.  Just
    // after the double-nuls there is a magic WORD value 0x0001 (DOS 3.0
    // and later).  After the value is a nul terminated string indicating
    // the applications executable file name (including PATH).
    //
    // We copy the value from WOWEXEC's original environment because
    // that is what WinExec appears to do.
    //
    // -BobDay

    *lpstr++ = '\1';
    *lpstr++ = '\0';        // Magic 0x0001 from DOS

    lstrcpy( lpstr, lpOriginalEnv );    // More Magic (see comment above)

    // Temporarily update our environment block

    *((LPWORD)(lpPDB + PDB_ENV_OFFSET)) = (WORD)hNewEnv | 1;

    pWowInfo->lpEnv = lpstrEnv;


    //
    // Set our current drive & directory as requested.
    //

    SetCurrentDirectory(pWowInfo->lpCurDir);

    ret = ExecProgram(pWowInfo);

    // Restore our environment block

    *((LPWORD)(lpPDB + PDB_ENV_OFFSET)) = wSegEnvSave;

    GlobalUnlock( hPDB );
    GlobalUnlock( hTask );
    GlobalUnlock( hNewEnv );
    GlobalFree( hNewEnv );


punt:

    // Change back to the Windows Directory
    // So that if we are execing from a NET Drive its
    // Not kept Active

    SetCurrentDirectory(szWindowsDirectory);

    //  Always call this when we are done try to start an app.
    //  It will do nothing if we were successful in starting an
    //  app, otherwise if we were unsucessful it will signal that
    //  the app has completed.
    WowFailedExec();

    // Check for errors.
    if (ret) {
        MyMessageBox(IDS_EXECERRTITLE, ret, pWowInfo->lpAppName);

        if ( ! gfSharedWOW) {

            //
            // We have just failed to exec the only app we are going to
            // try to exec in this separate WOW VDM.  We need to end WOW
            // here explicitly, otherwise we'll hang around forever because
            // the normal path is for kernel to exit the VDM when a task
            // exit causes the number of tasks to transition from 2 to 1 --
            // in this case the number of tasks never exceeds 1.
            //

            ExitKernelThunk(0);

        }
    }

    return(ret);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyMessageBox() -                                                        */
/*  Taken From Win 3.1 Progman - maf                                        */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL MyMessageBox(WORD idTitle, WORD idMessage, LPSTR psz)
{
  char szTitle[MAXTITLELEN+1];
  char szMessage[MAXMESSAGELEN+1];
  char szTempField[MAXMESSAGELEN+1];


  if (!LoadString(hAppInstance, idTitle, szTitle, sizeof(szTitle)))
      goto MessageBoxOOM;

  if (idMessage > IDS_LAST)
    {
      if (!LoadString(hAppInstance, IDS_UNKNOWNMSG, szTempField, sizeof(szTempField)))
          goto MessageBoxOOM;
      wsprintf(szMessage, szTempField, idMessage);
    }
  else
    {
      if (!LoadString(hAppInstance, idMessage, szTempField, sizeof(szTempField)))
          goto MessageBoxOOM;

      if (psz)
          wsprintf(szMessage, szTempField, (LPSTR)psz);
      else
          lstrcpy(szMessage, szTempField);
    }

  WowMsgBox(szMessage, szTitle, MB_ICONEXCLAMATION);
  return;


MessageBoxOOM:
  WowMsgBox(szOOMExitMsg, szOOMExitTitle, MB_ICONHAND);

  return ;
}



/***************************************************************************\
* main
*
*
* History:
* 04-13-91 ScottLu      Created - from 32 bit exec app
* 21-mar-92 mattfe      significant alterations for WOW
\***************************************************************************/

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance, LPSTR lpszCmdLine, int iCmd)

{
    int i;
    MSG msg;
    LPSTR pch,pch1;
    WORD    ret;
    WOWINFO wowinfo;
    char aszWOWDEB[CCHMAX];
    LPSTR pchWOWDEB;
    HANDLE hMMDriver;


    char        szBuffer[150];
    BOOL        bFinished;
    int         iStart;
    int         iEnd;


    hAppInstance = hInstance ;

    // Only Want One WOWExec
    if (hPrevInstance != NULL) {
        return(FALSE);
    }

    if (!InitializeApp(lpszCmdLine)) {
        OutputDebugString("WOWEXEC: InitializeApp failure!\n");
        return 0;
    }

/*
 * Look for a drivers= line in the [boot] section of SYSTEM.INI
 * If present it is the 16 bit MultiMedia interface, so load it
 */

#ifdef OLD_MMSYSTEM_LOAD
    if (GetPrivateProfileString((LPSTR)"boot", (LPSTR)"drivers",(LPSTR)"", aszMMDriver, sizeof(aszMMDriver), (LPSTR)"SYSTEM.INI")) {
/*
 * We have now discovered an app that rewrites the "drivers" entry with
 * multiple drivers - so the existing load method fails. As a temporary fix
 * while we decide what the "proper" fix is I will always load MMSYSTEM and
 * ONLY MMSYSTEM.
 *
 *       aszMMDriver[sizeof(aszMMDriver)-1] = '\0';
 *       hMMDriver = LoadLibrary((LPSTR)aszMMDriver);
 * #ifdef DEBUG
 *       if (hMMDriver < 32) {
 *           OutputDebugString("WOWEXEC: Load of MultiMedia driver failed\n");
 *       }
 * #endif
 */
        LoadLibrary("MMSYSTEM.DLL");
    }
#else
    /* Load DDL's from DRIVERS section in system.ini
     */
    GetPrivateProfileString( (LPSTR)"boot",      /* [Boot] section */
                            (LPSTR)"drivers",   /* Drivers= */
                            (LPSTR)"",          /* Default if no match */
                            szBuffer,    /* Return buffer */
                            sizeof(szBuffer),
                            (LPSTR)"system.ini" );

    if (!*szBuffer) {
        goto Done;
    }

    bFinished = FALSE;
    iStart    = 0;

    while (!bFinished) {
        iEnd = iStart;

        while (szBuffer[iEnd] && (szBuffer[iEnd] != ' ') &&
               (szBuffer[iEnd] != ',')) {
            iEnd++;
        }

        if (szBuffer[iEnd] == NULL) {
            bFinished = TRUE;
        }
        else {
            szBuffer[iEnd] = NULL;
        }

        /* Load and enable the driver.
         */
        OpenDriver( &(szBuffer[iStart]), NULL, NULL );
        iStart = iEnd + 1;
    }

Done:

#endif

/*
 * Look for a debug= line in the [boot] section of SYSTEM.INI
 * If present it is the 16 bit MultiMedia interface, so load it
 */

    if ( !gfMeow && (WOWQueryDebug() & 0x0001)!=0 ) {
        pchWOWDEB = "WOWDEB.EXE";
    } else {
        pchWOWDEB = "";
    }

    GetPrivateProfileString((LPSTR)"boot", (LPSTR)"debug",pchWOWDEB, aszWOWDEB, sizeof(aszWOWDEB), (LPSTR)"SYSTEM.INI");
    aszWOWDEB[sizeof(aszWOWDEB)-1] = '\0';

    if ( lstrlen(pchWOWDEB) != 0 ) {
        WinExec((LPSTR)aszWOWDEB,SW_SHOW);
    }

#if 0
/*  Preload winspool.exe.   Apps will keep loading and freeing it
 *  which is slow.   We might as well load it now so the reference
 *  count is 1 so it will never be loaded or freed
 */
    //
    // Disabled load of winspool.exe to save 8k.  Size vs. speed,
    // which one do we care about?  Right now, size!
    //
    LoadLibrary("WINSPOOL.EXE");
#endif

    // Always load SHELL.DLL, FileMaker Pro and Lotus Install require it.

    LoadLibrary("SHELL.DLL");

    //
    // Start any apps pending in basesrv queue
    //

    while (StartRequestedApp() && gfSharedWOW) {
        /* null stmt */ ;
    }


    while (1)  {
        if (!WowWaitForMsgAndEvent(ghwndMain) &&
            PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) &&
            msg.message != WM_WOWEXECHEARTBEAT )
           {
            if (msg.message != WM_QUIT) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return 1;
}


/***************************************************************************\
* InitializeApp
*
* History:
* 04-13-91 ScottLu      Created.
\***************************************************************************/

BOOL InitializeApp(LPSTR lpszCommandLine)
{
    WNDCLASS wc;
    int cyExecStart, cxExecStart;
    USHORT TitleLen, cbCopy;
    HWND  hwndFax;
    int   lResult;


    // Remove Real Mode Segment Address

    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hAppInstance;
    wc.hIcon            = LoadIcon(hAppInstance, MAKEINTRESOURCE(ID_WOWEXEC_ICON));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.lpszClassName    = "WOWExecClass";
#ifdef DEBUG
    wc.lpszMenuName     = "MainMenu";
#else
    wc.lpszMenuName     = NULL;
#endif

    if (!RegisterClass(&wc)) {
        OutputDebugString("WOWEXEC: RegisterClass failed\n");
        return FALSE;
    }

    /* Load these strings now.  If we need them later, we won't be able to load
     * them at that time.
     */
    LoadString(hAppInstance, IDS_OOMEXITTITLE, szOOMExitTitle, sizeof(szOOMExitTitle));
    LoadString(hAppInstance, IDS_OOMEXITMSG, szOOMExitMsg, sizeof(szOOMExitMsg));
    LoadString(hAppInstance, IDS_APPTITLE, szAppTitleBuffer, sizeof(szAppTitleBuffer));

    ghwndMain = CreateWindow("WOWExecClass", lpszAppTitle,
            WS_OVERLAPPED | WS_CAPTION | WS_BORDER | WS_THICKFRAME |
            WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CLIPCHILDREN |
            WS_SYSMENU,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, hAppInstance, NULL);

    if (ghwndMain == NULL ) {
#ifdef DEBUG
        OutputDebugString("WOWEXEC: ghwndMain Null\n");
#endif
        return FALSE;
    }

    hwndFax = FaxInit(hAppInstance);

    //
    // Give our window handle to BaseSrv, which will post WM_WOWEXECSTARTAPP
    // messages when we have commands to pick up.  The return value tells
    // us if we are the shared WOW VDM or not (a seperate WOW VDM).
    // We also pick up the ShowWindow parameter (SW_SHOW, SW_MINIMIZED, etc)
    // for the first WOW app here.  Subsequent ones we get from BaseSrv.
    //

         //
         // gwFirstCmdShow is no longer used, and is available.
         //

    lResult = WOWRegisterShellWindowHandle(ghwndMain,
                                               &gwFirstCmdShow,
                                               hwndFax
                                               );

    if (lResult < 0) {
       gfMeow=TRUE;
    } else if (lResult > 0) {
       gfSharedWOW=TRUE;
    }



    //
    // If this isn't the shared WOW, tell the kernel to exit when the
    // last app (except WowExec) exits.
    //

    if (!gfSharedWOW) {
        WowSetExitOnLastApp(TRUE);
    }

      /* Remember the original directory. */
    GetCurrentDirectory(NULL, szOriginalDirectory);
    GetWindowsDirectory(szWindowsDirectory, MAXITEMPATHLEN+1);

#ifdef DEBUG

    ShowWindow(ghwndMain, SW_MINIMIZE);

    //
    // If this is the shared WOW, change the app title string to
    // reflect this and change the window title.
    //

    if (gfSharedWOW) {

        LoadString(hAppInstance, IDS_SHAREDAPPTITLE, szAppTitleBuffer, sizeof(szAppTitleBuffer));

    }

    SetWindowText(ghwndMain, lpszAppTitle);
    UpdateWindow(ghwndMain);

#endif

    return TRUE;
}


/***************************************************************************\
* WndProc
*
* History:
* 04-07-91 DarrinM      Created.
\***************************************************************************/

LONG FAR PASCAL WndProc(
    HWND hwnd,
    WORD message,
    WORD wParam,
    LONG lParam)
{
    char chbuf[50];
    HICON hIcon;

    switch (message) {
    case WM_CREATE:
        break;

    case WM_DESTROY:
        // ignore since wowexec must stay around
        return 0;

#ifdef DEBUG
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case MM_ABOUT:
                LoadString(hAppInstance, errTitle, (LPSTR)chbuf, sizeof(chbuf));
                hIcon = LoadIcon(hAppInstance, MAKEINTRESOURCE(ID_WOWEXEC_ICON));
                ShellAbout(ghwndMain, (LPSTR)chbuf, (LPSTR)lpszAppTitle, hIcon);
            break;

            case MM_BREAK:
                _asm int 3
            break;

            case MM_FAULT:
                _asm mov cs:0,ax
            break;

            case MM_EXIT:
                ExitKernelThunk(0);
            break;

            case MM_WATSON:
                WinExec("drwatson", SW_MINIMIZE );
            break;

            case MM_PARTY:
            {
                FARPROC lpPartyDialogProc;

                lpPartyDialogProc = MakeProcInstance(PartyDialogProc, hAppInstance);

                DialogBox(hAppInstance, MAKEINTRESOURCE(ID_PARTY_DIALOG),
                          hwnd, lpPartyDialogProc);

                FreeProcInstance(lpPartyDialogProc);
            }
            break;

            case MM_GENTHUNK:
            {
                DWORD FAR PASCAL CallProc32W(DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD
                                             );

#define BIT(bitpos)  ((DWORD)1 << bitpos)

                DWORD hmodKernel32, hmodUser32, hmodWow32;
                DWORD pfn32;
                DWORD dw16, dw32;
                DWORD p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                      p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,
                      p31, p32;
                char szBuf16[1024], szBuf32[1024];
                char *pszErr;

                hmodKernel32 = LoadLibraryEx32W("kernel32", 0, 0);
                hmodUser32 = LoadLibraryEx32W("user32", 0, 0);
                hmodWow32 = LoadLibraryEx32W("wow32", 0, 0);


                //
                // Simple printf test.
                //

                pfn32 = GetProcAddress32W(hmodUser32, "wsprintfA");

                dw16 = wsprintf(szBuf16, "simple printf %ld", 12345678);

                dw32 = CallProc32W(   (DWORD)(LPSTR) szBuf32,
                                      (DWORD)(LPSTR) "simple printf %ld",
                                      12345678,
                                      0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      pfn32,
                                      BIT(30) | BIT(31),
                                      CPEX_DEST_CDECL | 32
                                      );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "simple printf comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "s1 success", "Genthunk Sanity Test", MB_OK);


                dw32 = CallProcEx32W( CPEX_DEST_CDECL | 3,
                                      BIT(0) | BIT(1),
                                      pfn32,
                                      (DWORD)(LPSTR) szBuf32,
                                      (DWORD)(LPSTR) "simple printf %ld",
                                      12345678 );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "simple printf comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "s2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Complex printf test.
                //

                // pfn32 still points to wsprintfA
                // pfn32 = GetProcAddress32W(hmodUser32, "wsprintfA");


               #if 0  // this blows out Win16 wsprintf!
                dw16 = wsprintf(szBuf16,
                                "complex printf "
                                 "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                 "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str"
                                );
               #else
                lstrcpy(szBuf16, "complex printf "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 );
                dw16 = lstrlen(szBuf16);
               #endif

                dw32 = CallProc32W(
                                (DWORD)(LPSTR) szBuf32,
                                (DWORD)(LPSTR) "complex printf "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                pfn32,
                                BIT(0) | BIT(3) | BIT(6) | BIT(9) | BIT(12) | BIT(15) |
                                  BIT(18) | BIT(21) | BIT(24) | BIT(27) | BIT(30) | BIT(31),
                                CPEX_DEST_CDECL | 32
                                );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "complex printf comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "c1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_CDECL | 32,
                                      BIT(0) | BIT(1) | BIT(4) | BIT(7) | BIT(10) | BIT(13) |
                                      BIT(16) | BIT(19) | BIT(22) | BIT(25) | BIT(28) | BIT(31),
                                      pfn32,
                                (DWORD)(LPSTR) szBuf32,
                                (DWORD)(LPSTR) "complex printf "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str"
                                );


                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "complex printf comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "c2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Simple WINAPI test (GetProcAddress of LoadModule)
                //

                pfn32 = GetProcAddress32W(hmodKernel32, "GetProcAddress");

                dw16 = GetProcAddress32W(hmodKernel32, "LoadModule");

                dw32 = CallProc32W(   hmodKernel32,
                                      (DWORD)(LPSTR) "LoadModule",
                                      0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      pfn32,
                                      BIT(30),
                                      CPEX_DEST_STDCALL | 32
                                      );

                if (dw16 != dw32) {
                    pszErr = "GetProcAddress comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "w1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_STDCALL | 2,
                                      BIT(1),
                                      pfn32,
                                      hmodKernel32,
                                      (DWORD)(LPSTR) "LoadModule" );

                wsprintf(szBuf16, "GPA via CP32Ex(LoadModule) == %lx\n", dw32);
                OutputDebugString(szBuf16);
                if (dw16 != dw32) {
                    pszErr = "GetProcAddress comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "w2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Complex WINAPI test WOWStdCall32ArgsTestTarget exists only on
                // checked WOW32.dll
                //

                pfn32 = GetProcAddress32W(hmodWow32, "WOWStdCall32ArgsTestTarget");

                if (!pfn32) {
                    MessageBox(hwnd,
                               "WOWStdCall32ArgsTestTarget not found, use checked wow32.dll for this test.",
                               "Genthunk Quicktest",
                               MB_OK
                               );
                    goto Done;
                }

                p1 = 1;
                p2 = 2;
                p3 = 3;
                p4 = 4;
                p5 = 5;
                p6 = 6;
                p7 = 7;
                p8 = 8;
                p9 = 9;
                p10 = 10;
                p11 = 11;
                p12 = 12;
                p13 = 13;
                p14 = 14;
                p15 = 15;
                p16 = 16;
                p17 = 17;
                p18 = 18;
                p19 = 19;
                p20 = 10;
                p21 = 21;
                p22 = 22;
                p23 = 23;
                p24 = 24;
                p25 = 25;
                p26 = 26;
                p27 = 27;
                p28 = 28;
                p29 = 29;
                p30 = 30;
                p31 = 31;
                p32 = 32;

                dw16 = ((((p1+p2+p3+p4+p5+p6+p7+p8+p9+p10) -
                          (p11+p12+p13+p14+p15+p16+p17+p18+p19+p20)) << p21) +
                        ((p22+p23+p24+p25+p26) - (p27+p28+p29+p30+p31+p32)));

                dw32 = CallProc32W(   p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                                      p21, p22,
                                      (DWORD)(LPDWORD) &p23,
                                                     p24, p25, p26, p27, p28, p29, p30,
                                      p31,
                                      (DWORD)(LPDWORD) &p32,
                                      pfn32,
                                      BIT(9) | BIT(0),
                                      CPEX_DEST_STDCALL | 32
                                      );

                if (dw16 != dw32) {
                    pszErr = "WOWStdCall32ArgsTestTarget comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "cw1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_STDCALL | 32,
                                      BIT(22) | BIT(31),
                                      pfn32,
                                      p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                                      p21, p22,
                                      (DWORD)(LPDWORD) &p23,
                                                     p24, p25, p26, p27, p28, p29, p30,
                                      p31,
                                      (DWORD)(LPDWORD) &p32
                                      );

                if (dw16 != dw32) {
                    pszErr = "WOWStdCall32ArgsTestTarget comparison failed (CallProcEx)";
                    goto ErrorMsg;

            ErrorMsg:
                    MessageBox(hwnd, pszErr, "Genthunk Sanity Test Failure", MB_OK);
                    goto Done;
                }

                wsprintf(szBuf16, "result of odd calc is %lx\n", dw32);
                OutputDebugString(szBuf16);

                MessageBox(hwnd, "Test successful!", "Genthunk Quicktest", MB_OK);

            Done:
                FreeLibrary32W(hmodKernel32);
                FreeLibrary32W(hmodUser32);
                FreeLibrary32W(hmodWow32);
            }
            break;

        }
        break;
#endif

    case WM_WOWEXECSTARTAPP:      // WM_USER+0

#ifdef DEBUG
        OutputDebugString("WOWEXEC - got WM_WOWEXECSTARTAPP\n");
#endif

        //
        // Either BaseSrv or Wow32 asked us to go looking for
        // commands to run.
        //

        if (!gfSharedWOW) {

            //
            // We shouldn't get this message unless we are the shared
            // WOW VDM!
            //

#ifdef DEBUG
            OutputDebugString("WOWEXEC - separate WOW VDM got WM_WOWEXECSTARTAPP!\n");
            _asm int 3;
#endif
            break;
        }

        //
        // Start requested apps until there are no more to start.
        // This handles the case where several Win16 apps are launched
        // in a row, before BaseSrv has the window handle for WowExec.
        //

        while (StartRequestedApp()) {
            /* Null stmt */ ;
        }

        break;

    case WM_WOWEXEC_START_TASK:
        {
            char sz[512];

            sz[ GlobalGetAtomName(wParam, sz, sizeof sz) ] = 0;
            GlobalDeleteAtom(wParam);
            WinExec(sz, (WORD)lParam);
        }

    case WM_WOWEXECHEARTBEAT:
        // Probably will never get here...
        break;

    case WM_WOWEXECSTARTTIMER:
        WowShutdownTimer(1);
        break;

    case WM_TIMER:
        if (wParam == 1) {  // timer ID

            KillTimer(ghwndMain, 1);

            //
            // The shutdown timer has expired, meaning it's time to kill this
            // shared WOW VDM.  First we need to let basesrv know not to queue
            // any more apps for us to start.
            //

            if (WOWRegisterShellWindowHandle(NULL,
                                             &gwFirstCmdShow,
                                             NULL
                                            )) {

                //
                // BaseSrv deregistered us successfully after confirming
                // there are no pending commands for us.
                //

                ExitKernelThunk(0);
            } else {

                //
                // There must be pending commands for us.  Might as well
                // start them.
                //

                PostMessage(ghwndMain, WM_WOWEXECSTARTAPP, 0, 0);
            }

        }

        break;

    case WM_TIMECHANGE:
        *((DWORD *)(((DWORD)40 << 16) | FIXED_NTVDMSTATE_REL40))
         |= VDM_TIMECHANGE;
        break;

    case WM_DDE_INITIATE:
        {
            // In win31, the Program Manager WindowProc calls peekmessage to filterout
            // otherwindowcreated and otherwindowdestroyed messages (which are atoms in win31)
            // whenever it receives WM_DDE_INITIATE message.
            //
            // This has a side effect - basically when peekmessage is called the app ie program
            // manager effectively yields allowing scheduling of other apps.
            //
            // So we do the side effect thing (simulate win31 behaviour) -
            //
            // The bug: 20221, rumba as/400 can't connect the firsttime to sna server.
            // Scenario: Rumbawsf execs snasrv and blocks on yield, snasrv execs wnap and blocks
            //           on yield. Eventually wnap yields and rumbawsf is scheduled which
            //           broadcasts a ddeinitiate message. When WOWEXEC receives this message
            //           it will peek for nonexistent msg, which allows snasrv to get scheduled

            MSG msg;
            while (PeekMessage(&msg, NULL, 0xFFFF, 0xFFFF, PM_REMOVE))
                DispatchMessage(&msg);
        }
        break;



    case WM_CLOSE:
#ifdef DEBUG
        ExitKernelThunk(0);
#else
        // ignore since wowexec must stay around
        return 0;
#endif // ! DEBUG


    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 1;
}

BOOL FAR PASCAL PartyDialogProc(HWND hDlg, WORD msg, WORD wParam, LONG lParam)
{
#ifdef DEBUG
    BOOL f;
    DWORD dw;
    char szBuf[255];

    switch (msg) {

        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_PARTY_NUMBER, EM_LIMITTEXT, 5, 0L);
            SendDlgItemMessage(hDlg, IDD_PARTY_STRING, EM_LIMITTEXT, sizeof(szBuf)-1, 0L);
            break;

        case WM_COMMAND:
            switch (wParam) {

                case 0xdab /* IDCANCEL */:
                    EndDialog(hDlg, FALSE);
                    break;

                case 0xdad /* IDOK */:
                    dw = GetDlgItemInt(hDlg, IDD_PARTY_NUMBER, &f, FALSE);
                    GetDlgItemText(hDlg, IDD_PARTY_STRING, szBuf, sizeof(szBuf));
                    WowPartyByNumber(dw, szBuf);
                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
#endif

    return TRUE;
}

// Misc File Routines - taken from progman (pmdlg.c) mattfe apr-1 92

//-------------------------------------------------------------------------
PSTR FAR PASCAL GetFilenameFromPath
    // Given a full path returns a ptr to the filename bit. Unless it's a UNC style
    // path in which case
    (
    PSTR szPath
    )
    {
    DWORD dummy;
    PSTR pFileName;
    BOOL fUNC;


    GetPathInfo(szPath, &pFileName, (PSTR*) &dummy, (WORD*) &dummy,
        &fUNC);

    // If it's a UNC then the 'filename' part is the whole thing.
    if (fUNC)
        pFileName = szPath;

    return pFileName;
    }


//-------------------------------------------------------------------------
void NEAR PASCAL GetPathInfo
    // Get pointers and an index to specific bits of a path.
    // Stops scaning at first space.
    (
                        // Uses:
    PSTR szPath,        // The path.

                        // Returns:
    PSTR *pszFileName,  // The start of the filename in the path.
    PSTR *pszExt,       // Extension part of path (starting with the dot).
    WORD *pich,         // Index (in DBCS characters) of filename part starting at 0.
    BOOL *pfUnc         // Contents set to true if it's a UNC style path.
    )
    {
    char *pch;          // Temp variable.
    WORD ich = 0;       // Temp.

    *pszExt = NULL;             // If no extension, return NULL.
    *pszFileName = szPath;      // If no seperate filename component, return path.
    *pich = 0;
    *pfUnc = FALSE;             // Default to not UNC style.

    // Check for UNC style paths.
    if (*szPath == '\\' && *(szPath+1) == '\\')
        *pfUnc = TRUE;

    // Search forward to find the last backslash or colon in the path.
    // While we're at it, look for the last dot.
    for (pch = szPath; *pch; pch = AnsiNext(pch))
        {
        if (*pch == ' ')
            {
            // Found a space - stop here.
            break;
            }
        if (*pch == '\\' || *pch == ':')
            {
            // Found it, record ptr to it and it's index.
            *pszFileName = pch+1;
            *pich = ich+1;
            }
        if (*pch == '.')
            {
            // Found a dot.
            *pszExt = pch;
            }
        ich++;
        }

    // Check that the last dot is part of the last filename.
    if (*pszExt < *pszFileName)
        *pszExt = NULL;

    }


//-----------------------------------------------------------------------------
//  StartRequestedApp
//      Calls WIN32 Base GetNextVDMCommand
//      and then starts the application
//
//-----------------------------------------------------------------------------

#define LargeEnvSize()    0x1000           // Size of a large env

BOOL NEAR PASCAL StartRequestedApp(VOID)
{
    char achCmdLine[CCHMAX];
    char achAppName[CCHMAX];
#ifdef DEBUG
    char achAppNamePlusCmdLine[sizeof(achCmdLine) + sizeof(achAppName)];
    int iGetNextVdmCmdLoops = 0;
#endif
    char achCurDir[CCHMAX];
    WOWINFO wowinfo;
    BOOL    b;
    HANDLE  hmemEnvironment;
    USHORT usEnvSize;

    achCmdLine[0] = '\0';
    achAppName[0] = '\0';

    // We start by assuming that the app will have an environment that will
    // be less than a large environment size. If not then
    // WowGetNextVdmCommand will fail and we will try again with the
    // enviroment size needed for the app as returned from the failed
    // WowGetNextVdmCommand call. If we detect that WowGetNextVdmCommand fails
    // but that we have plenty of environment space then we know another
    // problem has occured and we give up.

    // We don't worry about wasting memory since the environment will be
    // merged into another buffer and this buffer will be freed below.

    wowinfo.EnvSize = LargeEnvSize();
    hmemEnvironment = NULL;

    do {
        if (hmemEnvironment != NULL) {
            GlobalUnlock(hmemEnvironment);
       GlobalFree(hmemEnvironment);
        }
   
        // We need to allocate twice the space specified so that international
        // character set conversions can be successful.
        hmemEnvironment = GlobalAlloc(GMEM_MOVEABLE, 2*wowinfo.EnvSize);
        if (hmemEnvironment == NULL) {
#ifdef DEBUG
            OutputDebugString("WOWEXEC - failed to allocate Environment Memory\n");
#endif
            MyMessageBox(IDS_EXECERRTITLE, IDS_NOMEMORYMSG, NULL);
            return FALSE;
        }
   
        wowinfo.lpEnv    = GlobalLock(hmemEnvironment);
#ifdef DEBUG
        if (wowinfo.lpEnv == NULL) {
            OutputDebugString("WOWEXEC ASSERT - GlobalLock failed, fix this!\n");
            _asm { int 3 };
        }

        if (2*wowinfo.EnvSize > GlobalSize(hmemEnvironment)) {
            OutputDebugString("WOWEXEC ASSERT - alloced memory too small, fix this!\n");
            _asm { int 3 };
        }
#endif
        wowinfo.lpCmdLine = achCmdLine;
        wowinfo.CmdLineSize = CCHMAX;
        wowinfo.lpAppName = achAppName;
        wowinfo.AppNameSize = CCHMAX;
        wowinfo.CurDrive = 0;
        wowinfo.lpCurDir = achCurDir;
        wowinfo.CurDirSize = sizeof(achCurDir);
        wowinfo.iTask = 0;

        usEnvSize = wowinfo.EnvSize;   

#ifdef DEBUG
        if (++iGetNextVdmCmdLoops == 4) {
            OutputDebugString("WOWEXEC ASSERT - Too many calls to GetNextVdmCommand\n");
            _asm { int 3 };
        }
#endif
    } while (! (b = WowGetNextVdmCommand(&wowinfo)) &&
           (wowinfo.EnvSize > usEnvSize));

    if ( ! b ) {
#ifdef DEBUG
        OutputDebugString("WOWEXEC - GetNextVdmCommand failed.\n");
#endif
        MyMessageBox(IDS_EXECERRTITLE, IDS_NOMEMORYMSG, achCmdLine);
        GlobalUnlock( hmemEnvironment );
        GlobalFree( hmemEnvironment );
        return FALSE;
    }

    //
    // If CmdLineSize == 0, no more commands (wowexec was the command)
    // see WK32WowGetNextVdm
    //
    if (! wowinfo.CmdLineSize) {
        GlobalUnlock( hmemEnvironment );
        GlobalFree( hmemEnvironment );
        return FALSE;
    }


#ifdef DEBUG
    lstrcpy(achAppNamePlusCmdLine, achAppName);
    lstrcat(achAppNamePlusCmdLine, ":");
    lstrcat(achAppNamePlusCmdLine, achCmdLine);
    // Chop off trailing CRLF from command tail.
    achAppNamePlusCmdLine[ lstrlen(achAppNamePlusCmdLine) - 2 ] = '\0';

    OutputDebugString("WOWEXEC: CommandLine = <");
    OutputDebugString(achAppNamePlusCmdLine);
    OutputDebugString(">\n");

    SetWindowText(ghwndMain, achAppNamePlusCmdLine);
    UpdateWindow(ghwndMain);
#endif

    ExecApplication(&wowinfo);

#ifdef DEBUG

    if ( ! gfSharedWOW ) {

        //
        // If this is a separate WOW, we have just executed the one and only
        // app we're going to spawn.  Change our window title to
        // Command Line - WOWExec so that it's easy to see which WOW this
        // window is associated with.  No need to worry about freeing
        // this memory, since when we go away the VDM goes away and
        // vice-versa.
        //

        lpszAppTitle = GlobalLock(
            GlobalAlloc(GMEM_FIXED,
                        lstrlen(achAppNamePlusCmdLine) +
                        3 +                        // for " - "
                        lstrlen(szAppTitleBuffer) +
                        1                          // for null terminator
                        ));

        lstrcpy(lpszAppTitle, achAppNamePlusCmdLine);
        lstrcat(lpszAppTitle, " - ");
        lstrcat(lpszAppTitle, szAppTitleBuffer);
    }


    SetWindowText(ghwndMain, lpszAppTitle);
    UpdateWindow(ghwndMain);
#endif

    GlobalUnlock(hmemEnvironment);
    GlobalFree(hmemEnvironment);

    return TRUE;  // We ran an app.
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\wowexec.h ===
/****************************** Module Header ******************************\
* Module Name: exec.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Niblet's header file
*
* History:
* 04-13-91 ScottLu	Stolen from niblet sources
* 21-mar-92 mattfe	added stuff form win3.1 progman
\***************************************************************************/
#define NO_CALLPROC32_DECL
#include "windows.h"


/*
 * Resource defines
 */
#define WINDOWMENU          1
#define ID_WOWEXEC_ICON     2
#define ID_PARTY_DIALOG     3

#ifdef RC_INVOKED
#define ID(id) id
#else
#define ID(id) MAKEINTRESOURCE(id)
#endif

/*
 * Menu ID's
 */
#define MM_BREAK	8001
#define MM_ABOUT	8002
#define MM_EXIT         8003
#define MM_FAULT        8004
#define MM_WATSON       8005
#define MM_PARTY        8006
#define MM_GENTHUNK     8007

/*
 * Dialog control IDs
 */
#define IDD_PARTY_NUMBER   1
#define IDD_PARTY_STRING   2
#define IDD_PARTY_NUMLABEL 3
#define IDD_PARTY_STRLABEL 4

/* String Table Defines */
#define errTitle		0
#define IDS_BADPATHMSG3 	1
#define IDS_NOMEMORYMSG 	2
#define IDS_FILENOTFOUNDMSG	3
#define IDS_MANYOPENFILESMSG	4
#define IDS_NOASSOCMSG		5
#define IDS_ASSOCINCOMPLETE	6
#define IDS_MULTIPLEDSMSG	7
#define IDS_OS2APPMSG		8
#define IDS_NEWWINDOWSMSG	9
#define IDS_PMODEONLYMSG       10
#define IDS_ACCESSDENIED       11
#define IDS_DDEFAIL	       12
#define IDS_COMPRESSEDEXE      13
#define IDS_INVALIDDLL	       14
#define IDS_SHAREERROR	       15
#define IDS_BADPATHMSG	       16
#define	IDS_OOMEXITTITLE       17
#define	IDS_OOMEXITMSG	       18
#define IDS_UNKNOWNMSG	       19
#define IDS_EXECERRTITLE       20
#define	IDS_BADPATHTITLE       21
#define IDS_APPTITLE           22
#define IDS_SHAREDAPPTITLE     23
#define IDS_CANTLOADWIN32DLL   24

#define IDS_LAST               24       // Put New Strings Before this one


#ifdef JAPAN
#define MAXTITLELEN		42	/* Length of MessageBox titles */
#else
#define MAXTITLELEN		50	/* Length of MessageBox titles */
#endif
#define MAXMESSAGELEN		256	/* Length of MessageBox messages */
#define MAXITEMPATHLEN		64+16+48 /* Path + 8.3 + Drive(colon) + arguments */

/* PMDOS.ASM */
BOOL  FAR PASCAL IsReadOnly(LPSTR);
BOOL  FAR PASCAL PathType(LPSTR);
LONG  FAR PASCAL GetDOSErrorCode( void );
int   FAR PASCAL GetCurrentDrive(void);
int   FAR PASCAL SetCurrentDrive(WORD);
int   FAR PASCAL GetCurrentDirectory(WORD, LPSTR);
int   FAR PASCAL SetCurrentDirectory(LPSTR);
BOOL  FAR PASCAL IsRemoteDrive(int);
BOOL  FAR PASCAL IsRemovableDrive(int);
int   FAR PASCAL DosDelete(LPSTR);
int   FAR PASCAL DosRename(LPSTR, LPSTR);
LPSTR FAR PASCAL lmemmove(LPSTR, LPSTR, WORD);
DWORD FAR PASCAL FileTime(HANDLE);

typedef unsigned short USHORT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\math.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0
?DF=1
PMODE=1

        .xlist
        include cmacros.inc
;       include windows.inc
        include timer.inc
        .list

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

sBegin  Code286
        assumes cs,Code286
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

next_byte:
        inc     cx
        add     ax,ax
        adc     dx,dx
        jns     next_byte
ulNormalize_exit:
cEnd

sEnd

       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\test\shell\wowexfax.c ===
//**************************************************************************
//  WOW fax support:
//       supports delrina winfax only
//                                                - nandurir  created
//**************************************************************************


#define NOGDI
#define PRINTDRIVER
#define _WOWFAX16_
#define DEFINE_DDRV_DEBUG_STRINGS
#include "wowexec.h"
#include "wowfax.h"

#define WOWDRV_BITBLT       MAKEINTRESOURCE(1)
#define WOWDRV_CONTROL      MAKEINTRESOURCE(3)
#define WOWDRV_DISABLE      MAKEINTRESOURCE(4)
#define WOWDRV_ENABLE       MAKEINTRESOURCE(5)
#define WOWDRV_EXTDEVMODE   MAKEINTRESOURCE(90)
#define WOWDRV_DEVCAPS      MAKEINTRESOURCE(91)

//**************************************************************************
// FaxWndProc
//
//    NOTE: the definitions such as 'BITMAP' struct is different in this
//          file. This file is compiled with NOGDI option so that the
//          printer driver versions of the structure get defined
//          (in gdidefs.inc). However we donot use printer drivers version
//          of such structures, particularly BITMAP.
//**************************************************************************

LONG FAR PASCAL FaxWndProc(HWND hwnd, WORD message, WORD hdc,
                                                LPWOWFAXINFO16 lpfaxinfo)
{
    LPPOINT lppt;
    HANDLE       hMem;
    RECT rc;
    HINSTANCE    hInst;
    WORD         wSize;
    LONG         lRet = (LONG)lpfaxinfo;
    WORD         wRet;
    char         szDriverFileName[MAXITEMPATHLEN+1];

#ifdef DEBUG
    char         szTmp[128];

    if ((message >= WM_DDRV_FIRST) && (message <= WM_DDRV_LAST)) {
        wsprintf(szTmp, "FaxWndProc, 0x%XH, %s, 0x%XH, 0x%lX\n", hwnd, (LPSTR) szWmDdrvDebugStrings[message - WM_DDRV_FIRST], hdc, lpfaxinfo);
        OutputDebugString((LPSTR) szTmp);
    }
#endif
 
    switch (message) {
        default:
            return DefWindowProc(hwnd, message, hdc, (LPARAM)lpfaxinfo);
            break;

        case WM_DDRV_INITFAXINFO16:
            // allocate and initialize lpfaxinfo

            hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                                     sizeof(WOWFAXINFO16));
            lpfaxinfo = (LPWOWFAXINFO16)GlobalLock(hMem);
            if (lpfaxinfo) {
                lpfaxinfo->hmem = hMem;
            }

            lRet = (LONG)lpfaxinfo;
            break;

        case WM_DDRV_ENABLE:
        case WM_DDRV_LOAD:
            // now load the drv - lpfaxinfo must have been initialized

            if (lpfaxinfo == (LPWOWFAXINFO16)NULL)
                break;

            lstrcpy(szDriverFileName, lpfaxinfo->lpDriverName);
            lstrcat(szDriverFileName, ".DRV");
            hInst = lpfaxinfo->hInst = LoadLibrary(szDriverFileName);

            if (hInst) {

                // store necessary info
                (FARPROC)lpfaxinfo->lpControl = GetProcAddress(hInst, WOWDRV_CONTROL);
                (FARPROC)lpfaxinfo->lpDisable = GetProcAddress(hInst, WOWDRV_DISABLE);
                (FARPROC)lpfaxinfo->lpEnable = GetProcAddress(hInst, WOWDRV_ENABLE);
                (FARPROC)lpfaxinfo->lpBitblt = GetProcAddress(hInst, WOWDRV_BITBLT);
                (FARPROC)lpfaxinfo->lpExtDMode = GetProcAddress(hInst, WOWDRV_EXTDEVMODE);
                (FARPROC)lpfaxinfo->lpDevCaps = GetProcAddress(hInst, WOWDRV_DEVCAPS);

                if (!lpfaxinfo->lpControl || !lpfaxinfo->lpDisable || !lpfaxinfo->lpEnable ||
                      !lpfaxinfo->lpBitblt || !lpfaxinfo->lpExtDMode || !lpfaxinfo->lpDevCaps) {

#ifdef DEBUG
                    wsprintf(szTmp, "FaxWndProc, Failed GetProcAddress on: %s\n", szDriverFileName);
                    OutputDebugString((LPSTR) szTmp);
#endif
                    lRet = 0;
                }
            }
            else {
#ifdef DEBUG
                wsprintf(szTmp, "FaxWndProc, Failed load of: %s\n", szDriverFileName);
                OutputDebugString((LPSTR) szTmp);
#endif
                lRet = 0;
            }
            if (message == WM_DDRV_LOAD || lRet == 0)
                break;

            // case WM_DDRV_ENABLE continues

            if (lpfaxinfo) {
                // win31 gdi calls 'enable' twice - first to get the gdiinfo struct and next to get
                // pdevice struct
                wRet = (*lpfaxinfo->lpEnable)(lpfaxinfo->lpOut, InquireInfo,
                                           lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName, lpfaxinfo->lpIn);
#ifdef DEBUG
                if (!wRet) {
                    wsprintf(szTmp, "FaxWndProc, Enable InquireInfo Failed: %s, %s\n", szDriverFileName, lpfaxinfo->lpPortName);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
                hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                                      ((LPGDIINFO)lpfaxinfo->lpOut)->dpDEVICEsize);
                lpfaxinfo->hmemdevice = hMem;
                lpfaxinfo->lpDevice = GlobalLock(hMem);
                if (!lpfaxinfo->lpDevice) {
#ifdef DEBUG
                    wsprintf(szTmp, "FaxWndProc, GlobalAlloc Failed: 0x%lX\n", ((LPGDIINFO)lpfaxinfo->lpOut)->dpDEVICEsize);
                    OutputDebugString((LPSTR) szTmp);
#endif
                    return(0);
                }
                wRet = (*lpfaxinfo->lpEnable)(lpfaxinfo->lpDevice, EnableDevice,
                                           lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName, lpfaxinfo->lpIn);
#ifdef DEBUG
                if (!wRet) {
                    wsprintf(szTmp, "FaxWndProc, Enable, EnableDevice Failed: %s, %s\n", szDriverFileName, lpfaxinfo->lpPortName);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
                lppt = (LPPOINT)((LPSTR)lpfaxinfo->lpOut + sizeof(GDIINFO16));
                lppt->x = lppt->y = 0;
                wRet = (*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, GETPRINTINGOFFSET, 0, lppt);
#ifdef DEBUG
                if (!wRet) {
                    OutputDebugString((LPSTR) "FaxWndProc, Control GETPRINTINGOFFSET Failed\n");
                }
#endif
                lpfaxinfo->flState |= WFINFO16_ENABLED;
            }
            break;

        case WM_DDRV_STARTDOC:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                             SETPRINTERDC, (LPSTR)&hdc, 0);
                if (lRet) {
                    // EasyFax Ver2.0 support
                    // Also Procomm+ 3 cover sheets.  Bug #305665
                    lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                             STARTDOC, (LPSTR)lpfaxinfo->szDocName, 0);

#ifdef DEBUG
                    if (lRet < 0) {
                        OutputDebugString((LPSTR) "FaxWndProc, Control STARTDOC Failed\n");
                    }
#endif
                }
#ifdef DEBUG
                else {
                    OutputDebugString((LPSTR) "FaxWndProc, Control SETPRINTERDC Failed\n");
                }
#endif
            }
            break;

        case WM_DDRV_PRINTPAGE:
            if (lpfaxinfo) {
                for (;;) {
                    lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                              NEXTBAND, NULL, (LPSTR)&rc);
                    if (lRet < 0) {
#ifdef DEBUG
                        OutputDebugString((LPSTR) "FaxWndProc, Control NEXTBAND Failed\n");
#endif
                        break;
                    }

                    if (rc.left || rc.top || rc.right || rc.bottom) {
                        wRet = (*lpfaxinfo->lpBitblt)(lpfaxinfo->lpDevice, rc.left, rc.top,
                                     NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                                    SRCCOPY, NULL, NULL);
#ifdef DEBUG
                        if (!wRet) {
                            OutputDebugString((LPSTR) "FaxWndProc, BitBlt Failed\n");
                        }
#endif
                    }
                    else {
                        break;
                    }
                }
            }

            break;

        case WM_DDRV_ENDDOC:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, ENDDOC, 0, 0);
#ifdef DEBUG
                if (lRet <= 0) {
                    OutputDebugString((LPSTR) "FaxWndProc, Control ENDDOC Failed\n");
                }
#endif
            }
            break;

        case WM_DDRV_ESCAPE:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, lpfaxinfo->wCmd, 0, 0);
#ifdef DEBUG
                if (lRet <= 0) {
                    wsprintf(szTmp, "FaxWndProc, Escape %X Failed\n", lpfaxinfo->wCmd);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
            }
            break;

        case WM_DDRV_DISABLE:
            if (lpfaxinfo) {

                if (lpfaxinfo->flState & WFINFO16_ENABLED) {
                    (*lpfaxinfo->lpDisable)(lpfaxinfo->lpDevice);
                }

                GlobalUnlock(lpfaxinfo->hmemdevice);
                GlobalFree(lpfaxinfo->hmemdevice);
            }

            lRet = 0;

            // fall through

        case WM_DDRV_UNLOAD:

            if (lpfaxinfo) {
                if (lpfaxinfo->hInst) {
                    FreeLibrary(lpfaxinfo->hInst);
                }
            }

            lRet = 0;

            // fall through

        case WM_DDRV_FREEFAXINFO16:

            if  (lpfaxinfo) {
                GlobalUnlock(lpfaxinfo->hmem);
                GlobalFree(lpfaxinfo->hmem);
                lpfaxinfo = (LPWOWFAXINFO16)NULL;
            }

            lRet = 0;
            break;

        case WM_DDRV_EXTDMODE:
            if (lpfaxinfo) {
                lRet = (*lpfaxinfo->lpExtDMode)(lpfaxinfo->hwndui, lpfaxinfo->hInst,
                                             lpfaxinfo->lpOut, lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName,
                                             lpfaxinfo->lpIn, 0, lpfaxinfo->wCmd);
            }
            break;

        case WM_DDRV_DEVCAPS:
            if (lpfaxinfo) {
                lRet = (*lpfaxinfo->lpDevCaps)(lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName,
                                                       lpfaxinfo->wCmd, lpfaxinfo->lpOut, 0);
            }
            break;

    }

    return lRet;
}

//**************************************************************************
// FaxInit
//
//**************************************************************************


HWND FaxInit(HINSTANCE hInst)
{
    WNDCLASS wc;

    // Make sure we only allow one FaxWndProc to handle WowFax messages

    if (FindWindow(WOWFAX_CLASS, NULL)) {
        return((HWND)0);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = (WNDPROC)FaxWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = 0;
    wc.hCursor          = 0;
    wc.hbrBackground    = 0;
    wc.lpszMenuName     = 0;
    wc.lpszClassName    = WOWFAX_CLASS;

    if (!RegisterClass(&wc)) {
        return (HWND)0;
    }

    return CreateWindow(wc.lpszClassName, "", WS_OVERLAPPEDWINDOW,
                                0, 0, 0, 0, NULL, NULL, hInst, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\local.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LOCAL.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the routines which interface with the
;   timer counter hardware itself.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
.list

        externFP    DriverCallback      ; in MMSYSTEM.DLL
	externFP    StackEnter		; in MMSYSTEM.DLL
	externFP    StackLeave		; in MMSYSTEM.DLL
        externFP    tddEndMinPeriod     ; timer.asm
        externA     __WinFlags          ; Somewhere in Kernel ?

        .286p

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externW     Events
externD     lpOLDISR
externB     PS2_MCA

sBegin Data

; Current Time
public CurTime
CurTime         dw  3 dup(0)    ; 48 bit current tick count.

public wProgTime
wProgTime       dw  0           ; Time currently programmed into timer chip
                                ; ...NOTE 0=64k !!!
public	wNextTime
wNextTime       dw  0           ; Time next programmed into timer chip

public nInt8Count
nInt8Count      dw  0           ; # times int8 handler re-entered

ifdef DEBUG
public          RModeIntCount, PModeIntCount
RModeIntCount   dd  0
PModeIntCount   dd  0
endif

public          IntCount
IntCount        dw  0
fBIOSCall       dw  0           ; Bios callback needed: TRUE or FALSE
fIntsOn         dw  0		; Interrupts have already been turned back on
ifdef	RMODE_INT
dRModeTicks	dd  ?		; Temporary storage for Rmode ticks
endif

public		dTickUpdate
dTickUpdate	dd	0	; Amount to actually update times with

sEnd Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin  Code286
    assumes cs,Code286
    assumes ds,data
    assumes es,nothing

CodeFixWinFlags     dw      __WinFlags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local (private) functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @asm tddRModeISR | Service routine for timer interrupts on IRQ 0.
;        when in REAL mode
;
;   @comm
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef	RMODE_INT
	assumes ds,nothing
        assumes es,nothing

externD RModeOldISR

public RModeDataSegment
RModeDataSegment        dw      0

public	tddRmodeISR
tddRmodeISR	proc far
	push	ds
	push	ax
	push	bx

	mov	ax,cs:[RModeDataSegment]
	mov	ds,ax
	assumes	ds,Data

	inc	[IntCount]

ifdef	DEBUG
	add	[RModeIntCount].lo,1
	adc	[RModeIntCount].hi,0
endif

	mov	ax,[wNextTime]	; Next time programmed into timer chip
	xchg	ax,[wProgTime]	; Update current time if it was reset

	xor	bx,bx
	dec	ax			; convert 0 -> 64k
	add	ax,1
	adc	bx,bx

	cmp	[nInt8Count],1		; Do not allow multiple re-entrancy
	jge	tddRmodeISRNormalExit

	cld
	push	di
	push	cx
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddRmodeISRLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddRmodeISRNext
	cmp	[di].evDestroy,EVENT_DESTROYING
	je	tddRmodeISRNext
	test	[di].evFlags,TIME_BIOSEVENT
	jz	tddRmodeISRNext

	mov	dRModeTicks.lo,ax
	mov	dRModeTicks.hi,bx
	add	ax,[dTickUpdate.lo]
	adc	bx,[dTickUpdate.hi]
	cmp	[di].evTime.hi,bx
	jg	@f
	jl	tddRmodeISRChain
	cmp	[di].evTime.lo,ax
	jle	tddRmodeISRChain

@@:
	mov	ax,dRModeTicks.lo
	mov	bx,dRModeTicks.hi
	jmp	tddRmodeISRSearchExit

tddRmodeISRChain:
	pop	cx
	pop	di
	pop	bx
	pop	ax
	push	[RModeOldISR.hi]
	push	[RModeOldISR.lo]

	push	bp		; Restore DS from stack
	mov	bp,sp
	mov	ds,[bp+6]	; stack: [ds] [RModeOldISR.hi] [RModeOldISR.lo] [bp]
	assumes	ds,nothing
	pop	bp

	retf	2

tddRmodeISRNext:
	assumes	ds,Data
	add	di,SizeEvent	; Increment to next event slot
	loop	tddRmodeISRLoop

tddRmodeISRSearchExit:
	pop	cx
	pop	di

tddRmodeISRNormalExit:
	add	CurTime[0],ax
	adc	CurTime[2],bx
	adc	CurTime[4],0

	add	[dTickUpdate.lo],ax	; Update total needed to be added
	adc	[dTickUpdate.hi],bx

ifndef   NEC_98
	cmp	PS2_MCA,0	; Check for a PS/2 Micro Channel
	jz	@f
	in	al,PS2_SysCtrlPortB	; Get current System Control Port status
	or	al,PS2_LatchBit	; Set latch clear bit
	IO_Delay
	out	PS2_SysCtrlPortB,al	; Set new System Control Port status
@@:
endif   ; NEC_98
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port

	pop	bx
	pop	ax
	pop	ds
	assumes	ds,nothing
	iret

tddRmodeISR	endp
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddISR |
;       Service routine for timer interrupts on IRQ 0.
;
;	The ISR runs through all the event slots available, looking for
;	slots that are currently in used, and are not currently being
;	destroyed.  For each valid event found the callback time is updated.
;	After all times have been updated, the table is run through again,
;	calling all events that are due, and removing any due events that are
;	oneshots.  By updating all the events first, any new events that are
;	created during a callback will not be accidentally called too early.
;
;	Note that interrupts are not immediately restored, as this causes even
;	more problems with slow machines.  Also, the EOI is not sent to the
;	PIC, as the BIOS interrupt handler does a non-specific EOI, and this
;	would in turn EOI the last outstanding interrupt.
;
;	First there is a special check for the presence of a Micro Channel,
;	in which case, the System Control Port B must have bit 7 set in order
;	to have the IRQ 0 latch released.  This flag is aquired during Enable
;	time with an int 15h service C0h, requesting machine information, which
;	includes the presence of a Micro Channel.
;
;	The ISR then updates the tick count based on the count that was in
;	the timer's CE register.  While retrieving that previously programmed
;	time, it updates it to the new time that is contained in the timer's
;	CR register, in case these to items are different.  Note that the
;	maximum CE value of 0 is converted to 65536 through the decrement and
;	adding with carry.
;
;	Next, the ISR must determine if it is re-entering itself.  If this is
;	so, callbacks are not performed, and only a "missed ticks" count is
;	updated, indicating how many additional ticks should be subtracted
;	from each event due time.  This allows the ISR to finish immediately
;	if a timer interrupt is currently being serviced.  This is important
;	for both speed in general, and for slow machines that might generate
;	mouse events during timer events.  Note that only 6 bytes have been
;	pushed onto the stack for this case, and that everything but DS must
;	be removed before jumping to the exit label.  In this case, the
;	function can safely EOI the PIC, as the BIOS call will not be
;	performed, then the function will just return.
;
;	In the normal case, the ISR is not being re-entered, and timer event
;	due times are updated, and callbacks are made.  In this case, the
;	number of "missed ticks" is added to the CE tick count, bringing the
;	total up to the number of ticks passed since the last time the event
;	times were updated.  This global counter is then zeroed for the next
;	time re-entrancy occurs.  Note that interrupts are still turned off
;	at this point, and there is no need to fear bad things happening.
;
;	When checking for a valid event ID, the Destroy flag must be checked
;	in case the interrupt occured during a kill timer function call after
;	the Destroy flag was grabbed the second time, but before the actual ID
;	could be reset.
;
;	When a valid ID is found, its due time is updated with the CE value,
;	plus the amount of ticks that were missed because of re-entrancy, if
;	any.
;
;	After updating times, the event list is checked again, this time to
;	perform any of the callbacks that are due.  To make things easy, a
;	global flag is used to determine if interrupts have been turned back
;	on, and thus stacks have been switched.
;
;	If a valid event is found that is also due, meaning that the callback
;	time is <= 0, the fIntsOn flag is checked to determine if the stack
;	has already been switched and interrupts are already on.  If not, then
;	just that occurs.  The <f>tddEvent<d> function is then called to
;	service the event.
;
;	After all events have been called, interrupts are turned back off if
;	needed, and the original stack restored.  If no callback actually
;	occurred, then the stack is never switched.  The function then either
;	exits as a normal ISR would, or it chains to the BIOS ISR.  This is
;	done if the BIOS event was up for being called, and the fBIOSCall flag
;	was set because of that.  Since the flag cannot be set when this ISR
;	is being pre-entered, as callbacks are not performed, there is no need
;	to do a test and set proceedure on the fBIOSCall flag, just a simple
;	compare will do.  Note though that the nInt8Count re-entrancy count is
;	not decremented until after interrupts are turned off.
;
;	Interrupts are also cleared to ensure that the BIOS ISR is not
;	re-entered itself, since there is no re-entrancy control after this
;	function chains to BIOS.  Notice that DS was the first register pushed
;	onto the stack, and therefore the last item to get rid of, which is
;	done with the "retf 2".  DS itself is restored from stack before
;	chaining so that lpOLDISR (BIOS) can be accessed and pushed onto stack
;	as the return address.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,nothing
	assumes es,nothing

public	tddISR
tddISR	proc far

	push	ds		; This is pushed first for the case of BIOS

;----------------------------------------------------------------------------
;If we are on a 386 save all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pushad
        push    fs
        push    gs
.286p
@@:

	push	ax
	push	bx

	mov	ax,DGROUP	; set up local DS
	mov	ds,ax
	assumes	ds,Data

ifndef  NEC_98
	cmp	PS2_MCA,0	; Check for a PS/2 Micro Channel
	jz	@f
	in	al,PS2_SysCtrlPortB	; Get current System Control Port status
	or	al,PS2_LatchBit	; Set latch clear bit
	IO_Delay
	out	PS2_SysCtrlPortB,al	; Set new System Control Port status

@@:
endif   ; NEC_98
	inc	[IntCount]	; Ever-increasing Int counter
	inc	[nInt8Count]	; Number of times int 8 re-entered

	mov	ax,[wNextTime]	; Next time programmed into timer chip
	xchg	ax,[wProgTime]	; Update current time if it was reset

	xor	bx,bx
	dec	ax		; convert 0 -> 64k
	add	ax,1		; Force carry flag
	adc	bx,bx		; Set bx:ax == current tick count

	add	CurTime[0],ax	; Add tick count to total ticks
	adc	CurTime[2],bx
	adc	CurTime[4],0

ifdef	DEBUG
;	cmp	[nInt8Count],1		; Re-entrancy counter
;	je	@f			
;	add	[RModeIntCount].lo,1
;	adc	[RModeIntCount].hi,0
;@@:
	add	[PModeIntCount].lo,1	; For debug Pmode count message
	adc	[PModeIntCount].hi,0
endif
	cmp	[nInt8Count],1		; Do not allow multiple re-entrancy
	je	tddISRCheckCallbacks
	add	[dTickUpdate.lo],ax	; Update total needed to be added
	adc	[dTickUpdate.hi],bx
	pop	bx
	jmp	tddISREOIExit		; EOI before exiting

tddISRCheckCallbacks:
	add	ax,[dTickUpdate.lo]	; Add any extra ticks from re-entrancy
	adc	bx,[dTickUpdate.hi]
	push	cx
	xor	cx,cx
	mov	[dTickUpdate.lo],cx	; Reset tick re-entrant counter
	mov	[dTickUpdate.hi],cx

	cld			; never assume the value of this in an ISR!
	push	di
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddISRUpdateTimeLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddISRUpdateTimeNext
	sub	[di].evTime.lo,ax	; Subtract the amount of ticks gone by
	sbb	[di].evTime.hi,bx

tddISRUpdateTimeNext:
	add	di,SizeEvent	; Increment to next event slot
	loop	tddISRUpdateTimeLoop

	mov	fIntsOn,0		; Initialize interrupts set flag
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddISRCallLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddISRNextEvent
	cmp	[di].evDestroy,EVENT_DESTROYING
	je	tddISRNextEvent
	cmp	[di].evTime.hi,0	; Is it time to call the event?
	jg	tddISRNextEvent		; evTime <= 0
	jl	tddISREvent
	cmp	[di].evTime.lo,0
	jg	tddISRNextEvent

tddISREvent:
	test	[di].evFlags,TIME_BIOSEVENT
	jnz	tddISRCallEvent		; No need to switch, as no call will be made.
	cmp	fIntsOn,0	; Have interrupts been turned on already?
	jnz	tddISRCallEvent
	inc	fIntsOn		; fIntsOn == TRUE
	cCall	StackEnter	; Switch to a new stack
	sti			; Can be re-entered now with new stack

;	A timer callback needs to be called, but first before calling it,
;	we need to check to determine if the original timer interrupt function
;	is to be called during this interrupt.  The reason is that a timer
;	callback could take a long time, and the PIC should be EOI'ed as soon
;	as possible.
;	It is not possible to just do a specific EOI, as the BIOS timer
;	interrupt performs a non-specific EOI, which would turn back on some
;	other random interrupt.  So if the the BIOS needs to be called, it
;	is done now, else the EOI is performed now.  This assumes that the
;	BIOS callback is the first item in the list of callbacks.
;	If the BIOS callback occurs now, then the fBIOSCall flag is reset,
;	as there is no need to chain to it at the end of this interrupt.  So
;	if no other callbacks are to be performed, the BIOS interrupt is
;	chained to, else it is just called before the first timer callback
;	is performed.

	cmp	[fBIOSCall],0	; Does BIOS need to be called?
	je	tddISREOI
	mov	[fBIOSCall],0	; No need to call BIOS again at the end
	pushf			; Simulate an interrupt call
	call	lpOLDISR	; Call original timer interrupt
	jmp	tddISRCallEvent	; Do actual timer callback

;	No BIOS interrupt call is to be performed, so do EOI.
tddISREOI:
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port
tddISRCallEvent:
	call	tddEvent		; handle the event

tddISRNextEvent:
	add	di,SizeEvent	; Increment to next event slot
	loop	tddISRCallLoop

	cmp	fIntsOn,0	; Where interrupts turned back on?
	jz	@f
	cli			; Interrupts were turned on, so remove them
	cCall	StackLeave	; Switch back to old stack

@@:
	pop	di		; Restore everything except DS
	pop	cx
	pop	bx
	cmp	[fBIOSCall],0	; Does BIOS need to be called?
	je	tddISREOIExit
	pop	ax
	mov	[fBIOSCall],0

;----------------------------------------------------------------------------
;If we are on a 386 restore all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pop     gs
        pop     fs
        popad
.286p
@@:
	push	[lpOLDISR.hi]	; Push return address
	push	[lpOLDISR.lo]
	dec	[nInt8Count]	; exiting, decrement entry count

	push	bp		; Restore DS from stack
	mov	bp,sp
	mov	ds,[bp+6]	; stack: [ds] [lpOLDISR.hi] [lpOLDISR.lo] [bp]
	assumes	ds,nothing
	pop	bp

	retf	2		; Chain to BIOS ISR, removing DS from stack

tddISREOIExit:
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port
	pop	ax
	assumes ds,Data
	dec	[nInt8Count]	; exiting, decrement entry count

;----------------------------------------------------------------------------
;If we are on a 386 restore all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pop     gs
        pop     fs
        popad
.286p
@@:
	pop	ds
	assumes ds,nothing

	iret

tddISR	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddEvent |
;	Handle an event when it is due.
;
;	For a valid event, the ID is saved in case the slot needs to be zeroed
;	and the type of event is checked.  If this is a oneshot event
;	timer, the entry is freed.  Note that at this point, as in the kill
;	event function, the Destroy flag must be checked to determine if the
;	slot is currently being checked.  If so, the EVENT_DESTROYED flag must
;	be set instead of resetting the flag so that the function that was
;	interrupted can determine that the entry was killed while being
;	checked.
;
;	After saving the event handle, the function checks to see if the event
;	is a One Shot, in which case it is destroyed, and the event's
;	resolution is removed from resolution the table.
;
;	If on the other hand the event is a periodic one, the next calling
;	time is updated with the delay period.  Note that if the event is far
;	behind, or the last minimum resolution was very large, many delay
;	periods are added to the next call time.
;
;	If this is a BIOS event, then the fBIOSCall flag is set so that the
;	ISR chains to the old BIOS ISR instead of returning normally.  If this
;	is a normal event, the parameters are pushed, and the driver callback
;	function is called using the DCB_FUNCTION flag.
;
;	After returning from the callback, the return value from
;	<f>DriverCallback<d> is checked to determine if the callback succeeded.
;	If it did not, then the timer event needs to be removed.  The timer
;	event however may have been a oneshot, in which case it was already
;	been removed before the call was made, and the EVENT_DESTROYED flag
;	may have been set, so it is just left alone.  If the event is still
;	present however, it is destroyed after doing the checking to see if
;	this interrupt came while the event was being destroyed.  Note that
;	there is no check to see if the event IDs are the same before destroying
;	the event.  This is because if the callback failed, then the timer
;	structure cannot have changed, and no check is needed.
;
;@parm	DS:DI |
;	Points to the event slot.
;
;@comm	Uses AX,BX.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes	es,nothing
	assumes	ds,Data

cProc	tddEvent, <NEAR, PUBLIC>, <>
cBegin
	push	dx

	mov	dx,[di].evID
	test	[di].evFlags,TIME_PERIODIC
	jnz	tddEventPeriodic

tddEventKillOneShot:
	xor	ax,ax
	mov	[di].evID,ax			; Invalidate slot
	cmp	[di].evDestroy,EVENT_CHECKING	; Did this interrupt a Kill?
	jne	@f
	mov	al,EVENT_DESTROYED		; Let the interrupted Kill know
@@:
	mov	[di].evDestroy,al
	mov	[di].evCreate,ah		; pEvent->evCreate = FALSE
	push	dx
	push	cx
	cCall	tddEndMinPeriod,<[di].evResolution>
	pop	cx
	pop	dx
	jmp	tddEventCallback

tddEventPeriodic:
	mov	ax,[di].evDelay.lo
	mov	bx,[di].evDelay.hi
@@:
	add	[di].evTime.lo,ax
	adc	[di].evTime.hi,bx
	jl	@b

tddEventCallback:
	test	[di].evFlags,TIME_BIOSEVENT
	jz	tddEventDriverCallback
	inc	[fBIOSCall]
	jmp	tddEventExit

tddEventDriverCallback:
	push	cx
	push	es
	;
	;  call DriverCallback() in MMSYSTEM
	;
	push	[di].evCallback.hi	; execute callback function
	push	[di].evCallback.lo
	push	DCB_FUNCTION or DCB_NOSWITCH; callback flags
	push	dx			; idTimer
	xor	dx,dx
	push	dx			; msg = 0
	push	[di].evUser.hi		; dwUser
	push	[di].evUser.lo
	push	dx			; dw1 = 0
	push	dx
	push	dx			; dw2 = 0
	push	dx
	call	DriverCallback		; execute callback function
	pop	es
	or	ax,ax			; Check for a successful return
	jnz	tddEventSucceed		; If callback succeeded, just continue
	cmp	[di].evID,ax		; If the timer was already destroyed,
	jz	tddEventSucceed		; just leave
	mov	[di].evID,ax		; Else destroy the event
	cmp	[di].evDestroy,EVENT_CHECKING	; Did this interrupt a Kill?
	jne	@f
	mov	al,EVENT_DESTROYED	; Let the interrupted Kill know
@@:
	mov	[di].evDestroy,al
	mov	[di].evCreate,ah	; pEvent->evCreate = FALSE
	cCall	tddEndMinPeriod,<[di].evResolution>

tddEventSucceed:
	pop	cx

tddEventExit:
	pop	dx
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @asm GetCounterElement | Low level routine which loads the tick count
;	from the timer counter device, and returns the number of ticks that
;	have already passed.
;
;   @rdesc Returns the tick count in AX.
;
;   @comm All registers preserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public	GetCounterElement
GetCounterElement	proc near

	; Get rid of any latched count if this is called during interrupt time
	cmp	[nInt8Count],1
	jb	@f
	in	al,TMR_CNTR_0
	IO_Delay
	in	al,TMR_CNTR_0

@@:
	; read counter first time
	xor	ax,ax			; LATCH counter 0 command
	out	TMR_CTRL_REG,al		; send command

	in	al,TMR_CNTR_0		; read low byte
	mov	ah,al
	in	al,TMR_CNTR_0		; read high byte
	xchg	al,ah
	sub	ax,wProgTime		; Convert to number of ticks already past
	neg	ax

	ret

GetCounterElement	endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\libinit.asm ===
;
;  LibInit.asm	library stub to do local init for a Dynamic linked library
;
;  NOTE!!!! link this MODULE first or you will be sorry!!!!
;
?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.286
.xlist
include cmacros.inc
include windows.inc
include sysinfo.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
;include vtdapi.inc
.list

.list

sBegin  Data
;
; Stuff needed to avoid the C runtime coming in
;
; also known as "MAGIC THAT SAVED ME" - Glenn Steffler 2/7/90
;
; Do not remove!!
;
            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd    Data

;
;
; END of nasty stuff...
;

externA     WinFlags
externFP    LocalInit
externFP    Disable286
externFP    Enable286
externW     wMaxResolution
externW     wMinPeriod

; here lies the global data

sBegin  Data

public wEnabled
wEnabled	dw  0		; enable = 1 ;disable = 0

public PS2_MCA
ifdef   NEC_98
PS2_MCA         db      0       ; Micro Channel Flag
public bClockFlag               ; save machine clock
bClockFlag      db      0       ; 5Mhz = 0 ; 8Mhz = other
else    ; NEC_98
PS2_MCA         db      ?       ; Micro Channel Flag
endif   ; NEC_98

sEnd    Data

    assumes es,nothing

sBegin  CodeInit
    assumes cs,CodeInit
    assumes ds,Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Library unload function
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Disable routine is same as WEP

cProc   WEP,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen

    errn$   Disable

cEnd nogen

cProc   Disable,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen
    push    ds
    mov     ax,DGROUP           ; set up DS==DGROUP for exported funcs
    mov     ds,ax
    assumes ds,Data

    xor     ax,ax		; return value = no error

    cmp     wEnabled,ax 	; Q: enabled ?
    jz	    dis_done		; N: exit

    mov     wEnabled,ax 	; disabled now

    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     dis_386

    ; running under win286
dis_286:
    call    Disable286
    jmp     dis_done

    ; running under win386
dis_386:
    call    Disable286

dis_done:
    pop     ds
    ret     2

cEnd nogen

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Library Enable function
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cProc	Enable,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen
    mov     ax,wEnabled
    or      ax,ax               ; Q: already enabled ?
    jnz     enable_done 	; Y: exit

    inc     wEnabled		; mark as being enabled

ifdef   NEC_98
;
; Get system clock
;
    mov     ax,0002h
    mov     bx,0040h    ; get segment addres
                        ; make descriptor(real mode segment)
                        ; return the segment descriptor
                        ; in the case of exist the appointed segment descriptor already
                        ; (not make sure repeatedly)
    int     31h
    jc      error_exit  ; in the case of failed  ->jmp

    push    es
    mov     es,ax
    mov     al,byte ptr es:[101h]           ; get system info
    and     al,80h
    mov     byte ptr bClockFlag,al          ; save clock
    pop     es
endif   ; NEC_98

    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     enable_386

    ; running under win286
enable_286:
    call    Enable286
    jmp     enable_done

    ; running under win386
enable_386:
    call    Enable286

enable_done:
    ret     2

ifdef   NEC_98
error_exit:
    dec     wEnabled       ; mark as being enabled
    xor     ax,ax
    ret 2
endif   ; NEC_98

cEnd nogen

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public LibInit
LibInit proc far

    ; CX    = size of heap
    ; DI    = module handle
    ; DS    = automatic data segment
    ; ES:SI = address of command line (not used)

    jcxz    lib_heapok	    ; heap size zero? jump over unneeded LocalInit call

    cCall   LocalInit,<ds,ax,cx>    ; dataseg, 0, heapsize
    or	    ax,ax
    jnz     lib_heapok	    ; if heap set continue on

lib_error:
    xor     ax,ax
    ret 		    ; return FALSE (ax = 0) -- couldn't init

lib_heapok:
    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     lib_386

    ; running under win286
lib_286:
    call    Lib286Init
    jmp     lib_realdone    ; win 286 will enable timer on first event request

    ; running under win386
lib_386:
    call    Lib286Init

lib_realdone:
    ret

LibInit endp

sEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Win 386 timer VTD code for initialization, and removal
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP        GetVersion          ; in KERNEL
        externFP        MessageBox          ; in USER
        externFP        LoadString          ; in USER

sBegin  CodeInit
assumes cs,CodeInit
assumes ds,Data

;externNP    VTDAPI_GetEntryPt

; Assumes DI contains module handle
cProc WarningMessage <NEAR,PASCAL> <>
    LocalV aszErrorTitle, 32
    LocalV aszErrorMsg, 256
cBegin
    lea     ax, WORD PTR aszErrorTitle
    cCall   LoadString, <di, IDS_ERRORTITLE, ss, ax, 32>
    lea     ax, WORD PTR aszErrorMsg
    cCall   LoadString, <di, IDS_ERRORTEXT, ss, ax, 256>
    lea     ax, WORD PTR aszErrorTitle
    lea     bx, WORD PTR aszErrorMsg
    cCall   MessageBox, <NULL, ss, bx, ss, ax, MB_SYSTEMMODAL+MB_OK+MB_ICONHAND>
cEnd

if 0
Lib386Init proc near

    call    VTDAPI_GetEntryPt       ; this will return 0 if the VxD is not loaded

    or      ax,ax
    jnz     Lib386InitOk

ifndef  NEC_98
    DOUT    <TIMER: *** unable to find vtdapi.386 ***>
endif   ; NEC_98

    ;
    ;   warn the USER that we can't find our VxD, under windows 3.0
    ;   we can't bring up a message box, so only do this in win 3.1
    ;

    cCall   GetVersion
    xchg    al,ah
    cmp     ax,030Ah
    jb      Lib386InitFail

    cCall   WarningMessage,<>

Lib386InitFail:
    xor     ax,ax

Lib386InitOk:

    ret

Lib386Init endp
endif

Disable386 proc near

    errn$   Enable386               ; fall through

Disable386 endp

Enable386 proc near

    mov     ax,1		    ; nothing to do
    ret

Enable386 endp

sEnd	Code386

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Win 286 timer drv code for initialization, and removal
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    externW     Events
    externFP    tddISR                  ; in local.asm

    externFP    GlobalWire              ; in KERNEL
    externFP    GlobalPageLock          ; in KERNEL

sBegin  CodeInit
    assumes cs,CodeInit
    assumes ds,Data

Lib286Init proc near
    ; get the system configuration

    ;
    ;   the FIXED_286 segment is not loaded, load it and pagelock it.
    ;
    mov     dx,seg tddISR               ; get the 286 code segment
    mov     es,dx
    mov     ax,es:[0]                   ; load it!
    cCall   GlobalWire, <dx>            ; get it low in memory
    cCall   GlobalPageLock, <dx>        ; and nail it down!

ifndef  NEC_98
    mov     PS2_MCA,0			; Initialize PS2_MCA = FALSE
    stc					; Set this in case BIOS doesn't
    mov     ah,GetSystemConfig
    int     15h
    jc      Lib286Init_NoMicroChannel	; Successful call?
    or      ah,ah			; Valid return?
    jnz     Lib286Init_NoMicroChannel
    test    es:[bx.SD_feature1],SF1_MicroChnPresent
    jz      Lib286Init_NoMicroChannel
    inc     PS2_MCA			; PS2_MCA = TRUE
endif   ; NEC_98
Lib286Init_NoMicroChannel:

    push    di

    push    ds
    pop     es
    mov     di,DataOFFSET Events	; ES:DI --> Events
    xor     ax,ax
    mov     cx,(MAXEVENTS * SizeEvent)/2
    rep     stosw			; zero out event structures.

    ; set up one event as the standard call-back routine for the
    ; BIOS timer service
    ;
ifdef   NEC_98
    mov     ax,0002h
    mov     bx,0040h
    int     31h
    jc      error_init
    push    es
    mov     es,ax
    test    byte ptr es:[101h],80h
    pop     es
    mov     cx,0f000h
    jz      @f
    mov     cx,0c300h
@@:
    xor     bx,bx
else    ; NEC_98
    xor     bx,bx			; BX:CX = 64k
    xor     cx,cx
    inc     bx
endif   ; NEC_98

    mov     di,DataOFFSET Events	; DS:DI --> Events

    mov     [di].evTime.lo,cx		; Program next at ~= 55ms
    mov     [di].evTime.hi,bx		; standard 18.2 times per second event
    mov     [di].evDelay.lo,cx		; First event will be set off
    mov     [di].evDelay.hi,bx		; at 55ms (65536 ticks)
    mov     [di].evResolution,TDD_MINRESOLUTION	; Allow 55ms either way
    mov     [di].evFlags,TIME_BIOSEVENT+TIME_PERIODIC

    mov     ax,WinFlags
    test    ax,WF_CPU286
    jz      @f
    mov     wMaxResolution,TDD_MAX286RESOLUTION
    mov	    wMinPeriod,TDD_MIN286PERIOD
@@:
ifdef   NEC_98
    mov     ax,0001h
else    ; NEC_98
    mov     ax,bx                       ; Return TRUE
endif   ; NEC_98
    mov     [di].evID,ax		; enable event

    pop     di
    ret

ifdef   NEC_98
error_init:
    xor     ax,ax
    pop     di
    ret
endif   ; NEC_98

Lib286Init endp

sEnd

    end LibInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\api.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   API.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   Contains the routine tddMessage which communicates to either
;   the 386 timer API's of the 286 timer API's depending on the
;   WinFlags settings WF_WIN286,WF_WIN386.
;
;
;   Revision history:
;
;   2/12/90	     First created by w-glenns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1	; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmsystem.inc
include mmddk.inc
include timer.inc
.list

	.286p

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   External functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externFP    Enable
externFP    Disable

ifdef DEBUG
externFP    tddGetTickCount
endif

externFP    tddSetTimerEvent
externFP    tddKillTimerEvent
externFP    tddGetSystemTime
externFP    tddGetDevCaps
externFP    tddBeginMinPeriod
externFP    tddEndMinPeriod

;externFP    vtdSetTimerEvent
;externFP    vtdKillTimerEvent
;externFP    vtdGetSystemTime
;externFP    vtdGetDevCaps
;externFP    vtdBeginMinPeriod
;externFP    vtdEndMinPeriod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externA     WinFlags

sBegin  Data

        externW     wEnabled

	errnz  <TDD_KILLTIMEREVENT-DRV_RESERVED>
	errnz  <TDD_SETTIMEREVENT-4-DRV_RESERVED>
	errnz  <TDD_GETSYSTEMTIME-8-DRV_RESERVED>
	errnz  <TDD_GETDEVCAPS-12-DRV_RESERVED>
	errnz  <TDD_BEGINMINPERIOD-16-DRV_RESERVED>
	errnz  <TDD_ENDMINPERIOD-20-DRV_RESERVED>

	tblCall286  dd tddKillTimerEvent,tddSetTimerEvent,tddGetSystemTime,tddGetDevCaps,tddBeginMinPeriod, tddEndMinPeriod
	tblCall386  dd tddKillTimerEvent,tddSetTimerEvent,tddGetSystemTime,tddGetDevCaps,tddBeginMinPeriod, tddEndMinPeriod
;       tblCall386  dd vtdKillTimerEvent,vtdSetTimerEvent,vtdGetSystemTime,vtdGetDevCaps,vtdBeginMinPeriod, vtdEndMinPeriod
        tblCallLen  equ ($-tblCall286)/2

ifdef DEBUG
        externD     RModeIntCount
        externD     PModeIntCount
endif

sEnd    Data

sBegin  CodeFixed
        assumes cs,CodeFixed
        assumes ds,Data
	assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api DWORD | DriverProc | Pass messages to functions that really do work
;
;   @parm DWORD | nDevice | The id of the device to get the message.
;
;   @parm WORD | msg | The message.
;
;   @parm LONG | lParam1 | Parameter 1.
;
;   @parm LONG | lParam2 | Parameter 2.
;
;   @rdesc The return value depends on the message being sent.
;
;   @comm Devices not supporting a message should return 0.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;   driver message handler table
;
;   These two tables define which routine handles which driver message.
;
;   NOTE WARNING: ProcTbl must IMMEDIATELY follow MsgTbl.
;
MsgTbl  dw      TDD_GETSYSTEMTIME
        dw      TDD_BEGINMINPERIOD
        dw      TDD_ENDMINPERIOD
        dw      TDD_KILLTIMEREVENT
        dw      TDD_SETTIMEREVENT
        dw      TDD_GETDEVCAPS

        dw      DRV_LOAD
        dw      DRV_OPEN
        dw      DRV_CLOSE
        dw      DRV_ENABLE
        dw      DRV_DISABLE
        dw      DRV_QUERYCONFIGURE
        dw      DRV_INSTALL
ifdef DEBUG
        dw      TDD_GETTICK
        dw      TDD_GETRINTCOUNT
        dw      TDD_GETPINTCOUNT
endif
        dw      -1

MsgLen  equ     $-MsgTbl

ProcTbl dw	msg_TDD_GETSYSTEMTIME	; TDD_GETSYSTEMTIME
	dw	msg_TDD_BEGINMINPERIOD	; TDD_BEGINMINPERIOD
	dw	msg_TDD_ENDMINPERIOD	; TDD_ENDMINPERIOD
	dw	msg_TDD_KILLTIMEREVENT	; TDD_KILLTIMEREVENT
	dw	msg_TDD_SETTIMEREVENT	; TDD_SETTIMEREVENT
	dw	msg_TDD_GETDEVCAPS	; TDD_GETDEVCAPS
                                        ;
        dw      msg_DRV_LOAD            ; DRV_OPEN
	dw	msg_DRV_OPEN		; DRV_OPEN
	dw	msg_DRV_CLOSE		; DRV_CLOSE
	dw	msg_DRV_ENABLE		; DRV_ENABLE
	dw	msg_DRV_DISABLE 	; DRV_DISABLE
        dw      msg_DRV_QUERYCONFIGURE  ; DRV_QUERYCONFIGURE
        dw      msg_DRV_INSTALL		; DRV_INSTALL
ifdef DEBUG
        dw      msg_TDD_GETTICK         ; TDD_GETTICK
        dw      msg_TDD_GETRINTCOUNT    ; TDD_GETRINTCOUNT
        dw      msg_TDD_GETPINTCOUNT    ; TDD_GETPINTCOUNT
endif
        dw      msg_fail                ; default

ProcLen equ     $-ProcTbl

errnz   <ProcLen-MsgLen>                ; these had better be the same!
errnz   <ProcTbl-MsgTbl-MsgLen>         ; ProcTbl *must* follow MsgTbl

cProc DriverProc <PUBLIC,FAR,LOADDS> <di>
	ParmD	id
	ParmW	hDriver
	ParmW	msg
	ParmD	lParam1
	ParmD	lParam2
cBegin
	mov	ax,cs			; es == Code
	mov	es,ax
        assumes es,CodeFixed

	mov	ax,msg			; AX = Message number
	cmp	ax,DRV_RESERVED 	; messages below DRV_RESERVED dont
	jl	msg_dispatch		; ...need driver to be enabled

	cmp	wEnabled,0		; must be enabled for msgs > DRV_RESERVED
	jz	msg_error

msg_dispatch:
        mov     di,CodeFixedOFFSET MsgTbl
	mov	cx,MsgLen/2
	cld
	repnz	scasw
	lea	bx,[di+MsgLen-2]
	jmp	cs:[bx]
	assumes es,nothing

msg_error:
	mov	ax, TIMERR_NOCANDO
	jmp	short msg_makelong

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; handle std. installable driver messages.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
msg_DRV_ENABLE:
	cCall	Enable, <ax>		    ; enable driver
	jmp	short msg_makelong

msg_DRV_DISABLE:
	cCall	Disable, <ax>
	jmp	short msg_makelong

msg_DRV_LOAD:
msg_DRV_OPEN:
msg_DRV_CLOSE:
msg_success:
	mov	ax,1			    ; return 1 for all others
	jmp	short msg_makelong

msg_fail:
msg_DRV_QUERYCONFIGURE:
	xor	ax, ax			    ; no - return 0
	jmp	short msg_makelong

msg_DRV_INSTALL:
	mov	ax, DRVCNF_RESTART	    ; restart after install
	errn$	msg_makelong

msg_makelong:
	cwd				    ; make sure high word (dx) is set
        jmp     short msg_done

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; handle timer driver specific massages
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
ifdef DEBUG
msg_TDD_GETTICK:
        cCall   tddGetTickCount
        jmp     short msg_done

msg_TDD_GETRINTCOUNT:
        mov     ax,RModeIntCount.lo
        mov     dx,RModeIntCount.hi
        jmp     short msg_done

msg_TDD_GETPINTCOUNT:
        mov     ax,PModeIntCount.lo
        mov     dx,PModeIntCount.hi
        jmp     short msg_done
endif

msg_TDD_GETDEVCAPS:
	push	lParam1.hi
	push	lParam1.lo
	push	lParam2.lo
	jmp	short msg_call

msg_TDD_SETTIMEREVENT:
	push	lParam1.hi

msg_TDD_BEGINMINPERIOD:
msg_TDD_ENDMINPERIOD:
msg_TDD_KILLTIMEREVENT:
	push	lParam1.lo

msg_TDD_GETSYSTEMTIME:
	errn$	msg_call

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
msg_call:
	sub	ax,DRV_RESERVED 	    ; map msg into table index
	mov	di,offset DGROUP:tblCall286
	add	di,ax
	mov	ax,WinFlags
	test	ax,WF_WIN386
	jz	@f			    ; jump if not win386
	add	di,tblCallLen
@@:	call	dword ptr [di]		    ; index into table
	errn$	msg_done

msg_done:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\startend.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   STARTEND.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the routines which initialize, and clean
;   up the driver after Libentry/WEP/Enable/Diable called by windows.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1

	PMODE=1
	.xlist
	include  cmacros.inc
        include  int31.inc
	include  windows.inc
        include  mmddk.inc
	include  mmsystem.inc
	include  timer.inc
        .list

        externA     __WinFlags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin DATA

	; ISR support

	public	lpOLDISR
	lpOldISR    dd	?

ifdef RMODE_INT
        public  RModeOldISR
        RModeOldISR   dd  0

        public  RModeCodeSegment
        RModeCodeSegment dw ?

endif   ;RMODE_INT

	externW     Events
	externW     wNextTime
ifdef   NEC_98
        externB     bClockFlag                  ; 5Mhz = 0 ; 8Mhz = other
endif   ; NEC_98

sEnd DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP    tddISR                      ; in local.asm
        externFP    tddSetInterruptPeriodFar    ; in timer.asm

ifdef   RMODE_INT
        externW     RmodeDataSegment            ; in local.asm
        externFP    tddRModeISR                 ; in local.asm
endif
        externFP    GetSelectorBase             ; kernel
        externFP    AllocCStoDSAlias            ; kernel
        externFP    FreeSelector                ; kernel

sBegin  CodeInit
        assumes cs,CodeInit
        assumes ds,Data
        assumes es,nothing

;----------------------------Private-Routine----------------------------;
; SegmentFromSelector
;
;   Converts a selector to a segment...note that this routine assumes
;   the memory pointed to by the selector is below the 1Meg line!
;
; Params:
;   AX = selector to convert to segment
;
; Returns:
;   AX = segment of selector given
;
; Error Returns:
;   None
;
; Registers Destroyed:
;   none
;
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SegmentFromSelector proc near

    cCall   GetSelectorBase,<ax>        ;DX:AX = base of selector
rept 4
    shr     dx,1
    rcr     ax,1
endm
    ;AX now points to *segment* (iff selector is based below 1Mb)

    ret

SegmentFromSelector endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api WORD | Enable | This function enables the driver.  It
;       will hook interrupts and validate the hardware.
;
;   @rdesc Returns 1 if successfull, and 0 otherwise.
;
;   @comm This function is automatically invoked when the library is
;       first loaded. It is included so that win386 could call it
;       when it switches VMs.
;
;   @xref Disable
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cProc Enable286 <FAR, PUBLIC> <si, di>

cBegin
	; make sure clock interrupts are disabled until after
	; service routine has been initialized!!
	AssertSLI
	cli

	; get the currently owned timer interrupt vector

	; get interrupt vector, and specify timer interrupt number
;       mov	ax,03500H + TIMERINTERRUPT
;       push	es
;       int	21h 			; get the current vector in ES:BX
;       mov	lpOldISR.Sel,es
;       mov	lpOldISR.Off,bx		; save the old vector
;       pop	es
;
;       ; set vector to our isr
;
;       ; set interrupt vector function, and specify the timer interrupt number
;       mov	ax,02500h + TIMERINTERRUPT
;       push	ds
;       mov     dx,seg tddISR
;       mov	ds,dx
;       assumes	ds,nothing
;       mov     dx,offset tddISR
;       int	21h			; set the new vector
;       pop	ds
;       assumes	ds,DATA
;
;       mov	ax,[wNextTime]
;       not	ax
;       mov	[wNextTime],ax		; force set of period
;       call    tddSetInterruptPeriodFar

ifdef	RMODE_INT
	;
	; if running under DOSX set the RMODE interrupt too
	;
	mov	ax,__WinFlags
	test	ax,WF_PMODE
	jz	enable_no_dosx

	mov	ax,seg tddRModeISR
	call	SegmentFromSelector

	or	dx,dx		; ACK! above 1Mb
	jnz	enable_no_dosx

	mov	[RModeCodeSegment],ax	; save the segment of the code segment

	mov	ax,ds			; get SEGMENT of our data segment
	call	SegmentFromSelector
	push	ax			; save on stack

	mov	ax,seg tddRModeISR	; write data SEGMENT into _INTERRUPT
	cCall	AllocCStoDSAlias,<ax>	; code segment -- requires a data alias
	mov	es,ax
	pop	ax
	mov	es:[RModeDataSegment],ax
	cCall	FreeSelector,<es>	; don't need CS alias any longer

	mov	ax,Get_RM_IntVector	; get the real mode IRQ0 vector
	mov	bl,DOSX_IRQ + TIMERINTERRUPT
	int	31h			; DOSX get real mode vector in CX:DX

	mov	RModeOldISR.lo,dx	; save old ISR
	mov	RModeOldISR.hi,cx

	mov	cx,RModeCodeSegment	; CX:DX --> real mode ISR
	mov	dx,offset tddRModeISR

	mov	ax,Set_RM_IntVector	; DOSX Set Vector Function
	int	31h			; Set the DOS vector real mode

enable_no_dosx:
endif
	sti

	mov	ax,1
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api WORD | Disable | This function disables the driver.
;	It disables the hardware, unhooks interrupts and removes
;	all time events from the queue.
;
;   @rdesc Returns 1 if successfull, and 0 otherwise.
;
;   @comm This function is called automatically when Windows unloads
;       the library and invokes the WEP() function.  It is included
;       here so that WIN386 can use it when switching VMs.
;
;   @xref Enable
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


cProc Disable286 <FAR, PUBLIC> <si, di>

    ; note that all this is in the reverse order to Enable

cBegin
    AssertSLI
    cli
ifdef   NEC_98
    setmask TIMERMASK
    mov     al,36h
    out     timodeset,al                ; Timer mode set
    delay   8253,O-O
    mov     ax,0f000h                   ; count(25msec * 2457.6)
    cmp     byte ptr bClockFlag,00h     ; Q : clock 5 MHz ?
    jz      @f                          ; 5MHz,10MHz,12MHz,20MHz,25MHz set
    mov     ax,0c300h                   ; 8MHz,16MHz set
@@:
    out     ticntset,al
    delay   8253,O-O
    xchg    ah,al
    out     ticntset,al
    unmask  TIMERMASK
else    ; NEC_98
    ; set timer back to 55ms BIOS service
    xor     cx,cx		; 65536 ticks per period

    mov     al,TMR_MODE3_RW	; Read/Write counter 0 mode 3 (two bytes)
    out     TMR_CTRL_REG,al

    mov     al,cl
    out     TMR_CNTR_0,al	; write low byte

    mov     al,ch
    out     TMR_CNTR_0,al       ; write high byte
endif   ; NEC_98

ifdef RMODE_INT
    ;
    ; check for a REAL mode int handler and un-hook it.
    ;
    mov     dx,RModeOldISR.lo
    mov     cx,RModeOldISR.hi
    jcxz    disable_no_dosx

    mov     bl,DOSX_IRQ + TIMERINTERRUPT
    mov     ax,Set_RM_IntVector     ;DOSX Set Vector Function
    int     31h                     ;Set the DOS vector real mode

disable_no_dosx:
endif

    ; restore the old interrupt vector

    mov     ax,02500h + TIMERINTERRUPT
    ; set interrupt vector function, and specify the timer interrupt number

    push    ds
    lds     dx,lpOldISR
    assumes ds,nothing
    int     21h 		; reset the old vector
    pop ds
    assumes ds,DATA

    sti
    mov     ax,1
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\sysinfo.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	sysinfo.inc - structure & equates for INT 15h service 0C0h
;
;   Version:	1.00
;
;   Date:	28-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Mar-1989 RAP
;
;==============================================================================

; System Descriptor Structure returned from INT 15h, service C0h

SysDescStruc STRUC
SD_len	    dw	?
SD_model    db	?
SD_submodel db	?
SD_ROM_rev  db	?
SD_feature1 db	?
SD_feature2 db	?
SD_feature3 db	?
SD_feature4 db	?
SD_feature5 db	?
SysDescStruc ENDS


; Feature byte 1 bits assignments:

SF1_FD_uses_DMA3	= 10000000b
SF1_FD_uses_DMA3_bit	= 7
SF1_PIC_2_present	= 01000000b
SF1_PIC_2_present_bit	=  6
SF1_RealTimeClock	= 00100000b
SF1_RealTimeClock_bit	=   5
SF1_INT15s_called	= 00010000b
SF1_INT15s_called_bit	=    4
SF1_ExtEventWait	= 00001000b
SF1_ExtEventWait_bit	=     3
SF1_EBIOS_allocated	= 00000100b
SF1_EBIOS_allocated_bit =      2
SF1_MicroChnPresent	= 00000010b
SF1_MicroChnPresent_bit =	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\timer.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	TIMER.ASM
;
;	Copyright (c) Microsoft Corporation 1991. All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


?PLM=1	; pascal call convention
?WIN=0	; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
.list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   External functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externNP	GetCounterElement

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin DATA

externW	CurTime
externW	nInt8Count
externW	wProgTime
externW	wNextTime
externW	IntCount
externD	dTickUpdate
ifdef   NEC_98
        externB bClockFlag
endif   ; NEC_98

public	Events,wNextID

;	This structure is used in keeping track of all the current events,
;	including any BIOS event.
;
Events	EventStruct MAXEVENTS DUP (<>)

;	This value is used as an ever incrementing counter that is OR'ed into
;	handles returned from <f>tddSetTimerEvent<d>.  This is so that events
;	can be uniquely identified in <f>tddKillTimerEvent<d>.
;
wNextID         dw	0

;
;	The following is a table of timer resolution byte counters.  Each entry
;	N represents an interest in having the timer resolution set to N+1 MS.
;	Thus there are TDD_MAX386RESOLUTION to TDD_MINRESOLUTION entries to
;	represent 1..55 MS.  Each time <f>tddBeginMinPeriod<d> is called with
;	a timer period, the appropriate entry is incremented, and each time
;	<f>tddEndMinPeriod<d> is called with a timer period, that entry is
;	decremented.  Presumably there is a one to one match on the Begin and
;	End minimum period calls.
;
;	This is of course all a workaround for the fact that the timer chip
;	cannot be immediately reprogrammed the way it is wired in PCs in the
;	mode in which it needs to be run, thus a separate resolution table
;	must be kept in order to allow applications to set up a minimum
;	resolution before actually setting any events.
;
tddIntPeriodTable	db	TDD_MINRESOLUTION dup (0)

public	wMaxResolution,wMinPeriod
wMaxResolution	dw	TDD_MAX386RESOLUTION
wMinPeriod	dw	TDD_MIN386PERIOD

sEnd DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin	Code286
	assumes cs,Code286
	assumes ds,data
	assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Public exported functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddBeginMinPeriod |
;	Increments sets the specified resolution in the table of period
;	resolutions.  This optionally programming the timer for a new
;	higher resolution if the parameter passed is a new minimum.
;
;@parm	WORD | wPeriod |
;	Contains a resolution period from wMaxResolution through 55
;	milliseconds.
;
;@rdesc	Returns 0 for success, else TIMERR_NOCANDO if the resolution period
;	passed was out of range.
;
;@uses	ax,bx,dx.
;
;@xref	tddEndMinPeriod,tddSetInterruptPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
	assumes ds,Data

cProc	tddBeginMinPeriod <PUBLIC,FAR> <>
	parmW	wPeriod
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to error return

	mov	bx,wPeriod
	cmp	bx,[wMaxResolution]
	jb	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
	cmp	bx,TDD_MINRESOLUTION
	ja	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
	dec	bx			; Zero based resolution slot entries
	cmp	tddIntPeriodTable[bx],0FFh
ifdef DEBUG
	jne	tddBeginMinPeriodInRange
        inc     bx			; Show correct period in error
	DOUT	<tddBeginMinPeriod(#bx) overflow>
	jmp	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
tddBeginMinPeriodInRange:
else
	je	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
endif

	inc	tddIntPeriodTable[bx]	; Increment resolution[entry - 1]
	cmp	tddIntPeriodTable[bx],1	; Don't set period if entry is >1
	jne	@f
	call	tddSetInterruptPeriod
@@:
	xor	ax,ax			; Return ok (FALSE)

tddBeginMinPeriodExit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddEndMinPeriod |
;	Decrements the specified resolution in the table of period resolutions
;	that was presumably set previously with a <f>tddBeginMinPeriod<d> call.
;	This optionally programming the timer for a new lower resolution if
;	the parameter passed removed the current minimum.
;
;@parm	WORD | wPeriod |
;	Contains a resolution period from 1 through 55 milliseconds.
;
;@rdesc	Returns 0 for success, else TIMERR_NOCANDO if the resolution period
;	passed was out of range.
;
;@uses	ax,bx,dx.
;
;@xref	tddBeginMinPeriod,tddSetInterruptPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
	assumes ds,Data

cProc	tddEndMinPeriod <PUBLIC,FAR> <>
	parmW	wPeriod
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to error return

	mov	bx,wPeriod
	cmp	bx,[wMaxResolution]
	jb	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
	cmp	bx,TDD_MINRESOLUTION
	ja	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
	dec	bx			; Zero based resolution slot entries
	cmp	tddIntPeriodTable[bx],0
ifdef DEBUG
	jne	tddEndMinPeriodInRange
        inc     bx			; Show correct period in error
	DOUT	<tddEndMinPeriod(#bx) underflow>
	jmp	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
tddEndMinPeriodInRange:
else
	je	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
endif

	dec	tddIntPeriodTable[bx]	; Decrement resolution[entry - 1]
	jnz	@f			; No need to set interrupt period
	call	tddSetInterruptPeriod
@@:
	xor	ax,ax			; Return ok (FALSE)

tddEndMinPeriodExit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@func	void | tddSetInterruptPeriod |
;	This function optionally programs the timer with a new interrupt
;	period if the maximum resolution in the resolution table has changed.
if 0	; !!!
;
;	If the function is being called outside of interrupt time, the function
;	must first turn off interrupts so that the resolution table is not
;	changed between the time the the function finds a resolution to set,
;	and the time it starts to program the timer.  Once the timer begins to
;	be programmed, it won't send any more interrupts until programming is
;	finished.  The documentation does not specify that, but it was verified
;	through testing the timer.  If however the function is being called
;	during a timer interrupt, there is no need to turn off interrupts, as
;	the resolution table will not be changed at that time.
;
endif
;	In any case, the resolution table is searched, looking for the first
;	non-zero entry, which is taken as the maximum resolution the timer
;	should currently be programmed to.  If nothing is set in the table,
;	then the programming defaults to the minimum resolution of 55 MS.
;
;	Once an entry is found, it is compared to the previous programmed
;	time, not the currently programmed time.  This is in case an interrupt
;	has not occurred since the last time the timer was programmed using
;	this function.  Note that in converting to clock ticks, any period
;	that overflows a single word is taken to be 65536 ticks, which is the
;	maximum number allowable in the timer, and is equal to almost 55 MS.
;
;	If a new time must be programmed, the new resolution is sent out to
;	the timer, and eventually interrupts are set again.
;
;@rdesc	Nothing.
;
;@uses	ax,bx,dx.
;
;@xref	tddBeginMinPeriod,tddEndMinPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
        assumes ds,Data

cProc   tddSetInterruptPeriodFar <PUBLIC,FAR> <>
cBegin
        call tddSetInterruptPeriod
cEnd

cProc	tddSetInterruptPeriod <PUBLIC,NEAR> <>

cBegin
	xor	bx, bx			; Start at the beginning of the table

	EnterCrit			; !!!

tdd_sip_loop:
	cmp	bx,TDD_MINRESOLUTION	; Has the last entry been passed up?
	je	tdd_sip_Set_This_Period	; Jump out using TDD_MINRESOLUTION
	inc	bx
	cmp	tddIntPeriodTable[bx-1],0
	je	tdd_sip_loop

tdd_sip_Set_This_Period:
	mov	ax,bx
	call	tddMsToTicks

	or	dx,dx			; Check for overflow of WORD
ifdef   NEC_98
        jz      short @f
        mov     ax,0ffffh
@@:
        cmp     byte ptr bClockFlag,0
        mov     dx,0f000h               ; 5MHz tick count
        jz      @f
        mov     dx,0c300h               ; 8MHz tick count
@@:
        cmp     ax,dx
        jc      tdd_sip_period_ok
        mov     ax,dx                   ; Set to 25msec tick count
else    ; NEC_98
	jz	tdd_sip_period_ok
	xor	ax,ax                   ; Set to 64k instead.
endif   ; NEC_98
tdd_sip_period_ok:

	cmp	ax,[wNextTime]		; Compare with last programmed time
	je	tdd_sip_exit		; No need to reprogram

	DOUT	<tddSetInterruptPeriod: ms=#bx ticks=#ax>

	mov	bx,ax			; Save this value
	mov	[wNextTime],bx		; This is now the last programmed time

	mov	al, TMR_MODE2_RW	; Set counter 0 to mode 2
	out	TMR_CTRL_REG, al

	mov	al, bl
	out	TMR_CNTR_0, al
	mov	al, bh
	out	TMR_CNTR_0, al

tdd_sip_exit:
	LeaveCrit			; !!!
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddSetTimerEvent |
;	Adds a timer event, possibly periodic to the event queue.
;
;	A timer event is set by first looking through the table of external
;	event slots, trying to locate a currently vacant slot that is not
;	currently being checked or deleted.  If one is found, the Create flag
;	is test-and-set in order to try and grab the slot.
;
;	If this succeeds, the slot can be set up with the information, and the
;	resolution entered into the event resolution table.  The very last
;	thing that occurs is setting the ID element of the slot.  This is so
;	that an inturrupt will not try to execute this event until all the
;	parameters are set.  This means that the event could be executed
;	immediately after the ID is set, but before this function actually
;	returns to the caller.
;
;	If the function fails to grab the event slot, it means that either an
;	interrupt occurred, and another event was created in this slot, or that
;	this function is running during an interrupt that occurred while a new
;	event was being created.  In any case, the slot must be passed by.
;
;	If an interrupt had occurred during this function, it also means that
;	some other event could have been freed, but already passed by, so the
;	function misses it.  The function cannot go back though, because it
;	might actually be processing during an interrupt, and the slot being
;	passed by would continue in its present state, and thus cause an
;	infinite loop to occur.
;
;	When checking for a free event slot, not only is the ID checked, but
;	also the state of the Destroy flag.  This flag is used during the kill
;	event function to indicate that an event slot is currently being
;	checked or destroyed, or was destroyed during an interrupt while the
;	slot was being checked.  In either case, it indicates that this
;	function is being called during interrupt time, and the slot cannot be
;	re-used until the flag is removed by the kill event function.  This
;	means that during the kill event function, there is one less event
;	slot that can be used than normal.
;
;	Once the ID of the event slot is set, the event can be called.  Note
;	that the event may then be called before this function even returns.
;
;@rdesc	Returns a handle which identifies the timer event, or NULL if the
;	requested event is invalid, or the event queue is full.
;
;@xref	tddKillTimerEvent
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddSetTimerEvent <PUBLIC,FAR> <si,di,es>
	parmD	pTIMEREVENT
	localW	wResolution
	localW	wEventID
cBegin
	les	si,pTIMEREVENT		; timer event structure
	mov	ax,es
	or	ax,si
	; (pTIMEREVENT != NULL)
	jz	SetEventError		; NULL pointer, exit

	mov	bx,es:[si].te_wDelay

	; ((te_wDelay >= wMinPeriod) && (te_wDelay <= TDD_MAXPERIOD))
	cmp	bx,[wMinPeriod]		; delay less than min period?
	jb	SetEventError		; Yes, error

	cmp	bx,TDD_MAXPERIOD	; delay greater than max period?
	ja	SetEventError		; Yes, error

	; (!te_wResolution)
	mov	ax,es:[si].te_wResolution
	or	ax,ax			; resolution not set?
	jz	SetDefaultResolution	; Yes, set default resolution

	; ((te_wResolution >= TDD_MINRESOLUTION) && (te_wResolution <= wMaxResolution))
	cmp	ax,TDD_MINRESOLUTION	; resolution less than min resolution?
	jb	@f			; No, skip to next check
	mov	ax,TDD_MINRESOLUTION

@@:
	cmp	ax,[wMaxResolution]	; resolution greater than max resolution?
	ja	@f			; No, skip to next check
	mov	ax,[wMaxResolution]

@@:
	; (te_wResolution > te_wDelay)
	cmp	bx,ax			; delay less than resolution?
	jb	SetDefaultResolution	; Yes, set default resolution

	jmp	short SetEventValidParms

SetEventError:
	xor	ax,ax			; Return NULL
	jmp	SetEventExit

SetDefaultResolution:
	; te_wResolution = min(TDD_MINRESOLUTION, te_wDelay)
	mov	ax,TDD_MINRESOLUTION
	cmp	bx,ax			; delay less than min resolution?
	ja	SetEventValidParms  	; No, just use min resolution then
	mov	ax,bx			; Yes, use the period as the resolution

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
SetEventValidParms:
	mov	wResolution,ax		; save calculated resolution

	lea	di,Events		; DS:DI --> events
	xor	ax,ax			; event slot = 0

SetEventFindLoop:
	; if (!pEvent->evID && !pEvent->evDestroy)
	cmp	[di].evID,0
	jne	SetEventFindLoopNext
	cmp	BYTE PTR [di].evDestroy,0
	jne	SetEventFindLoopNext
	mov	bl,1
	xchg	BYTE PTR [di].evCreate,bl	; Test and set Create flag
	or	bl,bl
	jz	SetEventFindLoopFound

SetEventFindLoopNext:
	; pEvent++, wEventID++
	add	di,SizeEvent
	inc	ax
	; wEventID < MAXEVENTS
	cmp	ax,MAXEVENTS
	jb	SetEventFindLoop

	; Return NULL
	xor	ax,ax			; Slot not found, return NULL
	jmp	SetEventExit
	
SetEventFindLoopFound:
	;
	; combine the slot index and wNextID to produce a unique id to
	; return to the caller
	;
	add	[wNextID],MASKINCREMENT
	jz	SetEventFindLoopFound		; Ensure a non-zero mask
	or	ax,[wNextID]			; Add in the mask
	mov	wEventID,ax			; Save the event
	errnz	MAXEVENTS-16

	; tddBeginMinPeriod(pEvent->evResolution)
	mov	ax,wResolution
	mov	[di].evResolution,ax
	cCall	tddBeginMinPeriod <ax>

	; pEvent->evDelay = tddMsToTicks(pTIMEREVENT->te_wDelay)
	mov	ax,es:[si].te_wDelay
	call	tddMsToTicks
	mov	[di].evDelay.lo,ax
	mov	[di].evDelay.hi,dx

	; pEvent->evCallback = pTIMEREVENT->te_lpFunction
	mov	ax,es:[si].te_lpFunction.lo
	mov	dx,es:[si].te_lpFunction.hi
	mov	[di].evCallback.lo,ax
	mov	[di].evCallback.hi,dx

	; pEvent->evUser = pTIMEREVENT->te_dwUser
	mov	ax,es:[si].te_dwUser.lo
	mov	dx,es:[si].te_dwUser.hi
	mov	[di].evUser.lo,ax
	mov	[di].evUser.hi,dx

	; pEvent->evFlags = pTIMEREVENT->te_wFlags
	mov	ax,es:[si].te_wFlags
	mov	[di].evFlags,ax

@@:
	mov	bx,[IntCount]		; check for interrupt occurring
	call	GetCounterElement	; Get number of ticks passed
	xor	cx,cx
	add	ax,dTickUpdate.lo	; Add extra currently skipped.
	adc	cx,dTickUpdate.hi
	cmp	bx,[IntCount]
	jne	@b			; If interrupt occurred try again
	
	; pEvent->evTime = pEvent->evDelay + GetCounterElement + dTickUpdate
	mov	bx,[di].evDelay.lo
	mov	dx,[di].evDelay.hi
	add	bx,ax
	adc	dx,cx
	mov	[di].evTime.lo,bx
	mov	[di].evTime.hi,dx

	; pEvent->evID = wEventID
	mov	ax,wEventID
	mov	[di].evID,ax
	; Return wEventID

SetEventExit:
	xor	dx,dx
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddKillTimerEvent |
;	Removes a timer event from the event queue.  If the event was periodic,
;	this is the only way to discontinue operation.	Otherwise, this may be
;	used to remove an unwanted one shot event in case of application
;	termination.
;	
;	A timer event it killed by trying to grab the Destroy flag in a two
;	step process, which succeeds only if the function was able to grab
;	the slot before any interrupt destroyed the event.
;
;	After verifying that the event handle is valid, the function checks the
;	Destroy flag to determine if this function is being called during
;	interrupt time, and interrupted another process killing the same
;	timer.  If this is so, the function just aborts before wasting time
;	doing any other flag setting.
;
;	The function then sets the Destroy flag to a EVENT_CHECKING state,
;	grabbing the current state of the flag in order to use when setting
;	the final state of the Destroy flag if the function succeeds.
;
;	If the event handles match, the Destroy flag is set to a
;	EVENT_DESTROYING state.  At this point, the Destroy flag is either in
;	the state in which this function left it, or an interrupt occurred, and
;	the flag was set to a EVENT_DESTROYED state durring interrupt time.  If
;	an interrupt ended up destroying the event out from under this call,
;	the function is exited after clearing the Destroy flag so that the
;	event slot can be used.  Note that the event slot cannot be used until
;	the function exits so that the EVENT_DESTROYED flag is not disturbed.
;
;	If the flag is grabbed, no other call can destroy the event, and the
;	event will not be executed during interrupt time.  As was previously
;	mentioned, the Destroy flag is either reset, or if this function was
;	called during interrupt time while the event was being checked, the
;	flag is set to EVENT_DESTROYED.
;
;	The resolution entered into the event resolution table is removed.
;	The very last thing to occur is resetting the Create flag.  At that
;	point the event slot could be re-used if the Destroy flag was reset.
;
;	Note that if the event handles do not match, the Destroyed flag is also
;	reset so that it can be used in creating a new event when this event
;	is destroyed, which may have happened while checking the handles.
;
;@parm	WORD | wID | The event handle returned by the <f>tddSetTimerEvent<d>
;	function which identifies the event to destroy.
;
;@rdesc	Returns 0 if timer event destroyed, or TIMERR_NOCANDO if the
;	event was not registered in the system event queue.
;
;@xref	tddSetTimerEvent
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddKillTimerEvent <PUBLIC,FAR> <si,di>
	parmW	wID
cBegin
	mov	ax,wID
	and	ax,MASKFILTER			; Remove ID mask first
	errnz	MAXEVENTS-16

	imul	ax,SizeEvent			; Retrieve slot address
	lea	di,Events
	add	di,ax

	; if (pEvent->evDestroy == EVENT_DESTROYING)
	cmp	BYTE PTR [di].evDestroy,EVENT_DESTROYING	; If interrupting a destroy,
	je	KillEventError			; Leave with error

	mov	bl,EVENT_CHECKING
	xchg	BYTE PTR [di].evDestroy,bl	; Test and set Destroy check

	; if (pEvent->evID == wID)
	mov	ax,wID
	cmp	[di].evID,ax
	jne	KillEventRelease		; Wrong ID

	mov	bh,EVENT_DESTROYING
	xchg	BYTE PTR [di].evDestroy,bh	; Test and set Destroying

	cmp	bh,EVENT_CHECKING	; Was destroy interrupted?
	jne	KillEventRelease	; Slot has already been deleted

	mov	[di].evID,0		; Invalidate ID

	cmp	bl,EVENT_CHECKING	; Did this interrupt a destroy?
	jne	@f			; No, was already ZERO
	mov	bl,EVENT_DESTROYED	; Let the interrupted destroy know
@@:
	mov	BYTE PTR [di].evDestroy,bl
	cCall	tddEndMinPeriod,<[di].evResolution>

	; pEvent->evCreate = FALSE
	mov	BYTE PTR [di].evCreate,0	; Free up slot
	xor	ax,ax				; Return 0
	jmp	KillEventExit

KillEventRelease:
	; Free up checking flag
	mov	BYTE PTR [di].evDestroy,0

KillEventError:
	; Invalid ID or was deleted during interrupt time (test and set failed)
	mov	ax,TIMERR_NOCANDO

KillEventExit:
	cwd				; Set to zero
cEnd

	assumes	ds,Data
	assumes	es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public	GetTickCount
GetTickCount	proc near

@@:
	mov	cx,[IntCount]		; Save current interrupt count
	call	GetCounterElement	; Get number of ticks passed

	xor	dx,dx
	xor	bx,bx
	add	ax,CurTime[0]		; Add total tick count to current number past
	adc	dx,CurTime[2]
	adc	bx,CurTime[4]

	cmp	cx,[IntCount]		; Interrupt occurred while getting count
	jne	@b			; Get the count again
	ret
GetTickCount	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddGetSystemTime |
;	Returns a system time in milliseconds.
;
;@rdesc	Returns a 32 bit value in dx:ax representing the number of milliseconds
;	since the timer driver was started.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddGetSystemTime <PUBLIC,FAR> <>

cBegin
	call	GetTickCount
	call	tddTicksToMs
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddGetTickCount |
;	Returns a system time in clock ticks.
;
;@rdesc	Returns a 48 bit value in bx:dx:ax representing the number of clock
;	ticks since the timer driver was started.  A C interface would only
;	be able to access the lower 32 bits of this value.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddGetTickCount <PUBLIC,FAR> <>

cBegin
	call	GetTickCount
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddGetDevCaps |
;	Fills in TIMECAPS structure.
;
;@parm	<t>LPTIMECAPS<d> | lpTIMECAPS |
;	Points to the structure to fill.
;
;@parm	WORD | wSize |
;	Indicates the size of the structure passed.  Normally this should be
;	the size of the <t>TIMECAPS<d> structure this module was compiled with.
;
;@rdesc	Returns 0 on success, or TIMERR_NOCANDO on failure.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,nothing
	assumes es,nothing

cProc	tddGetDevCaps <PUBLIC,FAR> <si,ds>
	parmD	lpTIMECAPS
	parmW	wSize
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to an error state

	cmp	wSize,(SIZE TIMECAPS)	; Check the size of the structure passed
	jne	Caps_Exit

	lds	si,lpTIMECAPS		; timer event structure

	push	ds
	mov	ax,DGROUP
	mov	ds,ax
	assumes	ds,Data
	mov	ax,[wMinPeriod]		; Fill in the structure
	pop	ds
	assumes	ds,nothing

	mov	dx,TDD_MAXPERIOD
	mov	[si].tc_wPeriodMin,ax
	mov	[si].tc_wPeriodMax,dx
	xor	ax,ax			; Return success

Caps_Exit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddTicksToMs |
;	Convert clock ticks (1.19318 MHz) to milliseconds (1000 Hz)
;
;@parm	BX:DX:AX |
;	Tick count to convert to milliseconds.
;
;@rdesc	DX:AX |
;	Converted millisecond count.
;
;@comm	There is a 0.0000005% positive error in the approximation of
;	1193.18 ticks per millisecond by the process to avoid floating point
;	arithmetic, which effectively divides by 1193.179993 instead.
;
;	time `Ms' = clock ticks `T' / 1193.18
;
;	In order to be able to use fixed point, the math actually done is:
;
;	Ms = (T * 10000h) / (DWORD)(1193.18 * 10000h)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddTicksToMs <PUBLIC,NEAR> <si,di>

cBegin
	externNP	qdiv		; In math.asm

; qdiv
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder

	; multiply BX:DX:AX by 10000h and place result in DX:CX:BX:AX for qdiv
	mov	cx,dx
	mov	dx,bx
	mov	bx,ax
	xor	ax,ax

ifdef   NEC_98
        cmp     byte ptr bClockFlag,0
        jnz     set_8Mhz

set_5Mhz:
        ; SI:DI = 2457.6 * 10000h (essentially in 16.16 fixed notation)
        mov     si,2457         ; 2457 * 10000h
        mov     di,39321        ; 0.6 * 10000h = 39321.6
        jmp     short @f

set_8Mhz:
                                ; 8MHz,16MHz set
        ; SI:DI = 1996.8 * 10000h (essentially in 16.16 fixed notation)
        mov     si,1996         ; 1996 * 10000h
        mov     di,52428        ; 0.8 * 10000h = 52428.8
@@:
else    ; NEC_98
	; SI:DI = 1193.18 * 10000h (essentially in 16.16 fixed notation)
	mov	si,1193		; 1193 * 10000h
	mov	di,11796	; 0.18 * 10000h = 11796.48
endif   ; NEC_98

	call	qdiv		; (T * 10000h) / (DWORD)(1193.18 * 10000h)
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddMsToTicks |
;	Convert milliseconds (1000 Hz) to clock ticks (1.193 MHz).
;
;@parm	AX |
;	Millisecond count to convert to clock ticks
;
;@rdesc	DX:AX |
;	Converted clock tick count.
;
;@comm	There is a slight error in the approximation of 1193.18 ticks per
;	millisecond by the process to avoid floating point arithmetic, which
;	effectively multiplies by 1193.1875 instead.
;
;	clock ticks `T' = time `Ms' * 1193.18
;
;	In order to be able to use fixed point, the math actually done is
;
;	T = (Ms * (WORD)(1193.18 * 20h)) / 20h
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddMsToTicks <PUBLIC,NEAR> <>

cBegin
ifdef   NEC_98
        cmp     byte ptr bClockFlag,0
        jnz     set2_8Mhz

set2_5Mhz:
        mov     dx,39322       ; 2457.6 * 10h = 39321.6
        jmp     short @f

set2_8Mhz:
                               ; 8MHz,16MHz set
        mov     dx,31949       ; 1996.8 * 10h = 31948.8

@@:
        mul     dx             ; Ms * (WORD)(1996.8 * 10h)
        shr     ax,4           ; Divide the result by 10h
        mov     cx,dx          ; Save original first
        shl     cx,12          ; Keep only the bottom part
        shr     dx,4           ; Shift top part of return
        or      ax,cx          ; Put two halves of bottom part together

else    ; NEC_98
	mov	dx,38182	; 1193.18 * 20h = 38181.76
	mul	dx		; Ms * (WORD)(1193.18 * 20h)
	shr	ax,5		; Divide the result by 20h
	mov	cx,dx		; Save original first
	shl	cx,11		; Keep only the bottom part
	shr	dx,5		; Shift top part of return
	or	ax,cx		; Put two halves of bottom part together
endif   ; NEC_98
cEnd

sEnd	Code286

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\class1.c ===
/*************************************************************************
 *  CLASS1.C
 *
 *      Routines used to enumerate window classes
 *
 *************************************************************************/

#include "toolpriv.h"
#include <testing.h>

/* ----- Types ----- */

/* The following was stolen from the 3.1 USER but is the same as 3.0.
 *  Note that the only fielda we use (for now) are the atomClassName
 *  and the pclsNext fields.
 *  Oops.  We're going to use the hInstance field also.
 */
typedef struct tagCLS
{
    struct tagCLS *pclsNext;
    unsigned clsMagic;
    unsigned atomClassName;
    char *pdce;                 /* DCE * to DC associated with class */
    int cWndReferenceCount;     /* Windows registered with this class */
    unsigned style;
    long (far *lpfnWndProc)();
    int cbclsExtra;
    int cbwndExtra;
    HANDLE hInstance;
    HANDLE hIcon;
    HANDLE hCursor;
    HANDLE hbrBackground;
    char far *lpszMenuName;
    char far *lpszClassName;
} CLS;
typedef CLS FAR *LPCLS;

/* ----- Functions ----- */

/*  ClassFirst
 *      Returns information about the first task in the task chain.
 */

BOOL TOOLHELPAPI ClassFirst(
    CLASSENTRY FAR *lpClass)
{
    WORD wClassHead;

    /* Check for errors */
    if (!wLibInstalled || !lpClass || lpClass->dwSize != sizeof (CLASSENTRY))
        return FALSE;

    /* If we're in Win3.1, call the special entry point to get the head */
    if (!(wTHFlags & TH_WIN30))
        wClassHead = (WORD)(*lpfnUserSeeUserDo)(SD_GETCLASSHEADPTR, 0, 0L);

    /* In 3.0 (and 3.0a) we're forced to use a fixed offset.  Unfortunately,
     *  this offset is different in debug and nondebug versions.
     */
    else
    {
        if (GetSystemMetrics(SM_DEBUG))
            wClassHead = 0x1cc;
        else
            wClassHead = 0x1b8;
        wClassHead = *(WORD FAR *)MAKEFARPTR(hUserHeap, wClassHead);
    }

    /* Now get the stuff */
    return ClassInfo(lpClass, wClassHead);
}


/*  ClassNext
 *      Returns information about the next task in the task chain.
 */

BOOL TOOLHELPAPI ClassNext(
    CLASSENTRY FAR *lpClass)
{
    /* Check for errors */
    if (!wLibInstalled || !lpClass || !lpClass->wNext ||
        lpClass->dwSize != sizeof (CLASSENTRY))
        return FALSE;

    return ClassInfo(lpClass, lpClass->wNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\dllentry.asm ===
PAGE,132
;***************************************************************************
;*
;*   DLLENTRY.ASM
;*
;*      TOOLHELP.DLL Entry code
;*
;*      This module generates a code segment called INIT_TEXT.
;*      It initializes the local heap if one exists and then calls
;*      the C routine LibMain() which should have the form:
;*      BOOL FAR PASCAL LibMain(HANDLE hInstance,
;*                              WORD   wDataSeg,
;*                              WORD   cbHeap,
;*                              LPSTR  lpszCmdLine);
;*        
;*      The result of the call to LibMain is returned to Windows.
;*      The C routine should return TRUE if it completes initialization
;*      successfully, FALSE if some error occurs.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

extrn LocalInit:FAR
extrn GlobalUnwire:FAR

sBegin  CODE
        assumes CS,CODE

externNP ToolHelpLibMain
externNP HelperReleaseSelector
externNP NotifyUnInit
externNP InterruptUnInit

?PLM=0
externA  <_acrtused>             ;Ensures that Win DLL startup code is linked
?PLM=1


;  LibEntry
;
;       KERNEL calls this when the TOOLHELP is loaded the first time

cProc   LibEntry, <PUBLIC,FAR>
cBegin
        push    di               ;Handle of the module instance
        push    ds               ;Library data segment
        push    cx               ;Heap size
        push    es               ;Command line segment
        push    si               ;Command line offset

        ;** If we have some heap then initialize it
        jcxz    callc            ;Jump if no heap specified

        ;** Call the Windows function LocalInit() to set up the heap
        ;**     LocalInit((LPSTR)start, WORD cbHeap);
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ;Did it do it ok ?
        jz      error            ;Quit if it failed

        ;** Invoke our initialization routine
callc:
        call    ToolHelpLibMain  ;Invoke the 'C' routine (result in AX)
        jmp     SHORT exit

error:
        pop     si               ;Clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:

cEnd

;  WEP
;      Windows Exit Procedure

cProc   WEP, <FAR,PUBLIC>, <si,di,ds>
        parmW   wState
cBegin
        ;** Make sure our DS is safe
        mov     ax,_DATA        ;Get the DS value
        lar     cx,ax           ;Is it OK?
        jz      @F
        jmp     SHORT WEP_Bad   ;No
@@:     and     cx,8a00h        ;Clear all but P, Code/Data, R/W bits
        cmp     cx,8200h        ;Is it P, R/W, Code/Data?
        jne     WEP_Bad         ;No
        mov     ax,_DATA        ;Get our DS now
        mov     ds,ax

        ;** Uninstall the Register PTrace notifications if necessary
        cmp     wNotifyInstalled,0
        jz      @F
        cCall   NotifyUnInit
@@:
        ;** Release fault handlers
        cmp     wIntInstalled,0
        jz      @F
        cCall   InterruptUnInit
@@:
        ;** Release our roving selector
        test    wTHFlags, TH_WIN30STDMODE
        jz      @F
        cCall   HelperReleaseSelector, <wSel>
@@:

WEP_Bad:
        mov     ax,1
cEnd

sEnd

        END LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\global.c ===
/**************************************************************************
 *  GLOBAL.C
 *
 *      Routines used to walk the global heap.
 *
 **************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/*  GlobalInfo
 *      Reports information about the state of the global heap,
 *      specifically, the number of elements that will be returned by
 *      a global heap walk.
 */

BOOL TOOLHELPAPI GlobalInfo(
    GLOBALINFO FAR *lpGlobalInfo)
{
    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || lpGlobalInfo->dwSize != sizeof (GLOBALINFO))
        return FALSE;

    /* Get the item counts */
    if (wTHFlags & TH_KERNEL_386)
    {
        lpGlobalInfo->wcItems = Walk386Count(GLOBAL_ALL);
        lpGlobalInfo->wcItemsFree = Walk386Count(GLOBAL_FREE);
        lpGlobalInfo->wcItemsLRU = Walk386Count(GLOBAL_LRU);
    }
    else
    {
        lpGlobalInfo->wcItems = Walk286Count(GLOBAL_ALL);
        lpGlobalInfo->wcItemsFree = Walk286Count(GLOBAL_FREE);
        lpGlobalInfo->wcItemsLRU = Walk286Count(GLOBAL_LRU);
    }

    return TRUE;
}

/*  GlobalFirst
 *      Finds the first element in the global heap.  This is modified by
 *      wFlags which modifies which list (GLOBAL_ALL, GLOBAL_FREE,
 *      GLOBAL_LRU) should be walked
 */

BOOL TOOLHELPAPI GlobalFirst(
    GLOBALENTRY FAR *lpGlobal,
    WORD wFlags)
{
    DWORD dwFirst;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Call the appropriate low-level routine to find the first block */
    if (wTHFlags & TH_KERNEL_386)
    {
        /* Get the first item.  Return false if no items in this list */
        if (!(dwFirst = Walk386First(wFlags)))
            return FALSE;

        /* Return information about this first item */
        Walk386(dwFirst, lpGlobal, wFlags);
    }
    else
    {
        /* Get the first item.  Return false if no items in this list */
        if (!(dwFirst = Walk286First(wFlags)))
            return FALSE;

        /* Return information about this first item */
        Walk286(dwFirst, lpGlobal, wFlags);
    }

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalNext
 *      Returns the next item in the chain pointed to by lpGlobal and
 *      in the list indicated by wFlags (same choices as for GlobalFirst().
 */

BOOL TOOLHELPAPI GlobalNext(
    GLOBALENTRY FAR *lpGlobal,
    WORD wFlags)
{
    DWORD dwNext;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Check to see if we're at the end of the list */
    dwNext = wFlags & 3 ? lpGlobal->dwNextAlt : lpGlobal->dwNext;
    if (!dwNext)
        return FALSE;

    /* If we're using the 386 kernel, call the 386 heap walk routine with
     *  a pointer to the appropriate heap item
     *  (Note that this depends on GLOBAL_ALL being zero)
     */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwNext, lpGlobal, wFlags);
    else
        Walk286(dwNext, lpGlobal, wFlags);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalEntryHandle
 *      Used to find information about a global heap entry.  Information
 *      about this entry is returned in the structure.
 */

BOOL TOOLHELPAPI GlobalEntryHandle(
    GLOBALENTRY FAR *lpGlobal,
    HANDLE hItem)
{
    DWORD dwBlock;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Make sure this is a valid block */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(dwBlock = Walk386Handle(hItem)))
            return FALSE;
    }
    else
    {
        if (!(dwBlock = Walk286Handle(hItem)))
            return FALSE;
    }
    
    /* Return information about this item */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwBlock, lpGlobal, GLOBAL_ALL);
    else
        Walk286(dwBlock, lpGlobal, GLOBAL_ALL);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalEntryModule
 *      Returns global information about the block with the given module
 *      handle and segment number.
 */

BOOL TOOLHELPAPI GlobalEntryModule(
    GLOBALENTRY FAR *lpGlobal,
    HANDLE hModule,
    WORD wSeg)
{
    struct new_exe FAR *lpNewExe;
    struct new_seg1 FAR *lpSeg;
    DWORD dwBlock;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Grunge in the module database to find the proper selector.  Start
     *  by first verifying the module database pointer
     */
    if (!HelperVerifySeg(hModule, sizeof (struct new_exe)))
        return FALSE;

    /* Get a pointer to the module database */
    lpNewExe = MAKEFARPTR(hModule, 0);

    /* Make sure this is a module database */
    if (lpNewExe->ne_magic != NEMAGIC)
        return FALSE;

    /* See if the number requested is past the end of the segment table.
     *  Note that the first segment is segment 1.
     */
    --wSeg;
    if (lpNewExe->ne_cseg <= wSeg)
        return FALSE;

    /* Get a pointer to the segment table */
    lpSeg = MAKEFARPTR(hModule, lpNewExe->ne_segtab);

    /* Jump to the right spot in the segment table */
    lpSeg += wSeg;

    /* Make sure this is a valid block and get its arena pointer */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(dwBlock = Walk386Handle(lpSeg->ns_handle)))
            return FALSE;
    }
    else
    {
        if (!(dwBlock = Walk286Handle(lpSeg->ns_handle)))
            return FALSE;
    }

    /* Return information about this item */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwBlock, lpGlobal, GLOBAL_ALL);
    else
        Walk286(dwBlock, lpGlobal, GLOBAL_ALL);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    /* If we've gotten to here, it must be OK */
    return TRUE;
}


/*  GlobalHandleToSel
 *      Provides a generic method of converting a handle to a selector.
 *      This works across Windows versions as well as working when the
 *      value is already a selector.
 */

WORD TOOLHELPAPI GlobalHandleToSel(
    HANDLE hMem)
{
    return HelperHandleToSel(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\helper.asm ===
;**************************************************************************
;*  HELPER.ASM
;*
;*      Assembly routines used by more than one module
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC
PMODE32 = 0
PMODE   = 1
SWAPPRO = 0
        INCLUDE WINKERN.INC
        INCLUDE NEWEXE.INC
        INCLUDE TDB.INC

;** External functions
externNP Walk386VerifyLocHeap
externNP Walk286VerifyLocHeap
externFP GetCurrentTask
externFP InterruptUnRegister
externFP NotifyUnRegister
externNP SignalUnRegister
externFP TaskFirst
externFP TaskNext

;** Functions

sBegin  CODE
        assumes CS,CODE

.286p

;  HelperVerifySeg
;
;       Verifies that a selector is valid and that the segment it points
;       to is safe for reading out to wcb bytes offset
;       Returns 0 if too short or the length of the segment.
;       Preserves all used registers except the return value, AX

cProc   HelperVerifySeg, <PUBLIC,NEAR>, <dx>
        parmW   wSeg
        parmW   wcb
cBegin
        ;** Verify that this is a valid selector and that it is long enough
        cCall   HelperSegLen, <wSeg>    ;Check the segment
        or      dx,dx                   ;>64K?  If so, always return OK
        jnz     HVS_End
        cmp     ax,wcb                  ;Long enough?
        ja      HVS_End                 ;Yes, return the length
HVS_Bad:
        xor     ax,ax                   ;No.  Return FALSE
HVS_End:
cEnd


;  HelperHandleToSel
;       Converts a handle to a selector.  This routine knows how to
;       handle 3.0 and 3.1 differences as well as 286 & 386 differences.

cProc   HelperHandleToSel, <NEAR,PUBLIC>, <ds>
        parmW   h                       ;Handle
cBegin
        mov     ax,_DATA                ;Get the data segment
        mov     ds,ax                   ;Point with DS
        mov     ax,h                    ;Get the handle
        test    wTHFlags,TH_WIN30       ;Win3.0?
        jz      HTS_Win31               ;No
        test    ax,1                    ;Check the low bit
        jnz     HTS_End                 ;It's already a selector
        dec     ax                      ;Decrement for proper selector
        jmp     SHORT HTS_End           ;Out of here

HTS_Win31:
        or      ax,1                    ;Set the bit

HTS_End:

cEnd


;  HelperVerifyLocHeap
;
;       Uses the processor-specific local heap verify routine to check the
;       validity of a local heap.
;
;       Call:
;               AX = Block handle or selector
;               DS must point to TOOLHELP's DGROUP
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

HelperVerifyLocHeap PROC Near
        PUBLIC  HelperVerifyLocHeap

        test    wTHFlags,TH_KERNEL_386  ;Are we using KRNL386?
        jz      HVL_286                 ;No
        jmp     Walk386VerifyLocHeap    ;Jump to the 386 routine

HVL_286:
        jmp     Walk286VerifyLocHeap    ;Jump to the 286 routine

HVL_End:
        ret

HelperVerifyLocHeap ENDP


;  HelperGlobalType
;
;       Given data about a block, gropes around trying to decipher the
;       block type.  Parameters are passed and returned in the GLOBALENTRY
;       structure.

cProc   HelperGlobalType, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpGlobal
        localV  Task,<SIZE TASKENTRY>
cBegin
        lds     si,lpGlobal             ;Get the pointer
        mov     [si].ge_wData,0         ;Clear the wData field
                                        ;  Zero's not a valid seg # or type #

        ;** Check for internal block types
        mov     bx,[si].ge_hOwner       ;Get the owner handle
        mov     ax,GT_SENTINEL          ;Just in case...
        cmp     bx,GA_SENTINAL          ;Is this a sentinel?
        jz      HGT_JmpEnd              ;Yes, get out
        mov     ax,GT_BURGERMASTER      ;Just in case...
        cmp     bx,GT_BURGERMASTER      ;Burgermaster?
        jz      HGT_JmpEnd              ;Yes, get out
        cmp     bx,-7                   ;Lowest number reserved
        jb      HGT_0                   ;Not an internal block
        mov     ax,GT_INTERNAL          ;Internal KERNEL block type
HGT_JmpEnd:
        jmp     HGT_End                 ;Get out
HGT_0:

        ;** Check for a free block
        or      bx,bx                   ;Check for 0:  Free block
        jnz     HGT_2                   ;Not zero
        mov     ax,GT_FREE              ;Free blocks have zero owner
        jmp     HGT_End                 ;Unknown type
HGT_2:

        ;** Check for DGROUP and other data segments
        mov     ax,[si].ge_wFlags       ;Get the block flags
        test    ax,GAH_DGROUP           ;Is this a DGROUP segment
        jnz     @F
        jmp     HGT_10                  ;Didn't find it so continue
@@:

        ;** Save the segment number of the segment
        mov     ax,[si].ge_hOwner       ;Get the module database
        push    ax                      ;Save for later
        mov     bx,[si].ge_hBlock       ;Get the handle
        cCall   HelperGetSegNumber      ;Get the segment number
        mov     [si].ge_wData,ax        ;Save the segment number
        pop     bx                      ;Get hExe back in BX

        ;** Try two methods:  First, see if it is the hInst of the FIRST
        ;**     instance of its module
        lsl     cx, bx                  ;Is this segment OK?
        jnz     HGT_5                   ;No, punt and call it unknown data
        cmp     cx, ne_pautodata        ;Long enough?
        jbe     HGT_5                   ;No, get out
        mov     es,bx                   ;Point with ES
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jnz     HGT_5                   ;It isn't so get out
        mov     bx,es:[ne_pautodata]    ;Point to the segment table entry
        or      bx,bx                   ;Is there a DGROUP segment?
        jz      HGT_5                   ;No, flag as unknown data
        mov     ax,es:[bx].ns_handle    ;Get the handle from the table
        cmp     ax,[si].ge_hBlock       ;Does the DGROUP handle point here?
        jnz     HGT_3                   ;No, might be multiple instance
        mov     ax,GT_DGROUP            ;Matches, must be DGROUP
        jmp     HGT_End                 ;Get out
HGT_3:
        ;** It's not the first instance of this module.
        ;**     All multiple instance things will be on the task list
        ;**     so try to find it there.
        mov     bx,[si].ge_hBlock       ;Get the handle
        cCall   HelperHandleToSel,<bx>  ;Get the selector for this
        mov     di,ax                   ;Save in DI
        mov     ax,SIZE TASKENTRY       ;Get the struct size
        mov     WORD PTR Task.te_dwSize[0],ax ;Put in struct
        mov     WORD PTR Task.te_dwSize[2],0 ;Clear high word
        lea     ax,Task                 ;Get the structure
        cCall   TaskFirst, <ss,ax>      ;Get the first task's info
        or      ax,ax                   ;No tasks?
        jz      HGT_5                   ;Just call it data (not DGROUP)
HGT_TaskLoop:
        mov     ax,Task.te_hInst        ;Get this task's hInst
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cmp     ax,di                   ;Is this a match?
        je      HGT_TaskFound           ;Yes, do it
        lea     ax,Task                 ;Point to the struct
        cCall   TaskNext, <ss,ax>       ;Get the next one
        or      ax,ax                   ;End of the line?
        jnz     HGT_TaskLoop            ;Nope, do the next one
HGT_5:  mov     ax,GT_DATA              ;Unknown data segment
        jmp     HGT_End                 ;Get out
HGT_TaskFound:
        mov     ax,GT_DGROUP            ;Matches, must be DGROUP
        jmp     HGT_End                 ;Get out
HGT_10:

        ;** Check for a task database
        mov     ax,[si].ge_hBlock       ;Get the segment
        mov     bx,TDBSize              ;Get the limit to verify
        push    ax                      ;Save the segment
        cCall   HelperVerifySeg <ax,bx> ;Make sure we can check signature
        pop     bx                      ;Retrieve the segment value
        or      ax,ax                   ;Zero return means bad
        jz      HGT_20                  ;Not a task database
        mov     es,bx                   ;Point to the segment
        cmp     es:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jnz     HGT_20                  ;Nope, go on
        mov     ax,GT_TASK              ;Set the task flag
        jmp     HGT_End                 ;Get out
HGT_20:

        ;** Now check for Module database
        mov     ax,[si].ge_hOwner       ;Get the owner handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector for compare
        mov     cx,ax                   ;Save in CX
        mov     ax,[si].ge_hBlock       ;Does this block own itself?
        cCall   HelperHandleToSel, <ax> ;Convert to selector for compare
        cmp     ax,cx                   ;Do the pointers match?
        jnz     HGT_24                  ;No, so it's not a module database
        mov     ax,GT_MODULE            ;Set type
        jmp     HGT_End                 ;Get out
HGT_24:

        ;** Check for a code segment.  If found, return segment number
        mov     ax,[si].ge_hOwner       ;Get the module database
        push    ax                      ;Save the selector
        cCall   HelperVerifySeg <ax,2>  ;Make sure this is OK to put in ES
        pop     bx                      ;Retrieve in BX
        or      ax,ax                   ;Zero means bad
        jnz     @F
        jmp     SHORT HGT_Unknown
@@:     mov     es,bx                   ;Point with ES
        xor     dx,dx                   ;Use DX to count segments
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jz      HGT_25                  ;Looks good
        jmp     SHORT HGT_40            ;Not code or resource, try next
HGT_25: mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    HGT_30                  ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
        mov     bx,[si].ge_hBlock       ;Get the block we're looking for
HGT_SegLoop:
        inc     dx                      ;Bump the segment number
        cmp     bx,es:[di].ns_handle    ;Is this the correct segment entry?
        jz      HGT_27                  ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    HGT_SegLoop             ;Loop back to check next entry
        jmp     SHORT HGT_30            ;Now check resources
HGT_27:
        mov     [si].ge_wData,dx        ;Save the segment count
        mov     ax,GT_CODE              ;Flag that it's a code segment
        jmp     SHORT HGT_End           ;Get out

        ;** Check to see if it's a resource.  If so, return resource type #
HGT_30: mov     di,es:[ne_rsrctab]      ;Point to the resource table
        cmp     di,es:[ne_restab]       ;If both point to same place, no rsrc
        jz      HGT_40                  ;No resource table -- unknown type
        add     di,2                    ;Skip past alignment count
HGT_TypeLoop:
        mov     dx,es:[di].rt_id        ;DX holds current type number
        or      dx,dx                   ;Zero type means end of res table
        jz      HGT_40                  ;Not found so get out!
        mov     cx,es:[di].rt_nres      ;Get the number of resources
        add     di,SIZE RSRC_TYPEINFO   ;Bump past the structure
HGT_ResLoop:
        cmp     bx,es:[di].rn_handle    ;Is it this resource?
        jz      HGT_FoundRes            ;Yep.  This is the one
        add     di,SIZE RSRC_NAMEINFO   ;Bump past this structure
        loop    HGT_ResLoop             ;Loop for next resource structure
        jmp     HGT_TypeLoop            ;Try the next type

        ;** Found the resource, now compute the resource type
HGT_FoundRes:
        test    dx,RSORDID              ;If this bit set, must be ordinal type
        jnz     HGT_32                  ;Yep.  Ordinal
        mov     dx,GD_USERDEFINED       ;Named resources are all user-def
HGT_32: and     dx,NOT RSORDID          ;Clear the flag bit
        cmp     dx,GD_MAX_RESOURCE      ;If the type is too big, it's user-def
        jbe     HGT_34                  ;Standard type
        mov     dx,GD_USERDEFINED       ;User-defined resource type
HGT_34: mov     [si].ge_wData,dx        ;Save the type
        mov     ax,GT_RESOURCE          ;Return that it's a resource
        jmp     SHORT HGT_End           ;Get out

HGT_40:
HGT_Unknown:
        mov     ax,GT_UNKNOWN           ;Unknown type
HGT_End:
        mov     [si].ge_wType,ax        ;Save the type and exit
cEnd


;  HelperGrabSelector
;
;       Allocates a selector from DPMI.

cProc   HelperGrabSelector, <NEAR,PUBLIC>
cBegin
        xor     ax,ax                   ;DPMI Function 0, allocate LDT sels
        mov     cx,1                    ;Just 1 sel
        int     31h                     ;Call DPMI.  Selector in AX
cEnd


;  HelperReleaseSelector
;
;       Frees a selector to DPMI

cProc   HelperReleaseSelector, <NEAR,PUBLIC>
        parmW   wSelector
cBegin
        mov     ax,1                    ;DPMI function 1, free LDT sels
        mov     bx,wSelector            ;Get the sel
        int     31h                     ;Free it
cEnd

;  HelperSetSignalProc
;       Puts a signal proc in a task's TDB so that it gets called in place
;       of USER's proc.  Returns the old USER proc.

cProc   HelperSetSignalProc, <NEAR,PUBLIC>, <si,di>
        parmW   hTask,
        parmD   lpfn
cBegin
        ;** Point to the TDB
        mov     es,hTask                ;Point with ES

        ;** Swap the new with the old and return the old one
        mov     ax,WORD PTR lpfn        ;Get the new signal proc
        xchg    ax,WORD PTR es:[TDB_USignalProc] ;Switch with the old one
        mov     dx,WORD PTR lpfn + 2    ;Get HIWORD
        xchg    dx,WORD PTR es:[TDB_USignalProc + 2] ;Switch with old one
cEnd


;  HelperSignalProc
;       Cleans up when a TOOLHELP-using app is terminated.  This proc
;       MUST chain on to USER's signal proc.  Note that action is only taken
;       on the death signal (BX = 0666h)

cProc   HelperSignalProc, <FAR,PUBLIC>
cBegin  NOGEN
        
        ;** Save all registers
        sub     sp,4
        push    bp
        mov     bp,sp                   ;Make a stack frame
        pusha
        push    ds
        push    es

        ;** Get a pointer to the correct SIGNAL structure
        mov     ax,_DATA                ;Get the TOOLHELP.DLL DS
        mov     ds,ax                   ;Point with DS
        cCall   GetCurrentTask          ;Get the current task in AX
        mov     di,ax                   ;Save task in DI
        mov     si,npSignalHead         ;Get the first struct
HSP_SigLoop:
        or      si,si                   ;End of the list?
        jz      HSP_Return              ;Yes -- This is bad!!
        cmp     di,[si].si_hTask        ;Task match?
        je      HSP_FoundIt             ;Yes
        mov     si,[si].si_pNext        ;Get the next one
        jmp     HSP_SigLoop             ;Loop around
        
        ;** Compute the fake return address (old signal proc)
HSP_FoundIt:
        mov     ax,WORD PTR [si].si_lpfnOld ;Get LOWORD of old proc
        mov     [bp + 2],ax             ;Put on stack frame
        mov     dx,WORD PTR [si].si_lpfnOld + 2 ;Get HIWORD of old proc
        mov     [bp + 4],dx             ;Put on stack frame

        ;** See if we have the death signal.  If not, don't do anything
        ;**     but just chain on.  20h is the signal for task exit
        cmp     bx, 20h                 ;Is this the death signal?
        jne     HSP_Done                ;No.  Don't cleanup

        ;** Since we have a death signal, use it to clean up everything
        push    ax                      ;Save the return address
        push    dx
        cCall   InterruptUnRegister, <di> ;Unregister any interrupt callbacks
        cCall   NotifyUnRegister, <di>  ;Unregister any notification callbacks
        cCall   SignalUnRegister, <di>  ;Unregister any signal callbacks

        ;** If we have fooled with the LRU lock (we only do this on 286
        ;**     machines), we must force it unlocked.
        cmp     wLRUCount, 0            ;Is it set?
        je      HSP_NoLRUFoolingAround  ;No, don't mess with this
        mov     es, hMaster             ;Point to GlobalInfo struct
        mov     ax, es:[gi_lrulock]     ;Get current lock count
        sub     ax, wLRUCount           ;Get rid of the amount we messed it up
        jns     @F                      ;Result is OK--no underflow
        xor     ax, ax                  ;We don't like negative, so zero it
@@:     mov     es:[gi_lrulock], ax     ;Save the result
        mov     wLRUCount, 0            ;No more LRU count
HSP_NoLRUFoolingAround:
        pop     dx
        pop     ax

        ;** Make sure we have a proc to chain to
HSP_Done:
        or      ax,dx                   ;NULL pointer?
        jz      HSP_Return              ;Yes, don't chain to this one

HSP_ChainOn:
        pop     es
        pop     ds
        popa
        pop     bp
        retf                            ;Jump to next signal proc

HSP_Return:
        pop     es
        pop     ds
        popa
        pop     bp
        add     sp,4                    ;Clear fake return address
        retf    10                      ;Return to signal caller

cEnd    NOGEN


;  HelperSegLen
;       Gets the length of a segment, regardless whether it is a 286 or
;       386 segment.
;       Returns the DWORD length of the segment or zero on error.
;       Doesn't trash registers except DX:AX

cProc   HelperSegLen, <NEAR,PUBLIC>, <si,di,cx>
        parmW   wSeg
cBegin
        ;** Make sure the segment is present
        mov     cx,wSeg                 ;Get the selector
        lar     ax,cx                   ;Get the access rights
        jnz     HSL_Bad                 ;If LAR fails, this is bad
        test    ax,8000h                ;Is this segment present?
        jz      HSL_Bad                 ;No, call it bad
        
        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     HSL_Do286               ;Yes, do 16 bit stuff

        ;** Get the 32 bit length
.386p
        lsl     eax,ecx                 ;Get the limit
        jnz     SHORT HSL_Bad           ;We have an error
        mov     edx,eax                 ;Get HIWORD in DX
        shr     edx,16
        jmp     SHORT HSL_End           ;Done
.286p

        ;** Get the 16 bit length
HSL_Do286:
        xor     dx,dx                   ;286 never has >64K segs
        lsl     ax,cx                   ;Get the limit
        jnz     HSL_Bad                 ;Bad if LSL fails
        jmp     SHORT HSL_End           ;Done

HSL_Bad:
        xor     ax,ax                   ;Zero return value
        xor     dx,dx

HSL_End:

cEnd

;  HelperGetSegNumber
;
;       Returns the segment number corresponding to a selector given the
;       hExe.
;
;       Caller:  AX=hExe, BX=Handle
;       Exit:  AX=Seg Number or 0

cProc   HelperGetSegNumber, <NEAR,PUBLIC>, <di>
cBegin
        lsl     cx, ax                  ;Is the segment OK to load?
        jnz     HGSN_Error              ;No, don't do it
        cmp     cx, ne_segtab           ;Long enough?
        jbe     HGSN_Error              ;No
        mov     es,ax                   ;Point with ES
        xor     dx,dx                   ;Use DX to count segments
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have an hExe
        jnz     HGSN_Error              ;Nope, get out
        mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    HGSN_Error              ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
HGSN_SegLoop:
        inc     dx                      ;Bump the segment number
        cmp     bx,es:[di].ns_handle    ;Is this the correct segment entry?
        je      HGSN_FoundIt            ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    HGSN_SegLoop            ;Loop back to check next entry
        jmp     SHORT HGSN_Error        ;Not found

HGSN_FoundIt:
        mov     ax,dx                   ;Get segment number
        jmp     SHORT HGSN_End

HGSN_Error:
        xor     ax,ax                   ;Error return
        
HGSN_End:
cEnd

;** Internal helper functions

;  HelperPDBtoTDB
;
;       Takes a PDB handle and finds the task handle associated with it.
;       Caller:  AX = PDB Handle
;       Return:  AX = TDB handle or zero if no TDB exists for it

cProc   HelperPDBtoTDB, <NEAR,PUBLIC>
cBegin
        ;** Point to the first TDB
        mov     dx,_DATA                ;Get the library static segment
        mov     es,dx                   ;Point with ES
        mov     bx,es:[npwTDBHead]      ;Get pointer to first TDB
        mov     dx,es:[segKernel]       ;Get the KERNEL data segment
        mov     es,dx                   ;Point with ES
        mov     dx,es:[bx]              ;Get the first TDB

        ;** Check this TDB's PDB to see if it matches
PT_Loop:
        mov     es,dx                   ;Get the TDB segment
        cmp     ax,es:[TDB_PDB]         ;Compare PDB pointers
        jz      PT_Found                ;This is it
        mov     dx,es:[TDB_next]        ;Get the next TDB
        or      dx,dx                   ;End of the line?
        jnz     PT_Loop                 ;Nope, loop back
        xor     ax,ax                   ;Return NULL'
        jmp     SHORT PT_End            ;Outta here

PT_Found:
        mov     ax,es                   ;Save the found value
PT_End:

cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\timer\timer.inc ===
;
;    timer.inc
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segments
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

createSeg FIXED_TEXT,Code386,   word, public, CODE
createSeg FIXED_TEXT,CodeFixed, word, public, CODE
createSeg FIXED_286, Code286,   word, public, CODE
createSeg INIT_CODE, CodeInit,  word, public, CODE

createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Equates and structure definitions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IDS_ERRORTITLE	equ	1
IDS_ERRORTEXT	equ	2

;RMODE_INT	equ	1

ifdef DEBUG
    TDD_GETTICK         equ     42
    TDD_GETRINTCOUNT    equ     43
    TDD_GETPINTCOUNT    equ     44
endif

ifdef   NEC_98
TDD_MINRESOLUTION       equ     25      ; minimun resolution.(ms)
else    ; NEC_98
TDD_MINRESOLUTION	equ	55	; minimum resolution. (ms)
endif   ; NEC_98
TDD_MAX386RESOLUTION	equ	1	; maximum resolution. (ms)
TDD_MAX286RESOLUTION	equ	2	; maximum resolution. (ms)

TDD_MAXPERIOD		equ	0FFFFh	; maximum ms period.
TDD_MIN386PERIOD	equ	01h	; minimum ms period.
TDD_MIN286PERIOD	equ	02h	; minimum ms period.

ifdef   NEC_98
TMR_CNTR_0      equ     071h    ; counter 0 - programmable system interrupt
TMR_CTRL_REG    equ     077h    ; timer control word register
else    ; NEC_98
TMR_CNTR_0	equ	040h	; counter 0 - programmable system interrupt
TMR_CTRL_REG	equ	043h	; timer control word register
endif   ; NEC_98

TMR_MODE2_RW	equ   00110100b ; Read/Write counter 0 mode 2 (two bytes)
				; (countdown mode)

TMR_MODE3_RW	equ   00110110b ; Read/Write counter 0 mode 3 (two bytes)
				; (square wave mode)


PS2_SysCtrlPortB equ	61h	; IBM PS2 System Control Port B
PS2_LatchBit	equ	80h	; Latch clear bit for PS2
ifdef   NEC_98
PICDATA         equ     00h             ; Programmable interrupt controller port
SPECIFIC_EOI    equ     00100000b       ; IRQ 0 end-of-interrupt PIC command
else    ; NEC_98
PICDATA 	equ	020h	; Programmable interrupt controller port
SPECIFIC_EOI	equ	01100000b	; IRQ 0 end-of-interrupt PIC command
EOI_STATUS	equ	00001011b	; Status of pending EOIs
endif   ; NEC_98

TIME_BIOSEVENT  equ     8000h   ; special flag for bios event

TIMERINTERRUPT	equ	8	; interrupt number for timer counter


;	The following defines the maximum number of simultaneous events which
;	can be queued.  This value covers event slots 0 to 15.  Note that this
;	is 4 bits of data, which is relied upon in the code.
;
;	The two constants defined after are used to increment and filter the
;	mask added to the event slot IDs to create an event handle to return.
;	They illustrate the dependence upon the MAXEVENTS constant.

MAXEVENTS	equ	16

MASKINCREMENT	equ	0010h
MASKFILTER	equ	000fh

;	The following flags are used during the process of killing an event.
;
;	The first flag indicates that an event slot is being checked by the
;	kill event function, and that the EVENT_DESTROYED flag should be set
;	if the pevent is killed during interrupt time before the original
;	function completes its check.
;
;	The second flag indicates that an event is currently being killed, and
;	should not be allowed to execute.  This is set in the kill timer
;	function, and either cleared, or replaced with the EVENT_DESTROYED
;	flag when complete.
;
;	The third flag can be set either in the interrupt handler for oneshot
;	events, or in the kill timer function.  This is only set if the timer
;	was currently being checked when an interrupt occurred, and the event
;	was killed by the interrupt.  This flag disallows any new event to be
;	created in the event slot until the flag is cleared by the original
;	kill event function exiting.

EVENT_CHECKING		equ	1
EVENT_DESTROYING	equ	2
EVENT_DESTROYED		equ	4

EventStruct STRUC

evTime          dd  ?    ; actual time when the event will go off (in ticks)

evDelay         dd  ?    ; event delay time (in ticks)

evCallback      dd  ?    ; call back function

evUser          dd  ?    ; parameter to call-back function

evResolution    dw  ?    ; event resolution (in Ms)

evID            dw  ?    ; timer event id

evFlags         dw  ?    ; bits 1,0 = flags (one-shot/periodic)

evCreate	db  ?	 ; Creation flag

evDestroy	db  ?	 ; Destroying flag

EventStruct ENDS

    errnz <(SIZE EventStruct) and 1>

    SizeEvent equ <(SIZE EventStruct)>

;	Macro to cause a delay in between I/O accesses to the same device.

IO_Delay	MACRO
	jmp	$+2
ENDM

; this macro makes sure interrupts are disabled in debug driver
AssertCLI   MACRO
ifdef DEBUG
    push    ax
    pushf
    pop     ax
    test    ah,2
    jz	    @f
    int     3
@@: pop     ax
endif
ENDM

; this macro makes sure interrupts are enabled in debug driver
AssertSLI   MACRO
ifdef DEBUG
    push    ax
    pushf
    pop     ax
    test    ah,2
    jnz     @f
    int     3
@@: pop     ax
endif
ENDM

DefineInfo  MACRO
ifdef DEBUG
externNP    savedebuginfo
endif
ENDM

SaveInfo    MACRO   value
ifdef DEBUG
ifdef savedebuginfo
    push    ax
    mov     ax,value
    call    savedebuginfo
    pop     ax
else
    safd
endif
endif
ENDM

; The DOS Extender used for Standard mode Windows remaps the master 8259 from
; Int vectors 8h-Fh to 50h-57h.  In order to speed up com port interrupt
; response as much as possible, this driver hooks real mode interrupts
; when running in Standard mode.  It currently uses the following adjustment
; value to hook the real hardware int vector.  When time permits, this
; HARDCODED equate should be changed to be adjustible at run time.

DOSX_IRQ        equ     (50h - 8h)      ; Adjustment for DOSX remapping the
					; master 8259 from 8h to 50h
;	WinFlags[0] constants...remove when included in windows.inc

WF_PMODE	equ	01h
WF_CPU286	equ	02h
WF_CPU386	equ	04h
WF_CPU486	equ	08h
WF_WIN286	equ	10h		; WF_STANDARD
WF_WIN386	equ	20h		; WF_ENHANCED
WF_CPU086	equ	40h
WF_CPU186	equ	80h

;	Interrupt 31h service call equates

Get_RM_IntVector    equ     <(Int31_Int_Serv SHL 8 ) OR Int_Get_Real_Vec>
Set_RM_IntVector    equ     <(Int31_Int_Serv SHL 8 ) OR Int_Set_Real_Vec>

GetSystemConfig		equ	0c0h

;---------------------------------Macro---------------------------------;
;
; EnterCrit
;
;   saves the current state of the interrupt flag on the stack then
;   disables interrupts.
;
; Registers Destroyed:
;       BX, FLAGS
;
;------------------------------------------------------------------------;

EnterCrit macro
    local   no_cli
    pushf
    pushf
    pop     cx
    test    ch,2            ; if interrupts are already off, dont blow
    jz      no_cli          ; ... ~300 clocks doing the cli
    cli
no_cli:
endm

;---------------------------------Macro---------------------------------;
;
; LeaveCrit
;
;   restore the interrupt state saved by EnterCrit
;
; Registers Destroyed:
;       CX, FLAGS
;
;------------------------------------------------------------------------;

LeaveCrit macro reg
    local   no_sti
    pop     cx
    test    ch, 2
    jz      no_sti
    sti
no_sti:
endm

;------------------------------------------------------------------------;
;------------------------------------------------------------------------;

externFP    OutputDebugStr

DOUT macro text
    local   string_buffer

ifdef DEBUG

_DATA segment
string_buffer label byte
    db      "&text&",13,10,0
_DATA ends

    push    DataBASE
    push    DataOFFSET string_buffer
    call    OutputDebugStr
endif
    endm

ifdef   NEC_98
; Module Name: Timer interface procedures
;
; Created: 03-08-90 NEC Y.Ueno

TIMODESET       EQU     77H
TICNTSET        EQU     71H
TIMERMASK       EQU     01H

setmask macro   code
        cli                             ; mask timer int
        in      al,02h
        delay   8259,I-O
        or      al,code
        out     02h,al
        jmp     $+2
        sti
        endm

unmask macro    code
        cli                             ; mask timer int
        in      al,02h
        delay   8259,I-O
        and     al,not code
        out     02h,al
        jmp     $+2
        sti
        endm


;       DELAY MACRO FOR 80386
; This macro is defined in SYSMAC.INC(V23 ROM BIOS)             <880203 ver2.1
;
DELAY   MACRO   DEV,ACT,MOD

        IFIDN   <DEV>,<8237>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8253>
                IFIDN   <ACT>,<O-O>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8255>
                IFIDN   <ACT>,<O-O>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8259>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<I-I>
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<I-O>
                ENDIF
                IFIDN   <ACT>,<>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8251>
                IFIDN   <ACT>,<O-O>
                        IFIDN   <MOD>,<INIT>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<ASYNC>
        REPT    5
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<SYNC>
        REPT    10
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
        ENDIF

        IFIDN   <DEV>,<765>
        ENDIF

        IFIDN   <DEV>,<7220>
                IFIDN   <ACT>,<O-O>
                        IFIDN   <MOD>,<GRAPH>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<I-I>
                        IFIDN   <MOD>,<GRAPH>
        REPT    3
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        JMP     SHORT   $+2
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<O-I>
                        IFIDN   <MOD>,<GRAPH>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<I-O>
                        IFIDN   <MOD>,<GRAPH>
        REPT    3
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        JMP     SHORT   $+2
                        ENDIF
                ENDIF
        ENDIF

        IFIDN   <DEV>,<7201>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<7210>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<4990>
                REPT    3
                JMP     SHORT   $+2
                ENDM
        ENDIF

        ENDM
endif   ; NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\int2.asm ===
PAGE 60,150
;***************************************************************************
;*  INT2.ASM
;*
;*      Assembly code support routines used for the TOOLHELP.DLL interrupt
;*      trapping API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC
        include vint.inc
.286p

;** Symbols
I_EXCEPTION             EQU     0
I_INTERRUPT             EQU     1
MAX_INTERRUPT           EQU     7
GIVE_WDEB386            EQU     8000h
BAD_STACK_FLAG          EQU     8000h
MIN_STACK_ALLOWED       EQU     128

;** Local types

INT_INFO STRUC
ii_wNumber      DW      ?               ;INT nn
ii_wType        DW      ?               ;I_EXCEPTION or I_INTERRUPT
ii_dwChain      DD      ?
ii_wHandler     DW      ?               ;Note that this is CS relative
INT_INFO ENDS

;** Data
sBegin  DATA

IntInfo         LABEL   BYTE
        public IntInfo
UD_Info         DW      6               ;Undefined opcode
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                DD      0               ;Chain address (will be initialized)
                DW      OFFSET _TEXT:UD_Handler
Div0_Info       DW      0               ;Divide by zero
                DW      I_EXCEPTION     ;Hook with DPMI
                DW      OFFSET _TEXT:Div0_Handler
                DW      0
                DW      OFFSET _TEXT:Div0_Handler
Int1_Info       DW      1               ;Single step + debug register
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:Int1_Handler
Int3_Info       DW      3               ;Software debug int
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:Int3_Handler
GP_Info         DW      13              ;GP Fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:GP_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:GP_Handler
SF_Info         DW      12              ;Stack fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:SF_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:SF_Handler
PF_Info         DW      14              ;Page fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:PF_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:PF_Handler
CASRq_Info      DW      256             ;CtlAltSysRq (fake interrupt)
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:CASRq_Handler

                ;** The following data is used to see if GDI wants the
                ;**     Div0 we have trapped
lpGDIFlag       DD      0
hGDI            DW      0
szGDI           DB      'GDI', 0
        public lpGDIFlag, hGDI

                ;** Points to a KERNEL routine to see if it wants the
                ;**     GP fault first
lpfnPV          DD      0               ;Call to see if PV GP fault
        public lpfnPV

                ;** Globals used for DPMI emulation
lpOldHandler    DD      0               ;Previous DPMI exception handler
lpChainCSIP     DD      0               ;Next exception handler on chain
wException      DW      0
        public lpOldHandler, lpChainCSIP

externW wCASRqFlag                      ;Set when an CASRq INT3 has been set
externD dwCASRqCSIP                     ;Holds the CS:IP of the CASRq INT3
sEnd

;** Imports
externNP TerminateApp
externNP HelperHandleToSel
externNP HelperVerifySeg
externFP AllocCStoDSAlias
externFP FreeSelector
externFP GetModuleHandle
externFP GetProcAddress
externFP GlobalEntryHandle
externFP _wsprintf
externFP OutputDebugString
externA __WinFlags

;** Functions

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;** Interrupt trapping API

;  InterruptInit
;       Hooks all necessary interrupts and exceptions to allow an API
;       for app-level interrupt hooks.

cProc   InterruptInit, <NEAR,PUBLIC>, <si,di>
cBegin
        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT        ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array
DII_HandlerLoop:
        push    cx                      ;Save loop counter
        cmp     [si].ii_wNumber,256     ;Fake exception?
        jae     DII_Continue            ;Yes, don't hook anything!
        cmp     [si].ii_wType,I_EXCEPTION ;Exception?
        jnz     DII_Interrupt           ;Nope, hook as interrupt
        
        ;** Do a special case for 3.0 Std Mode 
        test    wTHFlags,TH_WIN30STDMODE ;Are we in Win30 std mode?
        jz      DII_NotStdMode          ;No.
        mov     ax,WORD PTR [si].ii_dwChain ;Get the secondary handler
        mov     [si].ii_wHandler,ax     ;Make sure we use it instead!
DII_NotStdMode:

        ;** Hook as an exception (DPMI)
        mov     ax,0202h                ;Get exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     31h                     ;Call DPMI
        mov     WORD PTR [si].ii_dwChain,dx ;Save the old offset
        mov     WORD PTR [si].ii_dwChain + 2,cx ;Save the old selector
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,[si].ii_wHandler     ;Address of exception handler
        mov     cx,cs                   ;Selector value of handler
        int     31h                     ;Call DPMI
        jmp     SHORT DII_Continue

        ;** Hook as an interrupt (DOS)
DII_Interrupt:
        mov     ah,35h                  ;Get interrrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     21h                     ;Call DOS
        mov     WORD PTR [si].ii_dwChain,bx ;Save the old offset
        mov     WORD PTR [si].ii_dwChain + 2,es ;Save the old selector
        mov     ah,25h                  ;Set interrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,[si].ii_wHandler     ;Address of exception handler
        push    ds                      ;Save static DS for later
        push    cs                      ;DS = CS
        pop     ds
        int     21h                     ;Call DOS
        pop     ds                      ;Get segment back

        ;** Prepare for next in table
DII_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        pop     cx                      ;Get loop counter back
        loop    DII_HandlerLoop         ;Loop back

        ;** Prepare the linked list
        mov     npIntHead,0             ;Put a NULL in the list head

        ;** Get information so we can check the GDI flag
        lea     ax,szGDI                ;Get the string
        cCall   GetModuleHandle, <ds,ax> ;Get GDI's module handle
        cCall   HelperHandleToSel, <ax> ;Convert the owner to a selector
        mov     hGDI,ax                 ;Save it for later
        cCall   GetProcAddress, <ax,0,355> ;The flag is ordinal 355
        mov     WORD PTR lpGDIFlag[0],ax ;Save it for later
        mov     WORD PTR lpGDIFlag[2],dx

DII_End:
        ;** Return TRUE
        mov     ax,1
cEnd


;  InterruptUnInit
;       Unhooks all interrupts and exceptions hooked by DebugInterruptUnInit.

cProc   InterruptUnInit, <NEAR,PUBLIC>, <si,di>
cBegin

        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT        ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array
DIU_HandlerLoop:
        push    cx                      ;Save loop counter
        cmp     [si].ii_wNumber,256     ;Fake exception?
        jae     DIU_Continue            ;Yes, don't unhook anything!
        cmp     [si].ii_wType,I_EXCEPTION ;Exception?
        jnz     DIU_Interrupt           ;Nope, hook as interrupt

        ;** Unhook exception (DPMI)
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,WORD PTR [si].ii_dwChain ;Put back the old offset
        mov     cx,WORD PTR [si].ii_dwChain + 2 ;Put back the old selector
        int     31h                     ;Call DPMI
        jmp     SHORT DIU_Continue

        ;** Unhook interrupt (DOS)
DIU_Interrupt:
        mov     ah,35h                  ;Get interrrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     21h                     ;Call DOS
        mov     ah,25h                  ;Set interrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,WORD PTR [si].ii_dwChain ;Put back the old offset
        push    ds
        mov     ds,WORD PTR [si].ii_dwChain + 2 ;Put back the old selector
        int     21h                     ;Call DOS
        pop     ds

        ;** Prepare for next in table
DIU_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        pop     cx                      ;Get loop counter back
        loop    DIU_HandlerLoop         ;Loop back

        ;** Prepare the linked list
        mov     npIntHead,0             ;Put a NULL in the list head

DIU_End:

cEnd

InterruptEntry  MACRO  Name, wBytes
        labelFP Name                    ;;Start at this address
        PUBLIC  Name
        sub     sp,wBytes               ;;Leave room on stack for return val
        push    bx                      ;;Save for the info pointer
ENDM

InterruptJump   MACRO pInfo
        mov     bx,OFFSET pInfo         ;;Point to interrupt info
        jmp     DIH_Main
ENDM

;  InterruptHandler
;       This routine is used to handle interrupts as they come in.  This
;       routine has multiple entry points; a seperate one for each int/
;       exception trapped.   Because interrupts and exceptions have
;       different stack frames, they are handled by two different code
;       sections.

cProc   InterruptHandler, <FAR,PUBLIC>
cBegin  NOGEN

        ;** All interrupt entry points here

        InterruptEntry GP_Handler, 14   ;Normal GP fault
        InterruptJump GP_Info
        InterruptEntry GP_StdModeHandler, 12 ;3.0 Std mode GP fault
        InterruptJump GP_Info
        InterruptEntry SF_Handler, 14   ;Normal Stack Fault
        InterruptJump SF_Info
        InterruptEntry SF_StdModeHandler, 12 ;3.0 Std mode Stack Fault
        InterruptJump SF_Info
        InterruptEntry PF_Handler, 14   ;Page fault
        InterruptJump PF_Info
        InterruptEntry PF_StdModeHandler, 10 ;3.0 Std mode Page fault
        InterruptJump PF_Info
        InterruptEntry UD_Handler, 14   ;Undefined opcode
        InterruptJump UD_Info
        InterruptEntry Int1_Handler, 14 ;Int 1
        InterruptJump Int1_Info
        InterruptEntry Int3_Handler, 14 ;Int 3
        InterruptJump Int3_Info
        InterruptEntry CASRq_Handler, 14 ;Ctrl-Alt-SysRq (not really an int)
        InterruptJump CASRq_Info

        ;** The divide by zero case has to include checking to make sure
        ;**     that this isn't GDI's divide by zero.

        InterruptEntry Div0_Handler, 14

        ;** Check to see if GDI wants this Div0
        push    ds                      ;Save some registers
        push    es
        mov     bx,_DATA                ;Point to our data
        mov     ds,bx                   ;  with DS
        mov     bx,WORD PTR lpGDIFlag[0];Get the low word
        push    bx
        or      bx,WORD PTR lpGDIFlag[2];Do we have a flag to look at?
        pop     bx
        jz      DIH_NoFlag              ;No.  Do this the hard way

        ;** Since we have a pointer to GDI's flag to look at, use it
        mov     es,WORD PTR lpGDIFlag[2];Get the seg value
        cmp     WORD PTR es:[bx],0      ;The flag is nonzero if GDI wants it
        je      DIH_NormalDiv0          ;GDI doesn't want it

        ;** GDI wants the Div0 so chain to it
DIH_ChainToGDI:
        pop     es                      ;Restore registers
        pop     ds                      ;  (Doesn't trash flags)
        push    bp                      ;Make the same stack frame for compat
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds
        push    es
        mov     ax,_DATA                ;Get the data segment
        mov     ds,ax                   ;Point with DS
        mov     bx,OFFSET Div0_Info     ;This fault's info
        jmp     DIH_DPMIChainOn         ;Chain on (ignore the int)

DIH_NormalDiv0:
        pop     es                      ;Restore registers
        pop     ds
        InterruptJump Div0_Info

        ;** We didn't get a GDI flag (only present in 3.1) so instead, we
        ;*      check the owner of the CS where the fault occurred.  If
        ;**     the owner is GDI, we ignore the Div0.
DIH_NoFlag:
        push    bp                      ;Make a stack frame
        mov     bp,sp
        sub     sp,SIZE GLOBALENTRY     ;Make room for a structure
Global  EQU     [bp - SIZE GLOBALENTRY] ;Point to our structure
        pusha                           ;Save all registers
        mov     WORD PTR Global.ge_dwSize[0],SIZE GLOBALENTRY ;Size of struct
        mov     WORD PTR Global.ge_dwSize[2],0
        lea     bx,Global               ;Point to the structure
        test    wTHFlags,TH_WIN30STDMODE ;3.0 std mode?
        jnz     DIH_Div0_StdMode        ;Yes
        mov     ax,[bp + 1ah + 4]       ;Get the CS value (4 is extra BP,BX
        jmp     SHORT @F                ;  pushed by InterruptEntry macro)
DIH_Div0_StdMode:
        mov     ax,[bp + 14h + 4]       ;Get the CS value
@@:     cCall   GlobalEntryHandle, <ss,bx,ax> ;Get info about the CS
        or      ax,ax                   ;Did the call succeed?
        jne     @F                      ;Yes, go on
        popa                            ;No, clear stack frame and do normal
        mov     sp,bp
        pop     bp
        jmp     DIH_NormalDiv0          ;Jump to normal processing
@@:     mov     ax,Global.ge_hOwner     ;Get the owner
        cCall   HelperHandleToSel, <ax> ;Make it a selector
        cmp     hGDI,ax                 ;Is this owned by GDI?
        popa                            ;Restore the registers
        mov     sp,bp                   ;Clear stack frame
        pop     bp
        je      DIH_ChainToGDI          ;Yes, so give the interrupt to it
        jmp     DIH_NormalDiv0          ;No, do normal stuff

        ;** We now have to first find the item on the block to see if we
        ;**     want to handle the interrupt.
PubLabel CommonInterruptEntry
DIH_Main:
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds
        push    es

        ;** We check first to see if this was a GP fault received from the
        ;*      parameter validation code.  If it was, we just chain on
        ;*      just as if we don't find any handlers.
        ;**
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax
        FSTI                             ;Must have interrupts on
        cmp     bx,OFFSET GP_Info       ;GP Fault?
        jnz     DIH_NotPVGPFault        ;No.
        mov     cx,WORD PTR lpfnPV[0]   ;Get the low word
        or      cx,WORD PTR lpfnPV[2]   ;Param Validation stuff present?
        jz      DIH_NotPVGPFault        ;No, skip this

        ;** Check to see if the parameter validation code wants the fault
        push    ds
        push    bx
        push    [bp + 1Ah]              ;Push faulting CS:IP
        push    [bp + 18h]
        call    [lpfnPV]                ;Call it
        pop     bx
        pop     ds
        or      ax,ax                   ;Non-zero means this was PV fault
        je      DIH_NotPVGPFault        ;Not a PV GP fault

        ;** It is a parameter validation fault so ignore it
        jmp     DIH_DPMIChainOn         ;Chain the fault on--we don't want it

        ;** We check here to see if the INT3 we received is from the CASRq
        ;*      handler.  If it was, we have to replace the INT3 with the
        ;*      previous byte and tell the user this was actually a CASRq
        ;**     event (not an INT3).
PubLabel DIH_NotPVGPFault
        cmp     bx,OFFSET Int3_Info     ;INT3?
        jnz     DIH_NotCASRq            ;Nope, ignore all this
        cmp     wCASRqFlag,0            ;Was this because of CASRq?
        je      DIH_NotCASRq            ;No.
        mov     ax,[bp + 12h]           ;INT3 is an IRET frame.  Get bkpt IP
        dec     ax                      ;Breaks AFTER instruction
        cmp     WORD PTR dwCASRqCSIP[0],ax ;Is this the right CASRq address?
        jne     DIH_NotCASRq            ;Nope
        mov     dx,[bp + 14h]           ;Get the breakpoint CS
        cmp     WORD PTR dwCASRqCSIP[2],dx ;Is this correct?
        jne     DIH_NotCASRq            ;Nope
        push    ax                      ;Save the IP value
        cCall   AllocCStoDSAlias, <dx>  ;Get a data alias to the CS
        mov     es,ax                   ;Point with ES
        pop     si                      ;Restore the IP value
        mov     [bp + 12h],si           ;Back to instr where INT3 was
        mov     al,BYTE PTR wCASRqFlag  ;Get the saved byte
        mov     es:[si],al              ;Put it back in the code
        mov     wCASRqFlag,0            ;Clear the flag
        cCall   FreeSelector, <es>      ;Get rid of the alias
        mov     bx,OFFSET CASRq_Info    ;Point to the CASRq information

        ;** See if we have at least one handler.  We should always have one.
PubLabel DIH_NotCASRq
        mov     si,npIntHead            ;Get the list start
        or      si,si                   ;Are there any routines hooked?
        jnz     DIH_Found               ;There should ALWAYS be at least one
                                        ;  routine hooked (otherwise, the
                                        ;  interrupt hooks should have
                                        ;  already been removed)

        ;** Return the stack to its prior state and chain on.
        ;*      We only get here in an erroneous state.  We keep the code in
        ;*      to avoid GP faulting if things get wierd.
        ;*      The stack looks like this:
        ;*              ------------
        ;*              |    ES    |
        ;*              |    DS    |
        ;*              |   PUSHA  |
        ;*         BP-->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |  Empty   |  [BP + 04h]
        ;*              |  Empty   |  [BP + 06h]
        ;*              |  Empty   |  [BP + 08h]
        ;*              |  Empty   |  [BP + 0Ah]
        ;*              |  Empty   |  [BP + 0Ch]
        ;*              |Our Ret IP|  [BP + 0Eh]
        ;*              |Our Ret CS|  [BP + 10h]
        ;*              |Original  |
        ;*              |  Frame   |
        ;*              |   ....   |
        ;*              ------------
        ;**
PubLabel DIH_DPMIChainOn
        mov     ax,WORD PTR [bx].ii_dwChain ;Get the LOWORD
        mov     [bp + 0eh],ax           ;Put into the frame we created
        mov     ax,WORD PTR [bx].ii_dwChain + 2 ;Get the HIWORD
        mov     [bp + 10h],ax           ;Put into the frame
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,10                   ;Clear extra space
        retf                            ;This uses our own "return" frame
                                        ;  to chain on

        ;** Since we found the entry, we have to call the user callback.
        ;*      Because we must be reentrant at this state, we have to make
        ;*      sure that we're safe.  To do so, we must do different
        ;**     actions for DPMI and for DOS frames.
PubLabel DIH_Found
        cmp     [bx].ii_wType,I_EXCEPTION ;DPMI Exception frame?
        je      @F
        jmp     DIH_SkipDPMI            ;No.  Skip DPMI processing
@@:

        ;** If we are in Win3.0 Std Mode, the DPMI frame was broken.  It
        ;*      simply left the normal IRET frame on the stack *AND* the
        ;**     error code.
        test    wTHFlags,TH_Win30StdMode ;3.0 Std mode?
        jz      @F
        jmp     DIH_SkipDPMI            ;Yes
@@:

        ;** Tell DPMI that the exception is over.  Before we do this,
        ;*      however, save information we'll need later on the user stack.
        ;*      The stack currently looks like this:
        ;*              ------------
        ;*              |    ES    |
        ;*              |    DS    |
        ;*              |   PUSHA  |
        ;*         BP-->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |  Empty   |  [BP + 04h]
        ;*              |  Empty   |  [BP + 06h]
        ;*              |  Empty   |  [BP + 08h]
        ;*              |  Empty   |  [BP + 0Ah]
        ;*              |  Empty   |  [BP + 0Ch]
        ;*              |  Empty   |  [BP + 0Eh]
        ;*              |  Empty   |  [BP + 10h]
        ;*              |  Ret IP  |  [BP + 12h]    <-
        ;*              |  Ret CS  |  [BP + 14h]      |
        ;*              |Error Code|  [BP + 16h]      | Pushed by DPMI
        ;*              |    IP    |  [BP + 18h]      |
        ;*              |    CS    |  [BP + 1Ah]      | (Locked stack)
        ;*              |   Flags  |  [BP + 1Ch]      |
        ;*              |    SP    |  [BP + 1Eh]      |
        ;*              |    SS    |  [BP + 20h]    <-
        ;*              ------------
        ;*
        ;*      Before returning to DPMI, however, we want to create a
        ;*      stack frame on the user's stack that we will be returning
        ;*      to so we can preserve information in a reentrant fashion.
        ;*      The user's stack will appear like this:
        ;*              ------------
        ;*       BP---->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |Our Ret IP|  [BP + 04h]
        ;*              |Our Ret CS|  [BP + 06h]
        ;*              |  Ret IP  |  [BP + 08h]
        ;*              |  Ret CS  |  [BP + 0Ah]
        ;*              |    AX    |  [BP + 0Ch]
        ;*              |Exception#|  [BP + 0Eh]
        ;*              |  Handle  |  [BP + 10h]
        ;*              |    IP    |  [BP + 12h]
        ;*              |    CS    |  [BP + 14h]
        ;*              |   Flags  |  [BP + 16h]
        ;*              ------------
        ;**

PubLabel DIH_Exception

        ;** Check to see if we're already on the faulting stack.  If we are,
        ;**     we want to shift everything up on this stack so that we
        ;**     have room for the TOOLHELP user frame
        mov     ax,ss                   ;Get the current SS
	cmp	ax,WORD PTR ss:[bp + 20h] ;Is it the same as the user frame?
	jne	DIH_EnoughRoomOnStack    ;No, ignore all of this

        ;** Move everything up by copy everything that's on stack now to
        ;**     above where SP starts at.  This actually uses too much
        ;**     stack, but it's safe and easy.
	push	bp                      ;We use BP to do copy
	lea	bp,[bp + 20h]           ;Point to lowest WORD to copy
	mov	ax,sp                   ;Point to position to copy to
	dec	ax
	dec	ax
DIH_CopyLoop:
	push	WORD PTR [bp]           ;Copy a WORD
	dec	bp                      ;Point to next WORD to copy
	dec	bp
	cmp	bp,ax                   ;Done yet?
	jne	DIH_CopyLoop            ;No
	pop	bp                      ;Yes, compute new BP value
	sub	bp,56                   ;Point BP to right place

        ;** Put stuff on DPMI's stack
PubLabel DIH_EnoughRoomOnStack
        mov     di,[bp + 1Eh]           ;Get the old SP value
        mov     cx,[bp + 20h]           ;  and the SS value
        cmp     di,MIN_STACK_ALLOWED    ;Are we going to stack fault?
        jb      DIH_BadStack            ;Yes, so swich
        mov     ax,__WinFlags           ;Make sure we have a 386 or higher
        test    ax,WF_CPU286
        jnz     DIH_SkipBigCheck        ;No need to check big bit
.386p
        push    eax                     ;Make sure we don't trash EAX
        lar     eax,ecx                 ;Get the access rights DWORD
        test    eax,00400000h           ;Check the BIG bit
        pop     eax
        jnz     DIH_BadStack            ;Don't use this stack if BIG
.286p
DIH_SkipBigCheck:
        mov     ax,di                   ;Get the stack pointer
        add     ax,2                    ;Point just beyond
        cCall   HelperVerifySeg, <cx,ax> ;Is this seg OK?
        or      ax,ax                   ;Check for success
        jz      DIH_BadStack            ;Stack is bogus, don't change to it

PubLabel DIH_StackOK
        sub     di,20                   ;Reserve space for the user frame
        mov     ds,cx                   ;Get stack value in DS
        mov     dx,[bp + 1Ah]           ;Get the old CS value
        mov     cx,[bp + 18h]           ;Get the old IP value
        mov     ax,[bp + 1Ch]           ;Get the old flags
        mov     [bp + 1Eh],di           ;Save as new SP value
        sub     di,4                    ;Make DI equal to what BP will be
        mov     [bp + 1Ah],cs           ;Prepare to IRET to ourself
        mov     [bp + 18h],OFFSET _TEXT:DIH_DPMIRestart

        ;** Save some things on the user's stack before returning
        mov     [di + 16h],ax           ;Save the flags
        mov     [di + 14h],dx           ;Save the old CS value
        mov     [di + 12h],cx           ;Save the old IP value
        mov     [di + 0Eh],bx           ;INT_INFO pointer to new stack
        mov     [di + 10h],si           ;Handle to new stack

        ;** Clear the Trace and Ints Enabled flags
        and     [bp + 1Ch],NOT 0100h    ;Clear TF.  We don't want to trace here
        pop     es                      ;Clear the DPMI stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear extra allocated space
        retf

        ;** The user stack is bad, so we want to stay on the fault handler
        ;**     stack.  In order to do this, we have to build a frame for
        ;**     the callback directly on the fault handler stack.
        ;**     We build the frame here and jump to it.
        ;**              ------------
        ;**              |    ES    |
        ;**              |    DS    |
        ;**              |   PUSHA  |
        ;**         BP-->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |  Empty   |  [BP + 04h]
        ;**              |Our Ret IP|  [BP + 06h]   ; Client callback addr
        ;**              |Our Ret CS|  [BP + 08h]
        ;**              |  Ret IP  |  [BP + 0Ah]   ; TOOLHELP restart addr
        ;**              |  Ret CS  |  [BP + 0Ch]
        ;**              |    AX    |  [BP + 0Eh]   ; Saved AX for MPI
        ;**              |Exception#|  [BP + 10h]   ; Exception number
        ;**              |  Handle  |  [BP + 12h]   ; TOOLHELP handle
        ;**              |    IP    |  [BP + 14h]   ; IRET frame of fault
        ;**              |    CS    |  [BP + 16h]
        ;**              |  Flags   |  [BP + 18h]
        ;**              |    SP    |  [BP + 1Ah]   ; Faulting SS:SP
        ;**              |    SS    |  [BP + 1Ch]
        ;**              |  Ret IP  |  [BP + 1Eh]   ; DPMI return address
        ;**              |  Ret CS  |  [BP + 20h]
        ;**              ------------
PubLabel DIH_BadStack
        mov     dx,[bp + 12h]           ;DPMI return CS:IP
        mov     cx,[bp + 14h]           ;  stored in CX:DX
        mov     ax,[bp + 18h]           ;Faulting IP
        mov     [bp + 14h],ax
        mov     ax,[bp + 1Ah]           ;Faulting CS
        mov     [bp + 16h],ax
        mov     ax,[bp + 1Ch]           ;Flags
        mov     [bp + 18h],ax
        mov     ax,[bp + 1Eh]           ;Faulting SP
        mov     [bp + 1Ah],ax
        mov     ax,[bp + 20h]           ;Faulting SS
        mov     [bp + 1Ch],ax
        mov     [bp + 1Eh],dx           ;DPMI ret IP
        mov     [bp + 20h],cx           ;DPMI ret CS
        mov     [bp + 12h],si           ;Point to INTERRUPT struct
        mov     ax,[bx].ii_wNumber      ;Get the interrupt number
        or      ax,BAD_STACK_FLAG       ;Flag the client that stack is bad
        mov     [bp + 10h],ax
        mov     ax,[bp - 02h]           ;Get the AX value from the PUSHA frame
        mov     [bp + 0Eh],ax
        mov     [bp + 0Ch],cs           ;Point to callback return address
        mov     [bp + 0Ah],OFFSET _TEXT:DIH_CallbackRestart
        mov     ax,WORD PTR [si].i_lpfn ;Point to the user callback OFFSET
        mov     [bp + 06h],ax
        mov     ax,WORD PTR [si].i_lpfn + 2 ;Point to callback segment
        mov     [bp + 08h],ax
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,2
        retf                            ;Jump to the user callback

        ;** At this point, DPMI IRETs back to us instead of to the faulting
        ;**      app.  We have to now create a stack frame identical to the
        ;**      frame used by interrupt-style hooks.  Note that we have
        ;**      already allocated the frame space (but not initialized it)
        ;**      before returning to DPMI.
        ;**      It will look like this:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |Our Ret IP|  [BP + 04h]
        ;**              |Our Ret CS|  [BP + 06h]
        ;**              |  Ret IP  |  [BP + 08h]
        ;**              |  Ret CS  |  [BP + 0Ah]
        ;**              |    AX    |  [BP + 0Ch]
        ;**              |Exception#|  [BP + 0Eh]
        ;**              |  Handle  |  [BP + 10h]
        ;**              |    IP    |  [BP + 12h]
        ;**              |    CS    |  [BP + 14h]
        ;**              |   Flags  |  [BP + 16h]
        ;**              ------------
        ;**
PubLabel DIH_DPMIRestart
        push    bx                      ;Save this register we're using
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all the registers
        push    ds
        push    es
        mov     bx,[bp + 0Eh]           ;Get the INT_INFO pointer back
        mov     si,[bp + 10h]           ;Get the INTERRUPT structure back
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax

        ;** We can now proceed with joint processing as we've matched the
        ;**     DOS interrupt frame
PubLabel DIH_SkipDPMI

        ;** Build our return frame and jump to the user callback
        mov     [bp + 10h],si           ;Point to INTERRUPT struct
        mov     ax,[bx].ii_wNumber      ;Get the interrupt number
        mov     [bp + 0Eh],ax           ;Put on frame
        mov     ax,[bp - 02h]           ;Get the AX value from the PUSHA frame
        mov     [bp + 0Ch],ax           ;Put on frame
        mov     [bp + 0Ah],cs           ;Point to callback return address
        mov     [bp + 08h],OFFSET _TEXT:DIH_CallbackRestart
        mov     ax,WORD PTR [si].i_lpfn ;Point to the user callback OFFSET
        mov     [bp + 04h],ax
        mov     ax,WORD PTR [si].i_lpfn + 2 ;Point to callback segment
        mov     [bp + 06h],ax
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        retf                            ;Jump to the user callback

        ;** When the callback returns, we have to know how to call the
        ;*      next matching callback or to chain on the interrupt list.
        ;*      We have to do a raft of special stuff if this was an
        ;*      exception so that the chained on handlers think it was
        ;**     DPMI that called them.
PubLabel DIH_CallbackRestart
        sub     sp,8                    ;Leave room for ret addresses
        push    bx                      ;For compat. with the above code
        push    bp                      ;Make the same stack frame
        mov     bp,sp
        pusha
        push    ds
        push    es

        ;** Get the next matching item on the list
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax
        mov     ax,[bp + 0Ch]           ;Get the saved AX value
        mov     [bp - 02h],ax           ;Put in PUSHA frame
        mov     si,[bp + 10h]           ;Get the last handle used
        or      si,si                   ;If NULL, app has messed with it
        jz      DIH_NukeIt              ;Nuke the app--it did a no-no
        mov     si,[si].i_pNext         ;Get the next item in the list
        or      si,si                   ;End of the line?
        jz      DIH_NextNotFound        ;Yes, chain on
        mov     ax,[bp + 0Eh]           ;Get the exception number
        cCall   InterruptInfo           ;Get the INT_INFO structure
        or      ax,ax                   ;If NULL return, user messed with #
        jz      DIH_NukeIt              ;  so nuke it
        mov     bx,ax                   ;Point with BX
        jmp     DIH_SkipDPMI            ;Process this one

        ;** If we don't find a match, we pass on to previous handler
PubLabel DIH_NextNotFound
        mov     ax,[bp + 0Eh]           ;Get the exception number
        and     ax,7fffh                ;Clear the new stack bit
        cCall   InterruptInfo           ;Find the INT_INFO structure
        or      ax,ax                   ;If the user messed with it,
        jz      DIH_NukeIt              ;  nuke the app.
        mov     si,ax                   ;Get the pointer in AX
        test    wTHFlags,TH_Win30StdMode ;3.0 Std mode?
        jnz     DIH_30StdChainOn        ;Always do normal chain on in 3.0sm
        cmp     [si].ii_wType,I_INTERRUPT ;Was this an interrupt?
        je      DIH_ChainOn             ;Yes, do normal chain on
        jmp     DIH_EmulateDPMI         ;No, do the DPMI chain on

PubLabel DIH_NukeIt
        push    [bp + 16h]              ;Copy the IRET frame for KERNEL
        push    [bp + 14h]
        push    [bp + 12h]

        push    0                       ;Nuke current task
        push    UAE_BOX OR GIVE_WDEB386 ;UAE box + give to wdeb
        push    cs                      ;Simulate a far jump
        call    NEAR PTR TerminateApp   ;Nuke the app

        ;** We only get here if WDEB386 is installed.  We tell it to set
        ;*      a breakpoint, then restart the app, in effect giving
        ;*      control to WDEB386.  Unfortunately, at this point, all
        ;**     fault handlers for this task have been removed
        add     sp,6                    ;Clear fake IRET frame
        mov     cx,[bp + 14h]           ;Faulting CS
        mov     bx,[bp + 12h]           ;Faulting IP
        mov     ax, 40h                 ;16 bit forced go command
        int     41h                     ;Call debugger
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear extra words
                                        ;  all that remains is IRET frame
        iret                            ;WDEB386 will get control

PubLabel DIH_NukeApp
        push    0                       ;Nuke current task
        push    UAE_BOX                 ;Draw the UAE box
        push    cs                      ;Simulate a far jump
        call    NEAR PTR TerminateApp   ;Nuke the app
        int     1                       ;Should never return
        jmp     SHORT DIH_ChainOn

        ;** In 3.0 standard mode we have to put an error code on the stack
        ;**     if it's a GP fault or.  If not, we just chain on normally
PubLabel DIH_30StdChainOn
        cmp     si,OFFSET GP_Info       ;Is this a GP fault?
        jne     DIH_ChainOn             ;No, handle normally
        mov     ax,WORD PTR [si].ii_dwChain ;Get the LOWORD
        mov     dx,WORD PTR [si].ii_dwChain + 2 ;Get HIWORD
        mov     bx,ax                   ;Save the LOWORD
        or      ax,dx                   ;Is there a chain on address?
        jz      DIH_NoChainAddr         ;No, just restart the instruction
        mov     [bp + 0Ch],bx           ;Put on stack so we can retf to it
        mov     [bp + 0Eh],dx
        mov     WORD PTR [bp + 10h],0   ;Zero the error code
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,8                    ;Clear extra words
        retf

PubLabel DIH_ChainOn
        mov     ax,WORD PTR [si].ii_dwChain ;Get the LOWORD
        mov     dx,WORD PTR [si].ii_dwChain + 2 ;Get HIWORD
        mov     bx,ax                   ;Save the LOWORD
        or      ax,dx                   ;Is there a chain on address?
        jz      DIH_NoChainAddr         ;No, just restart the instruction
        mov     [bp + 0Eh],bx           ;Put on stack so we can retf to it
        mov     [bp + 10h],dx
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,10                   ;Clear extra words
        retf

        ;** No chain on address was recorded so just restart the instruction
PubLabel DIH_NoChainAddr
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear all extra words
        iret                            ;  and restart instruction

        ;** Chain on a DPMI-style exception:
        ;**
        ;** The goal here is to make a fault frame that appears that DPMI
        ;**     has passed the next exception handler the interrupt.  We
        ;**     have only two important cases here:
        ;**             1) We have already told DPMI the int was finished.
        ;**             2) We have not told DPMI the int was finished and
        ;**                     have not switched off the fault handler stack
        ;**     We handle the cases differently:
        ;**     -If we have already told DPMI that the fault was handled,
        ;**      we have to make a new fault so that the next handler can see
        ;**      the frame.  This can be best accomplished by restarting the
        ;**      faulting instruction.  This will cause the same fault to
        ;**      happen and will make the same frame.
        ;**     -In the case of us still being on the fh stack, we have to
        ;**      rebuild the frame and chain on.
        ;**     The stack we're given looks like this:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |Our Ret IP|  [BP + 04h]
        ;**              |Our Ret CS|  [BP + 06h]
        ;**              |  Ret IP  |  [BP + 08h]
        ;**              |  Ret CS  |  [BP + 0Ah]
        ;**              |    AX    |  [BP + 0Ch]
        ;**              |Exception#|  [BP + 0Eh]
        ;**              |  Handle  |  [BP + 10h]
        ;**              |    IP    |  [BP + 12h]
        ;**              |    CS    |  [BP + 14h]
        ;**              |   Flags  |  [BP + 16h]
        ;**              |    SP    |  [BP + 18h]   ;Only here if on fh stack
        ;**              |    SS    |  [BP + 1Ah]
        ;**              |  Ret IP  |  [BP + 1Ch]   ;DPMI return address
        ;**              |  Ret CS  |  [BP + 1Eh]
        ;**              ------------
PubLabel DIH_EmulateDPMI
        mov     ax,[bp + 0Eh]           ;Get the exception number
        test    ax,BAD_STACK_FLAG       ;Still on fh stack?
        jnz     DIH_RebuildDPMIFrame    ;Yes, rebuild the frame

        ;** Rehook the exception so we're sure to get it first
        push    si                      ;Preserve handle
        mov     bx,ax                   ;Fault number in bx
        mov     wException,bx           ;Save as a static also
        mov     ax,0202h                ;Get exception handler - DPMI
        int     31h                     ;Call DPMI
        mov     WORD PTR lpOldHandler[0],dx ;Save the old exception handler
        mov     WORD PTR lpOldHandler[2],cx
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     dx,OFFSET DIH_EmDPMIRestart
        mov     cx,cs                   ;Selector value of handler
        int     31h                     ;Call DPMI
        pop     si

        ;** Save the address of the next exception handler
        mov     ax,WORD PTR [si].ii_dwChain[0] ;Address to chain fault to
        mov     WORD PTR lpChainCSIP[0],ax
        mov     ax,WORD PTR [si].ii_dwChain[2]
        mov     WORD PTR lpChainCSIP[2],ax

        ;** Restart the instruction.  This will fault and jump to our
        ;**     newly-established handler at DIH_EmDPMIRestart
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear all extra words
        iret                            ;  and restart instruction

        ;** Now we're on the fault handler stack with a DPMI frame.  Throw
        ;**     it to the next handler on the chain
PubLabel DIH_EmDPMIRestart
        sub     sp,4                    ;Enough room for a RETF frame
        push    bp
        mov     bp,sp
        pusha
        push    ds
        push    es
        mov     ax,_DATA                ;Point to TOOLHELP's DS
        mov     ds,ax

        ;** Restore the exception handler
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bx,wException           ;Get exception number
        mov     dx,WORD PTR lpOldHandler[0] ;Get the exception handler address
        mov     cx,WORD PTR lpOldHandler[2]
        int     31h                     ;Call DPMI

        ;** Put the chain address on the stack so we can return to it
        mov     ax,WORD PTR lpChainCSIP[0] ;Get chain address
        mov     [bp + 02h],ax
        mov     ax,WORD PTR lpChainCSIP[2]
        mov     [bp + 04h],ax

        ;** Restore registers and jump to the handler
        pop     es
        pop     ds
        popa
        pop     bp
        retf

        ;** Since we are already on the fault handler stack, there is no
        ;**     need to fault again.  All we have to do here is recreate the
        ;**     DPMI fault stack as if the fault had just occurred.  It would
        ;**     be nice to clear the exception and then make it fault again,
        ;**     but since we only get here in potentially stack-faulting
        ;**     conditions, we cannot do this.  We just build a reasonable
        ;**     facsimile of the frame and chain on.  This frame should
        ;**     look as follows when we're done:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |   Empty  |  [BP + 04h]
        ;**              |   Empty  |  [BP + 06h]
        ;**              |   Empty  |  [BP + 08h]
        ;**              |   Empty  |  [BP + 0Ah]
        ;**              | Chain IP |  [BP + 0Ch]
        ;**              | Chain CS |  [BP + 0Eh]
        ;**              |  Ret IP  |  [BP + 10h]
        ;**              |  Ret CS  |  [BP + 12h]
        ;**              |Error Code|  [BP + 14h]   ;Always return zero
        ;**              |    IP    |  [BP + 16h]
        ;**              |    CS    |  [BP + 18h]   ;Only here if on fh stack
        ;**              |   Flags  |  [BP + 1Ah]
        ;**              |    SP    |  [BP + 1Ch]   ;DPMI return address
        ;**              |    SS    |  [BP + 1Eh]
        ;**              ------------

PubLabel DIH_RebuildDPMIFrame
        mov     dx,[bp + 1Ch]           ;DPMI return CS:IP
        mov     cx,[bp + 1Eh]           ;  stored in CX:DX
        mov     ax,[bp + 1Ah]           ;Faulting SS
        mov     [bp + 1Eh],ax
        mov     ax,[bp + 18h]           ;Faulting SP
        mov     [bp + 1Ch],ax
        mov     ax,[bp + 16h]           ;Flags
        mov     [bp + 1Ah],ax
        mov     ax,[bp + 14h]           ;Faulting CS
        mov     [bp + 18h],ax
        mov     ax,[bp + 12h]           ;Faulting IP
        mov     [bp + 16h],ax
        xor     ax,ax                   ;Error code
        mov     [bp + 14h],ax
        mov     [bp + 12h],cx           ;DPMI ret CS
        mov     [bp + 10h],dx           ;DPMI ret IP
        mov     ax,WORD PTR [si].ii_dwChain[2] ;Address to chain fault to
        mov     [bp + 0Eh],ax
        mov     ax,WORD PTR [si].ii_dwChain[0]
        mov     [bp + 0Ch],ax
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,8                    ;Clear all extra words
        retf

cEnd    NOGEN


;** Helper functions

;  InterruptInfo
;       Gets a pointer to the INT_INFO structure given the interrupt
;       number.  Accepts the int number in AX and returns the pointer in AX.
;       Preserves all other registers

cProc   InterruptInfo, <NEAR,PUBLIC>, <si,cx>
cBegin
        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT + 1    ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array

        ;** Is this a match?
II_HandlerLoop:
        cmp     [si].ii_wNumber,ax      ;Match?
        jz      II_End                  ;Yes, return the pointer

        ;** Prepare for next in table
II_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        loop    II_HandlerLoop          ;Loop back
        xor     si,si                   ;Return NULL for not found

II_End:
        mov     ax,si                   ;Get return value
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\int1.c ===
/**************************************************************************
 *  INT1.C
 *
 *      Routines used to implement the interrupt trapping API in
 *      TOOLHELP.DLL
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wIntInstalled;
    INTERRUPT NEAR *npIntHead;

/*  InterruptRegister
 *      Registers an interrupt callback.
 */

BOOL TOOLHELPAPI InterruptRegister(
    HANDLE hTask,
    FARPROC lpfnCallback)
{
    INTERRUPT *pInt;
    INTERRUPT *pTemp;

    /* Make sure TOOLHELP.DLL is installed */
    if (!wLibInstalled)
        return FALSE;

    /* If the interrupt hook has not yet been installed, install it */
    if (!wIntInstalled)
    {
        /* Make sure we can hook! */
        if (!InterruptInit())
            return FALSE;
        wIntInstalled = TRUE;
    }

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Register a death signal handler for this task (does nothing if one
     *  is already installed.
     */
    SignalRegister(hTask);

    /* Check to see if this task is already registered */
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            return FALSE;

    /* Allocate a new INTERRUPT structure */
    pInt = (INTERRUPT *)LocalAlloc(LMEM_FIXED, sizeof (INTERRUPT));
    if (!pInt)
        return FALSE;

    /* Fill in the useful fields */
    pInt->hTask = hTask;
    pInt->lpfn = (LPFNCALLBACK) lpfnCallback;

    /* If this is the only handler, just insert it */
    if (!npIntHead)
    {
        pInt->pNext = npIntHead;
        npIntHead = pInt;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npIntHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pInt->pNext = pTemp->pNext;
        pTemp->pNext = pInt;
    }

    return TRUE;
}


/*  InterruptUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL TOOLHELPAPI InterruptUnRegister(
    HANDLE hTask)
{
    INTERRUPT *pInt;
    INTERRUPT *pBefore;

    /* Make sure we have interrupt installed and that TOOLHELP is OK */
    if (!wLibInstalled || !wIntInstalled)
        return FALSE;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            break;
        else
            pBefore = pInt;
    if (!pInt)
        return FALSE;

    /* Unhook the death signal proc only if there is no interrupt handler */
    if (!NotifyIsHooked(hTask))
        SignalUnRegister(hTask);

    /* Remove it from the list */
    if (!pBefore)
        npIntHead = pInt->pNext;
    else
        pBefore->pNext = pInt->pNext;

    /* Free the structure */
    LocalFree((HANDLE)pInt);

    /* If there are no more handlers, unhook the callback */
    if (!npIntHead)
    {
        InterruptUnInit();
        wIntInstalled = FALSE;
    }

    return TRUE;
}

/* ----- Helper functions ----- */

/*  InterruptIsHooked
 *      Returns TRUE iff the parameter task already has a interrupt hook.
 */

BOOL PASCAL InterruptIsHooked(
    HANDLE hTask)
{
    INTERRUPT *pInt;

    /* Loop thorugh all interrupts */
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            break;

    /* Return found/not found */
    return (BOOL)pInt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\class2.asm ===
;**************************************************************************
;*  CLASS2.ASM
;*
;*      Assembly support for the class enumeration routines.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 0
SWAPPRO = 0
        INCLUDE TDB.INC

;** Class structure
CLS STRUC
cls_pclsNext    DW      ?
cls_clsMagic    DW      ?
cls_atom        DW      ?
cls_pdce        DW      ?
cls_RefCount    DW      ?
cls_style       DW      ?
cls_lpfnWndProc DD      ?
cls_cbclsExtra  DW      ?
cls_cbwndExtra  DW      ?
cls_hInstance   DW      ?
cls_hIcon       DW      ?
cls_hCursor     DW      ?
cls_hbrBackgr   DW      ?
cls_lpszMnName  DW      ?
cls_lpszClsName DW      ?
CLS ENDS

;** External functions
externNP HelperVerifySeg
externFP GetAtomName

;** Functions

sBegin  CODE
        assumes CS,CODE

;  ClassInfo
;
;       Returns information about the class with the given block handle

cProc   ClassInfo, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpClass
        parmW   wOffset
cBegin
        ;** Start by verifying that we can read the segment here
        mov     ax,hUserHeap            ;Get the selector
        mov     bx,wOffset              ;  and the desired offset
        cCall   HelperVerifySeg, <ax,bx>
        or      ax,ax                   ;FALSE return?
        jnz     CI_SelOk                ;We're OK
        xor     ax,ax                   ;Return FALSE
        jmp     CI_End
CI_SelOk:

        ;** Point to the CLS structure with DS:SI.  Note that using DS to
        ;**     point to USER's DS is useful to get USER's local atoms
        mov     ax,hUserHeap            ;User's heap is User's DGROUP
        mov     ds,ax
        mov     si,wOffset              ;Get a pointer to the CLS structure

        ;** Copy the hInstance
        les     di,lpClass              ;Get the structure
        mov     ax,[si].cls_hInstance   ;Get the hInst of the class owner
        mov     es:[di].ce_hInst,ax     ;Save in the CLASSENTRY struct  

        ;** Get the string from the atom and copy the next pointer
        mov     ax,[si].cls_atom        ;Get the desired atom number
        lea     bx,[di].ce_szClassName  ;Get the offset to copy string to
        push    es                      ;Save ES (GetAtomName may trash)
        mov     cx,MAX_CLASSNAME        ;Get max classname length
        cCall   GetAtomName, <ax,es,bx,cx> ;Copy the atom string
        pop     es
        or      ax,ax                   ;OK?
        jnz     CI_20                   ;Yes
        mov     es:[di].ce_szClassName,0 ;No.  Clear the string
CI_20:  mov     ax,[si].cls_pclsNext    ;Get the next pointer
        mov     es:[di].ce_wNext,ax     ;Save it

        ;** Return TRUE on success
        mov     ax,TRUE
CI_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\krnlpeek.asm ===
;***************************************************************************
;*  KRNLPEEK.ASM
;*
;*      Assembly code used to peer into the heart of KERNEL and return
;*      information in global variables.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC            ;Include the TOOLHELP values
PMODE32 = 0                             ;This should work either way
PMODE   = 0
        INCLUDE WINKERN.INC
        INCLUDE WINDOWS.INC

;** Functions
externFP GlobalMasterHandle
externFP GlobalLock
externFP GetVersion
externFP GetProcAddress
externFP GetModuleHandle
externNP HelperHandleToSel

sBegin	DATA
externB	_szKernel
sEnd	DATA
;** Functions

sBegin  CODE
        assumes CS,CODE

;  void KernelType(void)
;
;       Returns information from KERNEL in global variables

cProc   KernelType, <PUBLIC>, <si,di>
cBegin
        mov     wTHFlags,0              ;Zero flags indicates error

.286
        ;** Call the undocumented function GlobalMasterHandle to get
        ;*      a pointer to the global HeapInfo structure.
        ;**     This is the means we can use to detect the kernel types.

        cCall   GlobalMasterHandle
        cCall   HelperHandleToSel, <dx> ;Convert it to a selector
        mov     hMaster,ax              ;Save the handle
        mov     wTHFlags,TH_KERNEL_386

KT_BothPModes:

        ;** Now get pmode KERNEL information
;        cCall   GetVersion              ;Which Windows version are we on
        mov     bx,SEG GlobalLock       ;KERNEL code segment selector
;	 cmp     ax,0004h                ;Win 4.0?
;        je      KT_Win31
;        mov     wTHFlags,0              ;Zero wTHFlags indicates error
;        jmp     SHORT KT_End            ;Unknown Windows version
KT_Win31:
	mov	ax,seg _DATA
	mov	dx,offset _DATA:_szKernel
	cCall	GetModuleHandle,<ax,dx>
	cCall	GetProcAddress,<ax,0,332>	; DX:AX -> hGlobalHeap
        mov     segKernel,dx            ;Save for later
        mov     es,dx                   ;Point with ES
	add	ax,4
	mov	npwExeHead,ax
	add	ax,10
	mov	npwTDBHead,ax
	add	ax,2
	mov	npwTDBCur,ax
	add	ax,6
	mov	npwSelTableLen,ax
	add	ax,2
	mov	npdwSelTableStart,ax
.8086
KT_End:

cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\local.c ===
/**************************************************************************
 *  LOCAL.C
 *
 *      Routines used to walk local heaps
 *
 **************************************************************************/

#include "toolpriv.h"

/* ----- Function prototypes ----- */

    NOEXPORT void NEAR PASCAL ComputeType(
        LOCALENTRY FAR *lpLocal);

/*  LocalInfo
 *      Reports information about the state of the indicated heap
 */

BOOL TOOLHELPAPI LocalInfo(
    LOCALINFO FAR *lpLocalInfo,
    HANDLE hHeap)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocalInfo ||
        lpLocalInfo->dwSize != sizeof (LOCALINFO))
        return FALSE;

    /* Get the item counts */
    if (wTHFlags & TH_KERNEL_386)
        lpLocalInfo->wcItems = WalkLoc386Count(hHeap);
    else
        lpLocalInfo->wcItems = WalkLoc286Count(hHeap);

    return TRUE;
}

/*  LocalFirst
 *      Finds the first block on a local heap.
 */

BOOL TOOLHELPAPI LocalFirst(
    LOCALENTRY FAR *lpLocal,
    HANDLE hHeap)
{
    WORD wFirst;

    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocal || lpLocal->dwSize != sizeof (LOCALENTRY))
        return FALSE;

    /* Convert the heap variable to a selector */
    hHeap = HelperHandleToSel(hHeap);

    /* Get the first item from the heap */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(wFirst = WalkLoc386First(hHeap)))
            return FALSE;
    }
    else
    {
        if (!(wFirst = WalkLoc286First(hHeap)))
            return FALSE;
    }

    
    /* Fill in other miscellaneous stuff */
    lpLocal->hHeap = hHeap;

    /* Get information about this item */
    if (wTHFlags & TH_KERNEL_386)
        WalkLoc386(wFirst, lpLocal, hHeap);
    else
        WalkLoc286(wFirst, lpLocal, hHeap);

    /* Guess at the type of the object */
    ComputeType(lpLocal);

    return TRUE;
}


/*  LocalNext
 *      Continues a local heap walk by getting information about the
 *      next item.
 */

BOOL TOOLHELPAPI LocalNext(
    LOCALENTRY FAR *lpLocal)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocal || lpLocal->dwSize != sizeof (LOCALENTRY))
        return FALSE;

    if (wTHFlags & TH_KERNEL_386)
        WalkLoc386(lpLocal->wNext, lpLocal, lpLocal->hHeap);
    else
        WalkLoc286(lpLocal->wNext, lpLocal, lpLocal->hHeap);

    /* See if this item is the last one.  If so, return done because this
     *  last item is NOT useful.
     */
    if (!lpLocal->wNext)
        return FALSE;

    /* Guess at the type of the object */
    ComputeType(lpLocal);

    return TRUE;
}


/*  ComputeType
 *      Computes the object type of an object
 */

NOEXPORT void NEAR PASCAL ComputeType(
    LOCALENTRY FAR *lpLocal)
{
    /* Decode the free/fixed/moveable bits */
    if (lpLocal->wFlags & 2)
        lpLocal->wFlags = LF_MOVEABLE;
    else if (lpLocal->wFlags & 1)
        lpLocal->wFlags = LF_FIXED;
    else
    {
        /* Free blocks never have a unique type so return */
        lpLocal->wFlags = LF_FREE;
        lpLocal->wType = LT_FREE;
        lpLocal->hHandle = NULL;
        return;
    }

    /* Decode the heap type if possible */
    UserGdiType(lpLocal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\memman.asm ===
;**************************************************************************
;*  MEMMAN.ASM
;*
;*      Returns information about the VMM.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC


sBegin  CODE
        assumes CS,CODE

;  MemManInfo
;
;       Returns information through DPMI about the VMM

cProc   MemManInfo, <PUBLIC,FAR>, <si,di,ds>
        parmD   lpMemMan
        localV  DPMIBuffer,30h          ;30h byte buffer for DPMI info
cBegin
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax

        ;** Fill the buffer with -1 so if the call messes up like
        ;**     in 3.0 std mode we get the correct results
        push    ss                      ;Point to the local variable block
        pop     es
        lea     di,DPMIBuffer           ;Get offset of buffer
        mov     cx,30h                  ;Max len of DPMI buffer
        mov     al,0ffh                 ;-1
        rep     stosb                   ;Fill buffer

        ;** Prepare to build public structure
        mov     ax,0500h                ;DPMI -- Get Free Memory Info
        lea     di,DPMIBuffer           ;Get offset of buffer
        int     31h                     ;Call DPMI
        jnc     MMI_10                  ;Success
        xor     ax,ax                   ;Return FALSE
        jmp     MMI_End                 ;Get out because of DPMI error
MMI_10: lds     si,lpMemMan             ;Point to the MEMMANINFO structure

        ;** Fill MEMMANINFO structure
        mov     ax,es:[di+0]            ;Loword of largest free block
        mov     WORD PTR [si].vmm_dwLargestFreeBlock,ax
        mov     ax,es:[di+2]            ;High word
        mov     WORD PTR [si].vmm_dwLargestFreeBlock + 2,ax
        mov     ax,es:[di+4]            ;Loword of largest unlockable block
        mov     WORD PTR [si].vmm_dwMaxPagesAvailable,ax
        mov     ax,es:[di+6]            ;Hiword
        mov     WORD PTR [si].vmm_dwMaxPagesAvailable + 2,ax
        mov     ax,es:[di+8]            ;Loword of largest lockable page
        mov     WORD PTR [si].vmm_dwMaxPagesLockable,ax
        mov     ax,es:[di+0ah]          ;Hiword
        mov     WORD PTR [si].vmm_dwMaxPagesLockable + 2,ax
        mov     ax,es:[di+0ch]          ;Loword of linear address space
        mov     WORD PTR [si].vmm_dwTotalLinearSpace,ax
        mov     ax,es:[di+0eh]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalLinearSpace + 2,ax
        mov     ax,es:[di+10h]          ;Loword of number of unlocked pages
        mov     WORD PTR [si].vmm_dwTotalUnlockedPages,ax
        mov     ax,es:[di+12h]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalUnlockedPages + 2,ax
        mov     ax,es:[di+14h]          ;Loword of number of free pages
        mov     WORD PTR [si].vmm_dwFreePages,ax
        mov     ax,es:[di+16h]          ;Hiword
        mov     WORD PTR [si].vmm_dwFreePages + 2,ax
        mov     ax,es:[di+18h]          ;Loword of total physical pages
        mov     WORD PTR [si].vmm_dwTotalPages,ax
        mov     ax,es:[di+1ah]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalPages + 2,ax
        mov     ax,es:[di+1ch]          ;Loword of free lin addr space (pages)
        mov     WORD PTR [si].vmm_dwFreeLinearSpace,ax
        mov     ax,es:[di+1eh]          ;Hiword
        mov     WORD PTR [si].vmm_dwFreeLinearSpace + 2,ax
        mov     ax,es:[di+20h]          ;Loword of size of paging file (pages)
        mov     WORD PTR [si].vmm_dwSwapFilePages,ax
        mov     ax,es:[di+22h]          ;Hiword
        mov     WORD PTR [si].vmm_dwSwapFilePages + 2,ax
        mov     [si].vmm_wPageSize,4096 ;Safe to hard code this for 386/486
        mov     ax,TRUE                 ;Return TRUE

MMI_End:
        
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\memory.asm ===
PAGE 60,150
;***************************************************************************
;*  MEMORY.ASM
;*
;*      Routines used to handle the read/write random memory API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC

;** Symbols
SI_CRITICAL     EQU     1
DI_CRITICAL     EQU     2

;** Imports
externA __AHINCR
externFP GlobalEntryHandle
externNP HelperHandleToSel

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  MemoryRead
;       Uses the passed in selector and offset to read memory into a user-
;       specified buffer.  This works for >64K segments and, if code, may
;       have been discarded.
;
;       This function is normally used for heap selectors.  However, if
;       a non-global heap selector is used, it must be less than 64K on
;       a 286.
;
;       Prototype:
;               DWORD MemoryRead(
;                       WORD wSel,      /* Selector to read from */
;                       DWORD dwOffset, /* Offset to read at */
;                       LPSTR lpBuffer, /* Buffer to put data into */
;                       DWORD dwcb)     /* Number of characters to read */
;       Returns number of characters read (ends at segment limit)

cProc   MemoryRead, <FAR,PUBLIC>, <si,di,ds>
        parmW   wSelector
        parmD   dwOffset
        parmD   lpBuffer
        parmD   dwcb
        localD  dwcbCopied
        localV  Global,<SIZE GLOBALENTRY>
cBegin
        ;** Make sure the segment is present.  We only will fault the
        ;**     segment in if it is a code segment
        cCall   HelperHandleToSel, <wSelector> ;Convert to sel from handle
        mov     wSelector, ax           ;Save it so we have a good sel
        mov     cx, ax
        push    WORD PTR lpBuffer[2]    ;Convert handle to selector
        cCall   HelperHandleToSel
        mov     WORD PTR lpBuffer[2], ax ;Save converted handle
        lar     ax,cx                   ;Get the access rights
        jnz     MR_ShortBad             ;Failed.  It's bad
        test    ax,8000h                ;Is it present?
        jnz     MR_Present              ;Yes
        test    ax,0800h                ;This bit set for code segments
        jnz     MR_FaultIn              ;Code segment, fault it in
MR_ShortBad:
        jmp     MR_Bad                  ;Return error
MR_FaultIn:
        mov     es,wSelector            ;Get the selector in ES.
        mov     al,es:[0]               ;Must be at least one byte long
MR_Present:
        
        ;** Check this block's length.  We use the global heap functions
        ;*      to do this because they check in the arena for the length.
        ;*      This is the only way to get lengths of 286 heap blocks
        ;**     beyond 64K.
        mov     ax,SIZE GLOBALENTRY     ;Get the size of the structure
        mov     WORD PTR Global.ge_dwSize[0],ax ;Save in the structure
        mov     WORD PTR Global.ge_dwSize[2],0 ;Clear the HIWORD
        lea     ax,Global               ;Point to the structure
        cCall   GlobalEntryHandle, <ss,ax,wSelector>
        or      ax,ax                   ;Was this a valid selector?
        jnz     MR_HeapSel              ;Yes, this is a heap selector

        ;** If this wasn't a heap selector, we get the length with an LSL.
        ;**     When used like this, 64K is the max on a 286
MR_NonHeap:
        mov     bx,wSelector            ;Get the selector
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jz      MR_32BitSize            ;No, do 32 bit size stuff
        lsl     dx,bx                   ;Get length in DX
        mov     WORD PTR Global.ge_dwBlockSize[0],dx ;Put in GLOBALENTRY struct
        mov     WORD PTR Global.ge_dwBlockSize[2],0
        jmp     SHORT MR_HeapSel
MR_32BitSize:
.386p
        lsl     edx,ebx
        mov     Global.ge_dwBlockSize,edx ;Put in GLOBALENTRY struct for later
.286p

MR_HeapSel:
        mov     dx,WORD PTR dwOffset[2] ;Get the HIWORD of segment offset
        cmp     dx,WORD PTR Global.ge_dwBlockSize[2] ;Check HIWORD of size
        jb      MR_OK                   ;Offset should be OK
        je      @F                      ;Equal.  Must check LOWORD
        jmp     MR_Bad                  ;Offset is not inside segment
@@:     mov     ax,WORD PTR dwOffset[0] ;Get the LOWORD of segment offset
        cmp     ax,WORD PTR Global.ge_dwBlockSize[0] ;Check LOWORD of size
        jb      MR_OK                   ;It's inside segment
        jmp     MR_Bad                  ;Not inside segment
MR_OK:

        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     MR_Do16Bit              ;Yes, do 16 bit stuff

        ;** Do this the 386 way (easy)
.386p
        mov     ax,wSelector            ;Point with DS
        mov     ds,ax                   ;  (keep copy in AX)
        mov     esi,dwOffset            ;Point into the big segment
        mov     ecx,dwcb                ;Get the copy length
        lsl     edx,eax                 ;Get the segment limit
        sub     edx,esi                 ;Get distance from offset to limit
        inc     edx                     ;Make this the real length
        cmp     ecx,edx                 ;Are we within the limit?
        jbe     SHORT MR_LimitOK        ;Yes
        mov     ecx,edx                 ;No, so make this the copy amount
MR_LimitOK:
        mov     edx,ecx                 ;Get the # of bytes to read for ret
        xor     edi,edi                 ;Clear the high word
        les     di,lpBuffer             ;Point to the dest. buffer
        mov     ax,cx                   ;Save the low bits of ECX
        shr     ecx,2                   ;Prepare for DWORD move
        jecxz   @F                      ;No zero-length DWORD moves!
        rep     movs  DWORD PTR [edi],DWORD PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     cx,ax                   ;Get a copy
        jecxz   @F                      ;Don't do zero!
        and     cx,03                   ;Do the remaining 3,2, or 1
        rep     movs BYTE PTR [edi], BYTE PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     ax,dx                   ;Bytes copied returned in DX:AX
        shr     edx,16
        jmp     MR_End                  ;Get out
.286p

        ;** Do this the 286 way (hard)
MR_Do16Bit:
        
        ;** Compute the actual copy length
        mov     ax,WORD PTR Global.ge_dwBlockSize[0] ;Get the segment size
        mov     dx,WORD PTR Global.ge_dwBlockSize[2]
        sub     ax,WORD PTR dwOffset[0] ;Get distance from offset to limit
        sbb     dx,WORD PTR dwOffset[2]
        cmp     dx,WORD PTR dwcb[2]     ;Off end of heap block?
        ja      MR_LimOk                ;No, just do it
        jb      MR_Truncate             ;Yes, must truncate our length
        cmp     ax,WORD PTR dwcb[0]     ;Are we off the end?
        jae     MR_LimOk                ;No, just do it
MR_Truncate:
        mov     WORD PTR dwcb[0],ax     ;Force this to be the new length
        mov     WORD PTR dwcb[2],dx
MR_LimOk:

        ;** Save the number of bytes to be copied for the return value
        mov     ax,WORD PTR dwcb[0]     ;Get the LOWORD
        mov     WORD PTR dwcbCopied[0],ax ;Save it
        mov     ax,WORD PTR dwcb[2]     ;Get the HIWORD
        mov     WORD PTR dwcbCopied[2],ax ;Save it

        ;** Position the initial copying selectors
        mov     al,BYTE PTR dwOffset[2] ;Grab the HIWORD (286 is only 24 bits)
        mov     ah,__AHINCR             ;Get the selector inc value
        mul     ah                      ;Multiply to get sel offset
        add     ax,wSelector            ;AX = sel in sel array
        mov     ds,ax                   ;Point to this with DS
        mov     si,WORD PTR dwOffset[0] ;Get the current pointers
        les     di,lpBuffer

        ;** This is the main copying loop
MR_CopyLoop:
        
        ;** Compute the size of this block copy.  This is done by finding the
        ;*      smaller of the following quantities:
        ;*      - Distance to end of source segment
        ;*      - Distance to end of dest. segment
        ;**     - Distance to end of copy
        xor     bx,bx                   ;Flags start at zero
        xor     cx,cx                   ;Get the highest segment value (64K)
        cmp     di,si                   ;The bigger of the two will win
        je      MR_Equal                ;They're the same
        ja      MR_DIBigger             ;DI is bigger
        sub     cx,si                   ;SI bigger, compute dist to end
        or      bx,SI_CRITICAL          ;Flag set for SI-critical
        jmp     SHORT MR_CheckEndCopy   ;Go on
MR_Equal:
        sub     cx,di                   ;Use DI (SI and DI are the same)
        or      bx,SI_CRITICAL OR DI_CRITICAL ;Both will come true
        jmp     SHORT MR_CheckEndCopy   ;Go on
MR_DIBigger:
        sub     cx,di                   ;SI is bigger
        or      bx,DI_CRITICAL          ;Flag clear for DI-critical
MR_CheckEndCopy:
        cmp     WORD PTR dwcb[2],0      ;Check for less than 64K left
        ja      MR_DoCopy               ;Nope.  More than 64K left
        jcxz    MR_GetSize              ;CX = 0 is full 64K segment
        cmp     WORD PTR dwcb[0],cx     ;Less than in either segment left?
        ja      MR_DoCopy               ;No.  Do it
MR_GetSize:
        mov     cx,WORD PTR dwcb[0]     ;Get in CX
MR_DoCopy:

        ;** Do this block of 64K or less.
        mov     dx,cx                   ;Save the number of bytes we did
        jcxz    @F                      ;Do 64K
        shr     cx,1                    ;Do WORDS
        jmp     SHORT MR_10             ;Skip over
@@:     mov     cx,8000h                ;32K WORDS
MR_10:  jcxz    @F                      ;No zero length WORD moves!
        rep     movsw                   ;Do the copy
@@:     mov     cx,dx                   ;Get any remaining bits
        and     cx,1                    ;Any more to do?
        jcxz    @F                      ;No, don't do it
        movsb                           ;Do the odd byte if necessary
@@:     mov     cx,dx                   ;Get back in CX

        ;** Bump the loop pointers
        jcxz    MR_BigCount             ;We did 64K
        sub     WORD PTR dwcb[0],cx     ;Subtract the bytes done
        sbb     WORD PTR dwcb[2],0      ;  and don't forget the HIWORD
        jmp     SHORT MR_20             ;Continue
MR_BigCount:
        sub     WORD PTR dwcb[2],1      ;Subtract 64K
MR_20:  mov     ax,WORD PTR dwcb[0]     ;We're done if the count of bytes
        or      ax,WORD PTR dwcb[2]     ;  is zero
        jnz     @F                      ;Not zero, go on
        mov     dx,WORD PTR dwcbCopied[2] ;Get the return count
        mov     ax,WORD PTR dwcbCopied[0]
        jmp     SHORT MR_End            ;Get out
@@:     test    bx,SI_CRITICAL          ;Does SI need incrementing?
        jz      MR_TestDI               ;No, try DI
        mov     ax,ds                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     ds,ax                   ;Point with DS still
        xor     si,si                   ;Point to start of this segment
MR_TestDI:
        test    bx,DI_CRITICAL          ;Does SI need incrementing?
        jz      MR_Continue             ;No, try DI
        mov     ax,es                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     es,ax                   ;Point with DS still
        xor     di,di                   ;Point to start of this segment
MR_Continue:
        jmp     MR_CopyLoop             ;Do it again

MR_Bad:
        xor     ax,ax                   ;Return DWORD 0
        cwd

MR_End:

cEnd


;  MemoryWrite
;       Uses the passed in selector and offset to write memory from a user-
;       specified buffer.  This works for >64K segments and, if code, may
;       have been discarded.  The selector may be a selector or a handle
;       but MUST be on the global heap (no aliases or selector array
;       members).  If worried about low memory conditions, lpBuffer should
;       be in a (temporarily) fixed segment.
;
;       Prototype:
;               DWORD MemoryWrite(
;                       WORD wSel,      /* Selector to read from */
;                       DWORD dwOffset, /* Offset to read at */
;                       LPSTR lpBuffer, /* Buffer to put data into */
;                       DWORD dwcb)     /* Number of characters to read */
;       Returns number of characters read (ends at segment limit)

cProc   MemoryWrite, <FAR,PUBLIC>, <si,di,ds>
        parmW   wSelector
        parmD   dwOffset
        parmD   lpBuffer
        parmD   dwcb
        localW  wSelFlag
        localD  dwcbCopied
        localV  DPMISelBuf,8
        localV  Global,<SIZE GLOBALENTRY>
cBegin
        ;** Make sure the segment is present.  We only will fault the
        ;**     segment in if it is a code segment
        cCall   HelperHandleToSel, <wSelector> ;Convert to sel from handle
        mov     wSelector, ax           ;Save it
        mov     cx,ax                   ;Get the selector
        push    WORD PTR lpBuffer[2]    ;Convert handle to selector
        cCall   HelperHandleToSel
        mov     WORD PTR lpBuffer[2], ax ;Save converted handle
        mov     wSelFlag,0              ;Clear the flag
        lar     ax,cx                   ;Get the access rights
        jnz     MW_ShortBad             ;Failed
        test    ax,8000h                ;Is it present?
        jnz     MW_Present              ;Yes
        test    ax,0800h                ;This bit set for code segments
        jnz     MW_FaultIn              ;Code segment, fault it in
MW_ShortBad:
        jmp     MW_Bad                  ;Return error
MW_FaultIn:
        mov     es,wSelector            ;Get the selector in ES.
        mov     al,es:[0]               ;Must be at least one byte long
MW_Present:
        
        ;** Check this block's length.  We use the global heap functions
        ;*      to do this because they check in the arena for the length.
        ;*      This is the only way to get lengths of 286 heap blocks
        ;**     beyond 64K.
        mov     ax,SIZE GLOBALENTRY     ;Get the size of the structure
        mov     WORD PTR Global.ge_dwSize[0],ax ;Save in the structure
        mov     WORD PTR Global.ge_dwSize[2],0 ;Clear the HIWORD
        lea     ax,Global               ;Point to the structure
        cCall   GlobalEntryHandle, <ss,ax,wSelector>
        or      ax,ax                   ;Was this a valid selector?
        jnz     MW_HeapSel              ;Yes, this is a heap selector

        ;** If this wasn't a heap selector, we get the length with an LSL.
        ;**     When used like this, 64K is the max on a 286
MW_NonHeap:
        mov     bx,wSelector            ;Get the selector
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jz      MW_32BitSize            ;No, do 32 bit size stuff
        lsl     dx,bx                   ;Get length in DX
        mov     WORD PTR Global.ge_dwBlockSize[0],dx ;Put in GLOBALENTRY struct
        mov     WORD PTR Global.ge_dwBlockSize[2],0
        jmp     SHORT MW_HeapSel
MW_32BitSize:
.386p
        lsl     edx,ebx
        mov     Global.ge_dwBlockSize,edx ;Put in GLOBALENTRY struct for later
.286p

MW_HeapSel:
        mov     dx,WORD PTR dwOffset[2] ;Get the HIWORD of segment offset
        cmp     dx,WORD PTR Global.ge_dwBlockSize[2] ;Check HIWORD of size
        jb      MW_OK                   ;Offset should be OK
        je      @F                      ;Equal.  Must check LOWORD
        jmp     MW_Bad                  ;Offset is not inside segment
@@:     mov     ax,WORD PTR dwOffset[0] ;Get the LOWORD of segment offset
        cmp     ax,WORD PTR Global.ge_dwBlockSize[0] ;Check LOWORD of size
        jb      MW_OK                   ;It's inside segment
        jmp     MW_Bad                  ;Not inside segment
MW_OK:
        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     MW_Do16Bit              ;Yes, do 16 bit stuff

        ;** Do this the 386 way (easy)
.386p
        ;** Get an alias selector if necessary
        mov     ax,wSelector            ;Get the source selector
        push    ss                      ;Get ES = SS
        pop     es
        lea     di,DPMISelBuf           ;Point to our descriptor buffer
        cCall   MakeAlias               ;Make the alias selector
        jnc     SHORT @F                ;No error
        jmp     MW_Bad                  ;Must be error
@@:     mov     wSelFlag,bx             ;Set the selector flag
        mov     wSelector,ax            ;Save the new selector

        ;** Do the copying
        mov     ax,wSelector            ;Point with DS
        mov     es,ax                   ;  (keep copy in AX)
        mov     edi,dwOffset            ;Point into the big segment
        mov     ecx,dwcb                ;Get the copy length
        lsl     edx,eax                 ;Get the segment limit
        sub     edx,edi                 ;Get distance from offset to limit
        inc     edx                     ;Make this the real length
        cmp     ecx,edx                 ;Are we within the limit?
        jbe     SHORT MW_LimitOK        ;Yes
        mov     ecx,edx                 ;No, so make this the copy amount
MW_LimitOK:
        xor     esi,esi                 ;Clear the high word
        lds     si,lpBuffer             ;Point to the dest. buffer
        mov     eax,ecx                 ;Save ECX
        shr     ecx,2                   ;Prepare for DWORD move
        jecxz   @F                      ;No zero-length DWORD moves!
        rep     movs  DWORD PTR [edi],DWORD PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     ecx,eax                 ;Get a copy
        jecxz   @F                      ;Don't do zero!
        and     ecx,03                  ;Do the remaining 3,2, or 1
        rep     movs BYTE PTR [edi], BYTE PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     edx,eax                 ;Bytes copied returned in DX:AX
        shr     edx,16

        ;** Free alias if necessary
        push    ax                      ;Save return value
        push    dx
        cmp     wSelFlag,0              ;Selector flag set?
        je      SHORT @F                ;Nope
        mov     ax,1                    ;DPMI function - Free Selector
        mov     bx,wSelector            ;Selector to free
        int     31h                     ;Call DPMI
@@:     pop     dx
        pop     ax
        jmp     MW_End                  ;Get out
.286p

        ;** Do this the 286 way (hard)
MW_Do16Bit:
        
        ;** Compute the actual copy length
        mov     ax,WORD PTR Global.ge_dwBlockSize[0] ;Get the segment size
        mov     dx,WORD PTR Global.ge_dwBlockSize[2]
        sub     ax,WORD PTR dwOffset[0] ;Get distance from offset to limit
        sbb     dx,WORD PTR dwOffset[2]
        cmp     dx,WORD PTR dwcb[2]     ;Off end of heap block?
        ja      MW_LimOk                ;No, just do it
        jb      MW_Truncate             ;Yes, must truncate our length
        cmp     ax,WORD PTR dwcb[0]     ;Are we off the end?
        jae     MW_LimOk                ;No, just do it
MW_Truncate:
        mov     WORD PTR dwcb[0],ax     ;Force this to be the new length
        mov     WORD PTR dwcb[2],dx
MW_LimOk:

        ;** Save the number of bytes to be copied for the return value
        mov     ax,WORD PTR dwcb[0]     ;Get the LOWORD
        mov     WORD PTR dwcbCopied[0],ax ;Save it
        mov     ax,WORD PTR dwcb[2]     ;Get the HIWORD
        mov     WORD PTR dwcbCopied[2],ax ;Save it

        ;** Position the initial copying selectors
        mov     al,BYTE PTR dwOffset[2] ;Grab the HIWORD (286 is only 24 bits)
        mov     ah,__AHINCR             ;Get the selector inc value
        mul     ah                      ;Multiply to get sel offset
        add     ax,wSelector            ;AX = sel in sel array
        mov     es,ax                   ;Point to this with DS
        mov     di,WORD PTR dwOffset[0] ;Get the current pointers
        lds     si,lpBuffer

        ;** This is the main copying loop
MW_CopyLoop:

        ;** Get an alias selector if necessary
        push    si                      ;Save regs
        push    di
        mov     ax,es                   ;Get the source selector
        push    ss                      ;Get ES = SS
        pop     es
        lea     di,DPMISelBuf           ;Point to our descriptor buffer
        cCall   MakeAlias               ;Make the alias selector
        pop     di                      ;Restore regs
        pop     si
        jnc     @F                      ;No error
        jmp     MW_Bad                  ;Must be error
@@:     mov     wSelFlag,bx             ;Set the selector flag
        mov     es,ax                   ;Save the new selector
        
        ;** Compute the size of this block copy.  This is done by finding the
        ;*      smaller of the following quantities:
        ;*      - Distance to end of source segment
        ;*      - Distance to end of dest. segment
        ;**     - Distance to end of copy
        xor     bx,bx                   ;Flags start at zero
        xor     cx,cx                   ;Get the highest segment value (64K)
        cmp     di,si                   ;The bigger of the two will win
        je      MW_Equal                ;They're the same
        ja      MW_DIBigger             ;DI is bigger
        sub     cx,si                   ;SI bigger, compute dist to end
        or      bx,SI_CRITICAL          ;Flag set for SI-critical
        jmp     SHORT MW_CheckEndCopy   ;Go on
MW_Equal:
        sub     cx,di                   ;Use DI (SI and DI are the same)
        or      bx,SI_CRITICAL OR DI_CRITICAL ;Both will come true
        jmp     SHORT MW_CheckEndCopy   ;Go on
MW_DIBigger:
        sub     cx,di                   ;SI is bigger
        or      bx,DI_CRITICAL          ;Flag clear for DI-critical
MW_CheckEndCopy:
        cmp     WORD PTR dwcb[2],0      ;Check for less than 64K left
        ja      MW_DoCopy               ;Nope.  More than 64K left
        jcxz    MW_GetSize              ;CX = 0 is full 64K segment
        cmp     WORD PTR dwcb[0],cx     ;Less than in either segment left?
        ja      MW_DoCopy               ;No.  Do it
MW_GetSize:
        mov     cx,WORD PTR dwcb[0]     ;Get in CX
MW_DoCopy:

        ;** Do this block of 64K or less.
        mov     dx,cx                   ;Save the number of bytes we did
        jcxz    @F                      ;Do 64K
        shr     cx,1                    ;Do WORDS
        jmp     SHORT MW_10             ;Skip over
@@:     mov     cx,8000h                ;32K WORDS
MW_10:  jcxz    @F                      ;No zero-length WORD moves
        rep     movsw                   ;Do the copy
@@:     mov     cx,dx                   ;Get any remaining bits
        and     cx,1                    ;Any more to do?
        jcxz    @F                      ;No, don't do it
        movsb                           ;Do the odd byte if necessary
@@:     mov     cx,dx                   ;Get back in CX

        ;** Bump the loop pointers
        jcxz    MW_BigCount             ;We did 64K
        sub     WORD PTR dwcb[0],cx     ;Subtract the bytes done
        sbb     WORD PTR dwcb[2],0      ;  and don't forget the HIWORD
        jmp     SHORT MW_20             ;Continue
MW_BigCount:
        sub     WORD PTR dwcb[2],1      ;Subtract 64K
MW_20:  mov     ax,WORD PTR dwcb[0]     ;We're done if the count of bytes
        or      ax,WORD PTR dwcb[2]     ;  is zero
        jnz     @F                      ;Not zero, go on
        mov     dx,WORD PTR dwcbCopied[2] ;Get the return count
        mov     ax,WORD PTR dwcbCopied[0]
        jmp     SHORT MW_End            ;Get out
@@:     test    bx,SI_CRITICAL          ;Does SI need incrementing?
        jz      MW_TestDI               ;No, try DI
        mov     ax,ds                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     ds,ax                   ;Point with DS still
        xor     si,si                   ;Point to start of this segment
MW_TestDI:
        test    bx,DI_CRITICAL          ;Does SI need incrementing?
        jz      MW_Continue             ;No, try DI
        mov     ax,es                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     es,ax                   ;Point with DS still
        xor     di,di                   ;Point to start of this segment
MW_Continue:

        ;** Free alias if necessary
        cmp     wSelFlag,0              ;Selector flag set?
        je      @F                      ;Nope
        mov     ax,1                    ;DPMI function - Free Selector
        mov     bx,wSelector            ;Selector to free
        int     31h                     ;Call DPMI
@@:     jmp     MW_CopyLoop             ;Do it again

MW_Bad:
        xor     ax,ax                   ;Return DWORD 0
        cwd

MW_End:

cEnd


;** Helper functions

;  MakeAlias
;       Makes an alias selector for the selector in AX.  The new selector
;       is returned in AX.  Carry is set on exit if error.
;       Returns nonzero in BX if an alias was made, zero if not
;       ES:DI points to an 8-byte descriptor buffer

cProc   MakeAlias, <NEAR, PUBLIC>, <si,di>
cBegin

        ;** If this is not a read/write selector, we must create an alias.
        ;*      In order to be able to free up the selector, we set a flag
        ;**     so we know to free it.
        xor     si,si                   ;No alias made, just in case
        lar     cx,ax                   ;Get its access rights
        jnz     MA_Bad                  ;Failed
        test    cx,800h                 ;Is this a code segment?
        jnz     MA_MakeAlias            ;Yes.  Always make an alias
        test    cx,200h                 ;Is it read/write?
        jnz     MA_End                  ;Yes, no need for alias
MA_MakeAlias:
        mov     bx,ax                   ;Get the selector
        mov     ax,0bh                  ;DPMI function - Get Descriptor
                                        ;ES:DI already point to buffer
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        xor     ax,ax                   ;DPMI Function - Alloc selector
        mov     cx,1                    ;Alloc 1 selector
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        mov     si,1                    ;Set flag to say alias made
        and     BYTE PTR DPMISelBuf[5],0f0h ;Mask out unwanted bits
        or      BYTE PTR DPMISelBuf[5],2 ;Make it a R/W Data segment
        mov     bx,ax                   ;Selector in BX
        mov     ax,0ch                  ;DPMI function - Set Descriptor
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        mov     ax,bx                   ;Get the new selector in AX
        jmp     SHORT MA_End            ;Get out

MA_Bad:
        stc                             ;Error

MA_End:
        mov     bx,si                   ;Get flag in BX
cEnd


sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\notify2.asm ===
PAGE 60,150
;***************************************************************************
;*  NOTIFY2.ASM
;*
;*      Assembly code support routines used for the TOOLHELP.DLL
;*      notification API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
.286p

;** Data
sBegin  DATA

globalW wCASRqFlag,0                    ;Set when an CASRq INT3 has been set
globalD dwCASRqCSIP,0                   ;Holds the CS:IP of the CASRq INT3
globalD lpfnOldProc,0                   ;Old hook from new PTrace hook
szWinDebug      DB      'WINDEBUG', 0

;** WARNING!!
;**     This structure is set to the size of the largest notification
;**     structure.  This is currently NFYLOADSEG which is 16 bytes long.
;**     If a structure is added that is longer than this or if any other
;**     structure is added, this space must be increased to match!!
ReturnStruct    DB      16 DUP (?)

sEnd

;** Imports
externFP GetModuleHandle
externFP RegisterPTrace
externFP OutputDebugString
externFP AllocCStoDSAlias
externFP FreeSelector
externNP HelperHandleToSel

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  NotifyInit
;       Called when the first app registers a notification handler.
;       Hooks the Register PTrace notification.
;       Returns FALSE if we couldn't initialize, TRUE otherwise

cProc   NotifyInit, <NEAR,PUBLIC>, <si,di,ds>
cBegin
        ;** In the Windows 3.1 KERNEL, there is a special hook just for
        ;*      TOOLHELP that lets us get PTrace stuff and still coexist
        ;*      with old-fashioned debuggers.  We can check to see if the
        ;*      hook exists by simply checking the TOOLHELP flags
        ;**
        test    wTHFlags,TH_GOODPTRACEHOOK ;Good hook around?
        jz      DNI_UseRegPTrace        ;Nope, use the old one
        lea     si,NotifyHandler        ;Point to the routine
        push    cs                      ;Parameter is lpfn to callback
        push    si
        call    lpfnNotifyHook          ;Hook it
        mov     WORD PTR lpfnOldProc[0],ax ;Save old proc
        mov     WORD PTR lpfnOldProc[2],dx
        jmp     SHORT DNI_10            ;We're in

        ;** Since there's no way we can see if someone else has Register
        ;*      PTrace, we just connect and hope for the best!
        ;**     We do check, however, to see if WINDEBUG.DLL is installed.
DNI_UseRegPTrace:
        lea     si,szWinDebug           ;Get the name of the module
        cCall   GetModuleHandle, <ds,si> ;Is WINDEBUG present?
        or      ax,ax                   ;Check the handle
        jnz     DNI_Fail                ;It's here so fail
        or      wTHFlags,TH_GOTOLDPTRACE ;Flag that we made the hook
        lea     si,NotifyHandler        ;Point to our routine
        cCall   RegisterPTrace, <cs,si> ;Tell KERNEL to use it

        ;** Connect to the FatalExit hook.  We currently ignore
        ;**     the return value, thus unhooking anyone else
DNI_10: cmp     WORD PTR lpfnFatalExitHook + 2,0 ;Can we hook it?
        jz      DNI_20                  ;Can't do it
        push    cs                      ;Get the CS:IP of RIP handler
        push    OFFSET NotifyRIPHandler
        call    DWORD PTR lpfnFatalExitHook ;Tell KERNEL to insert the hook
DNI_20:

        ;** Return OK
        mov     ax,TRUE                 ;Return TRUE
        jmp     SHORT DNI_End           ;Get out

DNI_Fail:
        xor     ax,ax                   ;FALSE

DNI_End:
cEnd


;  NotifyUnInit
;       Called when the no more apps have hooked notification handlers
;       so the hook to the Register PTrace notification is no longer needed.

cProc   NotifyUnInit, <NEAR,PUBLIC>, <si,di,ds>
cBegin
        ;** Did we have a new hook to undo?
        test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have a new hook?
        jz      DNU_TryOldPTrace        ;No
        push    WORD PTR lpfnOldProc[0] ;Get the old proc
        push    WORD PTR lpfnOldProc[2]
        call    lpfnNotifyHook          ;Unhook ourself
        jmp     SHORT DNU_NoOldPTrace

        ;** Unhook the old-style hook if necessary
DNU_TryOldPTrace:
        test    wTHFlags,TH_GOTOLDPTRACE ;Did we have a hook?
        jz      DNU_NoOldPTrace         ;No
        push    0
        push    0
        call    RegisterPTrace          ;Call KERNEL's routine to unhook
DNU_NoOldPTrace:

        ;** Unhook alternate hooks
        cmp     WORD PTR lpfnFatalExitHook + 2,0 ;Can we unhook it?
        jz      DNU_NoRIP               ;Can't do it
        xor     ax,ax                   ;Remove any other hooks
        push    ax                      ;NULL procedure
        push    ax
        call    DWORD PTR lpfnFatalExitHook
DNU_NoRIP:

cEnd


;  NotifyHandler
;       This routine is called directly by PTrace and is used to
;       dispatch the notifications to all registered callbacks.

cProc   NotifyHandler, <FAR,PUBLIC>
cBegin  NOGEN

        ;** Push a register frame
        ;*      When done, it should look like this:
        ;*              ------------
        ;*              |    ES    |  [BP - 14h]
        ;*              |    DS    |  [BP - 12h]
        ;*              |    DI    |  [BP - 10h]
        ;*              |    SI    |  [BP - 0Eh]
        ;*              |    BP    |  [BP - 0Ch]
        ;*              |    SP    |  [BP - 0Ah]
        ;*              |    BX    |  [BP - 08h]
        ;*              |    DX    |  [BP - 06h]
        ;*              |    CX    |  [BP - 04h]
        ;*              |    AX    |  [BP - 02h]
        ;*         BP-->|  Old BP  |  [BP - 00h]
        ;*              |    IP    |  [BP + 02h]
        ;*              |    CS    |  [BP + 04h]
        ;*              ------------
        ;**
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds                      ;Save segment registers, too
        push    es

        ;** Get the data segment
        mov     bx,_DATA                ;Get TOOLHELP data segment
        mov     ds,bx

        ;** If in 3.0 std mode and we get this wild notification 69h,
        ;**     translate it to a inchar notification as this is what it
        ;**     is supposed to be.
        cmp     ax,69h                  ;Bogus notification?
        jne     NH_NoBogusNotify        ;No, don't do this
        test    wTHFlags,TH_WIN30STDMODE ;3.0 standard mode?
        jz      NH_NoBogusNotify        ;No, might be valid in the future...
        mov     ax,NI_INCHAR            ;Put in real notify value
NH_NoBogusNotify:

        ;** Special case notifications:
        ;*      Notification 63h means that CtlAltSysRq was pressed.  For
        ;*      this, we want to handle as an interrupt, not a notification.
        ;*      To do this, we set a breakpoint and set a flag so that the
        ;**     INT3 handler knows what to do with it
        cmp     ax,63h                  ;CtlAltSysRq?
        jne     NH_NoCASRq              ;No.
        mov     ax,[bp + 04h]           ;Since we can't use IRET CS:IP, get
        mov     si,[bp + 02h]           ;  a safe address in KERNEL
        mov     WORD PTR dwCASRqCSIP[2],ax ;Save the CS:IP value
        cCall   AllocCStoDSAlias, <ax>  ;Get a data alias to the CS
        or      ax,ax                   ;Error?
        jnz     @F
        jmp     SHORT DNH_End           ;Yes, get out
@@:     verw    ax                      ;OK to write to?
        jnz     DNH_NoWrite             ;Yes, so do it
DNH_IRETCSOK:
        mov     es,ax                   ;Point with ES
        mov     WORD PTR dwCASRqCSIP[0],si
        mov     al,es:[si]              ;Get the character there
        mov     ah,1                    ;Make sure there's something in AH
        mov     wCASRqFlag,ax           ;Save the thing for the INT3 handler
        mov     BYTE PTR es:[si],0cch   ;Poke the INT3 in there
        mov     ax,es                   ;Get the selector back
DNH_NoWrite:
        cCall   FreeSelector, <ax>      ;Get rid of the alias
        jmp     SHORT DNH_End           ;Get out.  This will INT3 soon

NH_NoCASRq:                             ;  Does not return

        ;** Notifications to ignore here:
        ;**     Notification 60h is bogus and should be ignored
        cmp     ax,60h                  ;PostLoad notification?
        jz      DNH_End                 ;Yes, don't report

        ;** Decode the notification
        cCall   DecodeNotification      ;Returns dwData in CX:DX, AX is wID
                                        ;  BX is NOTIFYSTRUCT match flags
        ;** This is an entry point for notifications from sources other than
        ;**     PTrace
DNH_Decoded:

        ;** Loop through callbacks
        mov     di,npNotifyHead         ;Point to the start of the list
        xor     si,si                   ;FALSE return value is default
DNH_Loop:
        push    ax
        mov     ax,ds:[di].ns_pNext     ;Save the next pointer in a global
        mov     npNotifyNext,ax         ;  so we can chain in NotifyUnregister
        pop     ax

        or      di,di                   ;End of list?
        jz      DNH_Done                ;Yep.  Get out

        ;** If the flags for this notification are zero, we always send it
        or      bx,bx                   ;Check the matching flags
        jz      DNH_DoIt                ;Do notification

        ;** See if the flags match
        test    bx,ds:[di].ns_wFlags    ;Check against the NOTIFYSTRUCT flags
        jz      DNH_Continue            ;If zero, no match, don't do it

        ;** Call the user callback
DNH_DoIt:
        push    ax                      ;Save everything we need
        push    bx
        push    cx
        push    dx

        push    ax                      ;wID
        push    cx                      ;High word of dwData
        push    dx                      ;Low word
        call    DWORD PTR ds:[di].ns_lpfn ;Call the callback (PASCAL style)
        mov     si,ax                   ;Get return value in SI

        pop     dx                      ;Restore everything
        pop     cx
        pop     bx
        pop     ax

        ;** If the return value is nonzero, we don't want to give this to
        ;**     any more callbacks
        or      si,si                   ;TRUE return value?
        jnz     DNH_Done                ;Yes, get out

        ;** Get the next callback
DNH_Continue:
        mov     di,npNotifyNext         ;Get next pointer
        jmp     DNH_Loop                ;  and loop back

        ;** End of callback loop.
DNH_Done:

        ;**  If this was an InChar message but everyone ignored it, force
        ;**     the return to be an 'i' for 'ignore' on RIPs.  This i
        ;**     only necessary in 3.0 because the 3.1 KERNEL treats 0
        ;**     returns just like 'i'
        cmp     ax,NFY_INCHAR           ;Is this an InChar notification?
        jne     DNH_Default             ;No, so ignore
        test    wTHFlags,TH_WIN30       ;In 3.0?
        jz      DNH_Default             ;No, don't do this
        and     si,0ffh                 ;Ignore all but low byte
        or      si,si                   ;Non-zero?
        jnz     DNH_Default             ;Yes, return it as the character
        mov     si,'i'                  ;Instead of zero, return 'i'gnore.
DNH_Default:
        mov     [bp - 02h],si           ;Return the return code in AX

        ;** Clear off the stack and exit
DNH_End:
        mov     npNotifyNext,0          ;No current next pointer
        
        pop     es                      ;Restore all registers
        pop     ds
        popa
        pop     bp
        retf                            ;Just return

cEnd    NOGEN


;  NotifyRIPHandler
;       Gets called by KERNEL when a RIP occurs.  If it returns TRUE,
;       KERNEL will act like the RIP was ignored.  Otherwise, the RIP
;       procedes normally.
;       This routine does not need to worry about saving non-C regs

cProc   NotifyRIPHandler, <FAR,PUBLIC>
;       parmW   wExitCode
cBegin  nogen

        ;** Clear PASCAL-style parameters
        push    bp                      ;Make a stack frame
        mov     bp,sp
        mov     bx,[bp + 6]             ;Get the BP value
        mov     dx,[bp + 8]             ;Get the Exit code
        mov     [bp - 2],ax             ;Save it out of the way for now
        mov     ax,[bp + 4]             ;Get the RETF CS value
        mov     [bp + 8],ax             ;Shift down to clear parameters
        mov     ax,[bp + 2]             ;Get the RETF IP value
        mov     [bp + 6],ax             ;Shift down to clear parameters
        mov     ax,[bp + 0]             ;Get the old BP value
        mov     [bp + 4],ax             ;Shift down
        add     bp,4                    ;Move BP down on the stack
        mov     sp,bp                   ;Point SP there too
        pusha                           ;Save matching register frame
        push    ds
        push    es

        ;** Get the data segment
        mov     ax,_DATA                ;Get TOOLHELP data segment
        mov     ds,ax


        ;** Prepare to jump into the notification handler.
        ;**     The trick here is that if a notification callback returns
        ;**     non-zero, the RIP has been handled.  Otherwise, it has not.
        ;**     DX holds the exit code here, BX has the old BP value
        lea     si,ReturnStruct         ;Get a pointer to the return struct
        mov     WORD PTR [si].nrp_dwSize[0],SIZE NFYRIP
        mov     WORD PTR [si].nrp_dwSize[2],0
        mov     ax,ss:[bx + 4]          ;Get old CS value from stack
        mov     [si].nrp_wCS,ax         ;  (BX is BP from FatalExit stack)
        mov     ax,ss:[bx + 2]          ;Get old IP value
        mov     [si].nrp_wIP,ax
        mov     [si].nrp_wSS,ss         ;Save SS:BP for stack trace
        mov     [si].nrp_wBP,bx
        mov     [si].nrp_wExitCode,dx
        mov     cx,ds                   ;Point to structure
        mov     dx,si
        mov     bx,NF_RIP               ;Get the NOTIFYINFO match flags
        mov     ax,NFY_RIP              ;TOOLHELP ID

        ;** Jump to the real handler
        jmp     DNH_Decoded             ;Jump to alternate entry point

cEnd    nogen

;** Helper routines

;  DecodeNotification
;       Decodes a notification by pointing to a static structure and filling
;       this structure with notification-specific information.
;       The PTrace notification ID is in AX.
;       Returns the ToolHelp ID in AX
;       and the dwData value is in CX:DX.

cProc   DecodeNotification, <NEAR,PUBLIC>
cBegin
        ;** Point dwData to the structure just in case
        mov     cx,ds                   ;Get the segment value
        lea     dx,ReturnStruct         ;Get a pointer to the return struct
        xor     bx,bx                   ;Most notifications always match

        ;**  The stack frame looks like this:
        ;*              ------------
        ;*              |    ES    |  [BP - 14h]
        ;*              |    DS    |  [BP - 12h]
        ;*              |    DI    |  [BP - 10h]
        ;*              |    SI    |  [BP - 0Eh]
        ;*              |    BP    |  [BP - 0Ch]
        ;*              |    SP    |  [BP - 0Ah]
        ;*              |    BX    |  [BP - 08h]
        ;*              |    DX    |  [BP - 06h]
        ;*              |    CX    |  [BP - 04h]
        ;*              |    AX    |  [BP - 02h]
        ;*         BP-->|  Old BP  |  [BP - 00h]
        ;*              ------------
        ;**
FrameES         EQU     [BP - 14h]
FrameDS         EQU     [BP - 12h]
FrameDI         EQU     [BP - 10h]
FrameSI         EQU     [BP - 0Eh]
FrameBP         EQU     [BP - 0Ch]
FrameSP         EQU     [BP - 0Ah]
FrameBX         EQU     [BP - 08h]
FrameDX         EQU     [BP - 06h]
FrameCX         EQU     [BP - 04h]
FrameAX         EQU     [BP - 02h]

        ;** Check for LoadSeg
        cmp     ax,NI_LOADSEG           ;LoadSeg?
        jnz     DN_10                   ;No

        ;** LoadSeg:
        ;*      CX is selector
        ;*      BX is segment number
        ;*      SI is type:  Low bit set for data segment, clear for code
        ;*      DX is instance count only for data segments
        ;**     ES:DI module name
        mov     si,dx                   ;Point to NFYLOADSEG struct
        mov     ax,SIZE NFYLOADSEG      ;Get the structure size
        mov     WORD PTR [si].nls_dwSize,ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nls_dwSize + 2,0 ;HIWORD is zero
        mov     ax,FrameCX              ;Get selector
        mov     [si].nls_wSelector,ax   ;Save in structure
        mov     ax,FrameBX              ;Get segment number
        inc     ax                      ;Segment number is 1-based
        mov     [si].nls_wSegNum,ax     ;Save in structure
        mov     ax,FrameSI              ;Get the segment type
        mov     [si].nls_wType,ax       ;Put in structure
        mov     ax,FrameDX              ;Get instance count
        mov     [si].nls_wcInstance,ax  ;Put in structure
        mov     ax,FrameDI              ;Get offset of module name str
        mov     WORD PTR [si].nls_lpstrModuleName,ax ;Save it
        mov     ax,FrameES              ;Get segment of module name str
        mov     WORD PTR [si].nls_lpstrModuleName + 2,ax ;Save it
        mov     ax,NFY_LOADSEG          ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for FreeSeg
DN_10:  cmp     ax,NI_FREESEG           ;FreeSeg?
        jnz     DN_15                   ;No

        ;** FreeSeg:
        ;**     BX is selector
        xor     cx,cx                   ;Clear high word
        mov     dx,FrameBX              ;Get the selector
        test    wTHFlags,TH_WIN30STDMODE ;3.0 standard mode?
        jz      DN_FS_GotSelValue       ;No, what we have is correct
        mov     si,FrameSP              ;Point to old stack frame
        mov     dx, ss:[si + 6]         ;Selector is 6 bytes down
        lsl     ax, dx
        jz      DN_FS_CheckLen          ;Selector is OK
        mov     dx, FrameBX             ;Revert to BX value
        jmp     SHORT DN_FS_GotSelValue
DN_FS_CheckLen:
        cmp     ax, 15                  ;If the segment is 15 bytes long,
        jne     DN_FS_GotSelValue       ;  this is a bogus selector and is
                                        ;  really an arena header.
        push    es
        mov     es, dx                  ;Get handle
        cCall   HelperHandleToSel, <es:[0ah]> ;Convert to selector
        mov     dx, ax                  ;Get handle out of arena header
        pop     es
DN_FS_GotSelValue:
        mov     ax,NFY_FREESEG          ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for StartDLL
DN_15:  cmp     ax,NI_LOADDLL
        jnz     DN_20

        ;** StartDLL:
        ;**     CX is CS
        ;**     BX is IP
        ;**     SI is Module handle
        mov	si,dx			;Point with SI
        mov	ax,SIZE NFYSTARTDLL	;Get the size
        mov	WORD PTR [si].nsd_dwSize,ax ;Save the LOWORD of the size
        mov	WORD PTR [si].nsd_dwSize + 2,0 ;HIWORD is always zero
        mov	ax,FrameSI		;Get the hInstance
        mov	[si].nsd_hModule,ax	;Save in structure
        mov	ax,FrameCX		;Get the starting CS
        mov	[si].nsd_wCS,ax		;Save in structure
        mov	ax,FrameBX		;Get the starting IP
        mov	[si].nsd_wIP,ax		;Save in structure
        mov     ax,NFY_STARTDLL
        jmp     DN_End

        ;** Check for StartTask
DN_20:  cmp     ax,NI_STARTTASK         ;StartTask?
        jnz     DN_30                   ;No

        ;** StartTask:
        ;*      CX is CS
        ;**     BX is IP
        mov     cx,FrameCX
        mov     dx,FrameBX
        mov     ax,NFY_STARTTASK
        jmp     DN_End

        ;** Check for ExitCall
DN_30:  cmp     ax,NI_EXITCALL          ;ExitCall
        jnz     DN_40                   ;No

        ;** ExitCall:
        ;*      Exit code is on stack somewhere if we don't have the new
        ;**     notification handler.  If we do, it's in BL.
        xor     cx,cx                   ;Clear all but low byte
        xor     dh,dh
        test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have the good hook?
        jz      DN_DoOldHook            ;Nope, grope on the stack
        mov     dl,BYTE PTR FrameBX     ;Get the exit code
        mov     ax,NFY_EXITTASK         ;Get the TOOLHELP ID
        jmp     DN_End
DN_DoOldHook:
        mov     si,FrameSP              ;Point to old stack frame
        mov     dl,ss:[si + 6]          ;Exit code is 6 bytes down on stack
        mov     ax,NFY_EXITTASK         ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for DelModule
DN_40:  cmp     ax,NI_DELMODULE         ;DelModule?
        jnz     DN_60                   ;No

        ;** DelModule:
        ;**     ES is module handle
        xor     cx,cx                   ;Clear HIWORD
        mov     dx,FrameES              ;Get the module handle
        mov     ax,NFY_DELMODULE        ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for TaskSwitchIn
DN_60:  cmp     ax,NI_TASKIN            ;TaskSwitchIn?
        jnz     DN_70                   ;No

        ;** TaskSwitchIn:
        ;**     No data.  Callback should do GetCurrentTask()
        xor     cx,cx                   ;Clear data
        xor     dx,dx
        mov     ax,NFY_TASKIN           ;Get the TOOLHELP ID
        mov     bx,NF_TASKSWITCH        ;Get the NOTIFYSTRUCT match flag
        jmp     DN_End

        ;** Check for TaskSwitchOut
DN_70:  cmp     ax,NI_TASKOUT           ;TaskSwitchOut?
        jnz     DN_90                   ;No

        ;** TaskSwitchOut:
        ;**     No data
        xor     cx,cx                   ;Clear data
        xor     dx,dx
        mov     ax,NFY_TASKOUT          ;Get the TOOLHELP ID
        mov     bx,NF_TASKSWITCH        ;Get the NOTIFYSTRUCT match flag
        jmp     DN_End

        ;** Check for OutStr
DN_90:  cmp     ax,NI_OUTSTR            ;OutStr?
        jnz     DN_100                  ;No

        ;** OutStr:
        ;**     ES:SI points to string to display in 3.1
        ;**     DS:SI in 3.0
        test    wTHFlags,TH_WIN30       ;3.0?
        jz      DN_OS_Win31             ;Nope
        mov     cx,FrameDS              ;Get the segment value
        jmp     SHORT @F
DN_OS_Win31:
        mov     cx,FrameES              ;Get the segment value
@@:     mov     dx,FrameSI              ;  and the offset
        mov     ax,NFY_OUTSTR           ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for InChar
DN_100: cmp     ax,NI_INCHAR            ;InChar?
        jnz     DN_105                  ;No

        ;** InChar:
        ;**     No data passed (it wants data back in AL)
        xor     cx,cx                   ;Clear dwData
        xor     dx,dx
        mov     ax,NFY_INCHAR           ;Get the TOOLHELP ID
        jmp     SHORT DN_End

        ;** NOTE:  The following notifications are defined as "NEW" and
        ;**     are NOT sent through the normal PTrace interface so as to
        ;**     not break CodeSpew.  It stack faults when
        ;**     it is sent a notification it doesn't understand.  So,
        ;**     here we don't bother decoding any of these unless we have
        ;**     the new (Win 3.1) style hook
DN_105: test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have the advanced hook?
        jnz     DN_110                  ;Yes
        jmp     SHORT DN_End

        ;** Check for the parameter validation notifications
DN_110: cmp     ax,NI_LOGERROR          ;SDM_LOGERROR?
        jne     DN_120                  ;No

        ;** SDM_LOGERROR:
        ;*      CX is Error code
        ;**     DX:BX is lpInfo
        mov     si,dx                   ;Point with SI
        mov     ax,SIZE NFYLOGERROR     ;Get the size
        mov     WORD PTR [si].nle_dwSize[0],ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nle_dwSize[2],0 ;HIWORD is always zero
        mov     ax,FrameCX              ;Get the error code
        mov     [si].nle_wErrCode,ax    ;Save in structure
        mov     ax,FrameDX              ;Get the lpInfo
        mov     WORD PTR [si].nle_lpInfo[2],ax ;Save in structure
        mov     ax,FrameBX
        mov     WORD PTR [si].nle_lpInfo[0],ax ;Save in structure
        mov     ax,NFY_LOGERROR         ;Get the TOOLHELP ID
        jmp     SHORT DN_End

DN_120: cmp     ax,NI_LOGPARAMERROR     ;SDM_LOGPARAMERROR?
        jne     DN_Unknown              ;No

        ;** SDM_LOGPARAMERROR:
        ;**     ES:BX points to a structure:
        ;**             WORD wErr
        ;**             FARPROC lpfn
        ;**             VOID FAR* lpBadParam
        mov     si,dx                   ;Point with SI
        mov     ax,SIZE NFYLOGPARAMERROR ;Struct size
        mov     WORD PTR [si].nlp_dwSize[0],ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nlp_dwSize[2],0 ;HIWORD is always zero
        mov     es,FrameES              ;Point to the structure
        mov     bx,FrameBX
        mov     ax,es:[bx]              ;Get wErr
        mov     [si].nlp_wErrCode,ax    ;Save in structure
        mov     ax,es:[bx + 2]          ;Get lpfn[0]
        mov     WORD PTR [si].nlp_lpfnErrorAddr[0],ax
        mov     ax,es:[bx + 4]          ;Get lpfn[2]
        mov     WORD PTR [si].nlp_lpfnErrorAddr[2],ax
        mov     ax,es:[bx + 6]          ;Get lpBadParam[0]
        mov     WORD PTR [si].nlp_lpBadParam[0],ax
        mov     ax,es:[bx + 8]          ;Get lpBadParam[2]
        mov     WORD PTR [si].nlp_lpBadParam[2],ax
        mov     ax,NFY_LOGPARAMERROR    ;Get the TOOLHELP ID
        xor     bx,bx                   ;Always match
        jmp     SHORT DN_End

        ;** Must be unknown, return TOOLHELP ID NFY_UNKNOWN with KERNEL value
        ;**     in LOWORD(wData)
DN_Unknown:
        mov     dx,ax                   ;Get the notification value
        mov     ax,NFY_UNKNOWN          ;Unknown KERNEL notification
        xor     cx,cx                   ;Clear high WORD

DN_End:

cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\signal.c ===
/**************************************************************************
 *  SIGNAL.C
 *
 *      Routines used to clean up on a forced KERNEL termination of a
 *      TOOLHELP using app.
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wSignalInstalled;
    SIGNAL NEAR *npSignalHead;

/*  SignalRegister
 *      Registers a default signal proc to a task.  This signal proc is
 *      called when the task is about to be terminated and is called before
 *      the USER signal proc is called.  The registered callback is
 *      called HelperSignalProc() [HELPER.ASM] and chains to the USER signal
 *      proc (if any) instead of returning.
 */

BOOL PASCAL SignalRegister(
    HANDLE hTask)
{
    SIGNAL *pSig;
    SIGNAL *pTemp;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Check to see if this task is already registered */
    for (pSig = npSignalHead ; pSig ; pSig = pSig->pNext)
        if (pSig->hTask == hTask)
            return FALSE;

    /* Allocate a new SIGNAL structure */
    pSig = (SIGNAL *)LocalAlloc(LMEM_FIXED, sizeof (SIGNAL));
    if (!pSig)
        return FALSE;

    /* Fill in the useful fields */
    pSig->hTask = hTask;
    pSig->lpfn = (LPFNCALLBACK)HelperSignalProc;
    pSig->lpfnOld = (LPFNCALLBACK)
        HelperSetSignalProc(hTask, (DWORD)HelperSignalProc);

    /* If this is the only handler, just insert it */
    if (!npSignalHead)
    {
        pSig->pNext = npSignalHead;
        npSignalHead = pSig;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npSignalHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pSig->pNext = pTemp->pNext;
        pTemp->pNext = pSig;
    }

    return TRUE;
}


/*  SignalUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL PASCAL SignalUnRegister(
    HANDLE hTask)
{
    SIGNAL *pSig;
    SIGNAL *pBefore;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pSig = npSignalHead ; pSig ; pSig = pSig->pNext)
        if (pSig->hTask == hTask)
            break;
        else
            pBefore = pSig;
    if (!pSig)
        return FALSE;

    /* Remove it from the list */
    if (!pBefore)
        npSignalHead = pSig->pNext;
    else
        pBefore->pNext = pSig->pNext;

    /* Replace the old signal proc */
    HelperSetSignalProc(hTask, (DWORD)pSig->lpfnOld);

    /* Free the structure */
    LocalFree((HANDLE)pSig);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\module.c ===
/*************************************************************************
 *  MODULE.C
 *
 *      Routines to enumerate the various module headers on  the module
 *      chain.
 *
 *************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/* ----- Function prototypes ----- */

    NOEXPORT BOOL PASCAL ModuleGetInfo(
        WORD wModule,
        MODULEENTRY FAR *lpModule);

/*  ModuleFirst
 *      Finds the first module in the module list and returns information
 *      about this module.
 */

BOOL TOOLHELPAPI ModuleFirst(
    MODULEENTRY FAR *lpModule)
{
    WORD FAR *lpwExeHead;

    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return FALSE;

    /* Get a pointer to the module head */
    lpwExeHead = MAKEFARPTR(segKernel, npwExeHead);

    /* Use this pointer to get information about this module */
    return ModuleGetInfo(*lpwExeHead, lpModule);
}


/*  ModuleNext
 *      Finds the next module in the module list.
 */

BOOL TOOLHELPAPI ModuleNext(
    MODULEENTRY FAR *lpModule)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return FALSE;

    /* Use the next handle to get information about this module */
    return ModuleGetInfo(lpModule->wNext, lpModule);
}


/*  ModuleFindName
 *      Finds a module with the given module name and returns information
 *      about it.
 */

HANDLE TOOLHELPAPI ModuleFindName(
    MODULEENTRY FAR *lpModule,
    LPCSTR lpstrName)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule || !lpstrName ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return NULL;

    /* Loop through module chain until we find the name (or maybe we don't) */
    if (ModuleFirst(lpModule))
        do
        {
            /* Is this the name?  If so, we have the info, so return */
            if (!lstrcmp(lpstrName, lpModule->szModule))
                return lpModule->hModule;
        }
        while (ModuleNext(lpModule));

    /* If we get here, we didn't find it or there was an error */
    return NULL;
}


/*  ModuleFindHandle
 *      Returns information about a module with the given handle.
 */

HANDLE TOOLHELPAPI ModuleFindHandle(
    MODULEENTRY FAR *lpModule,
    HANDLE hModule)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule || !hModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return NULL;
    
    /* Use the helper function to find out about this module */
    if (!ModuleGetInfo(hModule, lpModule))
        return NULL;

    return lpModule->hModule;
}


/* ----- Helper functions ----- */

NOEXPORT BOOL PASCAL ModuleGetInfo(
    WORD wModule,
    MODULEENTRY FAR *lpModule)
{
    struct new_exe FAR *lpNewExe;
    BYTE FAR *lpb;

    /* Verify the segment so we don't GP fault */
    if (!HelperVerifySeg(wModule, 2))
        return FALSE;

    /* Get a pointer to the module database */
    lpNewExe = MAKEFARPTR(wModule, 0);

    /* Make sure this is a module database */
    if (lpNewExe->ne_magic != NEMAGIC)
        return FALSE;

    /* Get the module name (it's the first name in the resident names
     * table
     */
    lpb = ((BYTE FAR *)lpNewExe) + lpNewExe->ne_restab;
    _fstrncpy(lpModule->szModule, lpb + 1, *lpb);
    lpModule->szModule[*lpb] = '\0';

    /* Get the EXE file path.  A pointer is stored in the same place as
     *  the high word of the CRC was in the EXE file. (6th word in new_exe)
     *  This pointer points to the length of a PASCAL string whose first
     *  eight characters are meaningless to us.
     */
    lpb = MAKEFARPTR(wModule, *(((WORD FAR *)lpNewExe) + 5));
    _fstrncpy(lpModule->szExePath, lpb + 8, *lpb - 8);
    lpModule->szExePath[*lpb - 8] = '\0';

    /* Get other information from the EXE Header
     * The usage count is stored in the second word of the EXE header
     * The handle of the next module in the chain is stored in the
     *  ne_cbenttab structure member.
     */
    lpModule->hModule = wModule;
    lpModule->wcUsage = *(((WORD FAR *)lpNewExe) + 1);
    lpModule->wNext = lpNewExe->ne_cbenttab;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\notify1.c ===
/**************************************************************************
 *  NOTIFY1.C
 *
 *      Routines used to implement the Debugger Notification API in
 *      TOOLHELP.DLL
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wNotifyInstalled;
    NOTIFYSTRUCT NEAR *npNotifyHead;
    NOTIFYSTRUCT NEAR *npNotifyNext;

/*  NotifyRegister
 *      Registers a debugger notification callback.  This callback will
 *      be called whenever KERNEL has a notification to be sent.
 *      The format of the call to the callback function is documented
 *      elsewhere.
 */

BOOL TOOLHELPAPI NotifyRegister(
    HANDLE hTask,
    LPFNNOTIFYCALLBACK lpfn,
    WORD wFlags)
{
    NOTIFYSTRUCT *pInfo;
    NOTIFYSTRUCT *pTemp;

    /* Make sure TOOLHELP.DLL is installed */
    if (!wLibInstalled)
        return FALSE;

    /* If the notification hook has not yet been installed, install it */
    if (!wNotifyInstalled)
    {
        /* Make sure we can get a hook! */
        if (!NotifyInit())
            return FALSE;
        wNotifyInstalled = TRUE;
    }

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Register a death signal handler for this task (does nothing if one
     *  is already installed.
     */
    SignalRegister(hTask);

    /* Check to see if this task is already registered */
    for (pInfo = npNotifyHead ; pInfo ; pInfo = pInfo->pNext)
        if (pInfo->hTask == hTask)
            return FALSE;

    /* Allocate a new NOTIFYSTRUCT structure */
    pInfo = (NOTIFYSTRUCT *)LocalAlloc(LMEM_FIXED, sizeof (NOTIFYSTRUCT));
    if (!pInfo)
        return FALSE;

    /* Fill in the useful fields */
    pInfo->hTask = hTask;
    pInfo->wFlags = wFlags;
    pInfo->lpfn = lpfn;

    /* If this is the only handler, just insert it */
    if (!npNotifyHead)
    {
        pInfo->pNext = npNotifyHead;
        npNotifyHead = pInfo;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npNotifyHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pInfo->pNext = pTemp->pNext;
        pTemp->pNext = pInfo;
    }

    return TRUE;
}


/*  NotifyUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL TOOLHELPAPI NotifyUnRegister(
    HANDLE hTask)
{
    NOTIFYSTRUCT *pNotify;
    NOTIFYSTRUCT *pBefore;

    /* Make sure we have notifications installed and that TOOLHELP is OK */
    if (!wLibInstalled || !wNotifyInstalled)
        return FALSE;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pNotify = npNotifyHead ; pNotify ; pNotify = pNotify->pNext)
        if (pNotify->hTask == hTask)
            break;
        else
            pBefore = pNotify;
    if (!pNotify)
        return FALSE;

    /* Unhook the death signal proc only if there is no interrupt handler */
    if (!InterruptIsHooked(hTask))
        SignalUnRegister(hTask);

    /* Check to see if the notification handler is about to use this entry.
     *  If it is, we point it to the next one, if any.
     */
    if (npNotifyNext == pNotify)
        npNotifyNext = pNotify->pNext;

    /* Remove it from the list */
    if (!pBefore)
        npNotifyHead = pNotify->pNext;
    else
        pBefore->pNext = pNotify->pNext;

    /* Free the structure */
    LocalFree((HANDLE)pNotify);

    /* If there are no more handlers, unhook the callback */
    if (!npNotifyHead)
    {
        NotifyUnInit();
        wNotifyInstalled = FALSE;
    }

    return TRUE;
}

/* ----- Helper functions ----- */

/*  NotifyIsHooked
 *      Returns TRUE iff the parameter task already has a notification hook.
 */

BOOL PASCAL NotifyIsHooked(
    HANDLE hTask)
{
    NOTIFYSTRUCT *pNotify;

    /* Loop thorugh all notifications */
    for (pNotify = npNotifyHead ; pNotify ; pNotify = pNotify->pNext)
        if (pNotify->hTask == hTask)
            break;

    /* Return found/not found */
    return (BOOL)pNotify;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\stack1.c ===
/***************************************************************************
 *  STACK1.C
 *
 *      Code to support stack tracing on task stacks.
 *
 ***************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/* ----- Function prototypes ----- */

    NOEXPORT void StackTraceInfo(
        STACKTRACEENTRY FAR *lpStack);

/* ----- Functions ----- */

/*  StackTraceFirst
 *      Starts a task stack trace by returning information about the
 *      first frame on the task's stack.
 */

BOOL TOOLHELPAPI StackTraceFirst(
    STACKTRACEENTRY FAR *lpStackTrace,
    HANDLE hTDB)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStackTrace ||
        lpStackTrace->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get the first value */
    if (!(StackFrameFirst(lpStackTrace, hTDB)))
        return FALSE;

    /* Get module and segment number information */
    StackTraceInfo(lpStackTrace);

    return TRUE;
}


/*  StackTraceCSIPFirst
 *      Traces the stack of an arbitrary CS:IP.  All parameters must be
 *      given, and once started, the StackTraceNext function can be used
 *      to trace the remainder of the stack
 */

BOOL TOOLHELPAPI StackTraceCSIPFirst(
    STACKTRACEENTRY FAR *lpStack,
    WORD wSS,
    WORD wCS,
    WORD wIP,
    WORD wBP)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStack ||
        lpStack->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get the user information */
    lpStack->wSS = wSS;
    lpStack->wCS = wCS;
    lpStack->wIP = wIP;
    lpStack->wBP = wBP;

    /* Get module and segment number information */
    StackTraceInfo(lpStack);

    /* Set the hTask to the current task as we are in the current task
     *  context.  The CS may not be owned by this task, but at least
     *  we put a reasonable value in there.
     */
    lpStack->hTask = GetCurrentTask();

    return TRUE;
}


/*  StackTraceNext
 *      Continues a stack trace by returning information about the next
 *      frame on the task's stack.
 *      structure.
 */

BOOL TOOLHELPAPI StackTraceNext(
    STACKTRACEENTRY FAR *lpStackTrace)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStackTrace ||
        lpStackTrace->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get information about this frame */
    if (!StackFrameNext(lpStackTrace))
        return FALSE;

    /* Get module and segment number information */
    StackTraceInfo(lpStackTrace);

    return TRUE;
}

/* ----- Helper functions ----- */

/*  StackTraceInfo
 *      Gets module and segment number info about the given entry
 */

NOEXPORT void StackTraceInfo(
    STACKTRACEENTRY FAR *lpStack)
{
    GLOBALENTRY GlobalEntry;
    struct new_exe FAR *lpNewExe;
    struct new_seg1 FAR *lpSeg;
    WORD i;

    /* If we have a NULL CS, this is a NEAR frame.  Just return because we
     *  assume the user hasn't trashed the structure.  The module and seg
     *  info will be the same as the last time
     */
    if (!lpStack->wCS)
        return;

    /* Get information about the code segment block */
    GlobalEntry.dwSize = sizeof (GLOBALENTRY);
    if (!GlobalEntryHandle(&GlobalEntry, lpStack->wCS))
        return;

    /* The owner of all code segments is the hModule */
    lpStack->hModule = GlobalEntry.hOwner;

    /* To find the segment number, we look in the EXE header and count the
     *  listed segments till we find this one
     */

    /* Get a pointer to the EXE Header module */
    lpNewExe = MAKEFARPTR(HelperHandleToSel(lpStack->hModule), 0);

    /* Make sure this is a EXE Header segment */
    if (lpNewExe->ne_magic != NEMAGIC)
        return;

    /* Get the list of segments and go for it */
    lpSeg = MAKEFARPTR(HIWORD((DWORD)lpNewExe), lpNewExe->ne_segtab);
    for (i = 0 ; i < lpNewExe->ne_cseg ; ++i, ++lpSeg)
        if (HelperHandleToSel(lpSeg->ns_handle) == lpStack->wCS)
            break;
    if (i == lpNewExe->ne_cseg)
        return;

    /* Save the segment number (seg numbers start at one) */
    lpStack->wSegment = i + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\stack2.asm ===
;**************************************************************************
;*  STACK2.ASM
;*
;*      Assembly support code for stack tracing.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE TDB.INC

;** External functions

externNP HelperVerifySeg
externNP HelperHandleToSel

;** Functions

sBegin  CODE
        assumes CS,CODE

;  StackFrameFirst
;       Returns information about the first stack frame and checks it
;       for validity as much as possible.  The first stack frame is found
;       by getting the information from the TDB.  If this task is active,
;       or if the task was changed in an unusual way, this information
;       may be incorrect. If it is, the user must set up the first
;       CS, IP, and BP, and BPNext in the user structure, log it as the
;       first stack trace and call StackTraceNext directly.

cProc   StackFrameFirst, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpStack
        parmW   hTDB
cBegin
        ;** Verify that we have a good TDB first
        ;** Start by verifying the selector
        mov     ax,hTDB                 ;Get the selector
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        push    ax                      ;Save it
        mov     bx,TDBSize
        cCall   HelperVerifySeg, <ax,bx>
        pop     bx                      ;Get selector back
        or      ax,ax                   ;FALSE return?
        jnz     SHORT SF_SelOk          ;Selector's OK
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT SF_End
SF_SelOk:

        ;** Verify that the TDB signature matches
        mov     ds,bx                   ;Point with DS
        cmp     ds:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jz      SF_SigOk                ;Must be
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT SF_End
SF_SigOk:

        ;** Get the BP value from the task stack and store in structure
        les     di,lpStack              ;Get a pointer to the user struct
        mov     ax,ds:[TDB_taskSS]      ;Get the SS value
        mov     bx,ds:[TDB_taskSP]      ;Get the max segment offset we need
        add     bx,Task_CS + 2
        cCall   HelperVerifySeg, <ax,bx> ;Make sure we can read all this
        or      ax,ax                   ;Error?
        jz      SF_End                  ;Yes, can't do walk
        lds     bx,DWORD PTR ds:[TDB_taskSP] ;Get the SS:SP value
        mov     si,ds:[bx].Task_BP      ;Get the BP value from the stack
        and     si,NOT 1                ;Clear the FAR frame bit, if any
        mov     es:[di].st_wBP,si       ;Store the BP value
        mov     ax,ds:[bx].Task_IP      ;Store initial IP
        mov     es:[di].st_wIP,ax
        mov     ax,ds:[bx].Task_CS      ;Store the initial CS
        mov     es:[di].st_wCS,ax

        ;** Return as much info as possible about this first frame
        mov     ax,hTDB                 ;Get the TDB handle
        mov     es:[di].st_hTask,ax     ;Save in structure
        mov     es:[di].st_wSS,ds       ;Save the SS value
        mov     es:[di].st_wFlags,FRAME_FAR ;Force a FAR frame this time

        ;** Try to verify this stuff
        xor     ax,ax                   ;In case we need to exit
        or      si,si                   ;End of the line?
        jz      SF_End                  ;Nope
        cmp     si,ds:[0ah]             ;Compare against stack top
        jb      SF_End                  ;Fine with top
        cmp     si,ds:[0eh]             ;Check against stack bottom
        jae     SF_End                  ;OK with bottom too
        mov     ax,1                    ;Return TRUE

SF_End:
cEnd


;  StackFrameNext
;       Returns information in a public structure about the stack frame
;       pointed to by the BP value passed in.  Returns TRUE if the
;       information seems valid, or FALSE if information could not be
;       returned.

cProc   StackFrameNext, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpStack
cBegin
        ;** Get pointers to the frame
        les     di,lpStack              ;Get a pointer to the structure
        mov     ax,es:[di].st_wSS       ;Get the stack segment
        mov     ds,ax                   ;Point with DS

        ;** Get the next stack frame
        mov     si,es:[di].st_wBP       ;Get the current BP value
        lea     ax,[si + 6]             ;Get the max stack probe
        cmp     ax,si                   ;No stack wraparound allowed
        jb      SN_End                  ;If below, we have wrapped
        cCall   HelperVerifySeg, <ds,ax> ;Make sure the stack is OK
        or      ax,ax                   ;OK?
        jnz     @F                      ;Yes.
        jmp     SHORT SN_End            ;Return FALSE
@@:     mov     dx,ds:[si+4]            ;DX:CX is the return address
        mov     cx,ds:[si+2]
        mov     bx,ds:[si]              ;Get next BP value

        ;** Zero BP is end of chain
        xor     ax,ax                   ;In case we need to exit
        or      bx,bx                   ;End of the line?
        jz      SN_End                  ;Nope

        ;** If the new BP is higher on the stack than the old, it's invalid
        cmp     bx,si                   ;New BP <= Old BP?
        jbe     SN_End                  ;OK.

        ;** Make sure we're still on the stack (variables from KDATA.ASM)
        cmp     bx,ds:[0ah]             ;Compare against stack top
        jb      SN_End                  ;Fine with top
        cmp     bx,ds:[0eh]             ;Check against stack bottom
        jae     SN_End                  ;OK with bottom too

        ;** Return what we can about the frame
        mov     es:[di].st_wSS,ds       ;Save the SS value
        mov     es:[di].st_wBP,si       ;  and the BP value
        test    bx,1                    ;Far or near frame?
        jnz     SN_FarFrame             ;For sure far if BP is odd

        ;** Even when BP is not odd, we may have a far frame
        mov     ax,cs                   ;Get our RPL bits
        and     al,3                    ;Mask RPL bits
        mov     ah,dl                   ;Get frame's RPL bits
        and     ah,3                    ;Mask RPL bits
        cmp     al,ah                   ;If CS is a handle, they won't match
        jne     SN_NearFrame            ;Bits don't match
        lar     ax,dx                   ;Get the access bits
        test    ax,800h                 ;Is this a code segment?
        jz      SN_NearFrame            ;No.  MUST be near frame
        lsl     ax,dx                   ;Get the limit
        cmp     ax,cx                   ;Inside limit?
        jbe     SN_NearFrame            ;No.  MUST be near

        ;** Otherwise, probably is a far frame.  It may not be, of course,
        ;**     because this may be a code seg parameter
SN_FarFrame:
        mov     es:[di].st_wIP,cx       ;Save the offset
        mov     es:[di].st_wCS,dx       ;  and selector value
        mov     ax,FRAME_FAR            ;Tell the user what we did
        and     bx,NOT 1                ;Clear the far frame bit
        jmp     SHORT SN_20             ;Skip near section

        ;** Must be a near frame
SN_NearFrame:
        mov     es:[di].st_wIP,cx       ;Save the offset
                                        ;Leave the old CS value in
        mov     ax,FRAME_NEAR           ;Tell the user what we did
SN_20:  mov     es:[di].st_wFlags,ax    ;Save in the structure
        mov     es:[di].st_wBP,bx       ;Save BP in the structure
        mov     ax,1                    ;Return TRUE

SN_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\ththunks.asm ===
TITLE   THTHUNKS.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991-1992, Microsoft Corporation
;
; THTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;
;   09-Nov-1992 Dave Hart (davehart)
;   Adapted from mvdm\wow16\kernel31\kthunks.asm for ToolHelp
;
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .286p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowth.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

; Kernel API thunks

    ToolHelpThunk ClassFirst
    ToolHelpThunk ClassNext


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\task1.c ===
/*************************************************************************
 *  TASK1.C
 *
 *      Routines used to enumerate all tasks.
 *
 *************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Functions ----- */

/*  TaskFirst
 *      Returns information about the first task in the task chain.
 */

BOOL TOOLHELPAPI TaskFirst(
    TASKENTRY FAR *lpTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

    /* Pass a pointer to the first block to the assembly routine */
    return TaskInfo(lpTask, *(WORD FAR *)MAKEFARPTR(segKernel, npwTDBHead));
}


/*  TaskNext
 *      Returns information about the next task in the task chain.
 */

BOOL TOOLHELPAPI TaskNext(
    TASKENTRY FAR *lpTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || !lpTask->hNext ||
        lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

    /* Pass a pointer to the next block to the assembly routine */
    return TaskInfo(lpTask, lpTask->hNext);
}


/*  TaskFindHandle
 *      Returns information about the task with the given task handle.
 */

BOOL TOOLHELPAPI TaskFindHandle(
    TASKENTRY FAR *lpTask,
    HANDLE hTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

#ifdef WOW
    if ( (hTask & 0x4) == 0 && hTask <= 0xffe0 && hTask != 0 ) {
        //
        // If they are getting a task handle for an htask alias, then
        // just fill in the hinst method and return.
        //
        // Special hack for OLE 2.0's BusyDialog.
        //
        lpTask->hInst = hTask;
        return( TRUE );
    }
#endif

    /* Pass a pointer to the first block to the assembly routine */
    return TaskInfo(lpTask, hTask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\timer.asm ===
PAGE 60,150
;***************************************************************************
;*  TIMER.ASM
;*
;*      Routines used to give a cleaner interface to the VTD.
;*      This interface also works on a 286 by calling GetTickCount() in
;*      this case.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC

;** Symbols
SI_CRITICAL     EQU     1
DI_CRITICAL     EQU     2

;** Imports
externA __WinFlags
externFP GetTickCount

sBegin  DATA

dwLastTimeReturned      dd      0
wLastCountDown          dw      0


sEnd

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  TimerCount
;       Returns the count from either the virtual timer device or from the
;       Windows function GetTickCount() depending on the processor.
;       Prototype:
;               BOOL FAR PASCAL TimerCount(
;                       TIMERINFO FAR *lpTimer)
;

cProc   TimerCount, <FAR,PUBLIC>, <si,di,ds>
        parmD   lpTimer
        localD  dwJumpAddr
cBegin
        mov     ax, _DATA               ;Get our data segment
        mov     es, ax

        ;** Point to the structure
        lds     si,lpTimer              ;Point to the structure

        ;** Make sure the size is correct
        xor     ax,ax                   ;FALSE
        cmp     WORD PTR [si].ti_dwSize[2],0 ;High word must be zero
        je      @F
        jmp     TC_End
@@:     cmp     WORD PTR [si].ti_dwSize[0],SIZE TIMERINFO ;Low word must match
        je      @F
        jmp     TC_End
@@:

ifndef WOW
        ;** If we are in standard mode, always use Windows entry point
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_STANDARD          ;Standard mode?
        jnz     TC_TryMMSys             ;Yes, don't even try VTD
.386p
        ;** Try to get the VTD entry point
        mov     ax,1684h                ;Get device entry point
        mov     bx,5                    ;VTD device number
        int     2fh                     ;Win386 entry point
        mov     ax,es                   ;Did we get a value?
        or      ax,di                   ;  (zero means no device)
        jz      SHORT TC_UseWinAPI      ;No VTD--use Win API

        ;** Get the VTD values
        mov     WORD PTR dwJumpAddr[0],di ;Save the address
        mov     WORD PTR dwJumpAddr[2],es ;Save the address
        mov     ax,0101h                ;VTD:  ms since start of Win386
        call    DWORD PTR dwJumpAddr    ;Call the VTD
        jc      SHORT TC_UseWinAPI      ;Carry set means error
        mov     [si].ti_dwmsSinceStart,eax ;Save in structure
        mov     ax,0102h                ;VTD:  ms in this VM
        call    DWORD PTR dwJumpAddr    ;Call the VTD
        jc      SHORT TC_UseWinAPI      ;Carry set means VTD error
        mov     [si].ti_dwmsThisVM,eax  ;Save value in structure
        jmp     TC_ReturnOK             ;We're done
.286p

        ;** See if mmsystem timer is installed
TC_TryMMSys:
        cmp     WORD PTR es:[lpfntimeGetTime][2], 0 ;Installed?
        je      TC_UseWinAPI            ;No, do this the hard way
        call    DWORD PTR es:lpfntimeGetTime

        ;** Fill the structure with this information
        mov     WORD PTR [si].ti_dwmsSinceStart[0],ax
        mov     WORD PTR [si].ti_dwmsSinceStart[2],dx
        mov     WORD PTR [si].ti_dwmsThisVM[0],ax
        mov     WORD PTR [si].ti_dwmsThisVM[2],dx
        jmp     TC_ReturnOK
endif   ; ndef WOW

        ;** Use the Windows API
TC_UseWinAPI:
        cCall   GetTickCount            ;Call the Windows API
        mov     WORD PTR [si].ti_dwmsSinceStart[0],ax ;Save the value for now
        mov     WORD PTR [si].ti_dwmsSinceStart[2],dx

        ;** Read the countdown timer.  Note that the timer starts at 54 * 1193
        ;**     and counts down to zero.  Each count is 1193 ms.
ifdef   NEC_98
;       timer i/o access change
        push    ds
        mov     ax,40h                  ;       40:101                  ;921006
        mov     ds,ax
        test    byte ptr ds:[101h],80h  ; system clock check            ;921006
        pop     ds
        mov     cx,2457                 ; 2.5MHz
        jz      @f
        mov     cx,1996                 ; 2MHz
@@:
        push    cx
        xor     al,al                   ;Prepare to read tick count
        out     77h,al                  ;Send to timer                  ;921006
        in      al,dx                   ;Get the low byte
        mov     ah,al                   ;Save in AH
        in      al,dx                   ;Get the high byte
        xchg    ah,al
        pop     cx
        mov     dx,0ffffh               ;Get total countdown amount
        sub     dx,ax                   ;Get number of counts expired
        mov     ax,dx                   ;Get the number in AX for div
        xor     dx,dx                   ;Zero the high word
else    ; NEC_98
        xor     al,al                   ;Prepare to read tick count
        out     43h,al                  ;Send to timer
        in      al,40h                  ;Get the low byte
        mov     ah,al                   ;Save in AH
        in      al,40h                  ;Get the high byte
        xchg    ah,al
        mov     dx,0ffffh               ;Get total countdown amount
        sub     dx,ax                   ;Get number of counts expired
        mov     ax,dx                   ;Get the number in AX for div
        xor     dx,dx                   ;Zero the high word
        mov     cx,1193                 ;Divide to get ms
endif   ; NEC_98
        div     cx                      ;Divide it
        mov     cx, ax                  ;cx == saved Curr count

        ;** Now fill the structure.  Note that the 'ThisVM' entry is the
        ;**     same as the 'SinceStart' entry in standard mode.
        xor     dx, dx
        add     ax, WORD PTR [si].ti_dwmsSinceStart[0] ;Add this count in
        adc     dx, WORD PTR [si].ti_dwmsSinceStart[2]

        ;** Check to make sure we didn't mess up.  If we did (if the timer
        ;**     was reset right in the middle of us reading it).  If we
        ;**     messed up, do it again until we get it right.
        mov     bx, _DATA               ;Get our data segment
        mov     es, bx
        cmp     dx, WORD PTR es:dwLastTimeReturned[2]
        jne     TC_TimeOK
        cmp     ax, WORD PTR es:dwLastTimeReturned[0]
        jae     TC_TimeOK

        ; New time is less than the old time so estimate the curr time
        ; using LastTimeReturned as the base
        mov     ax, WORD PTR es:dwLastTimeReturned[0]
        mov     dx, WORD PTR es:dwLastTimeReturned[2]

        xor     bx, bx                            ;check for wrap
        cmp     cx, word ptr es:wLastCountDown
        jae     TC_NoWrap                         ;if wrap
        add     ax, cx                            ;   += curr count
        adc     dx, 0
        jmp     short TC_TimeOK

TC_NoWrap:                                        ;else no wrap
        mov     bx, cx                            ;  += Curr - LastCountDown
        sub     bx, word ptr es:wLastCountDown
        add     ax, bx
        adc     dx, 0

TC_TimeOK:
        mov     word ptr es:wLastCountDown, cx
        mov     WORD PTR es:dwLastTimeReturned[0], ax
        mov     WORD PTR es:dwLastTimeReturned[2], dx
        mov     WORD PTR [si].ti_dwmsSinceStart[0], ax ;Save good count
        mov     WORD PTR [si].ti_dwmsSinceStart[2], dx
        mov     WORD PTR [si].ti_dwmsThisVM[0],ax ;Save in structure
        mov     WORD PTR [si].ti_dwmsThisVM[2],dx ;Save in structure

TC_ReturnOK:
        mov     ax,1                    ;Return TRUE

TC_End:



cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\terminat.asm ===
PAGE 60,150
;***************************************************************************
;*  TERMINAT.ASM
;*
;*      Assembly code routine used for the TOOLHELP.DLL app terminate
;*      routine.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE TDB.INC

;** Symbols
I_EXCEPTION     EQU     0
I_INTERRUPT     EQU     1
MAX_INTERRUPT   EQU     5
GIVE_WDEB386    EQU     8000h
Q_HACK_30       EQU     54h

.286p

;** Data

sBegin  DATA

wTermFlags      DW      ?               ;Save terminate flags across Yield

sEnd

;** Imported values
externFP InterruptUnRegister
externFP NotifyUnRegister
externFP GetCurrentTask
externFP FatalAppExit
externFP TaskSetCSIP
externFP DirectedYield
externFP TaskSwitch

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  TerminateApp
;       Terminates the task in one of two ways:  TERMINATE_NORMAL or
;       TERMINATE_USER_DISPLAY.  TERMINATE_NORMAL calls KERNEL to display
;       the UAE box and terminates the app.  TERMINATE_USER_DISPLAY also
;       terminates the app but assumes the user has displayed some warning.
;       If the task passed in is not the current task, this function does
;       the DirectedYield() to switch to the correct task before terminating
;       it.
;       This function does not return when terminating the current task
;       except when WDEB386 is installed and the (undocumented) GIVE_WDEB386
;       flag is set.
;       Caller:         TerminateApp(
;                               HANDLE hTask,  (If NULL, does current task)
;                               WORD wFlags)

cProc   TerminateApp, <FAR,PUBLIC>, <si,di,ds>
        parmW   hTask
        parmW   wFlags
cBegin
        mov     ax, _DATA               ;Get our DS
        mov     ds, ax

        ;** Save the flags in the DS so we can get after DYield
        mov     ax,wFlags               ;Get the parameter flags
        mov     wTermFlags,ax           ;Save them

        ;** Get the task value
        cCall   GetCurrentTask          ;Get the task
        mov     si,hTask                ;Get the hTask value
        or      si,si                   ;Zero?
        jnz     TA_10                   ;No
        mov     es,ax                   ;Point ES at current task
        jmp     SHORT TA_NukeCurrent    ;In this case we always nuke current
TA_10:
        ;** If this is the current task, just nuke it and don't return
        cmp     ax,si                   ;Current?
        mov     es,si                   ;Point ES at task
        je      TA_NukeCurrent          ;Yes, nuke it directly

        ;** Switch to the new task and prepare to nuke it
        lea     ax,TA_NewTask           ;Get address of new task entry
        cCall   TaskSwitch, <si,cs,ax>  ;Switch to this task
        jmp     SHORT TA_End            ;Get out

        ;** We're in the new task now
TA_NewTask:
        mov     ax,_DATA                ;Get the TOOLHELP DS
        mov     ds,ax
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;Get the TDB pointer in ES

        ;** HACK ALERT!!!! In order to get USER to allow us to terminate
        ;*      this app, we are manually nuking the semaphore.  This is
        ;*      at a fixed offsets in the Q structure and only needs to
        ;**     be done in 3.0
        test    wTHFlags,TH_WIN30       ;In 3.0?
        jz      TA_NukeCurrent          ;No, don't do this ugly hack
        push    es                      ;Save ES while we play with the queue
        mov     es,es:[TDB_Queue]       ;ES points to queue now
        mov     bx,Q_HACK_30            ;Get 3.0 offset
        mov     WORD PTR es:[bx],0      ;Clear the semaphore count
        mov     WORD PTR es:[bx + 2],0  ;  and the semaphore value to wait for
        pop     es                      ;ES points to TDB again

TA_NukeCurrent:
        ;** Check the flag values.  If NO_UAE_BOX, tell KERNEL
        ;**     not to display the normal UAE box.
        test    wTermFlags,NO_UAE_BOX   ;Display the box?
        jz      TA_20                   ;Yes, so skip this stuff
        or      es:[TDB_ErrMode],02     ;Set the no display box flag
TA_20:
        ;** Terminate the app using KERNEL
        cCall   FatalAppExit, <0,0,0>   ;Do it

        ;** If we're flagged that this is an internal terminate, we just want
        ;*      to return if WDEB is installed so that we can pass the
        ;**     fault on.  To do this, we must return here to the caller.
        test    wFlags,GIVE_WDEB386     ;Internal entry?
        jnz     TA_End                  ;Yes, don't nuke app

        ;** If KERNEL doesn't nuke the app (does this if WDEB386
        ;**     is installed), nuke it ourselves (no UAE box)
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;  in ES
        cmp     WORD PTR es:[TDB_USignalProc] + 2,0 ;USER signal proc?
        jz      @F                      ;No
        mov     bx,0666h                ;Death knell
        mov     di, -1
        cCall   es:[TDB_USignalProc],<es,bx,di,es:[TDB_Module],es:[TDB_Queue]>
@@:     mov     ax,4CFFH                ;Nuke the app
        int     21h                     ;We don't return here

TA_End:

cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\toolhelp.c ===
/**************************************************************************
 *  TOOLHELP.C
 *
 *      Contains the initalization and deinitialization code for the
 *      TOOLHELP DLL.
 *
 **************************************************************************/

#include "toolpriv.h"
#undef VERSION
#include <mmsystem.h>

/* ----- Global variables ----- */
    WORD segKernel;
    WORD wLibInstalled;
    WORD wTHFlags;
    HANDLE hMaster;
    HANDLE hGDIHeap;
    HANDLE hUserHeap;
    WORD NEAR *npwExeHead;
    WORD NEAR *npwTDBHead;
    WORD NEAR *npwTDBCur;
    DWORD NEAR *npdwSelTableStart;
    WORD NEAR *npwSelTableLen;
    FARPROC lpfnGetUserLocalObjType;
    FARPROC lpfnFatalExitHook;
    FARPROC lpfnNotifyHook;
    LPFNUSUD lpfnUserSeeUserDo;
    FARPROC lpfnGetFreeSystemResources;
    FARPROC lpfntimeGetTime;
    WORD wSel;
    WORD wLRUCount;
    char szKernel[] = "KERNEL";

/* ----- Import values ----- */
#define FATALEXITHOOK           MAKEINTRESOURCE(318)
#define GETUSERLOCALOBJTYPE     MAKEINTRESOURCE(480)
#define USERSEEUSERDO           MAKEINTRESOURCE(216)
#define HASGPHANDLER            MAKEINTRESOURCE(338)
#define TOOLHELPHOOK            MAKEINTRESOURCE(341)
#define GETFREESYSTEMRESOURCES  MAKEINTRESOURCE(284)


/*  ToolHelpLibMain
 *      Called by DLL startup code.
 *      Initializes TOOLHELP.DLL.
 */

int PASCAL ToolHelpLibMain(
    HANDLE hInstance,
    WORD wDataSeg,
    WORD wcbHeapSize,
    LPSTR lpszCmdLine)
{
    HANDLE hKernel;
    HANDLE hUser;
    HANDLE hMMSys;

    /* Unless we say otherwise, the library is installed OK */
    wLibInstalled = TRUE;

    /* Do the KERNEL type-checking.  Puts the results in global variables */
    KernelType();

    /* If the KERNEL check failed (not in PMODE) return that the library did
     *  not correctly install but allow the load anyway.
     */
    if (!wTHFlags)
    {
        wLibInstalled = FALSE;

        /* Return success anyway, just fails all API calls */
        return 1;
    }

    /* Grab a selector.  This is only necessary in Win30StdMode */
    if (wTHFlags & TH_WIN30STDMODE)
        wSel = HelperGrabSelector();

    /* Get the User and GDI heap handles if possible */
    hKernel = GetModuleHandle((LPSTR)szKernel);
    hUser = GetModuleHandle("USER");
    hUserHeap = UserGdiDGROUP(hUser);
    hGDIHeap = UserGdiDGROUP(GetModuleHandle("GDI"));

    /* Get all the functions we may need.  These functions only exist in
     *  the 3.1 USER and KERNEL.
     */
    if (!(wTHFlags & TH_WIN30))
    {
        /* FatalExit hook */
        lpfnFatalExitHook = GetProcAddress(hKernel, FATALEXITHOOK);

        /* Internal USER routine to get head of class list */
        lpfnUserSeeUserDo = (LPFNUSUD)(FARPROC)
            GetProcAddress(hUser, USERSEEUSERDO);

        /* Identifies objects on USER's local heap */
        lpfnGetUserLocalObjType = GetProcAddress(hUser, GETUSERLOCALOBJTYPE);

        /* Identifies parameter validation GP faults */
        lpfnPV = GetProcAddress(hKernel, HASGPHANDLER);

        /* See if the new TOOLHELP KERNEL hook is around */
        lpfnNotifyHook = (FARPROC) GetProcAddress(hKernel, TOOLHELPHOOK);
        if (lpfnNotifyHook)
            wTHFlags |= TH_GOODPTRACEHOOK;

        /* Get the USER system resources function */
        lpfnGetFreeSystemResources = (FARPROC)
            GetProcAddress(hUser, GETFREESYSTEMRESOURCES);
    }

    /* Make sure we don't ever call these in 3.0 */
    else
    {
        lpfnFatalExitHook = NULL;
        lpfnUserSeeUserDo = NULL;
        lpfnGetUserLocalObjType = NULL;
        lpfnPV = NULL;
    }

    /* Try to get the multimedia system timer function address */
    hMMSys = GetModuleHandle("MMSYSTEM");
    if (hMMSys)
    {
        TIMECAPS tc;
        UINT (WINAPI* lpfntimeGetDevCaps)(
            TIMECAPS FAR* lpTimeCaps,
            UINT wSize);

        /* Call the timer API to see if the timer's really installed,
         *  and if it is, get the address of the get time function
         */
        lpfntimeGetDevCaps = (UINT(WINAPI *)(TIMECAPS FAR *, UINT))
            GetProcAddress(hMMSys, MAKEINTRESOURCE(604));
        if ((*lpfntimeGetDevCaps)(&tc, sizeof (tc)) == TIMERR_NOERROR)
            lpfntimeGetTime =
                GetProcAddress(hMMSys, MAKEINTRESOURCE(607));
    }

    /* Return success */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\task2.asm ===
;**************************************************************************
;*  TASK2.ASM
;*
;*      Assembly support for the task enumeration routines.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 0
SWAPPRO = 0
        INCLUDE TDB.INC
ifdef WOW
        INCLUDE WOW.INC
endif

;** Data

sBegin  DATA

lpfnRetAddr     DD      0               ;Return address after stack switch

sEnd

;** External functions
externNP HelperHandleToSel
externNP HelperVerifySeg
externFP GetCurrentTask
externFP DirectedYield
ifdef WOW
externFP PostAppMessage
endif

;** Functions

.286p

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA


;  TaskSetCSIP
;       Allows the user to set the CS:IP of a sleeping task so that it will
;       begin execution at this address when the task is yielded to.
;       Returns the old address.

cProc   TaskSetCSIP, <PUBLIC,FAR>, <si>
        parmW   hTask
        parmW   wCS
        parmW   wIP
cBegin
        assumes DS,nothing
        assumes ES,nothing

        ;** If this is the current task, do nothing:  we only work on
        ;**     sleeping tasks
        cCall   GetCurrentTask          ;Gets current task in AX
        mov     bx,hTask                ;Get desired task
        cmp     ax,bx                   ;Same?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Return a DWORD zero
        cwd
        jmp     SHORT TC_End
@@:

        ;** Get the TDB SS:SP
        mov     es,bx                   ;Point to TDB with ES
        les     si,DWORD PTR es:[TDB_TaskSP] ;Get a pointer to the task stack
ifdef WOW
        ;
        ; ES:SI now points to the place where we had the TDB's SS:SP pointing
        ; This spot in wow is actually the SS:BP frame of the WOW16CALL
        ; function.  The definitions for this frame come from WOW.INC (WOW.H).
        ; The addition of this strange value adjusts the SS:SP pointer back
        ; onto the stack, undoing a previous adjustment in TASKING.ASM
        add     si,(vf_vpCSIP-vf_wThunkCSIP)
endif
        ;** Change the CS:IP
        mov     ax,wIP                  ;Get the new IP value
        xchg    ax,es:[si].Task_IP      ;Swap with the old one
        mov     dx,wCS                  ;Get the new CS value
        xchg    dx,es:[si].Task_CS      ;Swap with the old one

TC_End:
cEnd


;  TaskGetCSIP
;       Gets the next CS:IP that this task will run at.

cProc   TaskGetCSIP, <PUBLIC,FAR>, <si>
        parmW   hTask
cBegin
        assumes DS,nothing
        assumes ES,nothing

        ;** If this is the current task, do nothing:  we only work on
        ;**     sleeping tasks
        cCall   GetCurrentTask          ;Gets current task in AX
        mov     bx,hTask                ;Get desired task
        cmp     ax,bx                   ;Same?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Return a DWORD zero
        cwd
        jmp     SHORT TG_End
@@:

        ;** Get the TDB SS:SP
        mov     es,bx                   ;Point to TDB with ES
        les     si,DWORD PTR es:[TDB_TaskSP] ;Get a pointer to the task stack

ifdef WOW
        ;
        ; ES:SI now points to the place where we had the TDB's SS:SP pointing
        ; This spot in wow is actually the SS:BP frame of the WOW16CALL
        ; function.  The definitions for this frame come from WOW.INC (WOW.H).
        ; The addition of this strange value adjusts the SS:SP pointer back
        ; onto the stack, undoing a previous adjustment in TASKING.ASM
        add     si,(vf_vpCSIP-vf_wThunkCSIP)
endif
        ;** Change the CS:IP
        mov     ax,es:[si].Task_IP      ;Get the CS:IP to return
        mov     dx,es:[si].Task_CS

TG_End:
cEnd


;  TaskSwitch
;       Switches to the indicated task from the current one.
;       Returns FALSE if it couldn't task switch.
;       Jumps to the address given by lpJmpAddr

cProc   TaskSwitch, <PUBLIC,FAR>, <si,di>
        parmW   hTask
        parmD   lpJmpAddr
cBegin
        push    ds
        mov     ax, _DATA               ;Make sure to set DS
        mov     ds, ax
        assumes ds,DATA

        ;** Check to make sure TOOLHELP is installed
        cmp     wLibInstalled,0         ;Library installed?
        pop     ds
        assumes ds,nothing
        jnz     @F                      ;Yes
        xor     ax,ax                   ;Return FALSE
        jmp     TS_End                  ;No.  Fail the API
@@:

        ;** Get the task handle
        cCall   GetCurrentTask          ;Get the current task
        cmp     ax,hTask                ;Switch to current task?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Yes, we can't do that so return FALSE

ifdef WOW
        jmp     TS_End
else
        jmp     SHORT TS_End
endif

@@:     cCall   HelperVerifySeg, <hTask,TDB_sig+1> ;Verify the segment
        or      ax,ax                   ;Segment OK?
        jz      TS_End                  ;Nope.  Get out
        mov     es,hTask                ;Get the TDB
        xor     ax,ax                   ;Get a zero just in case
        cmp     es:[TDB_sig], TDB_SIGNATURE ;Signature match?
        jne     TS_End                  ;Return FALSE

        ;** Poke in the address to jump to
        mov     si,es                   ;Save the hTask
        lea     ax,TS_FromYield         ;Point to new task address
        cCall   TaskSetCSIP, <si,cs,ax> ;Set the new address
        mov     es,si                   ;Get hTask back

        ;** Save the jump address from the stack so we can jump to it later
        push    ds
        mov     ax,_DATA                ;Point to our data segment
        mov     ds,ax
        assumes ds,DATA
        mov     ax,WORD PTR lpJmpAddr[0];Get the low word of the ret address
        mov     WORD PTR lpfnRetAddr[0],ax
        mov     ax,WORD PTR lpJmpAddr[2];Get the selector value
        mov     WORD PTR lpfnRetAddr[2],ax
        pop     ds

ifdef WOW
        ;** Force a task switch by posting a message. This is because the
        ;** event count is not used under WOW.
        cCall   PostAppMessage,<es, 0, 0, 0, 0>
else
        ;** Force a task switch by tampering with the event count
        inc     es:[TDB_nEvents]        ;Force at least one event so we
                                        ;  will switch to this task next
endif   ;WOW

        ;** Switch to the new task.  DirectedYield() returns only when this
        ;**     task is next scheduled
        cCall   DirectedYield, <si>     ;Switch to the new task
        mov     ax,1                    ;Return TRUE
        jmp     SHORT TS_End            ;Get out

        ;** Restore from the directed yield
TS_FromYield:

        ;** Make a stack frame to work on.  We can't trash any regs
        PUBLIC TS_FromYield
        sub     sp,4                    ;Save room for a far ret frame
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save everything
        push    ds
        push    es

        ;** Get our jump address from our DS and put in far ret frame
        mov     ax,_DATA                ;Get the TOOLHELP DS
        mov     ds,ax
        mov     ax,WORD PTR lpfnRetAddr[0] ;Get the offset
        mov     [bp + 2],ax             ;Put it on the stack
        mov     ax,WORD PTR lpfnRetAddr[2] ;Get the selector
        mov     [bp + 4],ax             ;Put on the stack

        ;** Restore the event count
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;Get the TDB pointer in ES
ifndef WOW
        dec     es:[TDB_nEvents]        ;Clear the dummy event we put in
endif

        ;** Clear the stack and 'return' to the new address
        pop     es
        pop     ds
        popa
        pop     bp
        retf

TS_End:
cEnd


;  TaskInfo
;
;       Returns information about the task with the given block handle

cProc   TaskInfo, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpTask
        parmW   wTask
cBegin
        ;** Start by verifying the selector
        mov     ax,wTask                ;Get the selector
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        push    ax                      ;Save it
        mov     bx,TDBSize
        cCall   HelperVerifySeg, <ax,bx>
        pop     bx                      ;Get selector back
        or      ax,ax                   ;FALSE return?
        jnz     TI_SelOk                ;Selector's OK
        xor     ax,ax                   ;Return FALSE
        jmp     TI_End
TI_SelOk:

        ;** Verify that the TDB signature matches
        mov     ds,bx                   ;Point with DS
        cmp     ds:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jz      TI_SigOk                ;Must be
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT TI_End
TI_SigOk:

        ;** Now, get information from the TDB
        les     di,lpTask               ;Point to destination buffer
        mov     ax,ds:[TDB_next]        ;Get the next TDB handle
        mov     es:[di].te_hNext,ax     ;Save in public structure
        mov     ax,wTask                ;Get this task's handle
        mov     es:[di].te_hTask,ax     ;Save in buffer
        mov     ax,ds:[TDB_Parent]      ;Get this task's parent
        mov     es:[di].te_hTaskParent,ax ;Save
        mov     ax,ds:[TDB_taskSS]      ;Get the SS
        mov     es:[di].te_wSS,ax
        mov     ax,ds:[TDB_taskSP]      ;Get the SP
        mov     es:[di].te_wSP,ax
        mov     ax,ds:[TDB_nEvents]     ;Event counter
        mov     es:[di].te_wcEvents,ax
        mov     ax,ds:[TDB_Queue]       ;Queue pointer
        mov     es:[di].te_hQueue,ax
        mov     ax,ds:[TDB_PDB]         ;Offset of DOS PSP
        mov     es:[di].te_wPSPOffset,ax
        mov     ax,ds:[TDB_Module]      ;Instance handle (DS) of task
        mov     es:[di].te_hInst,ax
        mov     ax,ds:[TDB_pModule]     ;Module database handle
        mov     es:[di].te_hModule,ax
        mov     cx,8                    ;Copy module name
        push    di                      ;Save structure pointer
        mov     si,TDB_ModName          ;Point to the string
        add     di,te_szModule          ;  and to the string dest
        cld
        repnz   movsb                   ;Copy the string
        mov     BYTE PTR es:[di],0      ;Zero terminate it
        pop     di                      ;Get structure pointer back

        ;** Get information from the stack segment.  Vars from KDATA.ASM
        mov     ax,es:[di].te_wSS       ;Get the SS value
        verr    ax                      ;OK to read here?
        jnz     TI_SkipThis             ;No, so don't do it
        mov     ds,ax                   ;Point with DS
        mov     ax,ds:[0ah]             ;Lowest value of SP allowed
        mov     es:[di].te_wStackTop,ax ;Save in structure
        mov     ax,ds:[0ch]             ;Get stack minimum value so far
        mov     es:[di].te_wStackMinimum,ax ;Save in structure
        mov     ax,ds:[0eh]             ;Largest value of SP allowed
        mov     es:[di].te_wStackBottom,ax ;Save in structure

        ;** Return TRUE on success
TI_SkipThis:
        mov     ax,1                    ;Return TRUE code
TI_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\toolhelp.inc ===
;**************************************************************************
;*  TOOLHELP.INC
;*
;*      Assembly-language public include file for TOOLHELP.DLL
;*
;**************************************************************************

;** General symbol values
MAX_DATA        EQU     11
MAX_PATH        EQU     255
MAX_MODULE_NAME EQU     8 + 1           ;Leave room for the zero and padding
MAX_CLASSNAME   EQU     255

; ----- Global heap walking -----

GLOBALENTRY STRUC
ge_dwSize       DD      ?               ;Structure version
ge_dwAddress    DD      ?               ;This block's address
ge_dwBlockSize  DD      ?               ;This block's size
ge_hBlock       DW      ?               ;This block's handle
ge_wcLock       DW      ?               ;Lock count
ge_wcPageLock   DW      ?               ;Page lock count
ge_wFlags       DW      ?               ;Block flags
ge_wHeapPresent DW      ?               ;Size of available local heap
ge_hOwner       DW      ?               ;Owner handle
ge_wType        DW      ?               ;Block type
ge_wData        DW      ?               ;Type-specific data
ge_dwNext       DD      ?               ;Pointer to next block
ge_dwNextAlt    DD      ?               ;Next free/LRU block in chain
GLOBALENTRY ENDS

; ** GlobalFirst()/GlobalNext() flags
GLOBAL_ALL      EQU     0
GLOBAL_LRU      EQU     1
GLOBAL_FREE     EQU     2

; ** GLOBALENTRY.ge_wType entries
GT_UNKNOWN      EQU     0
GT_DGROUP       EQU     1
GT_DATA         EQU     2
GT_CODE         EQU     3
GT_TASK         EQU     4
GT_RESOURCE     EQU     5
GT_MODULE       EQU     6
GT_FREE         EQU     7
GT_INTERNAL     EQU     8
GT_SENTINEL     EQU     9
GT_BURGERMASTER EQU     10

; ** if GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData:
GD_USERDEFINED          EQU     0
GD_CURSORCOMPONENT      EQU     1
GD_BITMAP               EQU     2
GD_ICONCOMPONENT        EQU     3
GD_MENU                 EQU     4
GD_DIALOG               EQU     5
GD_STRING               EQU     6
GD_FONTDIR              EQU     7
GD_FONT                 EQU     8
GD_ACCELERATORS         EQU     9
GD_RCDATA               EQU     10
GD_ERRTABLE             EQU     11
GD_CURSOR               EQU     12
GD_ICON                 EQU     14
GD_NAMETABLE            EQU     15
GD_MAX_RESOURCE         EQU     15

;** GLOBALENTRY.wFlags
GF_PDB_OWNER    EQU     100h            ;Low byte is KERNEL flags

; ----- Local heap walking -----

LOCALENTRY STRUC
le_dwSize       DD      ?
le_hHandle      DW      ?
le_wAddress     DW      ?
le_wSize        DW      ?
le_wFlags       DW      ?
le_wcLock       DW      ?
le_wType        DW      ?
le_hHeap        DW      ?
le_wHeapType    DW      ?
le_wNext        DW      ?
LOCALENTRY ENDS

; ** LOCALENTRY.wHeapType flags
NORMAL_HEAP     EQU     0
USER_HEAP       EQU     1
GDI_HEAP        EQU     2

;** LOCALENTRY.wFlags
LF_FIXED                EQU     1
LF_FREE                 EQU     2
LF_MOVEABLE             EQU     4

;** LOCALENTRY.wType
LT_NORMAL               EQU     0
LT_GDI_PEN              EQU     1
LT_GDI_BRUSH            EQU     2
LT_GDI_FONT             EQU     3
LT_GDI_PALETTE          EQU     4
LT_GDI_BITMAP           EQU     5
LT_GDI_RGN              EQU     6
LT_GDI_DC               EQU     7
LT_GDI_DISABLED_DC      EQU     8
LT_GDI_METADC           EQU     9
LT_GDI_METAFILE         EQU     10
LT_GDI_MAX              EQU     LT_GDI_METAFILE
LT_FREE                 EQU     0ffh

; ----- Stack tracing -----

STACKTRACEENTRY STRUC
st_dwSize       DD      ?
st_hTask        DW      ?
st_wSS          DW      ?
st_wBP          DW      ?
st_wCS          DW      ?
st_wIP          DW      ?
st_hModule      DW      ?
st_wSegment     DW      ?
st_wFlags       DW      ?
STACKTRACEENTRY ENDS

;** STACKTRACEENTRY.wFlags values
FRAME_FAR       EQU     0
FRAME_NEAR      EQU     1

; ----- Module list walking -----

MODULEENTRY STRUC
me_dwSize       DD      ?
me_szModule     DB      MAX_MODULE_NAME + 1 DUP(?)
me_hModule      DW      ?
me_wcUsage      DW      ?
me_szExePath    DB      MAX_PATH + 1 + 1 DUP(?)
me_wNext        DW      ?
MODULEENTRY ENDS

; ----- Task list walking -----

TASKENTRY STRUC
te_dwSize               DD      ?
te_hTask                DW      ?
te_hTaskParent          DW      ?
te_hInst                DW      ?
te_hModule              DW      ?
te_wSS                  DW      ?
te_wSP                  DW      ?
te_wStackTop            DW      ?
te_wStackMinimum        DW      ?
te_wStackBottom         DW      ?
te_wcEvents             DW      ?
te_hQueue               DW      ?
te_szModule             DB      MAX_MODULE_NAME + 1 DUP(?)
te_wPSPOffset           DW      ?
te_hNext                DW      ?
TASKENTRY ENDS

;** TaskSwitch() return values
TS_ERROR    EQU         0
TS_NEW      EQU         1
TS_OLD      EQU         2

; ----- Window Class enumeration -----

CLASSENTRY STRUC
ce_dwSize               DD      ?
ce_hInst                DW      ?
ce_szClassName          DB      MAX_CLASSNAME + 1 DUP(?)
ce_wNext                DW      ?
CLASSENTRY ENDS

; ----- Information functions -----

VMEMMANINFO STRUC
vmm_dwSize              DD      ?
vmm_dwLargestFreeBlock  DD      ?
vmm_dwMaxPagesAvailable DD      ?
vmm_dwMaxPagesLockable  DD      ?
vmm_dwTotalLinearSpace  DD      ?
vmm_dwTotalUnlockedPages DD     ?
vmm_dwFreePages         DD      ?
vmm_dwTotalPages        DD      ?
vmm_dwFreeLinearSpace   DD      ?
vmm_dwSwapFilePages     DD      ?
vmm_wPageSize           DW      ?
VMEMMANINFO ENDS

SYSHEAPINFO STRUC
si_dwSize               DD      ?
si_wUserFreePercent     DW      ?
si_wGDIFreePercent      DW      ?
si_hUserSegment         DW      ?
si_hGDISegment          DW      ?
SYSHEAPINFO ENDS

; ----- Notifications -----

;* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
;*      should ignore these.
;*
NFY_UNKNOWN     EQU     0

;** NFY_LOADSEG:  dwData points to a NFYLOADSEG structure
NFY_LOADSEG     EQU     1
NFYLOADSEG STRUC
nls_dwSize              DD      ?
nls_wSelector           DW      ?
nls_wSegNum             DW      ?
nls_wType               DW      ?       ;Low bit set for DATA, clear for CODE
nls_wcInstance          DW      ?       ;Instance count ONLY VALID FOR DATA!
nls_lpstrModuleName     DD      ?
NFYLOADSEG ENDS

;** NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed
NFY_FREESEG     EQU     2

;** NFY_STARTDLL:  dwData points to a NFYSTARTDLL structure
NFY_STARTDLL    EQU     3
NFYSTARTDLL STRUC
nsd_dwSize              DD      ?
nsd_hModule             DW      ?
nsd_wCS                 DW      ?
nsd_wIP                 DW      ?
NFYSTARTDLL ENDS

;** NFY_STARTTASK:  dwData is the CS:IP of the task start address
NFY_STARTTASK   EQU     4

;** NFY_EXITTASK:  The low byte of dwData contains the program exit code
NFY_EXITTASK    EQU     5

;** NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed
NFY_DELMODULE   EQU     6

;** NFY_RIP:  LOWORD(dwData) is the fatal exit code
;** NFY_RIP:  dwData points to a NFYRIP structure
NFY_RIP         EQU     7
NFYRIP STRUC
nrp_dwSize      DD      ?
nrp_wIP         DW      ?
nrp_wCS         DW      ?
nrp_wSS         DW      ?
nrp_wBP         DW      ?
nrp_wExitCode   DW      ?
NFYRIP ENDS

;** NFY_TASKIN:  No data.  Callback should do GetCurrentTask()
NFY_TASKIN      EQU     8

;** NFY_TASKOUT:  No data.  Callback should do GetCurrentTask()
NFY_TASKOUT     EQU     9

;** NFY_INCHAR:  Return value of callback is used.  If FALSE, mapped to 'i'
NFY_INCHAR      EQU     10

;** NFY_OUTSTR:  dwData points to the string to be displayed
NFY_OUTSTR      EQU     11

;** NFY_LOGERROR:  dwData points to a NFYLOGERROR struct
NFY_LOGERROR    EQU     12
NFYLOGERROR STRUC
nle_dwSize      DD      ?
nle_wErrCode    DW      ?
nle_lpInfo      DD      ?       ;Error-code dependent
NFYLOGERROR ENDS

;** NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct
NFY_LOGPARAMERROR EQU   13
NFYLOGPARAMERROR STRUC
nlp_dwSize              DD      ?
nlp_wErrCode            DW      ?
nlp_lpfnErrorAddr       DD      ?
nlp_lpBadParam          DD      ?
NFYLOGPARAMERROR ENDS

;** NotifyRegister() flags
NF_NORMAL       EQU     0
NF_TASKSWITCH   EQU     1
NF_RIP          EQU     2

;** TerminateApp() flag values
UAE_BOX         EQU     0
NO_UAE_BOX      EQU     1

TIMERINFO STRUC
ti_dwSize               DD      ?
ti_dwmsSinceStart       DD      ?
ti_dwmsThisVM           DD      ?
TIMERINFO ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\toolpriv.h ===
/**************************************************************************
 *  TOOLPRIV.H
 *
 *      Private header file for routines in the tool helper library
 *
 **************************************************************************/

#ifndef TOOLPRIV_H
#define TOOLPRIV_H

#define BUILDDLL

#include <windows.h>
#include "toolhelp.h"

/* ----- Symbols ----- */
#define VERSION     1
#ifndef NOEXPORT
#define NOEXPORT static
#endif
#define TOOLHELPAPI     WINAPI

#define FAULT_ACTIVE    2
#define NUM_EXCEPTIONS  3

/* wTHFlag values */
#define TH_KERNEL_286       1
#define TH_KERNEL_386       2
#define TH_WIN30            4
#define TH_WIN30STDMODE     8   /* THWIN30STDMODE set if TH_WIN30 & Std mode */
#define TH_GOODPTRACEHOOK   16
#define TH_GOTOLDPTRACE     32

/* ----- Code macros ----- */
#define MAKEFARPTR(s, o) ((void FAR *)(((WORD)(o)) | \
    (((DWORD)(WORD)(s)) << 16)))

/* ----- Types ----- */

typedef struct tagNOTIFYSTRUCT
{
    struct tagNOTIFYSTRUCT *pNext;
    HANDLE hTask;
    LPFNNOTIFYCALLBACK lpfn;
    WORD wFlags;
} NOTIFYSTRUCT;

typedef void (FAR PASCAL *LPFNCALLBACK)(void);

typedef struct tagINTERRUPT
{
    struct tagINTERRUPT *pNext;
    HANDLE hTask;
    LPFNCALLBACK lpfn;
} INTERRUPT;

typedef struct tagSIGNAL
{
    struct tagSIGNAL *pNext;
    HANDLE hTask;
    LPFNCALLBACK lpfn;
    LPFNCALLBACK lpfnOld;
} SIGNAL;

typedef LONG (FAR PASCAL *LPFNUSUD)(
    WORD wID,
    WORD wParam,
    LONG lParam);

/* ----- TOOLHELP global variables ----- */
    extern WORD segKernel;
    extern WORD wLibInstalled;
    extern HANDLE hMaster;
    extern WORD wTHFlags;
    extern HANDLE hUserHeap;
    extern HANDLE hGDIHeap;
    extern WORD NEAR *npwExeHead;
    extern WORD NEAR *npwTDBHead;
    extern WORD NEAR *npwTDBCur;
    extern DWORD NEAR *npdwSelTableStart;
    extern WORD NEAR *npwSelTableLen;
    extern WORD wNotifyInstalled;
    extern NOTIFYSTRUCT NEAR *npNotifyHead;
    extern WORD wIntInstalled;
    extern INTERRUPT NEAR *npIntHead;
    extern FARPROC lpfnGetUserLocalObjType;
    extern FARPROC lpfnFatalExitHook;
    extern FARPROC PASCAL lpfnPV;
    extern FARPROC lpfnNotifyHook;
    extern FARPROC lpfnGetFreeSystemResources;
    extern FARPROC lpfntimeGetTime;
    extern LPFNUSUD lpfnUserSeeUserDo;
    extern WORD wSignalInstalled;
    extern SIGNAL NEAR *npSignalHead;
    extern NOTIFYSTRUCT NEAR* npNotifyNext;
    extern WORD wLRUCount;

/* ----- Private function prototypes ----- */

    void PASCAL KernelType(void);

    DWORD PASCAL Walk386First(
        WORD wFlags);

    WORD PASCAL Walk386Count(
        WORD wFlags);

    void PASCAL Walk386(
        DWORD dwBlock,
        GLOBALENTRY FAR *lpGlobal,
        WORD wFlags);

    DWORD PASCAL Walk386Handle(
        HANDLE hBlock);

    WORD PASCAL WalkLoc386Count(
        HANDLE hHeap);

    HANDLE PASCAL WalkLoc386First(
        HANDLE hHeap);

    void PASCAL WalkLoc386(
        WORD wBlock,
        LOCALENTRY FAR *lpLocal,
        HANDLE hHeap);

    DWORD PASCAL Walk286First(
        WORD wFlags);

    WORD PASCAL Walk286Count(
        WORD wFlags);

    void PASCAL Walk286(
        DWORD dwBlock,
        GLOBALENTRY FAR *lpGlobal,
        WORD wFlags);

    DWORD PASCAL Walk286Handle(
        HANDLE hBlock);

    WORD PASCAL WalkLoc286Count(
        HANDLE hHeap);

    HANDLE PASCAL WalkLoc286First(
        HANDLE hHeap);

    void PASCAL WalkLoc286(
        WORD wBlock,
        LOCALENTRY FAR *lpLocal,
        HANDLE hHeap);

    BOOL PASCAL TaskInfo(
        TASKENTRY FAR *lpTask,
        WORD wBlock);

    WORD PASCAL StackFrameFirst(
        STACKTRACEENTRY FAR *lpStack,
        HANDLE hTDB);

    BOOL PASCAL StackFrameNext(
        STACKTRACEENTRY FAR *lpStack);

    HANDLE PASCAL UserGdiDGROUP(
        HANDLE hModule);

    DWORD PASCAL UserGdiSpace(
        HANDLE hData);

    WORD PASCAL HelperVerifySeg(
        WORD wSeg,
        WORD wcb);

    WORD PASCAL HelperHandleToSel(
        HANDLE h);

    void PASCAL HelperGlobalType(
        GLOBALENTRY FAR *lpGlobal);

    WORD PASCAL HelperGrabSelector(void);

    void PASCAL HelperReleaseSelector(
        WORD wSelector);

    void PASCAL UserGdiType(
        LOCALENTRY FAR *lpLocal);

    BOOL PASCAL NotifyInit(void);

    void PASCAL NotifyUnInit(void);
        
    BOOL PASCAL NotifyIsHooked(
        HANDLE hTask);

    BOOL PASCAL InterruptInit(void);

    void PASCAL InterruptUnInit(void);

    BOOL PASCAL InterruptIsHooked(
        HANDLE hTask);

    BOOL PASCAL SignalRegister(
        HANDLE hTask);

    BOOL PASCAL SignalUnRegister(
        HANDLE hTask);

    void FAR PASCAL HelperSignalProc(void);

    DWORD PASCAL HelperSetSignalProc(
        HANDLE hTask,
        DWORD lpfn);

    BOOL PASCAL ClassInfo(
        CLASSENTRY FAR *lpClass,
        WORD wOffset);

    DWORD PASCAL HelperSegLen(
        WORD wSeg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\toolpriv.inc ===
;**************************************************************************
;*  TOOLPRIV.INC
;*
;*      Private assembly-language include file for modules assembled as a
;*      part of TOOLHELP.DLL.
;*
;**************************************************************************

;** CMACROS.INC variables for correct assembly
DOS5 = 1
PMODE = 1
?WIN = 0
?PLM = 1

.286p

        INCLUDE CMACROS.INC
        INCLUDE TOOLHELP.INC

externA __WinFlags

;** TOOLHELP global variables
?PLM = 0
externW segKernel
externW wLibInstalled
externW hMaster
externW wTHFlags
externW npwExeHead
externW npwTDBHead
externW npwTDBCur
externW hUserHeap
externW hGDIHeap
externW npdwSelTableStart
externW npwSelTableLen
externW wNotifyInstalled
externW npNotifyHead
externW wIntInstalled
externW npIntHead
externD lpfnGetUserLocalObjType
externD lpfnFatalExitHook
externD lpfnUserSeeUserDo
externD lpfnNotifyHook
externD lpfnGetFreeSystemResources
externD lpfntimeGetTime;
externW wSel
externW wSignalInstalled
externW npSignalHead
externW npNotifyNext
externW wLRUCount
?PLM = 1

;** Symbols
TRUE    =       1
FALSE   =       0

KERNEL_286      EQU     1
KERNEL_386      EQU     2

FAULT_ACTIVE    EQU     2

NUM_EXCEP       EQU     3

;** wTHFlag values
TH_KERNEL_286   EQU     1
TH_KERNEL_386   EQU     2
TH_WIN30        EQU     4
TH_WIN30STDMODE EQU     8       ;THWIN30STDMODE set if TH_WIN30 & Std mode
TH_GOODPTRACEHOOK EQU   16
TH_GOTOLDPTRACE EQU     32

;** Notification values
NI_INCHAR       EQU     01h
NI_OUTSTR       EQU     12h
NI_LOADSEG      EQU     50h
NI_FREESEG      EQU     52h
NI_STARTTASK    EQU     59h
NI_EXITCALL     EQU     62h
NI_LOADDLL      EQU     64h
NI_DELMODULE    EQU     65h
NI_TASKOUT      EQU     0dh
NI_TASKIN       EQU     0eh
NI_CTLALTSYSRQ  EQU     63h
NI_LOGERROR     EQU     66h
NI_LOGPARAMERROR EQU    67h

;** Structures

NOTIFYSTRUCT STRUC
ns_pNext                DW      ?
ns_hTask                DW      ?
ns_lpfn                 DD      ?
ns_wFlags               DW      ?
NOTIFYSTRUCT ENDS

INTERRUPT STRUC
i_pNext                 DW      ?
i_hTask                 DW      ?
i_lpfn                  DD      ?
INTERRUPT ENDS

SIGNAL STRUC
si_pNext                DW      ?
si_hTask                DW      ?
si_lpfn                 DD      ?
si_lpfnOld              DD      ?
SIGNAL ENDS

;** Macros
PubLabel MACRO PLabel
        labelNP PLabel
        PUBLIC PLabel
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\usergdi2.asm ===
;***************************************************************************
;*  USERGDI2.ASM
;*
;*      Assembly routines used in computing heap space remaining for
;*      USER, GDI, and any other heaps.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
SWAPPRO = 0
PMODE32 = 0
PMODE   = 1
        INCLUDE WINKERN.INC
        INCLUDE NEWEXE.INC

;** This slimy thing is from GDIOBJ.INC and is subtracted from the
;**     object type nunbers only in 3.1
LT_GDI_BASE     EQU     ('G' or ('O' * 256)) - 1

;** External functions

externNP HelperVerifyLocHeap
externNP HelperHandleToSel

;** Functions

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

.286p

;  UserGdiDGROUP
;       Returns a handle to the DGROUP segment for a given module
;
;       HANDLE UserGdiDGROUP(
;               HANDLE hModule)

cProc   UserGdiDGROUP, <PUBLIC,NEAR>, <di,si>
        parmW   hModule
cBegin
        mov     ax,hModule              ;Get the handle
        cCall   HelperHandleToSel, <ax> ;Convert to a selector
        mov     es,ax                   ;Point with ES for this
        xor     ax,ax                   ;Prepare to return NULL
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jnz     UGD_End                 ;It isn't so get out
        mov     bx,es:[ne_pautodata]    ;Point to the segment table entry
        mov     ax,es:[bx].ns_handle    ;Get the handle from the table
        cCall   HelperHandleToSel, <ax> ;Convert to a selector for return
UGD_End:
cEnd


;  UserGdiSpace
;       This function was stolen from KERNEL where it is used to compute
;       the space remaining in the USER and GDI heaps.  It actually works
;       on any local heap.
;
;       DWORD UserGdiSpace(
;               HANDLE hData)
;       HIWORD of return is maximum size of heap (64K less statics, etc.)
;       LOWORD of return is space remaining on heap

cProc   UserGdiSpace, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hData
cBegin
        ;** Count the free space in this heap.  First:  Is this heap valid?
        mov     ax,hData                ;Get the heap selector
        cCall   HelperVerifyLocHeap     ;Call the verify routine
        mov     ax,0                    ;In case we jump -- set error
        mov     dx,0                    ;  Use MOV to not mess up carry
        jc      UGS_Exit                ;No valid local heap!!

        ;** Loop through all local blocks, adding free space
        cCall   HelperHandleToSel, <hData> ;Convert to selector
        mov     ds,ax                   ;Point to the segment
        mov     di,ds:[6]               ;Get pHeapInfo
        mov     di,[di].hi_first        ;First arena header
        mov     di,[di].la_free_next    ;First free block
UGS_Loop:
        add     ax,[di].la_size         ;Add in size of this block
        sub     ax,SIZE LocalArenaFree  ;Less block overhead
        mov     si,[di].la_free_next    ;Get next free block
        or      si,si                   ;NULL?
        jz      UGS_Break               ;Yes, say we're done
        cmp     si,di                   ;Last block? (points to self)
        mov     di,si                   ;Save for next time around
        jnz     UGS_Loop                ;Not last block so loop some more
UGS_Break:

        ;** We have the size of the local heap
        mov     si,ax                   ;Save the size
        mov     cx,ds                   ;Get the selector in a non-segreg
        lsl     ax,cx                   ;Get the size of the segment
        neg     ax                      ;64K - segment size
        add     ax,si                   ;Add in the free holes in the heap
        mov     dx,-1                   ;Compute the max size of heap
        sub     dx,ds:[6]               ;  which is 64K less statics

UGS_Exit:

cEnd


;  UserGdiType
;
;       Tries to compute the type of local heap block if possible
;       Prototype:
;
;       void PASCAL UserGdiType(
;               LOCALENTRY FAR *lpLocal)

cProc   UserGdiType, <PUBLIC,NEAR>, <si,di>
        parmD   lpLocal
cBegin
        ;** Get info from our static variables
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** See if we can do anything with this heap
        les     si,lpLocal              ;Get a pointer to the structure
        mov     es:[si].le_wType,LT_NORMAL ;In case we don't find anything
        mov     ax,es:[si].le_hHeap     ;Get the heap pointer
        cmp     ax,bx                   ;User's heap?
        jnz     UGT_10                  ;Nope, try next
        cCall   GetUserType             ;Call routine to get user type
        jmp     SHORT UGT_End           ;Get out

UGT_10: cmp     ax,cx                   ;GDI's heap?
        jnz     UGT_End                 ;Nope, can't do anything with it
        cCall   GetGDIType              ;Call routine to get GDI type

UGT_End:

cEnd


;** Internal helper functions

;  GetUserType
;
;       Uses the tags in debug USER.EXE to give information on what type
;       block is pointed to by the current LOCALENTRY structure.
;       Caller:  ES:SI points to the parameter LOCALENTRY structure
;       Return:  LOCALENTRY structure is correctly updated

cProc   GetUserType, <NEAR>
cBegin
        ;** Make sure we have a function to call
        cmp     WORD PTR lpfnGetUserLocalObjType + 2,0 ;Selector zero?
        je      GUT_End                 ;Yes

        ;** Call USER to get the type
        push    es                      ;Save ES
        mov     bx,es:[si].le_wAddress  ;Get the block address
        sub     bx, la_fixedsize        ;The USER call needs the arena header
        test    es:[si].le_wFlags, LF_MOVEABLE ;Moveable block?
        jz      @F                      ;No
        sub     bx, (SIZE LocalArena) - la_fixedsize ;Moveable arena bigger
@@:     push    bx                      ;Parameter arena handle
        call    DWORD PTR lpfnGetUserLocalObjType ;Call the function
        pop     es
        xor     ah,ah                   ;Clear the upper byte
        mov     es:[si].le_wType,ax     ;Save the type
GUT_End:
cEnd


;  GetGDIType
;
;       Uses the tags in debug GDI.EXE to give information on what type
;       block is pointed to by the current LOCALENTRY structure.
;       Caller:  ES:SI points to the parameter LOCALENTRY structure
;       Return:  LOCALENTRY structure is correctly updated

cProc   GetGDIType, <NEAR>, <ds>
cBegin
        ;** All fixed blocks are unknown to us
        test    es:[si].le_wFlags,LF_FIXED ;Is it fixed?
        jz      GGT_10                  ;Nope
        jmp     SHORT GGT_End           ;Yes, get out
GGT_10:

        ;** Prepare to find the type
        cCall   HelperHandleToSel,es:[si].le_hHeap ;Get the selector value
        mov     cx,wTHFlags             ;Save for when we trash DS
        mov     ds,ax                   ;Get the heap pointer
        mov     di,es:[si].le_wAddress  ;Get the block pointer

        ;** Get the type word
        mov     ax,[di+2]               ;Get the type word from the heap
        and     ax,05fffh               ;Mask out the stock object flag
        test    cx,TH_WIN30             ;In 3.0?
        jnz     CGT_Win30               ;Yes
        sub     ax,LT_GDI_BASE          ;No, subtract type tag base
CGT_Win30:
        cmp     ax,LT_GDI_MAX           ;Recognizable type code?
        ja      GGT_End                 ;No, get out
        mov     es:[si].le_wType,ax     ;Save in the structure

GGT_End:
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\walk286.asm ===
;**************************************************************************
;*  walk286.ASM
;*
;*      Assembly support code for the KRNL286 global heap routines
;*      for TOOLHELP.DLL
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 1
SWAPPRO = 0
        INCLUDE WINKERN.INC

;** External functions
externNP HelperVerifySeg
externNP HelperHandleToSel
externNP HelperPDBtoTDB
externNP HelperSegLen

;** Functions

sBegin  CODE
        assumes CS,CODE

;  Walk286Count
;
;       Returns the number of blocks in the given list

cProc   Walk286Count, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      W2C_LRU                 ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      W2C_Free                ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get total object count
        mov     ax,es:[hi_count]        ;Get heap count
        inc     ax                      ;Bump to include first sentinel
        jmp     SHORT W2C_End           ;Get out

        ;** Get LRU object count
W2C_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the LRU count
        jmp     SHORT W2C_End           ;Get out

        ;** Get Free list object count
W2C_Free:
        mov     ax,es:[gi_free_count]   ;Get free count
        jmp     SHORT W2C_End           ;Get out

        ;** Return the result in AX
W2C_End:
        
cEnd

;  Walk286First
;
;       Returns a handle to the first block in the 286 global heap.

cProc   Walk286First, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      W2F_LRU                 ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      W2F_Free                ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get first object in complete heap (wFlags == GLOBAL_ALL)
        mov     ax,es:[hi_first]        ;Get handle of first arena header
        jmp     SHORT W2F_End           ;Get out

        ;** Get first object in LRU list
W2F_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the number of objects
        or      ax,ax                   ;Are there any objects?
        je      W2F_End                 ;No, return NULL
        inc     es:[gi_lrulock]         ;No LRU sweeping for awhile
        inc     wLRUCount               ;Keep a count of this
        mov     ax,es:[gi_lruchain]     ;Get a pointer to the first item
        jmp     SHORT W2F_End           ;Done

        ;** Get first object in Free list
W2F_Free:
        mov     ax,es:[gi_free_count]   ;Get the number of objects
        or      ax,ax                   ;Are there any objects?
        jz      W2F_End                 ;No, return NULL
        mov     es,es:[hi_first]        ;Get the first object
        mov     ax,es:[ga_freenext]     ;Skip to the first free block
                                        ;Fall through to the return

        ;** Return the result in AX (return DX = NULL)
W2F_End:
        xor     dx,dx                   ;Clear high word
cEnd


;  Walk286
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   Walk286, <PUBLIC,NEAR>, <di,si,ds>
        parmD   dwBlock
        parmD   lpGlobal
        parmW   wFlags
cBegin
        ;** Set up to build public structure
        mov     es,WORD PTR dwBlock     ;Point to this block
        lds     si,lpGlobal             ;Point to the GLOBALENTRY structure

        ;** Fill public structure
        mov     ax,es:[ga_handle]       ;Get the handle of the block
        mov     [si].ge_hBlock,ax       ;Put in public structure
        mov     ax,es:[ga_size]         ;Get the size of the block (LOWORD)
        mov     dx,ax                   ;Clear high word
        shl     ax,4                    ;Left shift DX:AX by 4
        shr     dx,16-4
        mov     WORD PTR [si].ge_dwBlockSize,ax ;Put in public structure
        mov     WORD PTR [si].ge_dwBlockSize + 2,dx ;Put in public structure
        mov     ax,es:[ga_owner]        ;Owning task of block
        mov     [si].ge_hOwner,ax       ;Put in public structure
        xor     ah,ah                   ;No upper BYTE
        mov     al,es:[ga_count]        ;Lock count (moveable segments)
        mov     [si].ge_wcLock,ax       ;Put in public structure
        mov     WORD PTR [si].ge_wcPageLock,0 ;Zero the page lock count
        mov     al,es:[ga_flags]        ;BYTE of flags
        xor     ah,ah                   ;No upper BYTE
        mov     [si].ge_wFlags,ax       ;Put in public structure
        mov     ax,es:[ga_next]         ;Put next pointer in structure
        mov     WORD PTR [si].ge_dwNext,ax
        mov     WORD PTR [si].ge_dwNext + 2,0

        ;** Use DPMI to compute linear address of selector
        mov     ax,6                    ;Get Segment Base Address
        mov     bx,es                   ;Get the segment value
        int     31h                     ;Call DPMI
        mov     WORD PTR [si].ge_dwAddress,dx ;Save linear address
        mov     WORD PTR [si].ge_dwAddress + 2,cx

        ;** If this is a data segment, get local heap information
        mov     ax,[si].ge_hBlock       ;Get the handle
        cCall   Walk286VerifyLocHeap
        mov     [si].ge_wHeapPresent,TRUE ;Flag that there's a heap
        jnc     W2_10                   ;There really is no heap
        mov     [si].ge_wHeapPresent,FALSE ;Flag that there's no heap
W2_10:

        ;** If the owner is a PDB, translate this to the TDB
        mov     bx,[si].ge_hOwner       ;Get the owner
        cCall   HelperHandleToSel, <bx> ;Translate to selector
        mov     bx,ax                   ;Get the selector in BX
        cCall   HelperVerifySeg, <ax,2> ;Must be two bytes long
        or      ax,ax                   ;Is it?
        jz      W2_15                   ;No.
        push    es                      ;Save ES for later
        mov     es,bx                   ;Point to possible PDB block
        cmp     es:[0],20CDh            ;Int 20h is first word of PDB
        jnz     W2_12                   ;Nope, don't mess with this
        mov     ax,bx                   ;Pass parameter in AX
        cCall   HelperPDBtoTDB          ;Get the corresponding TDB
        or      ax,ax                   ;Was one found?
        jz      W2_11                   ;No.
        mov     [si].ge_hOwner,ax       ;Make the owner the TDB instead
W2_11:  or      [si].ge_wFlags,GF_PDB_OWNER ;Flag that a PDB owned block
W2_12:  pop     es                      ;Restore ES
W2_15:

        ;** Check for this being the last item in both lists
        mov     ax,es                   ;Get the current pointer
        cmp     ax,es:[ga_next]         ;See if we're at the end
        jne     W2_20                   ;No
        mov     WORD PTR [si].ge_dwNext,0 ;NULL the next pointer
        mov     WORD PTR [si].ge_dwNext + 2,0
W2_20:  mov     ax,es                   ;Get current pointer
        mov     cx,wFlags               ;Get the flags back
        cCall   NextLRU286              ;Get next LRU list pointer or 0
        mov     WORD PTR [si].ge_dwNextAlt,ax
        mov     WORD PTR [si].ge_dwNextAlt + 2,0

W2_End:
cEnd


;  Walk286Handle
;
;       Finds an arena pointer given a block handle

cProc   Walk286Handle, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hBlock
cBegin
        mov     ax,hBlock               ;Get the block handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cCall   SelToArena286           ;Get the arena pointer
        jnc     W2H_10                  ;Must be OK
        xor     ax,ax                   ;Return a 0L
        xor     dx,dx
        jmp     SHORT W2H_End           ;Error in conversion, get out
W2H_10: mov     ax,bx                   ;Get the low word
        xor     dx,dx                   ;No high word
W2H_End:
cEnd


;  WalkLoc286Count
;
;       Returns the number of blocks in the given local heap

cProc   WalkLoc286Count, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LC_10                   ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LC_End            ;Get out
LC_10:

        ;** Point to the block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the number of blocks
        mov     ax,es:[bx].hi_count     ;Get the count
LC_End:
cEnd


;  WalkLoc286First
;
;       Returns a handle to the first block in the 286 global heap.

cProc   WalkLoc286First, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that the given global block has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LF_10                   ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LF_End            ;Get out
LF_10:

        ;** Point to the global block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the first block and return it
        mov     ax,WORD PTR es:[bx].hi_first ;Get the first block
LF_End:
cEnd


;  WalkLoc286
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   WalkLoc286, <PUBLIC,NEAR>, <di,si,ds>
        parmW   wBlock
        parmD   lpLocal
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LW_10                   ;It's OK
        jmp     LW_End                 ;Get out
LW_10:

        ;** Get variables from the TOOLHELP DGROUP
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** Point to the heap
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        lds     di,lpLocal              ;Point to the LOCALENTRY structure
        mov     [di].le_wHeapType,NORMAL_HEAP ;In case we don't match below...
        cmp     bx,hHeap                ;User's heap?
        jnz     LW_3                    ;No
        mov     [di].le_wHeapType,USER_HEAP ;Yes
        jmp     SHORT LW_5              ;Skip on
LW_3:   cmp     cx,hHeap                ;GDI's heap?
        jnz     LW_5                    ;No
        mov     [di].le_wHeapType,GDI_HEAP ;Yes
LW_5:
        mov     si,wBlock               ;Get the address of the block

        ;** Get information about the given block
        mov     bx,es:[si].la_handle    ;Get the handle
        mov     [di].le_hHandle,bx      ;Save in the public structure
        mov     ax,si                   ;Get block address
        add     ax,la_fixedsize         ;Skip fixed size local arena
        mov     [di].le_wAddress,ax     ;Save the block address
        mov     ax,es:[si].la_next      ;Get the address of the next block
        mov     [di].le_wNext,ax        ;Save the next pointer
        sub     ax,si                   ;Compute the size
        sub     ax,SIZE LocalArena      ;Don't count arena size
        mov     [di].le_wSize,ax        ;Save in public structure
        mov     ax,es:[si].la_prev      ;Get the flags
        and     ax,3                    ;Mask out all but flags
        mov     [di].le_wFlags,ax       ;Save in structure

        ;** Moveable arenas are bigger and have a lock count to get
        test    al,LA_MOVEABLE          ;Block has a handle iff it's moveable
        jz      SHORT LW_NoHandle       ;No handle info
        sub     [di].le_wSize, (SIZE LocalArena) - la_fixedsize
        add     [di].le_wAddress, (SIZE LocalArena) - la_fixedsize
        xor     ah,ah                   ;Clear upper word
        mov     al,es:[bx].lhe_count    ;Get lock count
        mov     [di].le_wcLock,ax       ;Save it
        jmp     SHORT LW_20             ;Skip no handle info
LW_NoHandle:
        mov     ax, [di].le_wAddress    ;Handle of fixed block is real offset
        mov     [di].le_hHandle, ax
        mov     [di].le_wcLock,0
LW_20:
        ;** See if it's the end
        cmp     [di].le_wNext,si        ;Loop pointer?
        jnz     LW_End                  ;Nope
        mov     [di].le_wNext,0         ;Set a zero pointer
LW_End:
cEnd


;  Walk286VerifyLocHeap
;
;       Verifies that the given global block points to a data segment
;       with a local heap.
;
;       Call:
;               AX = Block handle or selector
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

cProc   Walk286VerifyLocHeap, <PUBLIC,NEAR>, <es,si,di>
cBegin
        ;** Convert to a handle
        cCall   HelperHandleToSel, <ax>

        ;** Verify the selector
        push    ax                      ;Save the parameter
        mov     bx,SIZE LocalInfo       ;Get the size
        cCall   HelperVerifySeg, <ax,bx> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     VLH_SelOK               ;Yes.
        stc                             ;Set error flag 
        jmp     SHORT VLH_End           ;Get out
VLH_SelOK:

        ;** Check data segment to see if it has a local heap
        mov     es,ax                   ;Point to the local block with ES
        cCall   HelperSegLen, <ax>      ;Get the length of the heap
        or      ax,ax                   ;Check for error
        jz      VLH_NoHeap              ;Get out on error
        mov     cx,ax                   ;Use CX for comparisons
        cmp     cx,8                    ;At least 8 bytes long?
        ja      VLH_10                  ;Yes
        stc                             ;No -- set error flag and get out
        jmp     SHORT VLH_End
VLH_10: mov     bx,es:[6]               ;Get offset to HeapInfo struct
        or      bx,bx                   ;If NULL, no local heap
        jz      VLH_NoHeap              ;Get out
        sub     cx,bx                   ;See if HeapInfo is beyond segment
        jbe     VLH_NoHeap
        sub     cx,li_sig + 2           ;Compare against last structure mem
        jbe     VLH_NoHeap
        cmp     es:[bx].li_sig,LOCALHEAP_SIG ;Make sure the signature matches
        jne     VLH_NoHeap              ;Doesn't match
        clc                             ;Must be a heap!
        jmp     SHORT VLH_End

VLH_NoHeap:
        stc                             ;Set error flag

VLH_End:
cEnd


;** Private helper functions

;  SelToArena286
;
;       Finds the arena entry for the given selector or handle.
;       The arena entry is stored 16 bytes before the block in linear
;       address space.
;
;       Caller:         AX = Selector
;       Returns:        BX = Arena entry
;       Trashes everything except segment registers and AX
;       Carry set on error

cProc   SelToArena286, <NEAR>, <es,ds,ax>
cBegin
        ;** Convert to a handle
        cCall   HelperHandleToSel, <ax>

        ;** Verify selector
        push    ax                      ;Save the parameter
        cCall   HelperVerifySeg, <ax,1> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     STA_SelOK               ;Must be
        stc                             ;Nope.  Set error flag and exit
        jmp     SHORT STA_End
STA_SelOK:
        ;** If this is Win30StdMode, we're in the old KRNL286 which used
        ;*      an arcane method of finding the arena.  If that's the case
        ;**     here, handle it seperately.
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx
        test    wTHFlags,TH_WIN30STDMODE ;3.0 Std Mode?
        jnz     STA_OldKRNL286          ;Yes
        mov     bx,segKernel            ;Get the KERNEL variable segment
        mov     es,bx
        mov     bx,npwSelTableLen       ;Get the pointer
        mov     dx,es:[bx]              ;Get the selector table length
        mov     bx,npdwSelTableStart    ;Get the start of the sel table
        mov     bx,es:[bx]              ;Get the linear offset (32 bits)
        mov     es,hMaster              ;Point to the arena table
        and     al,not 7                ;Clear the RPL bits for table lookup
        shr     ax,2                    ;Convert to WORD offset
        cmp     ax,dx                   ;Check to see if off the end of table
        jb      STA_InTable             ;It's in the table
        stc                             ;Set error flag--not in table
        jmp     SHORT STA_End           ;Get out
STA_InTable:
        add     bx,ax                   ;Add the selector offset
        mov     bx,es:[bx]              ;Do the sel table indirection
        clc                             ;BX now points to arena segment
        jmp     SHORT STA_End           ;Skip the old stuff

STA_OldKRNL286:
        mov     bx,ax                   ;Selector in BX
        mov     ax,6                    ;DPMI function 6, Get Seg Base Addr
        int     31h                     ;Call DPMI
        sub     dx,10h                  ;Move back 16 bytes
        sbb     cx,0                    ;  (this is a linear address)
        mov     ax,7                    ;DPMI function 7, Set Seg Base Addr
        mov     bx,wSel                 ;Use our roving selector
        int     31h                     ;Call DPMI
        mov     ax,8                    ;DPMI function 8, Set Seg Limit
        xor     cx,cx                   ;No upper byte
        mov     dx,16                   ;Just 16 bytes
        int     31h                     ;Call DPMI
        mov     ax,9                    ;DPMI function 9, Set Access Rights
        mov     cl,0b2h                 ;Desired rights byte
        int     31h                     ;Call DPMI
                                        ;Return arena segment pointer in BX
STA_End:
cEnd


;  NextLRU286
;
;       Checks the given arena table pointer to see if it is the last
;       arena entry on the list.
;       Uses a grungy method that is necessitated because of the
;       unterminated linked lists we're dealing with here.  The count
;       stored is the only reliable method for finding the end.  So, to
;       provide random access to blocks in the heap, the heap is searched
;       from top to bottom to find the block and see if it is the last
;       one.  If it is or if it is not on the given list, returns a 0
;       pointer to the next item.
;
;       If this search is for the entire global heap, we do not get the
;       LRU link, but return NULL in AX.  This speeds this up alot!
;
;       Caller:         AX = Arena table pointer
;                       CX = GLOBAL_ALL, GLOBAL_FREE, or GLOBAL_LRU
;       Return:         AX = Next arena table pointer or 0 if no more
;       Trashes all registers except segment registers and SI,DI

cProc   NextLRU286, <NEAR,PUBLIC>, <es,ds,si,di>
cBegin
        ;** Decode the flags
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx                   ;Point with DS
        mov     es,hMaster              ;Segment of master block
        cmp     cx,GLOBAL_ALL           ;Don't do this on full heap search
        jne     @F
        jmp     SHORT NL_BadList        ;Just return NULL for this one
@@:     cmp     cx,GLOBAL_FREE          ;Check free list?
        je      NL_Free                 ;Yes

        ;** Loop through LRU list until we find this item
NL_LRU:
        mov     si,ax                   ;Save the selector in AX
        mov     cx,es:[gi_lrucount]     ;Get the number of objects
        jcxz    NL_Bad                  ;No object so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_Bad                  ;1 object so return end
        mov     ds,es:[gi_lruchain]     ;Get a pointer to the first item
NL_LRULoop:
        mov     ax,ds                   ;Get in AX so we can compare
        cmp     si,ax                   ;Match yet?
        je      NL_ReturnNext           ;Found it, return next item
        mov     ds,ds:[ga_lrunext]      ;Not found yet, get the next one
        loop    NL_LRULoop              ;Loop through all items

        ;** Unlock the LRU sweeping
NL_Bad: dec     es:[gi_lrulock]         ;OK to LRU sweep now
        mov     ax, _DATA               ;Point to TH Data seg
        mov     ds, ax
        dec     wLRUCount               ;Keep a count of this
        jmp     SHORT NL_BadList        ;Not here either.  Get out

        ;** Loop through free list until we find this item
NL_Free:
        mov     si,ax                   ;Save the selector in SI
        mov     cx,es:[gi_free_count]   ;Get the number of objects
        jcxz    NL_BadList              ;0 objects so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_BadList              ;1 object so return end
        mov     ds,es:[hi_first]        ;Get a pointer to the first item
NL_FreeLoop:
        mov     ds,ds:[ga_lrunext]      ;Not found yet, get the next one
        mov     ax,ds                   ;Get the pointer so we can compare it
        cmp     ax,si                   ;Is this the one?
        je      NL_ReturnNext           ;Yes, return it
        loop    NL_FreeLoop             ;Loop through all items
        jmp     SHORT NL_BadList        ;Not here either.  Get out

NL_ReturnNext:
        mov     ax,ds:[ga_lrunext]      ;Return the next one
        jmp     SHORT NL_End            ;Get out

NL_BadList:
        xor     ax,ax                   ;Return zero for error

NL_End:
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\usergdi1.c ===
/**************************************************************************
 *  USERGDI1.C
 *
 *      Returns information about USER.EXE and GDI.EXE
 *
 **************************************************************************/

#include "toolpriv.h"

/*  SystemHeapInfo
 *      Returns information about USER's and GDI's heaps
 */

BOOL TOOLHELPAPI SystemHeapInfo(
    SYSHEAPINFO FAR* lpSysHeap)
{
    MODULEENTRY ModuleEntry;
#ifndef WOW
    DWORD dw;
    WORD wFreeK;
    WORD wMaxHeapK;
#endif

    /* Check the structure version number and pointer */
    if (!wLibInstalled || !lpSysHeap ||
        lpSysHeap->dwSize != sizeof (SYSHEAPINFO))
        return FALSE;

    /* Find the user data segment */
    ModuleEntry.dwSize = sizeof (MODULEENTRY);
    lpSysHeap->hUserSegment =
        UserGdiDGROUP(ModuleFindName(&ModuleEntry, "USER"));
    lpSysHeap->hGDISegment =
        UserGdiDGROUP(ModuleFindName(&ModuleEntry, "GDI"));

#ifndef WOW
    /* We get the information about the heap percentages differently in
     *  3.0 and 3.1
     */
    if ((wTHFlags & TH_WIN30) || !lpfnGetFreeSystemResources)
    {
        /* Get the space information about USER's heap */
        dw = UserGdiSpace(lpSysHeap->hUserSegment);
        wFreeK = LOWORD(dw) / 1024;
        wMaxHeapK = HIWORD(dw) / 1024;
        if (wMaxHeapK)
            lpSysHeap->wUserFreePercent = wFreeK * 100 / wMaxHeapK;
        else
            lpSysHeap->wUserFreePercent = 0;

        /* Get the space information about GDI's heap */
        dw = UserGdiSpace(lpSysHeap->hGDISegment);
        wFreeK = LOWORD(dw) / 1024;
        wMaxHeapK = HIWORD(dw) / 1024;
        if (wMaxHeapK)
            lpSysHeap->wGDIFreePercent = wFreeK * 100 / wMaxHeapK;
        else
            lpSysHeap->wGDIFreePercent = 0;
    }

    /* Get the information from USER in 3.1 */
    else
    {
        lpSysHeap->wUserFreePercent =
            (*(WORD (FAR PASCAL *)(WORD))lpfnGetFreeSystemResources)(2);
        lpSysHeap->wGDIFreePercent =
            (*(WORD (FAR PASCAL *)(WORD))lpfnGetFreeSystemResources)(1);
    }
#else

    lpSysHeap->wUserFreePercent = GetFreeSystemResources(GFSR_USERRESOURCES);
    lpSysHeap->wGDIFreePercent = GetFreeSystemResources(GFSR_GDIRESOURCES);

#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\toolhelp\walk386.asm ===
;**************************************************************************
;*  walk386.ASM
;*
;*      Assembly support code for the KERNEL386 global heap routines
;*      for TOOLHELP.DLL
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 1
PMODE   = 0
SWAPPRO = 0
        INCLUDE WINKERN.INC

;** External functions
externNP HelperVerifySeg
externNP HelperHandleToSel
externNP HelperPDBtoTDB
externNP HelperSegLen

;** Functions

sBegin  CODE
        assumes CS,CODE
.386p

;  Walk386Count
;
;       Returns the number of blocks in the given list

cProc   Walk386Count, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      SHORT W3C_LRU           ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      SHORT W3C_Free          ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get total object count
        mov     ax,es:[hi_count]        ;Get heap count
        inc     ax                      ;Bump to include first sentinel
        jmp     SHORT W3C_End           ;Get out

        ;** Get LRU object count
W3C_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the LRU count
        jmp     SHORT W3C_End           ;Get out

        ;** Get Free list object count
W3C_Free:
        mov     ax,es:[gi_free_count]   ;Get free count
        jmp     SHORT W3C_End           ;Get out

        ;** Return the result in AX
W3C_End:
        
cEnd

;  Walk386First
;
;       Returns a handle to the first block in the 386 global heap.

cProc   Walk386First, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      SHORT W3F_LRU           ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      SHORT W3F_Free          ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get first object in complete heap (wFlags == GLOBAL_ALL)
        mov     edi,es:[phi_first]      ;Get offset of first arena header
        jmp     SHORT W3F_End           ;Get out

        ;** Get first object in LRU list
W3F_LRU:
        xor     edi,edi                 ;Zero upper word
        mov     di,es:[gi_lrucount]     ;Get the number of objects
        or      di,di                   ;Are there any objects?
        jz      SHORT W3F_End           ;No, return NULL
        mov     edi,es:[gi_lruchain]    ;Get a pointer to the first item
        jmp     SHORT W3F_End           ;Done

        ;** Get first object in Free list
W3F_Free:
        xor     edi,edi                 ;Zero upper word
        mov     di,es:[gi_free_count]   ;Get the number of objects
        or      di,di                   ;Are there any objects?
        jz      SHORT W3F_End           ;No, return NULL
        mov     edi,es:[phi_first]      ;Get the first object
        mov     edi,es:[edi].pga_freenext ;Skip to the first free block
                                        ;Fall through to the return

        ;** Save the result in DX:AX for the return
W3F_End:
        mov     ax,di                   ;Get the low word
        shr     edi,16                  ;Get the high word out
        mov     dx,di                   ;Get the high word
cEnd


;  Walk386
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   Walk386, <PUBLIC,NEAR>, <di,si,ds>
        parmD   dwBlock
        parmD   lpGlobal
        parmW   wFlags
cBegin
        ;** Set up to build public structure
        mov     es,hMaster              ;Get the correct segment
        mov     edi,dwBlock             ;Point to this block
        lds     si,lpGlobal             ;Point to the GLOBALENTRY structure

        ;** Fill public structure
        mov     ax,es:[edi].pga_handle  ;Get the handle of the block
        mov     [si].ge_hBlock,ax       ;Put in public structure
        mov     eax,es:[edi].pga_address ;Get linear address of block
        mov     [si].ge_dwAddress,eax   ;Put in public structure
        mov     eax,es:[edi].pga_size   ;Get the size of the block
        mov     [si].ge_dwBlockSize,eax ;Put in public structure
        mov     ax,es:[edi].pga_owner   ;Owning task of block
        mov     [si].ge_hOwner,ax       ;Put in public structure
        xor     ah,ah
        mov     al,es:[edi].pga_count   ;Lock count (moveable segments)
        mov     [si].ge_wcLock,ax       ;Put in public structure
        mov     al,es:[edi].pga_pglock  ;Page lock count
        mov     [si].ge_wcPageLock,ax   ;Save in structure
        mov     al,es:[edi].pga_flags   ;Word of flags
        xor     ah,ah
        mov     [si].ge_wFlags,ax       ;Put in public structure
        mov     eax,es:[edi].pga_next   ;Put next pointer in structure
        mov     [si].ge_dwNext,eax

        ;** If this is a data segment, get local heap information
        mov     ax,[si].ge_hBlock       ;Get the handle
        cCall   Walk386VerifyLocHeap
        mov     [si].ge_wHeapPresent,TRUE ;Flag that there's a heap
        jnc     SHORT W3_10             ;There really is no heap
        mov     [si].ge_wHeapPresent,FALSE ;Flag that there's no heap
W3_10:

        ;** If the owner is a PDB, translate this to the TDB
        mov     bx,[si].ge_hOwner       ;Get the owner
        cCall   HelperHandleToSel, <bx> ;Translate to selector
        mov     bx,ax                   ;Get the selector in BX
        cCall   HelperVerifySeg, <ax,2> ;Must be two bytes long
        or      ax,ax                   ;Is it?
        jz      SHORT W3_15             ;No.
        push    es                      ;Save ES for later
        mov     es,bx                   ;Point to possible PDB block
        cmp     es:[0],20CDh            ;Int 20h is first word of PDB
        jnz     SHORT W3_12             ;Nope, don't mess with this
        mov     ax,bx                   ;Pass parameter in AX
        cCall   HelperPDBtoTDB          ;Get the corresponding TDB
        or      ax,ax                   ;Was one found?
        jz      SHORT W3_11             ;No.
        mov     [si].ge_hOwner,ax       ;Make the owner the TDB instead
W3_11:  or      [si].ge_wFlags,GF_PDB_OWNER ;Flag that a PDB owned block
W3_12:  pop     es                      ;Restore ES
W3_15:

        ;** Check for this being the last item in both lists
        cmp     edi,es:[edi].pga_next   ;See if we're at the end
        jnz     SHORT W3_20             ;No
        mov     [si].ge_dwNext,0        ;NULL the next pointer
W3_20:  mov     eax,edi                 ;Get current pointer
        mov     cx,wFlags               ;Get the flags back
        cCall   NextLRU386              ;Get next LRU list pointer or 0
        mov     [si].ge_dwNextAlt,eax   ;Save it

W3_End:
cEnd


;  Walk386Handle
;
;       Finds an arena pointer given a block handle

cProc   Walk386Handle, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hBlock
cBegin
        mov     ax,hBlock               ;Get the block handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cCall   SelToArena386           ;Get the arena pointer
        jnc     SHORT W3H_10            ;Must be OK
        xor     ax,ax                   ;Return a 0L
        xor     dx,dx
        jmp     SHORT W3H_End           ;Error in conversion, get out
W3H_10: mov     ax,bx                   ;Get the low word
        shr     ebx,16                  ;Get the high word in DX
        mov     dx,bx
W3H_End:
cEnd


;  WalkLoc386Count
;
;       Returns the number of blocks in the given local heap

cProc   WalkLoc386Count, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LC_10             ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LC_End            ;Get out
LC_10:

        ;** Point to the block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the number of blocks
        mov     ax,es:[bx].hi_count     ;Get the count
LC_End:
cEnd


;  WalkLoc386First
;
;       Returns a handle to the first block in the 386 global heap.

cProc   WalkLoc386First, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that the given global block has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LF_10             ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LF_End            ;Get out
LF_10:

        ;** Point to the global block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the first block and return it
        mov     ax,WORD PTR es:[bx].hi_first ;Get the first block
LF_End:
cEnd


;  WalkLoc386
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   WalkLoc386, <PUBLIC,NEAR>, <di,si,ds>
        parmW   wBlock
        parmD   lpLocal
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LW_10             ;It's OK
        jmp     LW_End                  ;Get out
LW_10:

        ;** Get variables from the TOOLHELP DGROUP
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** Point to the heap
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        lds     di,lpLocal              ;Point to the LOCALENTRY structure
        mov     [di].le_wHeapType,NORMAL_HEAP ;In case we don't match below...
        cmp     bx,hHeap                ;User's heap?
        jnz     SHORT W3_3              ;No
        mov     [di].le_wHeapType,USER_HEAP ;Yes
        jmp     SHORT W3_5              ;Skip on
W3_3:   cmp     cx,hHeap                ;GDI's heap?
        jnz     SHORT W3_5              ;No
        mov     [di].le_wHeapType,GDI_HEAP ;Yes
W3_5:
        mov     si,wBlock               ;Get the address of the block

        ;** Get information about the given block
        mov     bx,es:[si].la_handle    ;Get the handle
        mov     [di].le_hHandle,bx      ;Save in the public structure
        mov     ax,si                   ;Get block address
        add     ax,la_fixedsize         ;Skip fixed size local arena
        mov     [di].le_wAddress,ax     ;Save the block address
        mov     ax,es:[si].la_next      ;Get the address of the next block
        mov     [di].le_wNext,ax        ;Save the next pointer
        sub     ax,si                   ;Compute the size
        sub     ax,la_fixedsize         ;Size of fixed arena
        mov     [di].le_wSize,ax        ;Save in public structure
        mov     ax,es:[si].la_prev      ;Get the flags
        and     ax,3                    ;Mask out all but flags
        mov     [di].le_wFlags,ax       ;Save in structure

        ;** Moveable arenas are bigger and have a lock count to get
        test    al,LA_MOVEABLE          ;Block has a handle iff it's moveable
        jz      SHORT LW_NoHandle       ;No handle info
        sub     [di].le_wSize, (SIZE LocalArena) - la_fixedsize
        add     [di].le_wAddress, (SIZE LocalArena) - la_fixedsize
        xor     ah,ah                   ;Clear upper word
        mov     al,es:[bx].lhe_count    ;Get lock count
        mov     [di].le_wcLock,ax       ;Save it
        jmp     SHORT LW_20             ;Skip no handle info
LW_NoHandle:
        mov     ax, [di].le_wAddress    ;Handle of fixed block is real offset
        mov     [di].le_hHandle, ax
        mov     [di].le_wcLock,0        ;No lock count either
LW_20:
        ;** See if it's the end
        cmp     [di].le_wNext,0         ;Check for NULL pointer just in case
        jz      SHORT LW_End            ;It is so get out
        cmp     [di].le_wNext,si        ;Loop pointer?
        jnz     SHORT LW_End            ;Nope
        mov     [di].le_wNext,0         ;Set a zero pointer
LW_End:
cEnd


;  Walk386VerifyLocHeap
;
;       Verifies that the given global block points to a data segment
;       with a local heap.
;
;       Call:
;               AX = Block handle or selector
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

cProc   Walk386VerifyLocHeap, <PUBLIC,NEAR>, <es>
cBegin
        push    esi                     ;Save certain registers
        push    edi

        ;** Convert to a selector
        cCall   HelperHandleToSel, <ax>

        ;** Verify that the selector is long enough
        push    ax                      ;Save parameter
        mov     bx,SIZE LocalInfo
        cCall   HelperVerifySeg, <ax,bx> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     SHORT VLH_SelOK         ;Yes
        stc                             ;Set error flag 
        jmp     SHORT VLH_End           ;Get out
VLH_SelOK:

        ;** Check data segment to see if it has a local heap
        mov     es,ax                   ;Point to the local block with ES
        cCall   HelperSegLen, <ax>      ;Get the length of the heap
        movzx   ecx,dx                  ;ECX gets the length
        shl     ecx,16                  ;Put high word in high word of EAX
        mov     cx,ax                   ;Get the low word
        cmp     ecx,8                   ;At least 8 bytes long?
        ja      SHORT VLH_10            ;Yes
        stc                             ;No -- set error flag and get out
        jmp     SHORT VLH_End
VLH_10: xor     ebx,ebx                 ;Clear high word
        mov     bx,es:[6]               ;Get offset to HeapInfo struct
        or      bx,bx                   ;If NULL, no local heap
        jz      SHORT VLH_NoHeap        ;Get out
        sub     ecx,ebx                 ;See if HeapInfo is beyond segment
        jbe     SHORT VLH_NoHeap
  sub     ecx,li_sig + 2          ;Compare against last structure mem
        jbe     SHORT VLH_NoHeap
  cmp     es:[bx].li_sig,LOCALHEAP_SIG ;Make sure the signature matches
        jne     SHORT VLH_NoHeap        ;Doesn't match
        clc                             ;Must be a heap!
        jmp     SHORT VLH_End

VLH_NoHeap:
        stc                             ;Set error flag

VLH_End:
        pop     edi
        pop     esi
cEnd


;** Private helper functions

;  SelToArena386
;
;       Finds the arena entry for the given selector or handle.
;       Uses the selector table which is located just after the arena table.
;       Since this is a large segment, use 32 bit offsets into it.
;       The selector-to-arena mapping table is simply an array of arena
;       offsets indexed by the (selector number >> 3) * 4 [DWORD offsets].
;
;       Caller:         AX = Selector
;       Returns:        DX:EBX = Arena entry
;       Trashes everything except segment registers and AX
;       Carry set on error

cProc   SelToArena386, <NEAR,PUBLIC>, <es,ds,ax>
cBegin
        ;** Convert to a selector
        cCall   HelperHandleToSel, <ax>

        ;** Verify selector
        push    ax                      ;Save parameter
        cCall   HelperVerifySeg, <ax,1> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     SHORT STA_SelOK         ;Must be
        stc                             ;Nope.  Set error flag and exit
        jmp     SHORT STA_End
STA_SelOK:
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx
        mov     bx,segKernel            ;Get the KERNEL variable segment
        mov     es,bx
        mov     bx,npwSelTableLen       ;Get the pointer
        mov     dx,es:[bx]              ;Get the selector table length
        mov     bx,npdwSelTableStart    ;Get the start of the sel table
        mov     ebx,es:[bx]             ;Get the linear offset (32 bits)
        mov     es,hMaster              ;Point to the arena table
        and     al,not 7                ;Clear the RPL bits for table lookup
        shr     ax,1                    ;Convert to DWORD offset
        cmp     ax,dx                   ;Check to see if off the end of table
        jb      SHORT STA_InTable       ;It's in the table
        stc                             ;Set error flag--not in table
        jmp     SHORT STA_End           ;Get out
STA_InTable:
        movzx   eax,ax                  ;Convert the offset to 32 bits
        add     ebx,eax                 ;Add the selector offset
        mov     ebx,es:[ebx]            ;Do the sel table indirection
        mov     dx,hMaster              ;DX points to the arena segment
        clc                             ;No error; return OK
STA_End:
cEnd


;  NextLRU386
;
;       Checks the given arena table pointer to see if it is the last
;       arena entry on the list.
;       Uses a grungy method that is necessitated because of the
;       unterminated linked lists we're dealing with here.  The count
;       stored is the only reliable method for finding the end.  So, to
;       provide random access to blocks in the heap, the heap is searched
;       from top to bottom to find the block and see if it is the last
;       one.  If it is or if it is not on the given list, returns a 0
;       pointer to the next item.
;
;       If this search is for the entire global heap, we do not get the
;       LRU link, but return NULL in EAX.  This speeds this up alot!
;
;       Caller:         EAX = Arena table pointer
;                       CX = GLOBAL_ALL, GLOBAL_FREE, or GLOBAL_LRU
;       Return:         EAX = Next arena table pointer or 0 if no more
;       Trashes all registers except segment registers and ESI,EDI

cProc   NextLRU386, <NEAR,PUBLIC>, <es,ds>
cBegin
        push    esi
        push    edi

        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx                   ;Point with DS
        mov     es,hMaster              ;Segment of master block
        cmp     cx,GLOBAL_ALL           ;If doing entire heap, don't do this!
        je      SHORT NL_BadList        ;Must not be entire heap
        shr     cx,1                    ;Check for GLOBAL_LRU
        jc      SHORT NL_LRU            ;Bit set, must be LRU
        shr     cx,1                    ;Check for GLOBAL_FREE
        jc      SHORT NL_Free           ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Decide which list the block is in then hand off
        cmp     es:[eax].pga_owner,0    ;If the owner is zero, it's free
        jz      SHORT NL_Free           ;Handle this as if on free list
                                        ;Otherwise, might be on LRU list

        ;** Loop through LRU list until we find this item
NL_LRU:
        mov     cx,es:[gi_lrucount]     ;Get the number of objects
        jcxz    NL_Bad                  ;No object so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_Bad                  ;1 object so return end
        mov     edi,es:[gi_lruchain]    ;Get a pointer to the first item
NL_LRULoop:
        cmp     edi,eax                 ;Match yet?
        jz      SHORT NL_ReturnNext     ;Found it, return next item
        mov     edi,es:[edi].pga_lrunext ;Not found yet, get the next one
        loop    NL_LRULoop              ;Loop through all items
NL_Bad: jmp     SHORT NL_BadList        ;Not here either.  Get out

        ;** Loop through free list until we find this item
NL_Free:
        mov     cx,es:[gi_free_count]   ;Get the number of objects
        jcxz    NL_BadList              ;1 object so return end
        mov     edi,es:[phi_first]      ;Get a pointer to the first item
NL_FreeLoop:
        mov     edi,es:[edi].pga_lrunext ;Not found yet, get the next one
        cmp     edi,eax                 ;Match yet?
        jz      SHORT NL_ReturnNext     ;Found it, return next item
        loop    NL_FreeLoop             ;Loop through all items
        jmp     SHORT NL_BadList        ;Not here either.  Get out

NL_ReturnNext:
        mov     eax,es:[edi].pga_lrunext ;Return the next one
        jmp     SHORT NL_End            ;Get out

NL_BadList:
        xor     eax,eax                 ;Return zero for error

NL_End:
        pop     edi
        pop     esi
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\comdevi.h ===
WORD  FAR PASCAL      inicom(DCB FAR *);
WORD  FAR PASCAL      setcom(DCB FAR *);
void  FAR PASCAL      setque(int, qdb FAR *);
int   FAR PASCAL      reccom(int);
WORD  FAR PASCAL      sndcom(int, int);
WORD  FAR PASCAL      ctx(int, int);
int   FAR PASCAL      trmcom(int);
WORD  FAR PASCAL      stacom(int, COMSTAT FAR *);
LONG  FAR PASCAL      cextfcn(int, int);
WORD  FAR PASCAL      cflush(int, int);
WORD  FAR *FAR PASCAL cevt(int, int);
WORD  FAR PASCAL      cevtGet(int, int);
int   FAR PASCAL      csetbrk(int);
int   FAR PASCAL      cclrbrk(int);
DCB   FAR *FAR PASCAL getdcb(int);
int   FAR PASCAL      CommWriteString(int cid, LPSTR pbuf, int size);
BOOL  FAR PASCAL      EnableNotification(int cid, HWND hwnd,
                                         int recvth, int sendth);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\combcom.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  COMBCOM.H
 *
 *  History:
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16
--*/

/*
 * combcom.h - Common include file for combo boxs. This include file is used
 * in the combo box code, the single line edit control code, listbox code, and
 * static control code.
 */

/* ID numbers (hMenu) for the child controls in the combo box */
#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002

typedef struct tagCBox
  {
    HWND    hwnd;              /* Window for the combo box */
    HWND    hwndParent;        /* Parent of the combo box */
    RECT    comboDownrc;       /* Rectangle used for the "dropped" 
                                  (listbox visible) combo box */
    RECT    editrc;            /* Rectangle for the edit control/static text 
                                  area */
    RECT    buttonrc;          /* Rectangle where the dropdown button is */
    HWND    editHwnd;          /* Edit control window handle */
    HWND    listboxHwnd;       /* List box control window handle */
    WORD    CBoxStyle;         /* Combo box style */
    WORD    OwnerDraw;         /* Owner draw combo box if nonzero. value
				* specifies either fixed or varheight 
				*/
    WORD    fFocus:1;          /* Combo box has focus? */
    WORD    fNoRedraw:1;       /* Stop drawing? */
    WORD    fNoEdit:1;         /* True if editing is not allowed in the edit
				* window.  
				*/
    WORD    fButtonDownClicked:1;/* Was the popdown button just clicked and 
                                  mouse still down? */
    WORD    fButtonInverted:1; /* Is the dropdown button in an inverted state?
				*/
    WORD    fLBoxVisible:1;    /* Is list box visible? (dropped down?) */
    WORD    fKeyboardSelInListBox:1; /*	Is the user keyboarding through the
				      * listbox. So that we don't hide the
				      * listbox on selchanges caused by the
				      * user keyboard through it but we do
				      * hide it if the mouse causes the
				      *	selchange. 
				      */
    WORD    fExtendedUI:1;     /* Are we doing TandyT's UI changes on this
                                * combo box?
				*/
    HANDLE  hFont;             /* Font for the combo box */
    LONG    styleSave;         /* Save the style bits when creating window.
				* Needed because we strip off some bits and
				* pass them on to the listbox or edit box. 
				*/
  } CBOX;

typedef CBOX NEAR *PCBOX;
typedef CBOX FAR  *LPCBOX;

/*
 * For CBOX.cBoxType field, we define the following combo box styles. These
 * numbers are the same as the CBS_ style codes as defined in windows.h.
 */
#define SSIMPLE         1
#define SDROPDOWN       2
#define SDROPDOWNLIST   3

/* Owner draw types */
#define OWNERDRAWFIXED 1
#define OWNERDRAWVAR   2

/*
 * Special styles for static controls, edit controls & listboxes so that we
 * can do combo box specific stuff in their wnd procs.
 */
#define ES_COMBOBOX     0x0200L
#define LBS_COMBOBOX    0x8000L

/* Special internal combo box messages */
#define CBEC_SETCOMBOFOCUS  CB_MSGMAX+1
#define CBEC_KILLCOMBOFOCUS CB_MSGMAX+2


/* Special messages for listboxes so give combo box support */
#define LBCB_CARETON     LB_MSGMAX+1
#define LBCB_CARETOFF    LB_MSGMAX+2

/* Common Procedures */
VOID FAR PASCAL CBUpdateEditWindow(register PCBOX);
VOID FAR PASCAL CBHideListBoxWindow(register PCBOX pcbox, BOOL fNotifyParent);
VOID FAR PASCAL CBShowListBoxWindow(register PCBOX);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\comdev.h ===
/*************************************************************************
**
** Miscelaneous definitions.
*/
typedef unsigned short ushort;
typedef unsigned char uchar;

#ifdef NOCOMM
/*************************************************************************
**
** device control block.
** This block of information defines the functional parameters of the
** communications software and hardware.
**
** Fields in the DCB are defined as follows:
**
**      Id              - Comm device ID, set by the device driver.
**      BaudRate        - Baud rate at which operating.
**      ByteSize        - Number of bits per transmitted/received byte. (4-8)
**                        Received data is also masked off to this size.
**      Parity          - Transmitt/Receive Parity. (0,1,2,3,4) = (None, Odd,
**                        Even, Mark, Space)
**      StopBits        - Number of stop bits. (0,1,2) = (1, 1.5, 2)
**      RlsTimeout      - Amount of time, in milleseconds, to wait for RLSD to
**                        become high. RLSD, Receive Line Signal Detect is also
**                        known as CD, Carrier Detect. RLSD flow control can be
**                        achieved by specifying infinite timeout.
**      CtsTimeout      - Amount of time, in milleseconds, to wait for CTS,
**                        Clear To Send, to become high. CTS flow control can
**                        be achieved by specifying infinite timeout.
**      DsrTimeout      - Amount of time, in milleseconds, to wait for DSR,
**                        Data Set Ready, to become high. DSR flow control can
**                        be acheived by specifying infinite timeout.
**      fBinary         - Binary Mode flag. In non-binary mode, EofChar is
**                        recognized and remembered as end of data.
**      fRtsDisable     - Disable RTS flag. If set, Request To Send is NOT
**                        used, and remains low. Normally, RTS is asserted when
**                        the device is openned, and dropped when closed.
**      fParity         - Enable Parity Checking. Parity errors are not
**                        reported when 0.
**      fOutxCtsFlow    - enable output xon/xoff(hardware)  using cts
**      fOutxDsrFlow    - enable output xon/xoff(hardware)  using dsr
**      fOutX           - Indicates that X-ON/X-OFF flow control is to be used
**                        during transmission. The transmitter will halt if
**                        an X-OFF character is received, and will start again
**                        when an X-ON character is received.
**      fInX            - Indicates that X-ON/X-OFF flow control is to be used
**                        during reception. An X-OFF character will be
**                        transmitted when the receive queue comes within 10
**                        characters of being full, after which an X-ON will be
**                        transmitted when the queue comes with 10 characters
**                        of being empty.
**      fPeChar         - Indicates that characters received with parity errors
**                        are to be replaced with the character specified in
**                        PeChar, below.
**      fNull           - Indicates that received NULL characters are to be
**                        discarded.
**      fChEvt          - Indicates that the reception of EvtChar is to be
**                        flagged as an event by cevt.
**      fDtrFlow        - Indicates that the DTR signal is to be used for
**                        receive flow control. (cextfcn can be used to set and
**                        clear DTR, overriding this definition).
**      fRtsFlow        - Indicates that the RTS signal is to be used for
**                        receive flow control. (cextfcn can be used to set and
**                        clear RTS, overriding this definition).
**      XonChar         - X-ON character for both transmit and receive
**      XoffChar        - X-OFF character for both transmit and receive
**      XonLim          - When the number of characters in the receive queue
**                        drops below this value, then an X-ON character is
**                        sent, if enabled, and DTR is set, if enabled.
**      XoffLim         - When the number of characters in the receive queue
**                        exceeds this value, then an X-OFF character is sent,
**                        if enabled, and DTR is dropped, if enabled.
**      PeChar          - Parity Error replacement character.
**      EvtChar         - Character which triggers an event flag.
**      EofChar         - Character which specifies end of input.
**      TxDelay         - Specifies the minimum amount of time that must pass
**                        between transmission of characters.
**
** Timeouts are in milleseconds. 0 means ignore the signal. 0xffff means
** infinite timeout.
**
*************************************************************************/
typedef struct {
   char     Id;                         /* Internal Device ID               */
   ushort   BaudRate;                   /* Baudrate at which runing         */
   char     ByteSize;                   /* Number of bits/byte, 4-8         */
   char     Parity;                     /* 0,1,2,3,4 = None,Odd,Even,Mark,Sp*/
   char     StopBits;                   /* 0,1,2 = 1, 1.5, 2                */
   ushort   RlsTimeout;                 /* Timeout for RLSD to be set       */
   ushort   CtsTimeout;                 /* Timeout for CTS to be set        */
   ushort   DsrTimeout;                 /* Timeout for DSR to be set        */

   uchar    fBinary: 1;                 /* CTRL-Z as EOF flag               */
   uchar    fRtsDisable:1;              /* Suppress RTS                     */
   uchar    fParity: 1;                 /* Enable parity check              */
   uchar    fOutxCtsFlow: 1;            /* Enable output xon/xoff with cts  */
   uchar    fOutxDsrFlow: 1;            /* Enable output xon/xoff with dsr  */
   uchar    fDummy: 3;

   uchar    fOutX: 1;                   /* Enable output X-ON/X-OFF         */
   uchar    fInX: 1;                    /* Enable input X-ON/X-OFF          */
   uchar    fPeChar: 1;                 /* Enable Parity Err Replacement    */
   uchar    fNull: 1;                   /* Enable Null stripping            */
   uchar    fChEvt: 1;                  /* Enable Rx character event.       */
   uchar    fDtrflow: 1;                /* Enable DTR flow control          */
   uchar    fRtsflow: 1;                /* Enable RTS flow control          */
   uchar    fDummy2: 1;

   char     XonChar;                    /* Tx and Rx X-ON character         */
   char     XoffChar;                   /* Tx and Rx X-OFF character        */
   ushort   XonLim;                     /* Transmit X-ON threshold          */
   ushort   XoffLim;                    /* Transmit X-OFF threshold         */
   char     PeChar;                     /* Parity error replacement char    */
   char     EofChar;                    /* End of Input character           */
   char     EvtChar;                    /* Recieved Event character         */
   ushort   TxDelay;                    /* Amount of time between chars     */
   } DCB;

/*************************************************************************
**
** COMSTAT
** Status record returned by GetCommError
**
*************************************************************************/
typedef struct {
   uchar        fCtsHold: 1;            /* Transmit is on CTS hold      */
   uchar        fDsrHold: 1;            /* Transmit is on DSR hold      */
   uchar        fRlsdHold: 1;           /* Transmit is on RLSD hold     */
   uchar        fXoffHold: 1;           /* Transmit is on X-Off hold    */
   uchar        fXoffSent: 1;           /* Recieve in X-Off or DTR hold */
   uchar        fEof: 1;                /* End of file character found  */
   uchar        fTxim: 1;               /* Character being transmitted  */
   uchar        fPerr:1;                /* Printer error                */  /*081985*/
   ushort       cbInQue;                /* count of characters in Rx Que*/
   ushort       cbOutQue;               /* count of characters in Tx Que*/
   } COMSTAT;

/*************************************************************************
**
** DCB field definitions.
**
*************************************************************************/
#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0               /* Ignore signal                */
#define INFINITE        0xffff          /* Infinite timeout             */

/*************************************************************************
**
** Comm Device Driver Error Bits.
**
*************************************************************************/
#define CE_RXOVER       0x0001          /* Receive Queue overflow       */
#define CE_OVERRUN      0x0002          /* Receive Overrun Error        */
#define CE_RXPARITY     0x0004          /* Receive Parity Error         */
#define CE_FRAME        0x0008          /* Receive Framing error        */
#define CE_CTSTO        0x0020          /* CTS Timeout                  */
#define CE_DSRTO        0x0040          /* DSR Timeout                  */
#define CE_RLSDTO       0x0080          /* RLSD Timeout                 */
#define CE_PTO          0x0100          /* LPTx Timeout                 */  /*081985*/
#define CE_IOE          0x0200          /* LPTx I/O Error               */  /*081985*/
#define CE_DNS          0x0400          /* LPTx Device not selected     */  /*081985*/
#define CE_OOP          0x0800          /* LPTx Out-Of-Paper            */  /*081985*/
#define CE_MODE         0x8000          /* Requested mode unsupported   */

/*************************************************************************
**
** Initialization Error Codes
**
*************************************************************************/
#define IE_BADID        -1              /* Invalid or unsupported id    */
#define IE_OPEN         -2              /* Device Already Open          */
#define IE_NOPEN        -3              /* Device Not Open              */
#define IE_MEMORY       -4              /* Unable to allocate queues    */
#define IE_DEFAULT      -5              /* Error in default parameters  */
#define IE_HARDWARE     -10             /* Hardware Not Present         */
#define IE_BYTESIZE     -11             /* Illegal Byte Size            */
#define IE_BAUDRATE     -12             /* Unsupported BaudRate         */
/*************************************************************************
**
** Event mask definitions. Used by SetCommEventMask and GetCommEventMask
**
** RXCHAR       - Set when any character is received and placed in the input
**                queue.
** RXFLAG       - Set when a particular character, as defined in the dcb, is
**                received and placed in the input queue.
** TXEMPTY      - Set when the last character in the transmit queue is
**                transmitted.
** CTS          - Set when the CTS signal changes state.
** DSR          - Set when the DSR signal changes state.
** RLSD         - Set when the RLSD signal changes state.
** BREAK        - Set when a break is detected on input.
** ERR          - Set when a line status error occurs.
**
*************************************************************************/
#define EV_RXCHAR       0x0001          /* Any Character received       */
#define EV_RXFLAG       0x0002          /* Received certain character   */
#define EV_TXEMPTY      0x0004          /* Transmitt Queue Empty        */
#define EV_CTS          0x0008          /* CTS changed state            */
#define EV_DSR          0x0010          /* DSR changed state            */
#define EV_RLSD         0x0020          /* RLSD changed state           */
#define EV_BREAK        0x0040          /* BREAK received               */
#define EV_ERR          0x0080          /* Line Status Error Occurred   */
#define EV_RING         0x0100          /* Ring signal detected         */
#define EV_PERR         0x0200          /* LPTx error occured           */  /*081985*/

/*************************************************************************
**
** Extended Functions
**
** SETXOFF      - Causes transmit to behave as if an X-OFF character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
** SETXON       - Causes transmit to behave as if an X-ON character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
*************************************************************************/
#define SETXOFF         1               /* Set X-Off for output control */
#define SETXON          2               /* Set X-ON for output control  */
#define SETRTS          3               /* Set RTS high                 */
#define CLRRTS          4               /* Set RTS low                  */
#define SETDTR          5               /* Set DTR high                 */
#define CLRDTR          6               /* Set DTR low                  */
#define RESETDEV        7               /* Reset device if possible     */  /*081985*/
#endif


/* Escapes for comm */
#define GETMAXLPT	    8	    /* Max supported LPT id	    */
#define GETMAXCOM	    9	    /* Max supported COM id	    */
#define GETBASEIRQ	   10	    /* Get port base & irq for a port */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\comdev.c ===
/****************************************************************************/
/*                                      */
/*  COMDEV.C -                                  */
/*                                      */
/*  Windows Communication Routines                      */
/*                                      */
/****************************************************************************/

/*************************************************************************
**
** Windows Communication Layer
**
** This is the library interface layer for the Communications Device Driver.
** The driver presents an interface between windows based applications and the
** communications hardware.
**
**  /-----------------------------\
**     /     Windows           \
**     \      Application Program      /
**  \-----------------------------/
**  |      Windows Interface      |
**  +-----------------------------+
**  | OEM Dependant LowLevel Code |
**  /-----------------------------\
**     /    Machine Layer          \
**     \   Communications Hardware     /
**  \-----------------------------/
**
*************************************************************************/
#define USECOMM
#include "user.h"
#include "comdev.h"         /* Device driver structure defs */
#include "comdevi.h"            /* Device driver internal defs  */

HANDLE FAR GlobalDOSAlloc(LONG h);
void FAR GlobalDOSFree(HANDLE h);

#define length(string)       lstrlen((char FAR *)string)
#define UPPERCASE(x)         MyToUpper(x)


LPSTR NEAR PASCAL field(LPSTR, LPSTR);
short     getid(LPSTR);
char  FAR *GetMem(WORD);
cinfo *cinfoPtr(int);
void      FreeMem(LPSTR);
char  _fastcall NEAR MyToUpper(char);

/* Array of information for each communications device that we support. */
cinfo rgcinfo[DEVMAX] = {0};        /* Device additional info table */

/* Strings used for determining device characteristics. */

static char CODESEG COMbuf[] = "COM1:9600,E,7,1";
static char CODESEG LPTbuf[] = "LPT1";
static char CODESEG AUXbuf[] = "AUX1";      /* AUX will map to COM1     */
static char CODESEG PRNbuf[] = "PRN1";      /* PRN will map to LPT1     */
#define CONFIGINDEX 5           /* Index to 9600,... in COMbuf  */

/*************************************************************************
** OpenComm - open a communication device
**
** Synopsis:
**  short OpenComm(pszComName, cbInQue, cbOutQue)
**  FAR char    *pszComName;
**  ushort  cbInQue;
**  ushort  cbOutQue;
**
** Description:
**  OpenComm opens a comunication device an associates a com handle with it. The
**  communication device is initialized to a default configuration. The csetcom
**  function call, below, should be used to initialized the device to alternate
**  values.
**
**  OpenComm returns an id which is used in subsequent calls to reference the
**  communication device, or a negative error initialization error code.
**
**  pszComName points to a string which contains "COMn" where "n" is allowed to
**  range from 1 to the number of COMM devices supported by the OEM. cbInQue
**  and cbOutQue reflect the receive and transmit queue sizes, respectively.
**  These queues are allocated at open time, deallocated at close time, and are
**  used by the interrupt driven transmit/receive software.
**
**  pszComName may also point to a string which contains "LPTn" where "n" is
**  allowed to range from 1 to the number of LPT devices supported by the OEM.
**  cbInQue and cbOutQue are ignored for LPT devices.  LPT devices are not
**  interrupt driven.
**
*************************************************************************/

int API IOpenComm(LPSTR pszComName, WORD cbInQue, WORD cbOutQue)

{
  short   cidCur;             /* ID of device         */
  DCB     dcbNew;             /* Temp DCB             */
  short   ierr;               /* Return code from inicom      */
  register cinfo  *pcinfo;        /* pointer to information block */
  register qdb    *pqdbNew;       /* pointer to queue information */


  if ((cidCur = getid(pszComName)) == -1) /* if not recognized, return    */
      return(IE_BADID);           /*   error to caller        */
  pcinfo = cinfoPtr(cidCur);          /* form pointer to info block   */

  if (pcinfo->fOpen)              /* if device already open   */
      return(IE_OPEN);            /*    return error to caller    */

  if (pcinfo->fReservedHardware)    
      /* if device locked for some reason return error to caller ex locked for
       * use by mouse.
       */
      return(IE_HARDWARE);

  /* do nothing if device is LPTn. */
  if (!(cidCur & LPTx))         
    {
      if( (cbInQue == 0) && (cbOutQue == 0) ) /* if Queue length's zero,      */
      return(IE_MEMORY);              /* return memory error right away, */
                      /* so a buildDCB isn't done...
                         this is a common method of
                         finding if the comm port is
                         already opened or not...
                         wanted to make it fast */


      if (lstrlen(pszComName) < 4 || BuildCommDCB(pszComName, &dcbNew) == -1)
        {
          if (BuildCommDCB(COMbuf, &dcbNew) == -1)
          return(IE_DEFAULT);
        }

      pqdbNew = &pcinfo->qdbCur;      /* form pointer to qdb      */
      if ((pqdbNew->pqRx = GetMem(cbInQue)) == (char FAR *)NULL)
      return(IE_MEMORY);         /* no room for Rx queue     */

      if ((pqdbNew->pqTx = GetMem(cbOutQue)) == (char FAR *)NULL)
    {
      FreeMem(pqdbNew->pqRx);     /* no room for Tx queue     */
     return(IE_MEMORY);
    }

      pqdbNew->cbqRx = cbInQue;
      pqdbNew->cbqTx = cbOutQue;
      setque(cidCur,(qdb FAR *)pqdbNew);  /* init the queue's as well     */
    }

  dcbNew.Id = (char)cidCur;       /* set device ID in dcb     */
  ierr = inicom((DCB FAR *)&dcbNew);      /* attempt to init          */
  if (ierr)
    {
      if (!(cidCur & LPTx))       /* if a comm device         */
    {
      FreeMem(pqdbNew->pqRx);     /* free Tx queue        */
      FreeMem(pqdbNew->pqTx);     /* free Rx queue        */
    }

      return(ierr);          /* return error code        */
    }

  pcinfo->fOpen = TRUE;           /* indicate device open     */
  pcinfo->hTask = GetCurrentTask();
  return(cidCur);            /* all's well, return dev id    */
}

#ifdef DISABLE
int FAR PASCAL OpenCommFromDCB(LPDCB pdcb, WORD cbInQue, WORD cbOutQue)

{
  short   cidCur;             /* ID of device         */
  short   ierr;               /* Return code from inicom      */
  register cinfo  *pcinfo;        /* pointer to information block */
  register qdb    *pqdbNew;       /* pointer to queue information */


  cidCur = (WORD)pdcb->Id & 0x00FF;

  if ((cidCur & LPTxMask) > ((cidCur & LPTx) ? (PIOMAX - 1) : (CDEVMAX - 1)))
      return(IE_BADID);           /* check cid for validity  */

  pcinfo = cinfoPtr(cidCur);          /* form pointer to info block   */

  if (pcinfo->fOpen)              /* if device already open   */
      return(IE_OPEN);            /*    return error to caller    */

  if (!(cidCur & LPTx))           /* device is LPTn       */
    {
      if( (cbInQue == 0) && (cbOutQue == 0) ) /* if Queue length's zero,      */
      return(IE_MEMORY);              /* return memory error right away, */
                      /* so a buildDCB isn't done...  this
                       * is a common method of finding if
                       * the comm port is already opened
                       * or not...  wanted to make it fast
                       */

      pqdbNew = &pcinfo->qdbCur;      /* form pointer to qdb      */
      if ((pqdbNew->pqRx = GetMem(cbInQue)) == (char FAR *)NULL)
      return(IE_MEMORY);         /* no room for Rx queue     */

      if ((pqdbNew->pqTx = GetMem(cbOutQue)) == (char FAR *)NULL)
    {
      FreeMem(pqdbNew->pqRx);     /* no room for Tx queue     */
      return(IE_MEMORY);
    }

      pqdbNew->cbqRx = cbInQue;
      pqdbNew->cbqTx = cbOutQue;
      setque(cidCur,(qdb FAR *)pqdbNew);  /* init the queue's as well     */
    }

  ierr = inicom(pdcb);                    /* attempt to init          */
  if (ierr)
    {
      if (!(cidCur & LPTx))       /* if a comm device         */
    {
      FreeMem(pqdbNew->pqRx);     /* free Tx queue        */
      FreeMem(pqdbNew->pqTx);     /* free Rx queue        */
    }

      return(ierr);          /* return error code        */
    }

  pcinfo->fOpen = TRUE;           /* indicate device open     */
  pcinfo->hTask = GetCurrentTask();
  return(cidCur);            /* all's well, return dev id    */
}
#endif


/*************************************************************************
** SetCommState - set communciation device configuration
**
** Synopsis:
**  int SetCommState(pdcb)
**  LPDCB pdcb;
**
** Description:
**  pdcb points to an initialized Device Control Block for a device which
**  has been openned. The referenced device, as defined by the dcb's id field,
**  is set to the state as defined by the dcb. SetCommState returns 0 on
**  success, or a negative initialization error code if an error occurred. Note
**  that this will reinitialize all hardware and control as defined in the dcb,
**  but will not empty transmit or receive queues.
**
*************************************************************************/

int API ISetCommState(LPDCB pdcb)
{
  if (cinfoPtr(pdcb->Id)->fOpen == 0)
      return(IE_NOPEN);          /* File must be open first  */

  return(setcom(pdcb));
}



/*************************************************************************
** GetCommState - return current dcb values
**
** Synopsis:
**  int GetCommState(cid,pdcb)
**  WORD    cid;
**  LPDCB   *pdcb;
**
** Description:
**  The dcb pointed to by pdcb is updated to reflect the current dcb in use
**  for the device referenced by cid. Returns 0 on success, -1 on illegal
**  handle or IE_OPEN if port has not been opened yet.
**
*************************************************************************/

int API IGetCommState(register int cid, LPDCB pdcb)

{
  LPDCB    pdcbSrc;
  register int     i;

  if (cinfoPtr(cid)->fOpen == 0)     /* File must be open first  */
      return(IE_NOPEN);

  if ( (pdcbSrc = getdcb(cid)) )     /* pointer to dcb for device    */
    {
      i = sizeof(DCB);
      while (i--)
      *((char FAR *)pdcb)++ = *((char FAR *)pdcbSrc)++;

      return(0);
    }
  else
      return(-1);
}


/*************************************************************************
** ReadComm - read characters from communication device
**
** Synopsis:
**  int ReadComm(cid, pbuf, size)
**  WORD    cid;
**  LPSTR   *pbuf;
**  int     size;
**
** Description:
**  ReadComm reads size characters into pbuf and returns the number of characters
**  actually read. If the return value equals size bytes there may exist
**  additional characters to read. The return count will be less if the number
**  of characters present in the receive queue is less. If the return value is
**  0 then no characters were present.
**
**  If the return value is negative, then an error was also detected, and an
**  error code can be retrieved from GetCommError. The absolute value of the return
**  value is the number of characters read. Note that this implies that if
**  there are no characters to be read, then no error status can be returned,
**  and GetCommError should be used to read the status.
**
*************************************************************************/

int API IReadComm(int cid, LPSTR pbuf, int size)

{
  register int cbT;
  int     ch;

  cid &= 0xff;                /* get "pure" device ID     */
  if (size == 0)              /* Empty read */
      return(0);
  if ((cid & LPTxMask) > ((cid & LPTx) ? (PIOMAX - 1) : (CDEVMAX - 1)))
      return(0);             /* check cid for validity   */

  if (cinfoPtr(cid)->fOpen == 0)
      return(0);             /* can't assume valid dcb...    */

  cbT = 0;
  if (cinfoPtr(cid)->fchUnget)        /* if there's a backed-up char  */
    {
      cinfoPtr(cid)->fchUnget = FALSE;    /* return backed up char    */
      *pbuf++ = cinfoPtr(cid)->chUnget;   /*   and update transfer count  */
      cbT++;
    }
                      /*note. reccom returns -2 if no */
                      /*data available, - 1 if error  */
  ch = 0;

  if (SELECTOROF(lpCommReadString) == NULL)
    {
      while (cbT < size)              /* up to size characters    */
    {
      if ((ch = reccom(cid)) < 0)     /* stop when no char available  */
          break;              /*   or error           */
      *pbuf++ = (char)ch;         /* place character in users buf */
      cbT++;                  /* and update transfer count    */
    }
    }
  else
    {
       ch = 0;
       cbT = lpCommReadString(cid, pbuf, size);
    }

  return(ch == -1 ? -cbT : cbT);
}


/*************************************************************************
** UngetCommChar - push a character back onto receive queue.
**
** Synopsis:
**  int UngetCommChar(cid,ch)
**  WORD    cid;
**  char    ch;
**
** Description:
**  Allows an application to "back-up" one character in the receive character
**  stream by placing a character back into the receive stream. This character
**  is then the first character returned by the next call to ReadComm. UngetCommChar may
**  only be called once between calls to ReadComm. Returns 0 on success, -1 if
**  illegal id, or unable to back-up.
**
*************************************************************************/

int API IUngetCommChar(int cid, char ch)

{
  cid &= 0xFF;                /* get "pure" device ID     */
  if ((cid & LPTxMask) > ((cid & LPTx) ? (PIOMAX - 1) : (CDEVMAX - 1)))
      return(0);             /* check cid for validity   */

  if (cinfoPtr(cid)->fchUnget)           /* have we already backed up 1 */
      return(-1);

  if (cinfoPtr(cid)->fOpen == 0)         /* can't assume valid dcb...     */
      return(-1);

  cinfoPtr(cid)->fchUnget = TRUE;     /* set flag indicating backed-up*/
  cinfoPtr(cid)->chUnget = ch;        /* and save the character   */

  return(0);
}


/*************************************************************************
** WriteComm - write characters to communication device
**
** Synopsis:
**  int WriteComm(cid, pbuf, size)
**  int     cid;
**  LPSTR   *pbuf;
**  int     size;
**
** Description:
**  WriteComm will write size character to the communication device. The byte
**  count written is returned on success, negative byte count on error. GetCommError
**  can be used to retrieve any error code.
**
*************************************************************************/

int API IWriteComm(int cid, LPSTR pbuf, int size)

{
  int cbT;

  cid &= 0xFF;                /* get "pure" device ID     */

  if ((cid & LPTxMask) > ((cid & LPTx) ? (PIOMAX - 1) : (CDEVMAX - 1)))
      return(0);             /* check cid for validity   */
                      /*return zero if not valid      */
  if (cinfoPtr(cid)->fOpen == 0)      /* verify port has been opened  */
      return(-1);

  cbT = 0;

  if (SELECTOROF(lpCommWriteString) == NULL)
    {
      while (size--)
        {
           if (sndcom(cid,*pbuf++))       /* transmit character       */
           return(-cbT);              /* return if error          */

           cbT++;
        }
    }
  else
    {
      cbT = lpCommWriteString(cid, pbuf, size);
      if (cbT < size)
        {
          /* For consistency, if we couldn't transmit all the characters we
       * were asked to, return the negative of the number actually
       * transmitted.
       */
          cbT = -cbT;
        }
    }

  return(cbT);
}


/*************************************************************************
** CloseComm - close communication device
**
** Synopsis:
**  int CloseComm(cid)
**  ushort cid;
**
** Description:
**  closes the communication device and dealloctes any buffers. Returns 0 on
**  success, -1 on error.
**
*************************************************************************/

int API ICloseComm(int cid)

{
  register cinfo *pcinfo;
  WORD       retval;

  cid &= 0xFF;                /* get "pure" device ID     */
  if ((cid & LPTxMask) > ((cid & LPTx) ? (PIOMAX - 1) : (CDEVMAX - 1)))
      return(-1);             /* return error, cid not valid  */

  if ((pcinfo = cinfoPtr(cid))->fOpen==0) /* verify port opened    ...    */
      return(-1);             /* return error, port not open  */

  retval = trmcom(cid);           /* terminate the device     */
  if (retval == 0x8000)           /* if invalid ID        */
      return(-1);             /* return error code        */

  pcinfo->fOpen = FALSE;          /* indicate not open        */

  if (!(cid & LPTx))
    {
      FreeMem(pcinfo->qdbCur.pqRx);   /* Free Rx buffer       */
      FreeMem(pcinfo->qdbCur.pqTx);   /* Free Rx buffer       */
    }

  return(retval);             /* 0 if OK, -2 if queue trashed */
}


/*************************************************************************
** GetCommError - return device status
**
** Synopsis:
**  short GetCommError(cid,pstat)
**  ushort  cid;
**  stat FAR *pstat;
**
** Description:
**  GetCommError returns the most recent error code for the referenced device, or -1
**  for an illegal handle. In addition, if pstat is non-zero, GetCommError also
**  updates the status record it points to.
**
*************************************************************************/

int API IGetCommError(int cid, COMSTAT FAR *pstat)

{
  register WORD st;

  cid &= 0xFF;
  st = stacom(cid,pstat);
  if ((st != 0x8000) && pstat && (cinfoPtr(cid)->fchUnget))
      pstat->cbInQue++;

  return(st);
}


void FAR PASCAL SP_GPFaultCommCleanup(HANDLE hTask)
/* effects: When the given task gp faults, we check if it had any comm ports
 * opened and we close them.
 */
{
  register int i;

  for (i=0; i<DEVMAX; i++)        /* check all devices        */
      if (rgcinfo[i].fOpen && rgcinfo[i].hTask == hTask)
                                      /* if device is open        */
      CloseComm(i);           /* close it             */
}



/*************************************************************************
** BuildCommDCB  -  Parse a string into a dcb.
**
** Synopsis:
**  short BuildCommDCB(pszDef,pdcb)
**  char FAR *pszDef;
**  DCB FAR  *pdcb;
**
** Description:
**  Parses a passed string and fills appropriate fields in a dcb, the address
**  off which is also passed. The string conforms to that of a DOS MODE
**  command for COMn. For example: "COM1:9600,N,7,1". Returns 0 on success,
**  -1 on error.
**
*************************************************************************/

int API IBuildCommDCB(LPSTR pszDef, LPDCB pdcb)

{
  register int i;
  register int tempid;
  char     c;
  char     szT[80];           /* buffer in which to put things*/


  LFillStruct((LPSTR)pdcb, sizeof(DCB), 0);/* zero the dcb since probably on
                                            * app's stack
                        */

  pszDef = field(pszDef,(char FAR *)szT); /* Get first token          */
  if ((tempid=getid((char FAR *)szT))==-1)/* Get ID of device         */
      return(-1);             /* Unknown device       */

  pdcb->Id = (char)tempid;        /* we have a device id      */


  if (tempid & LPTx)              /* if a LPTx port, then let the */
      return(0);                      /*   rest default to whatever   */


  pszDef = field(pszDef,(char FAR *)szT); /* next field           */
  if (length(szT) < 2)
      return(-1);             /* must be at least two chars   */


  i = (szT[0] << 8) | szT[1];         /* cheap and sleazy mapping     */
  switch (i)                  /* based on first 2 chars   */
    {
      case 0x3131:
      i = 110;
      break;

      case 0x3135:
      i = 150;
      break;

      case 0x3330:
      i = 300;
      break;

      case 0x3630:
      i = 600;
      break;

      case 0x3132:
      i = 1200;
      break;

      case 0x3234:
      i = 2400;
      break;

      case 0x3438:
      i = 4800;
      break;

      case 0x3936:
      i = 9600;
      break;

      case 0x3139:
      i = 19200;
      break;

      case 0x3338:		/* handle 38400 baud  in BuildCommDCB() */
      i = 38400;
      break;

      default:
          return(-1);
    }

  pdcb->BaudRate = i;
  pdcb->XonLim   = 10;            /* Set these up always. */
  pdcb->XoffLim  = 10;            /* Set these up always. */
  pdcb->fBinary  = 1;             /* Set these up always. */
  pdcb->XonChar  = 0x11;                  /* Ctrl-Q */
  pdcb->XoffChar = 0x13;                  /* Ctrl-S */

  if ((pszDef = field(pszDef,(char FAR *)szT)) == 0)
      return(0);

  switch (szT[0])
    {
      case 0:
      case 'E':
      c = EVENPARITY;
      break;

      case 'O':
      c = ODDPARITY;
      break;

      case 'N':
      c = NOPARITY;
      break;

      case 'M':
          c = MARKPARITY;
          break;

      case 'S':
          c = SPACEPARITY;
          break;

      default:
      return(-1);
    }
  pdcb->Parity = c;

  if ((pszDef = field(pszDef,(char FAR *)szT)) == 0)
      return(0);

  switch (szT[0])
    {
      case 0:
      case '7':
      c = 7;
      break;

      case '8':
      c = 8;
      break;

      default:
      return(-1);
    }
  pdcb->ByteSize = c;

  if ((pszDef = field(pszDef,(char FAR *)szT)) == 0)
      return(0);

  switch (szT[0])
    {
      case 0:
      if (pdcb->BaudRate == 110)
        {
          c = TWOSTOPBITS;
          break;
        }
      /*** FALL THRU ***/

      case '1':
      c = ONESTOPBIT;
      break;

      case '2':
      c = TWOSTOPBITS;
      break;

      default:
      return(-1);
    }
  pdcb->StopBits = c;

  if ((pszDef = field(pszDef,(char FAR *)szT)) == 0)
      return(0);

  if (szT[0] != 'P')
      return(-1);

  pdcb->RlsTimeout = INFINITE;
  pdcb->CtsTimeout = INFINITE;
  pdcb->DsrTimeout = INFINITE;

  return(0);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  field() -                                   */
/*                                      */
/*--------------------------------------------------------------------------*/

LPSTR NEAR PASCAL field(LPSTR pszSrc, LPSTR lpszDst)
{
  register char   c;

  if (!(pszSrc))
      return(char FAR *)0;

  if (!(*pszSrc))
      return(char FAR *)0;

  /* While not the end of the string. */
  while (c = *pszSrc)
    {
      pszSrc++;

      /* Look for end of string. */
      if ((c == ' ') || (c == ':') || (c == ','))
    {
      *lpszDst = 0;

      while (*pszSrc == ' ')
          pszSrc++;

      if (*pszSrc)
          return(pszSrc);

      return(char FAR *)0;
    }

      *lpszDst++ = UPPERCASE(c);
    }

  *lpszDst = 0;

  return(pszSrc);
}


/*************************************************************************
**
** U T I L I T Y   R O U T I N E S
**
**************************************************************************
**
** getid
** Given a (far) pointer to a string, returns the comm ID of that device,
** or -1 indicating error. This routine accepts all device references of
** the form "COMn", where n is any number from 0 to 9, or "LPTn" where
** n is any number from 1 to 9
**
*************************************************************************/

short getid(LPSTR pszComName)

{
  int       id;
  register int  base;
  ushort    isLPTorCOM;
  LPSTR         pszName;

#ifdef JAPAN
  /* Brought from WIN2 */
  /* ------------- support 'oemgetid' (Jul,29,1987 SatoN) ----------- */
  typedef int (far *FARPROC)();

  extern  void    far     int3();
  static FARPROC lpOEMgetid = (FARPROC)(-1L);

  /* If lpOEMgetid has not been initialized yet, initialize it.
     This assumes 'GetProcAddress' does not cause FatalExit. */
  if (lpOEMgetid==(FARPROC)(-1L))
      {
      unsigned hComm;
      if ((hComm = GetModuleHandle( (char far *)"COMM" ))==NULL)
      lpOEMgetid = NULL;
      else
      lpOEMgetid = GetProcAddress( hComm,(char far *)"oemgetid" );
      }

    /* If COMM driver has the routine 'oemgetid', then call it. */
    if (lpOEMgetid && (id=(*lpOEMgetid)(pszComName))!=-1)
    return id;
    /* ------------- end of support 'oemgetid' ---------------------- */
#endif /* JAPAN */

  isLPTorCOM = TRUE;              /* assume LPTx or COMx      */
  base = 0;               /* assume serial        */
  id = 0;                 /* assume LPT1 or COM1 9/25/86 */

  switch (UPPERCASE(*pszComName))
    {
      case 'A':               /* AUX  possibility         */
      pszName = AUXbuf;       /* Search string to match   */
      isLPTorCOM = FALSE;         /* Show AUX or PRN          */
      break;

      case 'C':               /* COMx possibility         */
      pszName = COMbuf;       /* Search string to match   */
      break;              /* cid base             */

      case 'L':               /* LPTx possibility         */
      pszName = LPTbuf;       /* Search string to match   */
      base = LPTx;            /* cid base             */
      break;

      case 'P':               /* PRN  possibility         */
      pszName = PRNbuf;       /* Search string to match   */
      base = LPTx;            /* cid base             */
      isLPTorCOM = FALSE;         /* Show AUX or PRN          */
      break;

      default:
      return(-1);
    }

  while(*pszName != '1')          /* make sure strings match  */
    {
      if (*pszName++ != UPPERCASE(*pszComName++))
      return(-1);
    }

  if (isLPTorCOM ||           /* then get device number   */
      (*pszComName && *pszComName != ':'))/* accept PRN or AUX        */
      id = (*pszComName++) - '1';

  if (*pszComName == ':')         /* skip ':' if present      */
      pszComName++;

  if ((id < 0) || (*pszComName != '\0'))
      return(-1);

  if (id > (base ? (PIOMAX - 1) : (CDEVMAX - 1)))
       return(-1);

  return(base + id);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  cinfoPtr() -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

cinfo *cinfoPtr(int cid)

{
  if (cid & LPTx)
      return(&rgcinfo[((cid & LPTxMask)+CDEVMAX)]);

  return(&rgcinfo[(cid & 0xFF)]);
}


/*************************************************************************
**
** GetMem
** Uses windows memory allocator to get far, global memory. We fudge here,
** in that GlobalAlloc returns a handle, which happens to be the segment
** of the fixed memory we've asked for. Hence we need to fudge it to get
** an address.
**
*************************************************************************/

LPSTR GetMem(WORD size)

{
  /* See if the 286 DOS extender is installed, and if so, we must allocate
     memory from conventional memory, so the queue can be used in both
     protect and real modes (segment/selector ablility)
  */

  if( (WinFlags & (WF_PMODE|WF_WIN286)) == (WF_PMODE|WF_WIN286) )
    {
      return(MAKELP(GlobalDOSAlloc((LONG)size), NULL));
    }
  else
    {
      return(MAKELP(GlobalAlloc(
        GMEM_LOWER | GMEM_SHARE | GMEM_ZEROINIT | GMEM_FIXED,
        (LONG)size), NULL));
    }
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  FreeMem() -                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

void FreeMem(LPSTR pMem)

{
  /* See if the 286 DOS extender is installed, and if so, we must deallocate
     memory from conventional memory, so the queue can be used in both
     protect and real modes (segment/selector ablility)
  */

  if( (WinFlags & (WF_PMODE|WF_WIN286)) == (WF_PMODE|WF_WIN286) )
    {
      GlobalDOSFree((HANDLE)(((LONG)pMem) >> 16));
    }
  else
    {
      GlobalFree((HANDLE)(((LONG)pMem) >> 16));
    }
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  TransmitCommChar() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

int API ITransmitCommChar(int cid, char character)

{
  cid &= 0xFF;
  return(ctx(cid, character));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SetCommEventMask() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD FAR * API ISetCommEventMask(int cid, WORD evtmask)

{
  cid &= 0xFF;
  return(cevt(cid, evtmask));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetCommEventMask() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD API IGetCommEventMask(int cid, int evtmask)

{
  cid &= 0xFF;
  return(cevtGet(cid, evtmask));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SetCommBreak() -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

int API ISetCommBreak(int cid)

{
  cid &= 0xFF;
  return(csetbrk(cid));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  ClearCommBreak() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

int API IClearCommBreak(int cid)

{
  cid &= 0xFF;
  return(cclrbrk(cid));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  FlushComm() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Parameters:
 *   ushort cid   -- 0=com1  1=com2
 *   ushort queue -- 0 = clear transmit 1 = receive
 */

int API IFlushComm(int cid, int queue)

{
  cid &= 0xFF;
  return(cflush(cid, queue));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  EscapeCommFunction() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

LONG API IEscapeCommFunction(int cid, int fcn)
{
  LONG ret;

  cid &= 0xFF;

  ret = cextfcn(cid, fcn);

  if (SELECTOROF(lpCommWriteString) == NULL)
    {
#if 0
      if (fcn == GETMAXBAUD)
          /* For 3.0 drivers, fake the maxbaud rate escape.
       */
          ret = (LONG)CBR_19200;
      else
#endif
      if (fcn == GETMAXLPT)
          ret = (LONG)LPTx+2; /* 3 lpt ports */
      else
      if (fcn == GETMAXCOM)
          ret = (LONG)9;
      else
      if ((WORD)fcn <= RESETDEV)
          /* New for 3.1, we need to return a long from this function. So fix
       * things up for old 3.0 drivers who used the defined escape range
       * (we had 7 escapes for 3.0 drivers).
       */
          ret = (LONG)(int)(LOWORD(ret));
    }

  return(ret);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  EnableCommNotification() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/
BOOL API IEnableCommNotification(int cid,    HWND hwnd,
                                      int recvth, int sendth)
{
  cid &= 0xFF;

  if (SELECTOROF(lpCommEnableNotification) == NULL)
      return(FALSE);

  return(lpCommEnableNotification(cid, hwnd, recvth, sendth));
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  MyToUpper() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

char _fastcall NEAR MyToUpper(char c)
{
  return((c < (char)'a') ? c : c - (char)32);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LW_DriversInit() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

void LW_DriversInit(void)

{
  HMODULE     hModule;
  char        szString[128];

  /*------------------------------------------------------------------------*/
  /*    Comm Initialization                         */
  /*------------------------------------------------------------------------*/
  /* Find out if the poor user is running with a 3.0 comm driver. Do this by
   * checking for the 3.1 function WriteCommString.  Also, save off the
   * addresses of these functions so we don't rip had we imported them
   * directly.
   */
  LoadString(hInstanceWin, STR_COMMMODULENAME, szString, sizeof(szString));
  hModule = GetModuleHandle(szString);
  LoadString(hInstanceWin, STR_COMMWRITESTRING, szString, sizeof(szString));
  (FARPROC)lpCommWriteString = GetProcAddress((HINSTANCE)hModule, szString);
  LoadString(hInstanceWin, STR_COMMREADSTRING, szString, sizeof(szString));
  (FARPROC)lpCommReadString = GetProcAddress((HINSTANCE)hModule, szString);
  LoadString(hInstanceWin, STR_COMMENABLENOTIFICATION, szString, sizeof(szString));
  (FARPROC)lpCommEnableNotification = GetProcAddress((HINSTANCE)hModule, szString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\debug.c ===
/*++
 *
 *  WOW v3.5
 *
 *  Copyright (c) 1980-1994, Microsoft Corporation
 *
 *  DEBUG.C
 *  USER16 debug support
 *
 *  History:
 *
 *  Created 18-Aug-94 by Dave Hart (davehart)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
 *  At this time, all we want is GetSystemDebugState.
--*/

/* Debug api support */
#include "user.h"
#ifndef WOW
#include "menu.h"

typedef struct tagMSGR
  {
    LPARAM	lParam;
    WPARAM	wParam;
    WORD	message;
    HWND	hwnd;
  } MSGR;
typedef MSGR FAR *LPMSGR;


/* A debug hook gets called by Windows just before calling any other type of
 * hook. Let us call the hook which is about to be called as "App hook"; Debug
 * hook is provided with all the details of the App hook so that it can decide
 * whether to prevent Windows from calling the App hook or not; If the debug
 * hook wants Windows to skip the call to the App hook, it must return TRUE;
 * Otherwise, it must call the DefHookProc.  
 */

/*  Debug Hooks recieve three params just like anyother type of hook:

   iCode  =  Hook Code (must be HC_ACTION in the current implementaion).
   wParam =  hook type of the App hook, which is about to be called by 
             Windows.
   lParam =  a FAR pointer to DEBUGHOOKSTRUCT structure which contains all
	       the details about the App hook;
 */


/* Our helper call which returns a pointer to the senders message queue. 
 */
LPMSGR FAR PASCAL QuerySendMessageReversed(void);



BOOL API QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg)
{
  LPMSGR lpmsgr;

  if (h1 || h2 || h3)
      return(FALSE);

  if (!InSendMessage())
      return(FALSE);

  /* Get the inter task sendmessage we are servicing out of the apps queue. 
   */
  lpmsgr = QuerySendMessageReversed();

  lpmsg->hwnd    = lpmsgr->hwnd;
  lpmsg->message = lpmsgr->message;
  lpmsg->wParam  = lpmsgr->wParam;
  lpmsg->lParam  = lpmsgr->lParam;

  return(TRUE);
}

typedef struct
{
  BOOL       fOldHardwareInputState;
  BOOL       fMessageBox;
  BOOL       fDialog;

  BOOL       fMenu;
  BOOL       fInsideMenuLoop;
  PPOPUPMENU pGlobalPopupMenu;

  RECT       rcClipCursor;

  HWND       hwndFocus;
  HWND       hwndActive;
  HWND       hwndSysModal;
  HWND       hwndCapture;
} SAVESTATESTRUCT;
typedef SAVESTATESTRUCT NEAR *PSAVESTATESTRUCT;
typedef SAVESTATESTRUCT FAR  *LPSAVESTATESTRUCT;

static PSAVESTATESTRUCT pLockInputSaveState=NULL;

BOOL API LockInput(HANDLE h1, HWND hwndInput, BOOL fLock)
{
  if (h1)
      return(FALSE);

  if (fLock)
    {
      if (pLockInputSaveState)
        {
          /* Save state struct currently in use. 
	   */
          DebugErr(DBF_ERROR, "LockInput() called when already locked");
          return(NULL);
        }

      if (!hwndInput || hwndInput != GetTopLevelWindow(hwndInput))
          return(FALSE);

      pLockInputSaveState=(PSAVESTATESTRUCT)UserLocalAlloc(ST_LOCKINPUTSTATE,
                                            LPTR, 
                                            sizeof(SAVESTATESTRUCT));

      if (!pLockInputSaveState)
          /* No memory, can't lock. 
	   */
          return(FALSE);

      if (hwndInput)
          ChangeToCurrentTask(hwndInput, hwndDesktop);

      LockMyTask(TRUE);

      /* Set global which tells us a task is locked. Needs to be set after
       * calling LockMyTask...
       */
      hTaskLockInput = GetCurrentTask();

      /* For DBCS, save are we in a dlg box global. */
      pLockInputSaveState->fDialog     = fDialog;

      /* Save menu state and clear it so that the debugger can bring up menus
       * if needed.  
       */
      pLockInputSaveState->fMenu           = fMenu;
      pLockInputSaveState->fInsideMenuLoop = fInsideMenuLoop;
      fMenu = FALSE;
      fInsideMenuLoop = FALSE;

      pLockInputSaveState->pGlobalPopupMenu = pGlobalPopupMenu;
      pGlobalPopupMenu = NULL;

      /* Change focus etc without sending messages... 
       */
      pLockInputSaveState->hwndFocus   = hwndFocus;
      pLockInputSaveState->hwndActive  = hwndActive;
      hwndFocus  = hwndInput;
      hwndActive = hwndInput;
      
      /* Save capture and set it to null */
      pLockInputSaveState->hwndCapture = hwndCapture;
      SetCapture(NULL);

      /* Save sysmodal window */
      pLockInputSaveState->hwndSysModal= hwndSysModal;
      pLockInputSaveState->fMessageBox = fMessageBox;
      SetSysModalWindow(hwndInput);

      /* Save clipcursor rect */
      CopyRect(&pLockInputSaveState->rcClipCursor, &rcCursorClip);
      ClipCursor(NULL);

      /* Enable hardware input so that we can get mouse/keyboard messages. 
       */
      pLockInputSaveState->fOldHardwareInputState=EnableHardwareInput(TRUE);

    }
  else
    {
      if (!pLockInputSaveState)
        {
          /* Save state struct not in use, nothing to restore. 
	   */
          DebugErr(DBF_ERROR, "LockInput called with input already unlocked");
          return(NULL);
        }


      /* For DBCS, save are we in a dlg box global. */
      fDialog = pLockInputSaveState->fDialog;

      /* Restore clipcursor rect */
      ClipCursor(&pLockInputSaveState->rcClipCursor);

      /* Set active and focus windows manually so we avoid sending messages to
       * the applications. 
       */
      hwndFocus = pLockInputSaveState->hwndFocus;
      hwndActive= pLockInputSaveState->hwndActive;

      SetSysModalWindow(pLockInputSaveState->hwndSysModal);
      fMessageBox = pLockInputSaveState->fMessageBox;

      pGlobalPopupMenu = pLockInputSaveState->pGlobalPopupMenu;
      fMenu            = pLockInputSaveState->fMenu;
      fInsideMenuLoop  = pLockInputSaveState->fInsideMenuLoop;

      SetCapture(pLockInputSaveState->hwndCapture);
      EnableHardwareInput(pLockInputSaveState->fOldHardwareInputState);

      /* Unset global which tells us a task is locked. Has to be unset before
       * we call LockMyTask...  
       */
      hTaskLockInput = NULL;
      LockMyTask(FALSE);

      LocalFree((HANDLE)pLockInputSaveState);
      pLockInputSaveState = NULL;
    }

  return(TRUE);
}
#endif // !WOW

LONG API GetSystemDebugState(void)
{
  LONG   returnval = 0;
  HANDLE hTask;

  hTask = GetCurrentTask();
  if (!GetTaskQueue(hTask))
      returnval = returnval | SDS_NOTASKQUEUE;

#ifndef WOW
  if (fMenu)
      returnval = returnval | SDS_MENU;

  if (fDialog)
      returnval = returnval | SDS_DIALOG;

  if (fTaskIsLocked)
      returnval = returnval | SDS_TASKLOCKED;

  if (hwndSysModal)
      returnval = returnval | SDS_SYSMODAL;
#endif // !WOW

  return(returnval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\drvrrare.c ===
/* Installable drivers for windows.  Less common code.
 */
#include "user.h"

/*--------------------------------------------------------------------------*\
**
**  NewSignalProc() -
**
\*--------------------------------------------------------------------------*/
#define SG_EXIT     0x0020
#define SG_LOAD_DLL 0x0040
#define SG_EXIT_DLL 0x0080
#define SG_GP_FAULT 0x0666

BOOL
CALLBACK NewSignalProc(
    HTASK hTask,
    WORD message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fRet;

    // Notify installable drivers this app is going away.
    if ( message == SG_EXIT || message == SG_GP_FAULT ) {
        InternalBroadcastDriverMessage( NULL, DRV_EXITAPPLICATION,
                                       (message == SG_GP_FAULT
                                                    ? DRVEA_ABNORMALEXIT
                                                    : DRVEA_NORMALEXIT),
                                       0L, IBDM_FIRSTINSTANCEONLY );
    }

    //
    // Pass notification on to WOW32 (which passes on to USER32)
    //

    fRet = SignalProc( hTask, message, wParam, lParam );

    //
    // After letting WOW32 and User32 cleanup, destroy the shadow
    // message queue created by InitApp.
    //

    if ( message == SG_EXIT || message == SG_GP_FAULT ) {
        DeleteQueue();
    }

    return fRet;
}

HINSTANCE LoadAliasedLibrary(LPCSTR szLibFileName,
                             LPCSTR szSection,
                             LPCSTR szIniFile,
                             LPSTR  lpstrTail,
                             WORD   cbTail)
{
  char          sz[128];
  LPSTR         pch;
  OFSTRUCT      os;
  HFILE         fd;
  HINSTANCE     h;
  WORD          errMode;

  if (!szLibFileName || !*szLibFileName)
      return((HINSTANCE)2); /* File not found */

  /* read the filename and additional info. into sz
   */
  GetPrivateProfileString(szSection,          // ini section
                          szLibFileName,      // key name
                          szLibFileName,      // default if no match
                          sz,                 // return buffer
                          sizeof(sz),         // return buffer size
                          szIniFile);         // ini. file

  sz[sizeof(sz)-1] = 0;

  /* strip off the additional info. Remember, DS!=SS so we need to get a lpstr
   * to our stack allocated sz.
   */
  pch = (LPSTR)sz;
  while (*pch)
    {
      if (*pch == ' ')
        {
          *pch++ = '\0';
          break;
        }
      pch++;
    }

  // pch pts to ch after first space or null ch

  fd = OpenFile(sz, &os, OF_EXIST|OF_SHARE_DENY_NONE);
  if (HFILE_ERROR == fd)
      return((HINSTANCE)2);

  /* copy additional info. to lpstrTail
   */

  if (lpstrTail && cbTail)
    {
      while (cbTail-- && (*lpstrTail++ = *pch++))
          ;
      *(lpstrTail-1) = 0;
    }

  errMode = SetErrorMode(0x8001);

  h = LoadLibrary(sz);

  SetErrorMode(errMode);

  return (h);
}



int GetDrvrUsage(HMODULE hModule)
/* effects: Runs through the driver list and figures out how many instances of
 * this driver module handle we have.  We use this instead of GetModuleUsage
 * so that we can have drivers loaded as normal DLLs and as installable
 * drivers.
 */
{
  LPDRIVERTABLE lpdt;
  int           index;
  int           count;

  if (!hInstalledDriverList || !cInstalledDrivers || !hModule)
      return(0);

  count = 0;

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  for (index=0;index<cInstalledDrivers;index++)
    {
       if (lpdt->hModule==hModule)
           count++;

       lpdt++;
    }


  return(count);
}


BOOL PASCAL CheckValidDriverProc(LPDRIVERTABLE lpdt, HDRVR hdrv)
/* effects: Some vendors shipped multimedia style installable drivers with
 * bogus entry procs. This test checks for these bogus drivers and refuses to
 * install them.
 */
{
  WORD  currentSP;
  WORD  saveSP;

  _asm mov saveSP, sp
  (void)(lpdt->lpDriverEntryPoint)(0, hdrv, 0, 0L, 0L);
  _asm mov currentSP, sp
  _asm mov sp, saveSP

  if (saveSP != currentSP)
      DebugErr(DBF_ERROR, "Invalid driver entry proc address");

  return (saveSP == currentSP);
}

LRESULT FAR InternalLoadDriver(LPCSTR szDriverName,
                               LPCSTR szSectionName,
                               LPCSTR lpstrTail,
                               WORD   cbTail,
                               BOOL   fSendEnable)
{
  int           index;
  int           i;
  LPDRIVERTABLE lpdt;
  LPDRIVERTABLE lpdtBegin;
  LRESULT       result;
  HGLOBAL       h;
  HINSTANCE     hInstance;
  char          szDrivers[20];
  char          szSystemIni[20];

  /* Drivers receive the following messages: if the driver was loaded,
   * DRV_LOAD.  If DRV_LOAD returns non-zero and fSendEnable, DRV_ENABLE.
   */

  if (!hInstalledDriverList)
      h = GlobalAlloc(GHND|GMEM_SHARE, (DWORD)((WORD)sizeof(DRIVERTABLE)));
  else
      /* Alloc space for the next driver we will install. We may not really
       * install the driver in the last slot but rather in an intermediate
       * slot which was freed.
       */
      h = GlobalReAlloc(hInstalledDriverList,
                     (DWORD)((WORD)sizeof(DRIVERTABLE)*(cInstalledDrivers+1)),
                     GHND|GMEM_SHARE);

  if (!h)
      return(0L);

  cInstalledDrivers++;
  hInstalledDriverList = h;

  if (!szSectionName)
      LoadString(hInstanceWin, STR_DRIVERS, szDrivers, sizeof(szDrivers));
  LoadString(hInstanceWin, STR_SYSTEMINI, szSystemIni, sizeof(szSystemIni));

  lpdtBegin = lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList, NULL);

  /* Find an empty driver entry */
  for (i = 0; i < cInstalledDrivers; i++)
    {
      if (lpdt->hModule == NULL)
        {
          index = i;
          break;
        }

      lpdt++;
    }

  if (index + 1 < cInstalledDrivers)
      /* The driver went into an unused slot in the middle somewhere so
       * decrement cInstalledDrivers count.
       */
      cInstalledDrivers--;

  /* Temporarly use an hModule to 1 to reserve this entry in case the driver
   * loads another driver in its LibMain.
   */
  lpdt->hModule = (HMODULE)1;

  hInstance = LoadAliasedLibrary((LPSTR)szDriverName,
                         (LPSTR)(szSectionName ? szSectionName : szDrivers),
                         szSystemIni,
                         (LPSTR)lpstrTail,
                         cbTail);
  if (hInstance < HINSTANCE_ERROR)
    {
      lpdt->hModule = NULL;

      /* Load failed with an error. Return error code in highword.
       */
      return(MAKELRESULT(0, hInstance));
    }

  (FARPROC)lpdt->lpDriverEntryPoint = GetProcAddress(hInstance, "DriverProc");

  if (!lpdt->lpDriverEntryPoint)
    {
      FreeLibrary(hInstance);
      lpdt->hModule = 0;
      result = 0L;
      goto LoadCleanUp;
    }

  lpdt->hModule = hInstance;

  /* Save either the alias or filename of this driver. (depends on what the
   * app passed to us to load it)
   */
  lstrcpy(lpdt->szAliasName, szDriverName);

  if (GetDrvrUsage(hInstance) == 1)
    {
      /* If this is the first instance, send the drv_load message. Don't use
       * SendDriverMessage because we haven't initialized the linked list yet
       */
      if (!CheckValidDriverProc(lpdt, (HDRVR)(index+1)) ||
          !(lpdt->lpDriverEntryPoint)(lpdt->dwDriverIdentifier,
                                      (HDRVR)(index+1),
                                      DRV_LOAD,
                                      0L, 0L))
        {
          /* Driver failed load call.
           */
          lpdt->lpDriverEntryPoint = NULL;
          lpdt->hModule = NULL;
          FreeLibrary(hInstance);
          result = 0L;
          goto LoadCleanUp;
        }

      lpdt->fFirstEntry = 1;
    }

  /* Put driver in the load order linked list
   */
  if (idFirstDriver == -1)
    {
      /* Initialize everything when first driver is loaded.
       */
      idFirstDriver      = index;
      idLastDriver       = index;
      lpdt->idNextDriver = -1;
      lpdt->idPrevDriver = -1;
    }
  else
    {
      /* Insert this driver at the end of the load chain.
       */
      lpdtBegin[idLastDriver].idNextDriver = index;
      lpdt->idPrevDriver = idLastDriver;
      lpdt->idNextDriver = -1;
      idLastDriver = index;
    }

  if (fSendEnable && lpdt->fFirstEntry)
      SendDriverMessage((HDRVR)(index+1), DRV_ENABLE, 0L, 0L);

  result = MAKELRESULT(index+1, hInstance);

LoadCleanUp:
  return(result);
}



WORD FAR InternalFreeDriver(HDRVR hDriver, BOOL fSendDisable)
{
  LPDRIVERTABLE lpdt;
  WORD          w;
  int           id;

  /*  The driver will receive the following message sequence:
   *
   *      if usage count of driver is 1
   *          DRV_DISABLE (normally)
   *          DRV_FREE
   */

  if ((int)hDriver > cInstalledDrivers || !hDriver)
      return(0);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (!lpdt[(int)hDriver-1].hModule)
      return(0);

  /* If the driver usage count is 1, then send free and disable messages.
   */

  /* Clear dwDriverIdentifier so that the sendmessage for DRV_OPEN and
   * DRV_ENABLE have dwDriverIdentifier = 0 if an entry gets reused and so
   * that the DRV_DISABLE and DRV_FREE messages below also get
   * dwDriverIdentifier = 0.
   */

  lpdt[(int)hDriver-1].dwDriverIdentifier = 0;

  w = GetDrvrUsage(lpdt[(int)hDriver-1].hModule);
  if (w == 1)
    {
      if (fSendDisable)
          SendDriverMessage(hDriver, DRV_DISABLE, 0L, 0L);
      SendDriverMessage(hDriver, DRV_FREE, 0L, 0L);
    }
  FreeLibrary(lpdt[(int)hDriver-1].hModule);

  // Clear the rest of the table entry

  lpdt[(int)hDriver-1].hModule = 0;            // this indicates free entry
  lpdt[(int)hDriver-1].fFirstEntry = 0;        // this is also just to be tidy
  lpdt[(int)hDriver-1].lpDriverEntryPoint = 0; // this is also just to be tidy

  /* Fix up the driver load linked list */
  if (idFirstDriver == (int)hDriver-1)
    {
      idFirstDriver = lpdt[(int)hDriver-1].idNextDriver;
      if (idFirstDriver == -1)
        {
          /* No more drivers in the chain */
          idFirstDriver    = -1;
          idLastDriver     = -1;
          cInstalledDrivers= 0;
          goto Done;
        }
      else
        {
          /* Make prev entry of new first driver -1 */
          lpdt[idFirstDriver].idPrevDriver = -1;
        }
    }
  else if (idLastDriver == (int)hDriver-1)
    {
      /* We are freeing the last driver. So find a new last driver. */
      idLastDriver = lpdt[(int)hDriver-1].idPrevDriver;
      lpdt[idLastDriver].idNextDriver = -1;
    }
  else
    {
      /* We are freeing a driver in the middle of the list somewhere. */
      id = lpdt[(int)hDriver-1].idPrevDriver;
      lpdt[id].idNextDriver = lpdt[(int)hDriver-1].idNextDriver;

      id = lpdt[(int)hDriver-1].idNextDriver;
      lpdt[id].idPrevDriver = lpdt[(int)hDriver-1].idPrevDriver;
    }

Done:
  return(w-1);
}




LRESULT InternalOpenDriver(LPCSTR szDriverName,
                                   LPCSTR szSectionName,
                                   LPARAM lParam2,
                                   BOOL  fSendEnable)
{
  HDRVR         hDriver;
  LPDRIVERTABLE lpdt;
  LRESULT       result;
  char          sz[128];

  if (hDriver = (HDRVR)LOWORD(InternalLoadDriver(szDriverName, szSectionName,
                                          sz, sizeof(sz), fSendEnable)))
    {
      /* Set the driver identifier to the DRV_OPEN call to the driver
       * handle. This will let people build helper functions that the driver
       * can call with a unique identifier if they want to.
       */

      lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

      lpdt[(int)hDriver-1].dwDriverIdentifier = (DWORD)(WORD)hDriver;

      result = SendDriverMessage(hDriver,
                                 DRV_OPEN,
                                 (LPARAM)(LPSTR)sz,
                                 lParam2);
      if (!result)
          InternalFreeDriver(hDriver, fSendEnable);
      else
        {
          lpdt = (LPDRIVERTABLE)MAKELONG(0,hInstalledDriverList);

          lpdt[(int)hDriver-1].dwDriverIdentifier = (DWORD)result;

          result = (LRESULT)(DWORD)(WORD)hDriver;
        }
    }
  else
      result = 0L;

  return(result);
}


LRESULT InternalCloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2, BOOL fSendDisable)
{
  LPDRIVERTABLE lpdt;
  LRESULT       result;
  int           index;
  BOOL          f;
  HMODULE       hm;

  // check handle in valid range.

  if ((int)hDriver > cInstalledDrivers)
      return(FALSE);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (!lpdt[(int)hDriver-1].hModule)
      return(FALSE);

  result = SendDriverMessage(hDriver, DRV_CLOSE, lParam1, lParam2);

  if (result)
    {
      // Driver didn't abort close

      f  = lpdt[(int)hDriver-1].fFirstEntry;
      hm = lpdt[(int)hDriver-1].hModule;

      if (InternalFreeDriver(hDriver, fSendDisable) && f)
        {
          lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

          /* Only one entry for the driver in the driver list has the first
           * instance flag set. This is to make it easier to handle system
           * messages that only need to be sent to a driver once.
           *
           * To maintain the flag, we must set the flag in one of the other
           * entries if we remove the driver entry with the flag set.
           *
           * Note that InternalFreeDriver returns the new usage count of
           * the driver so if it is zero, we know that there are no other
           * entries for the driver in the list and so we don't have to
           * do this loop.
           */

          for (index=0;index<cInstalledDrivers;index++)
              if (lpdt[index].hModule == hm && !lpdt[index].fFirstEntry)
                {
                  lpdt[index].fFirstEntry = 1;
                  break;
                }
        }

    }

  return(result);
}


HDRVR API IOpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam)
{
  LRESULT result;

  /* The driver receives the following messages when it is opened. If it isn't
   * loaded, the library is loaded and the DRV_LOAD message is sent.  If
   * DRV_LOAD returns nonzero, the DRV_ENABLE message is sent.  Once the
   * driver is loaded or if it was previously loaded, the DRV_OPEN message is
   * sent.
   */
  result = InternalOpenDriver(szDriverName, szSectionName, lParam, TRUE);

  return((HDRVR)LOWORD(result));
}


LRESULT API ICloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
{
  /*  The driver will receive the following message sequence:
   *
   *      DRV_CLOSE
   *      if DRV_CLOSE returns non-zero
   *          if driver usage count = 1
   *              DRV_DISABLE
   *              DRV_FREE
   */

   return(InternalCloseDriver(hDriver, lParam1, lParam2, TRUE));
}


HINSTANCE API IGetDriverModuleHandle(HDRVR hDriver)
/* effects: Returns the module handle associated with the given driver ID.
 */
{
  LPDRIVERTABLE lpdt;
  HINSTANCE hModule = NULL;

  if (hDriver && ((int)hDriver <= cInstalledDrivers))
    {
      lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

      return lpdt[(int)hDriver-1].hModule;
    }
  else
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\edecrare.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDECRARE.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* edECRare.c - EC Edit controls Routines Called rarely are to be  	    */
/*		put in a seperate segment _EDECRare. This file contains     */
/*		these routines.		          		    	    */
/*                                                                          */
/* Created:  02-08-89  sankar                                               */
/****************************************************************************/

#define  NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*   Support Routines  common to Single-line and Multi-Line edit controls   */
/*   called Rarely.							    */
/****************************************************************************/


ICH FAR PASCAL ECGetTextHandler(ped, maxCchToCopy, lpBuffer)
register PED   ped;
register ICH   maxCchToCopy;
LPSTR          lpBuffer;
/* effects: Copies at most maxCchToCopy bytes to the buffer lpBuffer.  Returns
 * how many bytes were actually copied.  Null terminates the string thus at
 * most maxCchToCopy-1 characters will be returned.  
 */
{
  PSTR  pText;

  if (maxCchToCopy)
    {
#ifdef DEBUG
      /* In debug mode, trash their buffer so that we can catch
       * stack/allocation problems early. 
       */
      DebugFillStruct(lpBuffer, maxCchToCopy);
#endif

      /* Zero terminator takes the extra byte */
      maxCchToCopy = umin(maxCchToCopy-1, ped->cch);

      /* Zero terminate the string */
      *(LPSTR)(lpBuffer+maxCchToCopy) = 0;


      pText = LocalLock(ped->hText);
      LCopyStruct((LPSTR)pText, lpBuffer, maxCchToCopy);
      LocalUnlock(ped->hText);
    }

  return(maxCchToCopy);
}


BOOL FAR PASCAL ECNcCreate(hwnd, lpCreateStruct)
HWND               hwnd;
LPCREATESTRUCT     lpCreateStruct;
{
  LONG         windowStyle;
  register PED ped;

  /* Initially no ped for the window.  In case of no memory error, we can
   * return with a -1 for the window's PED 
   */
  SetWindowWord(hwnd, 0, (WORD)-1); /* No ped for this window */
  
  /* If pLocalHeap = 0, then we need to LocalInit our "new" data segment for
   * dialog boxes.  
   */
  if (!pLocalHeap)
    {
      LocalInit((WORD) NULL, 
                (WORD) 0,
                (WORD) GlobalSize(lpCreateStruct->hInstance)-64);

      /* Since LocalInit locked the segment (and it was locked previously, we
       * will unlock it to prevent lock count from being greater than 1).  
       */
      UnlockSegment((WORD)-1);
    }

  windowStyle = GetWindowLong(hwnd, GWL_STYLE);

  /* Try to allocate space for the ped.  HACK: Note that the handle to a fixed
   * local object is the same as a near pointer to the object.  
   */
  SwapHandle(&lpCreateStruct->lpszName);
  SwapHandle(&lpCreateStruct);

  if (!(ped = (PED) LocalAlloc(LPTR, sizeof(ED))))
      /* Error, no memory */
      return(NULL);

  if (windowStyle & ES_MULTILINE)
      /* Allocate memory for a char width buffer if we can get it. If we can't
       * we'll just be a little slower... 
       */
      ped->charWidthBuffer = LocalAlloc(LHND, sizeof(int)*256);

  if (windowStyle & ES_READONLY)
      ped->fReadOnly = 1;

  /* Allocate storage for the text for the edit controls.  Storage for single
   * line edit controls will always get allocated in the local data segment.
   * Multiline will allocate in the local ds but the app may free this and
   * allocate storage elsewhere...  
   */
  ped->hText = LocalAlloc(LHND, CCHALLOCEXTRA);
  if (!ped->hText) /* If no_memory error */
      return(FALSE);
  ped->cchAlloc = CCHALLOCEXTRA;

  SwapHandle(&lpCreateStruct);
  SwapHandle(&lpCreateStruct->lpszName);

  /* Set a field in the window to point to the ped so that we can recover the
   * edit structure in later messages when we are only given the window
   * handle.  
   */
  SetWindowWord(hwnd, 0, (WORD)ped);

  ped->hwnd = hwnd;
  ped->hwndParent = lpCreateStruct->hwndParent;

  if (windowStyle & WS_BORDER)
    {
      ped->fBorder = 1;
      /*
       * Strip the border bit from the window style since we draw the border
       * ourselves.
       */
      windowStyle = windowStyle & ~WS_BORDER;
      SetWindowLong(hwnd, GWL_STYLE, windowStyle);
    }

  return((BOOL)DefWindowProc(hwnd, WM_NCCREATE, 0, (LONG)lpCreateStruct));
}


BOOL FAR PASCAL ECCreate(hwnd, ped, lpCreateStruct)
HWND               hwnd;
register PED       ped;
LPCREATESTRUCT     lpCreateStruct;

/* effects: Creates the edit control for the window hwnd by allocating memory
 * as required from the application's heap.  Notifies parent if no memory
 * error (after cleaning up if needed).  Returns PED if no error else returns
 * NULL.  Just does the stuff which is independent of the style of the edit
 * control.  LocalAllocs done here may cause memory to move...  
 */
{
  LONG         windowStyle;


  /*
   * Get values from the window instance data structure and put them in the
   * ped so that we can access them easier.
   */
  windowStyle = GetWindowLong(hwnd, GWL_STYLE);

  if (windowStyle & ES_AUTOHSCROLL)
      ped->fAutoHScroll = 1;
  if (windowStyle & ES_NOHIDESEL)
      ped->fNoHideSel = 1;

  ped->cchTextMax = MAXTEXT; /* Max # chars we will initially allow */

  /* Set up undo initial conditions... (ie. nothing to undo) */
  ped->ichDeleted  = -1;
  ped->ichInsStart = -1;
  ped->ichInsEnd   = -1;
  
  /* Initialize the hilite attributes */
#ifdef WOW
  ped->hbrHiliteBk = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
#else
  ped->hbrHiliteBk = GetSysClrObject(COLOR_HIGHLIGHT);
#endif
  ped->rgbHiliteBk = GetSysColor(COLOR_HIGHLIGHT);
  ped->rgbHiliteText = GetSysColor(COLOR_HIGHLIGHTTEXT);

  return(TRUE);
}


void FAR PASCAL ECNcDestroyHandler(hwnd,ped,wParam,lParam)
HWND          hwnd;
register PED  ped;
WORD          wParam;
LONG          lParam;
/*
 * effects: Destroys the edit control ped by freeing up all memory used by it.
 */
{
  if (ped)
      /* ped could be NULL if WM_NCCREATE failed to create it... */
    {
      if (ped->fFocus)
          /* Destroy the caret if we have the focus and we are being
             killed */
          DestroyCaret();

      LocalFree(ped->hText);

#ifdef WOW
      DeleteObject(ped->hbrHiliteBk);
#endif
      /* Free up undo buffer and line start array (if present) */
      GlobalFree(ped->hDeletedText);
      LocalFree((HANDLE)ped->chLines);
      LocalFree((HANDLE)ped->charWidthBuffer);
      if (ped->pTabStops)
          /* Free tab stop buffer if it exists. 
	   */
          LocalFree((HANDLE)ped->pTabStops);

      /* Since a pointer and a handle to a fixed local object are the same */
      LocalFree((HANDLE)ped);
    }

  /* In case rogue messages float through after we have freed the ped, set the
   * handle in the window structure to FFFF and test for this value at the top
   * of EdWndProc.  
   */
  SetWindowWord(hwnd,0,(WORD)-1);

  /* Call DefWindowProc to free all little chunks of memory such as szName and
   * rgwScroll.  
   */
  DefWindowProc(hwnd,WM_NCDESTROY,wParam,lParam);
}


void FAR PASCAL ECSetPasswordChar(ped, pwchar)
register PED ped;
WORD         pwchar;
/* Sets the password char to display. */
{
  HDC  hdc;
  LONG style;

  ped->charPasswordChar = pwchar;

  if (pwchar)
    {
      hdc = ECGetEditDC(ped, TRUE);
      ped->cPasswordCharWidth = max(LOWORD(GetTextExtent(hdc,
                                               (LPSTR)&pwchar,
                                               1)), 
                                    1);
      ECReleaseEditDC(ped, hdc, TRUE);
    }

  style = GetWindowLong(ped->hwnd, GWL_STYLE);
  if (pwchar)
      style |= ES_PASSWORD;
  else
      style = style & (~ES_PASSWORD);

  SetWindowLong(ped->hwnd, GWL_STYLE, style);
}


void FAR PASCAL ECSetFont(ped, hfont, fRedraw)
register PED    ped;
HANDLE          hfont;
BOOL            fRedraw;
/* effects: Sets the edit control to use the font hfont.  warning: Memory
 * compaction may occur if hfont wasn't previously loaded.  If hfont == NULL,
 * then assume the system font is being used.  
 */
{
  register short  i;
  TEXTMETRIC	  TextMetrics;
  HDC		  hdc;
  HANDLE          hOldFont=NULL;
  RECT            rc;
  PINT            charWidth;
#ifdef FE_SB
  unsigned short LangID;
#endif

  hdc = GetDC(ped->hwnd);
  ped->hFont = hfont;

  if (hfont)
    {
      /* Since the default font is the system font, no need to select it in if
       * that's what the user wants.  
       */
      if (!(hOldFont = SelectObject(hdc, hfont)))
        {
          hfont = ped->hFont = NULL;
        }
    }

  /* Get the metrics and ave char width for the currently selected font */
  ped->aveCharWidth = GetCharDimensions(hdc, (TEXTMETRIC FAR *)&TextMetrics);

  ped->lineHeight = TextMetrics.tmHeight;
  ped->charOverhang = TextMetrics.tmOverhang;
  
  /* Check if Proportional Width Font */
  ped->fNonPropFont = !(TextMetrics.tmPitchAndFamily & 1);

  /* Get char widths */
  if (ped->charWidthBuffer)
    {
      charWidth = (PINT)LocalLock(ped->charWidthBuffer);
      if (!GetCharWidth(hdc, 0, 0xff, (LPINT)charWidth))
        {
          LocalUnlock(ped->charWidthBuffer);
          LocalFree((HANDLE)ped->charWidthBuffer);
          ped->charWidthBuffer=NULL;
        }
      else
        { 
          /* We need to subtract out the overhang associated with each
	   * character since GetCharWidth includes it... 
	   */
          for (i=0;i<=0xff;i++)
               charWidth[i] -= ped->charOverhang;

          LocalUnlock(ped->charWidthBuffer);
        }
    }

#ifdef FE_SB
    /* In DBCS Windows, Edit Control must handle Double Byte Character
     * in case of charset of the font is 128(Japan) or 129(Korea).
     */
     LangID = GetSystemDefaultLangID();
     if (LangID == 0x411 || LangID == 0x412 || LangID == 0x404 || LangID == 0x804 || LangID == 0xC04)
     {
        ped->charSet = TextMetrics.tmCharSet;
        ECGetDBCSVector( ped );
        ped->fDBCS = 1;
     }
#endif

  if (!hfont)
    {
      /* We are getting the statitics for the system font so update the system
       * font fields in the ed structure since we use these when determining
       * the border size of the edit control.  
       */
      ped->cxSysCharWidth = ped->aveCharWidth;
      ped->cySysCharHeight= ped->lineHeight;
    }
  else
      SelectObject(hdc, hOldFont);

  if (ped->fFocus)
    {
      /* Fix the caret size to the new font if we have the focus. */
      CreateCaret(ped->hwnd, (HBITMAP)NULL, 2, ped->lineHeight);
      ShowCaret(ped->hwnd);
    }

  ReleaseDC(ped->hwnd,hdc);

  if (ped->charPasswordChar)
      /* Update the password char metrics to match the new font. */
      ECSetPasswordChar(ped, ped->charPasswordChar);
	      
  if (ped->fSingle)
      SLSizeHandler(ped);
  else
    {
      MLSizeHandler(ped);    
      /* If word-wrap is not there, then we must calculate the maxPixelWidth
       * It is done by calling MLBuildChLines;
       * Also, reposition the scroll bar thumbs.
       * Fix for Bug #5141 --SANKAR-- 03/14/91 --
       */
      if(!ped->fWrap)
          MLBuildchLines(ped, 0, 0, FALSE);
      SetScrollPos(ped->hwnd, SB_VERT, 
      				(int)MLThumbPosFromPed(ped,TRUE), fRedraw);
      SetScrollPos(ped->hwnd, SB_HORZ, 
      				(int)MLThumbPosFromPed(ped,FALSE), fRedraw);
    }

  if (fRedraw)
    {
      GetWindowRect(ped->hwnd, (LPRECT)&rc);
      ScreenToClient(ped->hwnd, (LPPOINT)&rc.left);
      ScreenToClient(ped->hwnd, (LPPOINT)&rc.right);
      InvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
      UpdateWindow(ped->hwnd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\drvr.c ===
/* Installable drivers for windows. Often used stuff.
  */
#include "user.h"

LRESULT FAR InternalBroadcastDriverMessage(HDRVR  hDriverStart,
                                           WORD   message,
                                           LPARAM lParam1,
					   LPARAM lParam2,
                                           LONG   flags)
/* effects: Allows for sending messages to the drivers. Supports sending
 * messages to one instance of every driver, supports running through the list
 * in reverse order, and supports sending a message to a particular driver id.
 *
 * If flags & IBDM_SENDMESSAGE then only send message to
 * hDriverStart and ignore other flags. Fail if not
 * 0<hDriverStart<=cInstalledDrivers.
 *
 * If flags & IBDM_FIRSTINSTANCEONLY then send message to one instance of
 * each driver between hDriverStart and cInstalledDrivers.
 *
 * If flags  & IBDM_REVERSE then send message to drivers in reverse
 * order from hDriverStart to 1. If hDriverStart is 0 then send
 * messages to drivers from cInstalledDrivers to 1
 */
{
  LPDRIVERTABLE lpdt;
  LRESULT	result=0;
  int           id;
  int           idEnd;

  if (!hInstalledDriverList || (int)hDriverStart > cInstalledDrivers)
      return(FALSE);

  if (idFirstDriver == -1)
      /* No drivers in the list
       */
      return(FALSE);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);


  if (flags & IBDM_SENDMESSAGE)
    {
      if (!hDriverStart)
          return(FALSE);
      idEnd = lpdt[(int)hDriverStart-1].idNextDriver;
      flags &= ~(IBDM_REVERSE | IBDM_FIRSTINSTANCEONLY);
    }
  else
    {
      if (flags & IBDM_REVERSE)
        {
          if (!hDriverStart)
	      hDriverStart = (HDRVR)(idLastDriver+1);
          idEnd = lpdt[idFirstDriver].idPrevDriver;
        }
      else
        {
          if (!hDriverStart)
              hDriverStart = (HDRVR)(idFirstDriver+1);
	  idEnd = lpdt[idLastDriver].idNextDriver;
        }
    }

  /* Ids are -1 into the global driver list. */
  ((int)hDriverStart)--;

  for (id = (int)hDriverStart; id != idEnd; id = (flags & IBDM_REVERSE ? lpdt[id].idPrevDriver : lpdt[id].idNextDriver))
    {
       if (lpdt[id].hModule)
         {
           if ((flags & IBDM_FIRSTINSTANCEONLY) &&
               !lpdt[id].fFirstEntry)
               continue;

           result =
           (*lpdt[id].lpDriverEntryPoint)(lpdt[id].dwDriverIdentifier,
					  (HDRVR)(id+1),
                                          message,
                                          lParam1,
                                          lParam2);

           /* If this isn't a IBDM_SENDMESSAGE, we want to update our end
	    * points in case the driver callback added or removed some drivers
	    */
           if (flags & IBDM_REVERSE)
             {
               idEnd = lpdt[idFirstDriver].idPrevDriver;
             }
           else if (!(flags & IBDM_SENDMESSAGE))
             {
   	       idEnd = lpdt[idLastDriver].idNextDriver;
             }
           else
             {
               /* This is a IBDM_SENDMESSAGE. We need to break out of the for
		* loop here otherwise we run into problems if a new driver was
		* installed in the list during the callback and idEnd got
		* updated or something...
		*/
               break;
             }
         }
    }

  return(result);
}


LRESULT API ISendDriverMessage(HDRVR  hDriverID,
			       UINT   message,
			       LPARAM lParam1,
			       LPARAM lParam2)
{
  return(InternalBroadcastDriverMessage(hDriverID,
                                        message,
                                        lParam1,
                                        lParam2,
                                        IBDM_SENDMESSAGE));
}




BOOL API IGetDriverInfo(HDRVR hDriver, LPDRIVERINFOSTRUCT lpDriverInfoStruct)
{
  LPDRIVERTABLE lpdt;
  BOOL          ret = FALSE;

  if (!lpDriverInfoStruct ||
      lpDriverInfoStruct->length != sizeof(DRIVERINFOSTRUCT))
    {
      /* Error in struct size
       */
      DebugErr(DBF_ERROR, "Invalid size for DRIVERINFOSTRUCT");
      return(ret);
    }

#ifdef DEBUG
    DebugFillStruct(lpDriverInfoStruct, sizeof(DRIVERINFOSTRUCT));
    lpDriverInfoStruct->length = sizeof(DRIVERINFOSTRUCT);
#endif

  if (!hInstalledDriverList || (int)hDriver <= 0 || (int)hDriver > cInstalledDrivers)
      return(ret);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList, 0);

  if (lpdt[(int)hDriver-1].hModule)
    {
      lpDriverInfoStruct->hDriver = hDriver;
      lpDriverInfoStruct->hModule = lpdt[(int)hDriver-1].hModule;
      lstrcpy(lpDriverInfoStruct->szAliasName, lpdt[(int)hDriver-1].szAliasName);

      ret = TRUE;
    }


  return(ret);
}



HDRVR API IGetNextDriver(HDRVR hStart, DWORD dwFlags)
{
  int           iStart;
  int           iEnd;
  int           id;
  HDRVR 	h;
  LPDRIVERTABLE lpdt;

  if (!hInstalledDriverList || !cInstalledDrivers || idFirstDriver == -1)
      return(0);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (dwFlags & GND_REVERSE)
    {
      if (!hStart)
          iStart = idLastDriver;
      else
        {
          iStart = (int)hStart-1;

	  if (iStart == idFirstDriver)
	      /* If we are at the first driver, nothing left to do
	       */
	      return((HDRVR)0);

	  iStart = lpdt[iStart].idPrevDriver;
        }

      iEnd = lpdt[idFirstDriver].idPrevDriver;

    }
  else
    {
      if (!hStart)
          iStart = idFirstDriver;
      else
        {
	  iStart = (int)hStart-1;

          if (iStart == idLastDriver)
              /* If we are at the last driver, nothing left to do.
	       */
              return((HDRVR)0);

          iStart = lpdt[iStart].idNextDriver;
        }

      iEnd = lpdt[idLastDriver].idNextDriver;

    }

  if (!lpdt[iStart].hModule)
    {
      /* Bogus driver handle passed in
       */
      DebugErr(DBF_ERROR, "GetNextDriver: Invalid starting driver handle");
      return(0);
    }

  h = NULL;

  for (id = iStart; id != iEnd; id = (dwFlags & GND_REVERSE ? lpdt[id].idPrevDriver : lpdt[id].idNextDriver))
    {
       if (lpdt[id].hModule)
         {
           if ((dwFlags & GND_FIRSTINSTANCEONLY) &&
               !lpdt[id].fFirstEntry)
               continue;

	   h = (HDRVR)(id+1);
           break;
         }
    }

  return(h);
}


LRESULT API IDefDriverProc(dwDriverIdentifier, driverID, message, lParam1, lParam2)
DWORD  dwDriverIdentifier;
HDRVR  driverID;
UINT   message;
LPARAM lParam1;
LPARAM lParam2;
{

  switch (message)
   {
      case DRV_INSTALL:
         return((LRESULT)(DWORD)DRVCNF_OK);
         break;

      case DRV_LOAD:
      case DRV_ENABLE:
      case DRV_DISABLE:
      case DRV_FREE:
	 return((LRESULT)(DWORD)TRUE);
         break;
   }

  return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\editec.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDITEC.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* editec.c - Edit controls rewrite.  Version II of edit controls.          */
/*                                                                          */
/*                                                                          */
/* Created:  24-Jul-88 davidds                                              */
/****************************************************************************/

/* Warning: The single line editcontrols contain internal styles and API which
 * are need to support comboboxes.  They are defined in combcom.h/combcom.inc
 * and may be redefined or renumbered as needed.  
 */
#define NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/* Handlers common to both single and multi line edit controls.             */
/****************************************************************************/
LONG FAR PASCAL ECTabTheTextOut(hdc, x, y, lpstring, nCount, ped, iTabOrigin,
                                fDrawTheText)
HDC            hdc;
int            x;
int            y;
register int   nCount;              /* Count of chars in string */
LPSTR          lpstring;
register PED   ped;
int	       iTabOrigin;    /* Tab stops are with respect to this */
BOOL           fDrawTheText;
/* effects: Outputs the tabbed text if fDrawTheText is TRUE and returns the
 * textextent of the tabbed text. This is a local function for edit control
 * use so that it can be optimized for speed. 
 */
{
  int        nTabPositions;      /* Count of tabstops in tabstop array */
  LPINT      lpintTabStopPositions; /* Tab stop positions in pixels */

  int        initialx = x;  /* Save the initial x value so that we can get 
	                       total width of the string */
  int        cch;
  int        textextent;
  int        pixeltabstop = 0;
  int        i;
  int	     cxCharWidth;
  int        cyCharHeight = 0;
  RECT       rc;
  BOOL       fOpaque = GetBkMode(hdc) == OPAQUE;
  PINT       charWidthBuff;
  
  if (!lpstring || !nCount)
      return(MAKELONG(0,0));

  nTabPositions = (ped->pTabStops ? *(ped->pTabStops) : 0);
  lpintTabStopPositions = (LPINT)(ped->pTabStops ? (ped->pTabStops+1): NULL);

  cxCharWidth  = ped->aveCharWidth;
  cyCharHeight = ped->lineHeight;

  /* If no tabstop positions are specified, then use a default of 8 system
   * font ave char widths or use the single fixed tab stop.  
   */
  if (!lpintTabStopPositions)
      pixeltabstop = 8*cxCharWidth;
  else
    {
      if (nTabPositions == 1)
        {
          pixeltabstop = lpintTabStopPositions[0];

          if (!pixeltabstop)
              pixeltabstop=1;
        }
    }

  rc.left = initialx;
  rc.top  = y;
  rc.bottom = rc.top+cyCharHeight;

  while(nCount)
    {
      if (ped->charWidthBuffer)
        {
          charWidthBuff = (PINT)LMHtoP(ped->charWidthBuffer);
          textextent=0;
          /* Initially assume no tabs exist in the text so cch=nCount. 
	   */
          cch = nCount;
          for (i=0; i<nCount; i++)
             {
               /* Warning danger. We gotta be careful here and convert lpstr
		* (which is a SIGNED char) into an unsigned char before using
		* it to index into the array otherwise the C Compiler screws
		* us and gives a negative number... 
		*/
#ifdef FE_SB
               if (ECIsDBCSLeadByte(ped,lpstring[i])
                     && i+1 < nCount) {
                 textextent += LOWORD(GetTextExtent(hdc,&lpstring[i],2));
                 i++;
               } else if (lpstring[i] == TAB ){
                 cch = i;
                 break;
               } else
                   textextent += (charWidthBuff[(WORD)(((unsigned char FAR *)lpstring)[i])]);
#else
               if (lpstring[i] == TAB)
                 {
                   cch = i;
                   break;
                 }

               textextent += (charWidthBuff[(WORD)(((unsigned char FAR *)lpstring)[i])]);
#endif
             }

          nCount = nCount - cch;
        }
      else
        {
          /* Gotta call the driver to do our text extent. 
	   */
          cch = (int)ECFindTab(lpstring, nCount);
          nCount = nCount - cch;
          textextent = LOWORD(GetTextExtent(hdc, lpstring, cch));
        }


      if (fDrawTheText)
	{
          /* Output all text up to the tab (or end of string) and get its
	   * extent.  
	   */
          rc.right  = x+LOWORD(textextent);
          ExtTextOut(hdc,x, y, (fOpaque ? ETO_OPAQUE : 0), 
                     (LPRECT)&rc, lpstring, cch, 0L);
          rc.left   = rc.right;
        }
 
      if (!nCount)
          /* If we're at the end of the string, just return without bothering
	   * to calc next tab stop.  
	   */
          return(MAKELONG(LOWORD(textextent)+(x-initialx),cyCharHeight));

      /* Find the next tab position and update the x value.  
       */
      if (pixeltabstop)
          x = (((x-iTabOrigin+LOWORD(textextent))/pixeltabstop)*pixeltabstop)+
		  pixeltabstop + iTabOrigin;
      else
        {
          x += LOWORD(textextent);
          for (i=0; i < nTabPositions; i++)
             {
               if (x < (lpintTabStopPositions[i] + iTabOrigin))
                 {
                   x = (lpintTabStopPositions[i] + iTabOrigin);
                   break;
                 }
             }
	  /* Check if all the tabstops set are exhausted; Then start using
	   * default tab stop positions.
	   */
	  if (i == nTabPositions)
	    {
		pixeltabstop = 8 * cxCharWidth;
		x = ((x - iTabOrigin)/pixeltabstop)*pixeltabstop + 
			pixeltabstop + iTabOrigin;
	    }
        }

       /* Skip over the tab and the characters we just drew.  
	*/
       lpstring += (cch+1);
       nCount--; /* Skip over tab */
       if (!nCount && fDrawTheText)
	 {
           /* This string ends with a tab. We need to opaque the rect produced
	    * by this tab... 
	    */
           rc.right  = x;
           ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, 
                      (LPRECT)&rc, "", 0, 0L);
         }
    }

  return(MAKELONG((x-initialx), cyCharHeight));
}



ICH FAR PASCAL ECCchInWidth(ped, hdc, lpText, cch, width)
register PED    ped;
HDC    	        hdc;
LPSTR           lpText;
register ICH    cch;
unsigned int    width;
/* effects: Returns maximum count of characters (up to cch) from the given
 * string which will fit in the given width.  ie. Will tell you how much of
 * lpstring will fit in the given width even when using proportional
 * characters.  WARNING: If we use kerning, then this loses...  
 */
{
  int stringExtent;
  int cchhigh;
  int cchnew = 0;
  int cchlow = 0;

  if ((width<=0) || !cch)
      return(0);

  /* Optimize nonproportional fonts for single line ec since they don't have
   * tabs. 
   */
  if (ped->fNonPropFont && ped->fSingle)
      /* umin is unsigned min function */
      return(umin(width/ped->aveCharWidth,cch));

  /* Check if password hidden chars are being used. */
  if (ped->charPasswordChar)
      return(umin(width/ped->cPasswordCharWidth,cch));

  cchhigh = cch+1;
  while (cchlow < cchhigh-1)
  {
     cchnew = umax((cchhigh - cchlow)/2,1)+cchlow;

     if (ped->fSingle)
	 stringExtent = LOWORD(GetTextExtent(hdc, (LPSTR)lpText, cchnew));
     else
         stringExtent = LOWORD(ECTabTheTextOut(hdc, 0, 0,
					(LPSTR)lpText, 
					cchnew,
                                        ped, 0, FALSE));

     if (stringExtent > width)
         cchhigh = cchnew;
     else
         cchlow = cchnew;
  }
#ifdef FE_SB
  cchlow = ECAdjustIch( ped, lpText, cchlow );
#endif
  return(cchlow);
}


ICH FAR PASCAL ECFindTab(lpstr, cch)
LPSTR        lpstr;
register ICH cch;
/* effects: Scans lpstr and returns the number of chars till the first TAB.
 * Scans at most cch chars of lpstr.  
 */
{
  LPSTR copylpstr = lpstr;

  if (!cch)
      return(0);

  while (*lpstr != TAB)
    {
       lpstr++;
       if (--cch == 0)
           break;
    }
  return((ICH)(lpstr - copylpstr));

}


BOOL NEAR _fastcall ECIsDelimiter(char bCharVal)
{
	return((bCharVal == ' ') || (bCharVal == '\t'));
}

LONG FAR PASCAL ECWord(ped, ichStart, fLeft)
PED  ped;      /* Yes, I mean no register ped */
ICH  ichStart;
BOOL fLeft;
/* effects:  if fLeft Returns the ichMinSel and ichMaxSel of the word to the
 * left of ichStart.  ichMinSel contains the starting letter of the word,
 * ichmaxsel contains all spaces up to the first character of the next word.
 *
 * if !fLeft Returns the ichMinSel and ichMaxSel of the word to the right of
 * ichStart.  ichMinSel contains the starting letter of the word, ichmaxsel
 * contains the first letter of the next word.  If ichStart is in the middle
 * of a word, that word is considered the left or right word.  ichMinSel is in
 * the low order word and ichMaxSel is in the high order word.  ichMinSel is
 * in the low order word and ichMaxSel is in the high order word.  A CR LF
 * pair or CRCRLF triple is considered a single word for the purposes of
 * multiline edit controls.
 */
{
  PSTR          pText;
  register PSTR pWordMinSel;
  register PSTR pWordMaxSel;
  BOOL          charLocated=FALSE;
  BOOL          spaceLocated=FALSE;
#ifdef FE_SB
  PSTR		pWordStr;
  BOOL		fAlpha = FALSE;
#endif

  if ((!ichStart && fLeft) || (ichStart == ped->cch && !fLeft))
      /* We are at the beginning of the text (looking left) or we are at end
       * of text (looking right), no word here 
       */
      return(0L);

  pText = (PSTR) LocalLock(ped->hText);
  pWordMinSel = pWordMaxSel = pText+ichStart;

  /* if fLeft:  Move pWordMinSel to the left looking for the start of a word.
   * If we start at a space, we will include spaces in the selection as we
   * move left untill we find a nonspace character. At that point, we continue
   * looking left until we find a space.  Thus, the selection will consist of
   * a word with its trailing spaces or, it will consist of any leading at the
   * beginning of a line of text.  
   */

  /* if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
   * word.  If the pWordMinSel points to a character, then we move left
   * looking for a space which will signify the start of the word. If
   * pWordMinSel points to a space, we look right till we come upon a
   * character.  pMaxWord will look right starting at pMinWord looking for the
   * end of the word and its trailing spaces.  
   */


#ifdef FE_SB
  if (fLeft || (!ECIsDelimiter(*pWordMinSel) && *pWordMinSel != 0x0D && !ECIsDBCSLeadByte(ped,*pWordMinSel)))
#else
  if (fLeft || (!ECIsDelimiter(*pWordMinSel) && *pWordMinSel != 0x0D))
#endif
      /* If we are moving left or if we are moving right and we are not on a
       * space or a CR (the start of a word), then we was look left for the
       * start of a word which is either a CR or a character. We do this by
       * looking left till we find a character (or if CR we stop), then we
       * continue looking left till we find a space or LF.  
       */
    {
#ifdef FE_SB
      while (pWordMinSel > pText &&
             ((!ECIsDelimiter(*(pWordStr=(PSTR)LOWORD(ECAnsiPrev(ped,pText,pWordMinSel)))) && *pWordStr != 0x0A) ||
	      !charLocated))											/* FE_SB */
	{													/* FE_SB */
	   if (!fLeft &&											/* FE_SB */
	       (ECIsDelimiter(*(pWordStr=ECAnsiPrev(ped,pText,pWordMinSel))) ||					/* FE_SB */
		*pWordStr == 0x0A))										/* FE_SB */
#else
      while (pWordMinSel > pText &&
             ((!ECIsDelimiter(*(pWordMinSel-1)) && *(pWordMinSel-1) != 0x0A) || 
              !charLocated))
        {
           if (!fLeft &&
               (ECIsDelimiter(*(pWordMinSel-1)) ||
                *(pWordMinSel-1) == 0x0A))
#endif
	       /*
	        * If we are looking for the start of the word right, then we
	        * stop when we have found it. (needed in case charLocated is
	        * still FALSE)
	        */
               break;

#ifdef FE_SB
           if( !ECIsDBCSLeadByte(ped,*pWordMinSel) && !ECIsDelimiter(*pWordMinSel) &&
               *pWordMinSel != 0x0d && *pWordMinSel != 0x0a &&
               pWordMinSel != pText+ichStart )
               fAlpha = TRUE;
#endif

#ifdef FE_SB
           pWordMinSel = ECAnsiPrev(ped,pText,pWordMinSel);
#else
           pWordMinSel--;
#endif

#ifdef FE_SB
           if( ECIsDBCSLeadByte(ped, *pWordMinSel ) ){
               if( !fLeft || fAlpha )
                   pWordMinSel = ECAnsiNext(ped,pWordMinSel);
               break;
           }
#endif

           if (!ECIsDelimiter(*pWordMinSel) && *pWordMinSel != 0x0A)
               /*
	        * We have found the last char in the word. Continue looking
	        * backwards till we find the first char of the word
	        */
             {
               charLocated = TRUE;
               /* We will consider a CR the start of a word */
               if (*pWordMinSel == 0x0D)
                   break;
             }

        }
    }
  else
    {
       /* We are moving right and we are in between words so we need to move
	* right till we find the start of a word (either a CR or a character.
	*/
       while ((ECIsDelimiter(*pWordMinSel) ||
               *pWordMinSel == 0x0A) &&
              pWordMinSel<pText+ped->cch)
           pWordMinSel++;

    }

#ifdef FE_SB
  pWordMaxSel = (PSTR) umin((WORD)ECAnsiNext(ped,pWordMinSel),(WORD)pText+ped->cch);
#else
  pWordMaxSel = (PSTR) umin((WORD)pWordMinSel+1,(WORD)pText+ped->cch);
#endif
  if (*pWordMinSel == 0x0D)
    {
#ifdef FE_SB
      if (pWordMinSel>pText && *(ECAnsiPrev(ped,pText,pWordMinSel)) == 0x0D)
#else
      if (pWordMinSel>pText && *(pWordMinSel-1) == 0x0D)
#endif
          /* So that we can treat CRCRLF as one word also. */
          pWordMinSel--;
      else if (*(pWordMinSel+1) == 0x0D)
          /* Move MaxSel on to the LF */
          pWordMaxSel++;
    }


  /* Check if we have a one character word */
  if (ECIsDelimiter(*pWordMaxSel))
      spaceLocated = TRUE;

  /* Move pWordMaxSel to the right looking for the end of a word and its
   * trailing spaces. WordMaxSel stops on the first character of the next
   * word.  Thus, we break either at a CR or at the first nonspace char after
   * a run of spaces or LFs.  
   */
  while ((pWordMaxSel < pText+ped->cch) &&
         (!spaceLocated || (ECIsDelimiter(*pWordMaxSel))))

       {
         if (*pWordMaxSel == 0x0D)
             break;

#ifdef FE_SB
         if( ECIsDBCSLeadByte(ped,*pWordMaxSel) )
             break;
         else if( !ECIsDelimiter(*pWordMaxSel) && *pWordMaxSel != 0x0a &&
             *pWordMaxSel != 0x0d && ECIsDBCSLeadByte(ped,*pWordMinSel) )
             break;
#endif

#ifdef FE_SB
         pWordMaxSel = ECAnsiNext(ped,pWordMaxSel);
#else
         pWordMaxSel++;
#endif

         if (ECIsDelimiter(*pWordMaxSel))
             spaceLocated = TRUE;


#ifdef FE_SB
         if (*(ECAnsiPrev(ped,pText,pWordMaxSel)) == 0x0A)
             break;
#else
         if (*(pWordMaxSel-1) == 0x0A)
             break;
#endif
       }


  LocalUnlock(ped->hText);

  return(MAKELONG(pWordMinSel-pText,pWordMaxSel-pText));
}


void FAR PASCAL ECEmptyUndo(ped)
register PED ped;
/* effects: empties the undo buffer. 
 */
{
  ped->undoType = UNDO_NONE;
  if (ped->hDeletedText)
    {
      GlobalFree(ped->hDeletedText);
      ped->hDeletedText = NULL;
    }
}


BOOL FAR PASCAL ECInsertText(ped, lpText, cchInsert)
register PED    ped;
LPSTR           lpText;
ICH             cchInsert;
/* effects: Adds cch characters from lpText into the ped->hText starting at
 * ped->ichCaret.  Returns TRUE if successful else FALSE.  Updates
 * ped->cchAlloc and ped->cch properly if additional memory was allocated or
 * if characters were actually added.  Updates ped->ichCaret to be at the end
 * of the inserted text.  min and maxsel are equal to ichcaret.  
 */
{
  register PSTR pedText;
  PSTR		pTextBuff;
  LONG          style;
  WORD          i;
  WORD          allocamt;
  HANDLE        hTextCopy;
  WORD          lcompact;

#ifdef FE_SB
  /* Make sure we don't split a DBCS in half - 05/15/90 */
  cchInsert = ECAdjustIch(ped, lpText, cchInsert);
#endif

  if (!cchInsert)
      return(TRUE);

  /* Do we already have enough memory?? */
  if (cchInsert >= (ped->cchAlloc - ped->cch))
    {
      /* Save lpText across the allocs */
      SwapHandle(&lpText);

      /* Allocate what we need plus a little extra. Return FALSE if we are
       * unsuccessful.  
       */
      allocamt = ped->cch+cchInsert;

      if (allocamt+CCHALLOCEXTRA > allocamt)
          /* Need to avoid wrapping around 64K if ped->cch+cchInsert is close
	   * to 64K.
	   */
          allocamt += CCHALLOCEXTRA;

      if (!ped->fSingle)
        {
          /* If multiline, try reallocing the text allowing it to be movable.
	   * If it fails, move the line break array out of the way and try
	   * again. We really fail if this doesn't work...  
	   */
          hTextCopy = LocalReAlloc(ped->hText, allocamt, LHND);
          if (hTextCopy)
              ped->hText = hTextCopy;
          else
            {
              /* If the above localrealloc fails, we need to take extreme
	       * measures to try to alloc some memory. This is because the
	       * local memory manager is broken when dealing with large
	       * reallocs.  
	       */
              if (ped->chLines)
                {
                  hTextCopy = (HANDLE)LocalReAlloc((HANDLE)ped->chLines, 
                                           LocalSize((HANDLE)ped->chLines),
                                           LHND);
                  if (!hTextCopy)
                      return(FALSE);
                  ped->chLines = (int *)hTextCopy;
                }
              LocalShrink(0,0x100);

              lcompact = umin(allocamt, CCHALLOCEXTRA*100);
              hTextCopy = LocalAlloc(LHND|LMEM_NOCOMPACT|LMEM_NODISCARD,
                                     lcompact);
              if (hTextCopy)
                  LocalFree(hTextCopy);

              hTextCopy = LocalReAlloc(ped->hText, allocamt, LHND);
              if (hTextCopy)
                  ped->hText = hTextCopy;
              else
                  return(FALSE);
            }
        }
      else
        {
          if (!LocalReAlloc(ped->hText, allocamt, 0))
              return(FALSE);
        }

      ped->cchAlloc = LocalSize(ped->hText);
      /* Restore lpText */
      SwapHandle(&lpText);
    }

   /* Ok, we got the memory. Now copy the text into the structure 
    */
   pedText = (PSTR) LocalLock(ped->hText);

   /* Get a pointer to the place where text is to be inserted */
   pTextBuff = pedText + ped->ichCaret;
   if (ped->ichCaret != ped->cch)
     {
       /* We are inserting text into the middle. We have to shift text to the
	* right before inserting new text.  
	*/
       LCopyStruct( (LPSTR)pTextBuff, 
                    (LPSTR)(pTextBuff + cchInsert),
                    ped->cch-ped->ichCaret);
     }
   /* Make a copy of the text being inserted in the edit buffer. */
   /* Use this copy for doing UPPERCASE/LOWERCASE ANSI/OEM conversions */
   /* Fix for Bug #3406 -- 01/29/91 -- SANKAR -- */
   LCopyStruct(lpText, (LPSTR)pTextBuff, cchInsert);

#ifndef PMODE
   LockData(0);	/* Calls to Language drivers are made later; So, to be safe.*/
#endif

   /* We need to get the style this way since edit controls use their own ds. 
    */
   style = GetWindowLong(ped->hwnd, GWL_STYLE);
   if (style & ES_LOWERCASE)
       AnsiLowerBuff((LPSTR)pTextBuff, cchInsert);
   else
   if (style & ES_UPPERCASE)
       AnsiUpperBuff((LPSTR)pTextBuff, cchInsert);

#ifdef FE_SB
    if( style & ES_OEMCONVERT ){
        for( i = 0; i < cchInsert; i++ ){
	    /* Do not make any case conversion if a character is DBCS */
            if( ECIsDBCSLeadByte(ped, *((LPSTR)pTextBuff+i) ) )
                i++;
            else {
                if( IsCharLower( *((LPSTR)pTextBuff+i) ) ){
                    AnsiUpperBuff( (LPSTR)pTextBuff+i, 1 );
                    AnsiToOemBuff( (LPSTR)pTextBuff+i, (LPSTR)pTextBuff+i, 1 );
                    OemToAnsiBuff( (LPSTR)pTextBuff+i, (LPSTR)pTextBuff+i, 1 );
                    AnsiLowerBuff( (LPSTR)pTextBuff+i, 1 );
                } else {
                    AnsiToOemBuff( (LPSTR)pTextBuff+i, (LPSTR)pTextBuff+i, 1 );
                    OemToAnsiBuff( (LPSTR)pTextBuff+i, (LPSTR)pTextBuff+i, 1 );
                }
            }
        }
    }
#else
   if (style & ES_OEMCONVERT)
     {
       for (i=0;i<cchInsert;i++)
         {
           if (IsCharLower(*((LPSTR)pTextBuff+i)))
             {
               AnsiUpperBuff((LPSTR)pTextBuff+i, 1);
               AnsiToOemBuff((LPSTR)pTextBuff+i,(LPSTR)pTextBuff+i,1);
               OemToAnsiBuff((LPSTR)pTextBuff+i,(LPSTR)pTextBuff+i,1);
               AnsiLowerBuff((LPSTR)pTextBuff+i,1);
             }
	   else
             {
               AnsiToOemBuff((LPSTR)pTextBuff+i,(LPSTR)pTextBuff+i,1);
               OemToAnsiBuff((LPSTR)pTextBuff+i,(LPSTR)pTextBuff+i,1);
             }
         }
     }
#endif
#ifndef PMODE
   UnlockData(0);
#endif

   LocalUnlock(ped->hText);  /* Hereafter pTextBuff is invalid */

   /* Adjust UNDO fields so that we can undo this insert... */
   if (ped->undoType == UNDO_NONE)
     {
       ped->undoType    = UNDO_INSERT;
       ped->ichInsStart = ped->ichCaret;
       ped->ichInsEnd   = ped->ichCaret+cchInsert;
     }
   else
   if (ped->undoType & UNDO_INSERT)
     {
       if (ped->ichInsEnd == ped->ichCaret)
           ped->ichInsEnd += cchInsert;
       else
         {
UNDOINSERT:
	   if (ped->ichDeleted != ped->ichCaret)
             {
               /* Free Deleted text handle if any since user is inserting into
	          a different point. */
               GlobalFree(ped->hDeletedText);
	       ped->hDeletedText = NULL;
               ped->ichDeleted = -1;
               ped->undoType &= ~UNDO_DELETE;
             }
           ped->ichInsStart = ped->ichCaret;
           ped->ichInsEnd   = ped->ichCaret+cchInsert;
           ped->undoType |= UNDO_INSERT;
         }
     }
   else 
   if (ped->undoType == UNDO_DELETE)
     {
       goto UNDOINSERT;
     }

   ped->cch += cchInsert;
   ped->ichMinSel = ped->ichMaxSel = (ped->ichCaret += cchInsert);
   /* Set dirty bit */
   ped->fDirty = TRUE;
   
   return(TRUE);
}


ICH FAR PASCAL ECDeleteText(ped)
register PED    ped;
/* effects: Deletes the text between ped->ichMinSel and ped->ichMaxSel.  The
 * character at ichMaxSel is not deleted. But the character at ichMinSel is
 * deleted. ped->cch is updated properly and memory is deallocated if enough
 * text is removed. ped->ichMinSel, ped->ichMaxSel, and ped->ichCaret are set
 * to point to the original ped->ichMinSel.  Returns the number of characters
 * deleted.  
 */
{
  register PSTR pedText;
  ICH           cchDelete;
  LPSTR         lpDeleteSaveBuffer;
  HANDLE        hDeletedText;
  WORD          bufferOffset;

  cchDelete = ped->ichMaxSel - ped->ichMinSel;

  if (!cchDelete)
      return(0);

   /* Ok, now lets delete the text. */

   pedText = (PSTR) LocalLock(ped->hText);

   /* Adjust UNDO fields so that we can undo this delete... */
   if (ped->undoType == UNDO_NONE)
     {
UNDODELETEFROMSCRATCH:
       if (ped->hDeletedText = GlobalAlloc(GHND, (LONG)(cchDelete+1)))
	 {
           ped->undoType      = UNDO_DELETE;
           ped->ichDeleted    = ped->ichMinSel;
           ped->cchDeleted    = cchDelete;
           lpDeleteSaveBuffer = GlobalLock(ped->hDeletedText);
           LCopyStruct((LPSTR)(pedText+ped->ichMinSel),
                       lpDeleteSaveBuffer, 
                       cchDelete);
           lpDeleteSaveBuffer[cchDelete]=0;
           GlobalUnlock(ped->hDeletedText);
         }
     }
   else
   if (ped->undoType & UNDO_INSERT)
     {
UNDODELETE:
       ped->undoType = UNDO_NONE;
       ped->ichInsStart = ped->ichInsEnd = -1;
       GlobalFree(ped->hDeletedText);
       ped->hDeletedText = NULL;
       ped->ichDeleted    = -1;
       ped->cchDeleted    = 0;
       goto UNDODELETEFROMSCRATCH;
     }
   else 
   if (ped->undoType == UNDO_DELETE)
     {
       if (ped->ichDeleted == ped->ichMaxSel)
         {
           /* Copy deleted text to front of undo buffer */
           hDeletedText = GlobalReAlloc(ped->hDeletedText, 
                                        (LONG)(cchDelete+ped->cchDeleted+1),
                                        GHND);
           if (!hDeletedText)
               goto UNDODELETE;
           bufferOffset = 0;
           ped->ichDeleted = ped->ichMinSel;
         }
       else
       if (ped->ichDeleted == ped->ichMinSel)
         {
           /* Copy deleted text to end of undo buffer */
           hDeletedText = GlobalReAlloc(ped->hDeletedText,
                                        (LONG)(cchDelete+ped->cchDeleted+1),
                                        GHND);
           if (!hDeletedText)
               goto UNDODELETE;
           bufferOffset = ped->cchDeleted;
         }
       else
           /* Clear the current UNDO delete and add the new one since
              the deletes aren't contigous. */
           goto UNDODELETE;


       ped->hDeletedText  = hDeletedText;
       lpDeleteSaveBuffer = (LPSTR)GlobalLock(hDeletedText);
       if (!bufferOffset)
	 {
           /* Move text in delete buffer up so that we can insert the next
              text at the head of the buffer. */
           LCopyStruct(lpDeleteSaveBuffer, 
                       (LPSTR)(lpDeleteSaveBuffer+cchDelete),
                       ped->cchDeleted);
         }
       LCopyStruct((LPSTR)(pedText+ped->ichMinSel),
                   (LPSTR)(lpDeleteSaveBuffer+bufferOffset),
                   cchDelete);

       lpDeleteSaveBuffer[ped->cchDeleted+cchDelete]=0;
       GlobalUnlock(ped->hDeletedText);
       ped->cchDeleted += cchDelete;
     }


   if (ped->ichMaxSel != ped->cch)
     {
       /* We are deleting text from the middle of the buffer so we have to
          shift text to the left. */

       LCopyStruct((LPSTR)(pedText + ped->ichMaxSel), 
                   (LPSTR)(pedText + ped->ichMinSel),
                   ped->cch-ped->ichMaxSel);
     }

   LocalUnlock(ped->hText);

   if (ped->cchAlloc-ped->cch > CCHALLOCEXTRA)
     {
       /* Free some memory since we deleted a lot */
       LocalReAlloc(ped->hText, (WORD)(ped->cch+(CCHALLOCEXTRA/2)), 0);
       ped->cchAlloc = LocalSize(ped->hText);
     }


   ped->cch = ped->cch - cchDelete;
   ped->ichCaret = ped->ichMaxSel = ped->ichMinSel;
   /* Set dirty bit */
   ped->fDirty = TRUE;
   
   return(cchDelete);
}


void FAR PASCAL ECNotifyParent(ped, notificationCode)
register PED   ped;
short          notificationCode;
/* effects: Sends the notification code to the parent of the edit control */
{
  /*
   * Lowword contains handle to window highword has the notification code.
   */
  SendMessage(ped->hwndParent, WM_COMMAND,
              GetWindowWord(ped->hwnd,GWW_ID),
              MAKELONG(ped->hwnd, notificationCode));
}


void FAR PASCAL ECSetEditClip(ped, hdc)
register PED ped;
HDC          hdc;
/* effects: Sets the clip rectangle for the dc to ped->rcFmt intersect
 * rcClient.  
 */
{
  RECT rectClient;

  GetClientRect(ped->hwnd,(LPRECT)&rectClient);

  /*
   * If border bit is set, deflate client rectangle appropriately.
   */
  if (ped->fBorder)
      /* Shrink client area to make room for the border */
      InflateRect((LPRECT)&rectClient, 
	          -min(ped->aveCharWidth,ped->cxSysCharWidth)/2,
                  -min(ped->lineHeight,ped->cySysCharHeight)/4);


  /* Set clip rectangle to rectClient intersect ped->rcFmt */
  if (!ped->fSingle)
      IntersectRect((LPRECT)&rectClient, 
	            (LPRECT)&rectClient, (LPRECT)&ped->rcFmt);

  IntersectClipRect(hdc,rectClient.left, rectClient.top,
			rectClient.right, rectClient.bottom);

}


HDC FAR PASCAL ECGetEditDC(ped, fFastDC)
register PED ped;
BOOL         fFastDC;
/* effects: Hides the caret, gets the DC for the edit control, and clips to
 * the rcFmt rectangle specified for the edit control and sets the proper
 * font.  If fFastDC, just select the proper font but don't bother about clip
 * regions or hiding the caret.  
 */
{
  register HDC hdc;

  if (!fFastDC)
      HideCaret(ped->hwnd);

  hdc = GetDC(ped->hwnd);

  ECSetEditClip(ped, hdc);

  /*
   * Select the proper font for this edit control's dc.
   */
  if (ped->hFont)
      SelectObject(hdc, ped->hFont);

  return(hdc);
}


void FAR PASCAL ECReleaseEditDC(ped,hdc,fFastDC)
register PED ped;
HDC          hdc;
BOOL         fFastDC;
/* effects: Releases the DC (hdc) for the edit control and shows the caret.
 * If fFastDC, just select the proper font but don't bother about showing the
 * caret.  
 */
{
  if (ped->hFont)
      /*
       * Release the font selected in this dc.
       */
      SelectObject(hdc, GetStockObject(SYSTEM_FONT));

  ReleaseDC(ped->hwnd,hdc);

  if (!fFastDC)
      ShowCaret(ped->hwnd);
}


BOOL FAR PASCAL ECSetText(ped, lpstr)
register PED   ped;
LPSTR          lpstr;
/* effects: Copies the null terminated text in lpstr to the ped.  Notifies the
 * parent if there isn't enough memory. Sets the minsel, maxsel, and caret to
 * the beginning of the inserted text.  Returns TRUE if successful else FALSE
 * if no memory (and notifies the parent).  
 */
{
  ICH cchLength;
  ICH cchSave = ped->cch;
  ICH ichCaretSave = ped->ichCaret;

  ped->cch = ped->ichCaret = 0;

  ped->cchAlloc = LocalSize(ped->hText);
  if (!lpstr)
    {
      LocalReAlloc(ped->hText, CCHALLOCEXTRA, 0);
      ped->cch = 0;
    } 
  else
    {
      cchLength = lstrlen(lpstr);
      if (ped->fSingle)
          /* Limit single line edit controls to 32K */
          cchLength = umin(cchLength, 0x7ffe);

      /* Add the text */
      if (cchLength && !ECInsertText(ped,lpstr,cchLength))
        {
          /*
	   * Restore original state and notify parent we ran out of memory.
	   */
          ped->cch = cchSave;
          ped->ichCaret = ichCaretSave;
          ECNotifyParent(ped, EN_ERRSPACE);
          return(FALSE);
        }
    }

  ped->cchAlloc = LocalSize(ped->hText);
  ped->screenStart = ped->iCaretLine = 0;
  /* Update caret and selection extents */
  ped->ichMaxSel = ped->ichMinSel = ped->ichCaret = 0;
  ped->cLines = 1;
  return(TRUE);
}


ICH FAR PASCAL ECCopyHandler(ped)
register PED  ped;
/* effects: Copies the text between ichMinSel and ichMaxSel to the clipboard.
 * Returns the number of characters copied.  
 */
{
  HANDLE   hData;
  char	   *pchSel;
  char FAR *lpchClip;
  ICH      cbData;

  cbData = ped->ichMaxSel - ped->ichMinSel;

  if (!cbData)
      return(0);

  if (!OpenClipboard(ped->hwnd))
      return(0);

  EmptyClipboard();

  /* +1 for the terminating NULL */
  if (!(hData = GlobalAlloc(LHND, (LONG)(cbData+1))))
    {
      CloseClipboard();
      return(0);
    }

  lpchClip = GlobalLock(hData);
  pchSel = LocalLock(ped->hText) + ped->ichMinSel;

  LCopyStruct((LPSTR)(pchSel), (LPSTR)lpchClip, cbData);

  *(lpchClip+cbData) = 0;

  LocalUnlock(ped->hText);
  GlobalUnlock(hData);

  SetClipboardData(CF_TEXT, hData);

  CloseClipboard();

  return(cbData);
}


/****************************************************************************/
/* EditWndProc()                                                            */
/****************************************************************************/
LONG FAR PASCAL EditWndProc3(hwnd, message, wParam, lParam)
HWND          hwnd;
WORD          message;
register WORD wParam;
LONG          lParam;
/* effects: Class procedure for all edit controls.
	Dispatches all messages to the appropriate handlers which are named 
	as follows:
        SL (single line) prefixes all single line edit control procedures while
        ML (multi  line) prefixes all multi- line edit controls.
        EC (edit control) prefixes all common handlers.

        The EditWndProc only handles messages common to both single and multi
        line edit controls.  Messages which are handled differently between
        single and multi are sent to SLEditWndProc or MLEditWndProc.

	Top level procedures are EditWndPoc, SLEditWndProc, and MLEditWndProc.
	SL*Handler or ML*Handler or EC*Handler procs are called to handle
	the various messages.  Support procedures are prefixed with SL ML or
	EC depending on which code they support.  They are never called 
	directly and most assumpttions/effects are documented in the effects
	clause.
 */

{
  register PED ped;

  /* Get the ped for the given window now since we will use it a lot in
   * various handlers. This was stored using SetWindowWord(hwnd,0,ped) when we
   * initially created the edit control.  
   */
  ped = (PED) GetWindowWord(hwnd,0);
  if ((WORD)ped == (WORD)-1)
      /* The ped was destroyed and this is a rogue message to be ignored. */
      return(0L);


  /* Dispatch the various messages we can receive */
  switch (message)
  {
    /* Messages which are handled the same way for both single and multi line
     * edit controls.  
     */

    case WM_COPY:
      /* wParam - not used
         lParam - not used */
      return((LONG)ECCopyHandler(ped));
      break;

    case WM_ENABLE:
      /* wParam - nonzero is window is enables else disable window if 0.
         lParam - not used
       */
      if (ped->fSingle)
          /* Cause the rectangle to be redrawn in grey. 
	   */
          InvalidateRect(ped->hwnd, NULL, FALSE);
      return((LONG)(ped->fDisabled = !wParam));
      break;

    case EM_GETLINECOUNT:
      /* wParam - not used
         lParam - not used */
      return((LONG)ped->cLines);
      break;

    case EM_GETMODIFY:
      /* wParam - not used
         lParam - not used */
      /* effects: Gets the state of the modify flag for this edit control.
       */
      return((LONG)ped->fDirty);
      break;

    case EM_GETRECT:
      /* wParam - not used
         lParam - pointer to a RECT data structure that gets the dimensions. */
      /*
       * effects: Copies the rcFmt rect to *lpRect.  Note that the return value
       * of the copyrect has no meaning and we don't care...
       */
      return((LONG)CopyRect((LPRECT)lParam, (LPRECT)&ped->rcFmt));
      break;

    case WM_GETFONT:
      /* wParam - not used 
         lParam - not used */
      return(ped->hFont);
      break;

    case WM_GETTEXT:
      /* wParam - max number of bytes to copy
         lParam - buffer to copy text to. Text is 0 terminated. */
      return((LONG)ECGetTextHandler(ped, wParam, (LPSTR)lParam));
      break;

    case WM_GETTEXTLENGTH:
      return((LONG)ped->cch);
      break;

    case WM_NCDESTROY:
      /* wParam - used by DefWndProc called within ECNcDestroyHandler
         lParam - used by DefWndProc called within ECNcDestroyHandler */
      ECNcDestroyHandler(hwnd, ped, wParam, lParam);
      break;

    case WM_SETFONT:
      /* wParam - handle to the font 
         lParam - redraw if true else don't */
      ECSetFont(ped, (HANDLE)wParam, (BOOL)LOWORD(lParam));
      break;

    case WM_SETREDRAW:
      /* wParam - specifies state of the redraw flag. nonzero = redraw
         lParam - not used */
      /* effects: Sets the state of the redraw flag for this edit control.  
       */
      return((LONG)(ped->fNoRedraw = !(BOOL)wParam));
      /* If NoRedraw is true, we don't redraw... (Yes, this is backwards we
       * are keeping track of the opposite of the command ...  
       */
      break;

    case EM_CANUNDO:
      /* wParam - not used
         lParam - not used */
      return((LONG)(ped->undoType != UNDO_NONE));
      break;

    case EM_EMPTYUNDOBUFFER:
      /* wParam - not used
         lParam - not used */
      ECEmptyUndo(ped);
      break;

    case EM_GETSEL:
      /* wParam - not used
         lParam - not used */
      /* effects: Gets the selection range for the given edit control.  The
       * starting position is in the low order word.  It contains the position
       * of the first nonselected character after the end of the selection in
       * the high order word.  
       */

      return(MAKELONG(ped->ichMinSel,ped->ichMaxSel));
      break;

    case EM_LIMITTEXT:
      /* wParam - max number of bytes that can be entered
         lParam - not used */
      /* effects: Specifies the maximum number of bytes of text the user may
       * enter. If maxLength is 0, we may enter MAXINT number of characters.  
       */
      if (ped->fSingle)
        {
          if (wParam)
              wParam = umin(0x7FFEu,wParam);
          else
              wParam = 0x7FFEu;
        }

      if (wParam)
          ped->cchTextMax = (ICH)wParam;
      else
          ped->cchTextMax = 0xFFFFu;
      break;

    case EM_SETMODIFY:
      /* wParam - specifies the new value for the modify flag 
         lParam - not used */
      /*
       * effects: Sets the state of the modify flag for this edit control.
       */
      ped->fDirty = wParam;
      break;

    case EM_SETPASSWORDCHAR:
      /* wParam - sepecifies the new char to display instead of the real text.
         if null, display the real text. */
      ECSetPasswordChar(ped, wParam);
      break;

    case EM_GETFIRSTVISIBLE:
      /* wParam - not used 
         lParam - not used */
      /* effects: Returns the first visible char for single line edit controls
       * and returns the first visible line for multiline edit controls. 
       */
      return((LONG)(WORD)ped->screenStart);
      break;

    case EM_SETREADONLY:
      /* wParam - state to set read only flag to */
      ped->fReadOnly = wParam;
      lParam = GetWindowLong(ped->hwnd, GWL_STYLE);
      if (wParam)
          lParam |= ES_READONLY;
      else
          lParam &= (~ES_READONLY);
      SetWindowLong(ped->hwnd, GWL_STYLE, lParam);
      return(1L);
      break;

    /* Messages handled differently for single and multi line edit controls */
    case WM_CREATE:
      /* Since the ped for this edit control is not defined, we have to check
       * the style directly.  
       */
      if (GetWindowLong(hwnd, GWL_STYLE) & ES_MULTILINE)
         return(MLEditWndProc(hwnd, ped, message, wParam, lParam));
      else
         return(SLEditWndProc(hwnd, ped, message, wParam, lParam));
      break;
      
    case WM_NCCREATE:
      return(ECNcCreate(hwnd, (LPCREATESTRUCT)lParam));
      break;


    default:
      if (ped->fSingle)
          return(SLEditWndProc(hwnd, ped, message, wParam, lParam));
      else
          return(MLEditWndProc(hwnd, ped, message, wParam, lParam));
      break;
  } /* switch (message) */

  return(1L);
} /* EditWndProc */



void NEAR PASCAL ECFindXORblks(lpOldBlk, lpNewBlk, lpBlk1, lpBlk2)

/*
 *  This finds the XOR of lpOldBlk and lpNewBlk and returns resulting blocks
 *  through the lpBlk1 and lpBlk2; This could result in a single block or
 *  at the maximum two blocks;
 *     If a resulting block is empty, then it's StPos field has -1.
 *  NOTE:
 *     When called from MultiLine edit control, StPos and EndPos fields of
 *     these blocks have the Starting line and Ending line of the block;
 *     When called from SingleLine edit control, StPos and EndPos fields 
 *     of these blocks have the character index of starting position and
 *     ending position of the block.
 */

LPBLOCK  lpOldBlk;
LPBLOCK  lpNewBlk;
LPBLOCK  lpBlk1;
LPBLOCK  lpBlk2;

{
  if(lpOldBlk -> StPos >= lpNewBlk ->StPos)
  {
	lpBlk1 -> StPos = lpNewBlk -> StPos;
	lpBlk1 -> EndPos = umin(lpOldBlk -> StPos, lpNewBlk -> EndPos);
  }
  else
  {
	lpBlk1 -> StPos = lpOldBlk -> StPos;
	lpBlk1 -> EndPos = umin(lpNewBlk -> StPos, lpOldBlk -> EndPos);
  }

  if(lpOldBlk -> EndPos <= lpNewBlk -> EndPos)
  {
	lpBlk2 -> StPos = umax(lpOldBlk -> EndPos, lpNewBlk -> StPos);
	lpBlk2 -> EndPos = lpNewBlk -> EndPos;
  }
  else
  {
	lpBlk2 -> StPos = umax(lpNewBlk -> EndPos, lpOldBlk -> StPos);
	lpBlk2 -> EndPos = lpOldBlk -> EndPos;
  }
}

/*
 *   This function finds the XOR between two selection blocks(OldBlk and NewBlk)
 *   and returns the resulting areas thro the same parameters; If the XOR of
 *   both the blocks is empty, then this returns FALSE; Otherwise TRUE.
 *   
 *  NOTE:
 *     When called from MultiLine edit control, StPos and EndPos fields of
 *     these blocks have the Starting line and Ending line of the block;
 *     When called from SingleLine edit control, StPos and EndPos fields 
 *     of these blocks have the character index of starting position and
 *     ending position of the block.
 */
BOOL FAR PASCAL ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, OldBlk, 
								      NewBlk)

PED	ped;
ICH	ichOldMinSel;
ICH	ichOldMaxSel;
LPBLOCK   OldBlk;
LPBLOCK   NewBlk;

{
  BLOCK Blk[2];
  int	iBlkCount = 0;
  int	i;


  Blk[0].StPos = Blk[0].EndPos = Blk[1].StPos = Blk[1].EndPos = -1;


  /* Check if the Old selection block existed */
  if(ichOldMinSel != ichOldMaxSel)
    {
	/* Yes! Old block existed. */
	Blk[0].StPos = OldBlk -> StPos;
	Blk[0].EndPos = OldBlk -> EndPos;
	iBlkCount++;
    }

  /* Check if the new Selection block exists */
  if(ped -> ichMinSel != ped -> ichMaxSel)
    {
	/* Yes! New block exists */
	Blk[1].StPos = NewBlk -> StPos;
	Blk[1].EndPos = NewBlk -> EndPos;
	iBlkCount++;
    }

  /* If both the blocks exist find the XOR of them */
  if(iBlkCount == 2)
  {
	/* Check if both blocks start at the same character position */
	if(ichOldMinSel == ped->ichMinSel)
	{
	    /* Check if they end at the same character position */
	    if(ichOldMaxSel == ped -> ichMaxSel)
		return(FALSE);  /* Nothing changes */

#ifdef FE_SB
            /* This look like bug, Because it uses min/max to compare
             * two ICH values even if ICH is unsigned!
             */
	    Blk[0].StPos = umin(NewBlk -> EndPos, OldBlk -> EndPos);
	    Blk[0].EndPos = umax(NewBlk -> EndPos, OldBlk -> EndPos);
#else
	    Blk[0].StPos = min(NewBlk -> EndPos, OldBlk -> EndPos);
	    Blk[0].EndPos = max(NewBlk -> EndPos, OldBlk -> EndPos);
#endif
	    Blk[1].StPos = -1;
	}
	else
	{
	    if(ichOldMaxSel == ped -> ichMaxSel)
	    {
	        Blk[0].StPos = umin(NewBlk -> StPos, OldBlk -> StPos);
	        Blk[0].EndPos = umax(NewBlk -> StPos, OldBlk -> StPos);
	        Blk[1].StPos = -1;
	    }
	    else
		ECFindXORblks(OldBlk, NewBlk, &Blk[0], &Blk[1]);
	}
  }

  LCopyStruct((LPSTR)&Blk[0], (LPSTR)OldBlk, sizeof(BLOCK));
  LCopyStruct((LPSTR)&Blk[1], (LPSTR)NewBlk, sizeof(BLOCK));

  return(TRUE);  /* Yup , There is something to paint */
}


#ifdef FE_SB

/*
 * Set DBCS Vector for specified character set.
 */
VOID FAR PASCAL ECGetDBCSVector( ped )
PED ped;
{
    HANDLE hTable;
    PBYTE pTable, pDBCS;
    unsigned i;

    switch( ped->charSet ) {
         case SHIFTJIS_CHARSET:		/* 128 -> Japan */
             ped->DBCSVector[0] = 0x81;
             ped->DBCSVector[1] = 0x9f;
             ped->DBCSVector[2] = 0xe0;
             ped->DBCSVector[3] = 0xfc;
             break;
         case CHINESEBIG5_CHARSET:      /* 136 -> Taiwan */
             ped->DBCSVector[0] = 0x81;
             ped->DBCSVector[1] = 0xfe;
             break;
         case GB2312_CHARSET:           /* 134 -> China KKFIX 10/19/96 Change GB2312 -> GBK Code range*/
             ped->DBCSVector[0] = 0x81;
             ped->DBCSVector[1] = 0xfe;
             break;
         case HANGEUL_CHARSET:
             ped->DBCSVector[0] = 0x81;
             ped->DBCSVector[1] = 0xfe;
             break;
         default:
             ped->DBCSVector[0] = 0x0;
             break;
    }
    /* If we can allocate 256 bytes of local memory, edit control
     * operations are more comfortable
     */
    if ((ped->hDBCSVector = LocalAlloc( LHND, sizeof(BYTE)*256 )) == NULL)
         return;

    pTable = (PBYTE)LocalLock( ped->hDBCSVector );
    pDBCS = ped->DBCSVector;
    while(pDBCS[0]) {
         for (i = pDBCS[0]; i <= pDBCS[1]; i++) pTable[i] = 1;
         pDBCS += 2;
    }
    LocalUnlock( ped->hDBCSVector );
}

/*
 * Advance string pointer for Edit Control use only.
 */
LPSTR FAR PASCAL ECAnsiNext( ped, lpCurrent )
PED ped;
LPSTR lpCurrent;
{
	return lpCurrent+((ECIsDBCSLeadByte(ped,*lpCurrent)==TRUE)?2:1);
}

/*
 * Decrement string pointer for Edit Control use only.
 */
LPSTR FAR PASCAL ECAnsiPrev( ped, lpBase, lpStr )
PED ped;
LPSTR lpBase, lpStr;
{
    LPSTR lpCurrent = lpStr;

// human C discompiler version 1.0---
//;       parmD   pFirst                  ; [bx+10] es:di
//;       parmD   pStr                    ; [bx+6] ds:si
//
//        cmp     si,di           ; pointer to first char?
//        jz      ap5             ; yes, just quit

    if (lpBase == lpCurrent)
         return lpBase;

//	dec	si		; backup once
//	cmp	si,di		; pointer to first char?
//	jz	ap5		; yse, just quit

    if (--lpCurrent == lpBase)
         return lpBase;

//ap1:
//	dec	si		; backup once
//	mov	al, [si]	; fetch a character
//        cCall   IsDBCSLeadByte,<ax>  ; DBCS lead byte candidate?
//	test	ax,ax		;
//	jz	ap2		; jump if not.
//	cmp	si,di		; backword exhausted?
//	jz	ap3		; jump if so
//	jmp	ap1		; repeat if not

    do {
         lpCurrent--;
         if (!ECIsDBCSLeadByte(ped, *lpCurrent)) {
             lpCurrent++;
             break;
         }
    } while(lpCurrent != lpBase);

//ap2:
//	inc	si		; adjust pointer correctly
//ap3:

    return lpStr - (((lpStr - lpCurrent) & 1) ? 1 : 2);

//	mov	bx, [bp+6]	;
//	mov	di, bx		; result in DI
//	dec	di		;
//	sub	bx, si		; how many characters backworded
//	test	bx, 1		; see even or odd...
//	jnz	ap4		; odd - previous char is SBCS
//	dec	di		; make DI for DBCS
//ap4:
//	mov	si, di		; final result in SI
//ap5:
//	mov	ax,si
//	mov	dx,ds
//
//	pop     di
//        pop     si
//        pop     ds
//
//	pop	bp
//        ret     8
//cEnd    nogen
}

/*
 * Test to see DBCS lead byte or not - Edit Control use only.
 */
BOOL FAR PASCAL ECIsDBCSLeadByte( ped, cch )
PED ped;
BYTE cch;
{
    BYTE ch1, ch2;
    PBYTE pTable;

    if (!ped->fDBCS)
        return FALSE;

    if (ped->hDBCSVector) {
        pTable = (PBYTE)LMHtoP(ped->hDBCSVector);
        return pTable[ cch ];
    }

    pTable = ped->DBCSVector;
    while( *pTable ) {
         ch1 = *pTable++;
         ch2 = *pTable++;
         if (cch >= ch1 && cch <= ch2)
             return TRUE;
    }
    return FALSE;
}

/*
 * Assemble two WM_CHAR messages to single DBCS character.
 * If program detects first byte of DBCS character in WM_CHAR message,
 * it calls this function to obtain second WM_CHAR message from queue.
 * finally this routine assembles first byte and second byte into single
 * DBCS character.
 */
int FAR PASCAL DBCSCombine(hwnd, ch)
register HWND   hwnd;
int             ch;
{
    MSG     msg;
    int     i;

    i = 10;    /* loop counter to avoid the infinite loop */
    while (!PeekMessage((LPMSG)&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return( NULL );
        Yield();
    }

    return ((unsigned)ch | ((unsigned)(msg.wParam)<<8));
}

/*
 * This function adjusts a current pointer correctly. If a current
 * pointer is lying between DBCS first byte and second byte, this
 * function adjusts a current pointer to a first byte of DBCS position
 * by decrement once.
 */
ICH FAR PASCAL ECAdjustIch( ped, lpstr, ch )
PED ped;
LPSTR lpstr;
ICH ch;
{
    ICH newch = ch;

    if ( newch == 0 )
	return ( newch );

    if ( !ECIsDBCSLeadByte(ped, lpstr[--newch] ) )
	return ( ch );	// previous char is SBCS
    while(1) {
	if (!ECIsDBCSLeadByte(ped, lpstr[newch] )) {
	    newch++;
	    break;
	}
	if (newch)
	    newch--;
	else
	    break;
    }
    return ((ch - newch) & 1) ? ch-1 : ch;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\editsl.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDITSL.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* editsl.c - Edit controls rewrite.  Version II of edit controls.          */
/*                                                                          */
/*                                                                          */
/* Created:  24-Jul-88 davidds                                              */
/****************************************************************************/

#define  NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*                      Single Line Support Routines                        */
/****************************************************************************/

void FAR PASCAL SLSetCaretPosition(ped,hdc)
register PED ped;
HDC          hdc;
/* effects: If the window has the focus, find where the caret belongs and move
 * it there.  
 */
{
  int xPosition;
  /* We will only position the caret if we have the focus since we don't want
   * to move the caret while another window could own it.  
   */
  if (ped->fNoRedraw || !ped->fFocus)
      return;

  xPosition = SLIchToLeftXPos(ped, hdc, ped->ichCaret);
  if (!ped->fAutoHScroll)
      /* Don't leet caret go out of bounds of edit contol if there is too much
       * text in a non scrolling edit control. 
       */
      xPosition = min(xPosition, ped->rcFmt.right-1);

  SetCaretPos(xPosition, ped->rcFmt.top);
}


int NEAR PASCAL SLIchToLeftXPos(ped, hdc, ich)
register PED     ped;
HDC              hdc;
ICH              ich;
/* effects: Given a character index, find its (left side) x coordinate within
 * the ped->rcFmt rectangle assuming the character ped->screenStart is at
 * coordinates (ped->rcFmt.top, ped->rcFmt.left).  A negative value is
 * returned if the character ich is to the left of ped->screenStart.  WARNING:
 * ASSUMES AT MOST 1000 characters will be VISIBLE at one time on the screen.
 * There may be 64K total characters in the editcontrol, but we can only
 * display 1000 without scrolling.  This shouldn't be a problem obviously.  
 */
{
  int   textExtent;
  register PSTR pText;

  /* Check if we are adding lots and lots of chars. A paste for example could
   * cause this and GetTextExtents could overflow on this.  
   */
  if (ich > ped->screenStart && ich - ped->screenStart > 1000)
      return(30000);
  if (ped->screenStart > ich && ped->screenStart - ich > 1000)
      return(-30000);

  if (ped->fNonPropFont)
      return((ich-ped->screenStart)*ped->aveCharWidth + ped->rcFmt.left);

  /* Check if password hidden chars are being used. */
  if (ped->charPasswordChar)
      return((ich-ped->screenStart)*ped->cPasswordCharWidth+ped->rcFmt.left);
    
  pText = LocalLock(ped->hText);

  if (ped->screenStart <= ich)
    {
      textExtent = LOWORD(GetTextExtent(hdc,
                                    (LPSTR)(pText + ped->screenStart),
                                    ich-ped->screenStart));
      /* In case of signed/unsigned overflow since the text extent may be
       * greater than maxint.  This happens with long single line edit
       * controls. The rect we edit text in will never be greater than 30000
       * pixels so we are ok if we just ignore them.  
       */
      if (textExtent < 0 || textExtent > 31000)
          textExtent = 30000;
    }
  else
      textExtent = (-1) * 
                         (int)LOWORD(GetTextExtent(hdc,(LPSTR)(pText + ich),
                                              ped->screenStart-ich));

  LocalUnlock(ped->hText);

  return(textExtent-ped->charOverhang + ped->rcFmt.left);
}

/* effects: This finds out if the given ichPos falls within the current
 * Selection range and if so returns TRUE; Else returns FALSE.  
 */
BOOL NEAR PASCAL SLGetHiliteAttr(PED ped, ICH ichPos)
{
  return((ichPos >= ped->ichMinSel) && (ichPos < ped->ichMaxSel));
}

/* effects: This takes care of erasing the old selection and drawing the new
 * selection 
 */
void NEAR PASCAL SLRepaintChangedSelection(
	PED ped, HDC hdc,
	ICH ichOldMinSel, ICH ichOldMaxSel)
{
  BLOCK Blk[2];
  int   i;

  Blk[0].StPos = ichOldMinSel;
  Blk[0].EndPos = ichOldMaxSel;
  Blk[1].StPos = ped->ichMinSel;
  Blk[1].EndPos = ped->ichMaxSel;

  if(ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, 
                           (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1]))
  {
     UpdateWindow(ped->hwnd);
     /* Paint the rectangles where selection has changed */
     /* Paint both Blk[0] and Blk[1], if they exist */
     for(i = 0; i < 2; i++)
     {
        if (Blk[i].StPos != -1)
            SLDrawLine(ped, hdc, Blk[i].StPos, Blk[i].EndPos - Blk[i].StPos,
                       SLGetHiliteAttr(ped, Blk[i].StPos));
     }
  }
}


void FAR PASCAL SLChangeSelection(ped, hdc, ichNewMinSel, ichNewMaxSel)
register PED ped;
HDC          hdc;
ICH          ichNewMinSel;
ICH          ichNewMaxSel;
/* effects: Changes the current selection to have the specified starting and
 * ending values.  Properly highlights the new selection and unhighlights
 * anything deselected.  If NewMinSel and NewMaxSel are out of order, we swap
 * them. Doesn't update the caret position.  
 */
{
  ICH temp;
  ICH  ichOldMinSel;
  ICH  ichOldMaxSel;

  if (ichNewMinSel > ichNewMaxSel)
    {
      temp = ichNewMinSel;
      ichNewMinSel = ichNewMaxSel;
      ichNewMaxSel = temp;
    }
    ichNewMinSel = umin(ichNewMinSel, ped->cch);
    ichNewMaxSel = umin(ichNewMaxSel, ped->cch);

  /* Preserve the Old selection */
  ichOldMinSel = ped->ichMinSel;
  ichOldMaxSel = ped->ichMaxSel;

  /* Set new selection */
  ped->ichMinSel = ichNewMinSel;
  ped->ichMaxSel = ichNewMaxSel;

  /* We will find the intersection of current selection rectangle with the new
   * selection rectangle.  We will then invert the parts of the two rectangles
   * not in the intersection.  
   */

  if (!ped->fNoRedraw && (ped->fFocus || ped->fNoHideSel))
    {
      if (ped->fFocus)
          HideCaret(ped->hwnd);
      SLRepaintChangedSelection(ped, hdc, ichOldMinSel, ichOldMaxSel);
      SLSetCaretPosition(ped,hdc);
      if (ped->fFocus)
          ShowCaret(ped->hwnd);
    }
}


void NEAR PASCAL SLDrawLine(ped, hdc, ichStart, iCount, fSelStatus)

register PED   ped;
register HDC   hdc;
ICH            ichStart;
int            iCount;
BOOL           fSelStatus;

/* This draws the line starting from ichStart, iCount number of characters;
 * fSelStatus is TRUE, if it is to be drawn with the "selection" attribute.  
 */
{
  RECT   rc;
  HBRUSH hBrush;
  PSTR   pText;
  DWORD  rgbSaveBk;
  DWORD  rgbSaveText;
  int    iStCount;
  DWORD  rgbGray=0;

  if (ped->fNoRedraw)
      return;

  if (ichStart < ped->screenStart)
    {
      if (ichStart+iCount < ped->screenStart)
          return;

      iCount = iCount - (ped->screenStart-ichStart);
      ichStart = ped->screenStart;
    }

  CopyRect((LPRECT)&rc,(LPRECT)&ped->rcFmt);

  /* Set the proper clipping rectangle */
  ECSetEditClip(ped, hdc);

  pText = (PSTR) LocalLock(ped->hText);

  /* Calculates the rectangle area to be wiped out */
  if (iStCount = ichStart - ped->screenStart)
    {
      if (ped->charPasswordChar)
          rc.left += ped->cPasswordCharWidth * iStCount;
      else
          rc.left += LOWORD(GetTextExtent(hdc, 
                                          (LPSTR)(pText + ped->screenStart),
                                          iStCount)) -
                     ped->charOverhang;
    }

  if (ped->charPasswordChar)
      rc.right = rc.left + ped->cPasswordCharWidth * iCount;
  else
      rc.right = rc.left + LOWORD(GetTextExtent(hdc, 
                                            (LPSTR)(pText + ichStart), 
                                            iCount));
  /* Set the background mode before calling GetControlBrush so that the app
   * can change it to TRANSPARENT if it wants to.  
   */
  SetBkMode(hdc, OPAQUE);

  if (fSelStatus)
    {
      hBrush = ped->hbrHiliteBk;
      rgbSaveBk = SetBkColor(hdc, ped->rgbHiliteBk);
      rgbSaveText = SetTextColor(hdc, ped->rgbHiliteText);
    }
  else
    {
      /* We always want to send this so that the app has a chance to muck with
       * the DC 
       */
      hBrush = GetControlBrush(ped->hwnd, hdc, CTLCOLOR_EDIT);
    }

  if (ped->fDisabled && 
      (rgbGray = GetSysColor(COLOR_GRAYTEXT)))
    {
      /* Grey the text in the edit control if disabled. 
       */
      rgbSaveText = SetTextColor(hdc, rgbGray);
    }

  /* Erase the rectangular area before text is drawn. Note that we inflate the
   * rect by 1 so that the selection color has a one pixel border around the
   * text. 
   */
  InflateRect((LPRECT)&rc, 0, 1);
  /* Use paint rect so that the brush gets aligned if dithered. 
   */
  PaintRect(ped->hwndParent, ped->hwnd, hdc, hBrush, (LPRECT)&rc);
  InflateRect((LPRECT)&rc, 0, -1);
  
  if (ped->charPasswordChar)
    {
      for (iStCount = 0; iStCount < iCount; iStCount++)
           TextOut(hdc,
                   rc.left+iStCount*ped->cPasswordCharWidth,
                   rc.top,
                   (LPSTR)&ped->charPasswordChar,
                   1);
    }
  else
      TextOut(hdc,rc.left,rc.top,(LPSTR)(pText+ichStart),iCount);

  if (fSelStatus || rgbGray)
    {
      SetTextColor(hdc, rgbSaveText);
      if (fSelStatus)
          SetBkColor(hdc, rgbSaveBk);

    }

  LocalUnlock(ped->hText);
}

int  NEAR PASCAL SLGetBlkEnd(ped, ichStart, ichEnd, lpfStatus)
register  PED  ped;
register  ICH  ichStart;
ICH            ichEnd;
BOOL FAR       *lpfStatus;
/* Given a Starting point and and end point, this function returns whether the
 * first few characters fall inside or outside the selection block and if so,
 * howmany characters?  
 */
{
    *lpfStatus = FALSE;
    if (ichStart >= ped->ichMinSel)
      {
        if(ichStart >= ped->ichMaxSel)
            return(ichEnd - ichStart);
        *lpfStatus = TRUE;
        return(min(ichEnd, ped->ichMaxSel) - ichStart);
      }
    return(min(ichEnd, ped->ichMinSel) - ichStart);
}

void NEAR PASCAL SLDrawText(ped, hdc, ichStart)
register PED   ped;
register HDC   hdc;
ICH            ichStart;
/* effects:  Draws text for a single line edit control in the rectangle
 * specified by ped->rcFmt.  If ichStart == 0, starts drawing text at the left
 * side of the window starting at character index ped->screenStart and draws
 * as much as will fit.  If ichStart > 0, then it appends the characters
 * starting at ichStart to the end of the text showing in the window. (ie. We
 * are just growing the text length and keeping the left side
 * (ped->screenStart to ichStart characters) the same.  Assumes the hdc came
 * from ECGetEditDC so that the caret and such are properly hidden.  
 */
{
  ICH    cchToDraw;
  RECT   rc;

  PSTR   pText;
  BOOL   fSelStatus;
  int    iCount;
  ICH    ichEnd;
  BOOL   fNoSelection;

  if (ped->fNoRedraw)
      return;

  if (ichStart == 0)
      ichStart = ped->screenStart;

  CopyRect((LPRECT)&rc,(LPRECT)&ped->rcFmt);

  /* Find out how many characters will fit on the screen so that we don't do
   * any needless drawing.  
   */

  pText = (PSTR) LocalLock(ped->hText);

  cchToDraw = ECCchInWidth(ped, hdc, 
                           (LPSTR)(pText+ped->screenStart),
                           ped->cch-ped->screenStart,
                           rc.right - rc.left);
  ichEnd = ped->screenStart + cchToDraw;

  /*
   *  There is no selection if,
   *     1. MinSel and MaxSel are equal  OR
   *     2. (This has lost the focus AND Selection is to be hidden)
   */
  fNoSelection = ((ped->ichMinSel == ped->ichMaxSel) ||
                  (!ped->fFocus && !ped->fNoHideSel));
  while (ichStart < ichEnd)
    {
        if (fNoSelection)
          {
            fSelStatus = FALSE;
            iCount = ichEnd - ichStart;
          }
        else
            iCount = SLGetBlkEnd(ped, ichStart, ichEnd, 
		                 (BOOL FAR *)&fSelStatus);
			 
        SLDrawLine(ped, hdc, ichStart, iCount, fSelStatus);
        ichStart += iCount;
    }

  if (cchToDraw)
    {
      /* Check if password hidden chars are being used. */
      if (ped->charPasswordChar)
          rc.left += ped->cPasswordCharWidth * cchToDraw; 
      else 
          rc.left += LOWORD(GetTextExtent(hdc, 
                          (LPSTR)(pText + ped->screenStart), cchToDraw));
    }

  LocalUnlock(ped->hText);

  /* Check if anything to be erased on the right hand side */
  if (rc.left < rc.right)
    {
      SetBkMode(hdc, OPAQUE);
      /* Erase the rectangular area before text is drawn. Note that we inflate
       * the rect by 1 so that the selection color has a one pixel border
       * around the text. 
       */
      InflateRect((LPRECT)&rc, 0, 1);
      PaintRect(ped->hwndParent, ped->hwnd, hdc, NULL, (LPRECT)&rc);
    }
            
  SLSetCaretPosition(ped, hdc);
}


BOOL FAR PASCAL SLScrollText(ped, hdc)
register PED  ped;
HDC           hdc;
/* effects: Scrolls the text to bring the caret into view. If the text is
 * scrolled, the current selection is unhighlighted.  Returns TRUE if the text
 * is scrolled else returns false.  
 */
{
  register PSTR pText;
  ICH scrollAmount = (ped->rcFmt.right-ped->rcFmt.left)/4/ped->aveCharWidth+1;
  ICH newScreenStartX = ped->screenStart;

  if (!ped->fAutoHScroll)
      return(FALSE);

  /* Calculate the new starting screen position */
  if (ped->ichCaret <= ped->screenStart)
    {
      /* Caret is to the left of the starting text on the screen we must
       * scroll the text backwards to bring it into view.  Watch out when
       * subtracting unsigned numbers when we have the possibility of going
       * negative.  
       */
      if (ped->ichCaret > scrollAmount)
          newScreenStartX = ped->ichCaret - scrollAmount;
      else
          newScreenStartX = 0;
    }
  else
    {
      pText = (PSTR) LocalLock(ped->hText);
      if ((ped->ichCaret != ped->screenStart) &&
          (ECCchInWidth(ped, hdc, (LPSTR)(pText+ped->screenStart),
                  ped->ichCaret - ped->screenStart, 
                  ped->rcFmt.right-ped->rcFmt.left)  < 
           ped->ichCaret - ped->screenStart))
        {
           newScreenStartX = ((ped->ichCaret < scrollAmount*2) ? 0 :
                               ped->ichCaret - scrollAmount*2);
        }
      LocalUnlock(ped->hText);
    }

#ifdef FE_SB
  pText = (PSTR) LocalLock(ped->hText);
  newScreenStartX = ECAdjustIch( ped,pText,newScreenStartX );
  LocalUnlock(ped->hText);
#endif

  if (ped->screenStart != newScreenStartX)
    {
      ped->screenStart = newScreenStartX;
      SLDrawText(ped, hdc, 0);
      /* Caret pos is set by drawtext */
      return(TRUE);
    }

  return(FALSE);

}


ICH FAR PASCAL SLInsertText(ped, lpText, cchInsert)
register PED   ped;
LPSTR          lpText;
register ICH   cchInsert;
/* effects: Adds up to cchInsert characters from lpText to the ped starting at
 * ichCaret. If the ped only allows a maximum number of characters, then we
 * will only add that many characters to the ped and send a EN_MAXTEXT
 * notification code to the parent of the ec.  Also, if !fAutoHScroll, then we
 * only allow as many chars as will fit in the client rectangle. The number of
 * characters actually added is returned (could be 0). If we can't allocate
 * the required space, we notify the parent with EN_ERRSPACE and no characters
 * are added.  
 */
{
  HDC  hdc;
  PSTR pText;
  ICH  cchInsertCopy = cchInsert;
  int  textWidth;

  /* First determine exactly how many characters from lpText we can insert
   * into the ped.  
   */
  if (!ped->fAutoHScroll)
    {
      pText = (PSTR)LocalLock(ped->hText);
      hdc = ECGetEditDC(ped, TRUE);

      /* If ped->fAutoHScroll bit is not set, then we only insert as many
       * characters as will fit in the ped->rcFmt rectangle upto a maximum of
       * ped->cchTextMax - ped->cch characters. Note that if password style is
       * on, we allow the user to enter as many chars as the number of
       * password chars which fit in the rect.  
       */
      if (ped->cchTextMax <= ped->cch)
          cchInsert = 0;
      else
        {
          cchInsert = umin(cchInsert, (unsigned)(ped->cchTextMax - ped->cch));
          if (ped->charPasswordChar)
     	      textWidth = ped->cch * ped->cPasswordCharWidth;
          else
              textWidth = LOWORD(GetTextExtent(hdc, (LPSTR)pText, ped->cch));

          cchInsert = umin(cchInsert,
                       ECCchInWidth(ped, hdc, lpText, cchInsert, 
                                    ped->rcFmt.right-ped->rcFmt.left-
                                    textWidth));
        }

      LocalUnlock(ped->hText);
      ECReleaseEditDC(ped, hdc, TRUE);
    }
  else
    {
      if (ped->cchTextMax <= ped->cch)
          cchInsert = 0;
      else
          cchInsert = umin((unsigned)(ped->cchTextMax - ped->cch), cchInsert);
    }

  /* Now try actually adding the text to the ped */
  if (cchInsert && !ECInsertText(ped, lpText, cchInsert))
    {
      ECNotifyParent(ped, EN_ERRSPACE);
      return(0);
    }

  if (cchInsert)
      ped->fDirty = TRUE; /* Set modify flag */

  if (cchInsert < cchInsertCopy)
      /* Notify parent that we couldn't insert all the text requested */
      ECNotifyParent(ped, EN_MAXTEXT);

  /* Update selection extents and the caret position.  Note that ECInsertText
   * updates ped->ichCaret, ped->ichMinSel, and ped->ichMaxSel to all be after
   * the inserted text.  
   */

  return(cchInsert);
}


ICH PASCAL NEAR SLPasteText(register PED ped)
/* effects: Pastes a line of text from the clipboard into the edit control
 * starting at ped->ichMaxSel.  Updates ichMaxSel and ichMinSel to point to
 * the end of the inserted text.  Notifies the parent if space cannot be
 * allocated. Returns how many characters were inserted.  
 */
{
  HANDLE           hData;
  LPSTR            lpchClip;
  LPSTR            lpchClip2;
  register ICH     cchAdded;
  ICH              clipLength;

  if (!OpenClipboard(ped->hwnd))
      return(0);

  if (!(hData = GetClipboardData(CF_TEXT)))
    {
      CloseClipboard();
      return(0);
    }
    
  lpchClip2 = lpchClip = (LPSTR) GlobalLock(hData);

  /* Find the first carrage return or line feed.  Just add text to that point.
   */
  clipLength = (WORD)lstrlen(lpchClip);
  for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
       if (*lpchClip2++ == 0x0D)
           break;

  /* Insert the text (SLInsertText checks line length) */
  cchAdded = SLInsertText(ped, lpchClip, cchAdded);

  GlobalUnlock(hData);
  CloseClipboard();

  return(cchAdded);
}


void NEAR PASCAL SLReplaceSelHandler(register PED ped,
                                     LPSTR        lpText)
/* effects: Replaces the text in the current selection with the given text. 
 */
{
  BOOL fUpdate;
  HDC  hdc;

  SwapHandle(&lpText);
  ECEmptyUndo(ped);
  fUpdate = (BOOL)ECDeleteText(ped);
  ECEmptyUndo(ped);
  SwapHandle(&lpText);
  fUpdate = (BOOL)SLInsertText(ped, lpText, lstrlen(lpText)) || fUpdate;
  ECEmptyUndo(ped);
  
  if (fUpdate)
    {
      ECNotifyParent(ped, EN_UPDATE);
      hdc = ECGetEditDC(ped,FALSE);
      if (!SLScrollText(ped,hdc))
          SLDrawText(ped,hdc,0);
      ECReleaseEditDC(ped,hdc,FALSE);
      ECNotifyParent(ped,EN_CHANGE);
    }
}



void FAR PASCAL SLCharHandler(ped, keyValue, keyMods)
register PED  ped;
WORD          keyValue;
int           keyMods;
/* effects: Handles character input (really, no foolin') 
 */
{
  register HDC  hdc;
  unsigned char keyPress = LOBYTE(keyValue);
  BOOL          updateText = FALSE;
#ifdef FE_SB
  PSTR pText;
  int InsertTextLen = 0;
  WORD DBCSkey;
#endif

  if (ped->fMouseDown || ped->fReadOnly)
      /* Don't do anything if we are in the middle of a mousedown deal or if
       * this is a read only edit control. 
       */
      return;

  if ((keyPress == BACKSPACE) || (keyPress >= ' '))
    {
      /* Delete the selected text if any */
      if (ECDeleteText(ped))
          updateText=TRUE;
    }

  switch(keyPress)
  {
    case BACKSPACE:
      /* Delete any selected text or delete character left if no sel */
      if (!updateText && ped->ichMinSel)
        {
          /* There was no selection to delete so we just delete character 
             left if available */
#ifdef FE_SB
          pText = LMHtoP( ped->hText );
          if( ECAnsiPrev( ped,pText, pText+ped->ichMinSel) == pText+ped->ichMinSel-2)
              ped->ichMinSel--;
#endif
          ped->ichMinSel--;
          (void) ECDeleteText(ped);
          updateText = TRUE;
        }
      break;

    default:
      if (keyPress >= ' ')
        {
#ifdef FE_SB
          InsertTextLen = 1;
          if( IsDBCSLeadByte( keyPress ) )
              if( ( DBCSkey = DBCSCombine( ped->hwnd, keyPress ) ) != NULL )
                  if( SLInsertText( ped, (LPSTR)&DBCSkey, 2 ) == 2){
                      InsertTextLen = 2;
                      updateText = TRUE;
                  }else
                      MessageBeep(0);
              else
                  MessageBeep(0);
          else
#endif
          if (SLInsertText(ped, (LPSTR) &keyPress, 1))
              updateText = TRUE;
          else
              /* Beep. Since we couldn't add the text */
              MessageBeep(0);
        }
      else
          /* User hit an illegal control key */
          MessageBeep(0);

      break;
  }


  if (updateText) 
    {
      /* Dirty flag (ped->fDirty) was set when we inserted text */
      ECNotifyParent(ped, EN_UPDATE);
      hdc = ECGetEditDC(ped,FALSE);
      if (!SLScrollText(ped,hdc))
#ifdef FE_SB
          SLDrawText(ped,hdc,(ped->ichCaret == 0 ? 0 :ped->ichCaret - InsertTextLen));
#else
          SLDrawText(ped,hdc,(ped->ichCaret == 0 ? 0 :ped->ichCaret - 1));
#endif
      ECReleaseEditDC(ped,hdc,FALSE);
      ECNotifyParent(ped,EN_CHANGE);
    }

}



void NEAR PASCAL SLKeyDownHandler(register PED  ped,
                                  WORD          virtKeyCode,
				  int           keyMods)
/* effects: Handles cursor movement and other VIRT KEY stuff.  keyMods allows
 * us to make SLKeyDownHandler calls and specify if the modifier keys (shift
 * and control) are up or down.  This is useful for imnplementing the
 * cut/paste/clear messages for single line edit controls.  If keyMods == 0,
 * we get the keyboard state using GetKeyState(VK_SHIFT) etc. Otherwise, the
 * bits in keyMods define the state of the shift and control keys.  
 */
{
  HDC  hdc;


  /* Variables we will use for redrawing the updated text */
  register ICH newMaxSel = ped->ichMaxSel;
  ICH          newMinSel = ped->ichMinSel;

  /* Flags for drawing the updated text */
  BOOL updateText = FALSE;
  BOOL changeSelection = FALSE; /* new selection is specified by 
                                   newMinSel, newMaxSel */

  /* Comparisons we do often */
  BOOL MinEqMax = (newMaxSel == newMinSel);
  BOOL MinEqCar = (ped->ichCaret == newMinSel);
  BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

  /* State of shift and control keys. */
  int scState = 0; 

  /* Combo box support */
  BOOL fIsListVisible;
  BOOL fIsExtendedUI;

#ifdef FE_SB
  PSTR pText;
#endif

  if (ped->fMouseDown)
    {
      /* If we are in the middle of a mouse down handler, then don't do
       * anything. ie. ignore keyboard input.
       */
      return;
    }

  if (!keyMods)
    {
      /* Get state of modifier keys for use later. */
      scState =  ((GetKeyState(VK_CONTROL) & 0x8000) ? 1 : 0); 
      scState += ((GetKeyState(VK_SHIFT) & 0x8000) ? 2 : 0); 
    }
  else
      scState = ((keyMods == NOMODIFY) ? 0 : keyMods);



  switch(virtKeyCode)
  {
    case VK_UP:
      if (ped->listboxHwnd)
        {
          /* Handle Combobox support */
          fIsExtendedUI = SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0L);
          fIsListVisible = SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L);

          if (!fIsListVisible && fIsExtendedUI)
            {
              /* For TandyT
	       */
DropExtendedUIListBox:
              /* Since an extendedui combo box doesn't do anything on f4, we
	       * turn off the extended ui, send the f4 to drop, and turn it
	       * back on again.
	       */
              SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 0, 0L);
              SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0L);
              SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 1, 0L);
              return;
            }
          else
              goto SendKeyToListBox;
        }

      /* else fall through */
      
    case VK_LEFT:
      /* If the caret isn't already at 0, we can move left */
      if (ped->ichCaret)
        {
          switch (scState)
          {
             case NONEDOWN:
               /* Clear selection, move caret left */
#ifdef FE_SB
               pText = LMHtoP( ped->hText );
               if( ECAnsiPrev( ped, pText, pText + ped->ichCaret ) ==
                   pText + ped->ichCaret - 2 )
                 ped->ichCaret--;
#endif
               ped->ichCaret--;
               newMaxSel = newMinSel = ped->ichCaret;
               break;

             case CTRLDOWN:
               /* Clear selection, move caret word left */
               ped->ichCaret = LOWORD(ECWord(ped,ped->ichCaret,TRUE));
               newMaxSel = newMinSel = ped->ichCaret;
               break;

             case SHFTDOWN:
               /* Extend selection, move caret left */
#ifdef FE_SB
               pText = LMHtoP( ped->hText );
               if( ECAnsiPrev( ped, pText, pText + ped->ichCaret ) ==
                   pText + ped->ichCaret - 2 )
                 ped->ichCaret--;
#endif
               ped->ichCaret--;
               if (MaxEqCar && !MinEqMax)
                   /* Reduce selection extent */
                   newMaxSel = ped->ichCaret;
               else
                   /* Extend selection extent */
                   newMinSel = ped->ichCaret;
               break;

             case SHCTDOWN:
               /* Extend selection, move caret word left */
               ped->ichCaret = LOWORD(ECWord(ped,ped->ichCaret,TRUE));
               if (MaxEqCar && !MinEqMax)
                 {
                   /* Reduce selection extent */
                   /*
                    * Hint: Suppose WORD.  OR is selected. Cursor between R
                    * and D. Hit select word left, we want to just select the
                    * W and leave cursor before the W.
                    */
                   newMinSel = ped->ichMinSel;
                   newMaxSel = ped->ichCaret;
                 }
               else
                   /* Extend selection extent */
                   newMinSel = ped->ichCaret;
               break;
          }
 
          changeSelection = TRUE;
        }
      else
	{
          /* If the user tries to move left and we are at the 0th character 
             and there is a selection, then cancel the selection. */
          if (ped->ichMaxSel != ped->ichMinSel && 
              (scState == NONEDOWN || scState == CTRLDOWN))
            {
              changeSelection = TRUE;
              newMaxSel = newMinSel = ped->ichCaret;
            }
        }
      break;

    case VK_DOWN:
      if (ped->listboxHwnd)
        {
          /* Handle Combobox support */
          fIsExtendedUI = SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0L);
          fIsListVisible = SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L);

          if (!fIsListVisible && fIsExtendedUI)
            {
              /* For TandyT
	       */
              goto DropExtendedUIListBox;
            }
          else
              goto SendKeyToListBox;
        }

      /* else fall through */
      
    case VK_RIGHT:
      /*
       * If the caret isn't already at ped->cch, we can move right.
       */
      if (ped->ichCaret < ped->cch)
        {
          switch (scState)
          {
             case NONEDOWN:
               /* Clear selection, move caret right */
#ifdef FE_SB
               pText = LMHtoP( ped->hText ) + ped->ichCaret;
               if( ECIsDBCSLeadByte( ped, *pText ) )
                 ped->ichCaret++;
#endif
               ped->ichCaret++;
               newMaxSel = newMinSel = ped->ichCaret;
               break;

             case CTRLDOWN:
               /* Clear selection, move caret word right */
               ped->ichCaret = HIWORD(ECWord(ped,ped->ichCaret,FALSE));
               newMaxSel = newMinSel = ped->ichCaret;
               break;

             case SHFTDOWN:
               /* Extend selection, move caret right */
#ifdef FE_SB
               pText = LMHtoP( ped->hText ) + ped->ichCaret;
               if( ECIsDBCSLeadByte( ped, *pText ) )
                 ped->ichCaret++;
#endif
               ped->ichCaret++;
               if (MinEqCar && !MinEqMax)
                   /* Reduce selection extent */
                   newMinSel = ped->ichCaret;
               else
                   /* Extend selection extent */
                   newMaxSel = ped->ichCaret;
               break;

             case SHCTDOWN:
               /* Extend selection, move caret word right */
               ped->ichCaret = HIWORD(ECWord(ped,ped->ichCaret,FALSE));
               if (MinEqCar && !MinEqMax)
                 {
                   /* Reduce selection extent */
                   newMinSel = ped->ichCaret;
                   newMaxSel = ped->ichMaxSel;
                 }
               else
                   /* Extend selection extent */
                   newMaxSel = ped->ichCaret;
               break;
           }

           changeSelection = TRUE;
        }
      else
	{
          /* If the user tries to move right and we are at the last character 
             and there is a selection, then cancel the selection. */
          if (ped->ichMaxSel != ped->ichMinSel &&
              (scState == NONEDOWN || scState == CTRLDOWN))
            {
              newMaxSel = newMinSel = ped->ichCaret;
              changeSelection = TRUE;
            }
        }
      break;

    case VK_HOME:
      ped->ichCaret = 0;
      switch (scState)
        {
           case NONEDOWN:
           case CTRLDOWN:
             /* Clear selection, move caret home */
             newMaxSel = newMinSel = ped->ichCaret;
             break;

           case SHFTDOWN:
           case SHCTDOWN:
             /* Extend selection, move caret home */
             if (MaxEqCar && !MinEqMax)
               {
                 /* Reduce/negate selection extent */
                 newMinSel = 0;
                 newMaxSel = ped->ichMinSel;
               }
             else
                 /* Extend selection extent */
                 newMinSel = ped->ichCaret;
             break;
         }

      changeSelection = TRUE; 
      break;

    case VK_END:
      newMaxSel = ped->ichCaret = ped->cch;
      switch (scState)
        {
           case NONEDOWN:
           case CTRLDOWN:
             /* Clear selection, move caret to end of text */
             newMinSel = ped->cch;
             break;

           case SHFTDOWN:
           case SHCTDOWN:
             /* Extend selection, move caret to end of text */
             if (MinEqCar && !MinEqMax)
                 /* Reduce/negate selection extent */
                 newMinSel = ped->ichMaxSel;
             /* else Extend selection extent */
             break;
         }

      changeSelection = TRUE;
      break;

    case VK_DELETE:
      if (ped->fReadOnly)
          break;

      switch (scState)
        {
           case NONEDOWN:
             /*	Clear selection.  If no selection, delete (clear) character
	      * right.  
	      */
             if ((ped->ichMaxSel<ped->cch) && 
                 (ped->ichMinSel==ped->ichMaxSel))
               {
                 /* Move cursor forwards and simulate a backspace.  
		  */
#ifdef FE_SB
                 pText = LMHtoP( ped->hText ) + ped->ichCaret;
                 if( ECIsDBCSLeadByte( ped, *pText ) )
                   ped->ichCaret++;
#endif
                 ped->ichCaret++;
                 ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                 SLCharHandler(ped, (WORD) BACKSPACE, 0);
               }
             if (ped->ichMinSel != ped->ichMaxSel)
                 SLCharHandler(ped, (WORD) BACKSPACE, 0);
             break;

           case SHFTDOWN:
             /*	CUT selection ie. remove and copy to clipboard, or if no
	      * selection, delete (clear) character left.  
	      */

             if (SendMessage(ped->hwnd, WM_COPY, (WORD)0,0L) ||
                 (ped->ichMinSel == ped->ichMaxSel))
                 /* If copy successful, delete the copied text by simulating a
		  * backspace message which will redraw the text and take care
		  * of notifying the parent of changes.  Or if there is no
		  * selection, just delete char left.  
		  */
                 SLCharHandler(ped, (WORD) BACKSPACE, 0);
             break;

           case CTRLDOWN:
             /*	Delete to end of line if no selection else delete (clear)
	      * selection. 
	      */
             if ((ped->ichMaxSel<ped->cch) && 
                 (ped->ichMinSel==ped->ichMaxSel))
               {
                 /* Move cursor to end of line and simulate a backspace.  
		  */
                 ped->ichMaxSel = ped->ichCaret = ped->cch;
               }
             if (ped->ichMinSel != ped->ichMaxSel)
                 SLCharHandler(ped, (WORD) BACKSPACE, 0);
             break;
        }
 
      /* No need to update text or selection since BACKSPACE message does it
       * for us.  
       */
      break;

    case VK_INSERT:
      switch (scState)
        {
           case CTRLDOWN:
             /* Copy current selection to clipboard */
             SendMessage(ped->hwnd, WM_COPY, (WORD)NULL, (LONG)NULL);
             break;

           case SHFTDOWN:
             if (ped->fReadOnly)
                 break;

             /* Insert contents of clipboard (PASTE) */
             /* Unhighlight current selection and delete it, if any */
             ECDeleteText(ped);
             SLPasteText(ped);
             updateText = TRUE;
             ECNotifyParent(ped, EN_UPDATE);
             break;
        }
      break;

    case VK_F4:
    case VK_PRIOR:
    case VK_NEXT:
      /* Send keys to the listbox if we are a part of a combo box. This
       * assumes the listbox ignores keyup messages which is correct right
       * now.  
       */
      if (ped->listboxHwnd)
        {
SendKeyToListBox:
          /* Handle Combobox support */
          SendMessage(ped->listboxHwnd, WM_KEYDOWN, virtKeyCode, 0L);
          return;
        }
  }



  if (changeSelection || updateText)
    {
      hdc = ECGetEditDC(ped,FALSE);
      /* Scroll if needed */
      SLScrollText(ped,hdc);

      if (changeSelection)
          SLChangeSelection(ped,hdc,newMinSel,newMaxSel);
      if (updateText)
          SLDrawText(ped,hdc,0);

      /* SLSetCaretPosition(ped,hdc);*/
      ECReleaseEditDC(ped,hdc,FALSE);
      if (updateText)
          ECNotifyParent(ped, EN_CHANGE);
    }

}


ICH NEAR PASCAL SLMouseToIch(ped, hdc, mousePt)
register PED  ped;
HDC           hdc;
POINT         mousePt;
/* effects: Returns the closest cch to where the mouse point is.  
 */
{
  register PSTR pText;
  int           width = mousePt.x;
  int           textWidth;
  ICH           cch;

  if (width <= ped->rcFmt.left)
    {
      /* Return either the first non visible character or return 0 if at
       * beginning of text 
       */
      if (ped->screenStart)
          return(ped->screenStart - 1);
      else
          return(0);
    }

  if (width > ped->rcFmt.right)
    {
      pText = LocalLock(ped->hText);

      /* Return last char in text or one plus the last char visible */
      cch = ECCchInWidth(ped, hdc, (LPSTR)(pText+ped->screenStart), 
                         ped->cch - ped->screenStart, 
                         ped->rcFmt.right-ped->rcFmt.left) + 
            ped->screenStart;
      LocalUnlock(ped->hText);
      if (cch >= ped->cch)
          return(ped->cch);
      else
          return(cch+1);
    }

  /* Check if password hidden chars are being used. */
  if (ped->charPasswordChar)
      return(umin((width-ped->rcFmt.left)/ped->cPasswordCharWidth,ped->cch));

  if (!ped->cch)
      return(0);

  pText = LocalLock(ped->hText);
  cch   = ped->cch;

  while(((textWidth = 
	   LOWORD(GetTextExtent(hdc, (LPSTR)(pText+ped->screenStart), 
                               cch-ped->screenStart)))
           > (width-ped->rcFmt.left)) && (cch-ped->screenStart) )
    {
      /* For that "feel" */
      if ((textWidth - ped->aveCharWidth/2) < (width-ped->rcFmt.left))
          break;

      cch--;
    }

#ifdef FE_SB
  cch = ECAdjustIch( ped, pText, cch );
#endif

  LocalUnlock(ped->hText);
  return(cch);
}




void NEAR PASCAL SLMouseMotionHandler(ped, message, virtKeyDown, mousePt)
register PED   ped;
WORD           message;
WORD           virtKeyDown;
POINT          mousePt;
{
  LONG selection;
  BOOL changeSelection = FALSE;

  HDC  hdc = ECGetEditDC(ped,FALSE);
  
  ICH newMaxSel = ped->ichMaxSel;
  ICH newMinSel = ped->ichMinSel;

  ICH mouseIch = SLMouseToIch(ped, hdc, mousePt);

#ifdef FE_SB
  LPSTR pText;

  pText = LocalLock( ped->hText );
  mouseIch = ECAdjustIch( ped, pText, mouseIch );
  LocalUnlock( ped->hText );
#endif

  switch (message)
  {
    case WM_LBUTTONDBLCLK:
      /* Note that we don't have to worry about this control having the focus
       * since it got it when the WM_LBUTTONDOWN message was first sent.  If
       * shift key is down, extend selection to word we double clicked on else
       * clear current selection and select word.  
       */
#ifdef FE_SB
      pText = LocalLock( ped->hText ) + ped->ichCaret;
      selection = ECWord(ped,ped->ichCaret,
          (ECIsDBCSLeadByte(ped,*pText) && ped->ichCaret < ped->cch) ? FALSE : TRUE );
      LocalUnlock( ped->hText );
#else
      selection = ECWord(ped,ped->ichCaret,TRUE);
#endif
      newMinSel = LOWORD(selection);
      newMaxSel = ped->ichCaret = HIWORD(selection);
      changeSelection = TRUE;
      /* Set mouse down to false so that the caret isn't reposition on the
       * mouseup message or on an accidental move...  
       */
      ped->fMouseDown = FALSE;
      break;

    case WM_MOUSEMOVE:
      if (ped->fMouseDown)
        {
          changeSelection = TRUE;
          /* Extend selection, move caret word right */
          if ((ped->ichMinSel == ped->ichCaret) && 
              (ped->ichMinSel != ped->ichMaxSel))
            {
              /* Reduce selection extent */
              newMinSel = ped->ichCaret = mouseIch;
              newMaxSel = ped->ichMaxSel;
            }
          else
              /* Extend selection extent */
              newMaxSel = ped->ichCaret=mouseIch;
        }
      break;

    case WM_LBUTTONDOWN:  
      /*
       * If we currently don't have the focus yet, try to get it.
       */
      if (!ped->fFocus)
        {
          if (!ped->fNoHideSel)
              /* Clear the selection before setting the focus so that we don't
	       * get refresh problems and flicker. Doesn't matter since the
	       * mouse down will end up changing it anyway.  
	       */
              ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

          SetFocus(ped->hwnd);
          /* If we are part of a combo box, then this is the first time the
	   * edit control is getting the focus so we just want to highlight
	   * the selection and we don't really want to position the caret.  
	   */
          if (ped->listboxHwnd)
              break;
        }

      if (ped->fFocus)
        {
          /* Only do this if we have the focus since a clever app may not want
	   * to give us the focus at the SetFocus call above.  
	   */
          ped->fMouseDown = TRUE;
          SetCapture(ped->hwnd);
          changeSelection = TRUE;
          if (!(virtKeyDown & MK_SHIFT))
            {
              /*
               * If shift key isn't down, move caret to mouse point and clear
               * old selection
               */
              newMinSel = newMaxSel = ped->ichCaret = mouseIch;
            }
         else
           {
             /*	Shiftkey is down so we want to maintain the current selection
	      * (if any) and just extend or reduce it 
	      */
             if (ped->ichMinSel == ped->ichCaret)
                 newMinSel = ped->ichCaret = mouseIch;
             else
                 newMaxSel = ped->ichCaret = mouseIch;
           }
        }
      break;

    case WM_LBUTTONUP:
      if (ped->fMouseDown)
        {
          ReleaseCapture();
          /*SLSetCaretPosition(ped,hdc);*/
          ped->fMouseDown = FALSE;
        }
      break;
  }


  if (changeSelection)
    {
      SLScrollText(ped,hdc);
      SLChangeSelection(ped, hdc, newMinSel, newMaxSel);
    }

  ECReleaseEditDC(ped,hdc,FALSE);

}




void NEAR PASCAL SLPaintHandler(ped,althdc)
register PED  ped;
HDC           althdc;
/* effects: Handles painting of the edit control window. Draws the border if
 * necessary and draws the text in its current state.  
 */
{
  HWND         hwnd = ped->hwnd;
  HBRUSH       hBrush;
  register HDC hdc;
  PAINTSTRUCT  paintstruct;
  RECT         rcEdit;
  HANDLE       hOldFont;

  /* Had to put in hide/show carets.  The first one needs to be done before
   * beginpaint to correctly paint the caret if part is in the update region
   * and part is out.  The second is for 1.03 compatibility.  It breaks
   * micrografix's worksheet edit control if not there.  
   */

  HideCaret(hwnd);

  /* Allow subclassing hdc */
  if (!althdc)
      hdc = BeginPaint(hwnd, (PAINTSTRUCT FAR *)&paintstruct);
  else
      hdc = althdc;

  HideCaret(hwnd);

  if (!ped->fNoRedraw && IsWindowVisible(ped->hwnd))
    {
      /* Erase the background since we don't do it in the erasebkgnd message.
       */
      hBrush = GetControlBrush(ped->hwnd, hdc, CTLCOLOR_EDIT);
      FillWindow(ped->hwndParent, hwnd, hdc, hBrush);

      if (ped->fBorder)
        {
          GetClientRect(hwnd, (LPRECT)&rcEdit);
          DrawFrame(hdc, (LPRECT)&rcEdit, 1, DF_WINDOWFRAME);
        }

      if (ped->hFont)
          /* We have to select in the font since this may be a subclassed dc
	   * or a begin paint dc which hasn't been initialized with out fonts
	   * like ECGetEditDC does.  
	   */
          hOldFont = SelectObject(hdc, ped->hFont);

      SLDrawText(ped, hdc, 0);

      if (ped->hFont && hOldFont)
          SelectObject(hdc, hOldFont);

    }
  ShowCaret(hwnd);

  if (!althdc)
      EndPaint(hwnd, (LPPAINTSTRUCT)&paintstruct);

  ShowCaret(hwnd);
}



void NEAR PASCAL SLSetFocusHandler(ped)
register PED  ped;
/* effects: Gives the edit control the focus and notifies the parent
 * EN_SETFOCUS.  
 */
{
  register HDC hdc;

  if (!ped->fFocus)
    {
      UpdateWindow(ped->hwnd);

      ped->fFocus = TRUE;  /* Set focus */

      /* We don't want to muck with the caret since it isn't created. */
      hdc = ECGetEditDC(ped,TRUE);

      /* Show the current selection.  Only if the selection was hidden when we
       * lost the focus, must we invert (show) it.  
       */
      if (!ped->fNoHideSel)
          SLDrawText(ped, hdc, 0);		

      /* Create the caret. Add in the +1 because we have an extra pixel for
       * highlighting around the text. If the font is at least as wide as the
       * system font, use a wide caret else use a 1 pixel wide caret. 
       */
      CreateCaret(ped->hwnd, (HBITMAP)NULL, 
                  (ped->cxSysCharWidth > ped->aveCharWidth ? 1 : 2), 
                  ped->lineHeight+1);
      SLSetCaretPosition(ped,hdc);
      ECReleaseEditDC(ped,hdc,TRUE);
      ShowCaret(ped->hwnd);
    }

  /* Notify parent we have the focus */
  ECNotifyParent(ped, EN_SETFOCUS);
}




void NEAR PASCAL SLKillFocusHandler(ped, newFocusHwnd)
register PED ped;
HWND         newFocusHwnd;
/* effects: The edit control loses the focus and notifies the parent via
 * EN_KILLFOCUS.  
 */
{
  RECT rcEdit;

  if (ped->fFocus)
    {
      /* Destroy the caret */
      HideCaret(ped->hwnd);
      DestroyCaret();

      ped->fFocus = FALSE;  /* Clear focus */

      /* Do this only if we still have the focus.  But we always notify the
       * parent that we lost the focus whether or not we originally had the
       * focus.  
       */
      /* Hide the current selection if needed */
      if (!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel))
        {
          GetClientRect(ped->hwnd, (LPRECT)&rcEdit);
          if (ped->fBorder && rcEdit.right-rcEdit.left && 
              rcEdit.bottom-rcEdit.top)
            {
              /* Don't invalidate the border so that we avoid flicker */
              InflateRect((LPRECT)&rcEdit, -1, -1);
            }
          InvalidateRect(ped->hwnd, (LPRECT)&rcEdit, FALSE);
          UpdateWindow(ped->hwnd);

#if 0
          SLSetSelectionHandler(ped, ped->ichCaret, ped->ichCaret);
#endif
        }
    }

  /* If we aren't a combo box, notify parent that we lost the focus.  
   */
  if (!ped->listboxHwnd)
      ECNotifyParent(ped, EN_KILLFOCUS);
  else
    {
      /* This editcontrol is part of a combo box and is losing the focus.  If
       * the focus is NOT being sent to another control in the combo box
       * window, then it means the combo box is losing the focus.  So we will
       * notify the combo box of this fact.  
       */
      if (!IsChild(ped->hwndParent, newFocusHwnd))
        {
          /* Focus is being sent to a window which is not a child of the combo
	   * box window which implies that the combo box is losing the focus.
	   * Send a message to the combo box informing him of this fact so
	   * that he can clean up...  
	   */
          SendMessage(ped->hwndParent, CBEC_KILLCOMBOFOCUS, 0, 0L);
        }
    }
}


/*******************/
/* SLEditWndProc() */
/*******************/
LONG FAR PASCAL SLEditWndProc(hwnd, ped, message, wParam, lParam)
HWND          hwnd;
register PED  ped;
WORD          message;
register WORD wParam;
LONG          lParam;
/* effects: Class procedure for all single line edit controls.
        Dispatches all messages to the appropriate handlers which are named 
        as follows:
        SL (single line) prefixes all single line edit control procedures while
        EC (edit control) prefixes all common handlers.

        The SLEditWndProc only handles messages specific to single line edit
        controls.
 */

{
  /* Dispatch the various messages we can receive */
  switch (message)
  {
    case WM_CLEAR:
      /* wParam - not used
         lParam - not used */
      /*
       * Call SLKeyDownHandler with a VK_DELETE keycode to clear the selected
       * text.
       */
      if (ped->ichMinSel != ped->ichMaxSel)
          SLKeyDownHandler(ped, VK_DELETE, NOMODIFY);
      break;

    case WM_CHAR:
      /* wParam - the value of the key
         lParam - modifiers, repeat count etc (not used) */
      if (!ped->fEatNextChar)
          SLCharHandler(ped, wParam, 0);
      else
	  ped->fEatNextChar = FALSE;    
      break;

    case WM_CUT:
      /* wParam - not used
         lParam - not used */
      /* Call SLKeyDownHandler with a VK_DELETE keycode to cut the selected
       * text. (Delete key with shift modifier.) This is needed so that apps
       * can send us WM_PASTE messages.  
       */
      if (ped->ichMinSel != ped->ichMaxSel)
          SLKeyDownHandler(ped, VK_DELETE, SHFTDOWN);
      break;

    case WM_ERASEBKGND:
      /* wParam - device context handle
         lParam - not used */
      /* We do nothing on this message and we don't want DefWndProc to do
       * anything, so return 1 
       */
      return(1L);
      break;

    case WM_GETDLGCODE:
      /* wParam - not used
         lParam - not used */
      return(DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS);
      break;

    case WM_KEYDOWN:
      /* wParam - virt keycode of the given key
         lParam - modifiers such as repeat count etc. (not used) */
      SLKeyDownHandler(ped, wParam, 0);
      break;

    case WM_KILLFOCUS:
      /* wParam - handle of the window that receives the input focus
         lParam - not used */
      SLKillFocusHandler(ped, (HWND)wParam);
      break;

    case WM_MOUSEMOVE:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
      /* wParam - contains a value that indicates which virtual keys are down
         lParam - contains x and y coords of the mouse cursor */
      SLMouseMotionHandler(ped, message, wParam, MAKEPOINT(lParam));
      break;

    case WM_CREATE:
      /* wParam - handle to window being created
         lParam - points to a CREATESTRUCT that contains copies of parameters 
                  passed to the CreateWindow function. */
      return(SLCreateHandler(hwnd, ped, (LPCREATESTRUCT) lParam));
      break;

    case WM_PAINT:
      /* wParam - not used - actually sometimes used as a hdc when subclassing 
         lParam - not used */
      SLPaintHandler(ped, wParam);
      break;

    case WM_PASTE:
      /* wParam - not used
         lParam - not used */
      /* Call SLKeyDownHandler with a SHIFT VK_INSERT keycode to paste the
       * clipboard into the edit control.  This is needed so that apps can
       * send us WM_PASTE messages.  
       */
      SLKeyDownHandler(ped, VK_INSERT, SHFTDOWN);
      break;

    case WM_SETFOCUS:
      /* wParam - handle of window that loses the input focus (may be NULL)
         lParam - not used */
      SLSetFocusHandler(ped);
      break;

    case WM_SETTEXT:
      /* wParam - not used
         lParam - points to a null-terminated string that is used to set the
                  window text. */
      return(SLSetTextHandler(ped, (LPSTR)lParam));
      break;

    case WM_SIZE:
      /* wParam - defines the type of resizing fullscreen, sizeiconic, 
	          sizenormal etc.
         lParam - new width in LOWORD, new height in HIGHWORD of client area */
      SLSizeHandler(ped);
      return(0L);
      break;

    case WM_SYSKEYDOWN:
      if (ped->listboxHwnd && /* Check if we are in a combo box */
          (lParam & 0x20000000L))  /* Check if the alt key is down */
        {
          /*
	   * Handle Combobox support. We want alt up or down arrow to behave
	   * like F4 key which completes the combo box selection
	   */
          ped->fEatNextChar = FALSE;		
          if (lParam & 0x1000000)
            {
              /* This is an extended key such as the arrow keys not on the
	       * numeric keypad so just drop the combobox. 
	       */
              if (wParam == VK_DOWN || wParam == VK_UP)
                  goto DropCombo;
              else
                  goto foo;
            }

          if (GetKeyState(VK_NUMLOCK) < 0)
	    {
	      ped->fEatNextChar = FALSE;
              /* If numlock down, just send all system keys to dwp */
 	      goto foo;
            }
          else
              /* Num lock is up. Eat the characters generated by the key board
	       * driver. 
	       */
	      ped->fEatNextChar = TRUE;

	  if (!(wParam == VK_DOWN || wParam == VK_UP))
              goto foo;

DropCombo:
          if (SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0L) & 0x00000001)
            {
              /* Extended ui doesn't honor VK_F4. */
              if (SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L))
                  return(SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 0, 0L));
              else
                  return(SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 1, 0L));
            }
          else
              return(SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0L));
        }
foo:	
      if (wParam == VK_BACK)
	{
          SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
          break;
        }
      goto PassToDefaultWindowProc;
      break;

    case EM_GETLINE:
      /* wParam - line number to copy (always the first line for SL)
         lParam - buffer to copy text to. FIrst word is max # of bytes to copy
       */
      return(ECGetTextHandler(ped, (*(WORD FAR *)lParam), (LPSTR)lParam));
      break;

    case EM_LINELENGTH:
      /* wParam - ignored
         lParam - ignored */
      return((LONG)ped->cch);
      break;

    case EM_SETSEL:
      /* wParam - not used
         lParam - starting pos in lowword ending pos in high word */
      SLSetSelectionHandler(ped, LOWORD(lParam), HIWORD(lParam));
      break;

    case EM_REPLACESEL:
      /* wParam - not used
         lParam - points to a null terminated string of replacement text */
      SLReplaceSelHandler(ped, (LPSTR)lParam);
      break;

    case WM_UNDO:
    case EM_UNDO:
      SLUndoHandler(ped);
      break;
	    
    default:
PassToDefaultWindowProc:
      return(DefWindowProc(hwnd,message,wParam,lParam));
      break;

  } /* switch (message) */

  return(1L);
} /* SLEditWndProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\edit.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDIT.H
 *
 *  History:
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16
--*/

/****************************************************************************/
/*									    */
/*  EDIT.H - 							            */
/*									    */
/*	Edit Control Defines and Procedures				    */
/*									    */
/****************************************************************************/
#include "combcom.h"

/* NOTE: Text handle is sized as multiple of this constant
 *	 (should be power of 2).
 */
#define CCHALLOCEXTRA  0x20

/* Maximum width in pixels for a line/rectangle */
#define MAXPIXELWIDTH  30000

/* Limit multiline edit controls to at most 1024 characters on a single line.
 * We will force a wrap if the user exceeds this limit. 
 */
#define MAXLINELENGTH  1024

#define ES_FMTMASK     0x00000003L

/* Allow an initial maximum of 30000 characters in all edit controls since
 * some apps will run into unsigned problems otherwise.  If apps know about
 * the 64K limit, they can set the limit themselves. 
 */
#define MAXTEXT 30000

#define BACKSPACE         0x08
#define TAB               0x09

/* Key modifiers which have been pressed.  Code in KeyDownHandler and
   CharHandler depend on these exact values. */
#define NONEDOWN   0 /* Neither shift nor control down */
#define CTRLDOWN   1 /* Control key only down */ 
#define SHFTDOWN   2 /* Shift key only down */
#define SHCTDOWN   3 /* Shift and control keys down = CTRLDOWN + SHFTDOWN */
#define NOMODIFY   4 /* Neither shift nor control down */

/* Types of undo supported in this ped */
#define UNDO_NONE   0  /* We can't undo the last operation. */
#define UNDO_INSERT 1  /* We can undo the user's insertion of characters */
#define UNDO_DELETE 2  /* We can undo the user's deletion of characters */

typedef struct tagED
  {
    HANDLE  hText;             /* Block of text we are editing */
    ICH     cchAlloc;          /* Number of chars we have allocated for hText 
				*/
    ICH     cchTextMax;        /* Max number bytes allowed in edit control 
				*/
    ICH     cch;               /* Current number of bytes of actual text 
				*/
    int     cLines;            /* Number of lines of text */

    ICH     ichMinSel;         /* Selection extent.  MinSel is first selected 
                                  char */
    ICH     ichMaxSel;         /* MaxSel is first unselected character */
    ICH     ichCaret;          /* Caret location. Caret is on left side of 
                                  char */
    int     iCaretLine;        /* The line the caret is on. So that if word
				* wrapping, we can tell if the caret is at end
				* of a line of at beginning of next line... 
				*/
    ICH     screenStart;       /* Index of left most character displayed on
				* screen for sl ec and index of top most line
				* for multiline edit controls 
				*/
    int     ichLinesOnScreen;  /* Number of lines we can display on screen */
    WORD    xOffset;           /* x (horizontal) scroll position in pixels
				* (for multiline text horizontal scroll bar) 
				*/
    WORD    charPasswordChar;  /* If non null, display this character instead
				* of the real text. So that we can implement
				* hidden text fields. 
				*/
    WORD    cPasswordCharWidth;/* Width of password char */

    HWND    hwnd;              /* Window for this edit control */
    RECT    rcFmt;             /* Client rectangle */
    HWND    hwndParent;        /* Parent of this edit control window */

                               /* These vars allow us to automatically scroll
				* when the user holds the mouse at the bottom
				* of the multiline edit control window. 
				*/
    POINT   ptPrevMouse;       /* Previous point for the mouse for system
				* timer.  
				*/
    WORD    prevKeys;          /* Previous key state for the mouse */


    WORD    fSingle       : 1; /* Single line edit control? (or multiline) */
    WORD    fNoRedraw     : 1; /* Redraw in response to a change? */
    WORD    fMouseDown    : 1; /* Is mouse button down? when moving mouse */
    WORD    fFocus        : 1; /* Does ec have the focus ? */
    WORD    fDirty        : 1; /* Modify flag for the edit control */
    WORD    fDisabled     : 1; /* Window disabled? */
    WORD    fNonPropFont  : 1; /* Fixed width font? */
    WORD    fBorder       : 1; /* Draw a border? */
    WORD    fAutoVScroll  : 1; /* Automatically scroll vertically */
    WORD    fAutoHScroll  : 1; /* Automatically scroll horizontally */
    WORD    fNoHideSel    : 1; /* Hide sel when we lose focus? */
#ifdef FE_SB
    WORD    fDBCS         : 1; /* Are we use DBCS font set for editing? */
#else
    WORD    fKanji        : 1;
#endif
    WORD    fFmtLines     : 1; /* For multiline only. Do we insert CR CR LF at
				* word wrap breaks? 
				*/
    WORD    fWrap         : 1; /* Do word wrapping? */
    WORD    fCalcLines    : 1; /* Recalc ped->chLines array? (recalc line
				* breaks?) 
				*/ 
    WORD    fEatNextChar  : 1; /* Hack for ALT-NUMPAD stuff with combo boxes.
				* If numlock is up, we want to eat the next
				* character generated by the keyboard driver
				* if user enter num pad ascii value...  
				*/
    WORD    fStripCRCRLF  :1;   /* CRCRLFs have been added to text. Strip them
				 * before doing any internal edit control
				 * stuff 
				 */
    WORD    fInDialogBox  :1;   /* True if the ml edit control is in a dialog
				 * box and we have to specially treat TABS and
				 * ENTER 
				 */
    WORD    fReadOnly     :1;   /* Is this a read only edit control? Only
				 * allow scrolling, selecting and copying. 
				 */
    WORD    fCaretHidden  :1;  /* This indicates whether the caret is 
    				* currently hidden because the width or height
				* of the edit control is too small to show it.
				*/
    int     *chLines;          /* index of the start of each line */
    WORD    format;            /* Left, center, or right justify multiline
				* text.
				*/
    LPSTR   (FAR *lpfnNextWord)(); /* Next word function */
    ICH     maxPixelWidth;     /* Width (in pixels) of longest line */

    WORD    undoType;          /* Current type of undo we support */
    HANDLE  hDeletedText;      /* Handle to text which has been deleted (for
				  undo) 
				*/
    ICH     ichDeleted;        /* Starting index from which text was deleted*/
    ICH     cchDeleted;        /* Count of deleted characters in buffer */
    ICH     ichInsStart;       /* Starting index from which text was 
                                  inserted */
    ICH     ichInsEnd;         /* Ending index of inserted text */


    HANDLE  hFont;             /* Handle to the font for this edit control.
				  Null if system font. 
				*/
    int     aveCharWidth;      /* Ave width of a character in the hFont */
    int     lineHeight;        /* Height of a line in the hFont */
    int     charOverhang;      /* Overhang associated with the hFont */     
    int     cxSysCharWidth;    /* System font ave width */
    int     cySysCharHeight;   /* System font height */
    HWND    listboxHwnd;       /* ListBox hwnd. Non null if we are a combo 
                                  box */
    int     *pTabStops;	       /* Points to an array of tab stops; First
				* element contains the number of elements in
				* the array 
				*/
    HANDLE  charWidthBuffer;  
    HBRUSH  hbrHiliteBk;       /* Hilite background color brush. */
    DWORD   rgbHiliteBk;       /* Hilite background color */  
    DWORD   rgbHiliteText;     /* Hilite Text color */
#ifdef FE_SB
    BYTE    charSet;		/* Character set for current selected font */
    HANDLE  hDBCSVector;	/* Handle to the DBCS vector table */
    BYTE    DBCSVector[8];      /* DBCS vector table which contains flag
                                 * to detect lead byte of DBC.
				 */
#endif
  } ED;

typedef ED *PED;


/* The following structure is used to store a selection block; In Multiline
 * edit controls, "StPos" and "EndPos" fields contain the Starting and Ending
 * lines of the block. In Single line edit controls, "StPos" and "EndPos"
 * contain the Starting and Ending character positions of the block; 
 */
typedef  struct  tagBLOCK
      {
	 ICH  StPos;
	 ICH  EndPos;
      }  BLOCK;
typedef BLOCK FAR *LPBLOCK;



BOOL  FAR  PASCAL ECNcCreate(HWND, LPCREATESTRUCT);
BOOL  FAR  PASCAL ECCreate(HWND, PED, LPCREATESTRUCT);
LONG  FAR  PASCAL ECWord(PED, ICH, BOOL);  /* no register for PED */
ICH   FAR  PASCAL ECFindTab(LPSTR, register ICH);
void  FAR  PASCAL ECNcDestroyHandler(HWND, register PED, WORD, LONG);
BOOL  FAR  PASCAL ECSetText(register PED, LPSTR);
void  FAR  PASCAL ECSetPasswordChar(register PED, WORD);
ICH   FAR  PASCAL ECCchInWidth(register PED, HDC, LPSTR, register ICH, unsigned int);
void  FAR  PASCAL ECEmptyUndo(register PED);
BOOL  FAR  PASCAL ECInsertText(register PED, LPSTR, ICH);
ICH   FAR  PASCAL ECDeleteText(register PED);
void  FAR  PASCAL ECNotifyParent(register PED, short);
void  FAR  PASCAL ECSetEditClip(register PED, HDC);
HDC   FAR  PASCAL ECGetEditDC(register PED, BOOL);
void  FAR  PASCAL ECReleaseEditDC(register PED, HDC, BOOL);
void  FAR  PASCAL ECCreateHandler(register PED);
ICH   FAR  PASCAL ECGetTextHandler(register PED, register ICH, LPSTR);
void  FAR  PASCAL ECSetFont(register PED, HANDLE, BOOL);
ICH   FAR  PASCAL ECCopyHandler(register PED);
BOOL  FAR  PASCAL ECCalcChangeSelection(PED, ICH, ICH, LPBLOCK, LPBLOCK);
void  NEAR PASCAL ECFindXORblks(LPBLOCK, LPBLOCK, LPBLOCK, LPBLOCK);
LONG  FAR  PASCAL ECTabTheTextOut(HDC, int, int, LPSTR, int, PED, int, BOOL);

/****************************************************************************/
/*			Multi-Line Support Routines       	            */
/****************************************************************************/

ICH   FAR  PASCAL MLInsertText(PED, LPSTR, WORD, BOOL);
BOOL  FAR  PASCAL MLEnsureCaretVisible(register PED);
void  NEAR PASCAL MLDrawText(register PED, HDC, ICH, ICH);
void  NEAR PASCAL MLDrawLine(register PED, HDC, int, ICH, int, BOOL);
void  NEAR PASCAL MLPaintABlock(PED, HDC, int, int);
int   NEAR PASCAL GetBlkEndLine(int, int, BOOL FAR *, int, int);
LONG  FAR  PASCAL MLBuildchLines(register PED, int, int, BOOL);
void  NEAR PASCAL MLShiftchLines(register PED, register int, int);
BOOL  NEAR PASCAL MLInsertchLine(register PED, int, ICH, BOOL);
void  FAR  PASCAL MLSetCaretPosition(register PED,HDC);
LONG  NEAR PASCAL MLIchToXYPos(register PED, HDC, ICH, BOOL);
int   FAR  PASCAL MLIchToLineHandler(register PED, ICH);
void  NEAR PASCAL MLRepaintChangedSelection(PED, HDC, ICH, ICH);
void  NEAR PASCAL MLMouseMotionHandler(PED, WORD, WORD, POINT);
ICH   FAR  PASCAL MLLineLength(register PED, int);
void  FAR  PASCAL MLStripCrCrLf(register PED);
BOOL  FAR  PASCAL MLSetTextHandler(register PED, LPSTR);
int   FAR  PASCAL MLCalcXOffset(register PED, HDC, int);
BOOL  FAR  PASCAL MLUndoHandler(register PED);
LONG  FAR  PASCAL MLEditWndProc(HWND, register PED, WORD, register WORD, LONG);
void  FAR  PASCAL MLCharHandler(PED, WORD, int);
void  FAR  PASCAL MLSetSelectionHandler(register PED, ICH, ICH);
LONG  FAR  PASCAL MLCreateHandler(HWND, PED, LPCREATESTRUCT);
BOOL  FAR  PASCAL MLInsertCrCrLf(register PED);
void  FAR  PASCAL MLSetHandleHandler(register PED, HANDLE);
LONG  FAR  PASCAL MLGetLineHandler(register PED, WORD, ICH, LPSTR);
ICH   FAR  PASCAL MLLineIndexHandler(register PED, register int);
ICH   FAR  PASCAL MLLineLengthHandler(register PED, ICH);
void  FAR  PASCAL MLSizeHandler(register PED);
void  FAR  PASCAL MLChangeSelection(register PED, HDC, ICH, ICH);
void  FAR  PASCAL MLSetRectHandler(register PED, LPRECT);
BOOL  FAR  PASCAL MLExpandTabs(register PED);
BOOL  FAR  PASCAL MLSetTabStops(PED, int, LPINT);
int   FAR  PASCAL MLThumbPosFromPed(register PED, BOOL);

/****************************************************************************/
/*			Single Line Support Routines			    */
/****************************************************************************/

void  NEAR PASCAL SLReplaceSelHandler(register PED, LPSTR);
BOOL  FAR  PASCAL SLUndoHandler(register PED);
void  FAR  PASCAL SLSetCaretPosition(register PED, HDC);
int   NEAR PASCAL SLIchToLeftXPos(register PED, HDC, ICH);
void  FAR  PASCAL SLChangeSelection(register PED, HDC, ICH, ICH);
void  NEAR PASCAL SLDrawText(register PED, register HDC, ICH);
void  NEAR PASCAL SLDrawLine(register PED, register HDC, ICH, int, BOOL);
int   NEAR PASCAL SLGetBlkEnd(PED, ICH, ICH, BOOL FAR *);
BOOL  FAR  PASCAL SLScrollText(register PED, HDC);
void  FAR  PASCAL SLSetSelectionHandler(register PED,ICH, ICH);
ICH   FAR  PASCAL SLInsertText(register PED, LPSTR, register ICH);
ICH   NEAR PASCAL SLPasteText(register PED);
void  FAR  PASCAL SLCharHandler(register PED, WORD, int);
void  NEAR PASCAL SLKeyUpHandler(register PED, WORD);
void  NEAR PASCAL SLKeyDownHandler(register PED, WORD, int);
ICH   NEAR PASCAL SLMouseToIch(register PED, HDC, POINT);
void  NEAR PASCAL SLMouseMotionHandler(register PED, WORD, WORD, POINT);
LONG  FAR  PASCAL SLCreateHandler(HWND, PED, LPCREATESTRUCT);
void  FAR  PASCAL SLSizeHandler(register PED);
void  NEAR PASCAL SLPaintHandler(register PED, HDC);
BOOL  FAR  PASCAL SLSetTextHandler(register PED, LPSTR);
void  NEAR PASCAL SLSetFocusHandler(register PED);
void  NEAR PASCAL SLKillFocusHandler(register PED, HWND);
LONG  FAR  PASCAL SLEditWndProc(HWND, register PED, WORD, register WORD, LONG);


/****************************************************************************/
/* EditWndProc()                                                            */
/****************************************************************************/
LONG  FAR PASCAL EditWndProc(HWND, WORD, register WORD, LONG);


#ifdef FE_SB
/****************************************************************************/
/* DBCS Support Routines                                                    */
/****************************************************************************/
int FAR PASCAL DBCSCombine( HWND, int );
ICH FAR PASCAL ECAdjustIch( PED, LPSTR, ICH );
VOID FAR PASCAL ECGetDBCSVector( PED );
LPSTR FAR PASCAL ECAnsiNext( PED, LPSTR );
LPSTR FAR PASCAL ECAnsiPrev( PED, LPSTR, LPSTR );
BOOL FAR PASCAL ECIsDBCSLeadByte( PED, BYTE );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\edmlonce.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDMLONCE.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* edmlonce.c - Edit controls Routines Called just once or twice are to be  */
/*		put in a seperate segment _EDMLONCE. This file contains     */
/*		these routines.		          		    	    */
/*                                                                          */
/*                                                                          */
/* Created:  02-08-89  sankar                                               */
/****************************************************************************/

#define  NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*			Multi-Line Support Routines  called just once       */
/****************************************************************************/

void FAR PASCAL MLSizeHandler(ped)
register PED  ped;

/* effects: Handles sizing of the edit control window and properly updating
 * the fields that are dependent on the size of the control. ie. text
 * characters visible etc.  
 */
{
  RECT rc;

  GetClientRect(ped->hwnd, (LPRECT)&rc);

  MLSetRectHandler(ped, (LPRECT)&rc);

  GetWindowRect(ped->hwnd, (LPRECT)&rc);
  ScreenToClient(ped->hwnd, (LPPOINT)&rc.left);
  ScreenToClient(ped->hwnd, (LPPOINT)&rc.right);
  InvalidateRect(ped->hwnd, (LPRECT) &rc, TRUE);
  /*UpdateWindow(ped->hwnd);*/
}



BOOL FAR PASCAL MLSetTextHandler(ped, lpstr)
register PED   ped;
LPSTR          lpstr;
/* effects: Copies the null terminated text in lpstr to the ped.  Notifies the
 * parent if there isn't enough memory.  Returns TRUE if successful else FALSE
 * if memory error.  
 */
{
  BOOL fInsertSuccessful;

  /* Set the text and update the window if text was added */
  fInsertSuccessful = ECSetText(ped, lpstr);

  if (fInsertSuccessful)
    {
      MLStripCrCrLf(ped);
      /* Always build lines even if no text was inserted. */
      MLBuildchLines(ped, 0, 0, FALSE);


      /* Reset caret and selections since the text could have changed */
      ped->screenStart = ped->ichMinSel = ped->ichMaxSel = 0;
      ped->ichCaret = 0;
      ped->xOffset = 0;
      ped->iCaretLine = 0;
      ped->fDirty = FALSE;
    }
  ECEmptyUndo(ped);

  SetScrollPos(ped->hwnd, SB_VERT, 0, TRUE);
  SetScrollPos(ped->hwnd, SB_HORZ, 0, TRUE);

  /* We will always redraw the text whether or not the insert was successful
   * since we may set to null text. Since PaintHandler checks the redraw flag,
   * we won't bother to check it here.  
   */
  InvalidateRect(ped->hwnd, (LPRECT)NULL, TRUE);
  /* Need to do the updatewindow to keep raid happy.*/
  UpdateWindow(ped->hwnd);

  return(fInsertSuccessful);
}



LONG FAR PASCAL MLCreateHandler(hwnd, ped, lpCreateStruct)
HWND           hwnd;
register PED   ped;
LPCREATESTRUCT lpCreateStruct;

/* effects: Creates the edit control for the window hwnd by allocating memory
 * as required from the application's heap.  Notifies parent if no memory
 * error (after cleaning up if needed).  Returns TRUE if no error else returns
 * -1.  
 */
{
  LONG         windowStyle;
  LPSTR        lpWindowText=lpCreateStruct->lpszName;
  RECT         rc;
 
  
  /* Save the text across the local allocs in ECNcCreate */
  SwapHandle(&lpWindowText);

  /* Do the standard creation stuff */
  if (!ECCreate(hwnd, ped, lpCreateStruct))
      return(-1);

  /* Allocate line start array as a fixed block in local heap */
  if (!(ped->chLines = (int *)LocalAlloc(LPTR,2*sizeof(int))))
      return(-1);

  /* Call it one line of text... */
  ped->cLines = 1;

  /* Get values from the window instance data structure and put them in the
   * ped so that we can access them easier 
   */
  windowStyle = GetWindowLong(hwnd, GWL_STYLE);

  /* If app wants WS_VSCROLL or WS_HSCROLL, it automatically gets AutoVScroll
   * or AutoHScroll.  
   */
  if ((windowStyle & ES_AUTOVSCROLL) || (windowStyle & WS_VSCROLL))
      ped->fAutoVScroll = 1;

  ped->format = (LOWORD(windowStyle) & LOWORD(ES_FMTMASK));
  if (ped->format != ES_LEFT)
    {
      /* If user wants right or center justified text, then we turn off
       * AUTOHSCROLL and WS_HSCROLL since non-left styles don't make sense
       * otherwise.  
       */
      windowStyle = windowStyle & ~WS_HSCROLL;
      SetWindowLong(hwnd, GWL_STYLE, windowStyle);
      ped->fAutoHScroll = FALSE;
    }

  if (windowStyle & WS_HSCROLL)
      ped->fAutoHScroll = 1;

  ped->fWrap = (!ped->fAutoHScroll && !(windowStyle & WS_HSCROLL));

  ped->fSingle = FALSE;        /* Set multi line edit control */
  _asm int 3
  ped->cchTextMax = MAXTEXT;   /* Max # chars we will allow user to enter */

  /* Set the default font to be the system font.  
   */
  ECSetFont(ped, NULL, FALSE);

  SetRect((LPRECT)&rc, 0, 0, ped->aveCharWidth*10, ped->lineHeight);
  MLSetRectHandler(ped, (LPRECT)&rc);
  /* Set the window text if needed and notify parent if not enough memory to
   * set the initial text.  
   */
  /* Restore the text from the save we did at the beginning */
  SwapHandle(&lpWindowText);

  if (lpWindowText && !MLSetTextHandler(ped, lpWindowText))
     return(-1);

  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\edmlrare.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDMLRARE.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* edmlRare.c - Edit controls Routines Called rarely are to be		    */
/*		put in a seperate segment _EDMLRare. This file contains	    */
/*		these routines.						    */
/****************************************************************************/

#define  NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*			Multi-Line Support Routines  called Rarely	    */
/****************************************************************************/

BOOL FAR PASCAL MLInsertCrCrLf(ped)
register PED  ped;
/* effects: Inserts CR CR LF characters into the text at soft (word-wrap) line
 * breaks.  CR LF (hard) line breaks are unaffected.  Assumes that the text
 * has already been formatted ie. ped->chLines is where we want the line
 * breaks to occur.  Note that ped->chLines is not updated to reflect the
 * movement of text by the addition of CR CR LFs.  Returns TRUE if successful
 * else notify parent and return FALSE if the memory couldn't be allocated.  
 */
{
  ICH		dch;
  ICH		li;
  ICH		lineSize;
  /*register*/ unsigned char *pchText;
  unsigned char *pchTextNew;


  if (!ped->fWrap || !ped->cch)
      /* There are no soft line breaks if word-wrapping is off or if no chars 
       */
      return(TRUE);

  /* Calc an upper bound on the number of additional characters we will be
   * adding to the text when we insert CR CR LFs.  
   */
  dch = 3 * sizeof(char) * ped->cLines;

  if (!LocalReAlloc(ped->hText, ped->cch + dch, 0))
    {
      ECNotifyParent(ped, EN_ERRSPACE);
      return (FALSE);
    }

  ped->cchAlloc = ped->cch + dch;

  /* Move the text up dch bytes and then copy it back down, inserting the CR
   * CR LF's as necessary.  
   */

  pchTextNew = pchText = LocalLock(ped->hText);
  pchText += dch;
  dch = 0; /* Now we will use this to keep track of how many chars we add
	      to the text */

  /* Copy the text up dch bytes to pchText. This will shift all indices in
   * ped->chLines up by dch bytes.  
   */
  LCopyStruct((LPSTR)pchTextNew, (LPSTR)pchText, ped->cch);

  /* Now copy chars from pchText down to pchTextNew and insert CRCRLF at soft
   * line breaks.  
   */
  for (li = 0; li < ped->cLines-1; li++)
     {
       lineSize = ped->chLines[li+1]-ped->chLines[li];
       LCopyStruct((LPSTR)pchText, (LPSTR)pchTextNew, lineSize);
       pchTextNew += lineSize;
       pchText += lineSize;
       /* If last character in newly copied line is not a line feed, then we
	* need to add the CR CR LF triple to the end 
	*/
       if (*(PSTR)(pchTextNew-1) != 0x0A)
	 {
	   *pchTextNew++ = 0x0D;
	   *pchTextNew++ = 0x0D;
	   *pchTextNew++ = 0x0A;
	   dch += 3;
	 }
     }

  /* Now move the last line up. It won't have any line breaks in it... */
  LCopyStruct((LPSTR)pchText, (LPSTR)pchTextNew,
	      ped->cch-ped->chLines[ped->cLines-1]);

  LocalUnlock(ped->hText);

  /* Update number of characters in text handle */
  ped->cch += dch;

  if (dch)
      /*
       * So that the next time we do anything with the text, we can strip the
       * CRCRLFs
       */
      ped->fStripCRCRLF = TRUE;

  return((dch != 0));
}


void FAR PASCAL MLStripCrCrLf(ped)
register PED  ped;
/* effects: Strips the CR CR LF character combination from the text.  This
 * shows the soft (word wrapped) line breaks. CR LF (hard) line breaks are
 * unaffected.	
 */
{
  register unsigned char *pchSrc;
  unsigned char		 *pchDst;
  unsigned char		 *pchLast;

  if (ped->cch)
    {
      pchSrc = pchDst = LocalLock(ped->hText);
      pchLast = pchSrc + ped->cch;
      while (pchSrc < pchLast)
	 {
	   if (*(int *)pchSrc != 0x0D0D)
	       *pchDst++ = *pchSrc++;
	   else
	     {
	      pchSrc += 3;
	      ped->cch = ped->cch - 3;
	     }
	 }
      LocalUnlock(ped->hText);
    }
}


void FAR PASCAL MLSetHandleHandler(ped, hNewText)
register PED  ped;
HANDLE	      hNewText;
/* effects: Sets the ped to contain the given handle.  
 */
{
  ICH	newCch;

  ped->cch = ped->cchAlloc = LocalSize(ped->hText = hNewText);
  if (ped->cch)
    {
      /* We have to do it this way in case the app gives us a zero size 
	 handle */
      ped->cch = lstrlen((LPSTR)LocalLock(ped->hText));
      LocalUnlock(ped->hText);
    }

  /* Empty the undo buffer since the text will be in an inconsistant state. 
   */
  ECEmptyUndo(ped);

  newCch = (ICH)(ped->cch + CCHALLOCEXTRA);
  /* We do this LocalReAlloc in case the app changed the size of the handle */
  if (LocalReAlloc(ped->hText, newCch, 0))
      ped->cchAlloc = newCch;

  ped->fDirty = FALSE;

  MLStripCrCrLf(ped);
  MLBuildchLines(ped,0,0,FALSE);

  /* Reset caret and selections since the text could have changed causing
   * these to be out of range. 
   */
  ped->xOffset = ped->screenStart = ped->ichMinSel = ped->ichMaxSel = 0;
  ped->iCaretLine = ped->ichCaret = 0;

  SetScrollPos(ped->hwnd, SB_VERT, 0, TRUE);
  SetScrollPos(ped->hwnd, SB_HORZ, 0, TRUE);

  /* We will always redraw the text whether or not the insert was successful
   * since we may set to null text. Also, since PaintHandler checks the redraw
   * flag, we won't bother to check it here.  
   */
  InvalidateRect(ped->hwnd, (LPRECT)NULL, TRUE);
  UpdateWindow(ped->hwnd);
}


LONG FAR PASCAL MLGetLineHandler(ped, lineNumber, maxCchToCopy, lpBuffer)
register PED ped;
WORD	     lineNumber;
ICH	     maxCchToCopy;
LPSTR	     lpBuffer;
/* effects: Copies maxCchToCopy bytes of line lineNumber to the buffer
 * lpBuffer. The string is not zero terminated.	 
 */
{
  PSTR pText;

  if (lineNumber > ped->cLines-1)
      return(0L);

  maxCchToCopy = umin(MLLineLength(ped, lineNumber), maxCchToCopy);

  if (maxCchToCopy)
    {
      pText = (PSTR)(LocalLock(ped->hText) + ped->chLines[lineNumber]);
      LCopyStruct((LPSTR)pText, (LPSTR)lpBuffer, maxCchToCopy);
      LocalUnlock(ped->hText);
    }

  return(maxCchToCopy);

}


ICH FAR PASCAL MLLineIndexHandler(ped, iLine)
register PED ped;
register int iLine;
/* effects: This function returns the number of character positions that occur
 * preceeding the first char in a given line.  
 */
{
  if (iLine == -1)
      iLine = ped->iCaretLine;
  return(iLine	< ped->cLines ? ped->chLines[iLine] : -1);
}



ICH FAR PASCAL MLLineLengthHandler(ped, ich)
register PED ped;
ICH	     ich;
/* effects: if ich = -1, return the length of the lines containing the current
 * selection but not including the selection.  Otherwise, return the length of
 * the line containing ich.
 */
{
  ICH il1, il2;

  if (ich != 0xFFFF)
      return(MLLineLength(ped, MLIchToLineHandler(ped, ich)));

  /* Find length of lines corresponding to current selection */
  il1 = MLIchToLineHandler(ped, ped->ichMinSel);
  il2 = MLIchToLineHandler(ped, ped->ichMaxSel);
  if (il1 == il2)
      return(MLLineLength(ped, il1) - (ped->ichMaxSel - ped->ichMinSel));

  return(ped->ichMinSel - ped->chLines[il1] +
	 MLLineLength(ped, il2) - (ped->ichMaxSel - ped->chLines[il2]));
}


void FAR PASCAL MLSetSelectionHandler(ped, ichMinSel, ichMaxSel)
register PED ped;
ICH	     ichMinSel;
ICH	     ichMaxSel;
/*
 * effects: Sets the selection to the points given and puts the cursor at
 * ichMaxSel.
 */
{
  register HDC hdc;

  if (ichMinSel == 0xFFFF)
      /* Set no selection if we specify -1 
       */
      ichMinSel = ichMaxSel = ped->ichCaret;

  /* Since these are unsigned, we don't check if they are greater than 0.  
   */
  ichMinSel = umin(ped->cch,ichMinSel);
  ichMaxSel = umin(ped->cch,ichMaxSel);

  /* Set the caret's position to be at ichMaxSel.  
   */
  ped->ichCaret	  = ichMaxSel;
  ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);

  hdc = ECGetEditDC(ped,FALSE);
  MLChangeSelection(ped, hdc, ichMinSel, ichMaxSel);

  MLSetCaretPosition(ped,hdc);
  ECReleaseEditDC(ped,hdc,FALSE);

  MLEnsureCaretVisible(ped);
}


/**
**	MLSetTabStops(ped, nTabPos, lpTabStops)
**
**		This sets the tab stop positions set by the App by sending
**	a EM_SETTABSTOPS message.  
**	
**	nTabPos : Number of tab stops set by the caller
**	lpTabStops: array of tab stop positions in Dialog units.
**
**	Returns:
**		TRUE if successful
**		FALSE  if memory allocation error.
**/

BOOL   FAR   PASCAL  MLSetTabStops(ped, nTabPos, lpTabStops)

PED    ped;
int    nTabPos;
LPINT  lpTabStops;

{
    int	 * pTabStops;

    /* Check if tab positions already exist */
    if (!ped -> pTabStops)
      {
	/* Check if the caller wants the new tab positions */
	if (nTabPos)
	  {
	    /* Allocate the array of tab stops */
	    if(!(pTabStops = (int *)LocalAlloc(LPTR, (nTabPos + 1)*sizeof(int))))
		return(FALSE);
	}
	else
	    return(TRUE);    /* No stops then and no stops now! */
    }
    else
    {
	/* Check if the caller wants the new tab positions */
	if(nTabPos)
	{
	    /* Check if the number of tab positions is different */
	    if (ped->pTabStops[0] != nTabPos)
	      {
		/* Yes! So ReAlloc to new size */
		if(!(pTabStops = (int *)LocalReAlloc((HANDLE)ped->pTabStops, 
					  (nTabPos + 1) * sizeof(int), LPTR)))
		    return(FALSE);
	      }
	    else
		pTabStops = ped->pTabStops;
	}
	else
	{
	    /* Caller wants to remove all the tab stops; So, release */
	    if (LocalFree((HANDLE)ped->pTabStops))
		return(FALSE);	/* Failure */
	    ped->pTabStops = NULL;
	    return(TRUE);
	}
    }

    /* Copy the new tab stops onto the tab stop array after converting the
     * dialog co-ordinates into the pixel co-ordinates 
     */

    ped -> pTabStops = pTabStops;
    *pTabStops++ = nTabPos;	 /* First element contains the count */
    while(nTabPos--)
      {
        /* aveCharWidth must be used instead of cxSysCharWidth.
	 * Fix for Bug #3871 --SANKAR-- 03/14/91
	 */
	*pTabStops++ = MultDiv(*lpTabStops++, ped->aveCharWidth, 4);
      }
    
    return(TRUE);
}

BOOL FAR PASCAL MLUndoHandler(ped)
register PED ped;
/* effects: Handles Undo for multiline edit controls. */
{
  HANDLE hDeletedText = ped->hDeletedText;
  BOOL	 fDelete      = (BOOL)(ped->undoType & UNDO_DELETE);
  WORD	 cchDeleted   = ped->cchDeleted;
  WORD	 ichDeleted   = ped->ichDeleted;
  
  if (ped->undoType == UNDO_NONE)
      /* No undo... */
      return(FALSE);

  ped->hDeletedText = NULL;
  ped->cchDeleted = 0;
  ped->ichDeleted = -1;
  ped->undoType &= ~UNDO_DELETE;
  
  if (ped->undoType == UNDO_INSERT)
    {
      ped->undoType = UNDO_NONE;
      /* Set the selection to the inserted text */
      MLSetSelectionHandler(ped, ped->ichInsStart, ped->ichInsEnd);
      ped->ichInsStart = ped->ichInsEnd = -1;
      /* Now send a backspace to delete and save it in the undo buffer... 
       */
      MLCharHandler(ped, VK_BACK, NOMODIFY);
    }

  if (fDelete)
    {
      /* Insert deleted chars */
      /* Set the selection to the inserted text */
      MLSetSelectionHandler(ped, ichDeleted, ichDeleted);
      MLInsertText(ped, GlobalLock(hDeletedText), cchDeleted, FALSE);
      GlobalUnlock(hDeletedText);
      GlobalFree(hDeletedText);
      MLSetSelectionHandler(ped, ichDeleted, ichDeleted+cchDeleted);
    }

  return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\editml.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDITML.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* editml.c - Edit controls rewrite.  Version II of edit controls.	    */
/*									    */
/*									    */
/* Created:  24-Jul-88 davidds						    */
/****************************************************************************/

#define	NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*			Multi-Line Support Routines			    */
/****************************************************************************/

BOOL NEAR _fastcall MLIsDelimiter(char bCharVal)
{
  return((bCharVal == ' ') || (bCharVal == '\t'));
}


DWORD NEAR PASCAL LocGetTabbedTextExtent(HDC hdc, PSTR pstring, 
                                         int nCount, PED ped)
{
  return(ECTabTheTextOut(hdc, 0, 0, (LPSTR)pstring, nCount, ped, 0, FALSE));
}

int FAR PASCAL MLCalcXOffset(register PED ped,
                             HDC	  hdc,
                             int	  lineNumber)
/* effects: Calculates the horizontal offset (indent) required for centered
 * and right justified lines.  
 */
{
  PSTR	       pText;
  ICH	       lineLength;
  register ICH lineWidth;

  if (ped->format == ES_LEFT)
      return(0);


  lineLength = MLLineLength(ped, lineNumber);

  if (lineLength)
    {
      pText = LocalLock(ped->hText)+ped->chLines[lineNumber];
      hdc = ECGetEditDC(ped,TRUE);
      lineWidth = LOWORD(LocGetTabbedTextExtent(hdc, pText, lineLength,
						ped));
      ECReleaseEditDC(ped,hdc,TRUE);
      LocalUnlock(ped->hText);
    }
  else
     lineWidth = 0;

  /* 
   * If a SPACE or a TAB was eaten at the end of a line by MLBuildchLines
   * to prevent a delimiter appearing at the begining of a line, the 
   * the following calculation will become negative causing this bug.
   * So, now, we take zero in such cases.
   * Fix for Bug #3566 --01/31/91-- SANKAR -- 
   */
  lineWidth = max(0, ped->rcFmt.right-ped->rcFmt.left-lineWidth);
    
  if (ped->format == ES_CENTER)
      return(lineWidth/2);

  if (ped->format == ES_RIGHT)
      /* Subtract 1 so that the 1 pixel wide cursor will be in the visible
       * region on the very right side of the screen.  
       */
      return(max(0, lineWidth-1));
}


ICH NEAR PASCAL MLMoveSelection(register PED ped,
                                ICH	     ich,
                                BOOL	     fLeft)
/* effects: Moves the selection character in the direction indicated.  Assumes
 * you are starting at a legal point, we decrement/increment the ich. Then,
 * This decrements/increments it some more to get past CRLFs...  
 */
{
  register PSTR pText;

  if (fLeft && ich > 0)
    {
      /* Move left */
#ifdef FE_SB
      pText = LMHtoP( ped->hText ) + ich;
      if( ECIsDBCSLeadByte(ped, *ECAnsiPrev(ped, LMHtoP(ped->hText), pText ) ) )
          ich--;
#endif /* FE_SB */
      ich--;
      if (ich)
	{
	  /* Check for CRLF or CRCRLF */
	  /*pText = LocalLock(ped->hText)+ich;*/
	  pText = LMHtoP(ped->hText)+ich;

	  /* Move before CRLF or CRCRLF */
	  if (*pText == 0x0A)
	    {
	      ich--;
	      if (ich && *(pText-2) == 0x0D)
		  ich--;
	    }
	  /*LocalUnlock(ped->hText);*/
       }
    }
  else if (!fLeft && ich < ped->cch)
    {
#ifdef FE_SB
      pText = LMHtoP(ped->hText)+ich;
      if( ECIsDBCSLeadByte(ped, *pText ) )
          ich++;
#endif /* FE_SB */
      ich++;
      if (ich < ped->cch)
	{
	  /*pText = LocalLock(ped->hText)+ich;*/
	  pText = LMHtoP(ped->hText)+ich;

	  /* Move after CRLF */
	  if (*pText == 0x0A)
	      ich++;
	  else /* Check for CRCRLF */
	  if (ich && *pText == 0x0D && *(pText-1) == 0x0D)
	      ich+=2;
	  /*LocalUnlock(ped->hText);*/
       }
    }
  return(ich);
}


void FAR PASCAL MLSetCaretPosition(register PED ped, HDC hdc)
/* effects: If the window has the focus, find where the caret belongs and move
 * it there.  
 */
{
  LONG position;
  BOOL prevLine;

  /* We will only position the caret if we have the focus since we don't want
   * to move the caret while another window could own it.  
   */

  if (!ped->fFocus || ped->fNoRedraw)
      return;

  if(ped->fCaretHidden)
    {
      SetCaretPos(-20000, -20000);
      return;
    }

  /* Find the position of the caret */
  if ((ped->iCaretLine < ped->screenStart) || 
      (ped->iCaretLine > ped->screenStart+ped->ichLinesOnScreen))
      /* Caret is not visible. Make it a very small value so that it won't be
       * seen.  
       */
      SetCaretPos(-20000,-20000);
  else
    {
      if (ped->cLines-1 != ped->iCaretLine &&
	  ped->ichCaret == ped->chLines[ped->iCaretLine+1])
	  prevLine=TRUE;
      else
	  prevLine=FALSE;

      position = MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine);
      if (ped->fWrap)
        {
          if (HIWORD(position) > ped->rcFmt.bottom-ped->lineHeight)
	      SetCaretPos(-20000,-20000);
          else
            {
              /* Make sure the caret is in the visible region if word
	       * wrapping. This is so that the caret will be visible if the
	       * line ends with a space.
	       */
	      SetCaretPos(min(LOWORD(position),ped->rcFmt.right-1),
                          HIWORD(position));
            }
        }
      else
        {
          if (LOWORD(position) > ped->rcFmt.right || 
   	      HIWORD(position) > ped->rcFmt.bottom)
	      SetCaretPos(-20000,-20000);
          else
	      SetCaretPos(LOWORD(position),HIWORD(position));
        }
    }
}


ICH FAR PASCAL MLLineLength(register PED ped, int lineNumber)
/* effects: Returns the length of the line given by lineNumber ignoring any
 * CRLFs in the line.  
 */
{
  ICH           result;
  register PSTR pText;

  if (lineNumber >= ped->cLines)
      return(0);

  if (lineNumber == ped->cLines-1)
      /* Since we can't have a CRLF on the last line */
      return(ped->cch - ped->chLines[ped->cLines-1]);
  else
    {
      result = ped->chLines[lineNumber+1] - ped->chLines[lineNumber];
      /* Now check for CRLF or CRCRLF at end of line */
      if (result > 1)
	{
	  /*pText = LocalLock(ped->hText)+ped->chLines[lineNumber+1]-2;*/
	  pText = LMHtoP(ped->hText)+ped->chLines[lineNumber+1]-2;
	  if (*pText == 0x0D)
	    {
	      result = result - 2;
	      if (result && *(--pText) == 0x0D)
		  /* In case there was a CRCRLF */
		  result--;
	    }
	  /*LocalUnlock(ped->hText);*/
	}
    }
  return(result);
}


int FAR PASCAL MLIchToLineHandler(register PED ped, ICH ich)
/* effects: Returns the line number (starting from 0) which contains the given
 * character index.  If ich is -1, return the line the the first char in the
 * selection is on (the caret if no selection) 
 */
{
  register int line = ped->cLines-1;

  if (ich == 0xFFFF)
      ich = ped->ichMinSel;

  /* We could do a binary search here but is it really worth it??? We will
   * have to wait and see how often this proc is being called... 
   */

  while (line && (ich < ped->chLines[line]))
	 line--;

  return(line);
}


LONG NEAR PASCAL MLIchToXYPos(register PED ped,
                              HDC	   hdc,
                              ICH          ich,
                              BOOL	   prevLine)
/* effects: Given an ich, return its x,y coordinates with respect to the top
 * left character displayed in the window.  Returns the coordinates of the top
 * left position of the char.  If prevLine is TRUE then if the ich is at the
 * beginning of the line, we will return the coordinates to the right of the
 * last char on the previous line (if it is not a CRLF).  x is in the loword,
 * y in the highword.  
 */
{
  int	   iline;
  ICH	   cch;
  int	   xPosition,yPosition;
  int	   xOffset;
	   /*
	    * For horizontal scroll displacement on left justified text and
	    * for indent on centered or right justified text
	    */
  PSTR	   pText,pTextStart,pLineStart;

  /* Determine what line the character is on */
  iline = MLIchToLineHandler(ped, ich);

  /* Calc. the yPosition now.  Note that this may change by the height of one
   * char if the prevLine flag is set and the ICH is at the beginning of a
   * line.  
   */
  yPosition = (iline-ped->screenStart)*ped->lineHeight+ped->rcFmt.top;


  /* Now determine the xPosition of the character */
  pTextStart = LocalLock(ped->hText);

  if (prevLine && iline && (ich == ped->chLines[iline]) &&
      (*(pTextStart+ich-1) != 0x0A))
    {
      /* First char in the line.  We want text extent upto end of the previous
       * line if we aren't at the 0th line.  
       */
      iline--;

      yPosition = yPosition - ped->lineHeight;
      pLineStart = pTextStart+ped->chLines[iline];

      /* Note that we are taking the position in front of any CRLFs in the
       * text.  
       */
      cch = MLLineLength(ped, iline);
    }
  else
    {
      pLineStart = pTextStart + ped->chLines[iline];
      pText = pTextStart + ich;

      /* Strip off CRLF or CRCRLF. Note that we may be pointing to a CR but in
       * which case we just want to strip off a single CR or 2 CRs.  
       */
      /* We want pText to point to the first CR at the end of the line if
       * there is one. Thus, we will get an xPosition to the right of the last
       * visible char on the line otherwise we will be to the left of
       * character ich.  
       */

      /* Check if we at the end of text */
      if(ich < ped -> cch)
      {
	if (ich && *pText == 0x0A)
	    pText--;
	if (ich > 2 && *(pText-1) == 0x0D)
	    pText--;
      }

      cch = pText - pLineStart;
    }

  /* Find out how many pixels we indent the line for funny formats */
  if (ped->format != ES_LEFT)
      xOffset = MLCalcXOffset(ped, hdc, iline);
  else
      xOffset = -ped->xOffset;
  

  xPosition = ped->rcFmt.left + xOffset +
	      LOWORD(LocGetTabbedTextExtent(hdc, pLineStart, cch, ped));

  LocalUnlock(ped->hText);
  return(MAKELONG(xPosition,yPosition));
}


LONG NEAR PASCAL MLMouseToIch(register PED  ped,
                              HDC	    hdc,
                              POINT	    mousePt)
/* effects: Returns the closest cch to where the mouse point is.  cch is in
 * the lowword and lineindex is in the high word.  (So that we can tell if we
 * are at the beginning of the line or end of the previous line.)  
 */
{
  int  xOffset;
  PSTR pText;
  PSTR pLineStart;
  int  height = mousePt.y;
  int  line;
  int  width = mousePt.x;
  ICH  cch;
  ICH  cLineLength;
  ICH  cLineLengthNew;
  ICH  cLineLengthHigh=0;
  ICH  cLineLengthLow=0;
  int  textWidth;
  int  iOldTextWidth;
  int  iCurWidth;

  /* First determine which line the mouse is pointing to.  
   */
  line = ped->screenStart;
  if (height <= ped->rcFmt.top)
      /* Either return 0 (the very first line, or one line before the top line
       * on the screen. Note that these are signed mins and maxes since we
       * don't expect (or allow) more than 32K lines.  
       */
      line = max(0, line-1);
  else if (height >= ped->rcFmt.bottom)
      /* Are we below the last line displayed */
      line = min(line+ped->ichLinesOnScreen,ped->cLines-1);
  else
      /* We are somewhere on a line visible on screen */
      line=min(line+((height-ped->rcFmt.top)/ped->lineHeight),ped->cLines-1);


  /* Now determine what horizontal character the mouse is pointing to.  
   */
  pLineStart=(pText=LocalLock(ped->hText))+ped->chLines[line];
  cLineLength = MLLineLength(ped,line); /* Length is sans CRLF or CRCRLF */


  /* xOffset will be a negative value for center and right justified lines.
   * ie. We will just displace the lines left by the amount of indent for
   * right and center justification. Note that ped->xOffset will be 0 for
   * these lines since we don't support horizontal scrolling with them.  
   */
  if (ped->format != ES_LEFT)
      xOffset = MLCalcXOffset(ped,hdc,line);
  else
      /* So that we handle a horizontally scrolled window for left justified
       * text.  
       */
      xOffset = 0;

  width = width - xOffset;

  /* The code below is tricky... I depend on the fact that ped->xOffset is 0
   * for right and center justified lines 
   */

  /* Now find out how many chars fit in the given width */
  if (width >= ped->rcFmt.right)
    {
      /* Return 1+last char in line or one plus the last char visible */
      cch = ECCchInWidth(ped, hdc, (LPSTR)pLineStart, cLineLength, 
			 ped->rcFmt.right-ped->rcFmt.left+ped->xOffset);
#ifdef	FE_SB
      {
	ICH cch2;
        cch2 = umin(cch+1,cLineLength);
        if (ECAdjustIch( ped, pLineStart, cch2 ) != cch2)
	  /* Displayed character on the right edge is DBCS */
	  cch = umin(cch+2,cLineLength);
        else cch = cch2;
        cch += ped->chLines[line];
      }
#else
      cch = ped->chLines[line]+umin(cch+1,cLineLength);
#endif
    } 
  else if (width <= ped->rcFmt.left + ped->aveCharWidth/2)
    {
      /* Return first char in line or one minus first char visible.  Note that
       * ped->xOffset is 0 for right and centered text so we will just return
       * the first char in the string for them. (Allow a avecharwidth/2
       * positioning border so that the user can be a little off...  
       */
      cch = ECCchInWidth(ped, hdc, (LPSTR)pLineStart, cLineLength, 
			 ped->xOffset);
      if (cch)
	  cch--;

#ifdef FE_SB
      cch = ECAdjustIch( ped, pLineStart, cch );
#endif
      cch = ped->chLines[line]+cch;
    }
  else
    {
      /* Now the mouse is somewhere on the visible portion of the text
       * remember cch contains the length the line.  
       */
      iCurWidth = width + ped->xOffset;

      cLineLengthHigh = cLineLength+1;
      while(cLineLengthLow < cLineLengthHigh-1)
        {
          cLineLengthNew = umax((cLineLengthHigh-cLineLengthLow)/2,1)+
                           cLineLengthLow;

          /* Add in a avecharwidth/2 so that if user is half way on the next
	   * char, it is still considered the previous char. For that feel.  
	   */
          textWidth = ped->rcFmt.left + ped->aveCharWidth/2 +
	       LOWORD(LocGetTabbedTextExtent(hdc, pLineStart,
					     cLineLengthNew, ped));
          if (textWidth > iCurWidth)
              cLineLengthHigh = cLineLengthNew;
          else
              cLineLengthLow = cLineLengthNew;

  	  /* Preserve the old Width */
	  iOldTextWidth = textWidth;
	}

      /* Find out which side of the character the mouse click occurred */
      if ((iOldTextWidth - iCurWidth) < (iCurWidth - textWidth))
	  cLineLengthNew++;

      cLineLength = umin(cLineLengthNew,cLineLength);

#ifdef FE_SB
      cLineLength = ECAdjustIch( ped, pLineStart, cLineLength );
#endif

      cch = ped->chLines[line]+cLineLength;
    }
  LocalUnlock(ped->hText);
  return(MAKELONG(cch,line));
}


void NEAR PASCAL MLRepaintChangedSelection(PED	ped,
					   HDC	hdc,
					   ICH	ichOldMinSel,
					   ICH	ichOldMaxSel)

/* When selection changes, this takes care of drawing the changed portions
 * with proper attributes.  
 */
{
  BLOCK Blk[2];
  int   iBlkCount = 0;
  int   i;

  Blk[0].StPos = ichOldMinSel;
  Blk[0].EndPos = ichOldMaxSel;
  Blk[1].StPos = ped->ichMinSel;
  Blk[1].EndPos = ped->ichMaxSel;

  if (ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, 
                            (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1]))
    {
      /* Paint the rectangles where selection has changed */
      /* Paint both Blk[0] and Blk[1], if they exist */
      for(i = 0; i < 2; i++)
       {
        if (Blk[i].StPos != -1)
            MLDrawText(ped, hdc, Blk[i].StPos, Blk[i].EndPos);
       }
    }
}


void FAR PASCAL MLChangeSelection(register PED ped,
				  HDC	       hdc,
				  ICH	       ichNewMinSel,
				  ICH	       ichNewMaxSel)
/* effects: Changes the current selection to have the specified starting and
 * ending values.  Properly highlights the new selection and unhighlights
 * anything deselected.  If NewMinSel and NewMaxSel are out of order, we swap
 * them. Doesn't update the caret position.  
 */
{

  ICH  temp;
  ICH  ichOldMinSel, ichOldMaxSel;

  if (ichNewMinSel > ichNewMaxSel)
    {
      temp = ichNewMinSel;
      ichNewMinSel = ichNewMaxSel;
      ichNewMaxSel = temp;
    }
    ichNewMinSel = umin(ichNewMinSel, ped->cch);
    ichNewMaxSel = umin(ichNewMaxSel, ped->cch);

  /* Save the current selection */
  ichOldMinSel = ped->ichMinSel;
  ichOldMaxSel = ped->ichMaxSel;

  /* Set new selection */
  ped->ichMinSel = ichNewMinSel;
  ped->ichMaxSel = ichNewMaxSel;

  /* We only update the selection on the screen if redraw is on and if we have
   * the focus or if we don't hide the selection when we don't have the focus.
   */
  if (!ped->fNoRedraw && (ped->fFocus || ped->fNoHideSel))
    {
      /* Find old selection region, find new region, and invert the XOR of the
       * two and invert only the XOR region.
       */
      
      MLRepaintChangedSelection(ped, hdc, ichOldMinSel, ichOldMaxSel);

      MLSetCaretPosition(ped,hdc);
    }

}

// This updates the ped->iCaretLine field from the ped->ichCaret;
// Also, when the caret gets to the beginning of next line, pop it up to
// the end of current line when inserting text;
void NEAR PASCAL  MLUpdateiCaretLine(PED ped)
{
  PSTR   pText;

  ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);

  /* If caret gets to beginning of next line, pop it up to end of current line
   * when inserting text.
   */
  pText = LMHtoP(ped->hText)+ped->ichCaret-1;
  if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
      *pText != 0x0A)
      ped->iCaretLine--;
}

ICH FAR PASCAL MLInsertText(ped, lpText, cchInsert, fUserTyping)
register PED   ped;
LPSTR	       lpText;
ICH            cchInsert;
BOOL           fUserTyping;
/* effects: Adds up to cchInsert characters from lpText to the ped starting at
 * ichCaret. If the ped only allows a maximum number of characters, then we
 * will only add that many characters to the ped.  The number of characters
 * actually added is returned (could be 0). If we can't allocate the required
 * space, we notify the parent with EN_ERRSPACE and no characters are added.
 * We will rebuild the lines array as needed.  fUserTyping is true if the
 * input was the result of the user typing at the keyboard. This is so we can
 * do some stuff faster since we will be getting only one or two chars of
 * input.  
 */
{
  HDC		hdc;
  ICH		validCch=cchInsert;
  ICH           oldCaret = ped->ichCaret;
  int           oldCaretLine = ped->iCaretLine;
  BOOL          fCRLF=FALSE;
  LONG          l;
  WORD          localundoType = 0;
  HANDLE        localhDeletedText;
  ICH           localichDeleted;
  ICH           localcchDeleted;
  ICH           localichInsStart;
  ICH           localichInsEnd;
  LONG          xyPosInitial=0L;
  LONG          xyPosFinal=0L;

  if (!validCch)
      return(0);

  if (validCch)
    {
      /* Limit the amount of text we add */
      _asm int 3
      if (ped->cchTextMax <= ped->cch)
        {
	  /* When the max chars is reached already, notify parent */
	  /* Fix for Bug #4183 -- 02/06/91 -- SANKAR -- */
      	  ECNotifyParent(ped,EN_MAXTEXT);
          return(0);
	}

      validCch = umin(validCch, ped->cchTextMax - ped->cch);
      /* Make sure we don't split a CRLF in half */
      if (validCch && *(lpText+validCch) == 0x0A)
	  validCch--;
      if (!validCch)
        {
	  /* When the max chars is reached already, notify parent */
	  /* Fix for Bug #4183 -- 02/06/91 -- SANKAR -- */
      	  ECNotifyParent(ped,EN_MAXTEXT);
          return(0);
	}

      if (validCch == 2 && (*(WORD FAR *)lpText) == 0x0A0D)
          fCRLF=TRUE;

      if (!ped->fAutoVScroll && 
          (ped->undoType==UNDO_INSERT || ped->undoType==UNDO_DELETE))
        {
          /* Save off the current undo state */
          localundoType     = ped->undoType;
          localhDeletedText = ped->hDeletedText;
          localichDeleted   = ped->ichDeleted;
          localcchDeleted   = ped->cchDeleted;
          localichInsStart  = ped->ichInsStart; 
          localichInsEnd    = ped->ichInsEnd; 

          /* Kill undo */
          ped->undoType = UNDO_NONE;
          ped->hDeletedText  = NULL;
          ped->ichDeleted=
          ped->cchDeleted = 
          ped->ichInsStart=
          ped->ichInsEnd  = 0;
        }

      hdc = ECGetEditDC(ped,FALSE);
      if (ped->cch)
          xyPosInitial = MLIchToXYPos(ped, hdc, ped->cch-1, FALSE);


      /* Insert the text */
      if (!ECInsertText(ped, lpText, validCch))
	{
          ECReleaseEditDC(ped,hdc,FALSE);
	  ECNotifyParent(ped, EN_ERRSPACE);
	  return(0);
	}
      /* Note that ped->ichCaret is updated by ECInsertText */
    }

  l = MLBuildchLines(ped, oldCaretLine, validCch, 
                     (fCRLF ? FALSE : fUserTyping));

  if (ped->cch)
      xyPosFinal = MLIchToXYPos(ped, hdc, ped->cch-1, FALSE);

  if (HIWORD(xyPosFinal) < HIWORD(xyPosInitial) &&
      ped->screenStart+ped->ichLinesOnScreen >= ped->cLines-1)
    {
      RECT rc;
      CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
      rc.top = HIWORD(xyPosFinal)+ped->lineHeight;
      InvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }

  if (!ped->fAutoVScroll)
    {
      if (ped->ichLinesOnScreen < ped->cLines)
        {
          MLUndoHandler(ped);
          ECEmptyUndo(ped);
          if (localundoType == UNDO_INSERT || localundoType == UNDO_DELETE)
            {
              ped->undoType = localundoType;
              ped->hDeletedText = localhDeletedText;
              ped->ichDeleted   = localichDeleted;
              ped->cchDeleted   = localcchDeleted;
              ped->ichInsStart  = localichInsStart;
              ped->ichInsEnd    = localichInsEnd;
            }
          MessageBeep(0);
          ECReleaseEditDC(ped,hdc,FALSE);
          return(0);
        }
      else
        {
          if (localundoType == UNDO_INSERT || localundoType == UNDO_DELETE)
              GlobalFree(localhDeletedText);
        }
    }

  if (fUserTyping && ped->fWrap)
#ifdef FE_SB
      /* To avoid oldCaret points intermediate of DBCS character,
       * adjust oldCaret position if necessary.
       */
      oldCaret = ECAdjustIch(ped, LMHtoP(ped->hText), umin(LOWORD(l), oldCaret));
#else
      oldCaret = umin(LOWORD(l), oldCaret);
#endif


  /* These are updated by ECInsertText so we won't do it again */
  /* ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;*/
#ifdef NEVER
  ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);

  /* If caret gets to beginning of next line, pop it up to end of current line
   * when inserting text.
   */
  pText = LMHtoP(ped->hText)+ped->ichCaret-1;
  if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
      *pText != 0x0A)
      ped->iCaretLine--;
#else
  // Update ped->iCaretLine properly.
  MLUpdateiCaretLine(ped);
#endif

  ECNotifyParent(ped,EN_UPDATE);

  if (fCRLF || !fUserTyping)
      /* Redraw to end of screen/text if crlf or large insert. 
       */
      MLDrawText(ped, hdc, (fUserTyping ? oldCaret : 0), ped->cch);
  else
      MLDrawText(ped, hdc, oldCaret, umax(ped->ichCaret,HIWORD(l)));

  ECReleaseEditDC(ped,hdc,FALSE);

  /* Make sure we can see the cursor */
  MLEnsureCaretVisible(ped);

  ped->fDirty = TRUE;

  ECNotifyParent(ped,EN_CHANGE);

  if (validCch < cchInsert)
      ECNotifyParent(ped,EN_MAXTEXT);

  return(validCch);
}


ICH NEAR PASCAL MLDeleteText(register PED ped)
/* effects: Deletes the characters between ichMin and ichMax.  Returns the
 * number of characters we deleted.  
 */
{
  ICH  minSel = ped->ichMinSel;
  ICH  maxSel = ped->ichMaxSel;
  ICH  cchDelete;
  HDC  hdc;
  int  minSelLine;
  int  maxSelLine;
  LONG xyPos;
  RECT rc;
  BOOL fFastDelete = FALSE;
  LONG l;
#ifdef FE_SB
  ICH  cchcount;
#endif

  /* Get what line the min selection is on so that we can start rebuilding the
   * text from there if we delete anything.  
   */
  minSelLine = MLIchToLineHandler(ped,minSel);
  maxSelLine = MLIchToLineHandler(ped,maxSel);
#ifdef FE_SB
  switch(maxSel - minSel)
    {
     case 2:
         if (ECIsDBCSLeadByte(ped,*(LMHtoP(ped->hText)+minSel)) == FALSE)
         break;
         /* Fall thru */
     case 1:
//         if ((minSelLine==maxSelLine) && (ped->chLines[minSelLine] != minSel))
         if (minSelLine==maxSelLine)
              {
                if (!ped->fAutoVScroll)
                    fFastDelete = FALSE;
                else
                  {
                    fFastDelete = TRUE;
                    cchcount = ((maxSel - minSel) == 1) ? 0 : -1;
                  }
              }
    }
#else
  if (((maxSel - minSel) == 1) && 
      (minSelLine==maxSelLine) &&
      (ped->chLines[minSelLine] != minSel))
    {
      if (!ped->fAutoVScroll)
          fFastDelete = FALSE;
      else
          fFastDelete = TRUE;
    }
#endif
  if (!(cchDelete=ECDeleteText(ped)))
      return(0);

  /* Start building lines at minsel line since caretline may be at the max sel
   * point.  
   */
  if (fFastDelete)
    {
#ifdef FE_SB
      MLShiftchLines(ped, minSelLine+1, -2+cchcount);
#else
      MLShiftchLines(ped, minSelLine+1, -2);
#endif
      l=MLBuildchLines(ped, minSelLine, 1, TRUE);
    }
  else
    {
      MLBuildchLines(ped,max(minSelLine-1,0),-cchDelete, FALSE);
    }
#ifdef NEVER
  ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);

  /* If caret gets to beginning of this line, pop it up to end of previous
   * line when deleting text 
   */
  pText = LMHtoP(ped->hText)+ped->ichCaret;
  if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret
      && *(pText-1)!= 0x0A)
      ped->iCaretLine--;
#else
  MLUpdateiCaretLine(ped);
#endif

#if 0
  if (!ped->fAutoVScroll)
      ECEmptyUndo(ped);
#endif
  ECNotifyParent(ped,EN_UPDATE);

  /* Now update the screen to reflect the deletion */
  hdc = ECGetEditDC(ped,FALSE);
  /* Otherwise just redraw starting at the line we just entered */
  minSelLine = max(minSelLine-1,0);
  if (fFastDelete)
      MLDrawText(ped, hdc, ped->chLines[minSelLine], HIWORD(l));
  else
      MLDrawText(ped, hdc, ped->chLines[minSelLine], ped->cch);

  if (ped->cch)
    {
      /* Clear from end of text to end of window. 
       */
      xyPos = MLIchToXYPos(ped, hdc, ped->cch, FALSE);
      CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
      rc.top = HIWORD(xyPos)+ped->lineHeight;
      InvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }
  else
    {
      InvalidateRect(ped->hwnd, (LPRECT)&ped->rcFmt, TRUE);
    }
  ECReleaseEditDC(ped,hdc,FALSE);

  MLEnsureCaretVisible(ped);

  ped->fDirty = TRUE;

  ECNotifyParent(ped,EN_CHANGE);
  return(cchDelete);
}


BOOL NEAR PASCAL MLInsertchLine(register PED ped,
                                int	     iLine,
				ICH	     ich,
				BOOL         fUserTyping)
/* effects: Inserts the line iline and sets its starting character index to be
 * ich.  All the other line indices are moved up.  Returns TRUE if successful
 * else FALSE and notifies the parent that there was no memory.  
 */
{
  HANDLE hResult;

  if (fUserTyping && iLine < ped->cLines)
    {
      ped->chLines[iLine] = ich;
      return(TRUE);
    }

  hResult = 
	 LocalReAlloc((HANDLE)ped->chLines,(ped->cLines+2)*sizeof(int),LHND);

  if (!hResult)
    {
      ECNotifyParent(ped, EN_ERRSPACE);
      return(FALSE);
    }

  ped->chLines = (int *)hResult;
  /* Move indices starting at iLine up */
  LCopyStruct((LPSTR)(&ped->chLines[iLine]),(LPSTR)(&ped->chLines[iLine+1]),
	      (ped->cLines-iLine)*sizeof(int));
  ped->cLines++;

  ped->chLines[iLine] = ich;
  return(TRUE);
}

#if 0
BOOL NEAR PASCAL MLGrowLinesArray(ped, cLines)
register PED  ped;
int	      cLines;
/* effects: Grows the line start array in the ped so that it holds cLines.
 * Notifies parent and returns FALSE if no memory error.  We won't allow more
 * than 32700 lines in the edit control.  This allows us to use signed values
 * for line counts while still providing good functionality.  
 */
{
  HANDLE  hResult;


  if (cLines<32700 && 
      (hResult = LocalReAlloc((HANDLE)ped->chLines,
			      (cLines+1)*sizeof(ICH),LHND)))

      ped->chLines = (int *)hResult;
  else
      ECNotifyParent(ped, EN_ERRSPACE);


  return((BOOL)hResult);
}
#endif

void NEAR PASCAL MLShiftchLines(register PED ped,
				register int iLine,
				int	     delta)
/* effects: Move the starting index of all lines iLine or greater by delta
 * bytes.  
 */
{
  if (iLine >= ped->cLines)
      return;

  /* Just add delta to the starting point of each line after iLine */
  for (;iLine<ped->cLines;iLine++)
       ped->chLines[iLine] += delta;
}


LONG FAR PASCAL MLBuildchLines(ped, iLine, cchDelta, fUserTyping)
register PED ped;
int	     iLine;
int	     cchDelta;
BOOL         fUserTyping;
/* effects:  Rebuilds the start of line array (ped->chLines) starting at line
 * number ichLine.  Returns TRUE if any new lines were made else returns
 * false. 
 */
{
  register PSTR	ptext; /* Starting address of the text */
  /* We keep these ICH's so that we can Unlock ped->hText when we have to grow
   * the chlines array.  With large text handles, it becomes a problem if we
   * have a locked block in the way.  
   */
  ICH	ichLineStart; 
  ICH	ichLineEnd;
  ICH	ichLineEndBeforeCRLF;
  ICH	ichCRLF;

  int   iLineStart = iLine;
  ICH	cLineLength;
  ICH	cch;
  HDC	hdc;

  BOOL	fLineBroken = FALSE; /* Initially, no new line breaks are made */
  ICH	minCchBreak;
  ICH	maxCchBreak;

  if (!ped->cch)
    {
      ped->maxPixelWidth = 0;
      ped->xOffset = 0;
      ped->screenStart = 0;
      ped->cLines = 1;
      return(TRUE);
    }

  if (fUserTyping && cchDelta)
      MLShiftchLines(ped, iLine+1, cchDelta);

  hdc = ECGetEditDC(ped, TRUE);

  if (!iLine && !cchDelta && !fUserTyping)
    {
      /* Reset maxpixelwidth only if we will be running through the whole
       * text. Better too long than too short.  
       */
      ped->maxPixelWidth = 0;
      /* Reset number of lines in text since we will be running through all
       * the text anyway...  
       */
      ped->cLines = 1;
    }

  /* Set min and max line built to be the starting line */
  minCchBreak = maxCchBreak = (cchDelta ? ped->chLines[iLine] : 0);

  ptext = LocalLock(ped->hText);

  ichCRLF = ichLineStart = ped->chLines[iLine];

  while (ichLineStart < ped->cch)
    {
      if (ichLineStart >= ichCRLF)
	{
	  ichCRLF = ichLineStart;
	  /* Move ichCRLF ahead to either the first CR or to the end of text.
	   */
	  while (ichCRLF < ped->cch && *(ptext+ichCRLF) != 0x0D)
		 ichCRLF++;
	}

      if (!ped->fWrap)
	{
	  /* If we are not word wrapping, line breaks are signified by CRLF.
	   */

	  /* We will limit lines to MAXLINELENGTH characters maximum */
	  ichLineEnd=ichLineStart + umin(ichCRLF-ichLineStart,MAXLINELENGTH);

#ifdef	FE_SB
	  /* To avoid separating between DBCS char, adjust character
	   * position to DBCS lead byte if necessary.
	   */
	  ichLineEnd = ECAdjustIch(ped, ptext, ichLineEnd);
#endif
	  /* We will keep track of what the longest line is for the horizontal
	   * scroll bar thumb positioning. 
	   */
	  ped->maxPixelWidth = umax(ped->maxPixelWidth,
		   (unsigned int)
		   LOWORD(LocGetTabbedTextExtent(hdc, 
		   (ptext+ichLineStart),
		   ichLineEnd-ichLineStart,
		   ped)));
	} 
      else
	{
	  /* Find the end of the line based solely on text extents */
	  ichLineEnd = ichLineStart + 
		       ECCchInWidth(ped, hdc, (LPSTR)(ptext+ichLineStart),
				    ichCRLF-ichLineStart, 
				    ped->rcFmt.right-ped->rcFmt.left);
	  if (ichLineEnd == ichLineStart && ichCRLF-ichLineStart)
	    {
	      /* Maintain a minimum of one char per line */
	      ichLineEnd++;
	    }

  
#ifdef NEVER
	  /* Now starting from ichLineEnd, if we are not at a hard line break,
	   * then if we are not at a space (or CR) or the char before us is
	   * not a space, we will look word left for the start of the word to
	   * break at.  
	   */
	  if (ichLineEnd != ichCRLF)
	      if (!MLIsDelimiter(*(ptext+ichLineEnd)) ||
		  *(ptext+ichLineEnd) == 0x0D ||
		  !MLIsDelimiter(*(ptext+ichLineEnd-1)))
#else
	  /* Now starting from ichLineEnd, if we are not at a hard line break,
	   * then if we are not at a space AND the char before us is
	   * not a space,(OR if we are at a CR) we will look word left for the 
	   * start of the word to break at.  
	   * This change was done for TWO reasons:
	   *   1. If we are on a delimiter, no need to look word left to break at.
	   *   2. If the previous char is a delimter, we can break at current char.
	   * Change done by -- SANKAR --01/31/91--
	   */
	  if (ichLineEnd != ichCRLF)
	      if ((!MLIsDelimiter(*(ptext+ichLineEnd)) &&
	           !MLIsDelimiter(*(ptext+ichLineEnd-1))) ||
		  *(ptext+ichLineEnd) == 0x0D)
#endif
	        {
#ifdef FE_SB
		  cch = LOWORD(ECWord(ped, ichLineEnd, FALSE));
#else
		  cch = LOWORD(ECWord(ped, ichLineEnd, TRUE));
#endif
  		  if (cch > ichLineStart)
		      ichLineEnd = cch;
 		  /* Now, if the above test fails, it means the word left goes
		   * back before the start of the line ie. a word is longer
		   * than a line on the screen.  So, we just fit as much of
		   * the word on the line as possible.  Thus, we use the
		   * pLineEnd we calculated solely on width at the beginning
		   * of this else block...  
		   */
	        }
	}
#if 0
      if (!MLIsDelimiter((*(ptext+ichLineEnd-1))) &&
          MLIsDelimiter((*(ptext+ichLineEnd))))
#endif
      if ((*(ptext+ichLineEnd-1)!= ' ' && *(ptext+ichLineEnd-1)!= TAB) && 
          (*(ptext+ichLineEnd) == ' ' || *(ptext+ichLineEnd) == TAB))
          /* Swallow the space at the end of a line. */
          ichLineEnd++;

      /* Skip over crlf or crcrlf if it exists. Thus, ichLineEnd is the first
       * character in the next line.  
       */
      ichLineEndBeforeCRLF = ichLineEnd;

      if (*(ptext+ichLineEnd) == 0x0D)
	  ichLineEnd +=2;
      /* Skip over CRCRLF */
      if (*(ptext+ichLineEnd) == 0x0A)
	  ichLineEnd++;

      /* Now, increment iLine, allocate space for the next line, and set its
       * starting point 
       */
      iLine++;

      if (!fUserTyping ||/* (iLineStart+1 >= iLine) || */
          (iLine > ped->cLines-1) ||
          (ped->chLines[iLine] != ichLineEnd))
	{
	  /* The line break occured in a different place than before. */
	  if (!fLineBroken)
	    {
	      /* Since we haven't broken a line before, just set the min break
	       * line.  
	       */
	      fLineBroken = TRUE;
              if (ichLineEndBeforeCRLF == ichLineEnd)
                  minCchBreak = maxCchBreak = (ichLineEnd ? ichLineEnd-1 : 0);
              else
                  minCchBreak = maxCchBreak = ichLineEndBeforeCRLF;
	    }
	  maxCchBreak = umax(maxCchBreak,ichLineEnd);

	  LocalUnlock(ped->hText);
	  /* Now insert the new line into the array */
	  if (!MLInsertchLine(ped, iLine, ichLineEnd, (BOOL)(cchDelta!=0)))
	    {
	      ECReleaseEditDC(ped,hdc,TRUE);
	      return(MAKELONG(minCchBreak,maxCchBreak));
	    }

	  ptext = LocalLock(ped->hText);
	}
      else
        {
          maxCchBreak = ped->chLines[iLine];
          /* Quick escape */
          goto EndUp;
        }

      ichLineStart = ichLineEnd;
    } /* end while (ichLineStart < ped->cch) */


  if (iLine != ped->cLines)
    {
      ped->cLines = iLine;
      ped->chLines[ped->cLines] = 0;
    }

  /* Note that we incremented iLine towards the end of the while loop so, the
   * index, iLine, is actually equal to the line count 
   */
  if (ped->cch && 
      *(ptext+ped->cch-1) == 0x0A && 
      ped->chLines[ped->cLines-1]<ped->cch)
      /* Make sure last line has no crlf in it */
    {
      if (!fLineBroken)
	{
	  /* Since we haven't broken a line before, just set the min break
	   * line.  
	   */
	  fLineBroken = TRUE;
          minCchBreak = ped->cch-1;
	}
      maxCchBreak= umax(maxCchBreak,ichLineEnd);
      LocalUnlock(ped->hText);
      MLInsertchLine(ped, iLine, ped->cch, FALSE);
    }
  else
EndUp:
      LocalUnlock(ped->hText);

  ECReleaseEditDC(ped, hdc, TRUE);
  return(MAKELONG(minCchBreak,maxCchBreak));
}


void NEAR PASCAL MLPaintHandler(register PED ped,
				HDC	     althdc)
/* effects: Handles WM_PAINT messages.  
 */
{
  PAINTSTRUCT ps;
  HDC	      hdc;
  HDC	      hdcWindow;
  RECT	      rcEdit;
  DWORD	      dwStyle;
  HANDLE      hOldFont;
  POINT       pt;
  ICH         imin;
  ICH         imax;

  /* Allow subclassed hdcs.  
   */
  if (althdc)
      hdc = althdc;
  else
      hdc = BeginPaint(ped->hwnd, (PAINTSTRUCT FAR *)&ps);

  if (!ped->fNoRedraw && IsWindowVisible(ped->hwnd))
    {
#if 0
      if (althdc || ps.fErase)
	{
	  hBrush = GetControlBrush(ped->hwnd, hdc, CTLCOLOR_EDIT);
	  /* Erase the background since we don't do it in the erasebkgnd
	   * message 
	   */
	  FillWindow(ped->hwndParent, ped->hwnd, hdc, hBrush);
	}
#endif
      if (ped->fBorder)
	{
//	  hdcWindow = GetWindowDC(ped->hwnd);
          hdcWindow = hdc;
	  GetWindowRect(ped->hwnd, &rcEdit);
	  OffsetRect(&rcEdit, -rcEdit.left, -rcEdit.top);

	  dwStyle = GetWindowLong(ped->hwnd, GWL_STYLE);
	  if (HIWORD(dwStyle) & HIWORD(WS_SIZEBOX))
	    {
              /* Note we can't use user's globals here since we are on a
	       * different ds when in the edit control code. 
	       */
	      InflateRect(&rcEdit,
                          -GetSystemMetrics(SM_CXFRAME)+
                           GetSystemMetrics(SM_CXBORDER),
                          -GetSystemMetrics(SM_CYFRAME)+
                           GetSystemMetrics(SM_CYBORDER));

	    }

	  DrawFrame(hdcWindow, (LPRECT)&rcEdit, 1, DF_WINDOWFRAME);
//	  ReleaseDC(ped->hwnd, hdcWindow);
	}

     ECSetEditClip(ped, hdc);
     if (ped->hFont)
	 hOldFont = SelectObject(hdc, ped->hFont);

     if (!althdc)
       {
         pt.x = ps.rcPaint.left;
         pt.y = ps.rcPaint.top;
         imin = MLMouseToIch(ped, hdc, pt)-1;
         if (imin == -1)
             imin = 0;
         pt.x = ps.rcPaint.right;
         pt.y = ps.rcPaint.bottom;
         imax = MLMouseToIch(ped, hdc, pt)+1;
         MLDrawText(ped, hdc, imin, imax);
       }
     else
         MLDrawText(ped, hdc, 0, ped->cch);

     if (ped->hFont && hOldFont)
	 SelectObject(hdc, hOldFont);
  }

  if (!althdc)
      EndPaint(ped->hwnd, (PAINTSTRUCT FAR *)&ps);
}


void FAR PASCAL MLCharHandler(ped, keyValue, keyMods)
register PED  ped;
WORD	      keyValue;
int	      keyMods;
/* effects: Handles character input (really, no foolin') 
 */
{
  char unsigned keyPress = LOBYTE(keyValue);
  BOOL updateText = FALSE;
  int  scState;
#ifdef FE_SB
  WORD DBCSkey;
#endif

  if (ped->fMouseDown || keyPress == VK_ESCAPE)
      /* If we are in the middle of a mousedown command, don't do anything.
       * Also, just ignore it if we get a translated escape key which happens
       * with multiline edit controls in a dialog box. 
       */
      return;

  if (!keyMods)
    {
      /* Get state of modifier keys for use later. */
      scState =	 ((GetKeyState(VK_CONTROL) & 0x8000) ? 1 : 0); 
      /* We are just interested in state of the ctrl key */
      /* scState += ((GetKeyState(VK_SHIFT) & 0x8000) ? 2 : 0); */
    }
  else
      scState = ((keyMods == NOMODIFY) ? 0 : keyMods);

  if (ped->fInDialogBox && ((keyPress == VK_TAB && scState != CTRLDOWN) ||
                            keyPress == VK_RETURN))
      /* If this multiline edit control is in a dialog box, then we want the
       * TAB key to take you to the next control, shift TAB to take you to the
       * previous control, and CTRL-TAB to insert a tab into the edit control.
       * We moved the focus when we received the keydown message so we will
       * ignore the TAB key now unless the ctrl key is down.  Also, we want
       * CTRL-RETURN to insert a return into the text and RETURN to be sent to
       * the default button.  
       */
      return;

  if (ped->fReadOnly)
      /* Ignore keys in read only controls.
       */
      return;

  if (keyPress == 0x0A)
      keyPress = VK_RETURN;

  if (keyPress == VK_TAB  || keyPress == VK_RETURN || 
      keyPress == VK_BACK || keyPress >= ' ')
      /* Delete the selected text if any */
      if (MLDeleteText(ped))
	  updateText=TRUE;

#ifdef FE_SB
  if( IsDBCSLeadByte( keyPress ) )
      if( ( DBCSkey = DBCSCombine( ped->hwnd, keyPress ) ) != NULL )
          keyValue = DBCSkey;
#endif

  switch(keyPress)
  {
    case VK_BACK:
      /* Delete any selected text or delete character left if no sel */
      if (!updateText && ped->ichMinSel)
	{
	  /* There was no selection to delete so we just delete character
	   * left if available 
	   */
	  ped->ichMinSel = MLMoveSelection(ped,ped->ichCaret,TRUE);
	  MLDeleteText(ped);
	}
      break;

    default:
      if (keyPress == VK_RETURN)
	  keyValue = 0x0A0D;

      if (keyPress >= ' ' || keyPress == VK_RETURN || keyPress == VK_TAB)
	  MLInsertText(ped, (LPSTR) &keyValue, 
                       HIBYTE(keyValue) ? 2 : 1, TRUE);
      else
	  MessageBeep(0);

      break;
  }
}


void NEAR PASCAL MLKeyDownHandler(register PED ped,
				  WORD	       virtKeyCode,
				  int	       keyMods)
/* effects: Handles cursor movement and other VIRT KEY stuff.  keyMods allows
 * us to make MLKeyDownHandler calls and specify if the modifier keys (shift
 * and control) are up or down. If keyMods == 0, we get the keyboard state
 * using GetKeyState(VK_SHIFT) etc. Otherwise, the bits in keyMods define the
 * state of the shift and control keys.  
 */
{
  HDC hdc;

  /* Variables we will use for redrawing the updated text */
  register ICH newMaxSel = ped->ichMaxSel;
  register ICH newMinSel = ped->ichMinSel;

  /* Flags for drawing the updated text */
  BOOL changeSelection = FALSE; /* new selection is specified by 
				   newMinSel, newMaxSel */

  /* Comparisons we do often */
  BOOL MinEqMax = (newMaxSel == newMinSel);
  BOOL MinEqCar = (ped->ichCaret == newMinSel);
  BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

  /* State of shift and control keys. */
  int scState = 0;

  long position;
  BOOL prevLine;
  POINT mousePt;
  int	defaultDlgId;
  int	iScrollAmt;


  if (ped->fMouseDown)
      /* If we are in the middle of a mousedown command, don't do anything.  
       */
      return;

  if (!keyMods)
    {
      /* Get state of modifier keys for use later. */
      scState =	 ((GetKeyState(VK_CONTROL) & 0x8000) ? 1 : 0); 
      scState += ((GetKeyState(VK_SHIFT) & 0x8000) ? 2 : 0); 
    }
  else
      scState = ((keyMods == NOMODIFY) ? 0 : keyMods);


  switch(virtKeyCode)
  {
    case VK_ESCAPE:
      if (ped->fInDialogBox)
	{
          /* This condition is removed because, if the dialogbox does not
	   * have a CANCEL button and if ESC is hit when focus is on a 
	   * ML edit control the dialogbox must close whether it has cancel
	   * button or not to be consistent with SL edit control;
	   * DefDlgProc takes care of the disabled CANCEL button case.
	   * Fix for Bug #4123 -- 02/07/91 -- SANKAR --
	   */
#if 0
          if (GetDlgItem(ped->hwndParent, IDCANCEL))
#endif
     	      /* User hit ESC...Send a close message (which in turn sends a
	       * cancelID to the app in DefDialogProc... 
	       */
	      PostMessage(ped->hwndParent, WM_CLOSE, 0, 0L);
	}
      return;

    case VK_RETURN:
      if (ped->fInDialogBox)
	{
	  /* If this multiline edit control is in a dialog box, then we want
	   * the RETURN key to be sent to the default dialog button (if there
	   * is one).  CTRL-RETURN will insert a RETURN into the text.  Note
	   * that CTRL-RETURN automatically translates into a linefeed (0x0A)
	   * and in the MLCharHandler, we handle this as if a return was
	   * entered.  
	   */
	  if (scState != CTRLDOWN)
	    {
	      defaultDlgId = LOWORD(SendMessage(ped->hwndParent, 
                                                DM_GETDEFID,
				                0, 0L));
	      if (defaultDlgId)
		{
                  defaultDlgId=(WORD)GetDlgItem(ped->hwndParent, 
                                                defaultDlgId);
                  if (defaultDlgId)
                    {
		      SendMessage(ped->hwndParent, WM_NEXTDLGCTL, 
			          defaultDlgId, 1L);
                      if (!ped->fFocus)
 	                  PostMessage((HWND)defaultDlgId, 
                                      WM_KEYDOWN, VK_RETURN, 0L);
                    }
		}
	    }
	      
	  return;
	}
      break;

    case VK_TAB:
      /* If this multiline edit control is in a dialog box, then we want the
       * TAB key to take you to the next control, shift TAB to take you to the
       * previous control. We always want CTRL-TAB to insert a tab into the
       * edit control regardless of weather or not we're in a dialog box.  
       */
      if (scState == CTRLDOWN)
	  MLCharHandler(ped, virtKeyCode, keyMods);
      else
      if (ped->fInDialogBox)
	  SendMessage(ped->hwndParent, WM_NEXTDLGCTL, 
		      scState==SHFTDOWN, 0L);
      return;
      break;

    case VK_LEFT:
      /* If the caret isn't already at 0, we can move left */
      if (ped->ichCaret)
	{
	  switch (scState)
	  {
	     case NONEDOWN:
	       /* Clear selection, move caret left */
	       ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, TRUE);
	       newMaxSel = newMinSel = ped->ichCaret;
	       break;

	     case CTRLDOWN:
	       /* Clear selection, move caret word left */
	       ped->ichCaret = LOWORD(ECWord(ped,ped->ichCaret,TRUE));
	       newMaxSel = newMinSel = ped->ichCaret;
	       break;

	     case SHFTDOWN:
	       /* Extend selection, move caret left */
	       ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, TRUE);
	       if (MaxEqCar && !MinEqMax)
		   /* Reduce selection extent */
		   newMaxSel = ped->ichCaret;
	       else
		   /* Extend selection extent */
		   newMinSel = ped->ichCaret;
	       break;

	     case SHCTDOWN:
	       /* Extend selection, move caret word left */
	       ped->ichCaret = LOWORD(ECWord(ped,ped->ichCaret,TRUE));
	       if (MaxEqCar && !MinEqMax)
		 {
		   /* Reduce selection extent */
		   /* Hint: Suppose WORD.  OR is selected. Cursor between 
		      R and D. Hit select word left, we want to just select
		      the W and leave cursor before the W. */
		   newMinSel = ped->ichMinSel;
		   newMaxSel = ped->ichCaret;
		 }
	       else
		   /* Extend selection extent */
		   newMinSel = ped->ichCaret;
	       break;
	  }
 
	  changeSelection = TRUE;
	}
      else
	{
	  /* If the user tries to move left and we are at the 0th character 
	     and there is a selection, then cancel the selection. */
	  if (ped->ichMaxSel != ped->ichMinSel && 
	      (scState == NONEDOWN || scState == CTRLDOWN))
	    {
	      changeSelection = TRUE;
	      newMaxSel = newMinSel = ped->ichCaret;
	    }
	}	
      break;


    case VK_RIGHT:
      /* If the caret isn't already at ped->cch, we can move right */
      if (ped->ichCaret < ped->cch)
	{
	  switch (scState)
	  {
	     case NONEDOWN:
	       /* Clear selection, move caret right */
	       ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
	       newMaxSel = newMinSel = ped->ichCaret;
	       break;

	     case CTRLDOWN:
	       /* Clear selection, move caret word right */
	       ped->ichCaret = HIWORD(ECWord(ped,ped->ichCaret,FALSE));
	       newMaxSel = newMinSel = ped->ichCaret;
	       break;

	     case SHFTDOWN:
	       /* Extend selection, move caret right */
	       ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
	       if (MinEqCar && !MinEqMax)
		   /* Reduce selection extent */
		   newMinSel = ped->ichCaret;
	       else
		   /* Extend selection extent */
		   newMaxSel = ped->ichCaret;
	       break;

	     case SHCTDOWN:
	       /* Extend selection, move caret word right */
	       ped->ichCaret = HIWORD(ECWord(ped,ped->ichCaret,FALSE));
	       if (MinEqCar && !MinEqMax)
		 {
		   /* Reduce selection extent */
		   newMinSel = ped->ichCaret;
		   newMaxSel = ped->ichMaxSel;
		 }
	       else
		   /* Extend selection extent */
		   newMaxSel = ped->ichCaret;
	       break;
	   }

	   changeSelection = TRUE;
	}
      else
	{
	  /* If the user tries to move right and we are at the last character
	   * and there is a selection, then cancel the selection. 
	   */
	  if (ped->ichMaxSel != ped->ichMinSel &&
	      (scState == NONEDOWN || scState == CTRLDOWN))
	    {
	      newMaxSel = newMinSel = ped->ichCaret;
	      changeSelection = TRUE;
	    }
	}	
      break;


    case VK_UP:
    case VK_DOWN:
      if (virtKeyCode == VK_UP &&
	  ped->cLines-1 != ped->iCaretLine &&
	  ped->ichCaret == ped->chLines[ped->iCaretLine+1])
	  prevLine= TRUE;
      else
	  prevLine=FALSE;
 
      hdc = ECGetEditDC(ped,TRUE);
      position = MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine);
      ECReleaseEditDC(ped, hdc, TRUE);
      mousePt.x = LOWORD(position);
      mousePt.y = HIWORD(position)+1+ 
		  (virtKeyCode == VK_UP ? -ped->lineHeight : ped->lineHeight);

      if (scState == NONEDOWN || scState == SHFTDOWN)
	{
	  /* Send fake mouse messages to handle this */
	  /* NONEDOWN: Clear selection, move caret up/down 1 line */
	  /* SHFTDOWN: Extend selection, move caret up/down 1 line */
	  MLMouseMotionHandler(ped, WM_LBUTTONDOWN, 
			       scState==NONEDOWN ? 0 : MK_SHIFT, mousePt);
	  MLMouseMotionHandler(ped, WM_LBUTTONUP, 
			       scState==NONEDOWN ? 0 : MK_SHIFT, mousePt);
	}
      break;


    case VK_HOME:
      switch (scState)
	{
	   case NONEDOWN:
	     /* Clear selection, move cursor to beginning of line */
	     newMaxSel = newMinSel = ped->ichCaret = 
						 ped->chLines[ped->iCaretLine];
	     break;

	   case CTRLDOWN:
	     /* Clear selection, move caret to beginning of text */
	     newMaxSel = newMinSel = ped->ichCaret = 0;
	     break;

	   case SHFTDOWN:
	     /* Extend selection, move caret to beginning of line */
	     ped->ichCaret = ped->chLines[ped->iCaretLine];
	     if (MaxEqCar && !MinEqMax)
	       {
		 /* Reduce selection extent */
		 newMinSel = ped->ichMinSel;
		 newMaxSel = ped->ichCaret;
	       }
	     else
		 /* Extend selection extent */
		 newMinSel = ped->ichCaret;
	     break;

	   case SHCTDOWN:
	     /* Extend selection, move caret to beginning of text */
	     ped->ichCaret = newMinSel = 0;
	     if (MaxEqCar && !MinEqMax)
		 /* Reduce/negate selection extent */
		 newMaxSel = ped->ichMinSel;
	     break;
	 }

      changeSelection = TRUE; 
      break;

    case VK_END:
      switch (scState)
	{
	   case NONEDOWN:
	     /* Clear selection, move caret to end of line */
	     newMaxSel = newMinSel = ped->ichCaret = 
             ped->chLines[ped->iCaretLine]+MLLineLength(ped, ped->iCaretLine);
	     break;

	   case CTRLDOWN:
	     /* Clear selection, move caret to end of text */
	     newMaxSel = newMinSel = ped->ichCaret = ped->cch;
	     break;

	   case SHFTDOWN:
	     /* Extend selection, move caret to end of line */
	     ped->ichCaret = ped->chLines[ped->iCaretLine]+
	 			    MLLineLength(ped, ped->iCaretLine);
	     if (MinEqCar && !MinEqMax)
	       {
		 /* Reduce selection extent */
		 newMinSel = ped->ichCaret;
		 newMaxSel = ped->ichMaxSel;
	       }
	     else
		 /* Extend selection extent */
		 newMaxSel = ped->ichCaret;
	     break;

	   case SHCTDOWN:
	     newMaxSel = ped->ichCaret = ped->cch;
	     /* Extend selection, move caret to end of text */
	     if (MinEqCar && !MinEqMax)
		 /* Reduce/negate selection extent */
		 newMinSel = ped->ichMaxSel;
	     /* else Extend selection extent */
	     break;
	 }

      changeSelection = TRUE;
      break;

    case VK_PRIOR:
    case VK_NEXT:

      switch (scState)
	{
	   case NONEDOWN:
           case SHFTDOWN:
	     /* Vertical scroll by one visual screen */
             hdc = ECGetEditDC(ped,TRUE);
             position = MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine);
             ECReleaseEditDC(ped, hdc, TRUE);
             mousePt.x = LOWORD(position);
             mousePt.y = HIWORD(position)+1;

	     SendMessage(ped->hwnd, WM_VSCROLL, 
		     virtKeyCode == VK_PRIOR ? SB_PAGEUP : SB_PAGEDOWN,
		     0L);

             /* Move the cursor there */
	     MLMouseMotionHandler(ped, WM_LBUTTONDOWN, 
			       scState==NONEDOWN ? 0 : MK_SHIFT, mousePt);
  	     MLMouseMotionHandler(ped, WM_LBUTTONUP, 
			       scState==NONEDOWN ? 0 : MK_SHIFT, mousePt);
	     break;

	   case CTRLDOWN:
	     /* Horizontal scroll by one screenful minus one char */
	     iScrollAmt = ((ped->rcFmt.right - ped->rcFmt.left)
						/ped->aveCharWidth) - 1;
	     if(virtKeyCode == VK_PRIOR)
		iScrollAmt *= -1;  /* For previous page */

	     SendMessage(ped->hwnd, WM_HSCROLL, 
                         EM_LINESCROLL, (long)iScrollAmt);

	     break;
	}
	break;

    case VK_DELETE:
      if (ped->fReadOnly)
          break;

      switch (scState)
	{
	   case NONEDOWN:
	     /*	Clear selection.  If no selection, delete (clear) character
	      * right 
	      */
	     if ((ped->ichMaxSel<ped->cch) && 
                 (ped->ichMinSel==ped->ichMaxSel))
	       {
		 /* Move cursor forwards and send a backspace message... */
		 ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
		 ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
		 SendMessage(ped->hwnd, WM_CHAR, (WORD) BACKSPACE, 0L);
	       }
	     if (ped->ichMinSel != ped->ichMaxSel)
		 SendMessage(ped->hwnd, WM_CHAR, (WORD) BACKSPACE, 0L);
	     break;

	   case SHFTDOWN:
	     /*	CUT selection ie. remove and copy to clipboard, or if no
	      * selection, delete (clear) character left.  
	      */

	     if (SendMessage(ped->hwnd, WM_COPY, (WORD)0,0L) ||
		 (ped->ichMinSel == ped->ichMaxSel))
		 /* If copy successful, delete the copied text by sending a
		  * backspace message which will redraw the text and take care
		  * of notifying the parent of changes.  Or if there is no
		  * selection, just delete char left.  
		  */
		 SendMessage(ped->hwnd, WM_CHAR, (WORD) BACKSPACE, 0L);
	     break;

	   case CTRLDOWN:
 	     /*	Clear selection, or delete to end of line if no selection 
	      */
	     if ((ped->ichMaxSel<ped->cch) && 
                 (ped->ichMinSel==ped->ichMaxSel))
	       {
  	         ped->ichMaxSel = ped->ichCaret = 
                              ped->chLines[ped->iCaretLine]+
                              MLLineLength(ped, ped->iCaretLine);
               }
	     if (ped->ichMinSel != ped->ichMaxSel)
		 SendMessage(ped->hwnd, WM_CHAR, (WORD) BACKSPACE, 0L);
	     break;
	}
 
      /*
       * No need to update text or selection since BACKSPACE message does it
       * for us.
       */
      break;

    case VK_INSERT:
      if (scState == CTRLDOWN || 
          (scState == SHFTDOWN && !ped->fReadOnly))
	  /* if CTRLDOWN Copy current selection to clipboard */
	  /* if SHFTDOWN Paste clipboard */
	  SendMessage(ped->hwnd, scState == CTRLDOWN ? WM_COPY : WM_PASTE, 
		      (WORD)NULL, (LONG)NULL);
      break;

  }

  if (changeSelection)
    {
      hdc = ECGetEditDC(ped,FALSE);	 
      MLChangeSelection(ped,hdc,newMinSel,newMaxSel);
      /* Set the caret's line */
      ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);
      
      if (virtKeyCode == VK_END && ped->ichCaret < ped->cch && ped->fWrap &&
          ped->iCaretLine > 0)
        {
          /* Handle moving to the end of a word wrapped line. This keeps the
	   * cursor from falling to the start of the next line if we have word
	   * wrapped and there is no CRLF. 
	   */
          if (*((PSTR)LMHtoP(ped->hText)+ped->chLines[ped->iCaretLine]-2) != 
              0x0D)
              ped->iCaretLine--;
        }
      /* Since drawtext sets the caret position */
      MLSetCaretPosition(ped,hdc);
      ECReleaseEditDC(ped,hdc,FALSE);

      /* Make sure we can see the cursor */
      MLEnsureCaretVisible(ped);
    }

}


ICH PASCAL NEAR MLPasteText(register PED ped)
/* effects: Pastes a line of text from the clipboard into the edit control
 * starting at ped->ichCaret.  Updates ichMaxSel and ichMinSel to point to the
 * end of the inserted text.  Notifies the parent if space cannot be
 * allocated. Returns how many characters were inserted.  
 */
{
  HANDLE	   hData;
  LPSTR		   lpchClip;
  LPSTR		   lpchClip2;
  register ICH	   cchAdded=0;		/* No added data initially */
  DWORD            clipboardDataSize;
  HCURSOR          hCursorOld;

  if (!ped->fAutoVScroll)
      /* Empty the undo buffer if this edit control limits the amount of text
       * the user can add to the window rect. This is so that we can undo this
       * operation if doing in causes us to exceed the window boundaries. 
       */
      ECEmptyUndo(ped);

  /* See if any text should be deleted */
  MLDeleteText(ped);

  hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

  if (!OpenClipboard(ped->hwnd))
      goto PasteExitNoCloseClip;


  if (!(hData = GetClipboardData(CF_TEXT)))
    {
      goto PasteExit;
    }

  if (GlobalFlags(hData) & GMEM_DISCARDED)
    {
      goto PasteExit;
    }

  lpchClip2 = lpchClip = (LPSTR) GlobalLock(hData);

  /* Assumes lstrlen returns at most 64K 
   */
  cchAdded = umin((WORD)lstrlen(lpchClip),64000L);

  /* Insert the text (MLInsertText checks line length) */
  cchAdded = MLInsertText(ped, lpchClip, cchAdded, FALSE);

  GlobalUnlock(hData);


PasteExit:
  CloseClipboard();

PasteExitNoCloseClip:
  if (hCursorOld)
      SetCursor(hCursorOld);

  return(cchAdded);
}


void NEAR PASCAL MLMouseMotionHandler(register PED   ped,
				      WORD	     message,
				      WORD	     virtKeyDown,
				      POINT	     mousePt)
{
  LONG selection;
  BOOL updateText = FALSE;
  BOOL changeSelection = FALSE;

  HDC  hdc = ECGetEditDC(ped,TRUE);
  
  ICH newMaxSel = ped->ichMaxSel;
  ICH newMinSel = ped->ichMinSel;
  ICH ichStart	= ped->screenStart;

  ICH mouseCch; 
  ICH mouseLine;
  int i,j;

  selection = MLMouseToIch(ped, hdc, mousePt);
  mouseCch = LOWORD(selection);
  mouseLine = HIWORD(selection);

  /* Save for timer */
  ped->ptPrevMouse = mousePt;
  ped->prevKeys	   = virtKeyDown;

  switch (message)
  {
    case WM_LBUTTONDBLCLK:
      /*
       * if shift key is down, extend selection to word we double clicked on
       * else clear current selection and select word.
       */
#ifdef FE_SB
      /*
       * if character on the caret is DBCS, word selection is only one
       * DBCS character on the caret (or right side from the caret).
       */
      {
	PSTR pCaretChr = LocalLock(ped->hText)+ped->ichCaret;
        selection = ECWord(ped,ped->ichCaret,
                      ECIsDBCSLeadByte(ped,*pCaretChr) ? FALSE : TRUE);
        LocalUnlock(ped->hText);
      }
#else
      selection = ECWord(ped,ped->ichCaret,TRUE);
#endif
      newMinSel = LOWORD(selection);
      newMaxSel = ped->ichCaret = HIWORD(selection);

      ped->iCaretLine = MLIchToLineHandler(ped, ped->ichCaret);

      changeSelection = TRUE;
      /*
       * Set mouse down to false so that the caret isn't reposition on the
       * mouseup message or on a accidental move...
       */
      ped->fMouseDown = FALSE;
      break;

    case WM_MOUSEMOVE:
      if (ped->fMouseDown)
	{
	  /* Set the system timer to automatically scroll when mouse is
	   * outside of the client rectangle.  Speed of scroll depends on
	   * distance from window.  
	   */
	  i = mousePt.y < 0 ? -mousePt.y : mousePt.y - ped->rcFmt.bottom;
	  j = 400 - ((WORD)i << 4);
	  if (j < 100)
	      j = 100;
	  SetTimer(ped->hwnd, 1, j, (FARPROC)NULL);
	
	  changeSelection = TRUE;
	  /* Extend selection, move caret right */
	  if ((ped->ichMinSel == ped->ichCaret) && 
	      (ped->ichMinSel != ped->ichMaxSel))
	    {
	      /* Reduce selection extent */
	      newMinSel = ped->ichCaret = mouseCch;
	      newMaxSel = ped->ichMaxSel;
	    }
	  else
	    {
	      /* Extend selection extent */
	      newMaxSel = ped->ichCaret=mouseCch;
	    }
	  ped->iCaretLine = mouseLine;
	}
      break;

    case WM_LBUTTONDOWN:
/*	if (ped->fFocus)
	{*/
	  /*
	   * Only handle this if we have the focus.
	   */
	  ped->fMouseDown = TRUE;
	  SetCapture(ped->hwnd);
	  changeSelection = TRUE;
	  if (!(virtKeyDown & MK_SHIFT))
	    {
	      /*
	       * If shift key isn't down, move caret to mouse point and clear
	       * old selection
	       */
	      newMinSel = newMaxSel = ped->ichCaret = mouseCch;
	      ped->iCaretLine = mouseLine;
	    }
	  else
	    {
	      /*
	       * Shiftkey is down so we want to maintain the current selection
	       * (if any) and just extend or reduce it
	       */
	      if (ped->ichMinSel == ped->ichCaret)
		  newMinSel = ped->ichCaret = mouseCch;
	      else
		  newMaxSel = ped->ichCaret = mouseCch;
	      ped->iCaretLine = mouseLine;
	    }

	  /*
	   * Set the timer so that we can scroll automatically when the mouse
	   * is moved outside the window rectangle.
	   */
	  ped->ptPrevMouse=mousePt;
	  ped->prevKeys = virtKeyDown;
	  SetTimer(ped->hwnd, 1, 400, (FARPROC)NULL);
/*	  }*/
      break;

    case WM_LBUTTONUP:
      if (ped->fMouseDown)
	{
	  /* Kill the timer so that we don't do auto mouse moves anymore */
	  KillTimer(ped->hwnd, 1);
	  ReleaseCapture();
	  MLSetCaretPosition(ped,hdc);
	  ped->fMouseDown = FALSE;
	}
      break;
  }


  if (changeSelection)
    {
      MLChangeSelection(ped, hdc, newMinSel, newMaxSel);
      MLEnsureCaretVisible(ped);
    }

  ECReleaseEditDC(ped,hdc,TRUE);

  if (!ped->fFocus && (message == WM_LBUTTONDOWN))
      /* If we don't have the focus yet, get it */
      SetFocus(ped->hwnd);

}



int NEAR PASCAL MLPixelFromCount(register PED ped,
                                 int	      dCharLine,
                                 WORD	      message)
/* effects: Given a character or line count (depending on message == hscroll
 * or vscroll), calculate the number of pixels we must scroll to get there.
 * Updates the start of screen or xoffset to reflect the new positions.  
 */
{
  /* This can be an int since we can have 32K max lines/pixels 
   */
  int oldLineChar; 


  if (message != WM_HSCROLL)
    {
      /* We want to scroll screen by dCharLine lines */
      oldLineChar = ped->screenStart;

      /* Find the new starting line for the ped */
      ped->screenStart = max(ped->screenStart+dCharLine,0);
      ped->screenStart = min(ped->screenStart,ped->cLines-1);

      dCharLine = oldLineChar - ped->screenStart;

      /* We will scroll at most a screen full of text */
      if (dCharLine < 0)
	  dCharLine = -min(-dCharLine, ped->ichLinesOnScreen);
      else
	  dCharLine = min(dCharLine, ped->ichLinesOnScreen);

      return(dCharLine*ped->lineHeight);
    }

  /* No horizontal scrolling allowed if funny format */
  if (ped->format != ES_LEFT)
      return(0);

  /* Convert delta characters into delta pixels */
  dCharLine = dCharLine*ped->aveCharWidth;

  oldLineChar = ped->xOffset;

  /* Find new horizontal starting point */
  ped->xOffset = max(ped->xOffset+dCharLine,0);
  ped->xOffset = min(ped->xOffset,ped->maxPixelWidth);

  dCharLine = oldLineChar - ped->xOffset;

  /* We will scroll at most a screen full of text */
  if (dCharLine < 0)
      dCharLine = -min(-dCharLine, ped->rcFmt.right+1-ped->rcFmt.left);
  else
      dCharLine =  min(dCharLine, ped->rcFmt.right+1-ped->rcFmt.left);

  return(dCharLine);
}


int NEAR PASCAL MLPixelFromThumbPos(register PED ped,
                                    int	     pos,
                                    BOOL     fVertical)
/* effects: Given a thumb position from 0 to 100, return the number of pixels
 * we must scroll to get there.  
 */
{
  int dxy;
  int iLineOld;
  ICH iCharOld;

  if (fVertical)
    {
      iLineOld = ped->screenStart;
      ped->screenStart = (int)MultDiv(ped->cLines-1, pos, 100);
      ped->screenStart = min(ped->screenStart,ped->cLines-1);
      dxy = (iLineOld - ped->screenStart)*ped->lineHeight;
    }
  else
    {
      /* Only allow horizontal scrolling with left justified text */
      if (ped->format == ES_LEFT)
	{
	  iCharOld = ped->xOffset;
	  ped->xOffset = MultDiv(ped->maxPixelWidth-ped->aveCharWidth, pos, 100);
	  dxy = iCharOld - ped->xOffset;
	}
      else
	  dxy = 0;
    }

  return(dxy);
}


int FAR PASCAL MLThumbPosFromPed(register PED ped,
				  BOOL	   fVertical)
/*
 * effects: Given the current state of the edit control, return its vertical
 * thumb position if fVertical else returns its horizontal thumb position.
 * The thumb position ranges from 0 to 100.
 */
{
  WORD d1;
  WORD d2;

  if (fVertical)
    {
      if (ped->cLines < 2)
	  return(0);
      d1 = (WORD)(ped->screenStart);
      d2 = (WORD)(ped->cLines-1);
    }
  else
   {
      if (ped->maxPixelWidth < (ped->aveCharWidth*2))
	  return(0);
      d1 = (WORD)(ped->xOffset);
      d2 = (WORD)(ped->maxPixelWidth);
   }

  /* Do the multiply/division and avoid overflows and divide by zero errors */
  return(MultDiv(d1, 100, d2));
}


LONG NEAR PASCAL MLScrollHandler(register PED ped,
				 WORD	      message,
				 int	      cmd,
				 int	      iAmt)
{
  RECT	rc;
  RECT	rcUpdate;
  int	dx;
  int	dy;
  int	dcharline;
  BOOL	fVertical;
  HDC	hdc;

  UpdateWindow(ped->hwnd);

  /* Are we scrolling vertically or horizontally? */
  fVertical = (message != WM_HSCROLL);
  dx = dy = dcharline = 0;

  switch (cmd)
    {
       case SB_LINEDOWN:
	 dcharline = 1;
	 break;

       case SB_LINEUP:
	 dcharline = -1;
	 break;

       case SB_PAGEDOWN:
	 dcharline = ped->ichLinesOnScreen-1;
	 break;

       case SB_PAGEUP:
	 dcharline = -(ped->ichLinesOnScreen-1);
	 break;

       case SB_THUMBTRACK:
       case SB_THUMBPOSITION:
	 dy = MLPixelFromThumbPos(ped, iAmt, fVertical);
	 dcharline = -dy / (message == WM_VSCROLL ? ped->lineHeight : 
                                                    ped->aveCharWidth);
	 if (!fVertical)
	   {
	     dx = dy;
	     dy = 0;
	   }
	 break;

       case EM_LINESCROLL:
	 dcharline = iAmt;
	 break;

       case EM_GETTHUMB:
	 return(MLThumbPosFromPed(ped,fVertical));
	 break;

       default:
	 return(0L);
	 break;
    }

  GetClientRect(ped->hwnd, (LPRECT)&rc);
  IntersectRect((LPRECT)&rc, (LPRECT)&rc, (LPRECT)&ped->rcFmt);
  rc.bottom++;

  if (cmd != SB_THUMBPOSITION && cmd != SB_THUMBTRACK)
    {
      if (message == WM_VSCROLL)
	{
	  dx = 0;
	  dy = MLPixelFromCount(ped, dcharline, message);
	}
      else if (message == WM_HSCROLL)
	{
	  dx = MLPixelFromCount(ped, dcharline, message);
	  dy = 0;
	}
    }

  SetScrollPos(ped->hwnd, fVertical ? SB_VERT : SB_HORZ,
	       (int)MLThumbPosFromPed(ped,fVertical), TRUE);

  if (cmd != SB_THUMBTRACK)
      /* We don't want to notify the parent of thumbtracking since they might
       * try to set the thumb position to something bogus.  For example
       * NOTEPAD is such a #@@!@#@ an app since they don't use editcontrol
       * scroll bars and depend on these EN_*SCROLL messages to update their
       * fake scroll bars.  
       */
      ECNotifyParent(ped,fVertical ? EN_VSCROLL : EN_HSCROLL);

  if (!ped->fNoRedraw)
    {
      hdc = ECGetEditDC(ped,FALSE);
      ScrollDC(hdc,dx,dy, (LPRECT)&rc, (LPRECT)&rc, NULL, (LPRECT)&rcUpdate);
      MLSetCaretPosition(ped,hdc);
      ECReleaseEditDC(ped,hdc,FALSE);

      if (ped->ichLinesOnScreen+ped->screenStart >= ped->cLines)
        {
          InvalidateRect(ped->hwnd, (LPRECT)&rcUpdate, TRUE);
        }
      else
        {
          InvalidateRect(ped->hwnd, (LPRECT)&rcUpdate, FALSE);
        }
      UpdateWindow(ped->hwnd);
    }

  return(MAKELONG(dcharline, 1));
}


void NEAR PASCAL MLSetFocusHandler(register PED  ped)
/* effects: Gives the edit control the focus and notifies the parent
 * EN_SETFOCUS.  
 */
{
  HDC  hdc;

  if (!ped->fFocus)
    {
      ped->fFocus = 1;	/* Set focus */

      hdc = ECGetEditDC(ped,TRUE);


      /* Draw the caret */
      CreateCaret(ped->hwnd, (HBITMAP)NULL, 2, ped->lineHeight);
      ShowCaret(ped->hwnd);
      MLSetCaretPosition(ped, hdc);

      /* Show the current selection.  Only if the selection was hidden when we
       * lost the focus, must we invert (show) it.  
       */
      if (!ped->fNoHideSel && ped->ichMinSel!=ped->ichMaxSel)
	  MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel);

      ECReleaseEditDC(ped,hdc,TRUE);
    }
#if 0
  MLEnsureCaretVisible(ped);
#endif
  /* Notify parent we have the focus */
  ECNotifyParent(ped, EN_SETFOCUS);
}


void NEAR PASCAL MLKillFocusHandler(register PED ped)
/* effects: The edit control loses the focus and notifies the parent via
 * EN_KILLFOCUS.  
 */
{
  HDC hdc;

  if (ped->fFocus)
    {
      ped->fFocus = 0;	/* Clear focus */

      /* Do this only if we still have the focus.  But we always notify the
       * parent that we lost the focus whether or not we originally had the
       * focus.  
       */
      /* Hide the current selection if needed */
      if (!ped->fNoHideSel && ped->ichMinSel!=ped->ichMaxSel)
	{
	  hdc = ECGetEditDC(ped,FALSE);
	  MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel);
	  ECReleaseEditDC(ped,hdc,FALSE);
	}

      /* Destroy the caret */
      HideCaret(ped->hwnd);
      DestroyCaret();
    }

  /* Notify parent that we lost the focus. */
  ECNotifyParent(ped, EN_KILLFOCUS);
}



BOOL FAR PASCAL MLEnsureCaretVisible(ped)
register PED ped;
/*
 * effects: Scrolls the caret into the visible region.	Returns TRUE if
 * scrolling was done else returns FALSE.
 */
{
  int  cLinesToScroll;
  int  iLineMax;
  int  xposition;
  BOOL prevLine;
  register HDC	hdc;
  BOOL fScrolled = FALSE;


  if (IsWindowVisible(ped->hwnd))
    {
      if (ped->fAutoVScroll)
        {
          iLineMax = ped->screenStart + ped->ichLinesOnScreen-1;

          if (fScrolled = ped->iCaretLine > iLineMax)
            {
    	      MLScrollHandler(ped, WM_VSCROLL, EM_LINESCROLL, 
			      ped->iCaretLine-iLineMax);
            }
          else
            {
              if (fScrolled = ped->iCaretLine < ped->screenStart)
	          MLScrollHandler(ped, WM_VSCROLL, EM_LINESCROLL, 
			           ped->iCaretLine-ped->screenStart);
            }
       }
	

      if (ped->fAutoHScroll && 
	  ped->maxPixelWidth > ped->rcFmt.right-ped->rcFmt.left)
	{
	  /* Get the current position of the caret in pixels */
	  if (ped->cLines-1 != ped->iCaretLine &&
	      ped->ichCaret == ped->chLines[ped->iCaretLine+1])
	      prevLine=TRUE;
	  else
	      prevLine=FALSE;

	  hdc = ECGetEditDC(ped,TRUE);
	  xposition = LOWORD(MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine));
	  ECReleaseEditDC(ped,hdc,TRUE);

	  /* Remember, MLIchToXYPos returns coordinates with respect to the
	   * top left pixel displayed on the screen.  Thus, if xPosition < 0,
	   * it means xPosition is less than current ped->xOffset.  
	   */
	  if (xposition < 0)
	      /* Scroll to the left */
	      MLScrollHandler(ped, WM_HSCROLL, EM_LINESCROLL,
			      (xposition-(ped->rcFmt.right-ped->rcFmt.left)/3)
				 /ped->aveCharWidth);
	  else if (xposition > ped->rcFmt.right)
	      /* Scroll to the right */
	      MLScrollHandler(ped, WM_HSCROLL, EM_LINESCROLL,
                              (xposition-ped->rcFmt.right+
                              (ped->rcFmt.right-ped->rcFmt.left)/3)/
                              ped->aveCharWidth);
	}
    }
  xposition = (int)MLThumbPosFromPed(ped,TRUE);
  if (xposition != GetScrollPos(ped->hwnd, SB_VERT))
      SetScrollPos(ped->hwnd, SB_VERT, xposition, TRUE);

  xposition = (int)MLThumbPosFromPed(ped,FALSE);
  if (xposition != GetScrollPos(ped->hwnd, SB_HORZ))
      SetScrollPos(ped->hwnd, SB_HORZ, xposition, TRUE);

  return(fScrolled);
}


void FAR PASCAL MLSetRectHandler(ped, lprect)
register PED ped;
LPRECT	     lprect;
/*
 * effects: Sets the edit control's format rect to be the rect specified if
 * reasonable. Rebuilds the lines if needed.
 */
{
  RECT rc;

  CopyRect((LPRECT)&rc, lprect);

  if (!(rc.right-rc.left) || !(rc.bottom-rc.top))
    {
      if (ped->rcFmt.right - ped->rcFmt.left)
        {
	  ped->fCaretHidden = 1;	// then, hide it.
	  SetCaretPos(-20000, -20000);
	  /* If rect is being set to zero width or height, and our formatting
	     rectangle is already defined, just return. */
	  return;
	}

      SetRect((LPRECT)&rc, 0, 0, ped->aveCharWidth*10, ped->lineHeight);
    }

  if (ped->fBorder)
      /* Shrink client area to make room for the border */
      InflateRect((LPRECT)&rc, -(ped->cxSysCharWidth/2),
		  -(ped->cySysCharHeight/4));

  /*
   * If resulting rectangle is too small to do anything with, don't change it
   */
  if ((rc.right-rc.left < ped->aveCharWidth) ||
      ((rc.bottom - rc.top)/ped->lineHeight == 0))
    {
      // If the resulting rectangle is too small to display the caret, then
      // do not display the caret.
      ped->fCaretHidden = 1;
      SetCaretPos(-20000, -20000);
      /* If rect is too narrow or too short, do nothing */
      return;
    }
  else
      ped->fCaretHidden = 0;

  /* Calc number of lines we can display on the screen */
  ped->ichLinesOnScreen = (rc.bottom - rc.top)/ped->lineHeight;

  CopyRect((LPRECT)&ped->rcFmt, (LPRECT)&rc);

  /* Get an integral number of lines on the screen */
  ped->rcFmt.bottom = rc.top+ped->ichLinesOnScreen * ped->lineHeight;

  /* Rebuild the chLines if we are word wrapping only */
  if (ped->fWrap)
    {
      MLBuildchLines(ped, 0, 0, FALSE);
      // Update the ped->iCaretLine field properly based on ped->ichCaret
      MLUpdateiCaretLine(ped);
    }
}





/*******************/
/* MLEditWndProc() */
/*******************/
LONG FAR PASCAL MLEditWndProc(hwnd, ped, message, wParam, lParam)
HWND	      hwnd;
register PED  ped;
WORD	      message;
register WORD wParam;
LONG	      lParam;
/* effects: Class procedure for all multi line edit controls.
	Dispatches all messages to the appropriate handlers which are named 
	as follows:
	SL (single line) prefixes all single line edit control procedures while
	EC (edit control) prefixes all common handlers.

	The MLEditWndProc only handles messages specific to multi line edit
	controls.
 */

{
  switch (message)
  {
    case WM_CHAR:
      /* wParam - the value of the key
	 lParam - modifiers, repeat count etc (not used) */
      MLCharHandler(ped, wParam, 0);
      break;

    case WM_CLEAR:
      /* wParam - not used
	 lParam - not used */
      if (ped->ichMinSel != ped->ichMaxSel && !ped->fReadOnly)
	  SendMessage(ped->hwnd, WM_CHAR, (WORD) BACKSPACE, 0L);
      break;

    case WM_CUT:
      /* wParam - not used
	 lParam - not used */
      if (ped->ichMinSel != ped->ichMaxSel && !ped->fReadOnly)
	  MLKeyDownHandler(ped, VK_DELETE, SHFTDOWN);
      break;


    case WM_ERASEBKGND:
      FillWindow(ped->hwndParent, hwnd, (HDC)wParam, CTLCOLOR_EDIT);
      return((LONG)TRUE);

    case WM_GETDLGCODE:
      /* wParam - not used
	 lParam - not used */
	 /* Should also return DLGC_WANTALLKEYS for multiline edit controls */
      ped->fInDialogBox=TRUE; /* Mark the ML edit ctrl as in a dialog box */
      return(DLGC_WANTCHARS | DLGC_HASSETSEL | 
	     DLGC_WANTARROWS | DLGC_WANTALLKEYS);
      break;

    case WM_HSCROLL:
    case WM_VSCROLL:
      return(MLScrollHandler(ped, message, wParam, (int)lParam));
      break;

    case WM_KEYDOWN:
      /* wParam - virt keycode of the given key
	 lParam - modifiers such as repeat count etc. (not used) */
      MLKeyDownHandler(ped, wParam, 0);
      break;

    case WM_KILLFOCUS:
      /* wParam - handle of the window that receives the input focus
	 lParam - not used */
      MLKillFocusHandler(ped);
      break;

    case WM_SYSTIMER:
      /* This allows us to automatically scroll if the user holds the mouse
       * outside the edit control window.  We simulate mouse moves at timer
       * intervals set in MouseMotionHandler.  
       */
      if (ped->fMouseDown)
          MLMouseMotionHandler(ped, WM_MOUSEMOVE,
                               ped->prevKeys,ped->ptPrevMouse);
      break;

    case WM_MOUSEMOVE:
      if (!ped->fMouseDown)
          break;
      /* else fall through */

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
      /* wParam - contains a value that indicates which virtual keys are down
	 lParam - contains x and y coords of the mouse cursor */
      MLMouseMotionHandler(ped, message, wParam, MAKEPOINT(lParam));
      break;

    case WM_CREATE:
      /* wParam - handle to window being created
	 lParam - points to a CREATESTRUCT that contains copies of parameters 
		  passed to the CreateWindow function. */
      return(MLCreateHandler(hwnd, ped, (LPCREATESTRUCT) lParam));
      break;

    case WM_PAINT:
      /* wParam - officially not used (but some apps pass in a DC here)
	 lParam - not used */
      MLPaintHandler(ped, wParam);
      break;

    case WM_PASTE:
      /* wParam - not used
	 lParam - not used */
      if (!ped->fReadOnly)
          MLPasteText(ped);
      break;

    case WM_SETFOCUS:
      /* wParam - handle of window that loses the input focus (may be NULL)
	 lParam - not used */
      MLSetFocusHandler(ped);
      break;

    case WM_SETTEXT:
      /* wParam - not used
	 lParam - points to a null-terminated string that is used to set the
		  window text. */
      return(MLSetTextHandler(ped, (LPSTR)lParam));
      break;

    case WM_SIZE:
      /* wParam - defines the type of resizing fullscreen, sizeiconic, 
		  sizenormal etc.
	 lParam - new width in LOWORD, new height in HIGHWORD of client area */
      MLSizeHandler(ped);
      break;

    case EM_FMTLINES:
      /* wParam - indicates disposition of end-of-line chars.  If non
       * zero, the chars CR CR LF are placed at the end of a word
       * wrapped line.  If wParam is zero, the end of line chars are
       * removed.  This is only done when the user gets a handle (via
       * EM_GETHANDLE) to the text.  lParam - not used. 
       */
      if (wParam)
	  MLInsertCrCrLf(ped);
      else
	  MLStripCrCrLf(ped);
      MLBuildchLines(ped, 0, 0, FALSE);
      return((LONG)(ped->fFmtLines = wParam));
      break;

    case EM_GETHANDLE:
      /* wParam - not used 
	 lParam - not used */
      /* effects: Returns a handle to the edit control's text. */
      /*
       * Null terminate the string.  Note that we are guaranteed to have the
       * memory for the NULL since ECInsertText allocates an extra
       * byte for the NULL terminator.  
       */
      /**(LocalLock(ped->hText)+ped->cch) = 0;*/
      /*LocalUnlock(ped->hText);*/
      *(LMHtoP(ped->hText)+ped->cch) = 0;
      return((LONG)ped->hText);
      break;

    case EM_GETLINE:
      /* wParam - line number to copy (0 is first line)
	 lParam - buffer to copy text to. First word is max # of bytes to 
		  copy */
      return(MLGetLineHandler(ped, wParam, 
			      *(WORD FAR *)lParam, (LPSTR)lParam));
      break;

    case EM_LINEFROMCHAR:
      /* wParam - Contains the index value for the desired char in the text
	 of the edit control.  These are 0 based.
	 lParam - not used */
      return((LONG)MLIchToLineHandler(ped, wParam));
      break;

    case EM_LINEINDEX:
      /* wParam - specifies the desired line number where the number of the
	 first line is 0. If linenumber = 0, the line with the caret is used.
	 lParam - not used.
	 This function returns the number of character positions that occur
	 preceeding the first char in a given line. */
      return((LONG)MLLineIndexHandler(ped, wParam));
      break;

    case EM_LINELENGTH:
      /* wParam - specifies the character index of a character in the 
	 specified line, where the first line is 0.  If -1, the length
	 of the current line (with the caret) is returned not including the
	 length of any selected text.
	 lParam - not used */
      return((LONG)MLLineLengthHandler(ped, wParam));
      break;

    case EM_LINESCROLL:
      /* wParam - not used
	 lParam - Contains the number of lines and char positions to scroll */
      MLScrollHandler(ped, WM_VSCROLL, EM_LINESCROLL, LOWORD(lParam));
      MLScrollHandler(ped, WM_HSCROLL, EM_LINESCROLL, HIWORD(lParam));
      break;

    case EM_REPLACESEL:
      /* wParam - not used
	 lParam - Points to a null terminated replacement text. */
      SwapHandle(&lParam);
      ECEmptyUndo(ped);
      MLDeleteText(ped);
      ECEmptyUndo(ped);
      SwapHandle(&lParam);
      MLInsertText(ped, (LPSTR)lParam, lstrlen((LPSTR)lParam), FALSE);
      ECEmptyUndo(ped);
      break;

    case EM_SCROLL:
      /* Scroll the window vertically */
      /* wParam - contains the command type 
	 lParam - not used. */
      return(MLScrollHandler(ped, WM_VSCROLL, wParam, (int)lParam));
      break;

    case EM_SETHANDLE:
      /* wParam - contains a handle to the text buffer 
	 lParam - not used */
      MLSetHandleHandler(ped, (HANDLE)wParam);
      break;

    case EM_SETRECT:
      /* wParam - not used
	 lParam - Points to a RECT which specifies the new dimensions of the
		  rectangle. */
      MLSetRectHandler(ped, (LPRECT)lParam);
      /* Do a repaint of the whole client area since the app may have shrunk
       * the rectangle for the text and we want to be able to erase the old
       * text.  
       */
      InvalidateRect(hwnd, (LPRECT)NULL, TRUE);
      UpdateWindow(hwnd);
      break;

    case EM_SETRECTNP:
      /* wParam - not used
	 lParam - Points to a RECT which specifies the new dimensions of the
		  rectangle.
       */
      /* We don't do a repaint here. */
      MLSetRectHandler(ped, (LPRECT)lParam);
      break;

    case EM_SETSEL:
      /* wParam - not used
	 lParam - starting pos in lowword ending pos in high word */
      MLSetSelectionHandler(ped, LOWORD(lParam), HIWORD(lParam));
      break;

    case WM_UNDO:
    case EM_UNDO:
      return(MLUndoHandler(ped));
      break;

    case EM_SETTABSTOPS:
      /* This sets the tab stop positions for multiline edit controls.
       * wParam - Number of tab stops
       * lParam - Far ptr to a WORD array containing the Tab stop positions
       */
       return(MLSetTabStops(ped, (int)wParam, (LPINT)lParam));
      break;

    default:
      return(DefWindowProc(hwnd,message,wParam,lParam));
      break;
  }

  return(1L);
} /* MLEditWndProc */



void NEAR PASCAL MLDrawText(register PED ped,
			    HDC	     hdc,
			    ICH	     ichStart,
			    ICH      ichEnd)
/* effects: draws the characters between ichstart and ichend.  
 */
{
  DWORD	 textColorSave;
  DWORD	 bkColorSave;
  LONG	 xyPos;
  LONG   xyNonLeftJustifiedStart;
  HBRUSH hBrush;  
  ICH	 ich;
  PSTR	 pText;
  int	 line;
  ICH	 length;
  ICH    length2;
  int    xOffset;
  DWORD  ext;
  RECT   rc;
  BOOL   fPartialLine = FALSE;
  BOOL   fSelected    = FALSE;
  BOOL   fLeftJustified = TRUE;
#ifdef WOW
  HWND	 hwndSend;
#endif

  if (ped->fNoRedraw || !ped->ichLinesOnScreen)
      /* Just return if nothing to draw */
      return;

  /* Set initial state of dc */
#ifndef WOW
  hBrush = GetControlBrush(ped->hwnd, hdc, CTLCOLOR_EDIT);
#else
  if (!(hwndSend = GetParent(ped->hwnd)))
      hwndSend = ped->hwnd;
  SendMessage(hwndSend, WM_CTLCOLOR, (WORD)hdc, MAKELONG(ped->hwnd, CTLCOLOR_EDIT));
#endif

  if ((WORD)ichStart < (WORD)ped->chLines[ped->screenStart])
    {
      ichStart = ped->chLines[ped->screenStart];
      if (ichStart > ichEnd)
	  return;
    }

  line = min(ped->screenStart+ped->ichLinesOnScreen,ped->cLines-1);
  ichEnd = umin(ichEnd, ped->chLines[line]+MLLineLength(ped, line));

  line = MLIchToLineHandler(ped, ichStart);
  if (ped->format != ES_LEFT)
    {
      ichStart = ped->chLines[line];
      fLeftJustified = FALSE;
    }

  pText = LocalLock(ped->hText);

  HideCaret(ped->hwnd);
  
  while (ichStart <= ichEnd)
   {
StillWithSameLine:
     length2 = MLLineLength(ped, line);
     if (length2 < (ichStart - ped->chLines[line]))
       {
         goto NextLine;
       }

     length = length2 - (ichStart - ped->chLines[line]);

     xyPos  = MLIchToXYPos(ped, hdc, ichStart, FALSE);

     if (!fLeftJustified && ichStart == ped->chLines[line])
         xyNonLeftJustifiedStart = xyPos;

     /* Find out how many pixels we indent the line for funny formats */
     if (ped->format != ES_LEFT)
         xOffset = MLCalcXOffset(ped, hdc, line);
     else
         xOffset = -ped->xOffset;

     if (!(ped->ichMinSel == ped->ichMaxSel ||
           ichStart >= ped->ichMaxSel ||
           ichEnd   <  ped->ichMinSel ||
           (!ped->fNoHideSel && !ped->fFocus)))
       {
         if (ichStart < ped->ichMinSel)
           {
             fSelected = FALSE;
             length2 = umin(ichStart+length, ped->ichMinSel)-ichStart;
           }
         else
           {
             fSelected = TRUE;
             length2 = umin(ichStart+length, ped->ichMaxSel)-ichStart;
             /* Select in the highlight colors */
             bkColorSave = SetBkColor(hdc, ped->rgbHiliteBk);
             textColorSave = SetTextColor(hdc, ped->rgbHiliteText);
           }
         fPartialLine = (length != length2);
         length = length2;
       }

     ext = ECTabTheTextOut(hdc, LOWORD(xyPos), HIWORD(xyPos), 
		    (LPSTR)(pText+ichStart), length,
                    ped,/*iLeft+xOffset*/ped->rcFmt.left+xOffset, TRUE);

     if (fSelected)
       {
         fSelected = FALSE;
         SetBkColor(hdc, bkColorSave);
         SetTextColor(hdc, textColorSave);
       }

     if (fPartialLine)
       {
         fPartialLine = FALSE;
         ichStart += length;
         goto StillWithSameLine;
       }

     /*	Fill to end of line so use a very large width for this rectangle. 
      */
     SetRect((LPRECT)&rc,
	     LOWORD(xyPos)+LOWORD(ext), HIWORD(xyPos),
             32764,
	     HIWORD(xyPos)+ped->lineHeight);
     ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, (LPRECT)&rc, "",0,0L);
     if (!fLeftJustified)
       {
         SetRect((LPRECT)&rc,
                 ped->rcFmt.left,
                 HIWORD(xyNonLeftJustifiedStart),
                 LOWORD(xyNonLeftJustifiedStart),
                 HIWORD(xyNonLeftJustifiedStart)+ped->lineHeight);
         ExtTextOut(hdc, rc.left, rc.top, 
                            ETO_OPAQUE, (LPRECT)&rc, "",0,0L);
       }

NextLine:
     line++;
     if (ped->cLines > line)
       {
         ichStart = ped->chLines[line];
       }
     else
         ichStart = ichEnd+1;
   }

  LocalUnlock(ped->hText);   
  ShowCaret(ped->hwnd);  
  MLSetCaretPosition(ped,hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\edslrare.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  EDSLRARE.C
 *  Win16 edit control code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/****************************************************************************/
/* edslRare.c - SL Edit controls Routines Called rarely are to be  	    */
/*		put in a seperate segment _EDSLRare. This file contains     */
/*		these routines.		          		    	    */
/*                                                                          */
/*                                                                          */
/* Created:  02-08-89  sankar                                               */
/****************************************************************************/

#define  NO_LOCALOBJ_TAGS
#include "user.h"
#include "edit.h"

/****************************************************************************/
/*			Single-Line Support Routines  called Rarely	    */
/****************************************************************************/

void FAR PASCAL SLSetSelectionHandler(ped, ichSelStart, ichSelEnd)
register PED ped;
ICH          ichSelStart;
ICH          ichSelEnd;
/* effects: Sets the PED to have the new selection specified.  
 */
{
  register HDC hdc = ECGetEditDC(ped, FALSE);

  if (ichSelStart == 0xFFFF)
      /* Set no selection if we specify -1 */
      ichSelStart = ichSelEnd = ped->ichCaret;

  /* Bounds ichSelStart, ichSelEnd are checked in SLChangeSelection... */
  SLChangeSelection(ped, hdc, ichSelStart, ichSelEnd);
  /* Put the caret at the end of the selected text */
  ped->ichCaret = ped->ichMaxSel;

  SLSetCaretPosition(ped,hdc);

  /* We may need to scroll the text to bring the caret into view... */
  SLScrollText(ped,hdc);

  ECReleaseEditDC(ped,hdc,FALSE);
}


void FAR PASCAL SLSizeHandler(ped)
register PED  ped;
/* effects: Handles sizing of the edit control window and properly updating
 * the fields that are dependent on the size of the control. ie. text
 * characters visible etc.  
 */
{
  RECT rc;	
  GetClientRect(ped->hwnd, &rc);
  if (!(rc.right-rc.left) || !(rc.bottom-rc.top))
    {
      if (ped->rcFmt.right-ped->rcFmt.left)
          /* Don't do anything if we are becomming zero width or height and
             out formatting rect is already set... */
          return;
      /* Otherwise set some initial values to avoid divide by zero problems
         later... */
      SetRect((LPRECT)&rc,0,0,10,10);
    }

  CopyRect(&ped->rcFmt, &rc);
  if (ped->fBorder)
      /* Shrink client area to make room for the border */
      InflateRect((LPRECT)&ped->rcFmt, 
	          -(min(ped->aveCharWidth,ped->cxSysCharWidth)/2),
                  -(min(ped->lineHeight,ped->cySysCharHeight)/4));

#ifdef BROKEN
  ped->rcFmt.bottom = min(ped->rcFmt.top+
	                           max(ped->lineHeight,ped->cySysCharHeight), 
			  ped->rcFmt.bottom);
#else
  ped->rcFmt.bottom = min(ped->rcFmt.top+
                                   ped->lineHeight,
			  ped->rcFmt.bottom);
#endif
}


BOOL FAR PASCAL SLSetTextHandler(ped, lpstr)
register PED   ped;
LPSTR          lpstr;
/* effects: Copies the null terminated text in lpstr to the ped.  Notifies the
 * parent if there isn't enough memory.  Returns TRUE if successful else
 * FALSE.  
 */
{
  BOOL fInsertSuccessful;
  RECT rcEdit;

  SwapHandle(&lpstr);
  ECEmptyUndo(ped);
  SwapHandle(&lpstr);

  /* Add the text and update the window if text was added.  The parent is
   * notified of no memory in ECSetText.  
   */
  if (fInsertSuccessful = ECSetText(ped, lpstr))
      ped->fDirty = FALSE;

  ECEmptyUndo(ped);
  
  if (!ped->listboxHwnd)
      ECNotifyParent(ped, EN_UPDATE);

#ifndef WOW
  if (FChildVisible(ped->hwnd))
#else
  if (IsWindowVisible(GetParent(ped->hwnd)))
#endif
    {
      /* We will always redraw the text whether or not the insert was
       * successful since we may set to null text.  
       */
      GetClientRect(ped->hwnd, (LPRECT)&rcEdit);
      if (ped->fBorder && 
          rcEdit.right-rcEdit.left && rcEdit.bottom-rcEdit.top)
        {
          /* Don't invalidate the border so that we avoid flicker */
          InflateRect((LPRECT)&rcEdit, -1, -1);
        }
      InvalidateRect(ped->hwnd, (LPRECT)&rcEdit, FALSE);
      UpdateWindow(ped->hwnd);
    }

  if (!ped->listboxHwnd)  
      ECNotifyParent(ped, EN_CHANGE);

  return(fInsertSuccessful);
}


LONG FAR PASCAL SLCreateHandler(hwnd, ped, lpCreateStruct)
HWND            hwnd;
register PED    ped;
LPCREATESTRUCT  lpCreateStruct;

/* effects: Creates the edit control for the window hwnd by allocating memory
 * as required from the application's heap.  Notifies parent if no memory
 * error (after cleaning up if needed).  Returns TRUE if no error else returns
 * -1.  
 */
{
  LPSTR        lpWindowText = lpCreateStruct->lpszName;
  LONG         windowStyle  = GetWindowLong(hwnd, GWL_STYLE);

  /* Save text across the local allocs in ECNcCreate */
  SwapHandle(&lpWindowText);

  /* Do the standard creation stuff */
  if (!ECCreate(hwnd, ped, lpCreateStruct))
      return(-1);

  ped->fSingle = TRUE; /* Set single line edit control */

  /* Single lines always have no undo and 1 line */
  ped->cLines = 1;
  ped->undoType = UNDO_NONE;

  /* Check if this edit control is part of a combobox and get a pointer to the
   * combobox structure.  
   */
  if (windowStyle & ES_COMBOBOX)
      ped->listboxHwnd = GetDlgItem(lpCreateStruct->hwndParent,CBLISTBOXID);

  /* Set the default font to be the system font.  
   */
  ECSetFont(ped, NULL, FALSE);

  /* Set the window text if needed.  Return false if we can't set the text
   * SLSetText notifies the parent in case there is a no memory error.  
   */
  /* Restore text */
  SwapHandle(&lpWindowText);
  if (lpWindowText && *lpWindowText && !SLSetTextHandler(ped, lpWindowText))
      return(-1);

  if (windowStyle & ES_PASSWORD)
      ECSetPasswordChar(ped, (WORD)'*');

  return(TRUE);
}



BOOL FAR PASCAL SLUndoHandler(ped)
register PED ped;
/* effects: Handles UNDO for single line edit controls. */
{
  HANDLE hDeletedText = ped->hDeletedText;
  BOOL   fDelete      = (BOOL)(ped->undoType & UNDO_DELETE);
  WORD   cchDeleted   = ped->cchDeleted;
  WORD   ichDeleted   = ped->ichDeleted;
  BOOL   fUpdate      = FALSE;
  RECT   rcEdit;


  if (ped->undoType == UNDO_NONE)
      /* No undo... */
      return(FALSE);

  ped->hDeletedText = NULL;
  ped->cchDeleted = 0;
  ped->ichDeleted = -1;
  ped->undoType &= ~UNDO_DELETE;
  
  if (ped->undoType == UNDO_INSERT)
    {
      ped->undoType = UNDO_NONE;
      /* Set the selection to the inserted text */
      SLSetSelectionHandler(ped, ped->ichInsStart, ped->ichInsEnd);
      ped->ichInsStart = ped->ichInsEnd = -1;

#ifdef NEVER
      /* Now send a backspace to deleted and save it in the undo buffer... */
      SLCharHandler(ped, VK_BACK, NOMODIFY);
      fUpdate = TRUE;
#else
      /* Delete the selected text and save it in undo buff */
      /* Call ECDeleteText() instead of sending a VK_BACK message which 
       * results in a EN_UPDATE notification sent even before we insert 
       * the deleted chars. This results in Bug #6610.
       * Fix for Bug #6610 -- SANKAR -- 04/19/91 --
       */
      if (ECDeleteText(ped))
          fUpdate = TRUE;
#endif
    }

  if (fDelete)
    {
      /* Insert deleted chars */
      /* Set the selection to the inserted text */
      SLSetSelectionHandler(ped, ichDeleted, ichDeleted);
      SLInsertText(ped, GlobalLock(hDeletedText), cchDeleted);
      GlobalUnlock(hDeletedText);
      GlobalFree(hDeletedText);
      SLSetSelectionHandler(ped, ichDeleted, ichDeleted+cchDeleted);
      fUpdate=TRUE;
    }

  if(fUpdate)
    {
      /* If we have something to update, send EN_UPDATE before and EN_CHANGE
       * after the actual update.
       * A part of the Fix for Bug #6610 -- SANKAR -- 04/19/91 --
       */
      ECNotifyParent(ped, EN_UPDATE);
#ifndef WOW
      if (FChildVisible(ped->hwnd))
#else
      if (IsWindowVisible(GetParent(ped->hwnd)))
#endif
        {
          GetClientRect(ped->hwnd, (LPRECT)&rcEdit);
          if (ped->fBorder && rcEdit.right-rcEdit.left && 
              rcEdit.bottom-rcEdit.top)
	    {
	      /* Don't invalidate the border so that we avoid flicker */
              InflateRect((LPRECT)&rcEdit, -1, -1);
            }
          InvalidateRect(ped->hwnd, (LPRECT)&rcEdit, FALSE);
          UpdateWindow(ped->hwnd);
        }
      ECNotifyParent(ped,EN_CHANGE);
    }
  return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\fastres.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  FASTRES.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 12-Jan-1993 by Chandan Chuahan (ChandanC)
 *
 *  This file provides the Win 3.1 routines for loading BITMAP, MENU, ICON,
 *  CURSOR, and DIALOG resources. These routines load the resources from the
 *  App EXE and then pass the pointers to the corresponding 32 bit WOW
 *  thunks. Thus saving the call backs from USER client to find, load, lock,
 *  size, unlock, and free the resources.
 *
--*/

#include "user.h"

HBITMAP FAR PASCAL WOWLoadBitmap (HINSTANCE hInst, LPCSTR lpszBitmap, LPBYTE lpByte, DWORD ResSize);
HMENU   FAR PASCAL WOWLoadMenu (HINSTANCE hInst, LPCSTR lpszMenuName, LPBYTE lpByte, DWORD ResSize, WORD WinVer);
HCURSOR FAR PASCAL WOWLoadCursorIcon (HINSTANCE hInst, LPCSTR lpszCursor, LPBYTE lpByte, DWORD ResSize, HGLOBAL hGbl, WORD WinVer, WORD wRttype);

//
// fDialogApi is TRUE for DialogBox* apis
// fDialogApi is FALSE for CreateDialog* apis
//

HWND    FAR PASCAL WOWDialogBoxParam (HINSTANCE hInst, LPBYTE lpByte,
                         HWND hwndOwner, DLGPROC dlgprc,  LPARAM lParamInit,
                         DWORD ResSize, WORD fDialogApi);

DWORD   FAR PASCAL NotifyWOW (WORD Id, LPBYTE pData);
#define LR_DEFAULTSIZE      0x0040  // from \nt\public\sdk\inc\winuser.h
int     FAR PASCAL LookupIconIdFromDirectoryEx(LPBYTE lpByte, BOOL fIcon,
                                               int cxDesired, int cyDesired,
                                               WORD wFlags);
HANDLE  FAR PASCAL WOWSetClipboardData (UINT, HANDLE);

typedef struct _ICONCUR16 { /* iconcur */
    WORD   hInst;
    DWORD  lpStr;
} ICONCUR16;

/* These must match counterparts in mvdm\inc\wowusr.h */
#define NW_LOADICON         1 // Internal
#define NW_LOADCURSOR       2 // Internal

HINSTANCE CheckDispHandle (HINSTANCE hInst)
{
    HMODULE hIns;

    if (hInst) {
        hIns = GetModuleHandle ("DISPLAY");
        return ((hInst == (HINSTANCE) hIns) ? 0:hInst);
    }
    else {
        return (0);
    }
}


HBITMAP API ILoadBitmap (HINSTANCE hInst, LPCSTR lpszBitmap)
{
    HRSRC hRsrc = 0;
    HGLOBAL hGbl = 0;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HBITMAP ul = (HBITMAP)0;

    if (hInst = CheckDispHandle (hInst)) {

        hRsrc = FindResource (hInst, lpszBitmap, RT_BITMAP);
        if (!hRsrc) {
            goto lbm_exit;
        }
        ResSize = SizeofResource (hInst, hRsrc);
        if (!ResSize) {
            goto lbm_exit;
        }

        hGbl = LoadResource (hInst, hRsrc);
        if (!hGbl) {
            goto lbm_exit;
        }

        lpByte = LockResource (hGbl);
        if (!lpByte) {
            goto lbm_exit;
        }
    }

    ul = (HBITMAP) WOWLoadBitmap (hInst, lpszBitmap, lpByte, ResSize);


lbm_exit:
    if (lpByte) {
        GlobalUnlock (hGbl);
    }
    if (hGbl) {
        FreeResource(hGbl);
    }

    return (ul);
}




HMENU API ILoadMenu (HINSTANCE hInst, LPCSTR lpszMenuName)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HMENU  ul;
    WORD WinVer;

    if (hRsrc = FindResource (hInst, lpszMenuName, RT_MENU)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                if (lpByte = LockResource (hGbl))
                    WinVer = GetExpWinVer (hInst);
    }

    if (!lpByte) {
        return (NULL);
    }

    ul = (HMENU) WOWLoadMenu (hInst, lpszMenuName, lpByte, ResSize, WinVer);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}


HICON API ILoadIcon (HINSTANCE hInst, LPCSTR lpszIcon)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HICON  ul;
    DWORD IconId;
    WORD WinVer;

    ICONCUR16 IconCur;

    WinVer = GetExpWinVer (hInst);

    if (!(hInst = CheckDispHandle (hInst))) {
        ul = WOWLoadCursorIcon (hInst, lpszIcon, lpByte, ResSize, NULL, WinVer, (WORD)RT_ICON);
    }
    else {
        IconCur.hInst = (WORD) hInst;
        IconCur.lpStr = (DWORD) lpszIcon;

        if (!(ul = (HICON) NotifyWOW (NW_LOADICON, (LPBYTE) &IconCur))) {
            if (WinVer >= VER30) {
                if (hRsrc = FindResource (hInst, lpszIcon, RT_GROUP_ICON)) {
                    if (ResSize = SizeofResource (hInst, hRsrc))
                        if (hGbl = LoadResource (hInst, hRsrc))
                            lpByte = LockResource (hGbl);
                }
                if (!lpByte) {
                    return (NULL);
                }

                IconId = LookupIconIdFromDirectoryEx(lpByte, TRUE, 0, 0, LR_DEFAULTSIZE);

                GlobalUnlock (hGbl);
            }
            else {
                IconId = (DWORD)lpszIcon;
            }

            if (hRsrc = FindResource (hInst, (LPCSTR) IconId, RT_ICON)) {
                if (ResSize = SizeofResource (hInst, hRsrc))
                    if (hGbl = LoadResource (hInst, hRsrc))
                        lpByte = LockResource (hGbl);
                }
            if (!lpByte) {
                return (NULL);
            }

            ul = WOWLoadCursorIcon (hInst, lpszIcon, lpByte, ResSize, hGbl, WinVer, (WORD)RT_ICON);

            GlobalUnlock (hGbl);
        }
    }

    return (ul);
}


HCURSOR API ILoadCursor (HINSTANCE hInst, LPCSTR lpszCursor)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HCURSOR ul;
    DWORD CursorId;
    WORD WinVer;

    ICONCUR16 IconCur;

    WinVer = GetExpWinVer (hInst);

    if (!(hInst = CheckDispHandle (hInst))) {
        ul = WOWLoadCursorIcon (hInst, lpszCursor, lpByte, ResSize, NULL, WinVer, (WORD)RT_CURSOR);
    }
    else {
        IconCur.hInst = (WORD) hInst;
        IconCur.lpStr = (DWORD) lpszCursor;

        if (!(ul = (HICON) NotifyWOW (NW_LOADCURSOR, (LPBYTE) &IconCur))) {
            if (WinVer >= VER30) {
                if (hRsrc = FindResource (hInst, lpszCursor, RT_GROUP_CURSOR)) {
                    if (ResSize = SizeofResource (hInst, hRsrc))
                        if (hGbl = LoadResource (hInst, hRsrc))
                            lpByte = LockResource (hGbl);
                }
                if (!lpByte) {
                    return (NULL);
                }

                CursorId = LookupIconIdFromDirectoryEx((LPBYTE)lpByte, FALSE, 0, 0, LR_DEFAULTSIZE);

                GlobalUnlock (hGbl);
            }
            else {
                CursorId = (DWORD)lpszCursor;
            }

            if (hRsrc = FindResource (hInst, (LPCSTR) CursorId, RT_CURSOR)) {
                if (ResSize = SizeofResource (hInst, hRsrc))
                    if (hGbl = LoadResource (hInst, hRsrc))
                        if (lpByte = LockResource (hGbl))
                            WinVer = GetExpWinVer (hInst);
            }
            if (!lpByte) {
                return (NULL);
            }

            ul = WOWLoadCursorIcon (hInst, lpszCursor, lpByte, ResSize, hGbl, WinVer, (WORD)RT_CURSOR);

            GlobalUnlock (hGbl);
        }
    }

    return (ul);
}



HWND API ICreateDialogParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HWND  ul;

    if (hRsrc = FindResource (hInst, lpszDlgTemp, RT_DIALOG)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                lpByte = LockResource (hGbl);
    }

    if (!lpByte) {
        return (NULL);
    }

    ul = (HWND) WOWDialogBoxParam (hInst, lpByte, hwndOwner,
                                           dlgprc, lParamInit, ResSize, FALSE);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}

HWND API ICreateDialog (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return (ICreateDialogParam (hInst, lpszDlgTemp, hwndOwner, dlgprc, 0L));
}


HWND API ICreateDialogIndirectParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    return  WOWDialogBoxParam (hInst, (LPBYTE)lpszDlgTemp, hwndOwner,
                                            dlgprc, lParamInit, 0, FALSE);
}

HWND API ICreateDialogIndirect (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return  WOWDialogBoxParam (hInst, (LPBYTE)lpszDlgTemp, hwndOwner,
                                            dlgprc, 0, 0, FALSE);
}

int API IDialogBoxParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    int   ul;

    if (hRsrc = FindResource (hInst, lpszDlgTemp, RT_DIALOG)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                lpByte = LockResource (hGbl);
    }

    if (!lpByte) {
        return (-1);
    }

    ul = (int)WOWDialogBoxParam (hInst, lpByte, hwndOwner, dlgprc,
                                                  lParamInit, ResSize, TRUE);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}


int API IDialogBox (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return (IDialogBoxParam (hInst, lpszDlgTemp, hwndOwner, dlgprc, 0L));
}


int API IDialogBoxIndirectParam (HINSTANCE hInst, HGLOBAL hGbl, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    DWORD ResSize;
    LPBYTE lpByte;
    int    ul;

    if (lpByte = LockResource (hGbl)) {
        ResSize = GlobalSize(hGbl);
        ul = (int)WOWDialogBoxParam (hInst, lpByte, hwndOwner, dlgprc,
                                                   lParamInit, ResSize, TRUE);
        GlobalUnlock (hGbl);
    }
    else {
        ul = -1;
    }

    return (ul);
}


int API IDialogBoxIndirect(HINSTANCE hInst, HGLOBAL hGbl, HWND hwndOwner, DLGPROC dlgprc)
{
    return IDialogBoxIndirectParam (hInst, hGbl, hwndOwner, dlgprc, 0);
}

HANDLE  API SetClipboardData (UINT cbformat, HANDLE hMem)
{
    HANDLE ul;
    LPMETAFILEPICT  lpMf;

    switch (cbformat) {

        case CF_DSPMETAFILEPICT:
        case CF_METAFILEPICT:
            if (hMem) {
                lpMf = (LPMETAFILEPICT) GlobalLock(hMem);
                if (lpMf) {

                    /* If the handle is bad make hMF = NULL. This is needed
                     * for Micrograpfx. They don't check for failure when rendering
                     * data
                     */

                    if (!(GlobalReAlloc (lpMf->hMF, 0L, GMEM_MODIFY | GMEM_SHARE))) {
                        lpMf->hMF = NULL;
                    }
                }
                GlobalUnlock(hMem);
            }


            // It is intentional to let it thru to the "case statements".
            // ChandanC 5/11/92.


/*
*        These are the defaults.
*
*        case CF_DIB:
*        case CF_TEXT:
*        case CF_DSPTEXT:
*        case CF_SYLK:
*        case CF_DIF:
*        case CF_TIFF:
*        case CF_OEMTEXT:
*        case CF_PENDATA:
*        case CF_RIFF:
*        case CF_WAVE:
*        case CF_OWNERDISPLAY:
*/

        default:
            if (hMem) {
                hMem = GlobalReAlloc (hMem, 0L, GMEM_MODIFY | GMEM_DDESHARE);
            }
            break;

        case CF_DSPBITMAP:
        case CF_BITMAP:
        case CF_PALETTE:
            break;

    }

    ul = WOWSetClipboardData (cbformat, hMem);
    return (ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\intds.asm ===
;****************************************************************************
;
;   This file contains all global data that must be modified at interrupt
;   level.  Everthing in this file is placed in a fixed data segment
;   named INTDATA.  Only things that must be accessed and modified at
;   interrupt level may be placed in this file.  All values here must be
;   referenced as FAR in the code.
;
;   The creation of this segment allowed USER to eliminate all code segment
;   variables.  This was needed for protect mode as well as moving USER's
;   text segment into HIMEM.
;****************************************************************************

NOEXTERNS = 1
.xlist
include user.inc
.list


createSeg _INTDS, INTDS, BYTE, PUBLIC, DATA

sBegin INTDS

GlobalW hqSysQueue,     00h

ifndef WOW

GlobalW fMouseMoved,    00h
;; GlobalB fAltKeyUp,	80h 	; no longer used

GlobalW fInt24          00h     ; used for INT24 detection in NCMOUSEDOWN

;
; For Asynchronous key state information.
;
public rgbAsyncKeyState
rgbAsyncKeyState db     64 DUP(0)   ; 512 bits of information, 2 per key.

GlobalW fEnableInput,   TRUE

endif ; !WOW

GlobalW hqSysModal,	0	    ; hq of system modal window

ifndef WOW

;
; These are for the code that always keeps enough room for KEYUP/MOUSEUP msgs.
;
GlobalW cMsgRsrv,	0
GlobalB vKeyDown,	0

;
; Mouse Code Variables
;
GlobalW x_mickey_rate,	0	    ; mickeys/pixel ratio for x
GlobalW y_mickey_rate,	0	    ; mickeys/pixel ratio for y
GlobalW cur_x_mickey,	0	    ; current mickey count in x
GlobalW cur_y_mickey,	0	    ; current mickey count in y
GlobalW fSwapButtons,	0	    ; TRUE if L/R are to be swapped.

public ptTrueCursor
ptTrueCursor	POINT	<0, 0>	    ; interrupt-level cursor position

public ptCursor
ptCursor	POINT	<0, 0>	    ; cursor position as of last SkipSysMsg

public          rcCursorClip
rcCursorClip	RECT	<0, 0, 0, 0>

GlobalD dwMouseMoveExtraInfo, 0 ; Extra info for deferred MOUSE MOVE msgs

;
; CS copies of cxScreen, cyScreen for abs mouse scaling
;
GlobalW cxScreenCS,	0
GlobalW cyScreenCS,	0

;
; These are CS copies of msInfo.msXThresh & msYThresh
;   (copied at initialization)
;
GlobalW MouseThresh1,0
GlobalW MouseThresh2,0
GlobalW MouseSpeed,   0       ;0 - no accel, 1 - singel accel, 2 - dual accel

ifndef PMODE
;
; Mouse interrupt stack
;
public lpMouseStack
public prevSSSP
public NestCount
endif

lpMouseStack    dd      ?
prevSSSP	dd	?	    ;Previous stack when inside our hook
NestCount	db	0

;
; Hardware level (interrupt) hook addresse.  Called from event proc's
;

GlobalW 	fJournalPlayback,   0	; != 0 if WH_JOURNALPLAYBACK hook installed

; Table of interrupt-level hotkey hooks

GlobalW cHotKeyHooks,	0

public	rghkhHotKeyHooks
rghkhHotKeyHooks    dw	CHOTKEYHOOKMAX * (size HOTKEYHOOK)/2 dup (0)

; Hardware event hook

GlobalD hwEventHook,	NULL

endif ; !WOW


;
; Q management.
;
GlobalW hqList, 	0	    ; list of allocated queues
GlobalW hqCursor,	0	    ; hq of window under cursor
GlobalW hqCapture,	0	    ; hq of capture
GlobalW hqActive,	0	    ; hq of active window
GlobalW hqMouse,	0	    ; hq last to get mouse msg
GlobalW hqKeyboard,	0	    ; hq last to get kbd msg
GlobalW cQEntries,	120	    ; System queue size
GlobalW hqSysLock	0	    ; HQ of guy looking at the current event
GlobalW idSysLock	0ffffh	    ; Msg ID of event that's locking sys queue


ifndef WOW

;
; Timer management
;
public	timerInfo
timerInfo	    STIMERINFO	<0>
;
; Timer related stuff
;
public TimerTable
TimerTable	dw	(size TIMER)/2 * CTIMERSMAX dup (0)

GlobalW hSysTimer,	0	    ; system timer handle
GlobalD tSysTimer,	0	    ; system timer time
GlobalW dtSysTimer,	0	    ; delta time before next timer goes off
GlobalB fInScanTimers,	0	    ; flag to prevent ScanTimers recursion
GlobalW TimerTableMax,	0	    ; end of active timer entries

;
; Journalling stuff
;
GlobalD dtJournal,	0	    ; dt till next event is ready
GlobalW msgJournal,	0	    ; next journal message.

;
; Used in SaveEvent()
;
GlobalB fDontMakeAltUpASysKey  0    ; whether any intervening chars have arrived


;*--------------------------------------------------------------------------*
;*  Internal Strings							    *
;*--------------------------------------------------------------------------*

; These strings reside in user.rc but are loaded at boot time.  They must
; remain in user.rc for localization reasons.

endif ; !WOW

public szSysError
public szDivZero
szSysError      db      20 DUP(0)   ; "System Error"
szDivZero       db      50 DUP(0)   ; "Divide By Zero or Overflow Error"

ifndef WOW

public szNull
szNull		db	0,13

endif ; !WOW

sEnd INTDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\inuserds.c ===
/****************************************************************************/
/*                                      */
/*  INUSERDS -                                  */
/*                                      */
/*  User's DS Global Variables                      */
/*                                      */
/****************************************************************************/

#include "user.h"

//***** Initialization globals

HINSTANCE hInstanceWin = NULL;
HMODULE   hModuleWin = NULL;


//***** Comm driver globals

int (FAR PASCAL *lpCommWriteString)(int, LPCSTR, WORD);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
int (FAR PASCAL *lpCommReadString)(int, LPSTR, WORD);
                   /* Ptr to the comm driver's
                * commreadstring function. Only
                * exists in 3.1 drivers.
                */
BOOL (FAR PASCAL *lpCommEnableNotification)(int, HWND, int, int);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
//***** PenWindows globals

void (CALLBACK *lpRegisterPenAwareApp)(WORD i, BOOL fRegister) = NULL; /* Register dlg box as pen aware */

//***** Driver management globals

int	cInstalledDrivers =0;	    /* Count of installed driver structs allocated*/
HDRVR	hInstalledDriverList =NULL; /* List of installable drivers */
int     idFirstDriver=-1;           /* First driver in load order */
int     idLastDriver=-1;            /* Last driver in load order */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\iuser.h ===
//--------------------
// Function prototypes

#define GetMessage		   IGetMessage
#define TranslateMessage	   ITranslateMessage
#define DispatchMessage 	   IDispatchMessage
#define PeekMessage		   IPeekMessage
#define lstrcmp 		   Ilstrcmp
#define lstrcmpi		   Ilstrcmpi
#define SetSysModalWindow	   ISetSysModalWindow
// #define SendMessage		   ISendMessage
#define PostMessage		   IPostMessage
#define PostAppMessage		   IPostAppMessage
#define CallWindowProc		   ICallWindowProc
#define IsChild 		   IIsChild
#define IsWindowVisible 	   IIsWindowVisible
#define IsIconic		   IIsIconic
#define CallMsgFilter		   ICallMsgFilter
#define GetKeyboardState	   IGetKeyboardState
#define SetKeyboardState	   ISetKeyboardState
// #define SetCapture		   ISetCapture
#define GetQueueStatus		   IGetQueueStatus
#define SetTimer		   ISetTimer
#define KillTimer		   IKillTimer
#define IsWindowEnabled 	   IIsWindowEnabled
#define GetSystemMetrics	   IGetSystemMetrics
#define GetMenu 		   IGetMenu
#define GetMenuState		   IGetMenuState
#define DrawMenuBar		   IDrawMenuBar
#define DestroyMenu		   IDestroyMenu
#define CheckMenuItem		   ICheckMenuItem
#define EnableMenuItem		   IEnableMenuItem
#define GetSubMenu		   IGetSubMenu
#define GetMenuItemID		   IGetMenuItemID
#define SetActiveWindow 	   ISetActiveWindow
#define BeginPaint		   IBeginPaint
#define InvalidateRect		   IInvalidateRect
#define ValidateRect		   IValidateRect
#define InvalidateRgn		   IInvalidateRgn
#define ValidateRgn		   IValidateRgn
#define SetWindowText		   ISetWindowText
#define GetWindowText		   IGetWindowText
#define GetWindowTextLength	   IGetWindowTextLength
#define GetClientRect		   IGetClientRect
#define GetWindowRect		   IGetWindowRect
#define GetCursorPos		   IGetCursorPos
#define ClipCursor		   IClipCursor
#define GetClipCursor		   IGetClipCursor
#define ClientToScreen		   IClientToScreen
#define ScreenToClient		   IScreenToClient
#define DefDlgProc		   IDefDlgProc
#define GetSysColor		   IGetSysColor
#define DrawFocusRect		   IDrawFocusRect
#define FillRect		   IFillRect
#define FrameRect		   IFrameRect
#define InvertRect		   IInvertRect
#define SetRect 		   ISetRect
#define SetRectEmpty		   ISetRectEmpty
#define CopyRect		   ICopyRect
#define InflateRect		   IInflateRect
#define IntersectRect		   IIntersectRect
#define UnionRect		   IUnionRect
#define SubtractRect		   ISubtractRect
#define OffsetRect		   IOffsetRect
#define IsRectEmpty		   IIsRectEmpty
#define EqualRect		   IEqualRect
#define PtInRect		   IPtInRect
#define GetWindowWord		   IGetWindowWord
#define SetWindowWord		   ISetWindowWord
#define GetWindowLong		   IGetWindowLong
#define SetWindowLong		   ISetWindowLong
#define GetClassWord		   IGetClassWord
#define SetClassWord		   ISetClassWord
#define GetClassLong		   IGetClassLong
#define SetClassLong		   ISetClassLong
#define EnumTaskWindows 	   IEnumTaskWindows
#define MapWindowPoints 	   IMapWindowPoints
#define GetWindowTask		   IGetWindowTask
#define SetWindowsHook		   ISetWindowsHook
#define UnhookWindowsHook	   IUnhookWindowsHook
#define DefHookProc		   IDefHookProc
#define SetWindowsHookEx	   ISetWindowsHookEx
#define UnhookWindowsHookEx	   IUnhookWindowsHookEx
#define CallNextHookEx		   ICallNextHookEx

#define DrawText		   IDrawText
#define GetTabbedTextExtent	   IGetTabbedTextExtent
#define TabbedTextOut		   ITabbedTextOut
#define DrawIcon		   IDrawIcon
#define GetWindowDC		   IGetWindowDC
#define GetDC			   IGetDC
#define ReleaseDC		   IReleaseDC
#define GetDCEx 		   IGetDCEx
#define DefWindowProc		   IDefWindowProc
#define RegisterClass		   IRegisterClass
#define UnregisterClass 	   IUnregisterClass
#define GetClassInfo		   IGetClassInfo
#define GetClassName		   IGetClassName
#define GetNextQueueWindow	   IGetNextQueueWindow
#define CreateWindowEx		   ICreateWindowEx
#define DestroyWindow		   IDestroyWindow
#define ShowWindow		   IShowWindow
#define FlashWindow		   IFlashWindow
#define ShowOwnedPopups 	   IShowOwnedPopups
#define OpenIcon		   IOpenIcon
#define CloseWindow		   ICloseWindow
#define MoveWindow		   IMoveWindow
#define SetWindowPos		   ISetWindowPos
#define DeferWindowPos		   IDeferWindowPos
#define EndDeferWindowPos	   IEndDeferWindowPos
#define CreateDialogParam	   ICreateDialogParam
#define CreateDialogIndirectParam  ICreateDialogIndirectParam
// #define DialogBoxParam             IDialogBoxParam
#define DialogBoxIndirectParam	   IDialogBoxIndirectParam
#define EndDialog		   IEndDialog
#define GetDlgItem		   IGetDlgItem
#define GetDlgItemInt		   IGetDlgItemInt
#define SetDlgItemText		   ISetDlgItemText
#define GetDlgItemText		   IGetDlgItemText
#define CheckDlgButton		   ICheckDlgButton
#define IsDlgButtonChecked	   IIsDlgButtonChecked
#define SendDlgItemMessage	   ISendDlgItemMessage
#define GetNextDlgGroupItem	   IGetNextDlgGroupItem
#define GetNextDlgTabItem	   IGetNextDlgTabItem
#define GetDlgCtrlID		   IGetDlgCtrlID
#define OpenClipboard		   IOpenClipboard
#define SetClipboardViewer	   ISetClipboardViewer
#define ChangeClipboardChain	   IChangeClipboardChain
#define GetPriorityClipboardFormat IGetPriorityClipboardFormat
#define SetFocus		   ISetFocus
#define EnableWindow		   IEnableWindow
#define TranslateAccelerator	   ITranslateAccelerator
#define LoadAccelerators	   ILoadAccelerators
#define LoadMenu		   ILoadMenu
#define LoadMenuIndirect	   ILoadMenuIndirect
#define SetMenu 		   ISetMenu
#define ChangeMenu		   IChangeMenu
#define HiliteMenuItem		   IHiliteMenuItem
#define GetMenuString		   IGetMenuString
#define GetSystemMenu		   IGetSystemMenu
#define SetSystemMenu		   ISetSystemMenu
#define GetMenuItemCount	   IGetMenuItemCount
#define InsertMenu		   IInsertMenu
#define AppendMenu		   IAppendMenu
#define ModifyMenu		   IModifyMenu
#define RemoveMenu		   IRemoveMenu
#define DeleteMenu		   IDeleteMenu
#define SetMenuItemBitmaps	   ISetMenuItemBitmaps
#define TrackPopupMenu		   ITrackPopupMenu
#define GrayString		   IGrayString
#define UpdateWindow		   IUpdateWindow
#define EndPaint		   IEndPaint
#define GetUpdateRect		   IGetUpdateRect
#define GetUpdateRgn		   IGetUpdateRgn
#define ExcludeUpdateRgn	   IExcludeUpdateRgn
#define RedrawWindow		   IRedrawWindow
#define LockWindowUpdate	   ILockWindowUpdate
#define ScrollDC		   IScrollDC
#define ScrollWindowEx		   IScrollWindowEx
#define SetScrollPos		   ISetScrollPos
#define GetScrollPos		   IGetScrollPos
#define SetScrollRange		   ISetScrollRange
#define GetScrollRange		   IGetScrollRange
#define ShowScrollBar		   IShowScrollBar
#define EnableScrollBar 	   IEnableScrollBar
#define SetProp 		   ISetProp
#define GetProp 		   IGetProp
#define RemoveProp		   IRemoveProp
#define EnumProps		   IEnumProps
#define AdjustWindowRectEx	   IAdjustWindowRectEx
#define MessageBox		   IMessageBox
#define SetCursor		   ISetCursor
#define CreateCaret		   ICreateCaret
#define HideCaret		   IHideCaret
#define ShowCaret		   IShowCaret
#define ChildWindowFromPoint	   IChildWindowFromPoint
#define SetSysColors		   ISetSysColors
#define GetParent		   IGetParent
#define SetParent		   ISetParent
#define EnumChildWindows	   IEnumChildWindows
#define FindWindow		   IFindWindow
#define EnumWindows		   IEnumWindows
#define GetTopWindow		   IGetTopWindow
#define GetLastActivePopup	   IGetLastActivePopup
#define GetWindow		   IGetWindow
#define InvalidateDCCache	   InvalidateDCCache
#define LoadBitmap		   ILoadBitmap
#define LoadCursor		   ILoadCursor
#define CreateCursor		   ICreateCursor
#define DestroyCursor		   IDestroyCursor
#define LoadIcon		   ILoadIcon
#define CreateIcon		   ICreateIcon
#define DestroyIcon		   IDestroyIcon
#define LoadString		   ILoadString
#define IsDialogMessage 	   IIsDialogMessage
#define MapDialogRect		   IMapDialogRect
#define DlgDirList		   IDlgDirList
#define DlgDirSelect		   IDlgDirSelect
#define DlgDirSelectEx             IDlgDirSelectEx
#define DlgDirListComboBox	   IDlgDirListComboBox
#define DlgDirSelectComboBox	   IDlgDirSelectComboBox
#define DlgDirSelectComboBoxEx     IDlgDirSelectComboBoxEx
#define DefFrameProc		   IDefFrameProc
#define DefMDIChildProc 	   IDefMDIChildProc
#define TranslateMDISysAccel	   ITranslateMDISysAccel
#define ArrangeIconicWindows	   IArrangeIconicWindows
#define SystemParametersInfo	   ISystemParametersInfo
#define WinHelp 		   IWinHelp
#define OpenDriver		   IOpenDriver
#define CloseDriver		   ICloseDriver
#define GetDriverModuleHandle	   IGetDriverModuleHandle
#define SendDriverMessage	   ISendDriverMessage
#define DefDriverProc		   IDefDriverProc
#define GetNextDriver		   IGetNextDriver
#define GetDriverInfo		   IGetDriverInfo
#define SelectPalette		   ISelectPalette
#define RealizePalette		   IRealizePalette
//#define wsprintf                   Iwsprintf // see user.api
#define wvsprintf		   Iwvsprintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\iuser.inc ===
GetMessage		   equ	<IGetMessage>
TranslateMessage	   equ	<ITranslateMessage>
DispatchMessage 	   equ	<IDispatchMessage>
PeekMessage		   equ	<IPeekMessage>
lstrcmp 		   equ	<Ilstrcmp>
lstrcmpi		   equ	<Ilstrcmpi>
SetSysModalWindow	   equ	<ISetSysModalWindow>
SendMessage		   equ	<ISendMessage>
PostMessage		   equ	<IPostMessage>
PostAppMessage		   equ	<IPostAppMessage>
CallWindowProc		   equ	<ICallWindowProc>
;IsChild                    equ  <IIsChild>
;IsWindowVisible            equ  <IIsWindowVisible>
;IsIconic                   equ  <IIsIconic>
CallMsgFilter		   equ	<ICallMsgFilter>
GetKeyboardState	   equ	<IGetKeyboardState>
SetKeyboardState	   equ	<ISetKeyboardState>
SetCapture		   equ	<ISetCapture>
;GetQueueStatus             equ  <IGetQueueStatus>
SetTimer		   equ	<ISetTimer>
KillTimer		   equ	<IKillTimer>
;IsWindowEnabled            equ  <IIsWindowEnabled>
GetSystemMetrics	   equ	<IGetSystemMetrics>
GetMenu 		   equ	<IGetMenu>
GetMenuState		   equ	<IGetMenuState>
DrawMenuBar		   equ	<IDrawMenuBar>
DestroyMenu		   equ	<IDestroyMenu>
CheckMenuItem		   equ	<ICheckMenuItem>
EnableMenuItem		   equ	<IEnableMenuItem>
GetSubMenu		   equ	<IGetSubMenu>
GetMenuItemID		   equ	<IGetMenuItemID>
SetActiveWindow 	   equ	<ISetActiveWindow>
BeginPaint		   equ	<IBeginPaint>
InvalidateRect		   equ	<IInvalidateRect>
ValidateRect		   equ	<IValidateRect>
InvalidateRgn		   equ	<IInvalidateRgn>
ValidateRgn		   equ	<IValidateRgn>
SetWindowText		   equ	<ISetWindowText>
GetWindowText		   equ	<IGetWindowText>
GetWindowTextLength	   equ	<IGetWindowTextLength>
;GetClientRect              equ  <IGetClientRect>
;GetWindowRect              equ  <IGetWindowRect>
GetCursorPos		   equ	<IGetCursorPos>
ClipCursor		   equ	<IClipCursor>
GetClipCursor		   equ	<IGetClipCursor>
;ClientToScreen             equ  <IClientToScreen>
;ScreenToClient             equ  <IScreenToClient>
;GetSysColor                equ  <IGetSysColor>
DrawFocusRect		   equ	<IDrawFocusRect>
FillRect		   equ	<IFillRect>
FrameRect		   equ	<IFrameRect>
InvertRect		   equ	<IInvertRect>
;SetRect                   equ  <ISetRect>
;SetRectEmpty               equ  <ISetRectEmpty>
;CopyRect                   equ  <ICopyRect>
;InflateRect                equ  <IInflateRect>
;IntersectRect              equ  <IIntersectRect>
;UnionRect                  equ  <IUnionRect>
;SubtractRect               equ  <ISubtractRect>
;OffsetRect                 equ  <IOffsetRect>
;IsRectEmpty                equ  <IIsRectEmpty>
;EqualRect                  equ  <IEqualRect>
;PtInRect                   equ  <IPtInRect>
;GetWindowWord              equ  <IGetWindowWord>
SetWindowWord		   equ	<ISetWindowWord>
;GetWindowLong              equ  <IGetWindowLong>
SetWindowLong		   equ	<ISetWindowLong>
GetClassWord		   equ	<IGetClassWord>
SetClassWord		   equ	<ISetClassWord>
GetClassLong		   equ	<IGetClassLong>
SetClassLong		   equ	<ISetClassLong>
EnumTaskWindows 	   equ	<IEnumTaskWindows>
;MapWindowPoints            equ  <IMapWindowPoints>
GetWindowTask		   equ	<IGetWindowTask>
SetWindowsHook		   equ	<ISetWindowsHook>
UnhookWindowsHook	   equ	<IUnhookWindowsHook>
DefHookProc		   equ	<IDefHookProc>
SetWindowsHookEx	   equ	<ISetWindowsHookEx>
UnhookWindowsHookEx	   equ	<IUnhookWindowsHookEx>
CallNextHookEx		   equ	<ICallNextHookEx>

DrawText		   equ	<IDrawText>
GetTabbedTextExtent	   equ	<IGetTabbedTextExtent>
TabbedTextOut		   equ	<ITabbedTextOut>
DrawIcon		   equ	<IDrawIcon>
GetWindowDC		   equ	<IGetWindowDC>
GetDC			   equ	<IGetDC>
ReleaseDC		   equ	<IReleaseDC>
GetDCEx 		   equ	<IGetDCEx>
DefWindowProc		   equ	<IDefWindowProc>
RegisterClass		   equ	<IRegisterClass>
UnregisterClass 	   equ	<IUnregisterClass>
GetClassInfo		   equ	<IGetClassInfo>
GetClassName		   equ	<IGetClassName>
GetNextQueueWindow	   equ	<IGetNextQueueWindow>
CreateWindowEx		   equ	<ICreateWindowEx>
DestroyWindow		   equ	<IDestroyWindow>
ShowWindow		   equ	<IShowWindow>
FlashWindow		   equ	<IFlashWindow>
ShowOwnedPopups 	   equ	<IShowOwnedPopups>
OpenIcon		   equ	<IOpenIcon>
CloseWindow		   equ	<ICloseWindow>
MoveWindow		   equ	<IMoveWindow>
SetWindowPos		   equ	<ISetWindowPos>
DeferWindowPos		   equ	<IDeferWindowPos>
EndDeferWindowPos	   equ	<IEndDeferWindowPos>
CreateDialogParam	   equ	<ICreateDialogParam>
CreateDialogIndirectParam  equ	<ICreateDialogIndirectParam>
DialogBoxParam		   equ	<IDialogBoxParam>
DialogBoxIndirectParam	   equ	<IDialogBoxIndirectParam>
EndDialog		   equ	<IEndDialog>
GetDlgItem		   equ	<IGetDlgItem>
GetDlgItemInt		   equ	<IGetDlgItemInt>
SetDlgItemText		   equ	<ISetDlgItemText>
GetDlgItemText		   equ	<IGetDlgItemText>
CheckDlgButton		   equ	<ICheckDlgButton>
IsDlgButtonChecked	   equ	<IIsDlgButtonChecked>
SendDlgItemMessage	   equ	<ISendDlgItemMessage>
GetNextDlgGroupItem	   equ	<IGetNextDlgGroupItem>
GetNextDlgTabItem	   equ	<IGetNextDlgTabItem>
GetDlgCtrlID		   equ	<IGetDlgCtrlID>
DefDlgProc		   equ	<IDefDlgProc>
OpenClipboard		   equ	<IOpenClipboard>
SetClipboardViewer	   equ	<ISetClipboardViewer>
ChangeClipboardChain	   equ	<IChangeClipboardChain>
GetPriorityClipboardFormat equ	<IGetPriorityClipboardFormat>
SetFocus		   equ	<ISetFocus>
EnableWindow		   equ	<IEnableWindow>
TranslateAccelerator	   equ	<ITranslateAccelerator>
LoadAccelerators	   equ	<ILoadAccelerators>
LoadMenu		   equ	<ILoadMenu>
LoadMenuIndirect	   equ	<ILoadMenuIndirect>
SetMenu 		   equ	<ISetMenu>
ChangeMenu		   equ	<IChangeMenu>
HiliteMenuItem		   equ	<IHiliteMenuItem>
GetMenuString		   equ	<IGetMenuString>
GetSystemMenu		   equ	<IGetSystemMenu>
SetSystemMenu		   equ	<ISetSystemMenu>
GetMenuItemCount	   equ	<IGetMenuItemCount>
InsertMenu		   equ	<IInsertMenu>
AppendMenu		   equ	<IAppendMenu>
ModifyMenu		   equ	<IModifyMenu>
RemoveMenu		   equ	<IRemoveMenu>
DeleteMenu		   equ	<IDeleteMenu>
SetMenuItemBitmaps	   equ	<ISetMenuItemBitmaps>
TrackPopupMenu		   equ	<ITrackPopupMenu>
GrayString		   equ	<IGrayString>
UpdateWindow		   equ	<IUpdateWindow>
EndPaint		   equ	<IEndPaint>
GetUpdateRect		   equ	<IGetUpdateRect>
GetUpdateRgn		   equ	<IGetUpdateRgn>
ExcludeUpdateRgn	   equ	<IExcludeUpdateRgn>
RedrawWindow		   equ	<IRedrawWindow>
LockWindowUpdate	   equ	<ILockWindowUpdate>
ScrollDC		   equ	<IScrollDC>
ScrollWindowEx		   equ	<IScrollWindowEx>
SetScrollPos		   equ	<ISetScrollPos>
GetScrollPos		   equ	<IGetScrollPos>
SetScrollRange		   equ	<ISetScrollRange>
GetScrollRange		   equ	<IGetScrollRange>
ShowScrollBar		   equ	<IShowScrollBar>
EnableScrollBar 	   equ	<IEnableScrollBar>
SetProp 		   equ	<ISetProp>
;GetProp                    equ  <IGetProp>
RemoveProp		   equ	<IRemoveProp>
EnumProps		   equ	<IEnumProps>
AdjustWindowRectEx	   equ	<IAdjustWindowRectEx>
MessageBox		   equ	<IMessageBox>
SetCursor		   equ	<ISetCursor>
CreateCaret		   equ	<ICreateCaret>
HideCaret		   equ	<IHideCaret>
ShowCaret		   equ	<IShowCaret>
ChildWindowFromPoint	   equ	<IChildWindowFromPoint>
SetSysColors		   equ	<ISetSysColors>
GetParent		   equ	<IGetParent>
SetParent		   equ	<ISetParent>
EnumChildWindows	   equ	<IEnumChildWindows>
FindWindow		   equ	<IFindWindow>
EnumWindows		   equ	<IEnumWindows>
GetTopWindow		   equ	<IGetTopWindow>
GetLastActivePopup	   equ	<IGetLastActivePopup>
GetWindow		   equ	<IGetWindow>
;InvalidateDCCache          equ  <IInvalidateDCCache>
LoadBitmap		   equ	<ILoadBitmap>
LoadCursor		   equ	<ILoadCursor>
CreateCursor		   equ	<ICreateCursor>
DestroyCursor		   equ	<IDestroyCursor>
LoadIcon		   equ	<ILoadIcon>
CreateIcon		   equ	<ICreateIcon>
DestroyIcon		   equ	<IDestroyIcon>
LoadString		   equ	<ILoadString>
IsDialogMessage 	   equ	<IIsDialogMessage>
MapDialogRect		   equ	<IMapDialogRect>
DlgDirList		   equ	<IDlgDirList>
DlgDirSelect		   equ	<IDlgDirSelect>
DlgDirSelectEx             equ  <IDlgDirSelectEx>
DlgDirListComboBox	   equ	<IDlgDirListComboBox>
DlgDirSelectComboBox	   equ	<IDlgDirSelectComboBox>
DlgDirSelectComboBoxEx     equ  <IDlgDirSelectComboBoxEx>
DefFrameProc		   equ	<IDefFrameProc>
DefMDIChildProc 	   equ	<IDefMDIChildProc>
TranslateMDISysAccel	   equ	<ITranslateMDISysAccel>
ArrangeIconicWindows	   equ	<IArrangeIconicWindows>
SystemParametersInfo	   equ	<ISystemParametersInfo>
WinHelp 		   equ	<IWinHelp>
OpenDriver		   equ	<IOpenDriver>
CloseDriver		   equ	<ICloseDriver>
GetDriverModuleHandle	   equ	<IGetDriverModuleHandle>
SendDriverMessage	   equ	<ISendDriverMessage>
DefDriverProc		   equ	<IDefDriverProc>
GetNextDriver		   equ	<IGetNextDriver>
GetDriverInfo		   equ	<IGetDriverInfo>
SelectPalette		   equ	<ISelectPalette>
RealizePalette		   equ	<IRealizePalette>
;wsprintf                   equ  <Iwsprintf>  ; see user.api
wvsprintf		   equ	<Iwvsprintf>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\fmtmsg.c ===
//
// Windows NT WOW v5
//
// fmtmsg.c -- 16-bit FormatMessage API, lifted from Win95
//             \win\core\user\wn32rare.c by Dave Hart
//
//

#include "user.h"

typedef DWORD ULONG;

// from win95 user.h
#define CODESEG     _based(_segname("_CODE"))
#define TESTFAR(p)  SELECTOROF(p)

// from win95 dev\inc16\windows.h
#define FORMAT_MESSAGE_ALLOCATE_BUFFER  0x00000100      /* ;Internal NT */
#define FORMAT_MESSAGE_IGNORE_INSERTS   0x00000200      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_STRING      0x00000400      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_HMODULE     0x00000800      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_SYSTEM      0x00001000      /* ;Internal NT */
//#define FORMAT_MESSAGE_ARGUMENT_ARRAY   0x00002000      /* ;Internal */
#define FORMAT_MESSAGE_MAX_WIDTH_MASK   0x000000FF      /* ;Internal NT */
#define FORMAT_MESSAGE_VALID            0x00003FFF      /* ;Internal */


char CODESEG szStringFormat[] = "%s";
char CODESEG szStringFormat2[] = "%%%lu";
char CODESEG szStringFormat3[] = "%%%lu!%s!";


#if 0
// ----------------------------------------------------------------------------
//
//  GetSystemInstance()
//
//  _loadds function to return hInstanceWin.  Needed cuz FormatMessage can
//  LocalAlloc a buffer for an app.  We GlobalAlloc() a temp buffer to do the
//  actual work in.  Both local & global memory go away when the context that
//  created it terminates.
//
// ----------------------------------------------------------------------------
HINSTANCE NEAR _loadds FMGetSystemInstance(void)
{
    return(hInstanceWin);
}
#endif


#undef LocalAlloc
#undef LocalFree
extern HLOCAL WINAPI LocalAlloc(UINT, UINT);
extern HLOCAL WINAPI LocalFree(HLOCAL);

// ----------------------------------------------------------------------------
//
//  FormatMessage()
//
//  16-bit version of FormatMessage32().
//
//  Note that this API is NOT _loadds.  We might need to LocalAlloc() a buffer
//  for the result.  Therefore, we can't just use random static string vars.
//  They _must_ be CODESEG.
//
// ----------------------------------------------------------------------------
UINT _far _pascal FormatMessage(DWORD dwFlags, LPVOID lpSource, UINT idMessage,
    UINT idLanguage, LPSTR lpResult, UINT cbResultMax, DWORD FAR * rglArgs)
{
    LPSTR       lpBuffer;
    HINSTANCE   hInstance;
    UINT        Column;
    UINT        MaximumWidth;
    DWORD       rgInserts[100];
    WORD        MaxInsert, CurInsert;
    UINT        cbNeeded, cbResult;
    char        szMessage[256];
    LPSTR       MessageFormat;
    UINT        cbMessage;
    UINT        PrintParameterCount;
    DWORD       PrintParameter1;
    DWORD       PrintParameter2;
    char        PrintFormatString[32];
    LPSTR       s, s1, s1base;
    LPSTR       lpAlloc;
    LPSTR       lpDst, lpDstBeg;

    //
    // Force idLanguage to be 0 for 16-bit apps, for now...
    //
    if (idLanguage)
    {
        DebugErr(DBF_ERROR, "FormatMessage: language id must be 0");
        return(0);
    }

    //
    // Prevent NULL lpResult
    //
    if (!TESTFAR(lpResult))
    {
        DebugErr(DBF_ERROR, "FormatMessage: NULL result buffer");
        return(0);
    }

    //
    // Prevent caller from using non-defined flags...
    //
    if (dwFlags & ~FORMAT_MESSAGE_VALID)
    {
        DebugErr(DBF_ERROR, "FormatMessage: invalid flags");
        return(0);
    }

    //
    // Get temporary buffer.
    //
    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
        cbResultMax = 0x7FFE;

    lpBuffer = MAKELP(GlobalAlloc(GHND, (DWORD)cbResultMax+1), 0);
    if (!SELECTOROF(lpBuffer))
    {
        DebugErr(DBF_ERROR, "FormatMessage:  Couldn't allocate enough memory");
        return(0);
    }

    lpAlloc = NULL;
    cbResult = 0;

    MaximumWidth = LOWORD(dwFlags & FORMAT_MESSAGE_MAX_WIDTH_MASK);

    //
    // Get message string
    //
    if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
    {
        if (!TESTFAR(lpSource))
        {
            DebugErr(DBF_ERROR, "FormatMessage:  NULL format string");
            goto FailureExit;
        }

        MessageFormat = lpSource;
        cbMessage = lstrlen(MessageFormat);
    }
    else
    {
        if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE)
        {
            hInstance = (HINSTANCE)OFFSETOF(lpSource);
            if (!hInstance)
            {
                DebugErr(DBF_ERROR, "FormatMessage:  NULL hInstance not allowed for 16 bits");
                goto FailureExit;
            }
        }
        else if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)
#if 0
            // This doesn't work on WOW and it's not worth
            // fixing because our user.exe doesn't have any
            // FormatMessage text as string resources.
            hInstance = FMGetSystemInstance();
#else
        {
            DebugErr(DBF_ERROR, "FormatMessage:  FORMAT_MESSAGE_FROM_SYSTEM");
            goto FailureExit;
        }
#endif
        else
        {
            DebugErr(DBF_ERROR, "FormatMessage:  Invalid source");
            goto FailureExit;
        }

        //
        // Load the string
        //
        cbMessage = LoadString(hInstance, idMessage, szMessage,
            sizeof(szMessage)-1);

        if (!cbMessage)
        {
            DebugErr(DBF_ERROR, "FormatMessage:  Couldn't load source string");
            goto FailureExit;
        }

        MessageFormat = (LPSTR)szMessage;
    }

    lpDst = lpBuffer;
    MaxInsert = 0;
    Column = 0;
    s = MessageFormat;

    while (*s)
    {
        if (*s == '%')
        {
            s++;

            lpDstBeg = lpDst;
            if (*s >= '1' && *s <= '9')
            {
                CurInsert = *s++ - '0';
                if (*s >= '0' && *s <= '9')
                {
                    CurInsert = (CurInsert * 10) + (*s++ - '0');
                }
                CurInsert--;

                PrintParameterCount = 0;
                if (*s == '!')
                {
                    s1 = s1base = PrintFormatString;
                    *s1++ = '%';
                    s++;
                    while (*s != '!')
                    {
                        if (*s != '\0')
                        {
                            if (s1 >= (s1base + sizeof(PrintFormatString) - 1))
                            {
                                goto ParamError;
                            }

                            if (*s == '*')
                            {
                                if (PrintParameterCount++ > 1)
                                {
                                    goto ParamError;
                                }
                            }

                            *s1++ = *s++;
                        }
                        else
                        {
ParamError: 
                            DebugErr(DBF_ERROR, "FormatMessage:  Invalid format string");
                            goto FailureExit;
                        }
                    }

                    s++;
                    *s1 = '\0';
                }
                else
                {
                    lstrcpy(PrintFormatString, szStringFormat);
                    s1 = PrintFormatString + lstrlen(PrintFormatString);
                }

                if (!(dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) && TESTFAR(rglArgs))
                {
                    while (CurInsert >= MaxInsert)
                    {
                        rgInserts[MaxInsert++] = *(rglArgs++);
                    }

                    s1 = (LPSTR)rgInserts[CurInsert];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0)
                    {
                        PrintParameter1 = rgInserts[MaxInsert++] = *(rglArgs++);
                        if (PrintParameterCount > 1)
                        {
                            PrintParameter2 = rgInserts[MaxInsert++] = *(rglArgs++);
                        }
                    }

                    lpDst += wsprintf(lpDst, PrintFormatString, s1,
                        PrintParameter1, PrintParameter2);
                }
                else if (!lstrcmp(PrintFormatString, szStringFormat))
                {
                    lpDst += wsprintf(lpDst, szStringFormat2, CurInsert+1);
                }
                else
                {
                    lpDst += wsprintf(lpDst, szStringFormat3, CurInsert+1,
                        (LPSTR)&PrintFormatString[1]);
                }
            }
            else if (*s == '0')
                break;
            else if (!*s)
                goto FailureExit;
            else if (*s == '!')
            {
                *lpDst++ = '!';
                s++;
            }
            else if (*s == 't')
            {
                *lpDst++ = '\t';
                s++;
                if (Column % 8)
                {
                    Column = (Column + 7) & ~7;
                }
                else
                {
                    Column += 8;
                }
            }
            else if (*s == 'b')
            {
                *lpDst++ = ' ';
                s++;
            }
            else if (*s == 'r')
            {
                *lpDst++ = '\r';
                s++;
                lpDstBeg = NULL;
            }
            else if (*s == '\n')
            {
                *lpDst++ = '\r';
                *lpDst++ = '\n';
                s++;
                lpDstBeg = NULL;
            }
            else
            {
                if (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS)
                {
                    *lpDst++ = '%';
                }

                *lpDst++ = *s++;
            }

            if (!TESTFAR(lpDstBeg))
            {
                Column = 0;
            }
            else
            {
                Column += lpDst - lpDstBeg;
            }
        }
        else
        {
            char c;

            c = *s++;
            if (c == '\r')
            {
                if (*s == '\n')
                {
                    s++;
                }

                if (MaximumWidth)
                {
                    c = ' ';
                }
                else
                {
                    c = '\n';
                }
            }

            if (c == '\n' || (c == ' ' && MaximumWidth &&
                MaximumWidth != FORMAT_MESSAGE_MAX_WIDTH_MASK &&
                Column >= MaximumWidth))
            {

                *lpDst++ = '\r';
                *lpDst++ = '\n';
                Column = 0;
            }
            else
            {
                *lpDst++ = c;
                Column++;
            }
        }
    }

    *lpDst++ = 0;
    cbNeeded = lpDst - lpBuffer;

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        PSTR pstr;

        *(PSTR FAR *)lpResult = NULL;

        pstr = (PSTR)LocalAlloc(LPTR, cbNeeded);

        if (!pstr)
        {
            DebugErr(DBF_ERROR, "FormatMessge:  couldn't LocalAlloc memory for result");
            goto FailureExit;
        }

        lpDst = lpAlloc = (LPSTR)pstr;
    }
    else if (cbNeeded > cbResultMax)
    {
        DebugErr(DBF_ERROR, "FormatMessage:  passed in buffer is too small for result");
        goto FailureExit;
    }
    else
    {
        lpDst = lpResult;
    }

    lstrcpyn(lpDst, lpBuffer, cbNeeded);

    cbResult = --cbNeeded;

FailureExit:
    if (TESTFAR(lpAlloc))
    {
        if (cbResult)
        {
            *(PSTR FAR *)lpResult = (PSTR)OFFSETOF(lpAlloc);
        }
        else
        {
            LocalFree((HANDLE)OFFSETOF(lpAlloc));
        }
    }

    if (TESTFAR(lpBuffer))
        GlobalFree((HANDLE)SELECTOROF(lpBuffer));

    return(cbResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\helpcall.c ===
/*****************************************************************************
*                                                                            *
*  HELPCALL.C                                                                *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1989.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Program Description:  Sample interface to windows help                    *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by RKB      11/30/88                           *
*                     Revised to new API  1/12/88  (RKB)                     *
*                     Added to USER       3/28/89  (BG)                      *
*                     Slight update       6/15/89  (BG)                      *
*                     Clean ugly code     10/30/89 (BG)                      *
*                     GlobalFree if QUIT  1/26/90  (CRC)                     *
*                                                                            *
******************************************************************************
*/

#define   NO_REDEF_SENDMESSAGE
#include  "user.h"
#define _WINGDIP_             // We need to define these to prevent 
#include  "wowcmpat.h"        // redefinition of the GACF flags

#define WM_WINHELP 0x38
DWORD API NotifyWow(WORD, LPBYTE);

BOOL API 
Win32WinHelp(
	HWND hwndMain, 
	LPCSTR lpszHelp, 
	UINT usCommand, 
	DWORD ulData
        );

DWORD WINAPI
GetWOWCompatFlagsEx(
        void
        );


/* This must match its counterpart in mvdm\inc\wowusr.h */
#define NW_WINHELP         6 // Internal

WORD      msgWinHelp = 0;
char CODESEG szMS_WINHELP[] = "MS_WINHELP";


/*

Communicating with WinHelp involves using Windows SendMessage() function
to pass blocks of information to WinHelp.  The call looks like.

     SendMessage(hwndHelp, msgWinHelp, hwndMain, (LONG)hHlp);

Where:

  hwndHelp - the window handle of the help application.  This
             is obtained by enumerating all the windows in the
             system and sending them HELP_FIND commands.  The
             application may have to load WinHelp.
  msgWinHelp - the value obtained from a RegisterWindowMessage()
             szWINHELP
  hwndMain - the handle to the main window of the application
             calling help
  hHlp     - a handle to a block of data with a HLP structure
             at it head.

The data in the handle will look like:

         +-------------------+
         |     cbData        |
         |    usCommand      |
         |     ulTopic       |
         |    ulReserved     |
         |   offszHelpFile   |\     - offsets measured from beginning
       / |     offaData      | \      of header.
      /  +-------------------| /
     /   |  Help file name   |/
     \   |    and path       |
      \  +-------------------+
       \ |    Other data     |
         |    (keyword)      |
         +-------------------+

The defined commands are:

    HELP_CONTEXT   0x0001    Display topic in ulTopic
    HELP_KEY       0x0101    Display topic for keyword in offabData
    HELP_QUIT      0x0002    Terminate help

*/


/*******************
**
** Name:       HFill
**
** Purpose:    Builds a data block for communicating with help
**
** Arguments:  lpszHelp  - pointer to the name of the help file to use
**             usCommand - command being set to help
**             ulData    - data for the command
**
** Returns:    a handle to the data block or hNIL if the the
**             block could not be created.
**
*******************/


HANDLE HFill(LPCSTR lpszHelp, WORD usCommand, DWORD ulData)
{
  WORD     cb;                          /* Size of the data block           */
  HANDLE   hHlp;                        /* Handle to return                 */
  BYTE     bHigh;                       /* High byte of usCommand           */
  LPHLP    qhlp;                        /* Pointer to data block            */
                                        /* Calculate size                   */
  if (lpszHelp)
      cb = sizeof(HLP) + lstrlen(lpszHelp) + 1;
  else
      cb = sizeof(HLP);

  bHigh = (BYTE)HIBYTE(usCommand);

  if (bHigh == 1)
      cb += lstrlen((LPSTR)ulData) + 1;
  else if (bHigh == 2)
      cb += *((int far *)ulData);

                                        /* Get data block                   */
  if (!(hHlp = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, (DWORD)cb)))
      return NULL;

  if (!(qhlp = (LPHLP)GlobalLock(hHlp)))
    {
      GlobalFree(hHlp);
      return NULL;
    }

  qhlp->cbData        = cb;             /* Fill in info                     */
  qhlp->usCommand     = usCommand;
  qhlp->ulReserved    = 0;
  if (lpszHelp)
    {
      qhlp->offszHelpFile = sizeof(HLP);
      lstrcpy((LPSTR)(qhlp+1), lpszHelp);
    }
  else
      qhlp->offszHelpFile = 0;

  switch(bHigh)
    {
    case 0:
      qhlp->offabData = 0;
      qhlp->ulTopic   = ulData;
      break;
    case 1:
      qhlp->offabData = sizeof(HLP) + lstrlen(lpszHelp) + 1;
      lstrcpy((LPSTR)qhlp + qhlp->offabData,  (LPSTR)ulData);
      break;
    case 2:
      qhlp->offabData = sizeof(HLP) + lstrlen(lpszHelp) + 1;
      LCopyStruct((LPSTR)ulData, (LPSTR)qhlp + qhlp->offabData, *((int far *)ulData));
      break;
    }

   GlobalUnlock(hHlp);
   return hHlp;
  }



char CODESEG szEXECHELP[] = "\\WINHELP -x";

BOOL _fastcall LaunchHelper(LPSTR lpfile)
{
  int len;

  len = lstrlen(lpfile);

  if (lpfile[len-1]=='\\')
      /* Are we at the root?? If so, skip over leading backslash in text
       * string. */
      lstrcat(lpfile, szEXECHELP+1);
  else
      lstrcat(lpfile, szEXECHELP);

  return ((HINSTANCE)WinExec(lpfile, SW_SHOW) > HINSTANCE_ERROR);
}


BOOL LaunchHelp(VOID)
{
  char szFile[128];

  /* Search in windows directory */
  GetWindowsDirectory(szFile, sizeof(szFile));
  if (LaunchHelper(szFile))
      return(TRUE);

  /* Search system directory */
  GetSystemDirectory(szFile, sizeof(szFile));
  if (LaunchHelper(szFile))
      return(TRUE);

  /* Last ditch: simply let dos do it */
  lstrcpy(szFile, szEXECHELP+1);
  return ((HINSTANCE)WinExec(szFile, SW_SHOW) > HINSTANCE_ERROR);
}


/*******************
**
** Name:       WinHelp
**
** Purpose:    Displays help
**
** Arguments:
**             hwndMain        handle to main window of application
**             lpszHelp        path (if not current directory) and file
**                             to use for help topic.
**             usCommand       Command to send to help
**             ulData          Data associated with command:
**                             HELP_QUIT     - no data (undefined)
**                             HELP_LAST     - no data (undefined)
**                             HELP_CONTEXT  - context number to display
**                             HELP_KEY      - string ('\0' terminated)
**                                             use as keyword to topic
**                                             to display
**                             HELP_FIND     - no data (undefined)
**
** Returns:    TRUE iff success
**
*******************/

BOOL API IWinHelp(hwndMain, lpszHelp, usCommand, ulData)
HWND               hwndMain;
LPCSTR         lpszHelp;
UINT               usCommand;
DWORD              ulData;
{
  register HANDLE  hHlp;
  DWORD            dwHelpPid;           /* loword is hwndHelp             */
                                        /* hiword TRUE if hwndHelp is of this process */
  DWORD  dwWOWCompatFlagsEx;
  

  /* RAID BUG 394455
     Some apps have problems loading their help files with 16 bit winhelp. Hard coded paths,
     32 bit helper dlls, etc. These issues can be fixed by redirecting the call to winhelp32. 
     Check to see if the compatibility bit has been set for this app. */
  dwWOWCompatFlagsEx = GetWOWCompatFlagsEx();
  
  if (dwWOWCompatFlagsEx & WOWCFEX_USEWINHELP32) {
      return Win32WinHelp(hwndMain, lpszHelp, usCommand, ulData);
      }
  
  if (msgWinHelp == 0) {

    /* Register private WinHelp message for communicating to WinHelp via
     * WinHelp api.
     */
    char static CODESEG szWM_WINHELP[] = "WM_WINHELP";
    msgWinHelp = RegisterWindowMessage(szWM_WINHELP);
  }

  /* Move Help file name to a handle */
  if (!(hHlp = HFill(lpszHelp, usCommand, ulData)))
      return(FALSE);

  if ((dwHelpPid = (DWORD)NotifyWow(NW_WINHELP, szMS_WINHELP)) == (DWORD)NULL)
    {
      if (usCommand == HELP_QUIT)    /* Don't bother to load HELP just to*/
        {
          GlobalFree(hHlp);
          return(TRUE);
        }

      /* Can't find it --> launch it  */
      if (!LaunchHelp() || ((dwHelpPid = (DWORD)NotifyWow(NW_WINHELP, szMS_WINHELP)) == (DWORD)NULL))
        {
          /* Can't find help, or not enough memory to load help.*/
          GlobalFree(hHlp);
          return(FALSE);
        }

    }

  // if winhelp.exe was launched from this process, normal sendmessage else
  // we need to thunk the data across WOWVDM processes and the format is
  //     msg = WM_WINHELP, a private msg
  //     wparam = 0 instead of hwndMain, (note 1)
  //     lparam = LPHLP
  //
  // note 1: winhelp, calls GetWindowWord(wParam, GWW_HINSTANCE) when it receives HELP_QUIT
  //         command. If this matches a value in its table and is the only registered instance
  //         winhelp will close - this is quite ok undernormal circumstances (just one WOWVDM)
  //         but under multiple WOWVDM, numeric value of hinstances could be same for different
  //         hwnds.
  //
  //         So we workaround this by passing a NULL hwnd in wParam and by not sending HELP_QUIT
  //         message - which effectively implies that WinHelp will close only if there are no
  //         references to it from the same WOWVDM (as itself).
  //
  // This is the best compromise I could comeup with for running "only one WinHelp for all
  // WOWVDMs".
  //
  //                                                               - nanduri

  if (HIWORD(dwHelpPid)) {
      SendMessage((HWND)LOWORD(dwHelpPid), msgWinHelp, (WPARAM)hwndMain, MAKELPARAM(hHlp, 0));
  }
  else {
      if (usCommand != HELP_QUIT) {
          SendMessage((HWND)LOWORD(dwHelpPid), WM_WINHELP, (WPARAM)0, (LPARAM)GlobalLock(hHlp));
          GlobalUnlock(hHlp);
      }
  }

  GlobalFree(hHlp);
  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\init.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  INIT.C
 *  WOW16 user initialisation code
 *
 *  History:
 *
 *  Created 15-Apr-1991 by Nigel Thompson (nigelt)
 *
 *  Revised 19-May-1991 by Jeff Parsons (jeffpar)
 *  IFDEF'ed everything, since everything was only needed by RMLOAD.C,
 *  and that has been largely IFDEF'ed as well (see RMLOAD.C for details)
--*/

#define FIRST_CALL_MUST_BE_USER_BUG

#include "user.h"


/* These must match counterparts in mvdm\inc\wowusr.h */
#define NW_FINALUSERINIT       4 // Internal
#define NW_KRNL386SEGS         5 // Internal

DWORD API NotifyWow(WORD, LPBYTE);
VOID FAR PASCAL PatchUserStrRtnsToThunk(VOID);
/***************************************************************************

    global data items

***************************************************************************/


#ifdef NEEDED
HDC hdcBits;        // USER's general hdc
OEMINFO oemInfo;                // lots of interresting info
#endif
#ifdef FIRST_CALL_MUST_BE_USER_BUG
HWND    hwndDesktop;        // handle to the desktop window
#endif

BOOL fThunkStrRtns;         // if TRUE we thunk to Win32 (see winlang.asm)



FARPROC LPCHECKMETAFILE;

/***************************************************************************

    initialisation routine

***************************************************************************/

int FAR PASCAL LibMain(HANDLE hInstance)
{
#ifdef NEEDED
    HDC hDC;
#endif
    HANDLE   hLib;
    HANDLE   hInstKrnl;

    dprintf(3,"Initializing...");

    // Notify the hInstance of USER to wow32.
    //                                                     - Nanduri
    //
    // Overload this to return the ANSI code page from Win32 GetACP.
    //                                                     - DaveHart 5-May-94
    //

    {
#ifdef PMODE32
        extern _cdecl wow16gpsi(void);
        extern _cdecl wow16CsrFlag(void);
        extern _cdecl wow16gHighestUserAddress(void);
#endif
        WORD wCS;
        extern WORD MaxDWPMsg;
        extern BYTE DWPBits[1];
        extern WORD cbDWPBits;

// NOTE: these two structs are also in mvdm\inc\wowusr.h 
//       USERCLIENTGLOBALS  &  KRNL386SEGS
//       - they must be the same!!!
        struct {
            WORD       hInstance;
            LPSTR FAR *lpgpsi;
            LPSTR FAR *lpCallCsrFlag;
            DWORD      dwBldInfo;
            LPWORD     lpwMaxDWPMsg;
            LPSTR      lpDWPBits;
            WORD       cbDWPBits;
            WORD       wUnusedPadding;
            DWORD      pfnGetProcModule;
            LPSTR FAR *lpHighestAddress;
        } UserInit16;

        struct {
            WORD CodeSeg1;
            WORD CodeSeg2;
            WORD CodeSeg3;
            WORD DataSeg1;
        } Krnl386Segs;
            
        UserInit16.hInstance        = (WORD)hInstance;
#ifdef PMODE32
        UserInit16.lpgpsi           = (LPSTR *)wow16gpsi;
        UserInit16.lpCallCsrFlag    = (LPSTR *)wow16CsrFlag;
        UserInit16.lpHighestAddress = (LPSTR *)&wow16gHighestUserAddress;
#else
        UserInit16.lpgpsi           = (LPSTR *)0;
        UserInit16.lpCallCsrFlag    = (LPSTR *)0;
        UserInit16.lpHighestAddress = (LPSTR *)0;
#endif

#ifdef WOWDBG
        UserInit16.dwBldInfo        = (((DWORD)WOW) << 16) | 0x80000000;
#else
        UserInit16.dwBldInfo        = (((DWORD)WOW) << 16);
#endif

        _asm mov wCS, cs;
        UserInit16.lpwMaxDWPMsg = (LPWORD) MAKELONG((WORD)&MaxDWPMsg, wCS);
        UserInit16.lpDWPBits = (LPBYTE) MAKELONG((WORD)&DWPBits[0], wCS);
        UserInit16.cbDWPBits = *(LPWORD) MAKELONG((WORD)&cbDWPBits, wCS);
        UserInit16.pfnGetProcModule = (DWORD)(FARPROC) GetProcModule;

        fThunkStrRtns = NotifyWow(NW_FINALUSERINIT, (LPBYTE)&UserInit16);

        // now that wow32 knows pfnGetProcModule we can call GetProcAddress
        // to get the kernel code & data segs
        hInstKrnl = LoadLibrary("krnl386.exe");
        FreeLibrary(hInstKrnl);

        Krnl386Segs.CodeSeg1 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "LoadResource"));
        Krnl386Segs.CodeSeg2 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "LoadModule"));
        Krnl386Segs.CodeSeg3 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "FindResource"));
        Krnl386Segs.DataSeg1 = (WORD)hInstKrnl;

        NotifyWow(NW_KRNL386SEGS, (LPBYTE)&Krnl386Segs);

        //
        // fThunkStrRtns defaults to TRUE outside the U.S. English
        // locale and FALSE in the U.S. English locale.  If we are
        // thunking, patch the exported U.S. implementations to simply
        // near jmp to the equivalent thunk.
        //

        if (fThunkStrRtns) {
            PatchUserStrRtnsToThunk();
        }
    }

#ifdef FIRST_CALL_MUST_BE_USER_BUG
    // get the desktop window handle

    WinEval(hwndDesktop = GetDesktopWindow());
#endif


#ifdef NEEDED

    // create a compatible dc we can use for general bitmap stuff

    WinEval(hDC = GetDC(hwndDesktop));
    WinEval(hdcBits = CreateCompatibleDC(hDC));

    // fill in the oemInfo structure
    // NOTE: We only fill in the bits we need for WOW not all of it

    oemInfo.cxIcon          = GetSystemMetrics(SM_CXICON);
    oemInfo.cyIcon          = GetSystemMetrics(SM_CYICON);
    oemInfo.cxCursor        = GetSystemMetrics(SM_CXCURSOR);
    oemInfo.cyCursor        = GetSystemMetrics(SM_CYCURSOR);
    oemInfo.ScreenBitCount  = GetDeviceCaps(hDC, BITSPIXEL)
                            * GetDeviceCaps(hDC, PLANES);
    oemInfo.DispDrvExpWinVer= GetVersion();


    ReleaseDC(hwndDesktop, hDC);

#endif

    hLib = LoadLibrary( "gdi.exe" );
    LPCHECKMETAFILE = GetProcAddress( hLib, "CHECKMETAFILE" );

    LoadString(hInstanceWin, STR_SYSERR,   szSysError, 20);
    LoadString(hInstanceWin, STR_DIVBYZERO,szDivZero,  50);

    dprintf(3,"Initialisation complete");

    return TRUE;
}

/***************************************************************************

    debugging support

***************************************************************************/


#ifdef DEBUG

void cdecl dDbgOut(int iLevel, LPSTR lpszFormat, ...)
{
    char buf[256];
    int iLogLevel;
    char far *lpcLogLevel;

    // Get the external logging level from the emulated ROM

    iLogLevel = 0;
    (LONG)lpcLogLevel = 0x00400042;
    if (*lpcLogLevel >= '0' && *lpcLogLevel <= '9')
    iLogLevel = (*lpcLogLevel-'0')*10+(*(lpcLogLevel+1)-'0');

    if (iLevel==iLogLevel && (iLogLevel&1) || iLevel<=iLogLevel && !(iLogLevel&1)) {
        OutputDebugString("    W16USER:");
    wvsprintf(buf, lpszFormat, (LPSTR)(&lpszFormat + 1));
    OutputDebugString(buf);
    OutputDebugString("\r\n");
    }
}

void cdecl dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dDbgOut(0, "Assertion FAILED in file %s, line %d: %s\n",
        (LPSTR)file, line, (LPSTR)exp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\ks386p.inc ===
; extracted from sdk\inc\ks386.inc
;
; Yes I know this is not the right thing to do, but the 16bit
; masm runs "out of memory" while assembling (for cairo builds
; it runs out of memory in ks386.inc itself, so splitting our
; source file wouldn't do the trick).
;
;                                               - nanduri


;
;   Defines for user shared data
;
MM_SHARED_USER_DATA_VA equ 07FFE0000H
UsTickCountLow equ 00H
UsTickCountMultiplier equ 04H


;
;  Gdt Descriptor Offset Definitions
;

KGDT_R3_DATA equ 020H
KGDT_R3_TEB equ 038H

;
;  constants for system irql and IDT vector conversion
;
RPL_MASK equ 03H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\listing.inc ===
; for wow.asm
.286p
.model SMALL
.386p


ifndef WOWRTL

EXTRN   GetAppCompatFlags:FAR
PUBLIC   _GetAppCompatFlags@4
_TEXT   SEGMENT
_GetAppCompatFlags@4 PROC FAR                           ; COMDAT
        push   0
        call  GetAppCompatFlags
        movzx eax, ax
        shl   edx, 16
        or    eax, edx
        ret   4
_GetAppCompatFlags@4 ENDP
_TEXT   ENDS

else

_TEXT   SEGMENT
EXTRN   _GetAppCompatFlags@4:FAR
_TEXT   ENDS

endif

_TEXT   SEGMENT
EXTRN _wow16gpsi:NEAR
EXTRN _wow16CsrFlag:NEAR
EXTRN _wow16gHighestUserAddress:NEAR
_TEXT   ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\layer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

include layer.inc

LAYER_INCLUDE=1 	; to suppress including most of the stuff in user.inc
include user.inc
;include usermenu.inc

.list


_GPFIX SEGMENT WORD PUBLIC 'CODE'
_GPFIX ENDS


LAYER_START

include user.api

LAYER_END

; Force menu validation subroutines to get generated in the TEXT
; segment for the message validation layer...
;
genVHMENUtext   = 1

LAYER_EXPAND	TEXT

;
; WOW USER has only one segment
;

; We (NT WOW) do not need these.
;

;LAYER_EXPAND	TEXTMOVE
;LAYER_EXPAND	WINCRTDST
;LAYER_EXPAND	WINUTIL
;LAYER_EXPAND	LANG
;LAYER_EXPAND	RUNAPP
;LAYER_EXPAND	SWITCH
;LAYER_EXPAND	WMGR
;LAYER_EXPAND	WINSWP
;LAYER_EXPAND	DLGBEGIN
;LAYER_EXPAND	DLGCORE
;LAYER_EXPAND	CLPBRD
;LAYER_EXPAND	MENUAPI
;LAYER_EXPAND	MENUCORE
;LAYER_EXPAND	MDKEY
;LAYER_EXPAND	RESOURCE
;LAYER_EXPAND	LBOXDIR
;LAYER_EXPAND	RARE
;LAYER_EXPAND	ICON
;LAYER_EXPAND	SCRLBAR
;LAYER_EXPAND	MDIWIN
;LAYER_EXPAND	WMGR2
;LAYER_EXPAND	SPRINTF
;LAYER_EXPAND	COMDEV
;LAYER_EXPAND	NET

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\msutil.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  MSUTIL.C
 *  WOW16 misc. routines
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
 *  At this time, all we want is GetCharDimensions(), which the edit
 *  controls use.
--*/

/****************************************************************************/
/*									    */
/*  MSUTIL.C -								    */
/*									    */
/*	Miscellaneous Messaging Routines				    */
/*									    */
/****************************************************************************/

#include "user.h"

#ifndef WOW
#include "winmgr.h"


/*--------------------------------------------------------------------------*/
/*									    */
/*  CancelMode() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

void FAR PASCAL CancelMode(hwnd)

register HWND hwnd;

{
  if (hwnd != NULL)
    {
      if (hwnd != hwndCapture)
	  CancelMode(hwndCapture);
      SendMessage(hwnd, WM_CANCELMODE, 0, 0L);
    }
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  BcastCopyString() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Copy strings which are going to be Broadcast into USER's DS to prevent
 * EMS problems when switching tasks.
 */

HANDLE FAR PASCAL BcastCopyString(lParam)

LONG lParam;

{
  LPSTR		  ptrbuf;
  register int	  len;
  register HANDLE hMem;

  len = lstrlen((LPSTR)lParam) + 1;

  if ((hMem = GlobalAlloc(GMEM_FIXED | GMEM_LOWER, (LONG)len)) == NULL)
      return(NULL);

  /* Get the address of the allocated block. */
  ptrbuf = GlobalLock(hMem);
  LCopyStruct((LPSTR)lParam, ptrbuf, len);

  return(hMem);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SendSizeMessages() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void FAR PASCAL SendSizeMessage(hwnd, cmdSize)

register HWND hwnd;
WORD          cmdSize;

{
  DWORD lParam;

  lParam = MAKELONG(hwnd->rcClient.right - hwnd->rcClient.left,
                                  hwnd->rcClient.bottom - hwnd->rcClient.top);
  SendMessage(hwnd, WM_SIZE, cmdSize, lParam);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  AdjustWindowRect() -						    */
/*									    */
/*--------------------------------------------------------------------------*/

void USERENTRY AdjustWindowRect(lprc, style, fMenu)

LPRECT lprc;
LONG   style;
BOOL   fMenu;

{
    AdjustWindowRectEx(lprc, style, fMenu, (DWORD)0);
}

/*--------------------------------------------------------------------------*/
/*									    */
/*  AdjustWindowRectEx() -						    */
/*									    */
/*--------------------------------------------------------------------------*/

void USERENTRY AdjustWindowRectEx(lprc, style, fMenu, dwExStyle)

LPRECT lprc;
LONG   style;
BOOL   fMenu;
DWORD  dwExStyle;

{
  register int cx;
  register int cy;

  cx = cxBorder;
  cy = cyBorder;

  if (fMenu)
      lprc->top -= rgwSysMet[SM_CYMENU];

  /* Let us first decide if it is no-border, single border or dlg border */
  
  /* Check if the WS_EX_DLGMODALFRAME bit is set, if so Dlg border */
  if(dwExStyle & WS_EX_DLGMODALFRAME)
  {
	cx *= (CLDLGFRAME + 2*CLDLGFRAMEWHITE + 1);
	cy *= (CLDLGFRAME + 2*CLDLGFRAMEWHITE + 1);
  }
  else
  {
    /* C6.0 will not generate jump table for this switch because of the
     * range of values tested in case statemts;
     */
    switch (HIWORD(style) & HIWORD(WS_CAPTION))
    {
      case HIWORD(WS_CAPTION):
      case HIWORD(WS_BORDER):
	  break;	/* Single border */

      case HIWORD(WS_DLGFRAME):
	  cx *= (CLDLGFRAME + 2*CLDLGFRAMEWHITE + 1);
	  cy *= (CLDLGFRAME + 2*CLDLGFRAMEWHITE + 1);
	  break;	/* Dlg Border */

      default:		/* case 0 */
	  cx = 0;	/* No border */
	  cy = 0;
	  break;
    }
  }


  if((HIWORD(style) & HIWORD(WS_CAPTION)) == HIWORD(WS_CAPTION))
      lprc->top -= (cyCaption - cyBorder);
	
  if(cx || cy)
	InflateRect(lprc, cx, cy);

  /* Shouldn't we check if it has DLG frame and if so skip the following ?? */
  if (style & WS_SIZEBOX)
      InflateRect(lprc, cxSzBorder, cySzBorder);
}
#endif	// WOW

/*----------------------------------------------------------------------*/
/*									*/
/*    GetCharDimensions(hDC, lpTextMetrics)				*/
/*									*/
/*	This function loads the Textmetrics of the font currently	*/
/*    selected into the hDC and returns the Average char width of the   */
/*    font; Pl Note that the AveCharWidth value returned by the Text    */
/*    metrics call is wrong for proportional fonts. So, we compute them */
/*	On return, lpTextMetrics contains the text metrics of the 	*/
/*	currently selected font.					*/
/*									*/
/*----------------------------------------------------------------------*/

int  FAR  PASCAL  GetCharDimensions(HDC hDC, LPTEXTMETRIC lpTextMetrics)
{
  int  cxWidth;
  int  i;
  char AveCharWidthData[52];

  /* Store the System Font metrics info. */
  GetTextMetrics(hDC, lpTextMetrics);

  if (!(lpTextMetrics -> tmPitchAndFamily & 1)) /* If !variable_width font */
      cxWidth = lpTextMetrics -> tmAveCharWidth;
  else
    {
      /* Change from tmAveCharWidth.  We will calculate a true average as
         opposed to the one returned by tmAveCharWidth. This works better 
         when dealing with proportional spaced fonts. */

      for (i=0;i<=25;i++)
           AveCharWidthData[i] = (char)(i+(int)'a');
      for (i=0;i<=25;i++)
           AveCharWidthData[i+26] = (char)(i+(int)'A');
      cxWidth = LOWORD(GetTextExtent(hDC,AveCharWidthData,52)) / 26;

      cxWidth = (cxWidth + 1) / 2;	// round up

#if 0
      {
      char buf[80];
      wsprintf(buf, "cxWidth = %d tmAveCharWidth %d\r\n", cxWidth, lpTextMetrics -> tmAveCharWidth);
      OutputDebugString(buf);
      }
#endif

    }

  return(cxWidth);
}

#ifndef WOW
/*----------------------------------------------------------------------*/
/*									*/
/*    GetAveCharWidth(hDC)						*/
/*									*/
/*	This function loads the Textmetrics of the font currently	*/
/*    selected into the hDC and returns the Average char width of the   */
/*    font; Pl Note that the AveCharWidth value returned by the Text    */
/*    metrics call is wrong for proportional fonts. So, we compute them */
/*	On return, lpTextMetrics contains the text metrics of the 	*/
/*	currently selected font.					*/
/*									*/
/*----------------------------------------------------------------------*/

int  FAR  PASCAL  GetAveCharWidth(hDC)

HDC  hDC;

{
  TEXTMETRIC   TextMetric;

  return(GetCharDimensions(hDC, &TextMetric));
}

/*--------------------------------------------------------------------------*/
/*									    */
/*  MB_FindLongestString() -						    */
/*									    */
/*--------------------------------------------------------------------------*/

WORD  FAR  PASCAL MB_FindLongestString()

{
    int	   i;
    int    iMaxLen = 0;
    int    iNewMaxLen;
    PSTR   *pszCurStr;
    PSTR   szMaxStr;
    HDC	   hdc;
    WORD   wRetVal;

    hdc = (HDC)GetScreenDC();

    for(i = 0, pszCurStr = AllMBbtnStrings; i < MAX_SEB_STYLES; i++, pszCurStr++)
    {
	if((iNewMaxLen = lstrlen((LPSTR)*pszCurStr)) > iMaxLen)
	{
	   iMaxLen = iNewMaxLen;
	   szMaxStr = *pszCurStr;
	}
    }

    /* Find the longest string */
    
    wRetVal = ((WORD)PSMGetTextExtent(hdc, (LPSTR)szMaxStr, lstrlen((LPSTR)szMaxStr))
	   + ((int)PSGetTextExtent(hdc, (LPSTR)szOneChar, 1) << 1));

    InternalReleaseDC(hdc);

    return(wRetVal);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  InitPwSB() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

int * FAR PASCAL InitPwSB(hwnd)

register HWND hwnd;

{
  register int *pw;

  if (hwnd->rgwScroll)
      /* If memory is already allocated, don't bother to do it again. 
       */
      return(hwnd->rgwScroll);

  if ((hwnd->rgwScroll = pw = (int *)UserLocalAlloc(ST_WND, LPTR, 7 * sizeof(int))) != NULL)
    {
      /*  rgw[0] = 0;  */  /* LPTR zeros all 6 words */
      /*  rgw[1] = 0;  */
      /*  rgw[3] = 0;  */
      /*  rgw[4] = 0;  */
      /*  rgw[6] = 0;  Enable/Disable Flags */
      pw[2] = pw[5] = 100;
    }

  return(pw);
}

#endif	// WOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\msglayer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

include layer.inc

LAYER_INCLUDE=1 	; to suppress including most of the stuff in user.inc
include user.inc

.list
.xall

include msglayer.inc

MESSAGE_START	TEXT

include messages.api

MESSAGE_END

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\netdlg.h ===
/* netdlg.h -
 *
 * constants for network dialogs
 */

#ifdef RC_INVOKED
#define IDD_CONNECTPROGRESS	100
#define IDD_PASSWORD		101
#else
#define IDD_CONNECTPROGRESS	((LPSTR)100L)
#define IDD_PASSWORD		((LPSTR)101L)
#endif

#define IDD_DEV 		100
#define IDD_PASS		101
#define IDD_PATH		102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\msglayer.inc ===
;==========================================================================
;
; Message validation layer include file
;
;- Where applicable, i've specified a class id. as a param. to the MESSAGE
;  macro. For others (WM_ messages), i've specified the ID "COMMON".
;
;- For messages meaningful only to controls having a particular style, i've
;  added an option to the MESSAGE macro:
;
;  <MLCONLY>	     for messages applicable to ES_MULTILINE edit controls
;  <OWNERDRAWVARONLY> "     "	      "       " LBS_OWNERDRAWVARIABLE listboxes
;  <MULTISELONLY>     "     "	      "       " LBS_MULTIPLESEL listboxes
;  <MULTICOLONLY>     "     "	      "       " LBS_MULTICOLUMN listboxes
;
;
; Generic message IDs
;
WM_NULL 	    equ 0000h
WM_CREATE	    equ 0001h
WM_DESTROY	    equ 0002h
WM_MOVE 	    equ 0003h
WM_SIZEWAIT	    equ 0004h		   ;Internal
WM_SIZE 	    equ 0005h
WM_ACTIVATE	    equ 0006h
WM_SETFOCUS	    equ 0007h
WM_KILLFOCUS	    equ 0008h
WM_SETVISIBLE	    equ 0009h		   ;Internal
WM_ENABLE	    equ 000Ah
WM_SETREDRAW	    equ 000Bh
WM_SETTEXT	    equ 000Ch
WM_GETTEXT	    equ 000Dh
WM_GETTEXTLENGTH    equ 000Eh
WM_PAINT	    equ 000Fh
WM_CLOSE	    equ 0010h
WM_QUERYENDSESSION  equ 0011h
WM_QUIT 	    equ 0012h
WM_QUERYOPEN	    equ 0013h
WM_ERASEBKGND	    equ 0014h
WM_SYSCOLORCHANGE   equ 0015h
WM_ENDSESSION	    equ 0016h
WM_SYSTEMERROR	    equ 0017h		   ;Internal
WM_SHOWWINDOW	    equ 0018h
WM_CTLCOLOR	    equ 0019h
WM_WININICHANGE     equ 001Ah
WM_DEVMODECHANGE    equ 001Bh
WM_ACTIVATEAPP	    equ 001Ch
WM_FONTCHANGE	    equ 001Dh
WM_TIMECHANGE	    equ 001Eh
WM_CANCELMODE	    equ 001Fh
WM_SETCURSOR	    equ 0020h
WM_MOUSEACTIVATE    equ 0021h
WM_CHILDACTIVATE    equ 0022h
WM_QUEUESYNC	    equ 0023h
WM_GETMINMAXINFO    equ 0024h
WM_PAINTICON	    equ 0026h
WM_ICONERASEBKGND   equ 0027h
WM_NEXTDLGCTL	    equ 0028h
WM_ALTTABACTIVE     equ 0029h		   ;Internal
WM_SPOOLERSTATUS    equ 002Ah
WM_DRAWITEM	    equ 002Bh
WM_MEASUREITEM	    equ 002Ch
WM_DELETEITEM	    equ 002Dh
WM_VKEYTOITEM	    equ 002Eh
WM_CHARTOITEM	    equ 002Fh
WM_SETFONT	    equ 0030h
WM_GETFONT	    equ 0031h
WM_SETHOTKEY	    equ 0032h
WM_GETHOTKEY	    equ 0033h
WM_FILESYSCHANGE    equ 0034h		   ;Internal
WM_ISACTIVEICON     equ 0035h		   ;Internal
;WM_UNUSED0036      equ 0036h		   ;Internal
WM_QUERYDRAGICON    equ 0037h
WM_COMPAREITEM	    equ 0039h
WM_TESTING	    equ 0040h		   ;Internal
WM_COMPACTING	    equ 0041h
;WM_UNUSED          equ 0042h
;WM_UNUSED          equ 0043h
WM_COMMNOTIFY		equ 0044h
;WM_UNUSED		equ 0045h
WM_WINDOWPOSCHANGING	equ 0046h
WM_WINDOWPOSCHANGED	equ 0047h
WM_POWER		equ 0048h
WM_NCCREATE	    equ 0081h
WM_NCDESTROY	    equ 0082h
WM_NCCALCSIZE	    equ 0083h
WM_NCHITTEST	    equ 0084h
WM_NCPAINT	    equ 0085h
WM_NCACTIVATE	    equ 0086h
WM_GETDLGCODE	    equ 0087h
WM_SYNCPAINT	    equ 0088h		   ;Internal
WM_SYNCTASK	    equ 0089h		   ;Internal
WM_NCMOUSEMOVE	    equ 00A0h
WM_NCLBUTTONDOWN    equ 00A1h
WM_NCLBUTTONUP	    equ 00A2h
WM_NCLBUTTONDBLCLK  equ 00A3h
WM_NCRBUTTONDOWN    equ 00A4h
WM_NCRBUTTONUP	    equ 00A5h
WM_NCRBUTTONDBLCLK  equ 00A6h
WM_NCMBUTTONDOWN    equ 00A7h
WM_NCMBUTTONUP	    equ 00A8h
WM_NCMBUTTONDBLCLK  equ 00A9h
WM_KEYFIRST	    equ 0100h
WM_KEYDOWN	    equ 0100h
WM_KEYUP	    equ 0101h
WM_CHAR 	    equ 0102h
WM_DEADCHAR	    equ 0103h
WM_SYSKEYDOWN	    equ 0104h
WM_SYSKEYUP	    equ 0105h
WM_SYSCHAR	    equ 0106h
WM_SYSDEADCHAR	    equ 0107h
WM_YOMICHAR	    equ 0108h		   ;Internal
WM_KEYLAST	    equ 0108h
WM_CONVERTREQUEST   equ 010Ah		   ;Internal
WM_CONVERTRESULT    equ 010Bh		   ;Internal
WM_INITDIALOG	    equ 0110h
WM_COMMAND	    equ 0111h
WM_SYSCOMMAND	    equ 0112h
WM_TIMER	    equ 0113h
WM_HSCROLL	    equ 0114h
WM_VSCROLL	    equ 0115h
WM_INITMENU	    equ 0116h
WM_INITMENUPOPUP    equ 0117h
WM_SYSTIMER	    equ 0118h		   ;Internal
WM_MENUSELECT	    equ 011Fh
WM_MENUCHAR	    equ 0120h
WM_ENTERIDLE	    equ 0121h
WM_LBTRACKPOINT     equ 0131h		   ;Internal
WM_MOUSEFIRST	    equ 0200h
WM_MOUSEMOVE	    equ 0200h
WM_LBUTTONDOWN	    equ 0201h
WM_LBUTTONUP	    equ 0202h
WM_LBUTTONDBLCLK    equ 0203h
WM_RBUTTONDOWN	    equ 0204h
WM_RBUTTONUP	    equ 0205h
WM_RBUTTONDBLCLK    equ 0206h
WM_MBUTTONDOWN	    equ 0207h
WM_MBUTTONUP	    equ 0208h
WM_MBUTTONDBLCLK    equ 0209h
WM_MOUSELAST	    equ 0209h
WM_PARENTNOTIFY     equ 0210h
WM_ENTERMENULOOP    equ 0211h		   ;Internal
WM_EXITMENULOOP     equ 0212h		   ;Internal
WM_NEXTMENU	    equ 0213h		   ;Internal
WM_MDICREATE	    equ 0220h
WM_MDIDESTROY	    equ 0221h
WM_MDIACTIVATE	    equ 0222h
WM_MDIRESTORE	    equ 0223h
WM_MDINEXT	    equ 0224h
WM_MDIMAXIMIZE	    equ 0225h
WM_MDITILE	    equ 0226h
WM_MDICASCADE	    equ 0227h
WM_MDIICONARRANGE   equ 0228h
WM_MDIGETACTIVE     equ 0229h
WM_DROPOBJECT	    equ 022Ah		   ;Internal
WM_QUERYDROPOBJECT  equ 022Bh		   ;Internal
WM_BEGINDRAG	    equ 022Ch		   ;Internal
WM_DRAGLOOP	    equ 022Dh		   ;Internal
WM_DRAGSELECT	    equ 022Eh		   ;Internal
WM_DRAGMOVE	    equ 022Fh		   ;Internal
WM_MDISETMENU	    equ 0230h
WM_ENTERSIZEMOVE    equ 0231h		   ;Internal
WM_EXITSIZEMOVE     equ 0232h		   ;Internal
WM_DROPFILES	    equ 0233h
WM_KANJIFIRST	    equ 0280h		   ;Internal
WM_KANJILAST	    equ 029Fh		   ;Internal
WM_CUT		    equ 0300h
WM_COPY 	    equ 0301h
WM_PASTE	    equ 0302h
WM_CLEAR	    equ 0303h
WM_UNDO 	    equ 0304h
WM_RENDERFORMAT     equ 0305h
WM_RENDERALLFORMATS equ 0306h
WM_DESTROYCLIPBOARD equ 0307h
WM_DRAWCLIPBOARD    equ 0308h
WM_PAINTCLIPBOARD   equ 0309h
WM_VSCROLLCLIPBOARD equ 030Ah
WM_SIZECLIPBOARD    equ 030Bh
WM_ASKCBFORMATNAME  equ 030Ch
WM_CHANGECBCHAIN    equ 030Dh
WM_HSCROLLCLIPBOARD equ 030Eh
WM_QUERYNEWPALETTE  equ 030Fh
WM_PALETTEGONNACHANGE equ 0310h 	   ;Internal
WM_PALETTEISCHANGING equ 0310h
WM_CHANGEPALETTE    equ 0311h		   ;Internal
WM_PALETTECHANGED   equ 0311h
WM_PENWINFIRST	    equ 0380h
WM_PENWINLAST	    equ 038Fh
WM_INTERNAL_COALESCE_FIRST  equ 0390h	   ;Internal
WM_COALESCE_FIRST   equ 0390h
WM_COALESCE_LAST    equ 039Fh
WM_MM_RESERVED_FIRST equ 03A0h		   ;Internal
WM_MM_RESERVED_LAST  equ 03DFh		   ;Internal
WM_INTERNAL_COALESCE_LAST  equ (WM_MM_RESERVED_FIRST+16) ;Internal
WM_INTERNAL_DDE_FIRST equ 03E0h 	   ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh 	   ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h 	   ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh 	   ;Internal
WM_USER 	    equ 0400h

; Edit control messages

EM_GETSEL              equ (WM_USER+0)
EM_SETSEL              equ (WM_USER+1)
EM_GETRECT             equ (WM_USER+2)
EM_SETRECT             equ (WM_USER+3)
EM_SETRECTNP           equ (WM_USER+4)
EM_SCROLL              equ (WM_USER+5)
EM_LINESCROLL          equ (WM_USER+6)
EM_GETMODIFY           equ (WM_USER+8)
EM_SETMODIFY           equ (WM_USER+9)
EM_GETLINECOUNT        equ (WM_USER+10)
EM_LINEINDEX           equ (WM_USER+11)
EM_SETHANDLE           equ (WM_USER+12)
EM_GETHANDLE           equ (WM_USER+13)
EM_GETTHUMB            equ (WM_USER+14)
EM_LINELENGTH          equ (WM_USER+17)
EM_REPLACESEL          equ (WM_USER+18)
EM_SETFONT             equ (WM_USER+19)
EM_GETLINE             equ (WM_USER+20)
EM_LIMITTEXT           equ (WM_USER+21)
EM_CANUNDO             equ (WM_USER+22)
EM_UNDO                equ (WM_USER+23)
EM_FMTLINES            equ (WM_USER+24)
EM_LINEFROMCHAR        equ (WM_USER+25)
EM_SETWORDBREAK        equ (WM_USER+26)
EM_SETTABSTOPS         equ (WM_USER+27)
EM_SETPASSWORDCHAR     equ (WM_USER+28)
EM_EMPTYUNDOBUFFER     equ (WM_USER+29)
EM_GETFIRSTVISIBLELINE equ (WM_USER+30)
EM_SETREADONLY         equ (WM_USER+31)
EM_SETWORDBREAKPROC    equ (WM_USER+32)
EM_GETWORDBREAKPROC    equ (WM_USER+33)
EM_GETPASSWORDCHAR     equ (WM_USER+34)
EM_MSGMAX              equ (WM_USER+35)

; Button control messages

BM_GETCHECK	   equ (WM_USER+0)
BM_SETCHECK	   equ (WM_USER+1)
BM_GETSTATE	   equ (WM_USER+2)
BM_SETSTATE	   equ (WM_USER+3)
BM_SETSTYLE	   equ (WM_USER+4)

; Static control messages

STM_SETICON	   equ (WM_USER+0)
STM_GETICON	   equ (WM_USER+1)
STM_MSGMAX	   equ (WM_USER+2)

; Dialog box messages

DM_GETDEFID	    equ (WM_USER+0)
DM_SETDEFID	    equ (WM_USER+1)

; Listbox messages

LB_ADDSTRING	       equ (WM_USER+1)
LB_INSERTSTRING        equ (WM_USER+2)
LB_DELETESTRING        equ (WM_USER+3)
LB_RESETCONTENT        equ (WM_USER+5)
LB_SETSEL	       equ (WM_USER+6)
LB_SETCURSEL	       equ (WM_USER+7)
LB_GETSEL	       equ (WM_USER+8)
LB_GETCURSEL	       equ (WM_USER+9)
LB_GETTEXT	       equ (WM_USER+10)
LB_GETTEXTLEN	       equ (WM_USER+11)
LB_GETCOUNT	       equ (WM_USER+12)
LB_SELECTSTRING        equ (WM_USER+13)
LB_DIR		       equ (WM_USER+14)
LB_GETTOPINDEX	       equ (WM_USER+15)
LB_FINDSTRING	       equ (WM_USER+16)
LB_GETSELCOUNT	       equ (WM_USER+17)
LB_GETSELITEMS	       equ (WM_USER+18)
LB_SETTABSTOPS	       equ (WM_USER+19)
LB_GETHORIZONTALEXTENT equ (WM_USER+20)
LB_SETHORIZONTALEXTENT equ (WM_USER+21)
LB_SETCOLUMNWIDTH      equ (WM_USER+22)
LB_ADDFILE	       equ (WM_USER+23)     ;Internal
LB_SETTOPINDEX	       equ (WM_USER+24)
LB_GETITEMRECT	       equ (WM_USER+25)
LB_GETITEMDATA	       equ (WM_USER+26)
LB_SETITEMDATA	       equ (WM_USER+27)
LB_SELITEMRANGE        equ (WM_USER+28)
LB_SETANCHORINDEX      equ (WM_USER+29)     ;Internal
LB_GETANCHORINDEX      equ (WM_USER+30)     ;Internal
LB_SETCARETINDEX       equ (WM_USER+31)
LB_GETCARETINDEX       equ (WM_USER+32)
LB_SETITEMHEIGHT       equ (WM_USER+33)
LB_GETITEMHEIGHT       equ (WM_USER+34)
LB_FINDSTRINGEXACT     equ (WM_USER+35)
LBCB_CARETON           equ (WM_USER+36)     ;Internal
LBCB_CARETOFF          equ (WM_USER+37)     ;Internal
LB_MSGMAX	       equ (WM_USER+38)

; Combo box messages

CB_GETEDITSEL		 equ (WM_USER+0)
CB_LIMITTEXT		 equ (WM_USER+1)
CB_SETEDITSEL		 equ (WM_USER+2)
CB_ADDSTRING		 equ (WM_USER+3)
CB_DELETESTRING 	 equ (WM_USER+4)
CB_DIR			 equ (WM_USER+5)
CB_GETCOUNT		 equ (WM_USER+6)
CB_GETCURSEL		 equ (WM_USER+7)
CB_GETLBTEXT		 equ (WM_USER+8)
CB_GETLBTEXTLEN 	 equ (WM_USER+9)
CB_INSERTSTRING 	 equ (WM_USER+10)
CB_RESETCONTENT 	 equ (WM_USER+11)
CB_FINDSTRING		 equ (WM_USER+12)
CB_SELECTSTRING 	 equ (WM_USER+13)
CB_SETCURSEL		 equ (WM_USER+14)
CB_SHOWDROPDOWN 	 equ (WM_USER+15)
CB_GETITEMDATA		 equ (WM_USER+16)
CB_SETITEMDATA		 equ (WM_USER+17)
CB_GETDROPPEDCONTROLRECT equ (WM_USER+18)
CB_SETITEMHEIGHT	 equ (WM_USER+19)
CB_GETITEMHEIGHT	 equ (WM_USER+20)
CB_SETEXTENDEDUI	 equ (WM_USER+21)
CB_GETEXTENDEDUI	 equ (WM_USER+22)
CB_GETDROPPEDSTATE	 equ (WM_USER+23)
CB_FINDSTRINGEXACT       equ (WM_USER+24)
CB_MSGMAX		 equ (WM_USER+25)

; DDE messages

WM_DDE_FIRST	    equ 03E0h
WM_DDE_INITIATE     equ (WM_DDE_FIRST)
WM_DDE_TERMINATE    equ (WM_DDE_FIRST+1)
WM_DDE_ADVISE	    equ (WM_DDE_FIRST+2)
WM_DDE_UNADVISE     equ (WM_DDE_FIRST+3)
WM_DDE_ACK	    equ (WM_DDE_FIRST+4)
WM_DDE_DATA	    equ (WM_DDE_FIRST+5)
WM_DDE_REQUEST	    equ (WM_DDE_FIRST+6)
WM_DDE_POKE	    equ (WM_DDE_FIRST+7)
WM_DDE_EXECUTE	    equ (WM_DDE_FIRST+8)
WM_DDE_LAST	    equ (WM_DDE_FIRST+8)

;==================================================

VLmopen = 0
VLmpoff = 0
VLmname equ <>
VLmcont equ <>


DGROUP	group	_DATA
sBegin	DATA
assume	ds:_DATA
;extrn	atomSysClass:word
sEnd	DATA

ExternFP    IsMenu
IFNDEF	WOW
    ExternFP	IsGDIObject
ENDIF
ExternFP    IsWindow


MESSAGE_START	macro	    seg
    _SwitchSeg	<seg>,%VLseg

IFNDEF	WOW
    ExternNP	VHWND&seg
    ExternNP	VHWND0&seg
    ExternNP	VHMENU&seg
    ExternNP	VHMENU0&seg
    ExternNP	GHANDLE&seg
    ExternNP	GHANDLE0&seg
ENDIF

ExternNP    LP&seg
ExternNP    LP0&seg
ExternNP    CLP&seg
ExternNP    CLP0&seg
ExternNP    LPFN&seg
ExternNP    LPFN0&seg
ExternNP    CLPSZ&seg
ExternNP    CLPSZ0&seg
ExternNP    Inval_Param_&seg

hwnd	equ <[bp].0eh>
msg	equ <[bp].0ch>
wParam	equ <[bp].0ah>
lParam	equ <dword ptr [bp]+06h>

;cProc	 ValidateMessage,<FAR, PUBLIC>
;ParmW	 hwnd
;ParmW	 msg
;ParmW	 wParam
;ParmD	 lParam
;cBegin
public	ValidateMessage
ValidateMessage proc far

	push	bp
	mov	bp,sp

	push	offset VM_ERROR     ; push error handler address

	IFNDEF	WOW
	    mov	 bx,hwnd	     ; validate the window handle
	    lcall	VHWND
	ENDIF

	mov	ax,msg
	cmp	ax,WM_USER
	jb	VM_COMMON

	jmp	SHORT VM_VALID	    ;

	IFNDEF	WOW
	    mov	bx,_DATA
	    mov	es,bx
	    assume	es:_DATA
	    mov	bx,hwnd 	    ; ax = hwnd->pcls->atomClassName
	    mov	bx,es:[bx].wndPcls
	    mov	ax,es:[bx].uclsAtomClassName

	    mov	cx,ICLS_CTL_MAX     ; look up the class name
	    push	di		    ; in the atomSysClass array
	    mov	di,offset DGROUP:atomSysClass+(ICLS_CTL_MAX-1)*2
	    std
	    repnz	scasw
	    pop	di
	    cld
	    jnz	VM_VALID	    ; Not special window class: just return.
	    mov	bx,cx		    ; cx has ICLS index
	    add	bx,bx
	    mov	ax,msg
	    jmp	word ptr cs:vmjump[bx]

	ENDIF

VM_VALID:
	mov	ax,1		    ; return TRUE
VM_EXIT:
	pop	dx		    ; strip off error handler address
assume	es:NOTHING

	pop	bp

VM_ERROR:
	retf	2+2+2+4 	    ; error handler jmps here, with clean stack

ValidateMessage endp
;
; NOTE: The order of the following jump table is dependent
; on the order of the ICLS_* values defined in user.h
;

IFNDEF	WOW
vmjump:
	dw	VM_BUTTON
	errnz	<ICLS_BUTTON-0>

	dw	VM_EDIT
	errnz	<ICLS_EDIT-1>

	dw	VM_STATIC
	errnz	<ICLS_STATIC-2>

	dw	VM_LISTBOX
	errnz	<ICLS_LISTBOX-3>

	dw	VM_VALID	 ; No scrollbar messages
	errnz	<ICLS_SCROLLBAR-4>

	dw	VM_COMBOBOX
	errnz	<ICLS_COMBOBOX-5>

ENDIF

endm	; MESSAGE_START

MESSAGE_END	macro
    if VLmopen
	ENDMESSAGE
    endif
    sEnd    %VLseg
endm

;
; MESSAGE - begins a structure declaration
;
MESSAGE macro	name,opts

  if VLmopen
	ENDMESSAGE
  endif

  VLmopen=1
  VLmpoff = 4
  VLmjmp = 0

  _MOpts  <opts>

concat	VLmcont,<VLm>,name
concat	VLmname,name
VLcbstruct  =	0
endm

_MOpts	macro	opts
  VLnogen = 0
  VLnogenparm = 0
  irp	opt,<opts>
    ifidni  <opt>,<NOGEN>
      VLnogen = 1
    endif
    ifidni  <opt>,<DEBUGONLY>
      ifndef DEBUG
	VLnogen = 1
      endif
    endif
    ifidni  <opt>,<POSTED>
    endif
    ifidni  <opt>,<INTERNAL>
    endif
  endm
  VLgen = 0

endm
;
; ENDMESSAGE - Terminates a message declaration
;
ENDMESSAGE  macro
VLmopen = 0
  ife VLmjmp
    ;_print  <Nothing to validate for >,%VLmname
  else
    jmp VM_VALID
  endif
  irp label,<VLmcont>
label:
  endm
endm

;
; MESSAGE_CLASS - Announce
;
MESSAGE_CLASS	macro cls
VM_&cls:
endm

MESSAGE_CLASS_END   macro
  if VLmopen
    ENDMESSAGE
  endif

    jmp     VM_VALID
endm

_FlsMJmp2   macro   name
public PV_&name
PV_&name:
endm

_FlsMJmp    macro
ife VLmjmp
    _FlsMJmp2	%VLmname
    cmp     ax,VLmname
    jnz     VLmcont
    VLmjmp = 1
endif
endm

;
; Increment mpOff: 4 -> 0 -> 2
;
_IncMpOff   macro   size

ife VLmpoff-99
    _print  <Too many message parameters>
    errnz   1
else
 ife size-2

   ife VLmpoff-4
       VLmpoff = 0
   else
    ife VLmpoff-0
	VLmpoff = 2
    else
	VLmpoff = 99
    endif
   endif

 else

   ife VLmpoff-4
       _print  <First message parameter must be 16 bits>
       errnz 1
   else
    ife VLmpoff-0
       VLmpoff = 99
    else
       _print <Too many message parameters>
       errnz  1
    endif
   endif

 endif
endif

endm

;
;
;
_GenMP	macro	name,size,opts

    VLnogenparm = 0

    irp opt,<opts>
     ifidni opt,<NOGEN>
	VLnogenparm = 1
     endif
     ifidni opt,<DEBUGONLY>
      ifndef DEBUG
	VLnogenparm = 1
      endif
     endif
    endm

    VLgen = 1
    if VLnogenparm or VLnogen
	VLgen = 0
    endif

concat	_P_&name,<[bp]+2+4+>,%VLmpoff

_IncMpOff   size
endm

;
; Message parameter macros
;
MP_2	macro	name,opts
_GenMP	<name>,2,<opts>
endm

MP_4	macro	name,opts
_GenMP	<name>,4,<opts>
endm

MP_WMBZ macro	name,opts
_GenMP	<name>,2,<opts>
if VLgen
ifdef DEBUG
    _FlsMJmp
    mov     ax,_P_&name
    or	    ax,ax
    jz	    @F
    mov     bx,ERR_BAD_VALUE or ERR_WARNING
    lcall   Inval_Param_
@@:
endif
endif
endm

MP_LMBZ macro	name,opts
_GenMP	<name>,4,<opts>
if VLgen
ifdef DEBUG
    _FlsMJmp
    mov     bx,_P_&name
    mov     cx,_P_&name+2
    or	    bx,cx
    jz	    @F
    mov     ax,_P_&name
    mov     bx,ERR_BAD_DVALUE or ERR_WARNING
    lcall   Inval_Param_
@@:
endif	; DEBUG
endif
endm

; Simple types

MP_int	    equ <MP_2>
MP_BOOL     equ <MP_2>
MP_LONG     equ <MP_4>
MP_DWORD    equ <MP_4>
MP_WORD     equ <MP_2>

MP_POINT    equ <MP_4>

MP_RVALUE   macro   val, min, max, opts
    MP_2    <flags>,<opts>
endm

MP_VALUE    macro   val, max, opts
    MP_2    <flags>,<opts>
endm

MP_FLAGS    macro   flags, valid, opts
    MP_2    <flags>,<opts>
endm

; Handles
;
; Generate a GDI object validation macro.
;
; If nullok is 1, allow NULL.
; min & max are the allowed OBJ_* range.
; except, if specified, is an OBJ_* value within the range to reject.
;
_GenMPHGDI    macro   name,nullok,min,max,except
    name &macro   hObj,opts
	local	badobj
	local	objok
	_GenMP	  <hObj>,2,<opts>
	if VLgen
	    _FlsMJmp

	  IFNDEF    WOW

	  if nullok
	    mov     cx,_P_&&hObj
	    jcxz    objok
	    push    cx
	  else
	    push    _P_&&hObj
	  endif
	    call    IsGDIObject
	  ifnb <except>
	    cmp     al,except
	    jz	    badobj
	  endif
	  ife min-max
	    cmp     al,min
	    je	    objok
	  else
	    cmp     al,min
	    jb	    badobj
	    cmp     al,max
	    jbe     objok
	  endif
	badobj:
	    mov     ax,_P_&&hObj
            mov     bx,ERR_BAD_HANDLE
            lcall   Inval_Param_
	objok:

	ENDIF

	endif
    &endm
endm

OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3
OBJ_PALETTE	equ	4
OBJ_BITMAP	equ	5
OBJ_RGN 	equ	6
OBJ_DC		equ	7
OBJ_IC		equ	8
OBJ_DISABLED_DC equ	9
OBJ_METADC	equ	10
OBJ_METAFILE	equ	11

_GenMPHGDI  <MP_HDC>,0,OBJ_DC,OBJ_METAFILE
_GenMPHGDI  <MP_HDC0>,1,OBJ_DC,OBJ_METAFILE

_GenMPHGDI  <MP_HPEN>,0,OBJ_PEN,OBJ_PEN
_GenMPHGDI  <MP_HPEN0>,1,OBJ_PEN,OBJ_PEN

_GenMPHGDI  <MP_HBRUSH>,0,OBJ_BRUSH,OBJ_BRUSH
_GenMPHGDI  <MP_HBRUSH0>,1,OBJ_BRUSH,OBJ_BRUSH

_GenMPHGDI  <MP_HFONT>,0,OBJ_FONT,OBJ_FONT
_GenMPHGDI  <MP_HFONT0>,1,OBJ_FONT,OBJ_FONT

_GenMPHGDI  <MP_HPALETTE>,0,OBJ_PALETTE,OBJ_PALETTE
_GenMPHGDI  <MP_HPALETTE0>,1,OBJ_PALETTE,OBJ_PALETTE

_GenMPHGDI  <MP_HBITMAP>,0,OBJ_BITMAP,OBJ_BITMAP
_GenMPHGDI  <MP_HBITMAP0>,1,OBJ_BITMAP,OBJ_BITMAP

_GenMPHGDI  <MP_HRGN>,0,OBJ_RGN,OBJ_RGN
_GenMPHGDI  <MP_HRGN0>,1,OBJ_RGN,OBJ_RGN

MP_HRGN01   equ <MP_2>	    ; hrgn, NULL, or (HRGN)1

MP_HMENU macro	 hMenu,opts
    _GenMP    <hMenu>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU
	ENDIF
        _gensub VHMENU
    @@:
    endif
endm

MP_HMENU0 macro   hMenu,opts
    _GenMP    <hMenu>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU0
	ENDIF
        _gensub VHMENU
    endif
endm

MP_HWND  macro	 hwnd,opts
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov		 bx,_P_&hwnd
	    lcall	 VHWND
	ENDIF
        _gensub VHWND
    endif
endm

MP_HWND0 macro	 hwnd,opts
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF WOW
	     mov	 bx,_P_&hwnd
	     lcall	 VHWND0
	ENDIF
        _gensub VHWND
    endif
endm

; Warn if the window handle is 0 or a bad window handle

MP_HWNDW macro   hwnd,opts
     Local    ZeroHandle
    _GenMP    <hwnd>,2,<opts>
ifdef DEBUG
    if VLgen
	_FlsMJmp
	mov	cx,_P_&hwnd
	mov	ax, cx		;; Error reporting expects window handle in AX
	jcxz	ZeroHandle

	jmp	@F

	IFNDEF	WOW
	push	cx		;; Save window handle
	push	cx
	call	IsWindow
	or	ax,ax
	pop	ax		;; Resore the window handle to AX
	jnz	@F
	ENDIF

ZeroHandle:
	;; AX must have the bad Window handle
        mov     bx,ERR_BAD_HWND or ERR_WARNING
	lcall	Inval_Param_
    @@:
    endif
endif
endm

; Warning only.

MP_HWNDW0 macro   hwnd,opts
    _GenMP    <hwnd>,2,<opts>
ifdef DEBUG
    if VLgen
	_FlsMJmp

	IFNDEF	WOW
	    mov	cx,_P_&hwnd
	    jcxz	@F
	    push	cx
	    push	cx
	    call	IsWindow
	    or	ax,ax
	    pop	ax
	    jnz	@F
	    mov	 bx,ERR_BAD_HWND or ERR_WARNING
	    lcall	Inval_Param_
	   @@:
	ENDIF

    endif
endif
endm

MP_HWND01 macro   hwnd,opts	 ; hwnd, 0, or 1
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hwnd
	    cmp	 bx,1
	    jbe	@F
	    lcall	 VHWND
	ENDIF
        _gensub VHWND
    @@:
    endif
endm

MP_HWNDCLIP equ <MP_HWND>

MP_LHANDLE  macro   name,opts
    _GenMP  <name>,2,<opts>
    if VLgen
        _FlsMJmp
	mov	ax,_P_&name
	or	ax,ax
	jnz	@F
        mov     bx,ERR_BAD_LOCAL_HANDLE
        lcall   Inval_Param_
    @@:
    endif
endm

MP_LHANDLE0 equ <MP_2>

MP_GHANDLE     macro   h,opts
_GenMP	<h>,2,<opts>
if VLgen
    _FlsMJmp
    IFNDEF  WOW
	mov	ax,_P_&h
	lcall	GHANDLE
    ENDIF
endif
endm

MP_GHANDLE0    macro   h,opts
_GenMP	<h>,2,<opts>
if VLgen
    _FlsMJmp
    IFNDEF  WOW
	mov	ax,_P_&h
	lcall	GHANDLE0
    ENDIF
endif
endm

MP_GHANDLEDDE	equ <MP_GHANDLE>
MP_GHANDLEDDE0	equ <MP_GHANDLE0>

MP_GHANDLEDDEW     macro   h,opts
local	GHexit
_GenMP	<h>,2,<opts>
ifdef DEBUG
   if VLgen
      _FlsMJmp
      mov       ax,_P_&h
      test	al,0100b	; Reject GDT selectors
      jz        @F
      cmp	ax,0ffffh	; special case: -1 -> DS
      jz	GHexit
      lar	dx,ax		; is it a valid selector?
      jz        GHexit
@@:
      mov       bx,ERR_BAD_GLOBAL_HANDLE or ERR_WARNING
      lcall	Inval_Param_
GHexit:
   endif
endif
endm

MP_HICON    equ <MP_GHANDLE>
MP_HICON0   equ <MP_GHANDLE0>

MP_HTASK    equ <MP_GHANDLE>
MP_HTASK0   equ <MP_GHANDLE0>

; Pointers

MP_LP	macro	lptr,opts
_GenMP	<lptr>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lptr
    mov     cx,_P_&lptr+2
    mov     bx,1
    lcall   LP
    _gensub LP
endif
endm

MP_CLP	macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   CLP
    _gensub LP
endif
endm

MP_LP0	macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   LP0
    _gensub LP
endif
endm

MP_CLP0 macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   CLP0
    _gensub LP
endif
endm

MP_LPBUFFERCNT	equ <MP_LP>

MP_CLPSTR	macro	lpsz,opts
_GenMP	<lpsz>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lpsz
    mov     cx,_P_&lpsz+2
    mov     bx,-1
    lcall   CLPSZ
    _gensub LPSZ
endif
endm

MP_CLPSTR0	macro	lpsz,opts
_GenMP	<lpsz>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lpsz
    mov     cx,_P_&lpsz+2
    mov     bx,-1
    lcall   CLPSZ0
    _gensub LPSZ
endif
endm

MP_LPSTRCB	equ <MP_4>	; may be arbitrary 32-bit value
MP_CLPSTRCB	equ <MP_4>

MP_CLPSTRLB	equ <MP_4>	; may be arbitrary 32-bit value

MP_CLPMSG0	equ <MP_CLP0>

MP_LPRECT	equ <MP_LP>
MP_CLPRECT	equ <MP_LP>

MP_LPBUFFERX	macro	count, lpBuffer, opts
    MP_int	<count>,<opts>
    MP_LP	<lpBuffer>,<opts>
endm

MP_LPTSBUFFER0	macro	cTabs, lpTabs, opts
    MP_int	<cTabs>,<opts>
    MP_LP0	<lpTabs>,<opts>
endm

MP_LPWBUFFERX	macro	wCount, lpBuf, opts	;** lpBuf is int. buffer
    MP_int	<count>,<opts>
    MP_LP	<lpTabs>,<opts>
endm

MP_LPMEASUREITEMSTRUCT	equ <MP_LP>
MP_LPCREATESTRUCT	equ <MP_LP>

MP_CLPCOMPAREITEMSTRUCT equ <MP_CLP>
MP_CLPDELETEITEMSTRUCT	equ <MP_CLP>
MP_CLPDRAWITEMSTRUCT	equ <MP_CLP>
MP_CLPMDICREATESTRUCT	equ <MP_CLP>
MP_CLP5POINTBUFFER	equ <MP_CLP>	; array of 5 points

; Function pointers

MP_LPFNWORDBREAK0 macro   pfn,opts
_GenMP	<pfn>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&pfn
    mov     cx,_P_&pfn+2
    lcall   LPFN0
    _gensub LPFN
endif
endm

MP_LPFNTIMER0 macro   pfn,opts
_GenMP	<pfn>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&pfn
    mov     cx,_P_&pfn+2
    lcall   LPFN0
    _gensub LPFN
endif
endm

; More types

MP_ATOM 	equ <MP_2>
MP_ATOM0	equ <MP_2>

MP_BIVALUE	macro	val,v1,v2,opts
    MP_2	<val>,<opts>
endm

MP_CBINDEX	equ <MP_2>
MP_CBINDEXFFFF	equ <MP_2>
MP_CBITEMHEIGHTFFFF equ <MP_2>
MP_CHARINDEXFFFF    equ <MP_2>
MP_CHARVALUE	    equ <MP_2>
MP_CID		equ <MP_2>

MP_CONST	macro	val, constant, opts		  ;** set to SMP_JOBSTATUS
    MP_2	<val>,<opts>
endm

MP_CTRLID	equ <MP_2>
MP_EDITPOS	equ <MP_2>
MP_EMCHARPOS	equ <MP_2>
MP_EMLINE	equ <MP_2>
MP_EMLINEFFFF	equ <MP_2>
MP_EMLINEFFFF	equ <MP_2>
MP_EMCLINE	equ <MP_2>

MP_LBINDEX	equ <MP_2>
MP_LBINDEXFFFF	equ <MP_2>

MP_LBLPBUFFERINDEX macro wIndex, lpBuf, opts
    MP_2    <wIndex>,<opts>
    MP_4    <lpBuf>,<opts>
endm

MP_SHOWVALUE	equ <MP_WORD>
MP_SYSCOMMAND	equ <MP_WORD>
MP_VKEY 	equ <MP_WORD>

MP_WMMENUSELECT macro	idOrHandle, flags, opts
    MP_2	idOrHMenu	    ; id or menu handle
    MP_2	flags		    ; may be -1
    MP_2	hMenu		    ; may be NULL
endm

MP_WMNEXTDLGCTL macro	hwndOrFPrev, fHandle, opts     ;** if lParam is 0 wParam is a flag
    MP_2	<hwndOrFPrev>,<opts>
    MP_BOOL	<fHandle>,<opts>
    MP_WMBZ	lParamH,<opts>
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\net.c ===
#include  "user.h"
#include "winnet.h"
#include "netdlg.h"

void FAR PASCAL WriteOutProfiles(void);

#define IFNRESTORECONNECTION	23
#define IERR_MustBeLoggedOnToConnect   5000

#define CFNNETDRIVER 22 	    /* number of winnet entrypoints */
#define CFNNETDRIVER2 35	    /* ... in Windows 3.1	    */

extern FARPROC NEAR* pNetInfo;	    /* pointer to list of WINNET entrypoints */
extern HANDLE hWinnetDriver;

extern void FAR PASCAL WNetEnable( void );
extern WORD FAR PASCAL WNetGetCaps2(WORD nIndex);	/* winnet.asm */

typedef struct _conntext
  {
    char szDevice[5];
    char szPath[64];
    char szPassword[32];
  } CONNTEXT;


char CODESEG szNet[] = "Network";
char CODESEG szDialogs[] = "DefaultDialogs";

HWND hwndTopNet = NULL;
CONNTEXT FAR * lpctDlg;

#ifdef WOW
typedef VOID (FAR *LPTELLKRNL) (HINSTANCE);
#endif


WORD API IWNetGetCaps(WORD nIndex)
{
    WORD wRet;

    if (nIndex == 0xFFFF)
	wRet = (WORD)hWinnetDriver;
    else {
    	wRet = WNetGetCaps2(nIndex);

	if (nIndex == WNNC_DIALOG) {
	    // turn off the drivers built in dialogs if
	    // win.ini [network] defaultdialogs=1
	    if (GetProfileInt(szNet, szDialogs, 0)) {
		wRet &= ~(WNNC_DLG_ConnectDialog |
			  WNNC_DLG_DisconnectDialog |
			  WNNC_DLG_ConnectionDialog);
	    }
	}
    }
    return wRet;
}


WORD API WNetErrorText(WORD wError,LPSTR lpsz, WORD cbMax)
{
    WORD wInternalError;
    WORD cb;
    char szT[40];

    if ((wError == WN_NET_ERROR)
	&& (WNetGetError(&wInternalError) == WN_SUCCESS)
	&& (WNetGetErrorText(wInternalError,lpsz,&cbMax) == WN_SUCCESS))
      {
	return cbMax;
      }
    else
      {
	cb = LoadString(hInstanceWin,STR_NETERRORS+wError,lpsz,cbMax);
	if (!cb)
	  {
	    LoadString(hInstanceWin,STR_NETERRORS,szT,sizeof(szT));
	    cb = wvsprintf(lpsz, szT, (LPSTR)&wError);
	  }
      }
    return cb;
}

#if 0

/* CenterDialog() -
 *
 *  Puts a dialog in an aesthetically pleasing place relative to its parent
 */

void near pascal CenterDialog(HWND hwnd)
{
    int x, y;

    /* center the dialog
     */
    if (hwnd->hwndOwner)
      {
	x = hwnd->hwndOwner->rcWindow.left;
	y = hwnd->hwndOwner->rcWindow.right;

	x += rgwSysMet[SM_CXSIZE] + rgwSysMet[SM_CXFRAME];
	y += rgwSysMet[SM_CYSIZE] + rgwSysMet[SM_CYFRAME];
      }
    else
      {
	x = (hwndDesktop->rcWindow.right
	  - (hwnd->rcWindow.right-hwnd->rcWindow.left)) / 2;

	y = (hwndDesktop->rcWindow.bottom
	  - (hwnd->rcWindow.bottom-hwnd->rcWindow.top)) / 2;
      }

    SetWindowPos(hwnd,NULL,x,y,0,0,SWP_NOSIZE);
}
#endif

/* stub dlg proc for status dialog
 */

BOOL CALLBACK ProgressDlgProc(HWND hwnd, WORD wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
      {
    case WM_INITDIALOG:
	// CenterDialog(hwnd);
	break;

    default:
	return FALSE;
      }
    return TRUE;
}

/* PasswordDlgProc() -
 *
 *  Get a password for a network resource
 */

BOOL CALLBACK PasswordDlgProc(HWND hwnd, WORD wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
      {
    case WM_INITDIALOG:
	// CenterDialog(hwnd);
        // Tell PenWin about this
        if (lpRegisterPenAwareApp)
            (*lpRegisterPenAwareApp)(1, TRUE);

//	SetDlgItemText(hwnd,IDD_DEV,lpctDlg->szDevice);
	SetDlgItemText(hwnd,IDD_PATH,lpctDlg->szPath);
	SendDlgItemMessage(hwnd, IDD_PASS, EM_LIMITTEXT, (WPARAM)(sizeof(lpctDlg->szPassword)-1), 0L);
	SetTimer(hwnd, 1, 30 * 1000, NULL);
	break;

    case WM_TIMER:
    	KillTimer(hwnd, 1);
	wParam = (WPARAM)IDCANCEL;
	goto TimeOut;

    case WM_COMMAND:
	switch ((WORD)wParam)
	  {
	case IDD_PASS:
	    if (HIWORD(lParam) == EN_CHANGE)
	        KillTimer(hwnd, 1);
	    break;

	case IDOK:
	    GetDlgItemText(hwnd,IDD_PASS,lpctDlg->szPassword, sizeof(lpctDlg->szPassword));
	    /*** FALL THRU ***/

	case IDCANCEL:
	case IDABORT:
TimeOut:
            if (lpRegisterPenAwareApp)
                (*lpRegisterPenAwareApp)(1, FALSE);
	    EndDialog(hwnd, (int)wParam);
	    break;
	  }
	break;

    default:
	return FALSE;
      }
    return TRUE;
}

/* RestoreDevice() -
 *
 *  Restores a single device.  If fStartup is true, a dialog box is
 *  posted to list the connections being made (this posting is deferred
 *  until here so that if no permanant connections exist, none are
 *  restored.
 */

WORD NEAR PASCAL RestoreDevice(HWND hwndParent, LPSTR lpDev, BOOL fStartup, CONNTEXT FAR *lpct)
{
    WORD wT;
    WORD err;
    WORD errorMode;
    WORD result;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    result = WN_BAD_VALUE;
    if (lstrlen(lpDev) > 4)
	goto Done;

    lstrcpy(lpct->szDevice,lpDev);

    // If it's a drive that already exists then don't try to connect
    // over it.
    if (fStartup && *(lpDev+1) == ':') {
        if (GetDriveType(*lpDev-'A')) {
            // Drive already exists - don't stomp on it.
            result = WN_CANCEL;   // Don't report error.
            goto Done;
        }
    }

    if (fStartup)
	goto GetFromINI;

    wT = sizeof(lpct->szPath);
    err = WNetGetConnection(lpct->szDevice,lpct->szPath,&wT);

    if (err == WN_SUCCESS) {
	result = WN_SUCCESS;
	goto Done;
    }

    if (err == WN_DEVICE_ERROR) {
	err = WNetCancelConnection(lpct->szDevice,FALSE);
	if (err == WN_OPEN_FILES) {
	    // report a warning error to the user
	    WNetCancelConnection(lpct->szDevice,TRUE);
	} else if (err != WN_SUCCESS) {
	    result = err;
	    goto Done;
	}
    } else if (err == WN_NOT_CONNECTED) {
GetFromINI:
	if (!GetProfileString(szNet,lpct->szDevice,"",lpct->szPath,sizeof(lpct->szPath))) {
	    result = WN_NOT_CONNECTED;
	    goto Done;
	}
    } else if (err != WN_CONNECTION_CLOSED) {
	result = err;
	goto Done;
    }

    // initially attempt with a blank password
    //
    lpct->szPassword[0] = 0;

    // if on startup, show the status dialog
    //
    if (fStartup) {
	if (!hwndTopNet) {
	    hwndTopNet = CreateDialog(hInstanceWin,IDD_CONNECTPROGRESS,NULL,ProgressDlgProc);
            if (!hwndTopNet)
                goto TryConnection;

	    ShowWindow(hwndTopNet,SW_SHOW);
	}
	SetDlgItemText(hwndTopNet,IDD_DEV,lpct->szDevice);
	SetDlgItemText(hwndTopNet,IDD_PATH,lpct->szPath);
	UpdateWindow(hwndTopNet);
	hwndParent = hwndTopNet;
    }

TryConnection:

    // lpct->szPath now contains the path
    // and lpct->szPassword the password...
    err = WNetAddConnection(lpct->szPath,lpct->szPassword,lpct->szDevice);

    // if we're booting and the thing is connected, ignore
    if (fStartup && err == WN_ALREADY_CONNECTED) {
	result = WN_SUCCESS;
	goto Done;
    }

    // if it was success or some other error, return
    if (err != WN_BAD_PASSWORD && err != WN_ACCESS_DENIED) {
	result = err;
	goto Done;
    }

    // it was bad password.  prompt the user for the correct password
    lpctDlg = lpct;

    switch (DialogBox(hInstanceWin,IDD_PASSWORD,hwndParent,PasswordDlgProc)) {
    case -1:
	result = WN_OUT_OF_MEMORY;
	break;

    case IDOK:
	goto TryConnection;
	break;

    case IDCANCEL:
	result = WN_CANCEL;
	break;

    case IDABORT:
	result = WN_NET_ERROR;
	break;
    }

Done:
    SetErrorMode(errorMode);

    return result;
}

/* ReportError() -
 *
 *  Tell the user why the network connection failed
 */

void NEAR PASCAL ReportError(HWND hwndParent, WORD err, CONNTEXT FAR *lpct)
{
    char szTitle[80];
    char szT[200];
    char szError[150];
    LPSTR rglp[2];

    switch (err)
      {
    case WN_SUCCESS:
    case WN_CANCEL:
    case WN_NOT_CONNECTED:
	return;
      }

    WNetErrorText(err,szT,sizeof(szT));
    LoadString(hInstanceWin,STR_NETCONNMSG,szTitle,sizeof(szTitle));
    rglp[0] = (LPSTR)lpct->szPath;
    rglp[1] = (LPSTR)szT;
    wvsprintf(szError,szTitle,(LPSTR)rglp);
    LoadString(hInstanceWin,STR_NETCONNTTL,szTitle,sizeof(szTitle));
    MessageBox(hwndParent,szError,szTitle,MB_OK|MB_ICONEXCLAMATION);
}

/* WNetRestoreConnection() -
 *
 *  This function implements the "standard" restore-connection process.
 *  If the function is supported by the network driver, the driver is
 *  called instead.  Otherwise, standard behaviour is supplied.
 */

typedef WORD (FAR PASCAL* PFN_NETRESTORECON)(HWND, LPSTR);

UINT API WNetRestoreConnection(HWND hwndParent, LPSTR lpszDevice)
{
    static char CODESEG szInRestore[]="InRestoreNetConnect";
    static char CODESEG szRestore[]="Restore";
    char szDevice[10];
    char szTitle[50];
    char szMsg[255];
    CONNTEXT ct;
    WORD i;
    WORD err;
    BOOL bLoggedIn;

    if (!pNetInfo)
	return(WN_NOT_SUPPORTED);


    if (WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_RestoreConnection)
      {
	/* The device driver supports this call
	 */
	return (*(PFN_NETRESTORECON)(pNetInfo[IFNRESTORECONNECTION - 1]))(hwndParent, lpszDevice);
      }


    /* the network does not support restore connections.  do the default
     */
    if (HIWORD(lpszDevice))
	return RestoreDevice(hwndParent,lpszDevice,FALSE,&ct);

    // check to see if restoring net connects is enabled
    if (!GetProfileInt(szNet,szRestore,1))
	return(WN_SUCCESS);

    /* Check if we previously aborted in the middle of restoring net
     * connections.
     */
    if (GetProfileInt(szNet,szInRestore,0))
      {
        /* We died in the middle of restoring net connects. Inform user.
	 */
        LoadString(hInstanceWin, STR_NETCRASHEDTITLE, szTitle, sizeof(szTitle));
        LoadString(hInstanceWin, STR_NETCRASHEDMSG, szMsg, sizeof(szMsg));
        err = MessageBox(NULL, szMsg, szTitle,
                         MB_ICONEXCLAMATION | MB_RETRYCANCEL | MB_SYSTEMMODAL);

        if (err == IDCANCEL)
            goto ExitRestoreNet;

      }
    WriteProfileString(szNet,szInRestore,"1");
    /* Flush cache.
     */
    WriteOutProfiles();


    szDevice[1]=':';
    szDevice[2]=0;
    bLoggedIn = TRUE;
    for (i = 0; i < 26; i++)
      {
	szDevice[0] = (char)('A' + i);

        err = GetDriveType(i);
        if (err == DRIVE_FIXED || err == DRIVE_REMOVABLE)
          {
            /* Don't restore to system drives in case the user added a ram
	     * drive or new hard disk or something...
	     */
            continue;
          }
        else
          {
  	    err = RestoreDevice(hwndParent,szDevice,TRUE,&ct);
          }

	hwndParent = hwndTopNet;

	if ( (err == WN_NET_ERROR)			      &&
	     (WNetGetCaps (WNNC_NET_TYPE) == WNNC_NET_LanMan) &&
	     (WNetGetError (&err) == WN_SUCCESS)	      &&
	     (err == IERR_MustBeLoggedOnToConnect) )
	  {
	    bLoggedIn = FALSE;
	    break;    /* if not logged on to LanMan, skip rest #8361 RAID */
	  }
	else
	    // report error to user
	    ReportError(hwndParent,err,&ct);
      }

    /* Try to restore printer connections only if logged in. Fix for #8361
     * [lalithar] - 11/14/91
     */
    if (bLoggedIn)
      {
	szDevice[0] = 'L';
	szDevice[1] = 'P';
	szDevice[2] = 'T';
	szDevice[4] = 0;
	for (i = 0; i < 3; i++)
	  {
	    szDevice[3] = (char)('1' + i);
	    err = RestoreDevice(hwndParent,szDevice,TRUE,&ct);
	    hwndParent = hwndTopNet;

	    ReportError(hwndParent,err,&ct);
	  }
      }
    if (hwndTopNet)
      {
	DestroyWindow(hwndTopNet);
	hwndTopNet = NULL;
      }

ExitRestoreNet:
    /* Write out a 0 since we are no longer restoring net connections.
     */
    WriteProfileString(szNet,szInRestore,NULL);

    return(WN_SUCCESS);
}



/*--------------------------------------------------------------------------*/
/*									    */
/*  LW_InitNetInfo() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

void FAR PASCAL LW_InitNetInfo(void)
{
    int i;
    char szDriver[64];
    char szFile[32];
    char szSection[32];

#ifdef WOW
    HINSTANCE hInst;
    LPTELLKRNL lpTellKrnlWhoNetDrvIs;
#endif

    pNetInfo=NULL;

    if (!LoadString(hInstanceWin,STR_NETDRIVER,szDriver,sizeof(szDriver)))
	return;
    if (!LoadString(hInstanceWin,STR_BOOT,szSection,sizeof(szSection)))
	return;
    if (!LoadString(hInstanceWin,STR_SYSTEMINI,szFile,sizeof(szFile)))
	return;

    /*	look for in the tag NETWORK.DRV, with that as the output and the
     *	default string...
     */
    GetPrivateProfileString(szSection,szDriver,szDriver,szDriver,
	sizeof(szDriver),szFile);

    /* if entry present, but blank, punt
     */
    if (!*szDriver)
	return;

    hWinnetDriver = LoadLibrary(szDriver);
    if (hWinnetDriver < HINSTANCE_ERROR)
	return;

    pNetInfo = (FARPROC NEAR*)UserLocalAlloc(ST_STRING,LPTR,sizeof(FARPROC)*CFNNETDRIVER2);
    if (!pNetInfo)
      {
	FreeLibrary(hWinnetDriver);
	return;
      }

    for (i=0; i<CFNNETDRIVER; i++)
      {
	pNetInfo[i]=GetProcAddress(hWinnetDriver,MAKEINTRESOURCE(i+1));
      }

    if (WNetGetCaps(WNNC_SPEC_VERSION) >= 0x30D)
      {
	for (;i<CFNNETDRIVER2; i++)
	  {
	    pNetInfo[i]=GetProcAddress(hWinnetDriver,MAKEINTRESOURCE(i+1));
	  }
      }

#ifdef WOW
    // Sets up krnl robustness mechanism which allows us to prevent non-user.exe
    // modules from freeing the net driver (ie. causing ref count=0).  Otherwise
    // the proc addresses stored in pNetInfo would become invalid. bug #393078
    hInst = LoadLibrary("krnl386.exe");

    // if this fails, we just fly without robustness -- the way we used to...
    if(HINSTANCE_ERROR <= hInst) {
        lpTellKrnlWhoNetDrvIs =
                     (LPTELLKRNL) GetProcAddress(hInst, MAKEINTRESOURCE(545));
        if(lpTellKrnlWhoNetDrvIs) {
           lpTellKrnlWhoNetDrvIs(hWinnetDriver);
        }
    }
    FreeLibrary(hInst);
#endif

    WNetEnable();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SYNCHRONIZE_DRAIN=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\rmcreate.c ===
/****************************************************************************/
/*                                      */
/*  RMCREATE.C -                                */
/*                                      */
/*  Resource creating Routines.                     */
/*                                      */
/****************************************************************************/

#define RESOURCESTRINGS
#include "user.h"

#ifdef NOT_USED_ANYMORE
#define   NSMOVE   0x0010

HGLOBAL FAR PASCAL  DirectResAlloc(HGLOBAL, WORD, WORD);


/******************************************************************************
**
**  CreateCursorIconIndirect()
**
**      This is the common function called by CreateCursor and
**  CreateIcon()
**      DirectResAlloc() is called instead of GlobalAlloc() because
**  the Icons/Cursors created by one instance of the app can be used in
**  a WNDCLASS structure to Register a class which will be used by other
**  instances of the app and when the instance that created the icons/
**  cursors terminates, the resources SHOULD NOT BE FREED; If GlobalAlloc()
**  is used this is what will happen; At the same time, when the last
**  instance also dies, the memory SHOULD BE FREED; To achieve this,
**  DirectResAlloc() is used instead of GlobalAlloc();
**
******************************************************************************/

HGLOBAL CALLBACK CreateCursorIconIndirect(HINSTANCE hInstance,
                                             LPCURSORSHAPE lpHeader,
                         CONST VOID FAR* lpANDplane,
                         CONST VOID FAR* lpXORplane)
{
    register  WORD  ANDmaskSize;
    register  WORD  XORmaskSize;
    WORD  wTotalSize;
    HRSRC hResource;
    LPSTR lpRes;

    
    ANDmaskSize = lpHeader -> cbWidth * lpHeader -> cy;
    XORmaskSize = (((lpHeader -> cx * lpHeader -> BitsPixel + 0x0F) & ~0x0F)
                    >> 3) * lpHeader -> cy * lpHeader -> Planes;
    
    /* It is assumed that Cursor/Icon size won't be more than 64K */
    wTotalSize = sizeof(CURSORSHAPE) + ANDmaskSize + XORmaskSize;
    
#ifdef NEVER
    /* Allocate the required memory */
    if((hResource = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 
                        (DWORD)wTotalSize)) == NULL)
    return(NULL);
#else
    /* Let us preserve the long pointers */
    SwapHandle(&lpANDplane);
    SwapHandle(&lpXORplane);

    hResource = DirectResAlloc(hInstance, NSMOVE, wTotalSize);

    /* Let us restore the long pointers */
    SwapHandle(&lpANDplane);
    SwapHandle(&lpXORplane);
    
    if(hResource == NULL)
    return(NULL);
#endif

    if(!(lpRes = GlobalLock(hResource)))
    {
    GlobalFree(hResource);
    return(NULL);
    }

    LCopyStruct((LPSTR)lpHeader, lpRes, sizeof(CURSORSHAPE));
    lpRes += sizeof(CURSORSHAPE);
    LCopyStruct(lpANDplane, lpRes, ANDmaskSize);
    lpRes += ANDmaskSize;
    LCopyStruct(lpXORplane, lpRes, XORmaskSize);

    GlobalUnlock(hResource);
    return(hResource);
}

/******************************************************************************
**
**  CreateCursor()
**
**  This is the API call to create a Cursor "on-the-fly";
**
*******************************************************************************/

HCURSOR API ICreateCursor(hInstance, iXhotspot, iYhotspot, iWidth,
                   iHeight, lpANDplane, lpXORplane)

HINSTANCE hInstance;
int iXhotspot;
int iYhotspot;
int iWidth;
int iHeight;
CONST VOID FAR* lpANDplane;
CONST VOID FAR* lpXORplane;
{
    CURSORSHAPE    Header;

    Header.xHotSpot = iXhotspot;
    Header.yHotSpot = iYhotspot;
    Header.cx = iWidth;
    Header.cy = iHeight;
    Header.Planes = 1;      /* Cursors are only monochrome */
    Header.BitsPixel = 1;
    Header.cbWidth = ((iWidth + 0x0F) & ~0x0F) >> 3;

    return(CreateCursorIconIndirect(hInstance, &Header,
                        lpANDplane, lpXORplane));
}

/******************************************************************************
**
**  CreateIcon()
**
**  This is the API call to create an Icon "on-the-fly";
**
*******************************************************************************/

HICON API ICreateIcon(hInstance, iWidth, iHeight, bPlanes,
                bBitsPixel, lpANDplane, lpXORplane)

HINSTANCE hInstance;
int iWidth;
int iHeight;
BYTE    bPlanes;
BYTE    bBitsPixel;
CONST VOID FAR* lpANDplane;
CONST VOID FAR* lpXORplane;
{
    CURSORSHAPE    Header;

    Header.xHotSpot = iWidth/2;
    Header.yHotSpot = iHeight/2;
    Header.cx = iWidth;
    Header.cy = iHeight;
    Header.Planes = bPlanes;        /* Icons can be in color */
    Header.BitsPixel = bBitsPixel;
    Header.cbWidth = ((iWidth + 0x0F) & ~0x0F) >> 3;

    return(CreateCursorIconIndirect(hInstance, (LPCURSORSHAPE)&Header, 
                        lpANDplane, lpXORplane));
}

/******************************************************************************
 *
 *   DestroyIcon(hIcon) 
 *       This can be called to delete only those icons created "on the fly"
 *   using the CreateIcon() function
 *   Returns:
 *  TRUE if successful, FALSE otherwise.
 *
 ******************************************************************************/

BOOL API IDestroyIcon(HICON hIcon)

{
    return(!FreeResource(hIcon));
}

/******************************************************************************
 *
 *   DestroyCursor(hIcon) 
 *       This can be called to delete only those icons created "on the fly"
 *   using the CreateIcon() function
 *   Returns:
 *      TRUE if successful, FALSE otherwise.
 *
 ******************************************************************************/

BOOL API IDestroyCursor(HCURSOR hCursor)

{
    if (hCursor == hCurCursor)
    {
    /* #12068: if currently selected cursor resore arrow cursor and RIP [lalithar] */
        SetCursor(hCursNormal);
        DebugErr(DBF_ERROR, "DestroyCursor: Destroying current cursor");
    }
    return(!FreeResource(hCursor));
}

#endif /* NOT_USED_ANYMORE */


/****************************************************************************
**
**   DumpIcon()
**  
**  This function is called to get the details of a given Icon;
**
**  The caller must lock hIcon using LockResource() and pass the pointer
**  thro lpIcon;  This is the pointer to the header structure; 
**  Thro lpHeaderSize, the size of header is returned;
**  Thro lplpANDplane and lplpXORplane pointers to actual bit info is
**  returned;
**  This function returns a DWORD with the size of AND plane in loword
**  and size of XOR plane in hiword;
**
****************************************************************************/

DWORD CALLBACK DumpIcon(LPSTR       lpIcon, 
                        WORD FAR *  lpHeaderSize, 
                        LPSTR FAR * lplpANDplane, 
                        LPSTR FAR * lplpXORplane)

{
    register  WORD  ANDmaskSize;
    register  WORD  XORmaskSize;
    LPCURSORSHAPE  lpHeader;

    *lpHeaderSize = sizeof(CURSORSHAPE);

    if(!lpIcon)
    return((DWORD)0);

    lpHeader = (LPCURSORSHAPE)lpIcon;

    ANDmaskSize = lpHeader -> cbWidth * lpHeader -> cy;
    XORmaskSize = (((lpHeader -> cx * lpHeader -> BitsPixel + 0x0F) & ~0x0F)
                    >> 3) * lpHeader -> cy * lpHeader -> Planes;
    
    *lplpANDplane = (lpIcon += sizeof(CURSORSHAPE));
    *lplpXORplane = (lpIcon + ANDmaskSize);

    return(MAKELONG(ANDmaskSize, XORmaskSize));
}

#ifdef NOT_USED_ANYMORE
/****************************************************************************
**
** GetInternalIconHeader(lpIcon, lpDestBuff)
**  
**    This function has been added to fix bug #6351 with cornerstone
** XTRA_LARGE display driver. (It uses 64 X 64 Icons; Internally we 
** keep the size as 32 X 32. Progman must  know this internal size sothat
** it can tell that to WinOldApp.
****************************************************************************/

void API IGetInternalIconHeader(LPSTR       lpIcon, LPSTR lpDestBuff)
{
    LCopyStruct(lpIcon, lpDestBuff, sizeof(CURSORSHAPE));
}
#endif /* NOT_USED_ANYMORE */

/* APIs to make a copy of an icon or cursor */

HICON API ICopyIcon(HINSTANCE hInstance, HICON hIcon)
{
  LPSTR     lpAND;
  LPSTR     lpXOR;
  LPSTR     lpIcon;
  WORD      wHeaderSize;
  HICON     hIconCopy;
  LPCURSORSHAPE  lpHeader;

  lpIcon = LockResource(hIcon);
  if (!lpIcon)
      return NULL;

  lpHeader = (LPCURSORSHAPE)lpIcon;

  DumpIcon(lpIcon, &wHeaderSize, &lpAND, &lpXOR);

    hIconCopy = CreateIcon(hInstance,
                            lpHeader->cx,
                            lpHeader->cy,
                            lpHeader->Planes,
                            lpHeader->BitsPixel,
                            lpAND, lpXOR);

  UnlockResource(hIcon);

  return(hIconCopy);
}

HCURSOR API ICopyCursor(HINSTANCE hInstance, HICON hCursor)
{
  LPSTR     lpAND;
  LPSTR     lpXOR;
  LPSTR     lpCursor;
  WORD      wHeaderSize;
  HCURSOR     hCursorCopy;
  LPCURSORSHAPE  lpHeader;

  lpCursor = LockResource(hCursor);
  if (!lpCursor)
      return NULL;

  lpHeader = (LPCURSORSHAPE)lpCursor;

  DumpIcon(lpCursor, &wHeaderSize, &lpAND, &lpXOR);

    hCursorCopy = CreateCursor(hInstance,
                            lpHeader->xHotSpot,
                            lpHeader->yHotSpot,
                            lpHeader->cx,
                            lpHeader->cy,
                            lpAND, lpXOR);

  UnlockResource(hCursor);

  return(hCursorCopy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user1a.asm ===
;
;   USER1A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER1A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   DELETEMENU
    UserThunk   DESKTOPWNDPROC
    DUserThunk  DESTROYCARET,0
    UserThunk   DESTROYCURSOR
    UserThunk   DESTROYICON
    UserThunk   DESTROYMENU
    UserThunk   DESTROYWINDOW
;   UserThunk   DIALOGBOX                    ; defined in fastres.c
;   UserThunk   DIALOGBOXINDIRECT
;   UserThunk   DIALOGBOXINDIRECTPARAM

FUN_WOWDIALOGBOXPARAM EQU FUN_DIALOGBOXPARAM
    DUserThunk	WOWDIALOGBOXPARAM, %(size DIALOGBOXPARAM16)

    DUserThunk  DISABLEOEMLAYER
    UserThunk   DISPATCHMESSAGE
    UserThunk   DLGDIRLIST
    UserThunk   DLGDIRLISTCOMBOBOX
    UserThunk   DLGDIRSELECT
    UserThunk   DLGDIRSELECTCOMBOBOX
    UserThunk   DRAGDETECT
    UserThunk   DRAGOBJECT
    UserThunk   DRAWFOCUSRECT
    UserThunk   DRAWICON
    UserThunk   DRAWMENUBAR
        UserThunk   DRAWTEXT
;   DUserThunk  DUMPICON            ; LOCALAPI in rmload.c
;   UserThunk   EDITWNDPROC         ; LOCALAPI in wsubcls.c
    DUserThunk  EMPTYCLIPBOARD,0
    DUserThunk  ENABLEHARDWAREINPUT
    DUserThunk  ENABLEOEMLAYER
    UserThunk   ENABLEWINDOW
    UserThunk   ENDDEFERWINDOWPOS
    UserThunk   ENDDIALOG
    DUserThunk  ENDMENU
    UserThunk   ENDPAINT
    UserThunk   ENUMCHILDWINDOWS
    DUserThunk  ENUMCLIPBOARDFORMATS
    UserThunk   ENUMPROPS
    UserThunk   ENUMTASKWINDOWS
    UserThunk   ENUMWINDOWS
;;;    UserThunk   EQUALRECT	   ; LOCALAPI in winrect.asm
    UserThunk   ESCAPECOMMFUNCTION
    UserThunk   EXCLUDEUPDATERGN
    DUserThunk  EXITWINDOWS


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user.inc ===
;****************************************************************************
;*									    *
;*  USER.INC -								    *
;*									    *
;*	User Data Structures and Defines				    *
;*									    *
;****************************************************************************
;
; Conditional include #defines:
;
; LAYER_INCLUDE - Just define POINT, RECT, WND, and CLS structs, plus ICLS_*
; NOTEXT	- Blow off TEXTMETRICS and some other stuff
;

ifdef WOW
NOTEXT equ 1
endif

.286P

ifndef LAYER_INCLUDE

?DF=1		; Don't define _TEXT or _DATA
?WIN=0		; turn off Windows support (no default preserve DS in far calls)
include cmacros.inc
include vint.inc

createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp DGROUP,DATA

;createSeg _TEXT,TEXT,WORD,PUBLIC,CODE,IGROUP

createSeg _GPFIX0,GPFIX0,WORD,PUBLIC,CODE,IGROUP  ; GP fault trapping
createSeg _GPFIX, GPFIX, WORD,PUBLIC,CODE,IGROUP
createSeg _GPFIX1,GPFIX1,WORD,PUBLIC,CODE,IGROUP

;defGrp	IGROUP,TEXT

endif




include gpfix.inc	    ; GP fault handler stuff

VER20		    equ 0201h
VER300		    equ 0300h
VER310		    equ 0310h

FALSE		    equ 0
TRUE		    equ 1
NULL		    equ 0

; Debug fill constants

DBGFILL_ALLOC   equ     0fdh
DBGFILL_FREE    equ     0fbh
DBGFILL_BUFFER  equ     0f9h
DBGFILL_STACK   equ     0f7h

;*--------------------------------------------------------------------------*
;*									    *
;*  Window and internal class structures
;*									    *
;*--------------------------------------------------------------------------*

;
; POINT Structure
;
POINT   struc
    ptX 	dw ?
    ptY 	dw ?
POINT   ends

;
; RECT Structure
;
RECT    struc
    rcLeft	dw ?
    rcTop	dw ?
    rcRight	dw ?
    rcBottom	dw ?
RECT    ends

ifdef WOW
;
; RECTL Structure
;
RECTL    struc
    rclLeft	dd ?
    rclTop	dd ?
    rclRight	dd ?
    rclBottom	dd ?
RECTL    ends
endif

ifndef WOW
ifdef WORDEXSTYLE
WND	struc
    wndHwndNext     dw ?
    wndHwndChild    dw ?
    wndPwndParent   dw ?
    wndHwndOwner    dw ?
    wndRcWindow     db size RECT dup(?)
    wndRcClient     db size RECT dup(?)
    wndHq	    dw ?
    wndHRgnUpdate   dw ?
    wndPcls	    dw ?
    wndHInstance    dw ?
    wndLpfnWndProc  dd ?
    wndState	    dd ?
    wndStyle	    dd ?
    wndDwExStyle    dw ?
    wndHMenu	    dw ?
    wndHName	    dw ?
    wndRgwScroll    dw ?
    wndPproptab     dw ?
    wndHwndLastActive dw ?
    wndHSysMenu     dw ?
WND	ends

else

WND	struc
    wndHwndNext     dw ?
    wndHwndChild    dw ?
    wndPwndParent   dw ?
    wndHwndOwner    dw ?
    wndRcWindow     db size RECT dup(?)
    wndRcClient     db size RECT dup(?)
    wndHq	    dw ?
    wndHRgnUpdate   dw ?
    wndPcls	    dw ?
    wndHInstance    dw ?
    wndLpfnWndProc  dd ?
    wndState	    dd ?
    wndStyle	    dd ?
    wndDwExStyle    dd ?
    wndHMenu	    dw ?
    wndHName	    dw ?
    wndRgwScroll    dw ?
    wndPproptab     dw ?
    wndHwndLastActive dw ?
    wndHSysMenu     dw ?
WND	ends

endif   ; WORDEXSTYLE


;
; Internal window class structure
;
CLS	struc
    uclspclsNext	dw ?
    uclsMagic		dw ?
    uclsatomClassName	dw ?
    uclshdc		dw ?
    uclscWndReferenceCount  dw ?  ; Number of windows registered with this
				  ; Class

; NOTE: the remaining fields are in the same order as in the WNDCLASS struct

    uclsstyle		dw ?	; Class style
    uclslpfnWndProc	dd ?
    uclscbclsExtra	dw ?
    uclscbwndExtra	dw ?
    uclshModule 	dw ?	; Module handle
    uclshIcon		dw ?	; Class icon handle
    uclshCursor 	dw ?	; Class cursor handle
    uclshbrBackground	dw ?	; Class background brush
    uclslpszMenuName	dd ?	; Menu name
    uclslpszClassName	dd ?	; Far ptr to class name
CLS	ends

CLS_MAGIC   equ ('N' or ('K' * 256))

; System class ID constants
;
; See comments in USER.H
;
ICLS_BUTTON	    equ 0
ICLS_EDIT	    equ 1
ICLS_STATIC	    equ 2
ICLS_LISTBOX	    equ 3
ICLS_SCROLLBAR	    equ 4
ICLS_COMBOBOX	    equ 5	; End of special dlgmgr indices

ICLS_CTL_MAX	    equ 6	; Number of public control classes

ICLS_DESKTOP	    equ 6
ICLS_DIALOG	    equ 7
ICLS_MENU	    equ 8
ICLS_SWITCH	    equ 9
ICLS_ICONTITLE	    equ 10
ICLS_MDICLIENT	    equ 11
ICLS_COMBOLISTBOX   equ 12

ICLS_MAX	    equ 13	; Number of system classes
endif   ; !WOW

;
; SetWindowPos() SMWP structure header
;
SMWP struc
    SmwpCcvr        dw  ?
    SmwpCcvrAlloc   dw  ?
    SmwpFInUse      dw  ?
    SmwpSignature   dw  ?
;   SmwpRgcvr       db  1
SMWP ends

SMWP_SIG    equ     ('W' or ('P' * 256))

ifndef LAYER_INCLUDE	   ; If not included from layer.asm...

;
; Substitute API names with "I" internal names if RETAIL
;
ifndef DEBUG
include iuser.inc
endif

ifndef WOW
; Internal window class names
;
MENUCLASS       equ     8000h
DESKTOPCLASS    equ     8001h
DIALOGCLASS     equ     8002h
SWITCHWNDCLASS  equ     8003h
ICONTITLECLASS  equ     8004h

;
; Window flag Test, Set, and Clear macros
;
TSTWF	macro pwnd, flag
	LOCAL wlow, whigh
	wlow  = LOW flag
	whigh = HIGH flag
	test	byte ptr [pwnd+wndState+whigh], wlow
	endm

SETWF	macro pwnd, flag
	LOCAL wlow, whigh
	wlow  = LOW flag
	whigh = HIGH flag
	or	byte ptr [pwnd+wndState+whigh], wlow
	endm

CLRWF	macro pwnd, flag
	LOCAL nwlow, whigh
	nwlow = NOT(LOW flag)
	whigh = HIGH flag
	and	byte ptr [pwnd+wndState+whigh], nwlow
	endm

;
; Window Flags
;
; hwnd->state flags (offset 0, 1, 2, 3)
;
WFMPRESENT	    equ 0001h
WFVPRESENT	    equ 0002h
WFHPRESENT	    equ 0004h
WFCPRESENT	    equ 0008h
WFSENDSIZEMOVE	    equ 0010h
WFNOPAINT	    equ 0020h
WFFRAMEON	    equ 0040h
WFHASSPB	    equ 0080h
WFNONCPAINT	    equ 0101h
WFSENDERASEBKGND    equ 0102h
WFERASEBKGND	    equ 0104h
WFSENDNCPAINT	    equ 0108h
WFINTERNALPAINT     equ 0110h	     ; Internal paint required flag
WFUPDATEDIRTY	    equ 0120h
WFHIDDENPOPUP	    equ 0140h
WFMENUDRAW	    equ 0180h

WFHASPALETTE	    equ 0201h
WFPAINTNOTPROCESSED equ 0202h
WFWIN31COMPAT	    equ 0204h
WFALWAYSSENDNCPAINT equ 0208h
WFPIXIEHACK         equ 0210h
WFTOGGLETOPMOST     equ 0220h
;
; hwnd->style style bits (offsets 4, 5, 6, 7)
;
WFTYPEMASK	    equ 07C0h
WFTILED 	    equ 0700h
WFICONICPOPUP	    equ 07C0h
WFPOPUP 	    equ 0780h
WFCHILD 	    equ 0740h
WFMINIMIZED	    equ 0720h
WFVISIBLE	    equ 0710h
WFDISABLED	    equ 0708h
WFDISABLE	    equ WFDISABLED
WFCLIPSIBLINGS	    equ 0704h
WFCLIPCHILDREN	    equ 0702h
WFMAXIMIZED	    equ 0701h
WFICONIC	    equ WFMINIMIZED

WFMINBOX	    equ 0602h
WFMAXBOX	    equ 0601h

WFBORDERMASK	    equ 06C0h
WFBORDER	    equ 0680h
WFCAPTION	    equ 06C0h
WFDLGFRAME	    equ 0640h
WFTOPLEVEL	    equ 0640h

WFVSCROLL	    equ 0620h
WFHSCROLL	    equ 0610h
WFSYSMENU	    equ 0608h
WFSIZEBOX	    equ 0604h
WFGROUP 	    equ 0602h
WFTABSTOP	    equ 0601h

; If this dlg bit is set, WM_ENTERIDLE message will not be sent
WFNOIDLEMSG	    equ 0501h
;
; hwnd->dwExStyle extended style bits (offsets 8, 9)
;
WEFDLGMODALFRAME    equ 0801h
WEFDRAGOBJECT	    equ 0802h
WEFNOPARENTNOTIFY   equ 0804h
WEFTOPMOST	    equ 0808h
WEFACCEPTFILES	    equ 0810h
WEFTRANSPARENT	    equ 0820h	     ; "Transparent" child window

; Class styles
;
CFVREDRAW	    equ 0001h
CFHREDRAW	    equ 0002h
CFKANJIWINDOW	    equ 0004h
CFDBLCLKS	    equ 0008h
CFOEMCHARS	    equ 0010h
CFOWNDC 	    equ 0020h
CFCLASSDC	    equ 0040h
CFPARENTDC	    equ 0080h
CFNOKEYCVT	    equ 0101h
CFNOCLOSE	    equ 0102h
CFLVB		    equ 0104h
CFCLSDC 	    equ CFCLASSDC
CFSAVEBITS	    equ 0108h
CFSAVEPOPUPBITS     equ CFSAVEBITS
CFBYTEALIGNCLIENT   equ 0110h
CFBYTEALIGNWINDOW   equ 0120h

ST_CLASS	equ	1
ST_WND		equ 	2
ST_STRING	equ	3
ST_MENU		equ	4
ST_CLIP		equ	5
ST_CBOX		equ	6
ST_PALETTE	equ	7
ST_ED		equ	8
ST_BWL		equ	9
ST_OWNERDRAWMENU equ	10
ST_SPB		equ	11
ST_CHECKPOINT	equ	12
ST_DCE		equ	13
ST_MWP		equ	14
ST_PROP		equ	15
ST_LBIV		equ	16
ST_MISC		equ	17
ST_ATOMS	equ	18
ST_LOCKINPUTSTATE equ   19
ST_HOOKNODE	equ	20
ST_USERSEEUSERDOALLOC   equ 21
ST_HOTKEYLIST   equ     22
ST_POPUPMENU    equ     23
ST_HANDLETABLE  equ	32
ST_FREE		equ	0ffh
endif   ; !WOW

ifdef DEBUG
ifndef winmisc1
LocalAlloc	equ	<UserLocalAlloc>
LocalFree	equ	<UserLocalFree>
LocalLock	equ	<UserLocalLock>
LocalUnlock	equ	<UserLocalUnlock>
LocalReAlloc	equ	<UserLocalReAlloc>
LocalSize	equ	<UserLocalSize>

TAGSIZE         equ     4                  ; Size of a tag in debug USER
endif
endif

; The following is required to special-case the SetWindowWord(., GCW_HMODULE);
GCW_HMODULE       =  (-16)

; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.

ifndef NOTEXT
;
; TEXTMETRIC Structure
;
TEXTMETRIC struc
    tmHeight		dw ?
    tmAscent		dw ?
    tmDescent		dw ?
    tmInternalLeading	dw ?
    tmExternalLeading	dw ?
    tmAveCharWidth	dw ?
    tmMaxCharWidth	dw ?
    tmWeight		dw ?
    tmItalic		db ?
    tmUnderlined	db ?
    tmStruckOut 	db ?
    tmFirstChar 	db ?
    tmLastChar		db ?
    tmDefaultChar	db ?
    tmBreakChar 	db ?
    tmPitch		db ?
    tmOverhang		dw ?
    tmDigitizedAspectX	dw ?
    tmDigitizedAspectY	dw ?
    tmCharSet		db ?
TEXTMETRIC ends

;
; Text Drawing modes
;
TRANSPARENT	    equ 1
OPAQUE		    equ 2

;
; Stock Logical Objects
;
WHITE_BRUSH	    equ  0
LTGRAY_BRUSH	    equ  1
GRAY_BRUSH	    equ  2
DKGRAY_BRUSH	    equ  3
BLACK_BRUSH	    equ  4
HOLLOW_BRUSH	    equ  5
WHITE_PEN	    equ  6
BLACK_PEN	    equ  7
NULL_PEN	    equ  8
DOT_MARKER	    equ  9
OEM_FIXED_FONT	    equ 10
ANSI_FIXED_FONT     equ 11
ANSI_VAR_FONT	    equ 12

endif	; NOTEXT


ANSI_CHARSET	    equ 0
OEM_CHARSET	    equ 255

ifndef WOW
;
; Styles for CombineRgn
;
RGN_AND 	    equ 1
RGN_OR		    equ 2
RGN_XOR 	    equ 3
RGN_DIFF	    equ 4
RGN_COPY	    equ 5

;
; Predefined cursor & icon IDs
;
IDC_ARROW	    equ 1
IDC_IBEAM	    equ 2
IDC_WAIT	    equ 3
IDC_UPARROW	    equ 8
IDC_SIZE	    equ 9
IDC_ICON	    equ 10

IDI_APPLICATION     equ 1
IDI_NOTE	    equ 2
IDI_ERROR           equ 3
endif ; !WOW

;
; Memory manager flags
;
LMEM_FIXED	    equ 0000h
LMEM_MOVEABLE	    equ 0002h
LMEM_ZEROINIT	    equ 0040h
LMEM_DISCARDABLE    equ 0F00h
LHND		    equ LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR		    equ LMEM_FIXED+LMEM_ZEROINIT

GMEM_FIXED	    equ 0000h
GMEM_MOVEABLE	    equ 0002h
GMEM_ZEROINIT	    equ 0040h
GMEM_SHAREALL	    equ 2000h
GMEM_LOWER	    equ 1000h
GMEM_DISCARDABLE    equ 0F00h
GHND		    equ GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR		    equ GMEM_FIXED+GMEM_ZEROINIT


ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  Miscellaneous structures & constants				    *
;*									    *
;*--------------------------------------------------------------------------*

BITMAP struc
    bmType	    dw ?
    bmWidth	    dw ?
    bmHeight	    dw ?
    bmWidthBytes    dw ?
    bmPlanes	    db ?
    bmBitsPixel     db ?
    bmBits	    dq ?
BITMAP ends

PAINTSTRUCT struc
    PShdc	    dw ?
    PSfErase	    dw ?
    PSrcPaint	    db size RECT dup(?)
    PSfRestore	    dw ?
    PSfIncUpdate    dw ?
    PSrgbReserved   db 16 dup(?)
PAINTSTRUCT ends

;
; Message structure
;
MSGSTRUCT struc
    msHWND	    dw ?
    msMESSAGE	    dw ?
    msWPARAM	    dw ?
    msLPARAM	    dd ?
    msTIME	    dd ?
    msPT	    dd ?
MSGSTRUCT ends

NEWPARMS struc
    nprmHwnd	    dw ?
    nprmCmd	    db ?
NEWPARMS ends

;
;  CreateStruct   structure
;
;  Note: This is used in WinUtil.ASM
;  Modify this definition when this struct is modified in WINDOWS.H
;

CREATESTRUCT   struc
    csLPCreateParams	dd  ?
    csHInstance		dw  ?
    csHMenu		dw  ?
    csHwndParent	dw  ?
    csCY		dw  ?
    csCX		dw  ?
    csY			dw  ?
    csX			dw  ?
    csStyle		dd  ?
    csLPszName		dd  ?
    csLPszClass		dd  ?
    csExStyle		dd  ?
CREATESTRUCT   ends

;
; ShowWindow commands
;
HIDE_WINDOW	equ 0
SHOW_OPENWINDOW equ 1
SHOW_ICONWINDOW equ 2

;
; PostError constants
;
WARNING 	equ 0		; command codes
MINOR_ERROR	equ 1
FATAL_ERROR	equ 2

IGNORE		equ 0		; response codes
RETRY		equ 1
ABORT		equ 2

;
; GDI-related constants & commands
;
ERRORREGION	equ 0
NULLREGION	equ 1
SIMPLEREGION	equ 2
COMPLEXREGION	equ 3

;
; StretchBlt modes
;
BLACKONWHITE	equ 1
WHITEONBLACK	equ 2
COLORONCOLOR	equ 3

;
; PolyFill modes
;
ALTERNATE	equ 1
WINDING 	equ 2

;
; Size message commands
;
SIZENORMAL	equ 0
SIZEICONIC	equ 1
SIZEFULLSCREEN	equ 2

;
; Key state masks for mouse messages
;
MK_LBUTTON	equ 0001h
MK_RBUTTON	equ 0002h
MK_SHIFT	equ 0004h
MK_ALTERNATE	equ 0008h
MK_CONTROL	equ 0010h

;
; Predefined clipboard formats
;
CF_TEXT 	equ 1
CF_BITMAP	equ 2
CF_METAFILEPICT equ 3
CF_SYLK 	equ 4
CF_DIF		equ 5
CF_TIFF 	equ 6
CF_OEMTEXT	equ 7
CF_DIB          equ 8
CF_PALETTE      equ 9
CF_PENDATA      equ 10

CF_OWNERDISPLAY equ 80h       ; owner display
CF_DSPTEXT	equ 81h       ; display text
CF_DSPBITMAP	equ 82h       ; display bitmap
CF_DSPMETAFILE	equ 83h       ; display metafile

;
; Private clipboard format range
;
CF_PRIVATEFIRST equ 200h      ; Anything in this range doesn't
CF_PRIVATELAST	equ 2FFh      ; get GlobalFree'd
CF_GDIOBJFIRST	equ 300h      ; Anything in this range gets
CF_GDIOBJLAST	equ 3FFh      ; DeleteObject'ed

MAKEINTRESOURCE macro a
	mov	ax,a
	cwd
	endm

;
; Predefined resource types
;
RT_CURSOR	equ 1		   ; must be passed through MAKEINTRESOURCE
RT_BITMAP	equ 2
RT_ICON 	equ 3
RT_MENU 	equ 4
RT_DIALOG	equ 5
RT_STRING	equ 6
RT_FONTDIR	equ 7
RT_FONT 	equ 8

;
; Virtual Key definitions
;
VK_MOUSE	    equ 00H
VK_LBUTTON	    equ 01h
VK_RBUTTON	    equ 02h
VK_CANCEL	    equ 03h
VK_MBUTTON	    equ 04h
VK_BACK 	    equ 08h
VK_TAB		    equ 09h
VK_CLEAR	    equ 0Ch
VK_RETURN	    equ 0Dh
VK_SHIFT	    equ 10h
VK_CONTROL	    equ 11h
VK_MENU 	    equ 12h
VK_PAUSE	    equ 13h
VK_CAPITAL	    equ 14h
VK_ESCAPE	    equ 1Bh
VK_SPACE	    equ 20h
VK_PRIOR	    equ 21h
VK_NEXT 	    equ 22h
VK_END		    equ 23h
VK_HOME 	    equ 24h
VK_LEFT 	    equ 25h
VK_UP		    equ 26h
VK_RIGHT	    equ 27h
VK_DOWN 	    equ 28h
VK_SELECT	    equ 29h
VK_PRINT	    equ 2Ah
VK_EXECUTE	    equ 2Bh
VK_SNAPSHOT	    equ 2Ch
VK_INSERT	    equ 2Dh
VK_DELETE	    equ 2Eh
VK_HELP 	    equ 2Fh
VK_NUMPAD0	    equ 60h
VK_NUMPAD1	    equ 61h
VK_NUMPAD2	    equ 62h
VK_NUMPAD3	    equ 63h
VK_NUMPAD4	    equ 64h
VK_NUMPAD5	    equ 65h
VK_NUMPAD6	    equ 66h
VK_NUMPAD7	    equ 67h
VK_NUMPAD8	    equ 68h
VK_NUMPAD9	    equ 69h
VK_MULTIPLY	    equ 6Ah
VK_ADD		    equ 6Bh
VK_SEPARATOR	    equ 6Ch
VK_SUBTRACT	    equ 6Dh
VK_DECIMAL	    equ 6Eh
VK_DIVIDE	    equ 6Fh
VK_F1		    equ 70h
VK_F2		    equ 71h
VK_F3		    equ 72h
VK_F4		    equ 73h
VK_F5		    equ 74h
VK_F6		    equ 75h
VK_F7		    equ 76h
VK_F8		    equ 77h
VK_F9		    equ 78h
VK_F10		    equ 79h
VK_F11		    equ 7Ah
VK_F12		    equ 7Bh
VK_F13		    equ 7Ch
VK_F14		    equ 7Dh
VK_F15		    equ 7Eh
VK_F16		    equ 7Fh

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_CHANGE	    equ 0080h
MF_INSERT	    equ 0000h
MF_APPEND	    equ 0100h
MF_DELETE	    equ 0200h
MF_BYPOSITION	    equ 0400h
MF_BYCOMMAND	    equ 0000h
MF_GRAYED	    equ 0001h
MF_DISABLED	    equ 0002h
MF_ENABLED	    equ 0000h
MF_CHECKED	    equ 0008h
MF_BITMAP	    equ 0004h
MF_STRING	    equ 0000h
MF_POPUP	    equ 0010h
MF_DIVIDER	    equ 0020h
MF_BREAK	    equ 0040h

;
; Window Procedure Messages
;
WM_NULL 	    equ 0000h
WM_CREATE	    equ 0001h
WM_DESTROY	    equ 0002h
WM_BRUSHALIGN	    equ 0003h
WM_SIZEWAIT	    equ 0004h
WM_SIZE 	    equ 0005h
WM_ACTIVATE	    equ 0006h
WM_SETFOCUS	    equ 0007h
WM_KILLFOCUS	    equ 0008h
WM_SETVISIBLE	    equ 0009h
WM_ENABLE	    equ 000Ah
WM_SETREDRAW	    equ 000Bh
WM_SETTEXT	    equ 000Ch
WM_GETTEXT	    equ 000Dh
WM_GETTEXTLENGTH    equ 000Eh
WM_PAINT	    equ 000Fh
WM_CLOSE	    equ 0010h
WM_QUERYQUIT	    equ 0011h
WM_QUIT 	    equ 0012h
WM_QUERYOPEN	    equ 0013h
WM_ERASEBKGND	    equ 0014h
WM_SYSCOLORCHANGE   equ 0015h
WM_ENDSESSION	    equ 0016h
WM_SYSTEMERROR	    equ 0017h
WM_SHOWWINDOW	    equ 0018h
WM_CTLCOLOR	    equ 0019h
WM_WININICHANGE     equ 001Ah
WM_DEVMODECHANGE    equ 001Bh
WM_ACTIVATEAPP	    equ 001Ch

WM_QUEUESYNC	    equ 0023h
WM_SETFONT          equ 0030h
WM_GETFONT          equ 0031h

WM_WINDOWPOSCHANGING equ 0046h
WM_WINDOWPOSCHANGED equ 0047h

WM_NCCREATE	    equ 0081h
WM_NCDESTROY	    equ 0082h
WM_NCCALCSIZE	    equ 0083h
WM_NCHITTEST	    equ 0084h
WM_NCPAINT	    equ 0085h
WM_NCACTIVATE	    equ 0086h
WM_GETDLGCODE	    equ 0087h
WM_ENDDIALOG	    equ 0088h

WM_NCMOUSEMOVE	    equ 00A0h
WM_NCLBUTTONDOWN    equ 00A1h
WM_NCLBUTTONUP	    equ 00A2h
WM_NCLBUTTONDBLCLK  equ 00A3h
WM_NCRBUTTONDOWN    equ 00A4h
WM_NCRBUTTONUP	    equ 00A5h
WM_NCRBUTTONDBLCLK  equ 00A6h
WM_NCMBUTTONDOWN    equ 00A7h
WM_NCMBUTTONUP	    equ 00A8h
WM_NCMBUTTONDBLCLK  equ 00A9h

WM_KEYFIRST	    equ 0100h
WM_KEYLAST	    equ 0107h

WM_KEYDOWN	    equ 0100h
WM_KEYUP	    equ 0101h
WM_CHAR 	    equ 0102h
WM_DEADCHAR	    equ 0103h
WM_SYSKEYDOWN	    equ 0104h
WM_SYSKEYUP	    equ 0105h
WM_SYSCHAR	    equ 0106h
WM_SYSDEADCHAR	    equ 0107h

WM_INITDIALOG	    equ 0110h
WM_COMMAND	    equ 0111h
WM_SYSCOMMAND	    equ 0112h
WM_TIMER	    equ 0113h
WM_HSCROLL	    equ 0114h
WM_VSCROLL	    equ 0115h
WM_INITMENU	    equ 0116h
WM_INITMENUPOPUP    equ 0117h
WM_SYSTIMER	    equ 0118h

WM_MOUSEFIRST	    equ 0200h
WM_MOUSELAST	    equ 0209h

WM_MOUSEMOVE	    equ 0200h
WM_LBUTTONDOWN	    equ 0201h
WM_LBUTTONUP	    equ 0202h
WM_LBUTTONDBLCLK    equ 0203h
WM_RBUTTONDOWN	    equ 0204h
WM_RBUTTONUP	    equ 0205h
WM_RBUTTONDBLCLK    equ 0206h
WM_MBUTTONDOWN	    equ 0207h
WM_MBUTTONUP	    equ 0208h
WM_MBUTTONDBLCLK    equ 0209h
WM_DROPOBJECT       equ 022Ah
WM_QUERYDROPOBJECT  equ 022Bh
WM_BEGINDRAG	    equ 022Ch
WM_DRAGLOOP	    equ 022Dh
WM_DRAGSELECT	    equ 022Eh
WM_DRAGMOVE	    equ 022Fh
WM_DROPFILES	    equ 0233h

WM_CUT		    equ 0300h
WM_COPY 	    equ 0301h
WM_PASTE	    equ 0302h
WM_CLEAR	    equ 0303h
WM_UNDO 	    equ 0304h
WM_RENDERFORMAT     equ 0305h
WM_RENDERALLFORMATS equ 0306h
WM_DESTROYCLIPBOARD equ 0307h
WM_DRAWCLIPBOARD    equ 0308h
WM_PAINTCLIPBOARD   equ 0309h
WM_VSCROLLCLIPBOARD equ 030Ah
WM_SIZECLIPBOARD    equ 030Bh
WM_ASKCBFORMATNAME  equ 030Ch

WM_INTERNAL_COALESCE_FIRST equ 0390h	 ; internal

WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh

; The following message range reserved   ;Internal
; for multi-media                        ;Internal

WM_MM_RESERVED_FIRST  equ 03A0h    ;Internal
WM_MM_RESERVED_LAST   equ 03DFh    ;Internal

WM_INTERNAL_COALESCE_LAST equ (WM_MM_RESERVED_FIRST+16)	;internal

WM_INTERNAL_DDE_FIRST equ 03E0h    ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh    ;Internal

; The following messages are reserved for CBT ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h    ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh    ;Internal


WM_USER 	    equ 0400h

;
; System Menu Command Values
;
SC_SIZE 	    equ 0F000h
SC_MOVE 	    equ 0F010h
SC_ICON 	    equ 0F020h
SC_ZOOM 	    equ 0F030h
SC_NEXTWINDOW	    equ 0F040h
SC_PREVWINDOW	    equ 0F050h
SC_CLOSE	    equ 0F060h

;******** RedrawWindow() flags

RDW_INVALIDATE		equ 0001h   ; Invalidate
RDW_INTERNALPAINT	equ 0002h   ; Set WFINTERNALPAINT
RDW_ERASE		equ 0004h   ; Set WFSENDERASEBKGND

RDW_VALIDATE		equ 0008h   ; Validate
RDW_NOINTERNALPAINT	equ 0010h   ; Clear WFINTERNALPAINT
RDW_NOERASE		equ 0020h   ; Clear WFSENDERASEBKGND

RDW_NOCHILDREN		equ 0040h   ; Don't include children
RDW_ALLCHILDREN 	equ 0080h   ; Include all children

RDW_UPDATENOW		equ 0100h   ; Update the window now if needed
RDW_ERASENOW		equ 0200h   ; Erase the background now (implied by UPDATENOW)

; Internal-only RedrawWindow() flags
;
RDW_FRAME		equ 0400h   ; Set WFSENDNCPAINT
RDW_NOFRAME		equ 0800h   ; Clear WFSENDNCPAINT

RDW_REDRAWWINDOW	equ 1000h   ; Called from RedrawWindow()
RDW_SUBTRACTSELF	equ 2000h   ; Subtract self from hrgn

RDW_COPYRGN		equ 4000h   ; Copy the passed-in region

; WM_HOTKEYEVENT stuff

WM_HOTKEYEVENT          equ 0045h

endif ; !WOW

;
; SetWindowsHook() definitions
;
WH_MSGFILTER	    equ -1
WH_JOURNALRECORD    equ  0
WH_JOURNALPLAYBACK  equ  1
WH_KEYBOARD	    equ  2
WH_GETMESSAGE	    equ  3
WH_CALLWNDPROC	    equ  4
WH_CBT		    equ  5
WH_SYSMSGFILTER     equ  6
WH_MOUSE	    equ  7
WH_HARDWARE	    equ  8
WH_DEBUG	    equ  9
WH_SHELL            equ 10

ifndef WOW

;
; Standard hook code values
;
HC_GETLPLPFN	    equ -3
HC_LPLPFNNEXT	    equ -2
HC_LPFNNEXT	    equ -1
HC_ACTION	    equ  0
HC_GETNEXT	    equ  1
HC_SKIP 	    equ  2
HC_SYSMODALON	    equ  4
HC_SYSMODALOFF      equ  5

endif ; !WOW

; Lowest and highest valued windows hook IDs

WH_MINHOOK	    equ -1
WH_MAXHOOK	    equ 10
WH_CHOOKS	    equ (WH_MAXHOOK - WH_MINHOOK + 1)

HOOKNODE struc
    hkPhkNext	    dw ?
    hkLpfn	    dd ?
    hkIdHook	    dw ?
    hkHq	    dw ?
    hkHmodOwner     dw ?
    hkFCalled	    dw ?
HOOKNODE ends

HHOOK_MAGIC	    equ ('H' or ('K' * 256))

; SetHotKeyHook() definitions

HOTKEYHOOK  struc
    hkhPfn     dd  ?
    hkhHmodule dw  ?
HOTKEYHOOK  ends

CHOTKEYHOOKMAX	 equ 16

ifndef NOEXTERNS
sBegin	DATA

ifndef WOW
ExternW rgphkSysHooks
endif

sEnd    DATA
endif ;NOEXTERNS

MAX_SEB_STYLES equ 8  ; number of SEB_* values

SEB_OK         equ 1  ; Button with "OK".
SEB_CANCEL     equ 2  ; Button with "Cancel"
SEB_YES        equ 3  ; Button with "&Yes"
SEB_NO         equ 4  ; Button with "&No"
SEB_RETRY      equ 5  ; Button with "&Retry"
SEB_ABORT      equ 6  ; Button with "&Abort"
SEB_IGNORE     equ 7  ; Button with "&Ignore"
SEB_CLOSE      equ 8  ; Button with "Close"

SEB_DEFBUTTON  equ 8000h  ;Mask to make this button default

SEB_BTN1       equ 1  ; Button 1 was selected
SEB_BTN2       equ 2  ; Button 1 was selected
SEB_BTN3       equ 3  ; Button 1 was selected

;
; InvalidateDCCache() flags
;
IDC_DEFAULT         equ 0001h
IDC_CHILDRENONLY    equ 0002h
IDC_CLIENTONLY      equ 0004h

;
; Window field offsets for GetWindowLong() and GetWindowWord()
;
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

;
; Class field offsets for GetClassLong() and GetClassWord()
;
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)
GCW_ATOM          =  (-32)

;
; CTLCOLOR_* for the message WM_CTLCOLOR.
;
CTLCOLOR_MSGBOX     equ 0
CTLCOLOR_EDIT	    equ 1
CTLCOLOR_LISTBOX    equ 2
CTLCOLOR_BTN	    equ 3
CTLCOLOR_DLG	    equ 4
CTLCOLOR_SCROLLBAR  equ 5
CTLCOLOR_MAX	    equ 8	  ; 3 bits max

DLGC_WANTARROWS     equ 01h
DLGC_HASSETSEL	    equ 08h
DLGC_WANTCHARS	    equ 80h

SUENUMCHILDREN	    equ 0001h
SUPAINTFRAME	    equ 0002h
SUSTOPCLIPCHILDREN  equ 0004h
SUVALIDATE	    equ 8000h

MB_OKCANCEL         equ 00001h
MB_ICONHAND	    equ 00010h
MB_SYSTEMMODAL	    equ 01000h



ASMSYSCLROBJECTS  struc
    syshbrScrollbar         dw ?
    syshbrDesktop           dw ?
    syshbrActiveCaption     dw ?
    syshbrInactiveCaption   dw ?
    syshbrMenu              dw ?
    syshbrWindow            dw ?
    syshbrWindowFrame       dw ?
    syshbrMenuText          dw ?
    syshbrWindowText        dw ?
    syshbrCaptionText       dw ?
    syshbrActiveBorder      dw ?
    syshbrInactiveBorder    dw ?
    syshbrAppWorkspace      dw ?
    syshbrHiliteBk          dw ?
    syshbrHiliteText        dw ?
    syshbrBtnFace           dw ?
    syshbrBtnShadow         dw ?
    syshbrGrayText          dw ?
ASMSYSCLROBJECTS  ends


ASMSYSCOLORS   struc
    sysclrScrollbar         dd ?
    sysclrDesktop           dd ?
    sysclrActiveCaption     dd ?
    sysclrInactiveCaption   dd ?
    sysclrMenu              dd ?
    sysclrWindow            dd ?
    sysclrWindowFrame       dd ?
    sysclrMenuText          dd ?
    sysclrWindowText        dd ?
    sysclrCaptionText       dd ?
    sysclrActiveBorder      dd ?
    sysclrInactiveBorder    dd ?
    sysclrAppWorkspace      dd ?
    sysclrHiliteBk          dd ?
    sysclrHiliteText        dd ?
    sysclrBtnFace           dd ?
    sysclrBtnShadow         dd ?
    sysclrGrayText          dd ?
ASMSYSCOLORS   ends

SCREEN	struc
    scrncy		dw ?
    scrncx		dw ?
    scrnrc		db size RECT dup(?)
    scrncLock		dw ?
    scrncclm		dw ?
    scrncclmSave	dw ?
    scrncwnd		dw ?
SCREEN	ends

;
; Property List structures
;
PROP    struc
    propAtom        dw  0
    propValue       dw  0
PROP    ends

PROPTABLE struc
    proptabCprop    dw  0
    proptabRgprop   db size PROP dup(?)
PROPTABLE ends

;*--------------------------------------------------------------------------*
;*									    *
;*  Window Class Structures and Defines 				    *
;*									    *
;*--------------------------------------------------------------------------*

WNDCLASS struc
    clsStyle		dw ?	   ; Class style
    clsLpfnWndProc	dd ?
    clsCbClsExtra	dw ?
    clsCbWndExtra	dw ?
    clsHInstance	dw ?	   ; Instance handle
    clsHIcon		dw ?	   ; Class icon handle
    clsHCursor		dw ?	   ; Class cursor handle
    clsHbrBackground	dw ?	   ; Class background brush
    clsLpszMenuName	dd ?	   ; Menu name
    clsLpszClassName	dd ?	   ; Far ptr to class name
WNDCLASS ends

WNDSTRUC struc
    WSwndStyle		dd ?
    WSwndID		dw ?
    WSwndText		dw ?
    WSwndParent 	dw ?
    WSwndInstance	dw ?
    WSwndClassProc	dd ?
WNDSTRUC ends

;
; Window Styles (high words only)
;
WS_TILED		equ 0000h
WS_POPUP		equ 8000h
WS_CHILD		equ 4000h
WS_ICONIC		equ 2000h
WS_VISIBLE		equ 1000h
WS_DISABLED		equ 0800h
WS_CLIPSIBLINGS 	equ 0400h
WS_CLIPCHILDREN 	equ 0200h
WS_COLUMN		equ 0100h

WS_BORDER		equ 0080h
WS_CAPTION		equ 0040h
WS_VSCROLL		equ 0020h
WS_HSCROLL		equ 0010h
WS_SYSMENU		equ 0008h
WS_SIZEBOX		equ 0004h
WS_GROUP		equ 0002h
WS_TABSTOP		equ 0001h

;
; Class Styles
;
CS_VREDRAW		equ 0001h
CS_HREDRAW		equ 0002h
CS_KEYCVTWINDOW 	equ 0004h
CS_DBLCLKS		equ 0008h
CS_OEMCHARS		equ 0010h
CS_OWNDC		equ 0020h
CS_CLASSDC		equ 0040h
CS_PARENTDC		equ 0080h
CS_NOKEYCVT		equ 0100h
CS_LVB			equ 0400h
CS_SAVEPOPUPBITS	equ 0800h
CS_GLOBALCLASS		equ 4000h


;
; WinWhere Area Codes
;
HTTRANSPARENT		equ -1
HTNOWHERE		equ 0
HTCLIENT		equ 1
HTCAPTION		equ 2
HTCLOSEBOX		equ 3
HTGROWBOX		equ 4
HTMENU			equ 5
HTHSCROLL		equ 6
HTVSCROLL		equ 7

;*--------------------------------------------------------------------------*
;*  Message Structures and Defines					    *
;*--------------------------------------------------------------------------*

;
; Message Structure
;
MSG	struc
    msgHwnd	    dw ?
    msgMessage	    dw ?
    msgWParam	    dw ?
    msgLParam	    dd ?
    msgTime	    dd ?
    msgPt	    dd ?
MSG	ends

INTERNALMSG  struc
    imExtraMsgInfo  dd   ?
    imMsg           db   size MSG  dup (?)
INTERNALMSG  ends

;
; System Queue Message Structure
;
SYSMSG	struc
    smParamL	    dw ?
    smMessage	    dw ?
    smParamH	    dw ?
    smTime	    dd ?
SYSMSG	ends

INTERNALSYSMSG	struc
    ismExtraMsgInfo dd ?
    ismMsg	    db  size SYSMSG dup (?)
INTERNALSYSMSG  ends

; GetQueueStatus bits.

QS_KEY		  equ 0001h	; WM_KEY/SYSKEYUP/DOWN
QS_MOUSEMOVE	  equ 0002h	; WM_MOUSEMOVE
QS_MOUSEBUTTON	  equ 0004h	; WM_NC/L/R/MBUTTONUP/DOWN/DBLCLK
QS_MOUSE	  equ (QS_MOUSEMOVE or QS_MOUSEBUTTON)	  ; Any mouse event
QS_POSTMESSAGE	  equ 0008h	; Message posted with PostMessage()
QS_TIMER	  equ 0010h	; WM_TIMER
QS_PAINT	  equ 0020h	; WM_PAINT
QS_SENDMESSAGE	  equ 0040h	; Pending SendMessage() calls from other app
ifdef DISABLE
QS_HOTKEYEVENT	  equ 0080h	; WM_HOTKEYEVENT (WIN 3.1 ONLY)
endif

; Internal values

QS_SMRESULT	  equ 8000h
QS_SMPARAMSFREE   equ 4000h

QS_INPUT	  equ (QS_MOUSEMOVE or QS_MOUSEBUTTON or QS_KEY)

ifdef DISABLE
QS_ALLINPUT	  equ (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT or QS_HOTKEYEVENT)
else
QS_ALLINPUT	  equ (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT)
endif

; Q flags field values

QF_SEMWAIT	    equ 01h
QF_INIT 	    equ 02h
QF_PALETTEAPP       equ 04h

;
; Queue Structure
;
Q	struc
    qHqNext	    dw ?
    qHTask	    dw ?
    qCbEntry	    dw ?
    qCMsgs	    dw ?
    qPmsgRead	    dw ?
    qPmsgWrite	    dw ?
    qPmsgMax	    dw ?
    qTimeLast	    dd ?
    qPtLast	    dd ?
    qIdLast	    dw ?
    qdwExtraInfoLast dd ?
    qUnused	    dw ?
    qMsgLParam	    dd ?
    qMsgWParam	    dw ?
    qMsgMessage     dw ?
    qMsgHwnd	    dw ?
    qResult	    dd ?

    qCQuit	    dw ?
    qExitCode	    dw ?
    qFlags	    dw ?
    qpMsgFilterChain  dw ?	; Near Ptr to the head of the hook chain
    qHDS	    dw ?
    qWVersion	    dw ?
    qHqSender	    dw ?	; New Input Stuff starts here
    qHqSendList     dw ?
    qHqSendNext     dw ?
    qCPaintsReady   dw ?
    qCTimersReady   dw ?
    qChangeBits     dw ?
    qWakeBits	    dw ?
    qWakeMask	    dw ?
    qPResult	    dw ?
    qPResultSend    dw ?
    qPResultReceive dw ?
    qPhkCurrent     dw ?
    qRgphkHooks     dw WH_CHOOKS dup (?)
    qSemInput	    dd ?
    qHqSemNext	    dw ?
    qRgmsg	    db size INTERNALMSG dup (?)
Q	ends

;
; Timer Structure
;
TIMER	struc
    tmrHq	    dw ?
    tmrHwnd	    dw ?
    tmrID	    dw ?
    tmrCount	    dw ?
    tmrRate	    dw ?
    tmrFSys	    db ?
    tmrReady	    db ?
    tmrLpfn	    dd ?
TIMER	ends

CPUBLICTIMERS	    equ 32
CSYSTEMTIMERS	    equ 2
CTIMERSMAX	    equ CPUBLICTIMERS + CSYSTEMTIMERS

ifndef WOW

; GetSystemMetrics() codes.
SM_CXSCREEN	     equ 0
SM_CYSCREEN	     equ 1
SM_CXVSCROLL	     equ 2
SM_CYHSCROLL	     equ 3
SM_CYCAPTION	     equ 4
SM_CXBORDER	     equ 5
SM_CYBORDER	     equ 6
SM_CXDLGFRAME	     equ 7
SM_CYDLGFRAME	     equ 8
SM_CYVTHUMB	     equ 9
SM_CXHTHUMB	     equ 10
SM_CXICON	     equ 11
SM_CYICON	     equ 12
SM_CXCURSOR	     equ 13
SM_CYCURSOR	     equ 14
SM_CYMENU	     equ 15
SM_CXFULLSCREEN      equ 16
SM_CYFULLSCREEN      equ 17
SM_CYKANJIWINDOW     equ 18
SM_MOUSEPRESENT      equ 19
SM_CYVSCROLL	     equ 20
SM_CXHSCROLL	     equ 21
SM_DEBUG	     equ 22
SM_SWAPBUTTON	     equ 23
SM_RESERVED1	     equ 24
SM_RESERVED2	     equ 25
SM_RESERVED3	     equ 26
SM_RESERVED4	     equ 27
SM_CXMIN	     equ 28
SM_CYMIN	     equ 29
SM_CXSIZE	     equ 30
SM_CYSIZE	     equ 31
SM_CXFRAME	     equ 32
SM_CYFRAME	     equ 33
SM_CXMINTRACK	     equ 34
SM_CYMINTRACK	     equ 35
SM_CXDOUBLECLK       equ 36
SM_CYDOUBLECLK       equ 37
SM_CXICONSPACING     equ 38
SM_CYICONSPACING     equ 39
SM_MENUDROPALIGNMENT equ 40
SM_PENWINDOWS        equ 41
SM_DBCSENABLED       equ 42
SM_CMETRICSMAX	     equ 43

IFNDEF  NOCOLOR
; System colors
COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
COLOR_MAX                 = 20

ENDIF   ;NOCOLOR

; DrawFrame commands
DF_SHIFT0           equ 0000h
DF_SHIFT1           equ 0001h
DF_SHIFT2           equ 0002h
DF_SHIFT3           equ 0003h
DF_PATCOPY          equ 0000h
DF_PATINVERT        equ 0004h

DF_SCROLLBAR	    equ (COLOR_SCROLLBAR * 8)
DF_BACKGROUND	    equ (COLOR_BACKGROUND * 8)
DF_ACTIVECAPTION    equ (COLOR_ACTIVECAPTION * 8)
DF_INACTIVECAPTION  equ (COLOR_INACTIVECAPTION * 8)
DF_MENU		    equ (COLOR_MENU * 8)
DF_WINDOW	    equ (COLOR_WINDOW * 8)
DF_WINDOWFRAME	    equ (COLOR_WINDOWFRAME * 8)
DF_MENUTEXT	    equ (COLOR_MENUTEXT * 8)
DF_WINDOWTEXT	    equ (COLOR_WINDOWTEXT * 8)
DF_CAPTIONTEXT	    equ (COLOR_CAPTIONTEXT * 8)
DF_ACTIVEBORDER	    equ (COLOR_ACTIVEBORDER * 8)
DF_INACTIVEBORDER   equ (COLOR_INACTIVEBORDER * 8)
DF_APPWORKSPACE	    equ (COLOR_APPWORKSPACE * 8)
DF_GRAY             equ (DF_APPWORKSPACE + (1 * 8))
endif ; !WOW

ifndef NOEXTERNS
;*--------------------------------------------------------------------------*
;*  Externs for the Interrupt Level Global Variables                        *
;*--------------------------------------------------------------------------*

; This file is included to access intrerrupt variables. It declares them in
; the right segment, externs [csds], the variable that has the segment
; that these variables will be in, and assumes ds to the CODE segment

createSeg _INTDS, INTDS, BYTE, PUBLIC, DATA

sBegin INTDS

ifndef WOW
ExternB fDontMakeAltUpASysKey
ExternD hwEventHook
ifdef userhimem
ExternW fffedelta
endif
ExternW msgJournal
ExternD dtJournal
ExternD ptTrueCursor
ExternD dwMouseMoveExtraInfo
ExternD ptCursor
ifdef DOS30
ExternD lpSysProc
endif
ExternW hqActive
ExternW hqCapture
ExternW hqMouse
ExternW hqKeyboard
endif ; !WOW
ExternW hqList
ExternW hqSysQueue
ExternW hqSysModal
ExternW cQEntries
ifndef WOW
ExternW fMouseMoved
;; ExternB fAltKeyUp
ExternB rgbAsyncKeyState
ExternW fEnableInput
ExternW fSwapButtons
endif ; !WOW
ExternW hqCursor
ifndef WOW
ExternW cMsgRsrv
ExternB vKeyDown
ExternD timerInfo
ExternB TimerTable
ExternW TimerTableMax
ExternW hSysTimer
ExternD tSysTimer
ExternW dtSysTimer
ExternB fInScanTimers
endif ; !WOW
ExternW szDivZero
ExternW szSysError
ifndef WOW
ExternW x_mickey_rate
ExternW y_mickey_rate
ExternW cur_x_mickey
ExternW cur_y_mickey
ExternW rcCursorClip
ExternW cxScreenCS
ExternW cyScreenCS
ExternW MouseThresh1
ExternW MouseThresh2
ExternW MouseSpeed
ifndef PMODE
ExternD lpMouseStack
ExternD prevSSSP
ExternB NestCount
endif
ExternW hqSysLock
ExternW idSysLock

ExternW fJournalPlayback
endif ; !WOW

sEnd INTDS

endif


ifndef WOW
;*--------------------------------------------------------------------------*
;*  OEM Inquire Structures for Timer, Keyboard, Mouse, and Cursor modules   *
;*--------------------------------------------------------------------------*

STIMERINFO  struc
    tiResolution    dd 0    ; #microseconds each timer tick
STIMERINFO  ends

SKBINFO     struc
    kbBegin1	    db 0    ; some range values for the East Asia
    kbEnd1	    db 0
    kbBegin2	    db 0
    kbEnd2	    db 0
    kbStateSize     dw 0    ; #bytes of state info maintained by TOASCII
SKBINFO     ends

SMOUSEINFO  struc
    msExists	    db 0    ; true => mouse exists
    msRelative	    db 0    ; true => relative coordinate
    msNumButtons    dw 0    ; number of buttons on the mouse
    msRate	    dw 0    ; maximum rate of mouse input events
    msXThresh	    dw 0    ; threshold before acceleration
    msYThresh	    dw 0    ;
    msXRes	    dw 0    ; x resolution
    msYRes	    dw 0    ; y resolution
SMOUSEINFO  ends

SCURSORINFO struc
    dpXRate	    dw 0    ; horizontal mickey/pixel ratio
    dpYRate	    dw 0    ; vertical mickey/pixel ratio
    dpXMask	    dw 0
    dpYMask	    dw 0
    dpXCurSize	    dw 0
    dpYCurSize	    dw 0
    dpXIcoSize	    dw 0
    dpYIcoSize	    dw 0
SCURSORINFO ends

;
; OEM Info Structures
;

OEMBITMAPINFO struc
    oemhBitmap	    dw ?
    oemwidth	    dw ?
    oemheight	    dw ?
OEMBITMAPINFO ends

OEMSINFO    struc
    oembmFull	    	db size OEMBITMAPINFO dup(?)
    oembmUpArrow    	db size OEMBITMAPINFO dup(?)
    oembmDnArrow    	db size OEMBITMAPINFO dup(?)
    oembmRgArrow    	db size OEMBITMAPINFO dup(?)
    oembmLfArrow    	db size OEMBITMAPINFO dup(?)
    oembmReduce	    	db size OEMBITMAPINFO dup(?)
    oembmZoom	    	db size OEMBITMAPINFO dup(?)
    oembmRestore    	db size OEMBITMAPINFO dup(?)
    oembmMenuArrow  	db size OEMBITMAPINFO dup(?)
    oembmComboArrow 	db size OEMBITMAPINFO dup(?)
    oembmReduceD    	db size OEMBITMAPINFO dup(?)
    oembmZoomD	    	db size OEMBITMAPINFO dup(?)
    oembmRestoreD   	db size OEMBITMAPINFO dup(?)
    oembmUpArrowD   	db size OEMBITMAPINFO dup(?)
    oembmDnArrowD   	db size OEMBITMAPINFO dup(?)
    oembmRgArrowD   	db size OEMBITMAPINFO dup(?)
    oembmLfArrowD   	db size OEMBITMAPINFO dup(?)
    oemcxHThumb     	dw ?
    oemcyVVThumb    	dw ?
    oemcxMin	    	dw ?
    oemcyMin	    	dw ?
    oemcxIconSlot   	dw ?
    oemcyIconSlot   	dw ?
    oemcxIcon	    	dw ?
    oemcyIcon	    	dw ?
    oemcxPixelsPerInc   dw ?
    oemcyPixelsPerInch  dw ?
    oemcxCursor     	dw ?
    oemcyCursor     	dw ?
    oemDispDrvExpWinVer dw ?
    oemScreenBitCount   dw ?
    oemcSKanji	    	dw ?
    oemfMouse	    	dw ?
OEMSINFO    ends

OEMSINFOMONO	struc
    oembmAdjust     db size OEMBITMAPINFO dup(?)
    oembmSize	    db size OEMBITMAPINFO dup(?)
    oembmCheck	    db size OEMBITMAPINFO dup(?)
    oembmbtnbmp     db size OEMBITMAPINFO dup(?)
    oembmCorner	    db size OEMBITMAPINFO dup(?)
    oemcxbmpChk     dw ?
    oemcybmpChk     dw ?
OEMSINFOMONO	ends
endif ; !WOW


;*--------------------------------------------------------------------------*
;*  Debugging Defines							    *
;*--------------------------------------------------------------------------*

;
; RIP codes
;
RIP_CHECKDC		equ 0FFF2h    ; decimal -14
RIP_WLSINSEM		equ 0FFF3h    ; decimal -13
RIP_CHECKSEM		equ 0FFF4h    ; decimal -12
RIP_SENDMESSAGEINSEM	equ 0FFF5h    ; decimal -11
RIP_SEMNOTINORDER	equ 0FFF6h    ; decimal -10
RIP_RWLEAVEUNDERFLOW	equ 0FFF7h    ; decimal -9

RIP_WINDOWLEFTLOCKED	equ 0FFF9h    ; decimal -7 ; hq->cLock !equ 0 in GetMessage.
RIP_BADLOCKWINDOW	equ 0FFFAh    ; decimal -6 ; Window passed was NULL.
RIP_LOCKUNDERFLOW	equ 0FFFBh    ; decimal -5 ; Too many UnlockWindows.
RIP_INSEMAPHORE 	equ 0FFFCh    ; decimal -4
RIP_BADSEMCLEAR 	equ 0FFFDh    ; decimal -3
RIP_BADLOCKCOUNT	equ 0FFFEh    ; decimal -2
RIP_MEMALLOC		equ 1
RIP_MEMREALLOC		equ 2
RIP_MEMFREE		equ 3
RIP_MEMLOCK		equ 4
RIP_MEMUNLOCK		equ 5
RIP_SENDMESSAGELOCK	equ 6
RIP_BADWINDOWHANDLE	equ 7
RIP_DCBUSY		equ 8
RIP_NODEFWINDOWPROC	equ 9
RIP_CLIPBOARDOPEN	equ 000Ah
RIP_DCCAHCHEFULL        equ 000Bh
RIP_INVALKEYBOARD	equ 000Ch
RIP_INVALMOUSE		equ 000Dh
RIP_INVALCURSOR 	equ 000Eh
RIP_DSUNLOCKED		equ 000Fh
RIP_INVALLOCKSYSQ	equ 0010h
RIP_CARETBUSY		equ 0011h
RIP_GETCWRANGE		equ 0012h
RIP_HWNDOWNSDCS 	equ 0013h	      ; One hwnd owns all the DCs.
RIP_BADHQ		equ 0014h	      ; Operation on something of wrong task
RIP_NOQUEUE		equ 0019h	      ; GetAppVer() is called before queues are
				      	      ; created.
RIP_BADHOOKHANDLE	equ 001Bh
RIP_BADHOOKID		equ 001Ch
RIP_BADHOOKPROC 	equ 001Dh
RIP_BADHOOKMODULE	equ 001Eh
RIP_BADHOOKCODE 	equ 001Fh
RIP_HOOKNOTALLOWED	equ 0020h
RIP_UNREMOVEDPROP	equ 0021h
RIP_BADPROPNAME 	equ 0022h

RIP_BADTASKHANDLE	equ 0025h

RIP_GETSETINFOERR1	equ 0027h	      ; Bad negative index for Get/Set/Window etc.,
RIP_GETSETINFOERR2      equ 0028h        ; Bad Positive index for Get/Set/Window etc.,

RIP_WINDOWIDNOTFOUND    equ 002Ah        ; Dialog control ID not found
RIP_SYSTEMERRORBOXFAILED equ 002Bh       ; Hard sys error box failed due to no hq
RIP_INVALIDMENUHANDLE   equ 002Ch         ; Invalid menu handle

RIP_MESSAGEBOXWITHNOQUEUE equ 002Eh      ; Message box called with no message queue initialized
RIP_DLGWINDOWEXTRANOTALLOCATED equ 002Fh ; DLGWINDOWEXTRA bytes not allocated for dlg box
RIP_INTERTASKSENDMSGHANG       equ 0030h ; Intertask send message with tasks locked
RIP_INVALIDPARAM               equ 0031h
RIP_ASSERTFAILED               equ 0032h
RIP_INVALIDFUNCTIONCALLED      equ 0033h
RIP_LOCKINPUTERROR             equ 0034h
RIP_NULLWNDPROC		       equ 0035h ; SetWindowLong uses a NULL wnd proc
RIP_BAD_UNHOOK		       equ 0036h ; SetWindowsHook is called to unhook.
RIP_QUEUE_FULL                 equ 0037h ; PostMessage failed due to full queue.

;
; DebugErr() macro
;
ifdef DEBUG

ifndef winmisc1
externFP    DebugOutput,<C>
endif

DebugErr    macro   flags,msg
        local   a,b
        push    cs
        push    offset a
        push    flags or DBF_USER
        cCall   DebugOutput
        add     sp,2+4      ; DebugOutput is cdecl!
        jmp     short b
a:
        db      "USER: "
        db      msg
        db      0
b:
endm

else    ; DEBUG

DebugErr    macro   flags,msg
endm

endif   ; DEBUG

externFP	LogError

include		LogError.inc

UserLogError    macro flags,errcode,msg
        DebugErr <flags>,<msg>
        push    errcode
	push	0
	push	0
        call    LogError
endm

;
; Fast, inline check for valid window.
; NOTE: MUST BE USED INSIDE beg_fault_trap/end_fault_trap
;
FastIsWindow    macro   seg,reg
        mov     reg,seg:[reg].wndPcls
        cmp     seg:[reg].uclsMagic,CLS_MAGIC
        endm

;*--------------------------------------------------------------------------*
;*  Utility Macros							    *
;*--------------------------------------------------------------------------*

; Similar to LabelFP, except used for "validate in debug only" entry points.
; Declares Iname if debug, name if
;
LabelVDO macro  name
  ifdef DEBUG
        LabelFP <PUBLIC, I&name>
  else
        LabelFP <PUBLIC, I&name>
        LabelFP <PUBLIC, name>
  endif
endm

; Same as cProc, except used for "Validate in Debug Only" entry points.
; Declares Iname if debug, name if retail.
;
cProcVDO macro  name,opts,savelist
  ifdef DEBUG
        cProc   <I&name>,<opts>,<savelist>
  else
        LabelFP <PUBLIC, I&name>
        cProc   <name>,<opts>,<savelist>
  endif
endm

;
; EatTwoBytes macro
;
EatTwoBytes macro
	db	0A9h	;; Opcode for CMP AX,(immediate word)
	endm

;
; Push DWORD macro
;
pushd   macro   d
        push    word ptr (d)+2
        push    word ptr (d)
	endm
;
; Call an internal far entry point
;
wcall   macro   adr
        push    cs
        call    near ptr (adr)
	endm

;
; Short jump macro
;
jmps    macro   adr
        jmp     short (adr)
	endm

;
; XMOV macro
;
;   Use instead of MOV ax,reg.	Saves a byte.
;
xmov	macro	a,b
	xchg	a,b
	endm

ifndef WOW
;----------------------------------------------------------------------------
; New set of Critical Region Macros
;     The necessity for new set of macros is
;     1. We need to avoid "cli" if it is already disabled (saves 300 cycles
;        under 386pmode because "cli" and "sti" are simulated by Windows).
;     2. PostMessage() might be called with interrupts already disabled; so,
;        we should not blindly do a "sti" when we do LeaveCrit
;  WARNINGS:
;     1. These two macros must be properly nested.
;----------------------------------------------------------------------------
;  WARNINGS for NewEnterCrit:
;     (1) This trashes the zero flag.
;     (2) This trashes the register that is passed as the parameter; 
;     (3) It pushes flags onto stack which will be popped up by NewLeaveCrit
;----------------------------------------------------------------------------
NewEnterCrit   macro   Reg
	LOCAL	SkipCli	   ;; Declare symbol for macro
	pushf		   ;; Save flags on stack for the use of NewLeaveCrit
	pushf	
	pop	Reg	   ;; Load flags into BX register
	test    Reg, 0200h ;; see if interrupts are already disabled
	jz	SkipCli	   ;; Skip doing a "cli" and save 300 cycles!!!
        FCLI                ;; We have to clear the interrupts
SkipCli:
	endm
;----------------------------------------------------------------------------
; WARNINGS for NewLeaveCrit:
;    (1) This preserves the Z flag.
;    (2) This trashes the registers that are passed as the parameters;
;    (3) It pops the flags pushed by NewEnterCrit.
;   NOTE: It is much easier to use pushf and popf combination to preserve
;         the Z flag, but 286 processors have a bug which results in the 
;         interrupts enabled irrespect of the state of the flag before and
;         after the popf; That is why we do not use popf anywhere in this
;         macro;
;----------------------------------------------------------------------------
NewLeaveCrit    macro   Reg, ZFlagReg
	LOCAL	SkipSti    ;; Declare symbol for Macro
	pushf  		   ;; To save the Z flag
	pop	ZFlagReg   ;; Save the Z flag
	pop	Reg	   ;; pop flags pushed by NewEnterCrit
	test	Reg, 0200h ;; see if interrupts were disabled even 
			   ;; before entering the critical region
	jz	SkipSti	   ;; Skip doing a "sti".
        FSTI
SkipSti:
	not	ZFlagReg
	test    ZFlagReg, 0040h  ;; Restore Z flag to the value before
				 ;; entering NewLeaveCrit
	endm

endif ; !WOW

;
; Old Critical Region macros
;
EnterCrit   macro
        FCLI
	endm

LeaveCrit   macro
        FSTI
	endm


ifndef WOW
;
;   AllocP	Macro
;
;   Caution: You can not use ax regiter as a parameter for this Macro!
;

AllocP	macro	wType, cb
ifdef  DEBUG
ifndef winmisc1
	mov	ax, wType
	push	ax
endif
endif
	push	LPTR
	push	cb
	call	LocalAlloc
	endm


;
; AllocH Macro
;
; CAUTION:  You can NOT use ax register as a parameter for this MACRO!
;
AllocH	macro	wType, cb
ifdef DEBUG
ifndef winmisc1
	push	wType
endif
endif
	push	LHND
	push	cb
	call	LocalAlloc
	endm

FreeP	macro	Ptr
	push	Ptr
	call	LocalFree
	endm

;
; ReAllocH Macro
;
ReAllocH macro	h, cb
	push	h
	push	cb
	push	LMEM_ZEROINIT
	call	LocalReAlloc
	endm

;
; FreeH Macro
;
FreeH	macro	h
	push	h
	call	LocalFree
	endm

;
; LockH is assumed to preserve all registers (except flags)
;
LockH	macro	h, p
	inc	byte ptr [h+3]
        mov     p,[h]
	endm

;
; UnlockH is assumed to preserve all registers (except flags)
;
UnlockH macro   h
	dec	byte ptr [h+3]
        endm
endif ; !WOW


ifndef WOW
;----------------------------------------------------------------------------
;  GetES
;	This macro gets the current value of USER's data segment and loads it
;	into ES register.
;  NOTE: This Macro might destroy the AX register.
;----------------------------------------------------------------------------

UserDStoES  macro
	mov	ax,_DATA
	mov	es,ax
	    endm

UserDStoDS  macro
	mov	ax,_DATA
	mov	ds,ax
	    endm

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_WIN286       =    0010h
WF_WIN386       =    0020h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
endif ; !WOW

endif	; LAYER_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   USER.ASM
;   Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;
;--

    TITLE   USER.ASM
    PAGE    ,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
        LIBINIT equ 1

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1     ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

    __acrtused = 0
    public  __acrtused  ;satisfy external C ref.

ifdef LIBINIT
externFP LocalInit
endif
externFP  LW_InitNetInfo
ifndef WOW
externNP  LW_DriversInit
endif

externFP    GetModuleHandle
externFP    SetTaskSignalProc
externFP    NewSignalProc
externFP    IsWindow
externFP    CreateQueue
externFP    WOW16Call
externFP    TileWindows
externFP    CascadeWindows

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  DATA
DontMove    db  2 dup (0)   ; <<< WARNING 2 bytes *must* be reserved at the start
                ; users DS for compatability >>>>
Reserved    db  16 dup (0)  ;reserved for Windows
USER_Identifier db  'USER16 Data Segment'
fFirstApp   db  1

externD     LPCHECKMETAFILE;
ExternW  <hInstanceWin>
ExternW  <hWinnetDriver>

GlobalW     hwndSysModal,0

sEnd    DATA

;
; GP fault exception handler table definition
;
sBegin  GPFIX0
__GP    label   word
public __GP
sEnd    GPFIX0


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

ifdef LIBINIT
externFP LibMain
endif

ifdef WOW
externFP EnableSystemTimers
externFP SetDivZero
endif

cProc   USER16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

    cBegin <nogen>

ifdef WOW
    call EnableSystemTimers
endif

    IFDEF   LIBINIT
    ; push params and call user initialisation code

    push di         ;hModule
    mov  hInstanceWin, di

    ; if we have a local heap declared then initialize it

    jcxz no_heap

    push 0          ;segment
    push 0          ;start
    push cx         ;length
    call LocalInit

no_heap:
    call LibMain        ;return exit code from LibMain
    ELSE
    mov  ax,1       ;are we dressed for success or WHAT?!
    ENDIF
    push ax
    cmp  hInstanceWin, 0
    jne  hInstNotNull
    mov  hInstanceWin, di

hInstNotNull:
ifndef WOW
    call LW_DriversInit
endif
    pop  ax

    ret
    cEnd <nogen>

cProc   InitApp,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   hInst       ; App's hInstance

    cBegin

    mov     ax,8               ; MAGIC Win3.1 default message queue size
    push    ax                 ; NOTE Win3.1 (and User32) read the size
    call    CreateQueue        ; from win.ini, we don't.
    cmp     ax,0               ; hq
    jne     IA_HaveQ
    mov     ax,0               ; return FALSE
    jmp     IA_Ret

IA_HaveQ:
    push    ds

    mov     ax, _DATA          ; set USER16's DS
    mov     ds,ax
assumes ds, DATA

    xor     dx,dx
    push    dx
    push    seg NewSignalProc
    push    offset NewSignalProc
    call    SetTaskSignalProc
;
; Init WNET apis.
;
    cmp     fFirstApp, 1
    jne     IA_notfirstapp
    mov     fFirstApp, 0
    call    LW_InitNetInfo

IA_notfirstapp:

;
;   Setup Divide By Zero handler
;
    call    SetDivZero

    mov     ax,1
    xor     dx,dx

    pop     ds
IA_Ret:
    cEnd


assumes DS,NOTHING

cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   iExit       ;DLL exit code

    cBegin
    mov ax,1        ;always indicate success
    cEnd

;*--------------------------------------------------------------------------*
;*
;*  LFillStruct() -
;*
;*--------------------------------------------------------------------------*

cProc LFillStruct, <PUBLIC, FAR, NODATA, ATOMIC>,<di>
parmD lpStruct
parmW cb
parmW fillChar
cBegin
        les     di,lpStruct
        mov     cx,cb
        mov     ax,fillChar
        cld
    rep stosb
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetSysModalWindow() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetSysModalWindow, <PUBLIC, FAR>
cBegin nogen
        mov     ax,_DATA
        nop
        mov     es,ax
        mov     ax,es:[hwndSysModal]
        or      ax,ax
        jz      GSMW_ItsZero

        push    es
        push    ax                      ; make sure we only return valid
        call    IsWindow                ; windows.
        pop     es
        or      ax,ax
        jnz     GSMW_ItsNotZero
        mov     es:[hwndSysModal], ax   ; zero out hwndSysModal

GSMW_ItsNotZero:
        mov     ax,es:[hwndSysModal]

GSMW_ItsZero:
        retf
cEnd nogen

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  SetSysModalWindow() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc ISetSysModalWindow, <PUBLIC, FAR>
ParmW hwnd
cBegin nogen
        mov     ax,_DATA
        nop
        mov     es,ax
        mov     bx,sp
        mov     ax,ss:[bx+4]
        xchg    ax,es:[hwndSysModal]
        retf    2
cEnd nogen

;
; The DWPBits table defines which messages have actual processing for
; DefWindowProc.  We get these bits from user32.  User32 assumes the
; buffer passed in is zero-initialized, hence the DUP(0) below.
;

DWPBits DB 101 DUP(0)   ; Room for bits for msgs 0 - 807 (decimal)
public DWPBits

cbDWPBits DW ($ - codeoffset DWPBits)
public cbDWPBits

MaxDWPMsg DW 0
public MaxDWPMsg

;*--------------------------------------------------------------------------*
;*
;*  CheckDefWindowProc()
;*
;*  Checks to see if the message gets processed by DefWindowProc.  If not,
;*  the API returns 0.
;*
;*--------------------------------------------------------------------------*

ALIGN 4

cProc CheckDefWindowProc, <PUBLIC, NEAR>
parmW hWnd
parmW wMsg
parmW wParam
parmD lParam
parmD lpReturn          ; Callers Return Address
;parmW wBP           ; Thunk saved BP
;parmW wDS           ; Thunk saved DS
cBegin
    mov  bx,wMsg
    cmp  bx,cs:MaxDWPMsg
    ja   @f         ; jump if above (return with 0)
    mov  cx,bx
    shr  bx,3       ; make byte index into table
    mov  al,cs:[bx+DWPBits] ; get proper 8-bits
    and  cx,0007H
    shr  al,cl      ; get proper bit into bit 0 of al
    test al,1
    jz   @f

    mov  sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop  bp
    ret
@@:
    pop  bp
    xor  ax,ax     ; return (ULONG)0 to flag no window processing
    add  sp,2      ; skip thunk IP
    xor  dx,dx     ; return (ULONG)0 to flag no window processing
    retf 10        ; 10 bytes to pop


cEnd <nogen>



    UserThunk   ADJUSTWINDOWRECT
    UserThunk   ADJUSTWINDOWRECTEX

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.

    FUN_WIN32ANSILOWER     equ FUN_ANSILOWER
    FUN_WIN32ANSILOWERBUFF equ FUN_ANSILOWERBUFF
    FUN_WIN32ANSINEXT      equ FUN_ANSINEXT
    FUN_WIN32ANSIPREV      equ FUN_ANSIPREV
    FUN_WIN32ANSIUPPER     equ FUN_ANSIUPPER
    FUN_WIN32ANSIUPPERBUFF equ FUN_ANSIUPPERBUFF

    DUserThunk  WIN32ANSILOWER,     %(size ANSILOWER16)
    DUserThunk  WIN32ANSILOWERBUFF, %(size ANSILOWERBUFF16)
    DUserThunk  WIN32ANSINEXT,      %(size ANSINEXT16)
    DUserThunk  WIN32ANSIPREV,      %(size ANSIPREV16)
    DUserThunk  WIN32ANSIUPPER,     %(size ANSIUPPER16)
    DUserThunk  WIN32ANSIUPPERBUFF, %(size ANSIUPPERBUFF16)

    DUserThunk  ANYPOPUP,0
    UserThunk   APPENDMENU
    UserThunk   ARRANGEICONICWINDOWS
    DUserThunk  BEGINDEFERWINDOWPOS
    UserThunk   BEGINPAINT
    UserThunk   BRINGWINDOWTOTOP
    UserThunk   BROADCASTMESSAGE
    UserThunk   BUILDCOMMDCB
;;; UserThunk   BUTTONWNDPROC           ;LOCALAPI in wsubcls.c
    DUserThunk  CALCCHILDSCROLL
    UserThunk   CALLMSGFILTER
    UserThunk   CALLWINDOWPROC
    UserThunk   CARETBLINKPROC
    UserThunk   CHANGECLIPBOARDCHAIN
    UserThunk   CHANGEMENU
    UserThunk   CHECKDLGBUTTON
    UserThunk   CHECKMENUITEM
    UserThunk   CHECKRADIOBUTTON
    UserThunk   CHILDWINDOWFROMPOINT
    UserThunk   CLEARCOMMBREAK
    UserThunk   CLIPCURSOR
    DUserThunk  CLOSECLIPBOARD,0

FUN_WOWCLOSECOMM EQU FUN_CLOSECOMM
    DUserThunk   WOWCLOSECOMM %(size CLOSECOMM16)

    UserThunk   CLOSEWINDOW
;;; UserThunk   COMBOBOXCTLWNDPROC      ;LOCALAPI in wsubcls.c
    UserThunk   COMPUPDATERECT
    UserThunk   COMPUPDATERGN
    DUserThunk  CONTROLPANELINFO
    UserThunk   CONTSCROLL
;;;   UserThunk   COPYRECT               ; LOCALAPI in winrect.asm
    DUserThunk  COUNTCLIPBOARDFORMATS,0
    UserThunk   CREATECARET
    UserThunk   CREATECURSOR
    DUserThunk  CREATECURSORICONINDIRECT
;   UserThunk   CREATEDIALOG                 ; defined in fastres.c
;   UserThunk   CREATEDIALOGINDIRECT
;   UserThunk   CREATEDIALOGINDIRECTPARAM

;FUN_WOWCREATEDIALOGPARAM EQU FUN_CREATEDIALOGPARAM
;    DUserThunk  WOWCREATEDIALOGPARAM, %(size CREATEDIALOGPARAM16)

    UserThunk   CREATEICON
    DUserThunk  CREATEMENU,0
    DUserThunk  CREATEPOPUPMENU,0
    UserThunk   CREATEWINDOW
    UserThunk   CREATEWINDOWEX
    DUserThunk  DCHOOK
    UserThunk   DEFDLGPROC
    UserThunk   DEFERWINDOWPOS
    UserThunk   DEFFRAMEPROC
    UserThunk   DEFMDICHILDPROC
    PUserThunk   DEFWINDOWPROC,CheckDefWindowProc

.386p
LabelFP <PUBLIC, CascadeChildWindows>
        xor     edx, edx
        pop     eax             ; save caller's return addr
        push    edx             ; lpRect == NULL
        push    dx              ; chwnd == 0
        push    edx             ; ahwnd == NULL
        push    eax
        jmp     CascadeWindows

LabelFP <PUBLIC, TileChildWindows>
        xor     edx, edx
        pop     eax             ; save caller's return addr
        push    edx             ; lpRect == NULL
        push    dx              ; chwnd == 0
        push    edx             ; ahwnd == NULL
        push    eax
        jmp     TileWindows
.286p


; From Win 3.1 final inentry.asm - mattfe
;=========================================================================
; OldExitWindows()
;
; This function is at the same ordinal value as the old 2.x ExitWindows.  This
; does nothing more than terminate the app.  If it is the only app running the
; system will go away too.

LabelFP <PUBLIC, OldExitWindows>
    mov ax,4c00h
    int 21h
    retf            ; just in case the int21 returns...

sEnd    CODE

end USER16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user2.asm ===
;
;   USER2.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER2.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


;*--------------------------------------------------------------------------*
;*
;*  CheckDisplayHandle()
;*
;*  Checks to see if the handle passed in is the handle for the DISPLAY
;*  driver.   If that is the case then we change the parameter to NULL.
;*  This is to make applications like Winword 1.1a able to load cursors,icons
;*  and bitmaps from the 32 bit display driver.
;*
;*--------------------------------------------------------------------------*

display DB  'DISPLAY',0

cProc CheckDisplayHandle, <PUBLIC, NEAR>
parmW hInstance         ; Callers Parameters
parmD lpName            ; Callers
parmD lpReturn          ; Callers Return Address
cBegin
    pusha

    push    cs
    push    offset display
    Call    GetModuleHandle
    cmp ax,hInstance
    jnz @f

    mov hInstance,0h    ; Change Callers parameter to NULL
@@:
    popa

    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>



    UserThunk   FARCALLNETDRIVER
    UserThunk   FILEPORTDLGPROC
    UserThunk   FILLRECT
    DUserThunk  FILLWINDOW,8        ;Needs to be exposed in WIN32
    DUserThunk  FINALUSERINIT
    UserThunk   FINDWINDOW
    UserThunk   FLASHWINDOW
    UserThunk   FLUSHCOMM
    UserThunk   FRAMERECT
    DUserThunk  GETACTIVEWINDOW,0
    DUserThunk  GETASYNCKEYSTATE
    DUserThunk  GETCAPTURE,0
    DUserThunk  GETCARETBLINKTIME,0
    DUserThunk  GETCARETPOS
    UserThunk   GETCLASSINFO
    UserThunk   GETCLASSLONG
    UserThunk   GETCLASSWORD
    DUserThunk  GETCLIPBOARDDATA
    UserThunk   GETCLIPBOARDFORMATNAME
    DUserThunk  GETCLIPBOARDOWNER,0
    DUserThunk  GETCLIPBOARDVIEWER,0
    UserThunk   GETCOMMERROR
    UserThunk   GETCOMMEVENTMASK
    UserThunk   GETCOMMSTATE
    DUserThunk  GETCONTROLBRUSH
    UserThunk   GETDC
    DUserThunk  GETDIALOGBASEUNITS,0
    UserThunk   GETDLGCTRLID
    UserThunk   GETDLGITEMINT
    UserThunk   GETDLGITEMTEXT
    DUserThunk  GETDOUBLECLICKTIME,0
    DUserThunk  GETFILEPORTNAME
    DUserThunk  GETFOCUS,0
    DUserThunk  GETICONID
    DUserThunk  GETINPUTSTATE,0
    DUserThunk  GETINTERNALWINDOWPOS
    UserThunk   GETLASTACTIVEPOPUP
    DUserThunk  GETMENUCHECKMARKDIMENSIONS,0
    UserThunk   GETMENUSTRING
    UserThunk   GETMESSAGE
    DUserThunk  GETMESSAGE2
    DUserThunk  GETMESSAGEPOS,0
    DUserThunk  GETMESSAGETIME,0
;;;    DUserThunk  GETMOUSEEVENTPROC   ; local api in winmisc2.asm
    UserThunk   GETNEXTDLGGROUPITEM
    UserThunk   GETNEXTDLGTABITEM
    UserThunk   GETNEXTQUEUEWINDOW
    UserThunk   GETPRIORITYCLIPBOARDFORMAT
    UserThunk   GETPROP
    UserThunk   GETQUEUESTATUS
    UserThunk   GETSCROLLPOS
    UserThunk   GETSCROLLRANGE
;;;    DUserThunk  GETSYSMODALWINDOW,0 ; local api in winmisc1.asm
    UserThunk   GETSYSTEMMENU
    UserThunk   GETTABBEDTEXTEXTENT
;;;    UserThunk   GETTASKFROMHWND  ; No longer exported in Win95
    DUserThunk  GETTIMERRESOLUTION

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user2a.asm ===
;
;   USER2A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER2A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   GETUPDATERECT
    UserThunk   GETUPDATERGN
    UserThunk   GETWC2
    UserThunk   GETWINDOWDC
    DUserThunk  GETWINDOWLONG
    UserThunk   GETWINDOWTASK
    EUserThunk  GETWINDOWTEXT       ;Use the empty buffer user thunk.
    UserThunk   GETWINDOWTEXTLENGTH
    DUserThunk  GETWINDOWWORD
    DUserThunk  GLOBALADDATOM
    DUserThunk  GLOBALDELETEATOM
    UserThunk   GLOBALFINDATOM
    DUserThunk  GLOBALGETATOMNAME
    UserThunk   GRAYSTRING
    UserThunk   HIDECARET
    UserThunk   HILITEMENUITEM
    DUserThunk  ICONSIZE            ;;;;;;
;;; UserThunk   INFLATERECT      ; LOCALAPI in winrect.asm
;;; DUserThunk  INITAPP           ;LOCALAPI in user.asm
    DUserThunk  INSENDMESSAGE,0
    UserThunk   INSERTMENU
;;; UserThunk   INTERSECTRECT  ; LOCALAPI in winrect.asm
    UserThunk   INVALIDATERECT
    UserThunk   INVALIDATERGN
    UserThunk   INVERTRECT

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.

    FUN_WIN32ISCHARALPHA        equ FUN_ISCHARALPHA
    FUN_WIN32ISCHARALPHANUMERIC equ FUN_ISCHARALPHANUMERIC
    FUN_WIN32ISCHARLOWER        equ FUN_ISCHARLOWER
    FUN_WIN32ISCHARUPPER        equ FUN_ISCHARUPPER

    DUserThunk  WIN32ISCHARALPHA,        %(size ISCHARALPHA16)
    DUserThunk  WIN32ISCHARALPHANUMERIC, %(size ISCHARALPHANUMERIC16)
    DUserThunk  WIN32ISCHARLOWER,        %(size ISCHARLOWER16)
    DUserThunk  WIN32ISCHARUPPER,        %(size ISCHARUPPER16)

    DUserThunk  ISCLIPBOARDFORMATAVAILABLE
    UserThunk   ISDIALOGMESSAGE
    UserThunk   ISDLGBUTTONCHECKED
;;; UserThunk   ISRECTEMPTY         ; LOCALAPI in winrect.asm
    DUserThunk  ISTWOBYTECHARPREFIX        ;;;;;;
    DUserThunk  ISUSERIDLE
    DUserThunk  KILLSYSTEMTIMER        ;;;;;
    UserThunk   KILLTIMER
    UserThunk   KILLTIMER2
    UserThunk   LBOXCARETBLINKER
;;; UserThunk   LBOXCTLWNDPROC          ;LOCALAPI in wsubcls.c
;;; UserThunk   LOADACCELERATORS        ; localapi in rmload.c

FUN_WOWLOADBITMAP EQU FUN_LOADBITMAP
    DUserThunk	WOWLOADBITMAP, %(size LOADBITMAP16)

FUN_WOWLOADCURSORICON EQU FUN_LOADCURSOR
    DUserThunk	WOWLOADCURSORICON, %(size LOADCURSOR16)

;FUN_WOWLOADICON EQU FUN_LOADICON
;   DUserThunk	WOWLOADICON, %(size LOADICON16)

    DUserThunk  LOADICONHANDLER

FUN_WOWLOADMENU EQU FUN_LOADMENU
    DUserThunk	WOWLOADMENU, %(size LOADMENU16)

    UserThunk   LOADMENUINDIRECT
;;; UserThunk   LOADSTRING          ;LOCALAPI in rmload.c
    DUserThunk  LOCKMYTASK
    DUserThunk  LOOKUPMENUHANDLE

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.
    FUN_WIN32LSTRCMP equ FUN_LSTRCMP
    FUN_WIN32LSTRCMPI equ FUN_LSTRCMPI

    DUserThunk  WIN32LSTRCMP,  %(size LSTRCMP16)
    DUserThunk  WIN32LSTRCMPI, %(size LSTRCMPI16)

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user.h ===
/***************************************************************************/
/*                                                                         */
/*  USER.H -                                   */
/*                                                                         */
/*     User's main include file.                                           */
/*                                                                         */
/***************************************************************************/

#ifdef WOW
#define NO_LOCALOBJ_TAGS
#endif

// If #defined, only 16 bits of the window extended style will be stored
// in the window instance.
//
//#define WORDEXSTYLE


// This magic definition ensures that HWND is declared as a near
// pointer to our internal window data structure.  See
// the DECLARE_HANDLE macro in windows.h.
//
#define tagWND HWND__

// substitute API names with the "I" internal names
//
#ifndef DEBUG
#include "iuser.h"
#endif

#ifdef DEBUG
#ifndef NO_REDEF_SENDMESSAGE
#define SendMessage RevalSendMessage
#endif
#endif

//***** Include standard headers...

#define NOSOUND
#define NOFONT
#define NOKANJI
#define LSTRING
#define LFILEIO
#define WIN31

#define STRICT

#include <windows.h>

/* Structure types that occupy the USER Data Segment */
#define ST_CLASS        1
#define ST_WND          2
#define ST_STRING       3
#define ST_MENU         4
#define ST_CLIP         5
#define ST_CBOX         6
#define ST_PALETTE      7
#define ST_ED           8
#define ST_BWL          9
#define ST_OWNERDRAWMENU    10
#define ST_SPB          11
#define ST_CHECKPOINT       12
#define ST_DCE          13
#define ST_MWP          14
#define ST_PROP         15
#define ST_LBIV         16
#define ST_MISC         17
#define ST_ATOMS        18
#define ST_LOCKINPUTSTATE       19
#define ST_HOOKNODE     20
#define ST_USERSEEUSERDOALLOC   21
#define ST_HOTKEYLIST           22
#define ST_POPUPMENU            23
#define ST_HANDLETABLE      32 /* Defined by Kernel; We have no control */
#define ST_FREE         0xFF

#define CODESEG     _based(_segname("_CODE"))
#define INTDSSEG    _based(_segname("_INTDS"))

// Returns TRUE if currently executing app is 3.10 compatible
//
#define Is310Compat(hInstance)   (LOWORD(GetExpWinVer(hInstance)) >= 0x30a)
#define Is300Compat(hInstance)   (LOWORD(GetExpWinVer(hInstance)) >= 0x300)

#define VER     0x0300
#define VER31           0x0310
#define VER30       0x0300
#define VER20       0x0201

#define CR_CHAR     13
#define ESC_CHAR    27
#define SPACE_CHAR  32

typedef HANDLE      HQ;

struct tagDCE;

/* Window class structure */
typedef struct tagCLS
{
    /* NOTE: The order of the following fields is assumed. */
    struct tagCLS*  pclsNext;
    WORD        clsMagic;
    ATOM        atomClassName;
    struct tagDCE*  pdce;          /* DCE * to DC associated with class */
    int         cWndReferenceCount;   /* The number of windows registered
                         with this class */
    WORD        style;
    WNDPROC     lpfnWndProc;
    int         cbclsExtra;
    int         cbwndExtra;
    HMODULE         hModule;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPSTR       lpszMenuName;
    LPSTR       lpszClassName;
} CLS;
typedef CLS *PCLS;
typedef CLS far *LPCLS;
typedef PCLS  *PPCLS;

#define CLS_MAGIC   ('N' | ('K' << 8))

struct tagPROPTABLE;

/* Window instance structure */
typedef struct tagWND
{
    struct tagWND* hwndNext;   /* 0x0000 Handle to the next window      */
    struct tagWND* hwndChild;  /* 0x0002 Handle to child            */
    struct tagWND* hwndParent; /* 0x0004 Backpointer to the parent window.  */
    struct tagWND* hwndOwner;  /* 0x0006 Popup window owner field       */
    RECT      rcWindow;    /* 0x0008 Window outer rectangle         */
    RECT      rcClient;    /* 0x0010 Client rectangle           */
    HQ        hq;          /* 0x0018 Queue handle               */
    HRGN      hrgnUpdate;  /* 0x001a Accumulated paint region       */
    struct tagCLS*  pcls;      /* 0x001c Pointer to window class        */
    HINSTANCE     hInstance;   /* 0x001e Handle to module instance data.    */
    WNDPROC   lpfnWndProc; /* 0x0020 Far pointer to window proc.        */
    DWORD     state;       /* 0x0024 Internal state flags           */
    DWORD     style;       /* 0x0028 Style flags                */
#ifdef WORDEXSTYLE
    WORD          dwExStyle;   /* 0x002c Extended Style (ONLY LOW 16 BITS STORED) */
#else
    DWORD         dwExStyle;   /* 0x002c Extended Style                     */
#endif
    HMENU     hMenu;       /* 0x0030 Menu handle or ID          */
    HLOCAL    hName;       /* 0x0032 Alt DS handle of the window text   */
    int*      rgwScroll;   /* 0x0034 Words used for scroll bar state    */
    struct tagPROPTABLE* pproptab; /* 0x0036 Handle to the start of the property list */
    struct tagWND* hwndLastActive; /* 0x0038 Last active in owner/ownee list */
    HMENU     hSysMenu;    /* 0x003a Handle to system menu          */
} WND;

#undef API
#define API _loadds _far _pascal

#undef CALLBACK
#define CALLBACK _loadds _far _pascal

#ifndef MSDWP

#include <winexp.h>
#include "strtable.h"
#include "wmsyserr.h"

#endif   /* MSDWP */

/*** AWESOME HACK ALERT!
 *
 *  Window Style and State Masks -
 *
 *  High byte of word is byte index from the start of the state field
 *  in the WND structure, low byte is the mask to use on the byte.
 *  These masks assume the order of the state and style fields of a
 *  window instance structure.
 */

// hwnd->state flags (offset 0, 1, 2, 3)
#define WFMPRESENT    0x0001
#define WFVPRESENT    0x0002
#define WFHPRESENT    0x0004
#define WFCPRESENT    0x0008
#define WFSENDSIZEMOVE    0x0010
#define WFNOPAINT         0x0020
#define WFFRAMEON         0x0040
#define WFHASSPB          0x0080
#define WFNONCPAINT       0x0101
#define WFSENDERASEBKGND  0x0102
#define WFERASEBKGND      0x0104
#define WFSENDNCPAINT     0x0108
#define WFINTERNALPAINT   0x0110    // Internal paint required flag
#define WFUPDATEDIRTY     0x0120
#define WFHIDDENPOPUP     0x0140
#define WFMENUDRAW        0x0180

#define WFHASPALETTE      0x0201
#define WFPAINTNOTPROCESSED 0x0202  // WM_PAINT message not processed
#define WFWIN31COMPAT     0x0204    // Win 3.1 compatible window
#define WFALWAYSSENDNCPAINT 0x0208  // Always send WM_NCPAINT to children
#define WFPIXIEHACK       0x0210    // Send (HRGN)1 to WM_NCPAINT (see PixieHack)
#define WFTOGGLETOPMOST   0x0220    // Toggle the WS_EX_TOPMOST bit ChangeStates

// hwnd->style style bits (offsets 4, 5, 6, 7)
#define WFTYPEMASK    0x07C0
#define WFTILED       0x0700
#define WFICONICPOPUP     0x07C0
#define WFPOPUP       0x0780
#define WFCHILD       0x0740
#define WFMINIMIZED   0x0720
#define WFVISIBLE     0x0710
#define WFDISABLED    0x0708
#define WFDISABLE     WFDISABLED
#define WFCLIPSIBLINGS    0x0704
#define WFCLIPCHILDREN    0x0702
#define WFMAXIMIZED   0x0701
#define WFICONIC      WFMINIMIZED

#define WFMINBOX      0x0602
#define WFMAXBOX      0x0601

#define WFBORDERMASK      0x06C0
#define WFBORDER      0x0680
#define WFCAPTION     0x06C0
#define WFDLGFRAME    0x0640
#define WFTOPLEVEL    0x0640

#define WFVSCROLL     0x0620
#define WFHSCROLL     0x0610
#define WFSYSMENU     0x0608
#define WFSIZEBOX     0x0604
#define WFGROUP       0x0602
#define WFTABSTOP     0x0601

// If this dlg bit is set, WM_ENTERIDLE message will not be sent
#define WFNOIDLEMSG   0x0501

// hwnd->dwExStyle extended style bits (offsets 8, 9)
#define WEFDLGMODALFRAME  0x0801
#define WEFDRAGOBJECT     0x0802
#define WEFNOPARENTNOTIFY 0x0804
#define WEFTOPMOST    0x0808
#define WEFACCEPTFILES    0x0810
#define WEFTRANSPARENT    0x0820    // "Transparent" child window

// Class styles
#define CFVREDRAW         0x0001
#define CFHREDRAW         0x0002
#define CFKANJIWINDOW     0x0004
#define CFDBLCLKS         0x0008
#define CFOEMCHARS        0x0010
#define CFOWNDC           0x0020
#define CFCLASSDC         0x0040
#define CFPARENTDC        0x0080
#define CFNOKEYCVT        0x0101
#define CFNOCLOSE         0x0102
#define CFLVB             0x0104
#define CFCLSDC           CFCLASSDC
#define CFSAVEBITS    0x0108
#define CFSAVEPOPUPBITS   CFSAVEBITS
#define CFBYTEALIGNCLIENT 0x0110
#define CFBYTEALIGNWINDOW 0x0120


/*** AWESOME HACK ALERT!!!
 *
 * The low byte of the WF?PRESENT state flags must NOT be the
 * same as the low byte of the WFBORDER and WFCAPTION flags,
 * since these are used as paint hint masks.  The masks are calculated
 * with the MaskWF macro below.
 *
 * The magnitute of this hack compares favorably with that of the national debt.
 */
#define TestWF(hwnd, flag)   ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) & (BYTE)LOBYTE(flag))
#define SetWF(hwnd, flag)    ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) |= (BYTE)LOBYTE(flag))
#define ClrWF(hwnd, flag)    ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) &= ~(BYTE)LOBYTE(flag))
#define MaskWF(flag)         ((WORD)( (HIBYTE(flag) & 1) ? LOBYTE(flag) << 8 : LOBYTE(flag)) )

#define TestCF(hwnd, flag)   (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF(hwnd, flag)    (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF(hwnd, flag)    (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) &= ~LOBYTE(flag))
#define TestCF2(pcls, flag)  (*((BYTE *)(&pcls->style) + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF2(pcls, flag)   (*((BYTE *)(&pcls->style) + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF2(pcls, flag)   (*((BYTE *)(&pcls->style) + HIBYTE(flag)) &= ~LOBYTE(flag))

#define TestwndChild(hwnd)   (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFCHILD))
#define TestwndTiled(hwnd)   (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFTILED))
#define TestwndIPopup(hwnd)  (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFICONICPOPUP))
#define TestwndNIPopup(hwnd) (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFPOPUP))
#define TestwndPopup(hwnd)   (TestwndNIPopup(hwnd) || TestwndIPopup(hwnd))
#define TestwndHI(hwnd)      (TestwndTiled(hwnd) || TestwndIPopup(hwnd))

/* Special macro to test if WM_PAINT is needed */

#define NEEDSPAINT(hwnd)    (hwnd->hrgnUpdate != NULL || TestWF(hwnd, WFINTERNALPAINT))

/* Areas to be painted during activation and inactivation */
#define NC_DRAWNONE    0x00
#define NC_DRAWCAPTION 0x01
#define NC_DRAWFRAME   0x02
#define NC_DRAWBOTH    (NC_DRAWCAPTION | NC_DRAWFRAME)

void FAR DrawCaption(HWND hwnd, HDC hdc, WORD flags, BOOL fActive);

/* ActivateWindow() commands */
#define AW_USE       1
#define AW_TRY       2
#define AW_SKIP      3
#define AW_TRY2      4
#define AW_SKIP2     5      /* used internally in ActivateWindow() */
#define AW_USE2      6      /* nc mouse activation added by craigc */

/* These numbers serve as indices into the atomSysClass[] array
 * so that we can get the atoms for the various classes.
 * The order of the control classes is assumed to be
 * the same as the class XXXCODE constants defined in dlgmgr.h.
 */
#define ICLS_BUTTON     0
#define ICLS_EDIT       1
#define ICLS_STATIC     2
#define ICLS_LISTBOX        3
#define ICLS_SCROLLBAR      4
#define ICLS_COMBOBOX       5       // End of special dlgmgr indices

#define ICLS_CTL_MAX        6       // Number of public control classes

#define ICLS_DESKTOP        6
#define ICLS_DIALOG     7
#define ICLS_MENU       8
#define ICLS_SWITCH     9
#define ICLS_ICONTITLE      10
#define ICLS_MDICLIENT      11
#define ICLS_COMBOLISTBOX   12

#define ICLS_MAX        13      // Number of system classes

// The following are the atom values for the atom-named public classes
// NOTE: DIALOGCLASS at least should be in windows.h
//
#define MENUCLASS   0x8000      /* Public Knowledge */
#define DESKTOPCLASS    0x8001
#define DIALOGCLASS     0x8002
#define SWITCHWNDCLASS  0x8003
#define ICONTITLECLASS  0x8004

/* Z Ordering() return values */
#define ZO_ERROR        (-1)
#define ZO_EQUAL        0
#define ZO_DISJOINT     1
#define ZO_ABOVE        2
#define ZO_BELOW        3

#ifdef DEBUG
#ifndef  NO_LOCALOBJ_TAGS
HANDLE  FAR UserLocalAlloc(WORD, WORD, WORD);
HANDLE  FAR UserLocalFree(HANDLE);
char*   FAR UserLocalLock(HANDLE);
BOOL    FAR UserLocalUnlock(HANDLE);
HANDLE  FAR UserLocalReAlloc(HANDLE, WORD, WORD);
WORD    FAR UserLocalSize(HANDLE);

#define LocalAlloc(A,B) UserLocalAlloc(ST_MISC,A,B)
#define LocalFree   UserLocalFree
#define LocalLock   UserLocalLock
#define LocalUnlock UserLocalUnlock
#define LocalReAlloc    UserLocalReAlloc
#define LocalSize   UserLocalSize
#endif
#endif

#ifndef DEBUG
#define  UserLocalAlloc(TagType,MemType,Size)   LocalAlloc(MemType,Size)
#else
#ifdef NO_LOCALOBJ_TAGS
#define  UserLocalAlloc(TagType,MemType,Size)   LocalAlloc(MemType,Size)
#endif
#endif

#define XCOORD(l)   ((int)LOWORD(l))
#define YCOORD(l)   ((int)HIWORD(l))
#define abs(A)  ((A < 0)? -A : A)

/* CheckPoint structure */
typedef struct tagCHECKPOINT
  {
    RECT  rcNormal;
    POINT ptMin;
    POINT ptMax;
    HWND  hwndTitle;
    WORD  fDragged:1;
    WORD  fWasMaximizedBeforeMinimized:1;
    WORD  fWasMinimizedBeforeMaximized:1;
    WORD  fParkAtTop:1;
  } CHECKPOINT;

// Internal property name definitions

#define CHECKPOINT_PROP_NAME    "SysCP"
extern ATOM atomCheckpointProp;
#define WINDOWLIST_PROP_NAME    "SysBW"
extern ATOM atomBwlProp;

#define InternalSetProp(hwnd, key, value, fInternal)    SetProp(hwnd, key, value)
#define InternalGetProp(hwnd, key, fInternal)       GetProp(hwnd, key)
#define InternalRemoveProp(hwnd, key, fInternal)    RemoveProp(hwnd, key)
#define InternalEnumProps(hwnd, pfn, fInternal)     EnumProps(hwnd, pfn)

/* Window List Structure */
typedef struct tagBWL
  {
    struct tagBWL *pbwlNext;
    HWND          *phwndMax;
    HWND          rghwnd[1];
  } BWL;
typedef BWL *PBWL;

#define CHWND_BWLCREATE     32      // Initial BWL size
#define CHWND_BWLGROW       16      // Amt to grow BWL by when it needs to grow.

// BuildHwndList() commands
#define BWL_ENUMCHILDREN    1
#define BWL_ENUMLIST        2


/* DOS Semaphore Structure */
typedef struct tagSEMAPHORE
  {
    DWORD semaphore;
    HQ    hqOwner;
    BYTE  cBusy;
    BYTE  bOrder;
  } SEMAPHORE;
typedef SEMAPHORE FAR *LPSEM;

#define CheckHwnd(hwnd)         TRUE
#define CheckHwndNull(hwnd)     TRUE
#define ValidateWindow(hwnd)        TRUE
#define ValidateWindowNull(hwnd)    TRUE

#define AllocP(wType,cb)    UserLocalAlloc(wType,LPTR, cb)
#define FreeP(h)            LocalFree(h)

#ifndef DEBUG
#define     LMHtoP(handle)  (*((char**)(handle)))
#else
#ifdef NO_LOCALOBJ_TAGS
#define     LMHtoP(handle)  (*((char**)(handle)))
#else
#define     LMHtoP(handle)  (*((char**)(handle))+sizeof(long))
#endif
#endif

/* Evil nasty macros to work with movable local objects */
#define     LLock(handle)   ((*(((BYTE *)(handle))+3))++)
#define     LUnlock(handle) ((*(((BYTE *)(handle))+3))--)


#define dpHorzRes       HORZRES
#define dpVertRes       VERTRES


HWND WindowHitTest(HWND hwnd, POINT pt, int FAR* ppart);

/*
 * If the handle for CF_TEXT/CF_OEMTEXT is a dummy handle then this implies
 * that data is available in the other format (as CF_OEMTEXT/CF_TEXT)
 */
#define DUMMY_TEXT_HANDLE   ((HANDLE)0xFFFF)
#define DATA_NOT_BANKED     ((HANDLE)0xFFFF)

typedef struct tagCLIP
  {
    WORD    fmt;
    HANDLE  hData;
  } CLIP;
typedef CLIP *PCLIP;

extern CLIP* pClipboard;

typedef struct tagSYSMSG
  {
    WORD     message;
    WORD     paramL;
    WORD     paramH;
    DWORD    time;
  } SYSMSG;

typedef struct tagINTERNALSYSMSG
  {
    DWORD    ismExtraInfo;  /* Additional Info */
    SYSMSG   ismOldMsg;     /* External System Msg structure */
  } INTERNALSYSMSG;

typedef struct tagINTERNALMSG
  {
    DWORD    imExtraInfo;   /* Additional Info */
    MSG      imOldMsg;      /* External App Msg structure */
  } INTERNALMSG;


typedef struct tagTIMERINFO
  {
    LONG resolution;
  } TIMERINFO;


typedef struct tagKBINFO
  {
    BYTE  Begin_First_range;    /* Values used for Far East systems */
    BYTE  End_First_range;
    BYTE  Begin_Second_range;
    BYTE  End_Second_range;
    int   stateSize;        /* size of ToAscii()'s state block */
  } KBINFO;


typedef struct tagMOUSEINFO
  {
    char  fExist;
    char  fRelative;
    int   cButton;
    int   cmsRate;
    int   xThreshold;
    int   yThreshold;
    int   cxResolution;  /* resolution needed for absolute mouse coordinate */
    int   cyResolution;
    int   mouseCommPort; /* comm port # to reserve since mouse is using it */
  } MOUSEINFO;


typedef struct tagCURSORINFO
  {
    int   csXRate;
    int   csYRate;
  } CURSORINFO;


typedef struct tagCURSORSHAPE
  {
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
  } CURSORSHAPE;
typedef CURSORSHAPE *PCURSORSHAPE;
typedef CURSORSHAPE FAR * LPCURSORSHAPE;

// Standard ICON dimensions;
#define  STD_ICONWIDTH    32
#define  STD_ICONHEIGHT   32
#define  STD_CURSORWIDTH  32
#define  STD_CURSORHEIGHT 32

typedef struct tagICONINFO
  {
    int iIconCurrent;
    int fHeightChange;
    int crw;            /* current nunber of rows. */
    int cIconInRow;     /* maximum icons in a row. */
    int cIcon;
    int wEvent;
  } ICONINFO;


/* Height and Width of the desktop pattern bitmap. */
#define CXYDESKPATTERN      16

/* System object colors. */
#define CSYSCOLORS          21

typedef struct tagSYSCLROBJECTS
  {
    HBRUSH  hbrScrollbar;
    HBRUSH  hbrDesktop;
    HBRUSH  hbrActiveCaption;
    HBRUSH  hbrInactiveCaption;
    HBRUSH  hbrMenu;
    HBRUSH  hbrWindow;
    HBRUSH  hbrWindowFrame;
    HBRUSH  hbrMenuText;
    HBRUSH  hbrWindowText;
    HBRUSH  hbrCaptionText;
    HBRUSH  hbrActiveBorder;
    HBRUSH  hbrInactiveBorder;
    HBRUSH  hbrAppWorkspace;
    HBRUSH  hbrHiliteBk;
    HBRUSH  hbrHiliteText;
    HBRUSH  hbrBtnFace;
    HBRUSH  hbrBtnShadow;
    HBRUSH  hbrGrayText;
    HBRUSH  hbrBtnText;
    HBRUSH  hbrInactiveCaptionText;
    HBRUSH  hbrBtnHilite;
  } SYSCLROBJECTS;

typedef struct tagSYSCOLORS
  {
    LONG    clrScrollbar;
    LONG    clrDesktop;
    LONG    clrActiveCaption;
    LONG    clrInactiveCaption;
    LONG    clrMenu;
    LONG    clrWindow;
    LONG    clrWindowFrame;
    LONG    clrMenuText;
    LONG    clrWindowText;
    LONG    clrCaptionText;
    LONG    clrActiveBorder;
    LONG    clrInactiveBorder;
    LONG    clrAppWorkspace;
    LONG    clrHiliteBk;
    LONG    clrHiliteText;
    LONG    clrBtnFace;
    LONG    clrBtnShadow;
    LONG    clrGrayText;
    LONG    clrBtnText;
    LONG    clrInactiveCaptionText;
    LONG    clrBtnHilite;
  } SYSCOLORS;

typedef struct tagCARET
  {
    HWND    hwnd;
    BOOL    fVisible;
    BOOL    fOn;
    int     iHideLevel;
    int     x;
    int     y;
    int     cy;
    int     cx;
    HBITMAP hBitmap;
    WORD    cmsBlink;       /* Blink time in milliseconds. */
    WORD    hTimer;
  } CARET;

/* Resource ID of system menus. */
#define ID_SYSMENU   MAKEINTRESOURCE(1)
#define ID_CLOSEMENU MAKEINTRESOURCE(2)

/* Menu Item Structure */
typedef struct tagITEM
  {
    WORD    fFlags;                 /* Item Flags. Must be first in this
                                         * structure.
                     */
    HMENU   cmdMenu;                /* Handle to a popup */
    int     xItem;
    int     yItem;
    int     cxItem;
    int     cyItem;
    int     dxTab;
    HBITMAP hbmpCheckMarkOn;    /* Bitmap for an on  check */
    HBITMAP hbmpCheckMarkOff;   /* Bitmap for an off check */
    HBITMAP hItem;          /* Handle to a bitmap or string */
    int         ulX;                    /* String: Underline start */
    int         ulWidth;                /* String: underline width */
    int         cch;                    /* String: character count */
  } ITEM;
typedef ITEM        *PITEM;
typedef ITEM FAR *LPITEM;

#define SIG_MENU    ('M' | ('U' << 8))

/* Menu Structure */
typedef struct tagMENU
  {
    struct tagMENU* pMenuNext;
    WORD    fFlags;     /* Menu Flags.*/
    WORD    signature;  // signature
    HQ      hqOwner;    // owner queue
    int         cxMenu;
    int         cyMenu;
    int     cItems;     /* Number of items in rgItems */
    HWND        hwndNotify; /* The owner hwnd of this menu */
    ITEM*   rgItems;    /* The list of items in this menu */
#ifdef JAPAN
    int     MenuMode;   /* Kanji menu mode flag */
#endif
  } MENU;
typedef MENU    *PMENU;

// Layout of first part of menu heap structure.
//
typedef struct
{
    WORD    rgwReserved[8]; // reserve 8 words for standard DS stuff.
    MENU*   pMenuList;
} MENUHEAPHEADER;

// Head of menu list (USE ONLY WITH DS == MENUHEAP)
#define PMENULIST   (((MENUHEAPHEADER*)NULL)->pMenuList)

void FAR SetMenuDS(void);
void FAR SetMenuStringDS(void);

#define MENUSYSMENU     SPACE_CHAR      /* Space character */
#define MENUCHILDSYSMENU    '-'         /* Hyphen */


/* Defines for the fVirt field of the Accelerator table structure. */
#define FVIRTKEY  TRUE      /* Assumed to be == TRUE */
#define FLASTKEY  0x80      /* Indicates last key in the table */
#define FNOINVERT 0x02
#define FSHIFT    0x04
#define FCONTROL  0x08
#define FALT      0x10

/* Accelerator Table structure */
typedef struct tagACCEL
  {
    BYTE   fVirt;       /* Also called the flags field */
    WORD   key;
    WORD   cmd;
  } ACCEL;
typedef ACCEL FAR *LPACCEL;

/* OEM Bitmap Information Structure */
typedef struct tagOEMBITMAPINFO
  {
    HBITMAP hBitmap;
    int     cx;
    int     cy;
  } OEMBITMAPINFO;

/* OEM Information Structure */
typedef struct tagOEMINFO
  {
    OEMBITMAPINFO bmFull;
    OEMBITMAPINFO bmUpArrow;
    OEMBITMAPINFO bmDnArrow;
    OEMBITMAPINFO bmRgArrow;
    OEMBITMAPINFO bmLfArrow;
    OEMBITMAPINFO bmReduce;
    OEMBITMAPINFO bmZoom;
    OEMBITMAPINFO bmRestore;
    OEMBITMAPINFO bmMenuArrow;
    OEMBITMAPINFO bmComboArrow;
    OEMBITMAPINFO bmReduceD;
    OEMBITMAPINFO bmZoomD;
    OEMBITMAPINFO bmRestoreD;
    OEMBITMAPINFO bmUpArrowD;
    OEMBITMAPINFO bmDnArrowD;
    OEMBITMAPINFO bmRgArrowD;
    OEMBITMAPINFO bmLfArrowD;
    OEMBITMAPINFO bmUpArrowI;   //  Up Arrow Inactive
    OEMBITMAPINFO bmDnArrowI;   //  Down Arrow Inactive
    OEMBITMAPINFO bmRgArrowI;   //  Right Arrow Inactive
    OEMBITMAPINFO bmLfArrowI;   //  Left Arrow Inactive
    int       cxbmpHThumb;
    int       cybmpVThumb;
    int       cxMin;
    int       cyMin;
    int       cxIconSlot;
    int       cyIconSlot;
    int       cxIcon;
    int       cyIcon;
    WORD      cxPixelsPerInch;  /* logical pixels per inch in X direction */
    WORD      cyPixelsPerInch;  /* logical pixels per inch in Y direction */
    int       cxCursor;
    int       cyCursor;
    WORD      DispDrvExpWinVer; /* Display driver expected win version no */
    WORD      ScreenBitCount; /* (BitCount * No of planes) for display */
    int       cSKanji;
    int       fMouse;
  } OEMINFO;

/* OEMINFO structure for the monochrome bitmaps */
typedef struct tagOEMINFOMONO
  {
    OEMBITMAPINFO bmAdjust;
    OEMBITMAPINFO bmSize;
    OEMBITMAPINFO bmCheck;  /* Check mark */
    OEMBITMAPINFO bmbtnbmp; /* Check boxes */
    OEMBITMAPINFO bmCorner; /* Corner of buttons */
    int       cxbmpChk;
    int       cybmpChk;
  } OEMINFOMONO;

typedef struct  tagBMPDIMENSION
  {
    int     cxBits; /* Width of the Bitmap */
    int     cyBits;     /* Height of the huge bitmap */
  } BMPDIMENSION;

/* Holds the offsets of all bitmaps in bmBits (of hdcBits). */
typedef struct tagRESINFO
  {
    /* The next 9 match resInfo */
    int     dxClose;
    int     dxUpArrow;
    int     dxDnArrow;
    int     dxRgArrow;
    int     dxLfArrow;
    int     dxReduce;
    int     dxZoom;
    int     dxRestore;
    int     dxMenuArrow;
    int     dxComboArrow;
    int     dxReduceD;
    int     dxZoomD;
    int     dxRestoreD;
    int     dxUpArrowD;
    int     dxDnArrowD;
    int     dxRgArrowD;
    int     dxLfArrowD;
    int     dxUpArrowI;     // Up Arrow Inactive.
    int     dxDnArrowI;     // Down Arrow Inactive.
    int     dxRgArrowI;     // Right Arrow Inactive.
    int     dxLfArrowI;     // Left Arrow Inactive.
    HBITMAP hbmBits;
    BMPDIMENSION  bmpDimension;
  } RESINFO;

typedef struct tagRESINFOMONO
  {
    int     dxSize;
    int     dxBtSize;
    int     dxCheck;
    int     dxCheckBoxes;
    int     dxBtnCorners;
    HBITMAP   hbmBits;
    BMPDIMENSION  bmpDimensionMono;
  } RESINFOMONO;

typedef struct tagTASK
  {
    HQ      hq;
    HWND    hwnd;
    int     ID;
    WORD    count;
    WORD    freq;
    WORD    ready;
    FARPROC lpfnTask;
  } TASK;

//**** SetWindowsHook() related definitions

typedef struct tagHOOKNODE
{
    struct tagHOOKNODE* phkNext;// Next in chain
    HOOKPROC    lpfn;       // function ptr to call (NULL if deleted during call)
    int     idHook;     // hook ID for this node
    HQ      hq;     // hq for which this hook applies
    HMODULE hmodOwner;  // Module handle that contains this hook
    BOOL    fCalled;    // Whether inside call or not
} HOOKNODE;

#define HHOOK_MAGIC  ('H' | ('K' << 8))

extern HOOKNODE* rgphkSysHooks[];
extern HOOKNODE* phkDeleted;
extern BYTE rgbHookFlags[];

LRESULT FAR CallHook(int code, WPARAM wParam, LPARAM lParam, int idHook);

BOOL FAR IsHooked(WORD idHook);
BOOL      CallKbdHook(int code, WPARAM wParam, LPARAM lParam);
BOOL      CallMouseHook(int code, WPARAM wParam, LPARAM lParam);

void      UnhookHooks(HANDLE h, BOOL fQueue);

HMODULE FAR PASCAL GetProcModule(FARPROC lpfn);
HQ    HqFromTask(HTASK htask);

void UnhookHotKeyHooks(HMODULE hmodule);

#ifdef DISABLE
#define CallVisRgnHook(pparams) (int)CallHook(0, 0, (LONG)(VOID FAR*)pparams, WH_VISRGN) // ;Internal
#endif

// DC cache related declarations

// DC Cache Entry structure (DCE)
#define CACHESIZE 5

typedef struct tagDCE
{
    struct tagDCE *pdceNext;
    HDC       hdc;
    HWND      hwnd;
    HWND      hwndOrg;
    HWND      hwndClip;
    HRGN      hrgnClip;
    DWORD     flags;
} DCE;

extern DCE  *pdceFirst;     // Pointer to first element of cache

extern HRGN hrgnGDC;        // Temp used by GetCacheDC et al
extern HRGN hrgnEWL;        // Temp used by ExcludeWindowList()
extern HRGN hrgnDCH;        // Temp used by DCHook()
extern BOOL fSiblingsTouched;

#define InternalReleaseDC(hdc)  ReleaseCacheDC(hdc, FALSE)

/* InvalidateDCCache() flag values */
#define IDC_DEFAULT     0x0001
#define IDC_CHILDRENONLY    0x0002
#define IDC_CLIENTONLY      0x0004

#define IDC_VALID       0x0007  /* ;Internal */

BOOL FAR InvalidateDCCache(HWND hwnd, WORD flags);

int CalcWindowRgn(HWND hwnd, HRGN hrgn, BOOL fClient);

BOOL FAR CalcVisRgn(HRGN hrgn, HWND hwndOrg, HWND hwndClip, DWORD flags);
BOOL FAR ReleaseCacheDC(HDC hdc, BOOL fEndPaint);
HDC  FAR GetCacheDC(HWND hwndOrg, HWND hwndClip, HRGN hrgnClip, HDC hdcMatch, DWORD flags);
HDC  FAR CreateCacheDC(HWND hwndOrg, DWORD flags);
BOOL FAR DestroyCacheDC(HDC hdc);
HWND FAR WindowFromCacheDC(HDC hdc);

BOOL FAR IntersectWithParents(HWND hwnd, LPRECT lprc);


//**************************************************************************
//
// void SetVisible(hwnd, fSet)
//
// This routine must be used to set or clear the WS_VISIBLE style bit.
// It also handles the setting or clearing of the WF_TRUEVIS bit.
//
#define SetVisible(hwnd, fSet)      \
    if (fSet)                       \
    {                               \
        SetWF((hwnd), WFVISIBLE);   \
    }                               \
    else                            \
    {                               \
        ClrWF((hwnd), WFVISIBLE);   \
        ClrFTrueVis(hwnd);          \
    }

void FAR ClrFTrueVis(HWND hwnd);

/* Saved Popup Bits structure */
typedef struct tagSPB
  {
    struct tagSPB *pspbNext;
    HWND          hwnd;
    HBITMAP       hbm;
    RECT          rc;
    HRGN          hrgn;
    WORD      flags;
  } SPB;

#define SPB_SAVESCREENBITS  0x0001  // (*lpSaveScreenBits) was called
#define SPB_LOCKUPDATE      0x0002  // LockWindowUpdate() SPB
#ifdef DISABLE
#define SPB_DRAWBUFFER      0x0004  // BeginDrawBuffer() SPB
#endif

// SPB related functions

extern SPB* pspbFirst;

extern HRGN hrgnSCR;        // Temp rgn used by SpbCheckRect() */

extern HRGN hrgnSPB1;       // More temp regions

extern HRGN hrgnSPB2;

// This macro can be used to quickly avoid far calls to the SPB code.
// In some cases it can prevent pulling in the segment that contains
// all the code.
//
#define AnySpbs()   (pspbFirst != NULL)     // TRUE if there are any SPBs

BOOL SpbValidate(SPB* pspb, HWND hwnd, BOOL fChildren);
void SpbCheckDce(DCE* pdce);
BOOL FBitsTouch(HWND hwndInval, LPRECT lprcDirty, SPB* pspb, DWORD flagsDcx);
void FAR DeleteHrgnClip(DCE* pdce);

void FAR CreateSpb(HWND hwnd, WORD flags, HDC hdcScreen);
void FAR FreeSpb(SPB* pspb);
SPB* FAR FindSpb(HWND hwnd);
void FAR SpbCheckRect(HWND hwnd, LPRECT lprc, DWORD flagsDcx);
void FAR SpbCheckHwnd(HWND hwnd);
BOOL FAR RestoreSpb(HWND hwnd, HRGN hrgnUncovered, HDC FAR* phdcScreen);
void FAR SpbCheck(void);
BOOL FAR SpbCheckRect2(SPB* pspb, HWND hwnd, LPRECT lprc, DWORD flagsDcx);

// LockWindowUpdate related stuff

extern HWND hwndLockUpdate;
extern HQ   hqLockUpdate;

void FAR InternalInvalidate(register HWND hwnd, HRGN hrgnUpdate, WORD flags);
BOOL InternalInvalidate2(HWND hwnd, HRGN hrgn, HRGN hrgnSubtract, LPRECT prcParents, WORD flags);
void _fastcall DeleteUpdateRgn(HWND hwnd);

// SmartRectInRegion return codes
//
#define RIR_OUTSIDE 0
#define RIR_INTERSECT   1
#define RIR_INSIDE  2

WORD FAR SmartRectInRegion(HRGN hrgn, LPRECT lprc);

// Function used to redraw the screen

#define RedrawScreen()              \
    InternalInvalidate(hwndDesktop, (HRGN)1,   \
        RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN)

extern HRGN hrgnInv1;       // Temp used by RedrawWindow()
extern HRGN hrgnInv2;       // Temp used by InternalInvalidate()

HDC CALLBACK InternalBeginPaint(HWND hwnd, PAINTSTRUCT FAR *lpps, BOOL fWindowDC);

// Background and frame drawing related stuff

// WM_SYNCPAINT wParam and DoSyncPaint flags

void FAR DoSyncPaint(HWND hwnd, HRGN hrgn, WORD flags);

// NOTE: the first 4 values must be as defined for backward compatibility
// reasons.  They are sent as parameters to the WM_SYNCPAINT message.
// They used to be hard-coded constants.
//
// Only ENUMCLIPPEDCHILDREN, ALLCHILDREN, and NOCHECKPARENTS are passed on
// during recursion.  The other bits reflect the current window only.
//
#define DSP_ERASE       0x0001      // Send WM_ERASEBKGND
#define DSP_FRAME       0x0002      // Send WM_NCPAINT
#define DSP_ENUMCLIPPEDCHILDREN 0x0004      // Enum children if WS_CLIPCHILDREN
#define DSP_WM_SYNCPAINT    0x0008      // Called from WM_SYNCPAINT handler
#define DSP_NOCHECKPARENTS  0x0010      // Don't check parents for update region
#define DSP_ALLCHILDREN     0x0020      // Enumerate all children.

BOOL FAR SendEraseBkgnd(HWND hwnd, HDC hdcBeginPaint, HRGN hrgnUpdate);
void SendNCPaint(HWND hwnd, HRGN hrgnUpdate);
HWND _fastcall ParentNeedsPaint(HWND hwnd);

// UpdateWindow definitions

#define UW_ENUMCHILDREN     0x0001
#define UW_VALIDATEPARENTS  0x0002

void InternalUpdateWindow(HWND hwnd, WORD flags);
void UpdateWindow2(register HWND hwnd, WORD flags);
void ValidateParents(register HWND hwnd);

// Used for UpdateWindow() calls that really shouldn't be there...
#define UpdateWindow31(hwnd)

// ScrollWindow() definitions

extern HRGN hrgnSW;
extern HRGN hrgnScrl1;
extern HRGN hrgnScrl2;
extern HRGN hrgnScrlVis;
extern HRGN hrgnScrlSrc;
extern HRGN hrgnScrlDst;
extern HRGN hrgnScrlValid;
extern HRGN hrgnScrlUpdate;

// Scroll bar definitions

typedef struct tagSBINFO
{
   int   pos;
   int   posMin;
   int   posMax;
   int   cpxThumb;
   int   cpxArrow;
   int   cpx;
   int   pxMin;
   int   cxBorder;
   int   cyBorder;
   int   nBar;
   HWND  calcHwnd; /* used to identify the window described by this info */
} SBINFO;

// The following masks can be used along with the wDisableFlags field of SB
// to find if the Up/Left or Down/Right arrow or Both are disabled;
// Now it is possible to selectively Enable/Disable just one or both the
// arrows in a scroll bar control;
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.
#define SBFLAGSINDEX  6      // Index of Scroll bar flags in Wnd->rgwScroll[]

typedef struct tagSB
  {
    WND  wnd;
    int  pos;
    int  min;
    int  max;
    BOOL fVert;
    WORD wDisableFlags; // Indicates which arrow is disabled;
#ifdef DBCS_IME
    BOOL bImeStatus;    // IME status save
#endif
  } SB;

typedef SB *PSB;
typedef SB FAR *LPSB;

/* Structure for list of drivers installed by USER and opened by applications.
 */

typedef struct tagDRIVERTABLE
{
  WORD   fBusy:1;
  WORD   fFirstEntry:1;
  int    idNextDriver;      /* Next driver in load chain -1 if end */
  int    idPrevDriver;      /* Prev driver in load chain -1 if begin */
  HANDLE hModule;
  DWORD  dwDriverIdentifier;
  char   szAliasName[128];
  LRESULT (FAR * lpDriverEntryPoint)(DWORD, HDRVR, WORD, LPARAM, LPARAM);
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LRESULT FAR InternalLoadDriver(LPCSTR szDriverName,
                             LPCSTR szSectionName,
                             LPCSTR lpstrTail,
                             WORD  cbTail,
                             BOOL  fSendEnable);
WORD FAR InternalFreeDriver(HDRVR hDriver, BOOL fSendDisable);

/* Defines for InternalBroadcastDriverMessage flags */
#define IBDM_SENDMESSAGE       0x00000001
#define IBDM_REVERSE           0x00000002
#define IBDM_FIRSTINSTANCEONLY 0x00000004

LRESULT FAR InternalBroadcastDriverMessage(HDRVR, WORD, LPARAM, LPARAM, LONG);

/* Application queue structure */

#define MSGQSIZE    10

typedef struct tagQ
  {
    HQ          hqNext;
    HTASK   hTask;
    int         cbEntry;
    int         cMsgs;
    WORD        pmsgRead;
    WORD        pmsgWrite;
    WORD        pmsgMax;
    LONG        timeLast;    /* Time, position, and ID of last message */
    POINT       ptLast;
    int         idLast;
    DWORD   dwExtraInfoLast;  /* Additional info */
    WORD    unused;
    LPARAM  lParam;
    WPARAM  wParam;
    int         message;
    HWND        hwnd;
    LRESULT result;
    int         cQuit;
    int         exitCode;
    WORD        flags;
    WORD    pMsgFilterChain;
    HGLOBAL hDS;
    int         wVersion;
    HQ          hqSender;
    HQ          hqSendList;
    HQ          hqSendNext;
    WORD    cPaintsReady;
    WORD    cTimersReady;
    WORD        changebits;
    WORD        wakebits;
    WORD        wakemask;
    WORD        pResult;
    WORD        pResultSend;
    WORD        pResultReceive;
    HOOKNODE*   phkCurrent;
    HOOKNODE*   rgphkHooks[WH_CHOOKS];
    DWORD       semInput;
    HQ          hqSemNext;
    INTERNALMSG rgmsg[MSGQSIZE];
  } Q;
typedef Q FAR *LPQ;

// NOTE: These macros can be recoded to be much faster if
// hqCurrent and lpqCurrent are defined as globals that are set
// at task switch time.
//
#define Lpq(hq)     ((LPQ)MAKELP((hq), 0))
#define LpqFromHq(hq)   Lpq(hq)
#define LpqCurrent()    ((LPQ)(MAKELP(HqCurrent(), 0)))

typedef WORD ICH;

// Q flags field bits

#define QF_SEMWAIT        0x01
#define QF_INIT           0x02
#define QF_PALETTEAPP     0x04  /* This app used the palette */

// Internal GetQueueStatus() flags

#define QS_SMRESULT   0x8000
#define QS_SMPARAMSFREE   0x4000

/* Capture codes */
#define NO_CAP_CLIENT   0   /* no capture; in client area */
#define NO_CAP_SYS  1   /* no capture; in sys area */
#define CLIENT_CAPTURE  2   /* client-relative capture */
#define WINDOW_CAPTURE  3   /* window-relative capture */
#define SCREEN_CAPTURE  4   /* screen-relative capture */

// Extra bytes needed for specific window classes
//
#define CBEDITEXTRA     6
#define CBSTATICEXTRA   6
#ifdef DBCS_IME
#define CBBUTTONEXTRA   4   /* need one byte for IME status save */
#else
#define CBBUTTONEXTRA   3
#endif
#define CBMENUEXTRA 2

/* DrawBtnText codes */
#define DBT_TEXT    0x0001
#define DBT_FOCUS   0x0002

/* RIP error codes */
#define RIP_SEMCHECK        0xFFF4  /* Decimal -12 */
#define RIP_SWP             0xFFF1  /* Decimal -15 */ /* SetMultipleWindowPos */
#define RIP_MEMALLOC        0x0001   /* Insufficient memory for allocation */
#define RIP_MEMREALLOC      0x0002   /* Error realloc memory */
#define RIP_MEMFREE         0x0003   /* Memory cannot be freed */
#define RIP_MEMLOCK         0x0004   /* Memory cannot be locked */
#define RIP_MEMUNLOCK       0x0005   /* Memory cannot be unlocked */
#define RIP_BADGDIOBJECT    0x0006   /* Invalid GDI object */
#define RIP_BADWINDOWHANDLE 0x0007   /* Invalid Window handle */
#define RIP_DCBUSY          0x0008   /* Cached display contexts are busy */
#define RIP_NODEFWINDOWPROC 0x0009
#define RIP_CLIPBOARDOPEN   0x000A
#define RIP_GETDCWITHOUTRELEASE 0x000B /* App did a GetDC and destroyed window without release*/
#define RIP_INVALKEYBOARD   0x000C
#define RIP_INVALMOUSE      0x000D
#define RIP_INVALCURSOR     0x000E
#define RIP_DSUNLOCKED      0x000F
#define RIP_INVALLOCKSYSQ   0x0010
#define RIP_CARETBUSY       0x0011
#define RIP_GETCWRANGE      0x0012
#define RIP_HWNDOWNSDCS     0x0013  /* One hwnd owns all the DCs */
#define RIP_BADHQ           0x0014  /* operation on something of wrong task */
#define RIP_BADDCGRAY       0x0015  /* bad dc gray               */
#define RIP_REFCOUNTOVERFLOW  0x0016  /* Ref Count in CLS overflows */
#define RIP_REFCOUNTUNDERFLOW 0x0017  /* Ref Count in CLS becomes negative */
#define RIP_COUNTBAD          0x0018  /* Ref Count should be zero; But not so */
#define RIP_INVALIDWINDOWSTYLE 0x0019 /* Illegal window style bits were set */
#define RIP_GLOBALCLASS       0x001A /* An application that registered a global
                  * class is terminating, but the reference
                  * count is non-zero(somebody else is using
                                  * it). */
#define RIP_BADHOOKHANDLE   0x001B
#define RIP_BADHOOKID       0x001C
#define RIP_BADHOOKPROC     0x001D
#define RIP_BADHOOKMODULE   0x001E
#define RIP_BADHOOKCODE     0x001F
#define RIP_HOOKNOTALLOWED  0x0020

#define RIP_UNREMOVEDPROP   0x0021
#define RIP_BADPROPNAME     0x0022
#define RIP_BADTASKHANDLE   0x0023

#define RIP_GETSETINFOERR1    0x0027   /* Bad negative index for Get/Set/Window etc., */
#define RIP_GETSETINFOERR2    0x0028   /* Bad Positive index for Get/Set/Window etc., */

#define RIP_DIALOGBOXDESTROYWINDOWED 0x0029 /* App called DestroyWindow on a DialogBox window */
#define RIP_WINDOWIDNOTFOUND     0x002A /* Dialog control ID not found */
#define RIP_SYSTEMERRORBOXFAILED 0x002B /* Hard sys error box failed due to no hq */
#define RIP_INVALIDMENUHANDLE    0x002C /* Invalid hMenu */
#define RIP_INVALIDMETAFILEINCLPBRD 0x002D /* Invalid meta file pasted into clipboard */
#define RIP_MESSAGEBOXWITHNOQUEUE      0x002E  /* MessageBox called with no message queue initialized */
#define RIP_DLGWINDOWEXTRANOTALLOCATED 0x002F  /* DLGWINDOWEXTRA bytes not allocated for dlg box */
#define RIP_INTERTASKSENDMSGHANG       0x0030  /* Intertask send message with tasks locked */

#define RIP_INVALIDPARAM          0x0031   /* Invalid parameter passed to a function */
#define RIP_ASSERTFAILED          0x0032
#define RIP_INVALIDFUNCTIONCALLED 0x0033  /* Invalid function was called */
#define RIP_LOCKINPUTERROR        0x0034   /* LockInput called when input was already locked or when never locked.*/
#define RIP_NULLWNDPROC           0x0035   /* SetWindowLong uses a NULL wnd proc */
#define RIP_BAD_UNHOOK        0x0036   /* SetWindowsHook is used to unhook.     */
#define RIP_QUEUE_FULL            0x0037   /* PostMessage failed due to full queue. */

#ifdef DEBUG

#define DebugFillStruct DebugFillBuffer

#define DebugErr(flags, sz) \
    { static char CODESEG rgch[] = "USER: "sz; DebugOutput((flags) | DBF_USER, rgch); }

extern char CODESEG ErrAssertFailed[];

#define Assert(f)       ((f) ? TRUE : (DebugOutput(DBF_ERROR, ErrAssertFailed), FALSE))

extern BOOL fRevalidate;

#define DONTREVALIDATE() fRevalidate = FALSE;

VOID FAR CheckCbDlgExtra(HWND hwnd);

#else

#define DebugErr(flags, sz)

#define Assert(f)       FALSE

#define DONTREVALIDATE()

#define CheckCbDlgExtra(hwnd)

#endif

#define UserLogError(flags, errcode, sz)    \
        { DebugErr((flags), sz); \
          LogError(errcode, NULL); }

#define BM_CLICK        WM_USER+99
#define CH_PREFIX       '&'
#define CH_HELPPREFIX   0x08

#if defined(JAPAN) || defined(KOREA)
// Japan and Korea support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
//
#define CH_ENGLISHPREFIX    0x1E
#define CH_KANJIPREFIX      0x1F

#define KMM_ENGLISH     2       // English/Romaji menu mode
#define KMM_KANJI       3       // Kanji/Hangeul menu mode
extern int  KanjiMenuMode;
#endif

/* The total number of strings used as Button strings in MessageBoxes */
#define  MAX_MB_STRINGS    8

/* Dialog box activation border width factor. */
#define CLDLGFRAME          4
#define CLDLGFRAMEWHITE     0

/* Constants for onboard bitmap save. */
#define ONBOARD_SAVE    0x0000
#define ONBOARD_RESTORE 0x0001
#define ONBOARD_CLEAR   0x0002

/* Bitmap resource IDs */
#define BMR_ICON    1
#define BMR_BITMAP  2
#define BMR_CURSOR  3
#define BMR_DEVDEP  0
#define BMR_DEVIND  1
#define BMR_DEPIND  2

/* PID definitions */
#define get_PID               0
#define get_EMSSave_area      1
#define dont_free_banks       2
#define free_PIDs_banks       3
#define free_handle           4
#define memory_sizes          5
#define DDE_shared            6

// SetWindowPos() related structures and definitions
//
extern HRGN hrgnInvalidSum;
extern HRGN hrgnVisNew;
extern HRGN hrgnSWP1;
extern HRGN hrgnValid;
extern HRGN hrgnValidSum;
extern HRGN hrgnInvalid;

// CalcValidRects() "Region Empty" flag values
// A set bit indicates the corresponding region is empty.
//
#define RE_VISNEW   0x0001  // CVR "Region Empty" flag values
#define RE_VISOLD   0x0002  // A set bit indicates the
#define RE_VALID    0x0004  // corresponding region is empty.
#define RE_INVALID      0x0008
#define RE_SPB          0x0010
#define RE_VALIDSUM     0x0020
#define RE_INVALIDSUM   0x0040

typedef struct tagCVR       // cvr
{
    WINDOWPOS   pos;        // MUST be first field of CVR!
    int     xClientNew; // New client rectangle
    int     yClientNew;
    int     cxClientNew;
    int     cyClientNew;
    RECT    rcBlt;
    int     dxBlt;      // Distance blt rectangle is moving
    int     dyBlt;
    WORD    fsRE;       // RE_ flags: whether hrgnVisOld is empty or not
    HRGN    hrgnVisOld; // Previous visrgn
} CVR;

typedef struct tagSMWP      // smwp
{
    int     ccvr;       // Number of CVRs in the SWMP
    int     ccvrAlloc;  // Number of actual CVRs allocated in the SMWP
    BOOL    fInUse;
    WORD    signature;  // signature word for handle validation
    CVR     rgcvr[1];
} SMWP;

#define SMWP_SIG    ('W' | ('P' << 8))

#define PEMWP   HDWP

#define NEAR_SWP_PTRS
#ifdef  NEAR_SWP_PTRS

typedef SMWP* PSMWP;
typedef CVR*  PCVR;
#else

typedef SMWP FAR* PSMWP;
typedef CVR  FAR* PCVR;
#endif

BOOL  ValidateSmwp(PSMWP psmwp, BOOL FAR* pfSyncPaint);
HWND  SmwpFindActive(PSMWP psmwp);
void  SendChangedMsgs(PSMWP psmwp);
BOOL  ValidateWindowPos(WINDOWPOS FAR *ppos);
BOOL  BltValidBits(PSMWP psmwp);
BOOL  SwpCalcVisRgn(HWND hwnd, HRGN hrgn);
BOOL  CombineOldNewVis(HRGN hrgn, HRGN hrgnVisOld, HRGN hrgnVisNew, WORD crgn, WORD fsRgnEmpty);
void  CalcValidRects(PSMWP psmwp, HWND FAR* phwndNewActive);
BOOL  ValidateZorder(PCVR pcvr);
PSMWP ZOrderByOwner(PSMWP psmwp);
PSMWP AddCvr(PSMWP psmwp, HWND hwnd, HWND hwndInsertAfter, WORD flags);
BOOL  SwpActivate(HWND hwndNewActive);

void FAR HandleWindowPosChanged(HWND hwnd, WINDOWPOS FAR *lppos);
void FAR OffsetChildren(HWND hwnd, int dx, int dy, LPRECT prcHitTest);
BOOL FAR IntersectWithParents(HWND hwnd, LPRECT lprcParents);

// Preallocated buffers for use during SetWindowPos to prevent memory
// allocation failures.
//
#define CCVR_WORKSPACE      4
#define CCVR_MSG_WORKSPACE  2

#define CB_WORKSPACE     ((sizeof(SMWP) - sizeof(CVR)) + CCVR_WORKSPACE * sizeof(CVR))
#define CB_MSG_WORKSPACE ((sizeof(SMWP) - sizeof(CVR)) + CCVR_MSG_WORKSPACE * sizeof(CVR))

extern BYTE workspace[];
extern BYTE msg_workspace[];

typedef struct tagSTAT
  {
    WND wnd;
    HFONT  hFont;
    HBRUSH hBrush;
    HICON  hIcon;
  } STAT;
typedef STAT *PSTAT;

#define IsCrlf(x)       ((char)(x)==0x0D)

/* Help Engine stuff  */

typedef struct
  {
   unsigned short cbData;               /* Size of data                     */
   unsigned short usCommand;            /* Command to execute               */
   unsigned long  ulTopic;              /* Topic/context number (if needed) */
   unsigned long  ulReserved;           /* Reserved (internal use)          */
   unsigned short offszHelpFile;        /* Offset to help file in block     */
   unsigned short offabData;            /* Offset to other data in block    */
   } HLP;

typedef HLP FAR *LPHLP;

typedef HANDLE HDCS;

/* DrawFrame() Commands */
#define DF_SHIFT0       0x0000
#define DF_SHIFT1       0x0001
#define DF_SHIFT2       0x0002
#define DF_SHIFT3       0x0003
#define DF_PATCOPY      0x0000
#define DF_PATINVERT        0x0004

#define DF_SCROLLBAR        (COLOR_SCROLLBAR << 3)
#define DF_BACKGROUND       (COLOR_BACKGROUND << 3)
#define DF_ACTIVECAPTION    (COLOR_ACTIVECAPTION << 3)
#define DF_INACTIVECAPTION  (COLOR_INACTIVECAPTION << 3)
#define DF_MENU         (COLOR_MENU << 3)
#define DF_WINDOW       (COLOR_WINDOW << 3)
#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)
#define DF_MENUTEXT     (COLOR_MENUTEXT << 3)
#define DF_WINDOWTEXT       (COLOR_WINDOWTEXT << 3)
#define DF_CAPTIONTEXT      (COLOR_CAPTIONTEXT << 3)
#define DF_ACTIVEBORDER     (COLOR_ACTIVEBORDER << 3)
#define DF_INACTIVEBORDER   (COLOR_INACTIVEBORDER << 3)
#define DF_APPWORKSPACE     (COLOR_APPWORKSPACE << 3)
#define DF_GRAY         (DF_APPWORKSPACE + (1 << 3))


#ifdef FASTFRAME

typedef struct   tagFRAMEBITMAP
{
    int     x;  /* Top Left co-ordinates */
    int     y;
    int     dx; /* Width of the bitmap  */
    int     dy; /* Height of the bitmap */
}   FRAMEBITMAP;

#define  FB_THICKFRAME    FALSE
#define  FB_DLGFRAME      TRUE

#define  FB_ACTIVE  0
#define  FB_INACTIVE    1

#define  FB_HORZ    0
#define  FB_VERT    1
#define  FB_DLG_HORZ    2
#define  FB_DLG_VERT    3
#define  FB_CAPTION 4

typedef struct   tagFRAMEDETAILS
{
    HBITMAP     hFrameBitmap[5][2];  /* indices explained above */
    FRAMEBITMAP ActBorderH[4];    /* Four parts of Thick frame Horz bitmap */
    FRAMEBITMAP ActBorderV[4];
    FRAMEBITMAP DlgFrameH[4];     /* Four parts of Dlg Frame Horz bitmap */
    FRAMEBITMAP DlgFrameV[4];
    FRAMEBITMAP CaptionInfo[7];
    int         clBorderWidth;
}   FRAMEDETAILS;

typedef  FRAMEBITMAP *PFRAMEBITMAP;

// Fast frame related macros
#define  FC_ACTIVEBORDER    0x01
#define  FC_INACTIVEBORDER  0x02
#define  FC_ACTIVECAPTION   0x04
#define  FC_INACTIVECAPTION 0x08
#define  FC_WINDOWFRAME     0x10

#define  FC_ACTIVEBIT       0x01
#define  FC_INACTIVEBIT         0x02
#define  FC_STATUSBITS      (FC_ACTIVEBIT | FC_INACTIVEBIT)

#endif  /* FASTFRAME */

// The following defines the components of nKeyboardSpeed
#define KSPEED_MASK 0x001F      // Defines the key repeat speed.
#define KDELAY_MASK     0x0060      // Defines the keyboard delay.
#define KDELAY_SHIFT    5


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Secret Imports -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifndef   MSDWP

/* Imported from Kernel. */
HQ     FAR GetTaskQueue(HTASK);
HQ     FAR SetTaskQueue(HTASK, HQ);
void   FAR LockCurrentTask(BOOL);
HANDLE FAR emscopy();
//void   FAR ExitKernel(int);
int    FAR LocalCountFree(void);
int    FAR LocalHeapSize(void);
BOOL   FAR IsWinoldapTask(HTASK);
WORD   FAR GetExeVersion(void);
DWORD  FAR GetTaskDS(void);
void   FAR SetTaskSignalProc(WORD, FARPROC);
DWORD  FAR GetHeapSpaces(HMODULE hModule);
int    FAR IsScreenGrab(void);

/* Imported from GDI. */
int API IntersectVisRect(HDC, int, int, int, int);
int API ExcludeVisRect(HDC, int, int, int, int);
int API SelectVisRgn(HDC, HRGN);
int API SaveVisRgn(HDC);
int API RestoreVisRgn(HDC);
HRGN    API InquireVisRgn(HDC);
HDCS    API GetDCState(HDC);
BOOL    API SetDCState(HDC, HDCS);
HFONT   API GetCurLogFont(HDC);       // From GDI
#define     SwapHandle(foo)

HANDLE  FAR GDIInit2(HANDLE, HANDLE);
HRGN    API GetClipRgn(HDC);
HBITMAP FAR CreateUserBitmap(int, int, int, int, LONG);
void    FAR UnRealizeObject(HBRUSH);
void    FAR LRCCFrame(HDC, LPRECT, HBRUSH, DWORD);
void    FAR Death(HDC);
void    FAR Resurrection(HDC, LONG, LONG, LONG);
void    FAR DeleteAboveLineFonts(void);
BOOL    FAR GDIInitApp(void);
HBITMAP FAR CreateUserDiscardableBitmap(HDC, int, int);
void    FAR FinalGDIInit(HBRUSH);
void    FAR GDIMoveBitmap(HBITMAP);
BOOL    FAR IsValidMetaFile(HMETAFILE);
#define     GDIMoveBitmap(d1)

#endif      /*  MSDWP  */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DS Global Variables (from WINDS.C)                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

//***** Initialization globals

extern HINSTANCE hInstanceWin;
extern HMODULE hModuleWin;

//WORD rgwSysMet[]; // Defined in winmisc2.asm

//***** System mode globals

extern BOOL    fDialog;            // Dialog box is active
extern BOOL    fEndSession;        // Shutting down system
extern BOOL    fTaskIsLocked;          // LockTask() called

extern BOOL    fMessageBox;        // hard message box active
extern HWND    hwndSysModal;

extern HQ      hqAppExit;              // hq of app in app termination code

//***** System option settings globals

extern int     nKeyboardSpeed;         // keyboard repeat rate

extern int     iScreenSaveTimeOut;     // screen saver timeout

extern BOOL    fHires;             /* VERTRES > 300?               */
extern BOOL    fPaletteDisplay;        /* Are we on a palette display driver?      */
extern BOOL    fEdsunChipSet;          /* Edsun vga chip set?              */

//***** Window manager globals

extern HWND    hwndDesktop;        // Desktop window

extern PCLS    pclsList;           // List of registered classes

extern PBWL    pbwlCache;          // BuildWindowList() globals
extern PBWL    pbwlList;

//***** Input globals

extern BOOL    fThunklstrcmp;      // if TRUE we thunk to Win32

extern WORD    idSysPeek;          /* ID in sys queue of msg being looked at   */

extern DWORD   timeLastInputMessage;     // Time of the last keyboard, mouse, or
                  // other input message.

extern HWND    hwndCursor;

extern HWND    hwndDblClk;         // doubleclick parsing
extern RECT    rcDblClk;
extern WORD    dtDblClk;
extern WORD    msgDblClk;
extern DWORD   timeDblClk;

extern int     defQueueSize;           // Default msg queue size

extern HTASK   hTaskLockInput;         /* Task which has called LockInput() */

extern KBINFO  keybdInfo;
extern BYTE    *pState;            // Pointer to buffer for ToAscii

extern BOOL    fShrinkGDI;         /* Does GDI's heap needs shrinking?         */
extern BOOL    fLockNorem;         /* PeekMsg NOREMOVE flag            */

//***** Activation/Focus/Capture related globals

extern HWND    hwndActive;
extern HWND    hwndActivePrev;

extern HWND    hwndFocus;

extern int     codeCapture;
extern HWND    hwndCapture;

//***** SetWindowPos() related globals

extern HRGN hrgnInvalidSum;        // Temps used by SetWindowPos()
extern HRGN hrgnVisNew;
extern HRGN hrgnSWP1;
extern HRGN hrgnValid;
extern HRGN hrgnValidSum;
extern HRGN hrgnInvalid;

#ifdef LATER
// Are these still needed now that SysErrorBox() is working?
#endif

extern BYTE workspace[];           // Buffers used to prevent mem alloc
extern BYTE msg_workspace[];           // failures in messagebox

//***** General graphics globals

extern HDC     hdcBits;            /* DC with User's bitmaps                   */
extern HDC     hdcMonoBits;        /* DC with User's MONO bitmaps              */

extern OEMINFO         oemInfo;
extern OEMINFOMONO     oemInfoMono;

extern RESINFO         resInfo;
extern RESINFOMONO     resInfoMono;

extern SYSCLROBJECTS   sysClrObjects;
extern SYSCOLORS       sysColors;

extern HFONT   hFontSys;        // alias for GetStockObject(SYSTEM_FONT);
extern HFONT   hFontSysFixed;       // alias for GetStockObject(SYSTEM_FIXED_FONT);
extern HBRUSH  hbrWhite;        // alias for GetStockObject(WHITE_BRUSH);
extern HBRUSH  hbrBlack;        // alias for GetStockObject(BLACK_BRUSH);
extern HPALETTE hPalDefaultPalette; // alias for GetStockObject(DEFAULT_PALETTE);

//***** DC Cache related globals

extern DCE*    pdceFirst;       /* Ptr to first entry in cache */

extern HRGN    hrgnEWL;            // Temp used by ExcludeWindowList()
extern HRGN    hrgnGDC;          // Temp used by GetCacheDC() et al
extern HRGN    hrgnDCH;          // Temp used by DCHook()

extern HRGN    hrgnNull;           // empty rgn
extern HRGN    hrgnScreen;         // rcScreen-sized rgn

extern HDCS    hdcsReset;

extern HDC     hdcScreen;

//***** Begin/EndDrawBuffer() globals

#ifdef DISABLE
extern HWND    hwndBuffer;
extern HBITMAP hbmBuffer;
extern HBITMAP hbmBufferSave;
extern int     cxBuffer;
extern int     cyBuffer;
extern int     dxBuffer;
extern DCE*    pdceBuffer;
extern int     dxBufferVisRgn;
extern int     dyBufferVisRgn;
extern BOOL    fBufferFlushed;
extern RECT    rcBuffer;

extern HDCS    hdcsMemReset;
#endif

//***** LockWindowUpdate related globals

extern HQ      hqLockUpdate;
extern HWND    hwndLockUpdate;

//***** SPB related globals

extern SPB     *pspbFirst;

extern HRGN    hrgnSCR;          // Temp used by SpbCheckRect()
extern HRGN    hrgnSPB1;
extern HRGN    hrgnSPB2;

extern HRGN    hrgnInv0;                 // Temps used by InternalInvalidate()
extern HRGN    hrgnInv1;
extern HRGN    hrgnInv2;

//***** General Metrics

extern RECT    rcScreen;        // Screen rectangle
extern int     cxScreen;        // Screen height/width
extern int     cyScreen;

extern BOOL    fBeep;             /* Warning beeps allowed?           */

extern int     cxSysFontChar;       // System font metrics
extern int     cxSysFontOverhang;
extern int     cySysFontAscent;
extern int     cySysFontChar;
extern int     cySysFontExternLeading;

extern int     cxBorder;        // Nominal border width/height
extern int     cyBorder;

extern int     cyCaption;       // height of caption

extern int     cxSize;          // dimensions of system menu bitmap
extern int     cySize;

extern int     cyHScroll;       // scroll bar dimensions
extern int     cxVScroll;

extern int     cxSlot;          // icon slot dimensions
extern int     cySlot;

//***** ScrollWindow/ScrollDC related globals

extern HRGN    hrgnSW;           // Temps used by ScrollDC/ScrollWindow
extern HRGN    hrgnScrl1;
extern HRGN    hrgnScrl2;
extern HRGN    hrgnScrlVis;
extern HRGN    hrgnScrlSrc;
extern HRGN    hrgnScrlDst;
extern HRGN    hrgnScrlValid;
extern HRGN    hrgnScrlUpdate;

//***** Clipboard globals

extern int     cNumClipFormats;      // Number of formats in clipboard
extern CLIP    *pClipboard;      // Clipboard data
extern HQ      hqClipLock;       // hq of app accessing clipboard
extern HWND    hwndClipOwner;        // clipboard owner
extern HWND    hwndClipViewer;       // clipboard viewer
extern BOOL    fClipboardChanged;    // TRUE if DrawClipboard needs to be called
extern BOOL    fDrawingClipboard;    // TRUE if inside DrawClipboard()
extern HWND    hwndClipOpen;         // hwnd of app accessing clipboard
extern BOOL    fCBLocked;        /* Is clibboard locked? */

//***** Fast frame drawing globals

#ifdef FASTFRAME
extern BOOL    fFastFrame;
extern FRAMEDETAILS   Frame;
#endif  /* FASTFRAME */

//***** WinOldAppHackoMaticFlags

extern WORD    winOldAppHackoMaticFlags;   /* Flags for doing special things for
                                       winold app */
//***** TaskManager exec globals

extern PSTR    pTaskManName;           // Task manager file name

//***** atom management globals

extern HANDLE  hWinAtom;           // global atom manager heap

//***** WM_HOTKEY globals

extern PSTR    pHotKeyList;  /* Pointer to list of hot keys in system. */
extern int     cHotKeyCount;       /* Count of hot keys in list. */

//***** WinHelp() globals

extern WORD    msgWinHelp;

//***** SetWindowsHook() system hook table

extern HOOKNODE*  rgphkSysHooks[];
extern HOOKNODE*  phkDeleted;

//***** Driver management globals

extern int     cInstalledDrivers;      /* Count of installed driver structs allocated*/
extern HDRVR  hInstalledDriverList;   /* List of installable drivers */
extern int     idFirstDriver;              /* First driver in load chain */
extern int     idLastDriver;               /* Last driver in load chain */

//***** Display driver globals

extern HINSTANCE hInstanceDisplay;

extern BOOL    fOnBoardBitmap;         /* Can display save bitmaps onboard?    */
extern BOOL    (CALLBACK *lpSaveBitmap)(LPRECT lprc, WORD flags);
extern VOID    (CALLBACK *lpDisplayCriticalSection)(BOOL fLock);
extern VOID    (CALLBACK *lpWin386ShellCritSection)(VOID);
typedef int   (FAR *FARGETDRIVERPROC)(int, LPCSTR);
extern FARGETDRIVERPROC      lpfnGetDriverResourceId;

//***** Comm driver definitions and globals

// Comm driver constants
//
#define LPTx     0x80   /* Mask to indicate cid is for LPT device   */
#define LPTxMask 0x7F   /* Mask to get      cid    for LPT device   */

#define PIOMAX  3   /* Max number of LPTx devices in high level */
#define CDEVMAX 10  /* Max number of COMx devices in high level */
#define DEVMAX  (CDEVMAX+PIOMAX) /* Max number of devices in high level */

// qdb - queue definition block
//
typedef struct {
    char far    *pqRx;                  /* pointer to rx queue          */
    int         cbqRx;                  /* size of RX Queue in bytes    */
    char far    *pqTx;                  /* Pointer to TX Queue          */
    int         cbqTx;                  /* Size of TX Queue in bytes    */
} qdb;

// cinfo - Communications Device Information
//
typedef struct
{
    WORD   fOpen    : 1;       /* Device open flag         */
    WORD   fchUnget : 1;       /* Flag for backed-up character */
    WORD   fReservedHardware:1;    /* Reserved for hardware (mouse etc) */
    HTASK  hTask;          /* Handle to task who opened us */
    char   chUnget;        /* Backed-up character      */
    qdb    qdbCur;         /* Queue information        */
} cinfo;

extern cinfo rgcinfo[];

extern int (FAR PASCAL *lpCommWriteString)(int, LPCSTR, WORD);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
extern int (FAR PASCAL *lpCommReadString)(int, LPSTR, WORD);
                   /* Ptr to the comm driver's
                * commreadstring function. Only
                * exists in 3.1 drivers.
                */
extern BOOL (FAR PASCAL *lpCommEnableNotification)(int, HWND, int, int);
                  /* Ptr to the comm driver's
                   * EnableNotification function.
                   * Only exists in 3.1 drivers.
                   */

//***** PenWinProc globals
/* Ptr to register us as pen aware dlg box
 */
extern VOID (CALLBACK *lpRegisterPenAwareApp)(WORD i, BOOL fRegister);


//***** Resource handler globals

extern RSRCHDLRPROC lpDefaultResourceHandler;

//***** NLS related globals

extern HINSTANCE hLangDrv;    /* The module handle of the language driver */
extern FARPROC  fpLangProc;  /* The entry point into the language driver */

#ifdef DBCS_IME
extern HINSTANCE hWinnls;     /* WINNLS.DLL module handle */
#endif

//***** Caret globals

extern CARET   caret;
extern HQ      hqCaret;

//***** Cursor globals

extern CURSORINFO cursInfo;

#ifdef LATER
// Is this array big enough?
#endif

extern HCURSOR rghCursor[];

extern HBITMAP hbmCursorBitmap;        /* Pre created bitmap for SetCursor */
extern HGLOBAL hPermanentCursor;       /* Precreated permanent cursor resource */

extern HCURSOR hCurCursor;

extern HCURSOR hCursNormal;
extern HCURSOR hCursUpArrow;
extern HCURSOR hCursIBeam;
extern HCURSOR hCursSizeAll;

//INT iLevelCursor; NOTE: overlays sys metrics array (winmisc2.asm)

//***** Icon globals

extern HICON   hIconBang;
extern HICON   hIconHand;
extern HICON   hIconNote;
extern HICON   hIconQues;
extern HICON   hIconSample;
extern HICON   hIconWarn;
extern HICON   hIconErr;

extern HBITMAP hbmDrawIconMono;        /* Pre created bitmaps for drawicon */
extern HBITMAP hbmDrawIconColor;       /* Pre created bitmaps for drawicon */

extern HTASK   hTaskGrayString;      /* Task in graystring */

//***** Desktop/Wallpaper globals

extern HBITMAP hbmDesktop;         /* Monochrome Desktop pattern */
extern HBITMAP hbmWallpaper;           /* Bitmap that will be drawn on the desktop */

//***** Window move/size tracking globals

extern RECT    rcDrag;
extern RECT    rcWindow;
extern RECT    rcParent;
extern WORD    cmd;
extern HICON   hdragIcon;
extern BOOL    fTrack;
extern int     dxMouse;
extern int     dyMouse;
extern int     impx;
extern int     impy;
extern HWND    hwndTrack;
extern BOOL    fInitSize;
extern POINT   ptMinTrack;
extern POINT   ptMaxTrack;
extern BOOL    fmsKbd;
extern POINT   ptRestore;
extern HCURSOR hIconWindows;           /* Cool windows icon */
extern BOOL    fDragFullWindows;       /* Drag xor rect or full windows */

/* Added flag to stop anyone from setting the cursor while
 * we are moving the hDragIcon.  This was done to fix a bug in micrografix
 * Draw (They are doing a Setcursor() whenever they get a paint message).
 */
extern BOOL    fdragIcon;        // Prevent SetCursor while dragging icon

/* When an iconic window is moved around with a mouse, IsWindowVisible() call
 * returns FALSE! This is because, the window is internally hidden and what is
 * visible is only a mouse cursor! But how will the Tracer guys know this?
 * They won't! So, when an Icon window is moved around, its hwnd is preserved
 * in this global and IsWindowVisible() will return a true for
 * this window!
 */
extern HWND    hwndDragIcon;

//***** MessageBox globals

extern int     cntMBox;            // Nesting level for overlap tiling of mboxes
extern WORD    wDefButton;         // index of current default button
extern WORD    wMaxBtnSize;        // width of biggest button in any message box

//***** Size border metric globals

extern int     clBorder;           /* # of logical units in window frame       */
extern int     cxSzBorder;         /* Window border width (cxBorder*clBorder)  */
extern int     cySzBorder;         /* Window border height (cyBorder*clBorder) */
extern int     cxSzBorderPlus1;        /* cxBorder*(clBorder+1). We overlap a line */
extern int     cySzBorderPlus1;        /* cyBorder*(clBorder+1). We overlap a line */

//***** Window tiling/cascading globals

extern int     cxyGranularity; /* Top-level window grid granularity */
extern int     cyCWMargin;     /* Space on top of toplevel window 'stack'  */
extern int     cxCWMargin;     /* Space on right of toplevel window 'stack'*/
extern int     iwndStack;

extern int     cxHalfIcon;         // rounding helpers for icon positioning
extern int     cyHalfIcon;

//***** Alt-tab switching globals

extern HWND    hwndAltTab;
extern HWND    hwndSwitch;
extern HWND    hwndKbd;
extern BOOL    fFastAltTab;        /* Don't use Tandy's switcher? */
extern BOOL    fInAltTab;

//***** Icon title globals

extern int     cyTitleSpace;
extern BOOL    fIconTitleWrap;         /* Wrap icon titles or just use single line? */
extern LOGFONT iconTitleLogFont;       /* LogFont struct for icon title font */
extern HFONT   hIconTitleFont;       /* Font used in icon titles */

//***** GrayString globals

extern HBRUSH  hbrGray;          // GrayString globals.
extern HBITMAP hbmGray;
extern HDC     hdcGray;
extern int     cxGray;           // current dimensions of hbmGray
extern int     cyGray;

//***** WM_GETMINMAXINFO globals

extern POINT   rgptMinMaxWnd[];
extern POINT   rgptMinMax[];

//***** Menu globals

extern int     menuSelect;
extern int     mnFocus;

extern HANDLE  hMenuHeap;        /* Menu heap */
extern _segment menuBase;
extern HANDLE  hMenuStringHeap;
extern _segment menuStringBase;


//PPOPUPMENU pGlobalPopupMenu;        // mnloop.c

extern HWND    hwndRealPopup;

extern BOOL    fMenu;            /* Using a menu?                */
extern BOOL    fSysMenu;
extern BOOL    fInsideMenuLoop;      /* MenuLoop capture?            */

extern BOOL    fMenuStatus;
extern int     iActivatedWindow;/* This global is examined in the menu loop
                 * code so that we exit from menu mode if
                 * another window was activated while we were
                 * tracking menus.  This global is incremented
                 * whenever we activate a new window.
                 */
extern WORD    iDelayMenuShow;         /* Delay till the hierarchical menu is shown*/
extern WORD    iDelayMenuHide;         /* Delay till the hierarchical menu is hidden
                   when user drags outside of it */
extern HMENU   hSysMenu;

extern HBITMAP hbmSysMenu;
extern RECT    rcSysMenuInvert;

//***** Scroll bar globals

extern ATOM    atomScrollBar;          /* Atom for the scrollbar control wnd class */
extern HWND    hwndSB;
extern HWND    hwndSBNotify;
extern HWND    hwndSBTrack;
extern int     dpxThumb;
extern int     posOld;
extern int     posStart;
extern int     pxBottom;
extern int     pxDownArrow;
extern int     pxLeft;
extern int     pxOld;
extern int     pxRight;
extern int     pxStart;
extern int     pxThumbBottom;
extern int     pxThumbTop;
extern int     pxTop;
extern int     pxUpArrow;
extern BOOL    fHitOld;
extern int     cmdSB;
extern VOID (*pfnSB)(HWND, WORD, WPARAM, LPARAM);
extern RECT    rcSB;
extern RECT    rcThumb;
extern RECT    rcTrack;
extern BOOL    fTrackVert;
extern BOOL    fCtlSB;
extern WORD    hTimerSB;
extern BOOL    fVertSB;
extern SBINFO  *psbiSB;
extern SBINFO  sbiHorz;
extern SBINFO  sbiVert;
extern int     cmsTimerInterval;

//***** Control globals

extern ATOM atomSysClass[];

//***** Constant strings

extern char    szUNTITLED[];
extern char    szERROR[];
extern char    szOK[];
extern char    szCANCEL[];
extern char    szABORT[];
extern char    szRETRY[];
extern char    szIGNORE[];
extern char    szYYES[];
extern char    szCLOSE[];
extern char    szNO[];

extern char    szAM[];
extern char    szPM[];
extern PSTR    pTimeTagArray[];

extern char    szAttr[];
extern char    szOEMBIN[];
extern char    szDISPLAY[];
extern char    szOneChar[];
extern char    szSLASHSTARDOTSTAR[];
extern char    szYes[];
extern char    szNullString[];

#ifdef DEBUG

extern char CODESEG ErrAssertFailed[];
extern char CODESEG ErrInvalParam[];

#endif

#ifdef JAPAN
extern char    szJWordBreak[];      // Japanese word breaking char table
#endif

#ifdef KOREA
void   FAR SetLevel(HWND);
BOOL   FAR RequestHanjaMode(HWND, LPSTR);
WORD   FAR PASCAL TranslateHangeul(WORD);
#endif

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Global Variables from ASM files                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern BYTE rgbKeyState[];
extern int  iLevelCursor;
extern WORD rgwSysMet[];

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  INTDS interrupt-accessible globals
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern BOOL INTDSSEG fInt24;
extern BOOL INTDSSEG fMouseMoved;
extern BOOL INTDSSEG fEnableInput;
extern BOOL INTDSSEG fSwapButtons;
extern BOOL INTDSSEG fQueueDirty;
extern BOOL INTDSSEG fInScanTimers;

extern BYTE INTDSSEG vKeyDown;
extern BYTE INTDSSEG TimerTable[];
extern BYTE INTDSSEG rgbAsyncKeyState[];

extern BYTE* INTDSSEG TimerTableMax;

extern char INTDSSEG szDivZero[];
extern char INTDSSEG szNull[];
extern char INTDSSEG szSysError[];


extern DWORD   INTDSSEG tSysTimer;

#ifdef DOS30
extern INTDSSEGPROC INTDSSEG lpSysProc;
#endif

extern HANDLE INTDSSEG hSysTimer;

extern TIMERINFO INTDSSEG timerInfo;

extern  WORD __WinFlags;
#define WinFlags    ((WORD)(&__WinFlags))

// Input globals

#ifdef DISABLE
extern WORD modeInput;
#endif

extern HQ   INTDSSEG hqSysLock;      /* HQ of guy who is looking at current event */
extern WORD INTDSSEG idSysLock;   /* Msg ID of event that is locking sys queue */
extern POINT INTDSSEG ptTrueCursor;
extern POINT INTDSSEG ptCursor;
extern RECT  INTDSSEG rcCursorClip;

extern WORD INTDSSEG MouseSpeed;
extern WORD INTDSSEG MouseThresh1;
extern WORD INTDSSEG MouseThresh2;
extern WORD INTDSSEG cMsgRsrv;
extern WORD INTDSSEG x_mickey_rate;
extern WORD INTDSSEG y_mickey_rate;
extern WORD INTDSSEG cur_x_mickey;
extern WORD INTDSSEG cur_y_mickey;
extern WORD INTDSSEG cxScreenCS;
extern WORD INTDSSEG cyScreenCS;
extern WORD INTDSSEG cQEntries;
extern WORD INTDSSEG dtSysTimer;

extern DWORD INTDSSEG dtJournal;
extern WORD INTDSSEG msgJournal;
extern BOOL INTDSSEG fJournalPlayback;

extern WORD INTDSSEG rgMsgUpDowns[];
extern DWORD INTDSSEG lpMouseStack;
extern LPVOID INTDSSEG prevSSSP;
extern BYTE  INTDSSEG nestCount;

extern WORD INTDSSEG cHotKeyHooks;

extern HQ   INTDSSEG hqActive;
extern HQ   INTDSSEG hqList;
extern HQ   INTDSSEG hqCursor;
extern HQ   INTDSSEG hqSysQueue;
extern HQ   INTDSSEG hqSysModal;
extern HQ   INTDSSEG hqMouse;
extern HQ   INTDSSEG hqKeyboard;
extern HQ   INTDSSEG hqCapture;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Assembly Function Declarations                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifdef WOWEDIT
void FAR LCopyStruct(CONST VOID FAR* lpSrc, LPVOID lpDest, WORD cb);
#else
/*
 why is this required? Its here for the intrinsic pragma
 to recognize memcpy ... jonle on a saturday!
*/
#ifndef WOWDBG
LPVOID	memcpy(LPVOID lpDst, LPVOID lpSrc, int cb);
#endif

#pragma intrinsic(memcpy)
#define LCopyStruct(s,d,n) memcpy((LPVOID)(d),(LPVOID)(s),(int)(n))
#endif
WORD FAR GetAppVer(void);

#ifndef MSDWP

/* Suppport routines for separate segment stuff. */
#undef min
#undef max
#define min(a, b)   ((int)(a) < (int)(b) ? (int)(a) : (int)(b))
#define max(a, b)   ((int)(a) > (int)(b) ? (int)(a) : (int)(b))
#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define umax(a, b)  ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

int    FAR MultDiv(WORD a, WORD b, WORD c);
void   FAR LFillStruct(LPVOID, WORD, WORD);
HDC    FAR GetClientDc(void);
HQ     FAR HqCurrent(void);
BOOL   FAR ActivateWindow(HWND, WORD);

BOOL  CheckHwndFilter(HWND, HWND);
BOOL  CheckMsgFilter(WORD, WORD, WORD);
BOOL  WriteMessage(HQ, LONG, WORD, WORD, HWND, DWORD);
BOOL  ReceiveMessage(VOID);
VOID  FlushSentMessages(VOID);
LPSTR  WINAPI lstrcpyn(LPSTR, LPCSTR, int);

#define PSTextOut(a, b, c, d, e)  TextOut(a, b, c, d, e)
#define PSGetTextExtent(a, b, c) GetTextExtent(a, b, c)
#define PSFillRect(a, b, c) FillRect(a, b, c)
#define PSInvertRect(a, b)  InvertRect(a, b)
WORD   FAR GetNextSysMsg(WORD, INTERNALSYSMSG FAR *);
void   FAR SkipSysMsg(SYSMSG FAR *, BOOL);

void       TransferWakeBit(WORD);
void       ClearWakeBit(WORD, BOOL);
void       SetWakeBit(HQ, WORD);
void   FAR FarSetWakeBit(HQ, WORD);
void   FAR InitSysQueue(void);
BOOL   FAR CreateQueue(int);
void       DeleteQueue(void);
void       SuspendTask(void);
void       ReleaseTask(void);

void   FAR GlobalInitAtom(void);

void       MoveRect(LONG);
void       SizeRect(LONG);

BOOL   FAR SysHasKanji(void);

void   FAR SetDivZero(void);

int    FAR FindCharPosition(LPCSTR, char);

void   FAR OEMSetCursor(LPSTR);
void   FAR SetFMouseMoved(void);
BOOL       AttachDC(HWND);
BOOL       LastApplication(void);
void       CheckCursor(HWND);
void   FAR IncPaintCount(HWND);
void   FAR DecPaintCount(HWND);
void   FAR DeleteProperties(HWND);
void   FAR DestroyTimers(HQ, HWND);

int    FAR InquireSystem(int, int);
int    FAR EnableKeyboard(FARPROC, LPSTR);
int    FAR InquireKeyboard(LPSTR);
void   FAR DisableKeyboard(void);
int    FAR EnableMouse(FARPROC);
int    FAR InquireMouse(LPSTR);
void   FAR DisableMouse(void);
int    FAR InquireCursor(LPSTR);
void   FAR EnableSystemTimers(void);
void   FAR DisableSystemTimers(void);
void   FAR CreateSystemTimer(int, TIMERPROC);
WORD   FAR SetSystemTimer(HWND, int, int, TIMERPROC);
BOOL   FAR KillSystemTimer(HWND, int);

void   FAR CrunchX2(CURSORSHAPE FAR *, CURSORSHAPE FAR *, int, int);
void   FAR CrunchY(CURSORSHAPE FAR *, CURSORSHAPE FAR *, int, int, int);

void   FAR MenuBarDraw(HWND hwnd, HDC hdc, int cxFrame, int cyFrame);

BOOL   FAR ReadMessage(HQ, LPMSG, HWND, WORD, WORD, BOOL);

int    GetCurrentDrive(void);
int    GetCurrentDirectory(LPSTR, int);
int    SetCurrentDrive(int);
int    SetCurrentDirectory(LPCSTR);
BOOL       FFirst(LPSTR, LPSTR, WORD);
BOOL       FNext(LPSTR, WORD);

FAR    DestroyAllWindows(void);

BOOL   FAR LockWindowVerChk(HWND);

#ifndef  NOFASTFRAME
void  FAR SplitRectangle(LPRECT, LPRECT, int, int); /* WinRect.asm */
#endif

#endif  /* MSDWP */

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Internal Function Declarations                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifndef MSDWP

LRESULT CALLBACK ButtonWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK StaticWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK TitleWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SwitchWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DesktopWndProc(HWND hwndIcon, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MenuWindowProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT FAR  EditWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK LBoxCtlWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ComboBoxCtlWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SBWndProc(PSB psb, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MDIClientWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);

void FAR SkipSM2(void);
HWND FAR GetFirstTab(HWND hwnd);
CONST BYTE FAR* SkipSz(CONST BYTE FAR *lpsz);
void FAR DlgSetFocus(HWND hwnd);
HWND FAR PrevChild(HWND hwndDlg, HWND hwnd);
HWND FAR NextChild(HWND hwndDlg, HWND hwnd);
HWND FAR GetFirstLevelChild(HWND hwndDlg, HWND hwndLevel);
void FAR CheckDefPushButton(HWND hwndDlg, HWND hwndOldFocus, HWND hwndNewFocus);
HWND FAR GotoNextMnem(HWND hwndDlg, HWND hwndStart, char ch);
int  FAR FindMnemChar(LPSTR lpstr, char ch, BOOL fFirst, BOOL fPrefix);
int  FAR FindNextValidMenuItem(PMENU pMenu, int i, int dir, BOOL fHelp);
BOOL CALLBACK MenuPrint(HDC hdc, LPARAM lParam, int cch);
int  FAR MenuBarCompute(HMENU hMenu, HWND hwndNotify, int yMenuTop, int xMenuLeft, int cxMax);
HMENU CALLBACK LookupMenuHandle(HMENU hMenu, WORD cmd);
BOOL CALLBACK StaticPrint(HDC hdc, LPRECT lprc, HWND hwnd);

HICON FAR ColorToMonoIcon(HICON);
HGLOBAL CALLBACK LoadCursorIconHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
HGLOBAL CALLBACK LoadDIBCursorHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
HGLOBAL CALLBACK LoadDIBIconHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
void CallOEMCursor(void);
void FAR DestroyClipBoardData(void);
BOOL FAR SendClipboardMessage(int message);
void FAR DrawClipboard(void);
PCLIP FAR FindClipFormat(WORD format);
BOOL         IsDummyTextHandle(PCLIP pClip);
HANDLE       InternalSetClipboardData(WORD format, HANDLE hData);

PPCLS FAR GetClassPtr(LPCSTR lpszClassName, HINSTANCE hInstance, BOOL fUserModule);
PPCLS     GetClassPtrASM(ATOM, HMODULE, BOOL);
void FAR DelWinClass(PPCLS  ppcls);

VOID CALLBACK CaretBlinkProc(HWND hwnd, WORD message, WORD id, DWORD time);
void FAR InternalHideCaret(void);
void FAR InternalShowCaret(void);
void FAR InternalDestroyCaret(void);
HDC  FAR GetScreenDC(void);
PBWL FAR BuildHwndList(HWND hwnd, int flags);
void FAR FreeHwndList(PBWL pbwl);
void CALLBACK  DrawFrame(HDC hdc, LPRECT lprect, int clFrame, int cmd);
void FAR RedrawFrame(HWND hwnd);
void FAR BltColor(HDC, HBRUSH, HDC, int, int, int, int, int, int, BOOL);
void FAR EnableInput(void);
void FAR DisableInput(void);
void FAR CopyKeyState(void);
void CALLBACK  EnableOEMLayer(void);
void CALLBACK  DisableOEMLayer(void);
void FAR ColorInit(void);
BOOL FAR SetKeyboardSpeed(BOOL fInquire);
void FAR InitBorderSysMetrics(void);
void FAR InitSizeBorderDimensions(void);
void FAR SetMinMaxInfo(void);

// Returns TRUE if a GetDC() will return an empty visrgn or not
// (doesn't take into account being clipped away; just checks WFVISIBE
// and WFMINIMIZED)
//
BOOL FAR IsVisible(HWND hwnd, BOOL fClient);

// Returns TRUE if hwndChild == hwndParent or is one of its children.
//
BOOL FAR IsDescendant(HWND hwndParent, HWND hwndChild);

void FAR SetRedraw(HWND hwnd, BOOL fRedraw);
HBRUSH CALLBACK GetControlColor(HWND hwndParent, HWND hwndCtl, HDC hdc, WORD type);
HBRUSH CALLBACK GetControlBrush(HWND hwnd, HDC hdc, WORD type);
void FAR StoreMessage(LPMSG lpMsg, HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam, DWORD time);
LONG FAR GetPrefixCount(LPCSTR lpstr, int cch, LPSTR lpstrCopy, int copycount);
void FAR PSMTextOut(HDC hdc, int xLeft, int yTop, LPCSTR lpsz, int cch);
DWORD FAR PSMGetTextExtent(HDC hdc, LPCSTR lpstr, int cch);
HWND FAR GetTopLevelTiled(HWND hwnd);
BOOL FAR TrueIconic(HWND hwnd);
void FAR ChangeToCurrentTask(HWND hwnd1, HWND hwnd2);

HWND FAR GetLastTopMostWindow(void);
void FAR SendSizeMessage(HWND hwnd, WORD cmdSize);
HWND FAR NextTopWindow(HWND hwnd, HWND hwndSkip, BOOL fPrev, BOOL fDisabled);

void FAR DisableVKD(BOOL fDisable);
void FAR CheckFocus(HWND hwnd);
BOOL CALLBACK FChildVisible(HWND hwnd);
#define InternalGetClientRect(hwnd, lprc)   CopyRect(lprc, &hwnd->rcClient)
void FAR CheckByteAlign(HWND hwnd, LPRECT lprc);
void FAR CancelMode(HWND hwnd);
void FAR RedrawIconTitle(HWND hwnd);
void FAR DisplayIconicWindow(HWND hwnd, BOOL fActivate, BOOL fShow);
DWORD FAR GetIconTitleSize(HWND hwnd);
BOOL FAR SendZoom(HWND hwnd, LPARAM lParam);
BOOL CALLBACK  DestroyTaskWindowsEnum(HWND hwnd, LPARAM lParam);
void CALLBACK  LockMyTask(BOOL fLock);
void CALLBACK RepaintScreen(void);
HANDLE FAR BcastCopyString(LPARAM lParam);
BOOL CALLBACK SignalProc(HTASK hTask, WORD message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK NewSignalProc(HTASK hTask, WORD message, WPARAM wParam, LPARAM lParam);
HWND FAR GetWindowCreator(HWND hwnd);

void FAR InitSendValidateMinMaxInfo(HWND hwnd);
void FAR DrawDragRect(LPRECT lprc, WORD flags);
void FAR MoveSize(HWND hwnd, WORD cmdMove);
BYTE FAR SetClrWindowFlag(HWND hwnd, WORD style, BYTE cmd);
void FAR ParkIcon(HWND hwnd, CHECKPOINT * pcp);
void FAR ShowOwnedWindows(HWND hwndOwner, WORD cmdShow);
HWND FAR MinMaximize(HWND hwnd, WORD cmd, BOOL fKeepHidden);
void FAR SetTiledRect(HWND hwnd, LPRECT lprc);
#endif  // MSDWP
void FAR AdjustSize(HWND hwnd, LPINT lpcx, LPINT lpcy);
#ifndef MSDWP

void FAR NextWindow(WORD flags);
void FAR DoScroll(HWND hwnd, HWND hwndNotify, int cmd, int pos, BOOL fVert);
void CALLBACK ContScroll(HWND hwnd, WORD message, WORD id, DWORD time);
void FAR MoveThumb(HWND hwnd, int px, BOOL fCancel);
void FAR SBTrackInit(HWND hwnd, LPARAM lParam, int curArea);
void FAR DrawSize(HWND hwnd, HDC hdc, int cxFrame, int cyFrame, BOOL fBorder);
void FAR CalcSBStuff(HWND hwnd, BOOL fVert);
WORD     GetWndSBDisableFlags(HWND, BOOL);
void     FreeWindow(HWND hwnd);
void FAR DestroyTaskWindows(HQ hq);
BOOL FAR TrackInitSize(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
void FAR DrawPushButton(HDC hdc, LPRECT lprc, WORD style, BOOL fInvert, HBRUSH hbrBtn, HWND hwnd);
void FAR DrawBtnText(HDC hdc, HWND hwnd, BOOL dbt, BOOL fDepress);
void FAR Capture(HWND hwnd, int code);
int  FAR SystoChar(WORD message, LPARAM lParam);
void FAR LinkWindow(HWND, HWND, HWND *);
void FAR UnlinkWindow(HWND, HWND *);
void FAR DrawScrollBar(HWND hwnd, HDC hdc, BOOL fVert);
void CALLBACK  PaintRect(HWND hwndBrush, HWND hwndPaint, HDC hdc, HBRUSH hbr, LPRECT lprc);

BOOL FAR SetDeskPattern(LPSTR);
BOOL FAR SetDeskWallpaper(LPSTR);
void FAR SetGridGranularity(WORD);

int  FAR GetAveCharWidth(HDC);
#ifndef NOTEXTMETRIC
int  FAR GetCharDimensions(HDC, TEXTMETRIC FAR *);
#endif

BOOL FAR LW_ReloadLangDriver(LPSTR);
HBRUSH FAR GetSysClrObject(int);
int  API SysErrorBox(LPCSTR lpszText, LPCSTR lpszCaption, unsigned int btn1, unsigned int btn2, unsigned int btn3);
BOOL FAR SnapWindow(HWND hwnd);
WORD  FAR MB_FindLongestString(void);
#ifdef FASTFRAME
HBITMAP FAR CreateCaptionBitmaps(void);
HBITMAP FAR CreateBorderVertBitmaps(BOOL fDlgFrame);
HBITMAP FAR CreateBorderHorzBitmaps(BOOL fDlgFrame);
void FAR GetCaptionBitmapsInfo(FRAMEBITMAP Caption[], HBITMAP hBitmap);
void FAR GetHorzBitmapsInfo(FRAMEBITMAP Bitmap[], BOOL fDlgFrame, HBITMAP hBitmap);
void FAR GetVertBitmapsInfo(FRAMEBITMAP Bitmap[], BOOL fDlgFrame, HBITMAP hBitmap);
BOOL FAR DrawIntoCaptionBitmaps(HDC   hdc,HBITMAP hBitmap, FRAMEBITMAP FrameInfo[], BOOL fActive);
BOOL FAR DrawIntoHorzBitmaps(HDC hdc, HBITMAP hBitmap, FRAMEBITMAP FrameInfoH[], BOOL fActive, BOOL fDlgFrame);
BOOL FAR DrawIntoVertBitmaps(HDC hdc, HBITMAP hBitmap, FRAMEBITMAP FrameInfoH[], FRAMEBITMAP FrameInfoV[], BOOL fActive, BOOL fDlgFrame);
BOOL FAR RecreateFrameBitmaps(void);
void FAR DeleteFrameBitmaps(int, int);
BOOL FAR PASCAL UpdateFrameBitmaps(WORD  wColorFlags);
BOOL FAR PASCAL RecolorFrameBitmaps(WORD wColorFlags);
#endif  /* FASTFRAME */

void PostButtonUp(WORD msg);

#endif  /*  MSDWP  */


void CALLBACK EndMenu(void);
void CALLBACK FillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc, HBRUSH hbr);
void FAR SysCommand(HWND hwnd, int cmd, LPARAM lParam);
void FAR HandleNCMouseGuys(HWND hwnd, WORD message, int htArea, LPARAM lParam);
void FAR EndScroll(HWND hwnd, BOOL fCancel);
HWND FAR GetTopLevelWindow(HWND hwnd);
void FAR RedrawIconTitle(HWND hwnd);
int  FAR FindNCHit(HWND hwnd, LONG lPt);
void FAR CalcClientRect(HWND hwnd, LPRECT lprc);
BOOL FAR DepressTitleButton(HWND hwnd, RECT rcCapt, RECT rcInvert, WORD hit);
void FAR SetSysMenu(HWND hwnd);
HMENU FAR GetSysMenuHandle(HWND hwnd);
int *FAR InitPwSB(HWND hwnd);
BOOL FAR DefSetText(HWND hwnd, LPCSTR lpsz);
void FAR DrawWindowFrame(HWND hwnd, HRGN hrgnClip);
void FAR ShowIconTitle(HWND hwnd, BOOL fShow);
HBRUSH FAR GetBackBrush(HWND hwnd);
BOOL FAR IsSystemFont(HDC);
BOOL FAR IsSysFontAndDefaultMode(HDC);
VOID FAR DiagOutput(LPCSTR);
VOID FAR UserDiagOutput(int, LPCSTR);
#define UDO_INIT     0
#define UDO_INITDONE 1
#define UDO_STATUS   2


HANDLE FAR TextAlloc(LPCSTR);
HANDLE FAR TextFree(HANDLE);
WORD   FAR TextCopy(HANDLE, LPSTR, WORD);
#define TextPointer(h)  (LPSTR)MAKELP(hWinAtom, h)

BOOL CALLBACK FARValidatePointer(LPVOID);

// GDI exports
#ifdef DEBUG
VOID CALLBACK SetObjectOwner(HGDIOBJ, HINSTANCE);
#else
#define SetObjectOwner(d1, d2)
#endif
BOOL CALLBACK MakeObjectPrivate(HGDIOBJ, BOOL);
VOID CALLBACK GDITaskTermination(HTASK);
VOID CALLBACK RealizeDefaultPalette(HDC);

// Internal functions called directly by debug version to
// prevent validation errors
//
#ifdef DEBUG
HDC  API IGetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);
BOOL API IGrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);
BOOL API IRedrawWindow(HWND hwnd, CONST RECT FAR* lprcUpdate, HRGN hrgnUpdate, WORD flags);
int  API IScrollWindowEx(HWND hwnd, int dx, int dy,
        CONST RECT FAR* prcScroll, CONST RECT FAR* prcClip,
        HRGN hrgnUpdate, RECT FAR* prcUpdate, WORD flags);
#endif

#ifdef DBCS_IME
#define WM_IMECONTROL   WM_USER
void FAR InitIME(void);                 // wmcaret.c
BOOL _loadds FAR EnableIME( HWND, BOOL );       // wmcaret.c
VOID API SetImeBoundingRect(HWND, DWORD, LPRECT);   // wmcaret.c
BOOL API ControlIME(HWND, BOOL);            // wmcaret.c
HANDLE API SetFontForIME(HWND, HANDLE);         // wmcaret.c
VOID API ControlCaretIme(BOOL);             // wmcaret.c
BOOL API EatString(HWND, LPSTR, WORD);          // editec.c
VOID API CheckKatanaInstalled(HWND);            // wmcaret.c
#endif

#ifdef JAPAN
// Save time of WM_LBUTTONDOWN and WM_LBUTTONUP, used to decided
// whether to lock large popup menus that cover the static portion
// of the menu...
extern int     fLongPMenu;
extern DWORD   lbuttondown_time;
#endif

/****************************************************************************

    debugging support

****************************************************************************/

#ifdef DEBUG

    extern void cdecl dDbgOut(int iLevel, LPSTR lpszFormat, ...);
    extern void cdecl dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    #define dprintf                          dDbgOut

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))
    #define WinEval(exp) \
        ((__dwEval=(DWORD)(LPVOID)(exp)) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

    #define dprintf /##/
//  #define dprintf  if (0) ((int (*)(char *, ...)) 0)

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\rmload.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  RMLOAD.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 12-Apr-1991 by Nigel Thompson (nigelt)
 *  Much hacked about version of the Win 3.1 rmload.c source
 *  It doesn't attempt any device driver resource loading
 *  or do anything to support Win 2.x apps.
 *
 *  Revised 19-May-1991 by Jeff Parsons (jeffpar)
 *  IFDEF'ed everything except LoadString;  because of the client/server
 *  split in USER32, most resources are copied to the server's context and
 *  freed in the client's, meaning the client no longer gets a handle to
 *  a global memory object.  We could give it one, but it would be a separate
 *  object, which we would have to keep track of, and which would be difficult
 *  to keep in sync with the server's copy if changes were made.
--*/

/****************************************************************************/
/*                                      */
/*  RMLOAD.C -                                  */
/*                                      */
/*  Resource Loading Routines.                      */
/*                                      */
/****************************************************************************/

#define RESOURCESTRINGS
#include "user.h"
#include "multires.h"

//
// We define certain things here because including mvdm\inc\*.h files here
// will lead to endless mess.
//

DWORD API NotifyWow(WORD, LPBYTE);

typedef struct _LOADACCEL16 {    /* ldaccel */
    WORD   hInst;
    WORD   hAccel;
    LPBYTE pAccel;
    DWORD  cbAccel;
} LOADACCEL16, FAR *PLOADACCEL16;

/* This must match its counterpart in mvdm\inc\wowusr.h */
#define NW_LOADACCELERATORS        3 //


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadAccelerators() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

HACCEL API ILoadAccelerators(HINSTANCE hInstance, LPCSTR lpszAccName)
{
    HRSRC hrl;
    HACCEL hAccel = NULL;
    LOADACCEL16 loadaccel;

    hrl = FindResource(hInstance, lpszAccName, RT_ACCELERATOR);
#ifdef WOW
    if (hrl) {
        hAccel = (HACCEL)LoadResource(hInstance, hrl);
        if (hAccel) {

            // create 32bit accelerator and 16-32 alias.

            loadaccel.hInst = (WORD)hInstance;
            loadaccel.hAccel = (WORD)hAccel;
            loadaccel.pAccel = (LPBYTE)LockResource(hAccel);
            loadaccel.cbAccel = (DWORD)SizeofResource(hInstance, hrl);

            if (NotifyWow(NW_LOADACCELERATORS, (LPBYTE)&loadaccel)) {
                UnlockResource(hAccel);
            }
            else {
                UnlockResource(hAccel);
                hAccel = NULL;
            }
        }

    }

    return (hAccel);
#else
    if (!hrl)
    return NULL;

    return (HACCEL)LoadResource(hInstance, hrl);
#endif
}



int API ILoadString(
    HINSTANCE    h16Task,
    UINT         wID,
    LPSTR        lpBuffer,
    register int nBufferMax)
{
    HANDLE   hResInfo;
    HANDLE   hStringSeg;
    LPSTR    lpsz;
    register int cch, i;

    /* Make sure the parms are valid. */
    if (!lpBuffer || (nBufferMax-- == 0))
    return(0);

    cch = 0;

    /* String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResource(h16Task, (LPSTR)((LONG)((wID >> 4) + 1)), RT_STRING))
      {
    /* Load that segment. */
    hStringSeg = LoadResource(h16Task, hResInfo);

    /* Lock the resource. */
    if (lpsz = (LPSTR)LockResource(hStringSeg))
      {
        /* Move past the other strings in this segment. */
        wID &= 0x0F;
        while (TRUE)
          {
        cch = *((BYTE FAR *)lpsz++);
        if (wID-- == 0)
            break;
        lpsz += cch;
          }

        /* Don't copy more than the max allowed. */
        if (cch > nBufferMax)
        cch = nBufferMax;

        /* Copy the string into the buffer. */
        LCopyStruct(lpsz, lpBuffer, cch);

        GlobalUnlock(hStringSeg);

        /* BUG: If we free the resource here, we will have to reload it
         *      immediately for many apps with sequential strings.
         *      Force it to be discardable however because non-discardable
         *      string resources make no sense.   Chip
         */
        GlobalReAlloc(hStringSeg, 0L,
              GMEM_MODIFY | GMEM_MOVEABLE | GMEM_DISCARDABLE);
      }
      }

    /* Append a NULL. */
    lpBuffer[cch] = 0;

    return(cch);
}


#ifdef NEEDED

#define  DIB_RGB_COLORS  0

HBITMAP FAR  PASCAL ConvertBitmap(HBITMAP hBitmap);
HANDLE  NEAR PASCAL LoadDIBCursorIconHandler(HANDLE, HANDLE, HANDLE, BOOL);
WORD    FAR  PASCAL GetIconId(HANDLE, LPSTR);
HBITMAP FAR  PASCAL StretchBitmap(int, int, int, int, HBITMAP, BYTE, BYTE);
WORD    NEAR PASCAL StretchIcon(LPCURSORSHAPE, WORD, HBITMAP, BOOL);
WORD    NEAR PASCAL SizeReqd(BOOL, WORD, WORD, BOOL, int, int);
WORD    NEAR PASCAL CrunchAndResize(LPCURSORSHAPE, BOOL, BOOL, BOOL, BOOL);
HANDLE  FAR  PASCAL LoadCursorIconHandler2(HANDLE, LPCURSORSHAPE, WORD);
HANDLE  FAR  PASCAL LoadDIBCursorIconHandler2(HANDLE, LPCURSORSHAPE, WORD, BOOL);

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadIconHandler() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

HICON FAR PASCAL LoadIconHandler(hIcon, fNewFormat)

HICON   hIcon;
BOOL    fNewFormat;

{
  LPCURSORSHAPE lpIcon;
  WORD      wSize;

    dprintf(7,"LoadIconHandler");
  wSize = (WORD)GlobalSize(hIcon);
  lpIcon = (LPCURSORSHAPE)(GlobalLock(hIcon));

  if (fNewFormat)
      return(LoadDIBCursorIconHandler2(hIcon, lpIcon, wSize, TRUE));
  else
      return(LoadCursorIconHandler2(hIcon, lpIcon, wSize));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  FindIndividualResource()                            */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL FindIndividualResource(register HANDLE hResFile,
                      LPSTR       lpszName,
                      LPSTR       lpszType)

{
  WORD        idIcon;
  register HANDLE h;

    dprintf(7,"FindIndividualResource");
  /* Check if the resource is to be taken from the display driver.
   * If so, check the driver version; If the resource is to be taken from
   * the application, check the app version.
   */

  if ((lpszType != RT_BITMAP) && ((LOWORD(GetExpWinVer(hResFile)) >= VER)))
    {
      /* Locate the directory resource */
      h = SplFindResource(hResFile, lpszName, (LPSTR)(lpszType + DIFFERENCE));
      if (h == NULL)
      return((HANDLE)0);

      /* Load the directory resource */
      h = LoadResource(hResFile, h);

      /* Get the name of the matching resource */
      idIcon = GetIconId(h, lpszType);

      /* NOTE: Don't free the (discardable) directory resource!!! - ChipA */
      /*
       * We should not call SplFindResource here, because idIcon is
       * internal to us and GetDriverResourceId won't know how tomap it.
       */
      return(FindResource(hResFile, MAKEINTRESOURCE(idIcon), lpszType));
    }
  else
      /* It is an Old app; The resource is in old format */
      return(SplFindResource(hResFile, lpszName, lpszType));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetBestFormIcon()                               */
/*                                      */
/*  Among the different forms of Icons present, choose the one that     */
/*  matches the PixelsPerInch values and the number of colors of the        */
/*  current display.                                    */
/*                                          */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL GetBestFormIcon(LPRESDIR  ResDirPtr,
                 WORD      ResCount)

{
  register WORD wIndex;
  register WORD ColorCount;
  WORD      MaxColorCount;
  WORD      MaxColorIndex;
  WORD      MoreColorCount;
  WORD      MoreColorIndex;
  WORD      LessColorCount;
  WORD      LessColorIndex;
  WORD      DevColorCount;

    dprintf(7,"GetBestFormIcon");
  /* Initialse all the values to zero */
  MaxColorCount = MaxColorIndex = MoreColorCount =
  MoreColorIndex = LessColorIndex = LessColorCount = 0;

  /* get number of colors on device.  if device is very colorful,
  ** set to a high number without doing meaningless 1<<X operation.
  */
  if (oemInfo.ScreenBitCount >= 16)
      DevColorCount = 32000;
  else
      DevColorCount = 1 << oemInfo.ScreenBitCount;

  for (wIndex=0; wIndex < ResCount; wIndex++, ResDirPtr++)
    {
      /* Check for the number of colors */
      if ((ColorCount = (ResDirPtr->ResInfo.Icon.ColorCount)) <= DevColorCount)
    {
      if (ColorCount > MaxColorCount)
        {
              MaxColorCount = ColorCount;
          MaxColorIndex = wIndex;
        }
    }

      /* Check for the size */
      /* Match the pixels per inch information */
      if ((ResDirPtr->ResInfo.Icon.Width == (BYTE)oemInfo.cxIcon) &&
          (ResDirPtr->ResInfo.Icon.Height == (BYTE)oemInfo.cyIcon))
    {
      /* Matching size found */
      /* Check if the color also matches */
          if (ColorCount == DevColorCount)
          return(wIndex);  /* Exact match found */

          if (ColorCount < DevColorCount)
        {
          /* Choose the one with max colors, but less than reqd */
              if (ColorCount > LessColorCount)
        {
                  LessColorCount = ColorCount;
          LessColorIndex = wIndex;
        }
        }
      else
        {
              if ((LessColorCount == 0) && (ColorCount < MoreColorCount))
        {
                  MoreColorCount = ColorCount;
          MoreColorIndex = wIndex;
        }
        }
    }
    }

  /* Check if we have a correct sized but with less colors than reqd */
  if (LessColorCount)
      return(LessColorIndex);

  /* Check if we have a correct sized but with more colors than reqd */
  if (MoreColorCount)
      return(MoreColorIndex);

  /* Check if we have one that has maximum colors but less than reqd */
  if (MaxColorCount)
      return(MaxColorIndex);

  return(0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetBestFormCursor()                             */
/*                                      */
/*   Among the different forms of cursors present, choose the one that      */
/*   matches the width and height defined by the current display driver.    */
/*                                          */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL GetBestFormCursor(LPRESDIR  ResDirPtr,
                   WORD      ResCount)

{
  register WORD  wIndex;

    dprintf(7,"GetBestFormCursor");
  for (wIndex=0; wIndex < ResCount; wIndex++, ResDirPtr++)
    {
      /* Match the Width and Height of the cursor */
      if ((ResDirPtr->ResInfo.Cursor.Width  == oemInfo.cxCursor) &&
          ((ResDirPtr->ResInfo.Cursor.Height >> 1) == oemInfo.cyCursor))
      return(wIndex);
    }

  return(0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetIconId()                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD FAR PASCAL GetIconId(hRes, lpszType)

HANDLE   hRes;
LPSTR    lpszType;

{
  WORD        w;
  LPRESDIR    ResDirPtr;
  LPNEWHEADER     DataPtr;
  register WORD   RetIndex;
  register WORD   ResCount;

    dprintf(7,"GetIconId");
  if ((DataPtr = (LPNEWHEADER)LockResource(hRes)) == NULL)
      return(0);

  ResCount = DataPtr->ResCount;
  ResDirPtr = (LPRESDIR)(DataPtr + 1);

  switch (LOWORD((DWORD)lpszType))
    {
      case RT_ICON:
       RetIndex = GetBestFormIcon(ResDirPtr, ResCount);
       break;

      case RT_CURSOR:
       RetIndex = GetBestFormCursor(ResDirPtr, ResCount);
       break;
    }

  if (RetIndex == ResCount)
      RetIndex = 0;

  ResCount = ((LPRESDIR)(ResDirPtr+RetIndex))->idIcon;

  UnlockResource(hRes);

  return(ResCount);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  UT_LoadCursorIconBitmap() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL UT_LoadCursorIconBitmap(register HANDLE hrf,
                       LPSTR       lpszName,
                       int         type)

{
  register HANDLE h;

    dprintf(7,"LoadCursorIconBitmap");
  if (hrf == NULL) return (HANDLE)0; // no 2.x support - NigelT

  h = FindIndividualResource(hrf, lpszName, MAKEINTRESOURCE(type));

  if (h != NULL)
      h = LoadResource(hrf, h);

  return(h);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  fCheckMono() -                                                          */
/*      Checks a DIB for being truely monochrome.  Only called if           */
/*      BitCount == 1.  This function checks the color table (address       */
/*      passed) for true black and white RGB's                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL fCheckMono(LPVOID  lpColorTable,
                BOOL    fNewDIB)

{
  LPLONG   lpRGB;
  LPWORD   lpRGBw;

    dprintf(7,"fCheckMono");
  lpRGB = lpColorTable;
  if (fNewDIB)
    {
      if ((*lpRGB == 0 && *(lpRGB + 1) == 0x00FFFFFF) ||
      (*lpRGB == 0x00FFFFFF && *(lpRGB + 1) == 0))
      return(TRUE);
    }
  else
    {
      lpRGBw = lpColorTable;
      if (*(LPSTR)lpRGBw == 0)
        {
      if (*lpRGBw == 0 && *(lpRGBw+1) == 0xFF00 && *(lpRGBw+2) == 0xFFFF)
              return(TRUE);
        }
      else if (*lpRGBw == 0xFFFF && *(lpRGBw+1) == 0x00FF && *(lpRGBw+2) == 0)
      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadNewBitmap() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Loads a 3.x format bitmap into the DIB structure. */

HBITMAP NEAR PASCAL LoadNewBitmap(HANDLE  hRes,
                  LPSTR   lpName)

{
  register HBITMAP hbmS;
  register HBITMAP hBitmap;

    dprintf(7,"LoadNewBitmap");

  if ((hbmS = hBitmap = UT_LoadCursorIconBitmap(hRes,lpName,(WORD)RT_BITMAP)))
    {
      /* Convert the DIB bitmap into a bitmap in the internal format */
      hbmS = ConvertBitmap(hBitmap);

      /* Converted bitmap is in hbmS; So, release the DIB */
      FreeResource(hBitmap);
    }
  return(hbmS);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  ConvertBitmap()                             */
/*                                      */
/*    This takes in a handle to data in PM 1.1 or 1.2 DIB format or     */
/*    Windows 3.0 DIB format and creates a bitmap in the internal       */
/*    bitmap format and returns the handle to it.               */
/*                                      */
/*    NOTE:                                 */
/*   This function is exported because it is called from CLIPBRD.EXE    */
/*                                      */
/*--------------------------------------------------------------------------*/

HBITMAP FAR PASCAL ConvertBitmap(HBITMAP hBitmap)

{
  int           Width;
  register int      Height;
  HDC           hDC;
  BOOL          fMono = FALSE;
  LPSTR         lpBits;
  register HBITMAP  hbmS;
  LPBITMAPINFOHEADER    lpBitmap1;
  LPBITMAPCOREHEADER    lpBitmap2;

    dprintf(7,"ConvertBitmap");
  lpBitmap1 = (LPBITMAPINFOHEADER)LockResource(hBitmap);

  if (!lpBitmap1)
      return(NULL);

  if ((WORD)lpBitmap1->biSize == sizeof(BITMAPCOREHEADER))
    {
      /* This is an "old form" DIB.  This matches the PM 1.1 format. */
      lpBitmap2 = (LPBITMAPCOREHEADER)lpBitmap1;
      Width = lpBitmap2->bcWidth;
      Height = lpBitmap2->bcHeight;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpBits = (LPSTR)(lpBitmap2 + 1);

      /* Skip the color table entries, if any */
      if (lpBitmap2->bcBitCount != 24)
    {
      if (lpBitmap2->bcBitCount == 1)
          fMono = fCheckMono(lpBits, FALSE);
      lpBits += (1 << (lpBitmap2->bcBitCount)) * sizeof(RGBTRIPLE);
    }
    }
  else
    {
      Width = (WORD)lpBitmap1->biWidth;
      Height = (WORD)lpBitmap1->biHeight;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpBits = (LPSTR)(lpBitmap1 + 1);

      /* Skip the color table entries, if any */
      if (lpBitmap1->biClrUsed != 0)
    {
      if (lpBitmap1->biClrUsed == 2)
          fMono = fCheckMono(lpBits, TRUE);
      lpBits += lpBitmap1->biClrUsed * sizeof(RGBQUAD);
    }
      else
    {
      if (lpBitmap1->biBitCount != 24)
        {
          if (lpBitmap1->biBitCount == 1)
          fMono = fCheckMono(lpBits, TRUE);
          lpBits += (1 << (lpBitmap1->biBitCount)) * sizeof(RGBQUAD);
        }
    }
    }

  /* Create a bitmap */
  if (fMono)
      hbmS = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL);
  else
    {
      /* Create a color bitmap compatible with the display device */
      hDC = GetScreenDC();
      hbmS = CreateCompatibleBitmap(hDC, Width, Height);
      InternalReleaseDC(hDC);
    }

  /* Initialize the new bitmap by converting from PM format */
  if (hbmS != NULL)
      SetDIBits(hdcBits, hbmS, 0, Height, lpBits,
                (LPBITMAPINFO)lpBitmap1, DIB_RGB_COLORS);

  GlobalUnlock(hBitmap);

  return(hbmS);
}


HANDLE NEAR PASCAL Helper_LoadCursorOrIcon(HANDLE  hRes,
                       LPSTR   lpName,
                       WORD    type)
{
  HANDLE h;

    dprintf(7,"Helper_LoadCursorOrIcon");

  /* If we can't find the cursor/icon in the app, and this is a 2.x app, we
   * need to search into the display driver to find it.
   */
  h = UT_LoadCursorIconBitmap(hRes, lpName, type);
  return(h);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursor() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

HCURSOR API LoadCursor(hRes, lpName)

HANDLE  hRes;
LPSTR   lpName;

{
    HCURSOR hcur;

    dprintf(5,"LoadCursor");

    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Cursor");
        hcur = WOWLoadCursor32(hRes, lpName);
    } else {
        hcur = ((HCURSOR)Helper_LoadCursorOrIcon(hRes, lpName, (WORD)RT_CURSOR));
    }
#ifdef DEBUG
    if (hcur == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HCURSOR)1;
    }
#endif

    dprintf(5,"LoadCursor returning %4.4XH", hcur);

    return hcur;
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadIcon() -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

HICON API LoadIcon(hRes, lpName)

HANDLE hRes;
LPSTR  lpName;

{
    HICON hicon;

    dprintf(5,"LoadIcon");

    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Icon");
        hicon = WOWLoadIcon32(hRes, lpName);
    } else {
        hicon = ((HICON)Helper_LoadCursorOrIcon(hRes, lpName, (WORD)RT_ICON));
    }
#ifdef DEBUG
    if (hicon == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HICON)1;
    }
#endif
    dprintf(5,"LoadIcon returning %4.4XH", hicon);

    return hicon;
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  StretchBitmap() -                               */
/*                                      */
/*  This routine stretches a bitmap into another bitmap,            */
/*   and returns the stretched bitmap.                          */
/*--------------------------------------------------------------------------*/

HBITMAP FAR  PASCAL StretchBitmap(iOWidth, iOHeight, iNWidth, iNHeight, hbmS,
               byPlanes, byBitsPixel)

int     iOWidth;
int iOHeight;
int iNWidth;
int iNHeight;
HBITMAP hbmS;
BYTE    byPlanes;
BYTE    byBitsPixel;

{
    register HBITMAP  hbmD;
    HBITMAP  hbmDSave;
    register HDC         hdcSrc;




    dprintf(7,"StretchBitmap");
      if ((hdcSrc = CreateCompatibleDC(hdcBits)) != NULL)
    {
      if ((hbmD = (HBITMAP)CreateBitmap(iNWidth, iNHeight, byPlanes, byBitsPixel, (LPINT)NULL)) == NULL)
          goto GiveUp;

      if ((hbmDSave = SelectObject(hdcBits, hbmD)) == NULL)
          goto GiveUp;

      if (SelectObject(hdcSrc, hbmS) != NULL)
        {
          /* NOTE: We don't have to save the bitmap returned from
           * SelectObject(hdcSrc) and select it back in to hdcSrc,
           * because we delete hdcSrc.
           */
          SetStretchBltMode(hdcBits, COLORONCOLOR);

          StretchBlt(hdcBits, 0, 0, iNWidth, iNHeight, hdcSrc, 0, 0, iOWidth, iOHeight, SRCCOPY);

          SelectObject(hdcBits, hbmDSave);

          DeleteDC(hdcSrc);

          return(hbmD);
        }
      else
        {
GiveUp:
          if (hbmD != NULL)
          DeleteObject(hbmD);
          DeleteDC(hdcSrc);
          goto Step1;
        }

    }
      else
    {
Step1:
      return(NULL);
    }
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadOldBitmap() -                               */
/*                                      */
/*   This loads bitmaps in old formats( Version 2.10 and below)         */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL LoadOldBitmap(HANDLE  hRes,
                 LPSTR   lpName)

{
  int          oWidth;
  int          oHeight;
  BYTE         planes;
  BYTE         bitsPixel;
  WORD         wCount;
  DWORD        dwCount;
  LPBITMAP     lpBitmap;
  register HBITMAP hbmS;
  HBITMAP      hbmD;
  register  HBITMAP   hBitmap;
  BOOL         fCrunch;
  WORD         wDevDep;

    dprintf(7,"LoadOldBitmap");

  if (hbmS = hBitmap = UT_LoadCursorIconBitmap(hRes, lpName, BMR_BITMAP))
    {
      lpBitmap = (LPBITMAP)LockResource(hBitmap);

      fCrunch = ((*(((BYTE FAR *)lpBitmap) + 1) & 0x0F) != BMR_DEVDEP);
      lpBitmap = (LPBITMAP)((BYTE FAR *)lpBitmap + 2);

      oWidth = lpBitmap->bmWidth;
      oHeight = lpBitmap->bmHeight;
      planes = lpBitmap->bmPlanes;
      bitsPixel = lpBitmap->bmBitsPixel;

      if (!(*(((BYTE FAR *)lpBitmap) + 1) & 0x80))
    {
      hbmS = CreateBitmap(oWidth, oHeight, planes, bitsPixel,
          (LPSTR)(lpBitmap + 1));
    }
      else
    {
      hbmS = (HBITMAP)CreateDiscardableBitmap(hdcBits, oWidth, oHeight);
      wCount = (((oWidth * bitsPixel + 0x0F) & ~0x0F) >> 3);
      dwCount = wCount * oHeight * planes;
      SetBitmapBits(hbmS, dwCount, (LPSTR)(lpBitmap + 1));
    }

      GlobalUnlock(hBitmap);
      FreeResource(hBitmap);

      if (hbmS != NULL)
    {
      if (fCrunch && ((64/oemInfo.cxIcon + 64/oemInfo.cyIcon) > 2))
        {
          /* Stretch the Bitmap to suit the device */
              hbmD = StretchBitmap(oWidth, oHeight,
               (oWidth * oemInfo.cxIcon/64),
               (oHeight * oemInfo.cyIcon/64),
               hbmS, planes, bitsPixel);

          /* Delete the old bitmap */
          DeleteObject(hbmS);

          if (hbmD == NULL)
        return(NULL);    /* Some problem in stretching */
          else
            return(hbmD);    /* Return the stretched bitmap */
        }
    }
    }
  else
    {
       return (HANDLE)0;
    }
  return(hbmS);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadBitmap() -                              */
/*                                      */
/*  This routine decides whether the bitmap to be loaded is in old or       */
/*  new (DIB) format and calls appropriate handlers.                */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE API LoadBitmap(hRes, lpName)

HANDLE hRes;
LPSTR  lpName;

{
    HANDLE hbmp;

    dprintf(5,"LoadBitmap");
    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Bitmap");
        hbmp = WOWLoadBitmap32(hRes, lpName);
    } else {

        /* Check if the resource is to be taken from the display driver.  If so,
         * check the driver version; If the resource is to be taken from the
         * application, check the app version
         */
        if (((hRes == NULL) && (oemInfo.DispDrvExpWinVer >= VER)) ||
        ((hRes != NULL) && (LOWORD(GetExpWinVer(hRes)) >= VER))) {
            hbmp = (LoadNewBitmap(hRes, lpName));
        } else {
            hbmp = (LoadOldBitmap(hRes, lpName));
        }
    }
#ifdef DEBUG
    if (hbmp == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HANDLE)1;
    }
#endif
    dprintf(5,"LoadBitmap returning %4.4XH", hbmp);

    return hbmp;
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CrunchAndResize()  -                            */
/*  This Crunches the monochrome icons and cursors if required and      */
/*      returns the newsize of the resource after crunching.            */
/*      This routine is also called to resize the monochrome AND mask of a  */
/*  color icon.                             */
/*  Parameters:                                 */
/*  lpIcon: Ptr to the resource                     */
/*  fIcon : TRUE, if the resource is an icon. FALSE, if it is a cursor. */
/*  fCrunch : TRUE if resource is to be resized.                    */
/*  fSinglePlane: TRUE if only AND mask of a color icon is passed       */
/*                    through lpIcon                            */
/*  fUseSysMetrics: Whether to use the icon/cursor values found in      */
/*              oemInfo or not.                         */
/*  Returns:                                    */
/*  The new size of the resource is returned.               */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL CrunchAndResize(lpIcon, fIcon, fCrunch, fSinglePlane, fUseSysMetrics)

LPCURSORSHAPE   lpIcon;
BOOL        fIcon;
BOOL        fCrunch;
BOOL        fSinglePlane;
BOOL        fUseSysMetrics;


{
  WORD      size;
  register int  cx;
  register int  cy;
  int       oHeight;
  int       nHeight;
  int       iNewcbWidth;
  BOOL      bStretch;
  HBITMAP   hbmS;
  HBITMAP   hbmD;

    dprintf(7,"CrunhAndResize");
  if(fUseSysMetrics)
    {
      if(fIcon)
        {
      cx = oemInfo.cxIcon;
      cy = oemInfo.cyIcon;
    }
      else
        {
      cx = oemInfo.cxCursor;
      cy = oemInfo.cyCursor;
    }
    }
  else
    {
      cx = lpIcon->cx;
      cy = lpIcon->cy;
    }

  if (fIcon)
    {
      lpIcon->xHotSpot = cx >> 1;
      lpIcon->yHotSpot = cy >> 1;
      if (fSinglePlane)
    {
      /* Only the AND mask exists */
      oHeight = lpIcon->cy;
      nHeight = cy;
    }
      else
    {
      /* Both AND ans XOR masks exist; So, height must be twice */
      oHeight = lpIcon->cy << 1;
      nHeight = cy << 1;
    }
    }
  else
    {
      oHeight = lpIcon->cy << 1;
      nHeight = cy << 1;
    }

  iNewcbWidth = ((cx + 0x0F) & ~0x0F) >> 3;
  size = iNewcbWidth * nHeight;

  if (fCrunch && ((lpIcon->cx != cx) || (lpIcon->cy != cy)))
    {
      if (!fIcon)
    {
      lpIcon->xHotSpot = (lpIcon->xHotSpot * cx)/(lpIcon->cx);
      lpIcon->yHotSpot = (lpIcon->yHotSpot * cy)/(lpIcon->cy);
    }

      /* To begin with, assume that no stretching is required */
      bStretch = FALSE;

      /* Check if the width is to be reduced */
      if (lpIcon->cx != cx)
    {
        /* Stretching the Width is necessary */
        bStretch = TRUE;
    }

      /* Check if the Height is to be reduced */
      if (lpIcon->cy != cy)
    {
          /* Stretching in Y direction is necessary */
          bStretch = TRUE;
    }

      /* Check if stretching is necessary */
      if (bStretch)
    {
      /* Create a monochrome bitmap with the icon/cursor bits */
      if ((hbmS = CreateBitmap(lpIcon->cx, oHeight, 1, 1, (LPSTR)(lpIcon + 1))) == NULL)
          return(NULL);

      if ((hbmD = StretchBitmap(lpIcon->cx, oHeight, cx, nHeight, hbmS, 1, 1)) == NULL)
        {
          DeleteObject(hbmS);
          return(NULL);
        }

      DeleteObject(hbmS);

      lpIcon->cx = cx;
      lpIcon->cy = cy;
      lpIcon->cbWidth = iNewcbWidth;

      GetBitmapBits(hbmD, (DWORD)size, (LPSTR)(lpIcon + 1));
      DeleteObject(hbmD);
    }
    }

  return(size + sizeof(CURSORSHAPE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursorIconHandler() -                           */
/*                                      */
/*  This handles 2.x (and less) Cursors and Icons               */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadCursorIconHandler(hRes, hResFile, hResIndex)

register HANDLE hRes;
HANDLE      hResFile;
HANDLE      hResIndex;

{
  register int    fh        = 0;
  BOOL        bNew      = FALSE;
  WORD        wMemSize;
  LPCURSORSHAPE   lpIcon;
  HANDLE      hTempRes;

    dprintf(7,"LoadCursorIconHandler");
  wMemSize = SizeofResource(hResFile, hResIndex);

#if 1 // was 0 - NigelT
  if (!hRes)
    {
      if (!(hRes = AllocResource(hResFile, hResIndex, 0L)))
      return(NULL);
      fh = -1;
      bNew = TRUE;
    }

  while (!(lpIcon = (LPCURSORSHAPE)GlobalLock(hRes)))
    {
      if (!GlobalReAlloc(hRes, (DWORD)wMemSize, 0))
      goto LoadCIFail;
      else
      fh = -1;
    }

  if (fh)
    {
      fh = AccessResource(hResFile, hResIndex);
      if (fh != -1 && _lread(fh, (LPSTR)lpIcon, wMemSize) != 0xFFFF)
      _lclose(fh);
      else
    {
      if (fh != -1)
          _lclose(fh);
      GlobalUnlock(hRes);
      goto LoadCIFail;
    }

    }
#else
  /* Call kernel's resource handler instead of doing the stuff ourselves
   * because we use cached file handles that way. davidds
   */
  // For resources which are not preloaded, hRes will be NULL at this point.
  // For such cases, the default resource handler does the memory allocation
  // and returns a valid handle.
  // Fix for Bug #4257 -- 01/21/91 -- SANKAR
  if (!(hTempRes = lpDefaultResourceHandler(hRes, hResFile, hResIndex)))
      goto LoadCIFail;
  // We must use the handle returned by lpDefaultResourceHandler.
  hRes = hTempRes;

  lpIcon = (LPCURSORSHAPE)GlobalLock(hRes);
#endif

  if (LoadCursorIconHandler2(hRes, lpIcon, wMemSize))
      return(hRes);

LoadCIFail:
  /* If the loading of the resource fails, we MUST discard the memory we
   * reallocated above, or kernel will simply globallock the thing on the
   * next call to LockResource(), leaving invalid data in the object.
   */
  if (bNew)
      GlobalFree(hRes);
  else
      GlobalDiscard(hRes);

  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursorIconHandler2() -                          */
/*                                      */
/*  This handles all 2.x Cursors and Icons                  */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadCursorIconHandler2(hRes, lpIcon, wMemSize)

register HANDLE hRes;
LPCURSORSHAPE   lpIcon;
register WORD   wMemSize;

{
  BOOL      fCrunch;
  BOOL      fIcon;
  WORD      wNewSize;
  BOOL      fStretchInXdirection;
  BOOL      fStretchInYdirection;

    dprintf(7,"LoadCursorIconHandler2");
  fIcon = (*(LPSTR)lpIcon == BMR_ICON);

  /* Is this a device dependant icon/cursor?. */
  fCrunch = (*((LPSTR)lpIcon+1) != BMR_DEVDEP);

  LCopyStruct((LPSTR)lpIcon+2, (LPSTR)lpIcon, wMemSize-2);

  fCrunch = fCrunch || (lpIcon->cx != GetSystemMetrics(SM_CXICON)) ||
                   (lpIcon->cy != GetSystemMetrics(SM_CYICON));

  /* Only support monochrome cursors. */
  lpIcon->Planes = lpIcon->BitsPixel = 1;

  fStretchInXdirection = fStretchInYdirection = TRUE;  // Assume we need stretching.

  if(fIcon)
    {
      if((oemInfo.cxIcon > STD_ICONWIDTH) && (lpIcon->cx <= oemInfo.cxIcon))
      fStretchInXdirection = FALSE; // No Need to stretch in X direction;
      if((oemInfo.cyIcon > STD_ICONHEIGHT) && (lpIcon->cy <= oemInfo.cyIcon))
          fStretchInYdirection = FALSE; // No need to stretch in Y direction;
    }
  else
    {
      if((oemInfo.cxCursor > STD_CURSORWIDTH) && (lpIcon->cx <= oemInfo.cxCursor))
      fStretchInXdirection = FALSE; // No need to stretch in X direction.
      if((oemInfo.cyCursor > STD_CURSORHEIGHT) && (lpIcon->cy <= oemInfo.cyCursor))
      fStretchInYdirection = FALSE; // No need to stretch in Y direction.
    }

  // Check if the Icon/Cursor needs to be stretched now or not
  if(!(fStretchInXdirection || fStretchInYdirection))
    {
      GlobalUnlock(hRes);
      return(hRes);
    }
  wNewSize = SizeReqd(fIcon, 1, 1, TRUE, 0, 0);

  /* Before we crunch, let us make sure we have a big enough resource. */
  if (fCrunch)
    {
      if (wNewSize > wMemSize)
        {
      GlobalUnlock(hRes);

          /* Make this non discardable so that kernel will try to move this
       * block when reallocing.  DavidDS
       */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_NODISCARD);

      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
            {
              /* So it gets discarded. Note that since the above realloc is
           * less than 64K, the handle won't change.
           */
              GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
          return(NULL);
            }

          /* So it gets discarded */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);

      if (!(lpIcon = (LPCURSORSHAPE)GlobalLock(hRes)))
          return(NULL);
      wMemSize = wNewSize;
        }
    }

  wNewSize = CrunchAndResize(lpIcon, fIcon, fCrunch, FALSE, TRUE);

  GlobalUnlock(hRes);

  /* Has it already been resized? */
  if (wNewSize < wMemSize)
    {
      /* Make it an exact fit. */
      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
          return(NULL);
    }

  return(hRes);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorHandler() -                            */
/*                                      */
/*  This is called when a Cursor in DIB format is loaded            */
/*      This converts the cursor into Old format and returns the handle     */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBCursorHandler(hRes, hResFile, hResIndex)

HANDLE  hRes;
HANDLE  hResFile;
HANDLE  hResIndex;

{
    dprintf(7,"LoadDIBCursorIconHandler");
  return(LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, FALSE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBIconHandler() -                          */
/*                                      */
/*  This is called when an Icon in DIB format is loaded         */
/*      This converts the cursor into Old format and returns the handle     */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBIconHandler(hRes, hResFile, hResIndex)

HANDLE  hRes;
HANDLE  hResFile;
HANDLE  hResIndex;

{
    dprintf(7,"LoadDIBIconHandler");
  return(LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, TRUE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  StretchIcon() -                                 */
/*  When this routine is called, lpIcon already has the monochrome      */
/*  AND bitmap properly sized. This routine adds the color XOR bitmap at    */
/*  end of lpIcon and updates the header with the values of the color       */
/*  info(bitcount and Planes);                          */
/*  wOldSize : Contains the size of AND mask + CURSORSHAPE          */
/*                                      */
/*   Returns:  The new size ( Size of AND mask + XOR bitmap + CURSORSHAPE)  */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL StretchIcon(lpIcon, wOldSize, hXORbitmap, fStretchToSysMetrics)

LPCURSORSHAPE       lpIcon;
WORD            wOldSize;
register HBITMAP    hXORbitmap;
BOOL            fStretchToSysMetrics;

{
  WORD          wCount;
  BITMAP        bitmap;
  register HBITMAP  hNewBitmap;

    dprintf(7,"StretchIcon");
  GetObject(hXORbitmap, sizeof(BITMAP), (LPSTR)&bitmap);

  if(fStretchToSysMetrics)
    {
      /* Do we need to resize things? */
      if ((oemInfo.cxIcon != bitmap.bmWidth) || (oemInfo.cyIcon != bitmap.bmHeight))
    {
          hNewBitmap = StretchBitmap(bitmap.bmWidth, bitmap.bmHeight,
                 oemInfo.cxIcon, oemInfo.cyIcon, hXORbitmap,
                 bitmap.bmPlanes, bitmap.bmBitsPixel);
          DeleteObject(hXORbitmap);

          if (hNewBitmap == NULL)
          return(0);

          GetObject(hNewBitmap, sizeof(BITMAP), (LPSTR)&bitmap);
          hXORbitmap = hNewBitmap;
        }
    }

  /* Update the Planes and BitsPixels field with the color values */
  lpIcon->Planes = bitmap.bmPlanes;
  lpIcon->BitsPixel = bitmap.bmBitsPixel;

  wCount = bitmap.bmWidthBytes * bitmap.bmHeight * bitmap.bmPlanes;
  GetBitmapBits(hXORbitmap, (DWORD)wCount, (LPSTR)((LPSTR)lpIcon + wOldSize));
  DeleteObject(hXORbitmap);

  return(wCount + wOldSize);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorIconHandler() -                        */
/*                                      */
/*  This is called when a Cursor/Icon in DIB format is loaded       */
/*      This converts the cursor/icon internal format and returns the       */
/*      handle                                  */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, fIcon)

register HANDLE hRes;
HANDLE      hResFile;
HANDLE      hResIndex;
BOOL        fIcon;

{
  register int  fh  = 0;
  BOOL      bNew    = FALSE;
  WORD      wMemBlkSize;
  LPCURSORSHAPE lpCurSh;
  HANDLE    hTempRes;

    dprintf(7,"LoadDIBCursorIconHandler");
  wMemBlkSize = (WORD)SizeofResource(hResFile, hResIndex);

#if 1 // was 0 - NigelT
  if (!hRes)
    {
      if (!(hRes = AllocResource(hResFile, hResIndex, 0L)))
      goto LoadDIBFail;
      fh = -1;
      bNew = TRUE;
    }

  while (!(lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes)))
    {
      if (!GlobalReAlloc(hRes, (DWORD)wMemBlkSize, 0))
      goto LoadDIBFail;
      else
      fh = -1;
    }

  if (fh)
    {
      fh = AccessResource(hResFile, hResIndex);
      if (fh != -1 && _lread(fh, (LPSTR)lpCurSh, wMemBlkSize) != 0xFFFF)
      _lclose(fh);
      else
    {
      if (fh != -1)
          _lclose(fh);
      GlobalUnlock(hRes);
      goto LoadDIBFail;
    }
    }
#else
  /* Call kernel's resource handler instead of doing the stuff ourselves
   * because we use cached file handles that way. davidds
   */
  // For resources which are not preloaded, hRes will be NULL at this point.
  // For such cases, the default resource handler does the memory allocation
  // and returns a valid handle.
  // Fix for Bug #4257 -- 01/21/91 -- SANKAR
  if (!(hTempRes = lpDefaultResourceHandler(hRes, hResFile, hResIndex)))
      goto LoadDIBFail;
  // We must use the handle returned by lpDefaultResourceHandler.
  hRes = hTempRes;

  lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes);
#endif

  if (LoadDIBCursorIconHandler2(hRes, lpCurSh, wMemBlkSize, fIcon))
      return(hRes);

LoadDIBFail:
  /* if the loading of the resource fails, we MUST discard the memory we
   * reallocated above, or kernel will simply globallock the thing on the
   * next call to LockResource(), leaving invalid data in the object.
   */
  if (bNew)
      FreeResource(hRes);
  else
      GlobalDiscard(hRes);

  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorIconHandler2() -                       */
/*                                      */
/*  This is called when a Cursor/Icon in DIB format is loaded       */
/*      This converts the cursor/icon into Old format and returns the       */
/*      handle                                  */
/*                                      */
/*  NOTE:  All cursors(always monochrome) and Monochrome Icons are treated  */
/*     alike by this routine. Color Icons are treated as special case   */
/*     determined by the local flag "fMono".                */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBCursorIconHandler2(hRes, lpCurSh, wMemBlkSize, fIcon)

register HANDLE hRes;
WORD        wMemBlkSize;
LPCURSORSHAPE   lpCurSh;
register BOOL   fIcon;

{
  HDC           hDC;
  BOOL          fMono       = FALSE;
  WORD          Width;
  WORD          Height;
  WORD          wCount;
  WORD          BitCount;
  WORD          Planes;
  LPSTR         lpBits;
  BITMAP        bitmap;
  HBITMAP       hBitmap;
  WORD          wNewSize;
  HBITMAP       hANDbitmap;
  HBITMAP       hXORbitmap;
  LPWORD        lpColorTable;
  LPBITMAPINFOHEADER    lpHeader;
  LPBITMAPCOREHEADER    lpHeader1   = 0;
  BOOL          fStretchToSysMetrics;
  BOOL          fStretchInXdirection;
  BOOL          fStretchInYdirection;


    dprintf(7,"LoadDIBCursorIconHandler2");
  lpHeader = (LPBITMAPINFOHEADER)lpCurSh;

  if (!fIcon)
    {
      /* Skip over the cursor hotspot data in the first 2 words. */
      lpHeader = (LPBITMAPINFOHEADER)((LPSTR)lpHeader + 4);
    }

  if ((WORD)lpHeader->biSize == sizeof(BITMAPCOREHEADER))
    {
      /* This is an "old form" DIB.  This matches the PM 1.1 format. */
      lpHeader1 = (LPBITMAPCOREHEADER)lpHeader;

      Width = lpHeader1->bcWidth;
      Height = lpHeader1->bcHeight;
      BitCount = lpHeader1->bcBitCount;
      Planes = lpHeader1->bcPlanes;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpColorTable = (LPWORD)(lpBits = (LPSTR)(lpHeader1 + 1));

      /* Skip the color table entries, if any */
      if (lpHeader1->bcBitCount != 24)
    {
      if (lpHeader1->bcBitCount == 1)
          fMono = fCheckMono(lpBits, FALSE);
      lpBits += (1 << (lpHeader1->bcBitCount)) * sizeof(RGBTRIPLE);
    }
    }
  else
    {
      Width = (WORD)lpHeader->biWidth;
      Height = (WORD)lpHeader->biHeight;
      BitCount = lpHeader->biBitCount;
      Planes = lpHeader->biPlanes;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpColorTable = (LPWORD)(lpBits = (LPSTR)(lpHeader + 1));

      /* Skip the color table entries, if any */
      if (lpHeader->biClrUsed != 0)
    {
      if (lpHeader->biClrUsed == 2)
          fMono = fCheckMono(lpBits, TRUE);
      lpBits += lpHeader->biClrUsed * sizeof(RGBQUAD);
    }
      else
    {
      if (lpHeader->biBitCount != 24)
        {
          if (lpHeader->biBitCount == 1)
          fMono = fCheckMono(lpBits, TRUE);
          lpBits += (1 << (lpHeader->biBitCount)) * sizeof(RGBQUAD);
        }
    }
    }

  // By default Stretch the icon/cursor to the dimensions in oemInfo;
  // If this is FALSE, then the stretching will take place during DrawIcon();
  fStretchInXdirection = TRUE;
  fStretchInYdirection = TRUE;

  // Check if the Icon/Cursor needs to be stretched to the dimensions in
  // oemInfo now or not.
  if(fIcon)
    {
      if((oemInfo.cxIcon > STD_ICONWIDTH) && (Width <= oemInfo.cxIcon))
      fStretchInXdirection = FALSE; // No Need to stretch in X direction;
      if((oemInfo.cyIcon > STD_ICONHEIGHT) && (Height <= oemInfo.cyIcon))
          fStretchInYdirection = FALSE; // No need to stretch in Y direction;
    }
  else
    {
      if((oemInfo.cxCursor > STD_CURSORWIDTH) && (Width <= oemInfo.cxCursor))
      fStretchInXdirection = FALSE; // No need to stretch in X direction.
      if((oemInfo.cyCursor > STD_CURSORHEIGHT) && (Height <= oemInfo.cyCursor))
      fStretchInYdirection = FALSE; // No need to stretch in Y direction.
    }

  fStretchToSysMetrics = fStretchInXdirection || fStretchInYdirection;

  if (fMono)
    {
      /* Create a bitmap */
      if (!(hBitmap = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }

      /* Convert the DIBitmap format into internal format */
      SetDIBits(hdcBits, hBitmap, 0, Height, lpBits, (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);
      // Cursors/Icons in DIB format have a height twice the actual height.
      wNewSize = SizeReqd(fIcon, BitCount, Planes, fStretchToSysMetrics, Width, Height>>1);
    }
  else
    {
      /* The height is twice that of icons */
      Height >>= 1;
      if (lpHeader1)
      lpHeader1->bcHeight = Height;
      else
      lpHeader->biHeight = Height;

      /* Create the XOR bitmap Compatible with the current device */
      hDC = GetScreenDC();
      if (!(hXORbitmap = CreateCompatibleBitmap(hDC, Width, Height)))
    {
          InternalReleaseDC(hDC);
      GlobalUnlock(hRes);
      return(NULL);
    }
      InternalReleaseDC(hDC);

      /* Convert the DIBitmap into internal format */
      SetDIBits(hdcBits, hXORbitmap, 0, Height, lpBits,
                (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);

      GetObject(hXORbitmap, sizeof(BITMAP), (LPSTR)(&bitmap));
      wNewSize = SizeReqd(fIcon, bitmap.bmBitsPixel, bitmap.bmPlanes,
                  fStretchToSysMetrics, Width, Height);

      /* Create the monochrome AND bitmap */
      if (!(hANDbitmap = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }

      /* Get the offset to the AND bitmap */
      lpBits += (((Width * BitCount + 0x1F) & ~0x1F) >> 3) * Height;

      /* Set the header with data for a monochrome bitmap */
      Planes = BitCount = 1;

      /* Set the color table for a monochrome bitmap */
      *lpColorTable++ = 0;
      *lpColorTable++ = 0xFF00;
      *lpColorTable   = 0xFFFF;

      if (lpHeader1)
    {
      lpHeader1->bcWidth = Width;
      lpHeader1->bcHeight = Height;
      lpHeader1->bcPlanes = Planes;
      lpHeader1->bcBitCount = BitCount;
    }
      else
    {
      lpHeader->biWidth = Width;
      lpHeader->biHeight = Height;
      lpHeader->biPlanes = Planes;
      lpHeader->biBitCount = BitCount;
    }

      SetDIBits(hdcBits, hANDbitmap, 0, Height, lpBits,
                (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);
      hBitmap = hANDbitmap;
    }

  GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bitmap);

  if (fIcon)
    {
      lpCurSh->xHotSpot = 0;
      lpCurSh->yHotSpot = 0;
    }

  /* The following lines are replaced by a single functon call
   *
   * lpCurSh->cx = bitmap.bmwidth;
   * lpCurSh->cy = bitmap.bmHeight;
   * lpCurSh->cbWidth = bitmap.bmWidthBytes;
   * lpCurSh->Planes = bitmap.bmPlanes;
   * lpCurSh->BitsPixel = bitmap.bmBitsPixel;
   */

  LCopyStruct((LPSTR)&(bitmap.bmWidth),
              (LPSTR)&(lpCurSh->cx), (sizeof(WORD)) << 2);

  /* Cursors in PM format have twice the actual height. */
  if (fMono)
      lpCurSh->cy = lpCurSh->cy >> 1;

  wCount = bitmap.bmWidthBytes * bitmap.bmHeight * bitmap.bmPlanes;

  lpBits = (LPSTR)(lpCurSh + 1);

  /* Copy the bits in Bitmap into the resource */
  GetBitmapBits(hBitmap, (DWORD)wCount, lpBits);

  /* Delete the bitmap */
  DeleteObject(hBitmap);


  /* Before crunching, let us make sure we have a big enough resource */
  if (wNewSize > wMemBlkSize)
    {
      GlobalUnlock(hRes);

      /* Make this non discardable so that kernel will try to move this block
       * when reallocing.  DavidDS
       */
      GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_NODISCARD);

      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
        {
          /* So it gets discarded. Note that since the above realloc is less
       * than 64K, the handle won't change.
       */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
      return(NULL);
        }

      GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
      if (!(lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes)))
      return(NULL);

      wMemBlkSize = wNewSize;
    }

  wNewSize = CrunchAndResize(lpCurSh, fIcon, TRUE, !fMono, fStretchToSysMetrics);

  if (!fMono)
    {
      if (!(wNewSize = StretchIcon(lpCurSh, wNewSize, hXORbitmap, fStretchToSysMetrics)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }
    }

  GlobalUnlock(hRes);

  /* Does it need to be resized? */
  if (wNewSize < wMemBlkSize)
    {
      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
      return(NULL);
    }

  return(hRes);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SizeReqd() -                                */
/*  This returns the size of an Icon or Cursor after it is stretched    */
/*  or crunched                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL SizeReqd(fIcon, BitCount, Planes, fUseSysMetrics, iWidth, iHeight)

BOOL    fIcon;
WORD    BitCount;
WORD    Planes;
BOOL    fUseSysMetrics;
int iWidth;
int iHeight;

{
  WORD  size;

    dprintf(7,"SizeReqd");
  if(fUseSysMetrics)  //Use the dimensions in oemInfo; Else, use given dimensions
    {
      if(fIcon)
        {
          iWidth = oemInfo.cxIcon;
          iHeight = oemInfo.cyIcon;
    }
      else
        {
          iWidth = oemInfo.cxCursor;
          iHeight = oemInfo.cyCursor;
    }
    }

  size = (((iWidth*BitCount+0x0F) & ~0x0F) >> 3) *
             iHeight * Planes;

  if ((BitCount == 1) && (Planes == 1))
      size <<= 1;
  else
      size += (((iWidth+0x0F) & ~0x0F) >> 3)*iHeight;

  return(size + sizeof(CURSORSHAPE));
}

#endif  // NEEDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user3.asm ===
;
;   USER3.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;
;--

    TITLE   USER3.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


cProc TouchNotPresentSel, <PUBLIC, NEAR>
parmD  lpsz  ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin
    mov ax,es
    mov es,word ptr lpsz+2      ; makes NP sel P
    mov es,ax

    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

    UserThunk   MAPDIALOGRECT
    UserThunk   MB_DLGPROC
;;; UserThunk   MDICLIENTWNDPROC        ;LOCALAPI in wsubcls.c
    UserThunk   MENUITEMSTATE
    DUserThunk  MESSAGEBEEP
    UserThunk   MESSAGEBOX
    UserThunk   MODIFYMENU
    UserThunk   MOVEWINDOW
;;;  UserThunk   OFFSETRECT         ; LOCALAPI in winrect.asm
;;; DUserThunk  OLDEXITWINDOWS      ; LOCALAPI in winutil.asm
    UserThunk   OPENCLIPBOARD

FUN_WOWOPENCOMM EQU FUN_OPENCOMM
    DUserThunk   WOWOPENCOMM %(size OPENCOMM16)

    UserThunk   OPENICON
    DUserThunk  PAINTRECT
    UserThunk   PEEKMESSAGE
    UserThunk   POSTAPPMESSAGE
    UserThunk   POSTMESSAGE
    UserThunk   POSTMESSAGE2
    DUserThunk  POSTQUITMESSAGE
;;;    UserThunk   PTINRECT          ; LOCALAPI in winrect.asm

    UserThunk   READCOMM
    UserThunk   REALIZEPALETTE
    UserThunk   REGISTERCLASS
    UserThunk   REGISTERCLIPBOARDFORMAT
    PDUserThunk REGISTERWINDOWMESSAGE, TouchNotPresentSel
    DUserThunk  RELEASECAPTURE,0
    UserThunk   RELEASEDC
    UserThunk   REMOVEMENU
    UserThunk   REMOVEPROP
    DUserThunk  REPAINTSCREEN
    DUserThunk  REPLYMESSAGE
;;; UserThunk   SBWNDPROC           ;LOCALAPI in wsubcls.c
    DUserThunk  SCROLLCHILDREN
    UserThunk   SCROLLDC
    UserThunk   SCROLLWINDOW
        UserThunk   SELECTPALETTE
    UserThunk   SENDDLGITEMMESSAGE
    UserThunk   SENDMESSAGE
    UserThunk   SENDMESSAGE2
    UserThunk   SETACTIVEWINDOW
    UserThunk   SETCAPTURE
    DUserThunk  SETCARETBLINKTIME
    DUserThunk  SETCARETPOS
    UserThunk   SETCLASSLONG
    UserThunk   SETCLASSWORD

FUN_WOWSETCLIPBOARDDATA EQU FUN_SETCLIPBOARDDATA
    DUserThunk  WOWSETCLIPBOARDDATA, %(size SETCLIPBOARDDATA16)

    UserThunk   SETCLIPBOARDVIEWER

sEnd    CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user3a.asm ===
;
;   USER3A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;   Split off user3a.asm from user3.asm 2-May-95 davehart
;
;--

    TITLE   USER3A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

;*--------------------------------------------------------------------------*
;*
;*  CheckMsgForTranslate, CheckAccMsgForTranslate, CheckMDIAccMsgForTranslate
;*
;*  Checks to see if the message number in the message is one of those
;*  that the system actually uses.  If not, then the API just returns with
;*  a 0 in AX.  This saves the 16-32-16 bit transition for most messages.
;*
;*--------------------------------------------------------------------------*

ALIGN 16
cProc CheckMsgForTranslate, <PUBLIC, NEAR>
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
;parmW wBP           ; Thunk saved BP
;parmW wDS           ; Thunk saved DS
cBegin
    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, KEYUP, SYSKEYDOWN, SYSKEYUP
;  in other words, 100, 101, 104, amd 105 hex

     and ax,0fffah   ; wipe out 2 bits that are variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_KEYUP
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSKEYUP
;    jz  @f


    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 4        ; lpMsg -- 4 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

ALIGN 16
cProc CheckAccMsgForTranslate, <PUBLIC, NEAR>
parmW hWnd
parmW hAccTbl
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin

    test hWnd,0ffffh
    jz   SHORT t_not

    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, CHAR, SYSKEYDOWN, SYSCHAR
;  in other words, 100, 102, 104, amd 106 hex

     and ax,0fff9h   ; wipe out 2 bits that are variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_CHAR
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSCHAR
;    jz  @f

t_not:
    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 8        ; 8 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

ALIGN 16
cProc CheckMDIAccMsgForTranslate, <PUBLIC, NEAR>
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin
    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, SYSKEYDOWN
;  in other words, 100, 104

     and ax,0fffbh   ; wipe out 1 bit that is variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_KEYUP
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSKEYUP
;    jz  @f
    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 6        ; 6 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

;
; Our message queues resize automagically, so just say YES
; to whatever they ask for.
;

cProc SetMessageQueue,<PUBLIC,FAR,PASCAL,NODATA,WIN>
        ParmW qSize
cBegin
        mov   ax,1      ; just say we did it
cEnd

ExternFP        <GetCurrentTask>
ExternFP        <HqCurrent>

externA __MOD_DUSER

cProc SysErrorBox,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin <nogen>
        ; we check whether the queue exists for this process

        call GetCurrentTask
        or ax, ax
        jz i_SysErrorBox

        call HqCurrent ; flags are set on exit
        jz i_SysErrorBox

        push size SysErrorBox16

        t_SysErrorBox:
                push word ptr HI_WCALLID
                push __MOD_DUSER + FUN_SYSERRORBOX
                call WOW16Call
        .erre (($ - t_SysErrorBox) EQ (05h + 03h + 03h))

i_SysErrorBox:
       retf 0eh
cEnd <nogen>



    UserThunk   SETCOMMBREAK
    UserThunk   SETCOMMEVENTMASK
    UserThunk   SETCOMMSTATE
    UserThunk   SETCURSOR
    DUserThunk  SETCURSORPOS
    UserThunk   SETDESKPATTERN
    UserThunk   SETDESKWALLPAPER
    UserThunk   SETDLGITEMINT
    UserThunk   SETDLGITEMTEXT
    DUserThunk  SETDOUBLECLICKTIME
    UserThunk   SETEVENTHOOK
    UserThunk   SETFOCUS
    UserThunk   SETGETKBDSTATE
    UserThunk   SETGRIDGRANULARITY
    DUserThunk  SETINTERNALWINDOWPOS
    UserThunk   SETKEYBOARDSTATE
    UserThunk   SETMENU
    UserThunk   SETMENUITEMBITMAPS
    UserThunk   SETPARENT
    UserThunk   SETPROP
;;;    UserThunk   SETRECT         ; LOCALAPI in winrect.asm
;;;    UserThunk   SETRECTEMPTY    ; LOCALAPI in winrect.asm
    UserThunk   SETSCROLLPOS
    UserThunk   SETSCROLLRANGE
    UserThunk   SETSYSCOLORS
;;;    UserThunk   SETSYSMODALWINDOW ; local api in winmisc1.asm
    UserThunk   SETSYSTEMMENU
    DUserThunk  SETSYSTEMTIMER      ;;;;;;;
    UserThunk   SETTIMER
    UserThunk   SETTIMER2
    UserThunk   SETWC2
    UserThunk   SETWINDOWLONG
    UserThunk   SETWINDOWPOS
    DUserThunk  SETWINDOWSHOOKINTERNAL
    UserThunk   SETWINDOWTEXT
    UserThunk   SETWINDOWWORD
    UserThunk   SHOWCARET
    DUserThunk  SHOWCURSOR
    UserThunk   SHOWOWNEDPOPUPS
    UserThunk   SHOWSCROLLBAR
    UserThunk   SHOWWINDOW
    DUserThunk  SIGNALPROC
    UserThunk   SNAPWINDOW
;;; UserThunk   STATICWNDPROC           ;LOCALAPI in wsubcls.c
;;; UserThunk   STRINGFUNC          ;LOCALAPI in winlang.asm
    DUserThunk  SWAPMOUSEBUTTON
    DUserThunk  SWITCHTOTHISWINDOW
    UserThunk   SWITCHWNDPROC
;;;    DUserThunk  SYSERRORBOX  ; LOCALAPI in this file
    UserThunk   TABBEDTEXTOUT
    UserThunk   TABTHETEXTOUTFORWIMPS
    UserThunk   TRACKPOPUPMENU
    PUserThunk   TRANSLATEACCELERATOR,CheckAccMsgForTranslate
    PUserThunk   TRANSLATEMDISYSACCEL,CheckMDIAccMsgForTranslate
    PUserThunk   TRANSLATEMESSAGE,CheckMsgForTranslate
    UserThunk   TRANSMITCOMMCHAR
    UserThunk   UNGETCOMMCHAR
    UserThunk   UNHOOKWINDOWSHOOK
;;;    UserThunk   UNIONRECT        ; LOCALAPI in winrect.asm
    UserThunk   UNREGISTERCLASS
    UserThunk   UPDATEWINDOW
    DUserThunk  USERYIELD

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wclass.asm ===
TITLE   wsubcls.asm

_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS

_DATA   SEGMENT  WORD PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP _DATA

EXTRN	CALLWINDOWPROC:FAR
EXTRN   DEFDLGPROC:FAR

_TEXT   SEGMENT

        ASSUME  CS: _TEXT


PUBLIC  BUTTONWNDPROC
PUBLIC  COMBOBOXCTLWNDPROC
PUBLIC  EDITWNDPROC
PUBLIC  LBOXCTLWNDPROC
PUBLIC  SBWNDPROC
PUBLIC  STATICWNDPROC
PUBLIC  MDICLIENTWNDPROC
PUBLIC  TITLEWNDPROC
PUBLIC  MENUWINDOWPROC
PUBLIC  DEFDLGPROCTHUNK
PUBLIC  DESKTOPWNDPROC

SUBCLASS_MAGIC  equ 0534C4353h          ; "SCLS" Sub-Class magic value */

align 16

        dd  SUBCLASS_MAGIC
        dd  2
        dd  0

BUTTONWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET BUTTONWNDPROC
        mov     dx,SEG BUTTONWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

BUTTONWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  3
        dd  0

COMBOBOXCTLWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET COMBOBOXCTLWNDPROC
        mov     dx,SEG COMBOBOXCTLWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

COMBOBOXCTLWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  4
        dd  0


EDITWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET EDITWNDPROC
        mov     dx,SEG EDITWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

EDITWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  5
        dd  0

LBOXCTLWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET LBOXCTLWNDPROC
        mov     dx,SEG LBOXCTLWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

LBOXCTLWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  7
        dd  0

SBWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET SBWNDPROC
        mov     dx,SEG SBWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

SBWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  8
        dd  0

STATICWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET STATICWNDPROC
        mov     dx,SEG STATICWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

STATICWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  6
        dd  0

MDICLIENTWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET MDICLIENTWNDPROC
        mov     dx,SEG MDICLIENTWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

MDICLIENTWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0bh     ; 11 decimal
        dd  0

TITLEWNDPROC    PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET TITLEWNDPROC
        mov     dx,SEG TITLEWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

TITLEWNDPROC    ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0ch    ; 12 decimal
        dd  0

MENUWINDOWPROC    PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET MENUWINDOWPROC
        mov     dx,SEG MENUWINDOWPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

MENUWINDOWPROC    ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0ah     ; 10 decimal
        dd  0


DEFDLGPROCTHUNK     PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR DEFDLGPROC
        mov     sp,bp
        pop     bp
        dec     bp
        ret     10

DEFDLGPROCTHUNK     ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  9
        dd  0


DESKTOPWNDPROC     PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET DESKTOPWNDPROC
        mov     dx,SEG DESKTOPWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

DESKTOPWNDPROC     ENDP


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\usermenu.inc ===
;****************************************************************************
;*									    *
;*  USERMENU.INC -							    *
;*									    *
;*	Menu Structures and Defines					    *
;*									    *
;****************************************************************************

;
; mnFlags bits
;
FISPOPUP	= 01h

;
; Resource template lastmenu bit
;
FENDMENU	= 080h

;
; itmFlags bits and flags parameter values
;
MF_CHANGE       = 0080h
MF_INSERT       = 0000h
MF_APPEND       = 0100h
MF_DELETE       = 0200h
MF_BYPOSITION   = 0400h
MF_SEPARATOR    = 0800h
MF_REMOVE       = 1000h
MF_BYCOMMAND    = 0000h
MF_GRAYED       = 0001h
MF_DISABLED     = 0002h
MF_ENABLED      = 0000h
MF_BITMAP       = 0004h
MF_OWNERDRAW    = 0100h
MF_STRING       = 0000h
MF_CHECKED      = 0008h
MF_UNCHECKED    = 0000h
MF_POPUP        = 0010h
MF_MENUBARBREAK = 0020h
MF_MENUBREAK    = 0040h
MF_HILITE       = 0080h
MF_UNHILITE     = 0000h
MF_HELP         = 4000h
MF_ALLSTATE	= 00FFh

TAB		= 9
PATCOPYL	= 0021h
PATCOPYH	= 00F0h

ITEM	struc
    itmFlags	    dw ?
    itmCmdMenu	    dw ?
    itmXItem	    dw ?
    itmYItem	    dw ?
    itmCxItem	    dw ?
    itmCyItem	    dw ?
    itmDxTab	    dw ?
    itmCheckMarkOn  dw ?
    itmCheckMarkOff dw ?
    itmHItem	    dw ?
    strgX           dw ?
    strgWidth       dw ?
    len 	    dw ?
ITEM	ends

SIG_MENU	equ ('M' + ('U' * 256))

AMENU	struc
    mnPMenuNext     dw ?
    mnFlags	    dw ?
    mnSignature     dw ?
    mnHqOwner	    dw ?
    mnCxMenu	    dw ?
    mnCyMenu	    dw ?
    mnCItems	    dw ?
    mnhwndNotify    dw ?
    mnRgItems	    dw ?
ifdef JAPAN
    mnMenuMode	    dw ?
endif
AMENU	ends

;
; Menu string structure
;
if 0
STRG	struc
    len 	dw ?
    strgX       dw ?
    strgWidth   dw ?
    strgString	dw ?
STRG	ends
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user95.asm ===
;
;   USER95.ASM
;   Win16 USER thunks new for Win95
;
;   History:
;
;   Created 7-Oct-97 by Dave Hart (davehart)
;
;--

    TITLE   USER5.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


    DUserThunk  ACTIVATEKEYBOARDLAYOUT
    DUserThunk  BROADCASTSYSTEMMESSAGE
    DUserThunk  CALLMSGFILTER32
    DUserThunk  CASCADEWINDOWS
    DUserThunk  CHANGEDISPLAYSETTINGS
    DUserThunk  CHECKMENURADIOITEM
    DUserThunk  CHILDWINDOWFROMPOINTEX
    DUserThunk  CHOOSECOLOR_CALLBACK16
    DUserThunk  CHOOSEFONT_CALLBACK16
    DUserThunk  COPYIMAGE
    DUserThunk  CREATEICONFROMRESOURCEEX
    DUserThunk  DESTROYICON32
    DUserThunk  DISPATCHINPUT, 0
    DUserThunk  DISPATCHMESSAGE32
    DUserThunk  DLLENTRYPOINT
    DUserThunk  DOHOTKEYSTUFF
    DUserThunk  DRAWANIMATEDRECTS
    DUserThunk  DRAWCAPTION
    DUserThunk  DRAWCAPTIONTEMP
    DUserThunk  DRAWEDGE
    DUserThunk  DRAWFRAMECONTROL
    DUserThunk  DRAWICONEX
    DUserThunk  DRAWMENUBARTEMP
    DUserThunk  DRAWSTATE
    DUserThunk  DRAWTEXTEX
    DUserThunk  ENUMDISPLAYSETTINGS
    DUserThunk  FINDREPLACE_CALLBACK16
    DUserThunk  FINDWINDOWEX
    DUserThunk  GETAPPVER, 0
    DUserThunk  GETCLASSINFOEX
    DUserThunk  GETFOREGROUNDWINDOW, 0
    DUserThunk  GETICONINFO
    DUserThunk  GETKEYBOARDLAYOUT
    DUserThunk  GETKEYBOARDLAYOUTLIST
    DUserThunk  GETKEYBOARDLAYOUTNAME
    DUserThunk  GETMENUCONTEXTHELPID
    DUserThunk  GETMENUDEFAULTITEM
    DUserThunk  GETMENUITEMINFO
    DUserThunk  GETMENUITEMRECT
    DUserThunk  GETMESSAGE32
    DUserThunk  GETPROPEX
    DUserThunk  GETSCROLLINFO
    DUserThunk  GETSHELLWINDOW, 0
    DUserThunk  GETSYSCOLORBRUSH
    DUserThunk  GETWINDOWCONTEXTHELPID
    DUserThunk  GETWINDOWRGN
    DUserThunk  HACKTASKMONITOR
    DUserThunk  INITTHREADINPUT
    DUserThunk  INSERTMENUITEM
    DUserThunk  INSTALLIMT
    DUserThunk  ISDIALOGMESSAGE32
    DUserThunk  LOADIMAGE
    DUserThunk  LOADKEYBOARDLAYOUT
    DUserThunk  LOOKUPICONIDFROMDIRECTORYEX
    DUserThunk  MENUITEMFROMPOINT
    DUserThunk  MESSAGEBOXINDIRECT
    DUserThunk  MSGWAITFORMULTIPLEOBJECTS
    DUserThunk  OPENFILENAME_CALLBACK16
    DUserThunk  PEEKMESSAGE32
    DUserThunk  PLAYSOUNDEVENT
    DUserThunk  POSTMESSAGE32
    DUserThunk  POSTPOSTEDMESSAGES, 0
    DUserThunk  POSTTHREADMESSAGE32
    DUserThunk  PRINTDLG_CALLBACK16
    DUserThunk  REGISTERCLASSEX
    DUserThunk  REMOVEPROPEX
    DUserThunk  SETCHECKCURSORTIMER
    DUserThunk  SETFOREGROUNDWINDOW
    DUserThunk  SETMENUCONTEXTHELPID
    DUserThunk  SETMENUDEFAULTITEM
    DUserThunk  SETMENUITEMINFO
    DUserThunk  SETMESSAGEEXTRAINFO
    DUserThunk  SETPROPEX
    DUserThunk  SETSCROLLINFO
    DUserThunk  SETSYSCOLORSTEMP
    DUserThunk  SETWINDOWCONTEXTHELPID
    DUserThunk  SETWINDOWRGN
    DUserThunk  SIGNALPROC32
    DUserThunk  TILEWINDOWS
    DUserThunk  TRACKPOPUPMENUEX
    DUserThunk  TRANSLATEMESSAGE32
    DUserThunk  UNINSTALLIMT
    DUserThunk  UNLOADINSTALLABLEDRIVERS
    DUserThunk  UNLOADKEYBOARDLAYOUT
    DUserThunk  WINDOWFROMDC
    DUserThunk  WNETINITIALIZE, 0
    DUserThunk  WNETLOGON

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\user4.asm ===
;
;   USER4.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;   Split off from USER3.ASM 26-May-93 by bobday
;
;--

    TITLE   USER4.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   VALIDATERECT
    UserThunk   VALIDATERGN
    DUserThunk  WAITMESSAGE,0
    DUserThunk  WINDOWFROMPOINT
;;; UserThunk   WINFARFRAME         ;LOCALAPI in winstack.asm
;;; UserThunk   WINHELP
    DUserThunk  WINOLDAPPHACKOMATIC
    DUserThunk  WOWWORDBREAKPROC
;;; UserThunk   WNETADDCONNECTION
;;; UserThunk   WNETBROWSEDIALOG
;;; UserThunk   WNETCANCELCONNECTION
;;; UserThunk   WNETCANCELJOB
;;; UserThunk   WNETCLOSEJOB
;;; UserThunk   WNETDEVICEMODE
;;; UserThunk   WNETGETCAPS
;;; UserThunk   WNETGETCONNECTION
;;; UserThunk   WNETGETERROR
;;; UserThunk   WNETGETERRORTEXT
;;; UserThunk   WNETGETUSER
;;; UserThunk   WNETHOLDJOB
;;; UserThunk   WNETLOCKQUEUEDATA
;;; UserThunk   WNETOPENJOB
;;; UserThunk   WNETRELEASEJOB
;;; UserThunk   WNETSETJOBCOPIES
;;; UserThunk   WNETUNLOCKQUEUEDATA
;;; UserThunk   WNETUNWATCHQUEUE
;;; UserThunk   WNETWATCHQUEUE
    UserThunk   WRITECOMM
;;; UserThunk   WVSPRINTF           ;LOCALAPI in wsprintf.c
    UserThunk   XCSTODS
    DUserThunk  _FFFE_FARFRAME
;;; UserThunk   _WSPRINTF           ;LOCALAPI in wsprintf.c
    UserThunk   SETWINDOWSHOOKEX
    UserThunk   UNHOOKWINDOWSHOOKEX
    UserThunk   CALLNEXTHOOKEX

;;;;;
;;;;;   Win 3.1 Thunks
;;;;;

    DUserThunk  QUERYSENDMESSAGE
    DUserThunk  USERSEEUSERDO
    DUserThunk  LOCKINPUT
;   DUserThunk  GETSYSTEMDEBUGSTATE, 0
    UserThunk   ENABLECOMMNOTIFICATION
    UserThunk   EXITWINDOWSEXEC
    DUserThunk  GETCURSOR, 0
    DUserThunk  GETOPENCLIPBOARDWINDOW, 0
;   UserThunk   SENDDRIVERMESSAGE
;   UserThunk   OPENDRIVER
;   UserThunk   CLOSEDRIVER
;   UserThunk   GETDRIVERMODULEHANDLE
;   UserThunk   DEFDRIVERPROC
;   UserThunk   GETDRIVERINFO
;   UserThunk   GETNEXTDRIVER
    UserThunk   MAPWINDOWPOINTS
    DUserThunk  OLDSETDESKPATTERN
    DUserThunk  GETFREESYSTEMRESOURCES
    DUserThunk  OLDSETDESKWALLPAPER      ;;;;;;
    DUserThunk  GETMESSAGEEXTRAINFO, 0
;;;    DUserThunk  KEYBD_EVENT         ; local API in winmisc2.asm
    DUserThunk  KEYBDEVENT
    UserThunk   REDRAWWINDOW
    UserThunk   LOCKWINDOWUPDATE
;;    DUserThunk  MOUSE_EVENT          ;; in winmisc2.asm
    DUserThunk  MOUSEEVENT
;;    DUserThunk  MENUWINDOWPROC       ;;;;;; in wclass.asm
    UserThunk   GETCLIPCURSOR
    UserThunk   SCROLLWINDOWEX
    DUserThunk  ISMENU
    UserThunk   GETDCEX
;;    UserThunk   COPYICON              ;;;; in rmcreate.c
;;    UserThunk   COPYCURSOR            ;;;; in rmcreate.c
    UserThunk   GETWINDOWPLACEMENT
    UserThunk   SETWINDOWPLACEMENT
    UserThunk   GETINTERNALICONHEADER
;;;    UserThunk   SUBTRACTRECT        ; LOCALAPI in winrect.asm
    UserThunk   DLGDIRSELECTEX
    UserThunk   DLGDIRSELECTCOMBOBOXEX
    DUserThunk  GETUSERLOCALOBJTYPE
    DUserThunk  HARDWARE_EVENT
    UserThunk   ENABLESCROLLBAR
    UserThunk   SYSTEMPARAMETERSINFO
;   UserThunk   GP
;;; DUserThunk  WNETERRORTEXT
;;; UserThunk   WNETABORTJOB
;;; DUserThunk  WNETENABLE
;;; DUserThunk  WNETDISABLE
;;; DUserThunk  WNETRESTORECONNECTION
;;; DUserThunk  WNETWRITEJOB
;;; DUserThunk  WNETCONNECTDIALOG
;;; DUserThunk  WNETDISCONNECTDIALOG
;;; DUserThunk  WNETCONNECTIONDIALOG
;;; DUserThunk  WNETVIEWQUEUEDIALOG
;;; DUserThunk  WNETPROPERTYDIALOG
;;; DUserThunk  WNETGETDIRECTORYTYPE
;;; DUserThunk  WNETDIRECTORYNOTIFY
;;; DUserThunk  WNETGETPROPERTYTEXT
    DUserThunk  NOTIFYWOW
    DUserThunk  Win32WinHelp          
sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winhook.asm ===
title   WINHOOK.ASM - SetWindowsHook() and friends

ifdef WOW
NOEXTERNS equ 1
SEGNAME equ <TEXT>
endif

        .xlist
        include user.inc
        .list

	swappro  = 0

; include NEW_SEG1 struc used in GetProcModule

	include newexe.inc

ExternFP <GetCodeInfo>
ExternFP <GetExePtr>
ExternFP <GetCurrentTask>
ExternFP <SetWindowsHookInternal>

createSeg   _%SEGNAME,%SEGNAME,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

;===========================================================================

sBegin  %SEGNAME

assumes CS,%SEGNAME
assumes DS,DATA
assumes ES,NOTHING

;============================================================================
;
;  HANDLE FAR PASCAL GetProcModule(FARPROC lpfn);
;
;  This function returns the module handle corresponding to a given
;  hook proc address.
;
;  CAUTION: This uses the undocumented feature of "GetCodeInfo()" that it
;	returns the module handle in ES register.
;
cProc   GetProcModule, <PUBLIC, FAR>
ParmD	lpfn
LocalV  seginfofromkernel, %size NEW_SEG1+2
cBegin
; Turns out GetCodeInfo
;
	pushd	lpfn		; GetCodeInfo(lpfn, &seginfo)
        lea     ax,seginfofromkernel
        push    ss
        push    ax
        call    GetCodeInfo
        or      ax,ax           ; AX is BOOL fSuccess (even though windows.h says void)
	mov	ax,es		; ES contains the module handle according
				; to David Weise...
	jnz	gpmexit		; We're ok

        ; hack. Excel global allocs some memory, puts
        ; code into it and passes it to us. The GetCodeInfo fails in this
        ; case so we need to get the module handle for a globalalloced
        ; chunk of memory.

        push    word ptr lpfn+2
        call    GetExePtr
gpmexit:

ifdef DEBUG
	or	ax,ax
	jnz	gpm900
        DebugErr DBF_ERROR, "Invalid Hook Proc Addr"
	xor	ax,ax
gpm900:
endif
cEnd


;==============================================================================
;
;   FARPROC FAR PASCAL SetWindowsHook(int idHook, FARPROC lpfn)
;   {
;	SetWindowsHookEx2(idHook,
;		(HOOKPROC)lpfn,
;		GetProcModule(lpfn),
;		(idHook == WH_MSGFILTER ? GetCurrentTask() : NULL));
;   }
;
cProc	ISetWindowsHook,<FAR, PUBLIC, LOADDS>
ParmW	idHook
ParmD	lpfn
LocalW	hmodule
LocalW	htask
cBegin
        ; Check if some apps are trying to unhook a hook using SetWindowsHook()
        mov     bx, seg_lpfn
	cmp	bx, HHOOK_MAGIC
	jz	swhHookMagic

	cmp	idHook,WH_MSGFILTER
        jnz     swh10

	call	GetCurrentTask
        jmp     swhMakeCall

swhHookMagic:
	; Now, it is clear that this app wants to unhook by calling SetWindowsHook()
	; All Micrographix apps do this trick to unhook their keyboard hooks.
	; Fix for Bug #7972 -- SANKAR -- 05/30/91 --
	; Let us unhook the node passed in thro lpfn;
ifdef DEBUG
        DebugErr <DBF_WARNING>, "SetWindowsHook called to unhook: use UnhookWindowsHook"
endif
        xor     ax,ax
        jmps    swhMakeCall

swh10:
        pushd   lpfn
        call    GetProcModule

swhMakeCall:
        push    ax
        push    idHook
        pushd   lpfn

        call    SetWindowsHookInternal

swhExit:
cEnd

sEnd    %SEGNAME

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\usercli.asm ===
;---------------------------------------------------------------------------
;   Optimzed Code Path - on x86 builds effectively excecutes USER32 code.
;
;   Created:
;     16-DEC-93 nandurir
;---------------------------------------------------------------------------
    TITLE   USER5.ASM
    PAGE    ,132

    .286p

    .xlist
    include ks386p.inc
    .286p
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include wow.inc
    include wowusr.inc
    ;;;;;include cmacros.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

externFP WowSetCompatHandle
;---------------------------------------------------------------------------
; Optimized thunks for x86 only
;
;
;---------------------------------------------------------------------------

ifndef PMODE32

      USER16CLIENTTHUNK  macro Iapi, api, argtypeslist, returntype, api32, apispecificcode, callserver
          sBegin CODE

              index = 0
              IRP argtype, <argtypeslist>
                  index = index + 1
              ENDM

              IFE index
                  &Iapi &api, 0
              ELSE
                  &Iapi &api
              ENDIF
          sEnd CODE
      endm

else

externFP OutputDebugString
LOGARGS macro apiname
       push dx
       push ax
       push cs
       push OFFSET afterlog_&apiname
       call OutputDebugString
       pop  ax
       pop  dx
       jmp  short afterlogname_&apiname
afterlog_&apiname: DB 'USER: ','&apiname','()', 0dh, 0ah, 0
afterlogname_&apiname:


endm
; flat selector values
;

FLATDS equ KGDT_R3_DATA OR RPL_MASK
FLATFS equ KGDT_R3_TEB OR RPL_MASK

; set flat ds and fs
;

SETFLATDSANDFS macro
.386p
     mov   ax, FLATDS
     mov   ds, ax
     mov   ax, FLATFS
     mov   fs, ax
endm

externFP  GetSelectorBase
GETFLATADDRESS macro farpointer
     ; check for null
     xor   dx, dx
     mov   ax, word ptr &farpointer+2
     or    ax, ax
     jz    @F
     cCall GetSelectorBase, <ax>

     ; check for base address 0

     mov   cx, ax
     or    cx, dx
     jz    @F

     ; now its ok

     add   ax, word ptr &farpointer
     adc   dx, 0
@@:
endm

; generates code like: parmW arg1
;

GENPARAM  macro argtype, argname
    parm&argtype &argname
endm


pushWORD_DWORD  macro argname
    movzx  eax, &argname
    push   eax
endm

pushINT_LONG   macro argname
    movsx  eax, &argname
    push   eax
endm

pushDWORD_DWORD   macro argname
    push  dword ptr &argname
endm

pushPSZ_DWORD   macro argname, apiname, argnumber

    GETFLATADDRESS &argname
    push  dx
    push  ax

    IFNB <apiname>
        or    ax, dx
        jnz   @F
        add   sp, argnumber * 4
        xor   eax, eax
        jmp   short FailCall_&apiname
    @@:
    ENDIF

endm

pushHHOOK_DWORD macro argname
    push dword ptr -1                  ; unreferenced parameter
                                       ; effectively an assertion
endm

pushARG16 macro argname
    push  &argname
endm

CALLORDECLARE macro  typestring, api32, totalbytes
    &typestring api32&@&totalbytes
endm

TESTCALLSERVERCONDITION macro
    mov   edx, DWORD PTR _wow16CsrFlag
    test  BYTE PTR [edx], 1
endm

; assumes eax is pointer to the flag
CLEARCALLSERVERCONDITION macro
    mov   BYTE PTR [edx], 0
endm

;--------------------------------------------------------------------------
; Iapi = either DUserThunk or UserThunk
; api  = actual name
; argtypeslist = list of argument 'types' like <WORD, INT, HWND>
; api32 = this function is called instead of _Api
; apispecificcode = flag indicating additional code needed for this api.
;                   This is intended for handling 'compatibility'.
;
;                   If this argument is not blank, then there must exist a macro
;                   APISPECIFICCODE_api, which expands to the desired code.
;                   At present it is included just before the 'return' to
;                   the app.
;
; callserver =  flag indication that it may be necessary to actually call
;               USER32.
;
;               If this argument is not blank, then there must exist a macro
;               CALLSERVERCONDITION_api which expands to the desired code and
;               clears or sets the zero flag. If ZF is clear, the actual
;               thunk gets called, else nop.
;
;
; generates code similar to:
;
;   externFP _Api OR Api32
;   sBegin CODE
;      if necessary
;           FUN_WOWApi equ FUN_Api
;           DUserThunk WOWApi, %(size Api16)
;      endif
;
;   cProc Api, <PUBLIC, FAR, PASCAL>, <ds>
;      parmW arg1
;   cBegin
;      movzx, eax, arg1
;      push   eax
;      call far ptr _Api OR Api32 (decorates the names)
;
;      if necessary checks the callservercondtion
;           resets the callservercondition
;           push arg1
;           call WOWApi ; the actual thunk to wow32/server
;        @@:
;      endif
;
;      if exists, includes code in apispecificcode_api
;      endif
;   cEnd
;   sEnd CODE
;
;                                                          - nanduri
;--------------------------------------------------------------------------


USER16CLIENTTHUNK  macro Iapi, api, argtypeslist, returntype, api32, apispecificcode, callserver

    ;*** declare api
    ;

    index = 0
    IRP argtype, <argtypeslist>
       index = index + 1
    ENDM

    IFB <api32>
        CALLORDECLARE <externFP>, _&api, %(index*4)
    ELSE
        CALLORDECLARE <externFP>, _&api32, %(index*4)
    ENDIF

    sBegin CODE                       ; _&api

    ;*** create thunk to wow32
    ;

    IFNB <callserver>
        FUN_WOW&api equ FUN_&api
        DUserThunk WOW&api, %(size api&16)
    ENDIF

    ;*** create thea Api label
    ;

    IFNB <api>
        IFIDNI <Iapi>, <DUSERTHUNK>
            cProc &api, <PUBLIC, FAR, PASCAL>, <ds>
        ELSE
            cProc I&api, <PUBLIC, FAR, PASCAL>, <ds>
        ENDIF
    ENDIF
    
    ;*** declare args
    ;

    nargcount = 0
    IRP argtype, <argtypeslist>
        nargcount = nargcount + 1
        IFIDNI <argtype>, <WORD>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <INT>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <SHORT>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <DWORD>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <LONG>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <ULONG>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <PSZ>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <NONOPTPSZ>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <HWND>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <HHOOK>
            genparam D, arg%(nargcount)
        ENDIF
    ENDM

    ;*** begin body
    ;

    cBegin
    
       ;*** set 32bit registers
       ;

       SETFLATDSANDFS

       ;*** push args in reverse
       ;

       FailCall = 0
       argtopush = nargcount
       REPT nargcount
           inputargindex = 0
           IRP argtype, <argtypeslist>
               inputargindex = inputargindex + 1
               IFE argtopush - inputargindex
                   IFIDNI <argtype>, <WORD>
                       pushWORD_DWORD arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <INT>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <SHORT>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <DWORD>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <LONG>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <ULONG>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <PSZ>
                       pushPSZ_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <NONOPTPSZ>
                       FailCall = argtopush ; fails call if null
                       pushPSZ_DWORD   arg%argtopush, &api, %argtopush
                   ENDIF
                   IFIDNI <argtype>, <HWND>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <HHOOK>
                       pushHHOOK_DWORD  arg%argtopush
                   ENDIF
               ENDIF
           ENDM
           argtopush = argtopush - 1
       ENDM

       ;*** called user32/client api
       ;

       IFB <api32>
          CALLORDECLARE <call>, _&api, %(nargcount*4)
       ELSE
          CALLORDECLARE <call>, _&api32, %(nargcount*4)
       ENDIF

       ;*** check if we ever need to call server
       ;*** calls the real wow thunk

       IFNB <callserver>
           TESTCALLSERVERCONDITION
           jz @F
           CLEARCALLSERVERCONDITION
           index = 0;
           IRP argtype, <argtypeslist>
              index = index + 1
              pushARG16 arg%index
           ENDM
           call WOW&api
       @@:
       ENDIF

       ;*** check for any api specific compatibility code to execute
       ;

       IFNB <apispecificcode>
           APISPECIFICCODE_&api
       ENDIF

       IF FailCall
       FailCall_&api:
       ENDIF

       IFNB <returntype>
          IRP argtype, <dword, long, ulong>
             IFIDNI <returntype>, <argtype>
                 mov edx, eax
                 shr edx, 16
                 EXITM
             ENDIF
          ENDM

          IFIDNI <returntype>, <boolzero>
              xor ax, ax
          ENDIF

       ENDIF

ifdef DEBUG
       ;LOGARGS &api
endif

    cEnd
    ; end body

    sEnd CODE                            ; _&api
endm

endif ; PMODE32

assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

;;;;;;;;;;sBegin  CODE              ; macro will generate this

APISPECIFICCODE_GETCLIENTRECT macro
    xor eax, eax
endm

APISPECIFICCODE_GETKEYSTATE macro
    mov cl, ah
    and cl, 080h
    or  al, cl
endm

APISPECIFICCODE_GETWINDOWRECT macro
    xor eax, eax
endm

; The following call is only for a dBase for Windows 5.0 bug. Notice however, that this
; means that the internal KERNEL api WowSetCompatHandle will be called for every
; single invocation of GetDlgItem, no matter what app is running. This is bad, but
; on X86 platforms we don't transition to WOW32, and the cost of testing for it
; is just about as expensive as just saving it. Still, this should be removed as
; soon as we are convinced that the dBase bug has been fixed. -NeilSa
APISPECIFICCODE_GETDLGITEM macro
     push ax
     call WowSetCompatHandle
endm

public _wow16gpsi
public _wow16CsrFlag
public _wow16gHighestUserAddress

sBegin CODE
_wow16gpsi            DD 0
_wow16CsrFlag         DD 0
_wow16gHighestUserAddress  DD 0
sEnd   CODE

    ; the following may end up calling wow32

    USER16CLIENTTHUNK UserThunk,   DEFHOOKPROC,      <int, word, dword, hhook>, dword, WOW16DefHookProc,,srvcond
    USER16CLIENTTHUNK UserThunk,   ENABLEMENUITEM,   <hwnd, word, word>, word,,,srvcond
    USER16CLIENTTHUNK DUserThunk,  GETKEYSTATE,      <int>, int,, compatcode, srvcond
    USER16CLIENTTHUNK UserThunk,   GETKEYBOARDSTATE, <nonoptpsz>, boolzero,,,srvcond

    ; the following are all thunked locally

    USER16CLIENTTHUNK UserThunk,   CLIENTTOSCREEN,   <hwnd, psz>,boolzero
    USER16CLIENTTHUNK UserThunk,   GETCLASSNAME,     <hwnd, psz, word>, word, GETCLASSNAMEA
    USER16CLIENTTHUNK UserThunk,   GETCLIENTRECT,    <hwnd, psz>, bool,,compatcode
    USER16CLIENTTHUNK UserThunk,   GETCURSORPOS,     <psz>, boolzero
    USER16CLIENTTHUNK DUserThunk,  GETDESKTOPHWND,   <>, hwnd, GETDESKTOPWINDOW
    USER16CLIENTTHUNK DUserThunk,  GETDESKTOPWINDOW, <>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETDLGITEM,       <hwnd, word>, hwnd,,compatcode
    USER16CLIENTTHUNK UserThunk,   GETMENU,          <hwnd>, hmenu
    USER16CLIENTTHUNK UserThunk,   GETMENUITEMCOUNT, <hwnd>, int
    USER16CLIENTTHUNK UserThunk,   GETMENUITEMID,    <hwnd, int>, uint
    USER16CLIENTTHUNK UserThunk,   GETMENUSTATE,     <hwnd, word, word>, uint
    USER16CLIENTTHUNK DUserThunk,  GETNEXTWINDOW,    <hwnd, word>, hwnd, GETWINDOW
    USER16CLIENTTHUNK UserThunk,   GETPARENT,        <hwnd>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETSUBMENU,       <hwnd, int>, hmenu
    USER16CLIENTTHUNK UserThunk,   GETSYSCOLOR,      <int>, dword
    USER16CLIENTTHUNK UserThunk,   GETSYSTEMMETRICS, <int>, int
    USER16CLIENTTHUNK UserThunk,   GETTOPWINDOW,     <hwnd>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETWINDOW,        <hwnd, word>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETWINDOWRECT,    <hwnd, psz>, bool,,compatcode
    USER16CLIENTTHUNK DUserThunk,  ISWINDOW,         <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   SCREENTOCLIENT,   <hwnd, psz>, boolzero
ifdef DEBUG
    USER16CLIENTTHUNK UserThunk,   ISCHILD,          <hwnd, hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISICONIC,         <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISWINDOWENABLED,  <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISWINDOWVISIBLE,  <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISZOOMED,         <hwnd>, bool
else
    USER16CLIENTTHUNK DUserThunk,  ISCHILD,          <hwnd, hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISICONIC,         <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISWINDOWENABLED,  <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISWINDOWVISIBLE,  <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISZOOMED,         <hwnd>, bool
endif


;;;;;;;;;sEnd    CODE              ; macro will generate this

sBegin CODE

ifndef PMODE32

    DUserThunk  GETTICKCOUNT, 0
    DUserThunk  GETCURRENTTIME, 0

else

labelFP  <PUBLIC, GETTICKCOUNT>
labelFP  <PUBLIC, GETCURRENTTIME>

    ; the TickCount is accessible from client address space.
    ; refer sdk\inc\ntexapi.h
    ;                                                 - nanduri

.386p
    ; set 32bit ds

    push  ds
    mov   ax, FLATDS
    mov   ds, ax

    ; from  sdk\inc\ntexapi.h  NtGetTickCount - equivalent code

    mov   edx, MM_SHARED_USER_DATA_VA
    mov   eax, [edx].UsTickCountLow
    mul   dword ptr [edx].UsTickCountMultiplier
    shrd  eax,edx,24

    mov   edx, eax
    shr   edx, 010h
    and   ax, NOT GRAINYTIC_RES   ; round off to lower 64 boundary
                ;this is a cheap implemention of WOWCF_GRAINYTICS flag
    pop ds
    retf
.286p

endif

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winlang.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINLANG.ASM
;   Win16 language-dependent string services
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--


;****************************************************************************
;*                                                                          *
;*  WinLang.ASM -                                                           *
;*                                                                          *
;*      API calls to support different lanuages                             *
;*                                                                          *
;****************************************************************************

NOTEXT = 1

.xlist
include user.inc
.list

ExternFP       AllocSelector
ExternFP       FreeSelector
ExternFP       PrestoChangoSelector

ExternNP       IAnsiPrev
ExternNP       IAnsiNext

;****************************************************************************
;*                                                                          *
;*  WOW note:  The implementations in this file are the US implementations  *
;*             with all the language driver and DBCS stuff ripped out.      *
;*             PatchUserStrRtnsToThunk, at the bottom of this file, is      *
;*             called during startup of user16 if the locale is other       *
;*             than U.S. English, or if forced to thunk by a registry key.  *
;*             This routine patches each of the APIs implemented here to    *
;*             simply jump to the thunk, with a name beginning "Win32".     *
;*                                                                          *
;*             The StrRtnsPatchTable defined below controls the patching.   *
;*                                                                          *
;****************************************************************************

ExternNP        Win32lstrcmp
ExternNP        Win32lstrcmpi
ExternNP        Win32AnsiPrev
ExternNP        Win32AnsiNext
ExternNP        Win32AnsiUpper
ExternNP        Win32AnsiLower
ExternNP        Win32AnsiUpperBuff
ExternNP        Win32AnsiLowerBuff
ExternNP        Win32IsCharAlpha
ExternNP        Win32IsCharAlphaNumeric
ExternNP        Win32IsCharUpper
ExternNP        Win32IsCharLower

sBegin   DATA
LabelW  StrRtnsPatchTable

;       Location of patch                  Target of jmp patched in
;       -----------------                  ------------------------
        dw codeOffset Ilstrcmp,            codeOffset Win32lstrcmp
        dw codeOffset Ilstrcmpi,           codeOffset Win32lstrcmpi
;
; These two functions need to be thunked only for DBCS builds
;
ifdef   FE_SB
        dw codeOffset IAnsiPrev,           codeOffset Win32AnsiPrev
        dw codeOffset IAnsiNext,           codeOffset Win32AnsiNext
endif ; FE_SB

        dw codeOffset IAnsiUpper,          codeOffset Win32AnsiUpper
        dw codeOffset IAnsiLower,          codeOffset Win32AnsiLower
        dw codeOffset IAnsiUpperBuff,      codeOffset Win32AnsiUpperBuff
        dw codeOffset IAnsiLowerBuff,      codeOffset Win32AnsiLowerBuff
        dw codeOffset IsCharAlpha,         codeOffset Win32IsCharAlpha
        dw codeOffset IsCharAlphaNumeric,  codeOffset Win32IsCharAlphaNumeric
        dw codeOffset IsCharUpper,         codeOffset Win32IsCharUpper
        dw codeOffset IsCharLower,         codeOffset Win32IsCharLower
LabelW  StrRtnsPatchTableEnd
sEnd


createSeg _TEXT, CODE, WORD, PUBLIC, CODE


sBegin  CODE
assumes  CS, CODE
assumes  DS, DATA

ExternNP        MyUpper
ExternNP        MyLower
ExternNP        MyAnsiUpper
ExternNP        MyAnsiLower



;--------------------------------------------------------------------------
;
; The following table contains the primary and secondary weight info.
;
; For alphanumeric characters primary weight is equal to (Ascii + PrimeWt)
; Secondary weight is either 0 or 1 (For all upper case letters zero and
; lower case letters 1);
;
; For non-alphanumeric characters, primary weight is their ASCII value and
; the secondary weight is zero.
;
; Note that the primary weight calculated with this table for the smallest
; of the alpha-numeric character('0') is 100h (30h+D0h), which is more than
; the primary weight of the highest non-alpha-numeric character FFh;
; Thus all non-alpha-numeric characters will sort before any alpha-numeric
; characters;
;
;       Note that 'PrimeWt' field for lowercase letters is B0h instead of
;       D0h because when added with their ascii, it should become exactly
;       equal to the primary weights of their upper-case counterparts;
;
; IMPORTANT NOTE: On 01-17-90, we came across a bug in lstrcmpi() due to
;   the fact that we are not treating characters C0h to FEh as upper and
;   lower case alphas; So, I added some more ranges to the SortStruc table
;   to map the range C0h to D6h onto the range E0h to F6 and to map the
;   range D8h to DEh onto the range F8h to FEh. A value of 20h in the PrimeWt
;   field automatically takes care of this mapping because that is the diff
;   to be added to the uppercase letter to make it lowercase; The secondary
;   weights are as usual 0 for uppercase and 1 for lowercase;
;   --Fix for Bug #8222  --01-17-90-- SANKAR --
;--------------------------------------------------------------------------
SortStruct      STRUC

    StartAscii  db      ?
    EndAscii    db      ?
    PrimeWt     db      ?
    SecondWt    db      ?

SortStruct      ENDS


public SortTable
LabelB  SortTable

        SortStruct      <'0', '9', 0D0h, 0>
        SortStruct      <'A', 'Z', 0D0h, 0>
        SortStruct      <'a', 'z', 0B0h, 1>
        SortStruct      <0C0h, 0D6h, 20h, 0>
        SortStruct      <0D8h, 0DEh, 20h, 0>
        SortStruct      <0E0h, 0F6h,   0, 1>
        SortStruct      <0F8h, 0FEh,   0, 1>
LabelB  SortTableEnd

;*----------------------------------------------------------------------*
;*                                                                      *
;*      GetWeightValues()                                               *
;*         Input:                                                       *
;*              AL = character whose weight values are asked for        *
;*         Output:                                                      *
;*              AX = Primary weight of the character                    *
;*              BL = Secondary weight of the character                  *
;*----------------------------------------------------------------------*

public GetWeightValues
GetWeightValues PROC    NEAR

        xor     ah, ah
        xor     bx, bx  ; Index into the table
        ; Enter the number of entries in the sort table.
        mov     cx, (SortTableEnd - SortTable)/(SIZE SortStruct)
gwv_loop:
        cmp     al, byte ptr SortTable[bx].StartAscii
        jb      gwv_end
        cmp     al, byte ptr SortTable[bx].EndAscii
        jbe     gwv_GetWeights
        add     bx, SIZE  SortStruct
        loop    gwv_loop
        jmps    gwv_end

gwv_GetWeights:
        add     al, byte ptr SortTable[bx].PrimeWt
        adc     ah, 0
        mov     bl, byte ptr SortTable[bx].SecondWt

gwv_end:
        ret

GetWeightValues ENDP


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  lstrcmp(String1, String2) -                                             *
;*                                                                          *
;*    String1 and String2 are LPSTR's to null terminated strings.           *
;*                                                                          *
;*    This function returns -1 if String1 sorts before String2, 0 if String1*
;*    and String2 have the same sorting and 1 if String2 sorts before       *
;*    String1.                                                              *
;*   NOTE: This is case sensitive compare.                                  *
;*                                                                          *
;*   Outside the U.S. English locale, this function is patched to be a      *
;*   near jump to Win32lstrcmp, aka WU32lstrcmp.                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc Ilstrcmp, <FAR, PUBLIC>, <SI, DI>
;                              ^^^^^^^^ US_lstrcmp assumes SI, DI saved!

ParmD  lpStr1
ParmD  lpStr2
LocalB SecWeight1       ; Locals used by US_lstrcmp
LocalB SecWeight2
LocalB LocSecWeight
LocalB fCaseSensitive   ; Flag indicating whether it is case sensitive or not.

cBegin
        mov     byte ptr fCaseSensitive, 1    ; Yup! It is case sensitive
        call    US_lstrcmp
cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*      US_lstrcmp                                                      *
;*         US version of string sort(Case sensitive);                   *
;*         Uses locals defined by Ilstrcmp above.
;*      To understand the algorithm, read the comments for SortStruct   *
;*                                                                      *
;*----------------------------------------------------------------------*

public  US_lstrcmp
US_lstrcmp      PROC    NEAR

        push    ds      ; Save ds
        ;Initialise the secondary wt values
        mov     byte ptr SecWeight1, 0
        mov     byte ptr SecWeight2, 0

        ; Load both the strings
        lds     si, lpStr1
        les     di, lpStr2

ss_loop:
        ; Take one char from both the strings.
        mov     al, byte ptr ds:[si]
        xor     ah, ah  ; make secondary wts zero
        mov     dl, byte ptr es:[di]
        xor     dh, dh

        inc     si      ; Move to next character
        inc     di

        cmp     al, 0
        jz      ss_chkprimary   ; Check if lpStr1 has ended

        cmp     dl, 0
        jz      ss_chkprimary   ; Check if lpStr2 has end