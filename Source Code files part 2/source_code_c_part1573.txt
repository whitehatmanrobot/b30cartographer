SharingServicesPage (spUPS, &psp);
        if (SUCCEEDED(hr))
            hpsp = CreatePropertySheetPage (&psp);
    }
    return hpsp;
}

// stubs (these are referenced, but not called via this code path)
HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis) { return S_OK; }
HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis) { return S_OK; }
INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam) { return 0; }
INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam ) { return 0; }
HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager) { return S_OK; }
HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection) { return S_OK; }
STDAPI_(VOID) NcFreeNetconProperties (NETCON_PROPERTIES* pProps) { return; }
DWORD RasGetErrorString(UINT uErrorValue, LPTSTR lpszErrorString, DWORD cBufSize) { return -1; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\properties.cpp ===
#include "properties.h"
#include "util.h"

static const TCHAR c_szSharedAccessClientKeyPathDownlevel[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICSClient");
static const TCHAR c_szShowIcon[] = TEXT("ShowIcon");

CPropertiesDialog::CPropertiesDialog(IInternetGateway* pInternetGateway)
{
    m_hIcon = NULL;
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();

}

CPropertiesDialog::~CPropertiesDialog()
{
    m_pInternetGateway->Release();
}


LRESULT CPropertiesDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    
    // load the little icon, this can not be done in the rc file, it stretches the icon
    
    int cx = GetSystemMetrics(SM_CXSMICON);
    int cy = GetSystemMetrics(SM_CYSMICON);
    
    m_hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_GATEWAY), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR));
    if(NULL != m_hIcon)
    {
        SendDlgItemMessage(IDC_PROPERTIES_ADAPTERICON, STM_SETICON, reinterpret_cast<WPARAM>(m_hIcon), 0);
    }

    // set the text with the connection name
    
    LPTSTR pszConnectionName;
    hr = GetConnectionName(m_pInternetGateway, &pszConnectionName);
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(IDC_PROPERTIES_ADAPTERNAME, pszConnectionName);
        
        LocalFree(pszConnectionName);
    }

    // check the show icon checkbox

    if(SUCCEEDED(ShouldShowIcon()))
    {
        CheckDlgButton(IDC_PROPERTIES_SHOWICON, BST_CHECKED);
    }

    return 0;
}

LRESULT CPropertiesDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(NULL != m_hIcon)
    {
        DestroyIcon(m_hIcon);
    }

    return 0;
}

LRESULT CPropertiesDialog::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR* pNotifyHeader = reinterpret_cast<NMHDR*>(lParam);

    if(PSN_APPLY == pNotifyHeader->code)
    {
        SetShowIcon(BST_CHECKED == IsDlgButtonChecked(IDC_PROPERTIES_SHOWICON));
    }

    return 0;
}

HRESULT CPropertiesDialog::ShouldShowIcon(void)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPathDownlevel, NULL, KEY_QUERY_VALUE, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, c_szShowIcon, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &dwSize))
        {
            if(REG_DWORD == dwType && 0 == dwValue) 
            {
                hr = E_FAIL;
            }
        }
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT CPropertiesDialog::SetShowIcon(BOOL bShowIcon)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPathDownlevel, NULL, TEXT(""), 0, KEY_SET_VALUE, NULL, &hKey, NULL))
    {
        DWORD dwValue = bShowIcon;
        if(ERROR_SUCCESS == RegSetValueEx(hKey, c_szShowIcon, NULL, REG_DWORD, reinterpret_cast<LPBYTE>(&dwValue), sizeof(dwValue)))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
        
        RegCloseKey(hKey);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\stdafx.h ===
#pragma once

#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#include "atlwin.h"
#include "upnp.h"
#include "icsdclt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\trayicon.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "beacon.h"
#include "winsock2.h"

#define WM_APP_TRAYMESSAGE WM_APP
#define WM_APP_ADDBEACON WM_APP+1 // wParam: unused, lParam: IInternetGateway*
#define WM_APP_REMOVEBEACON WM_APP+2 // wParam: unused, lParam: unused
#define WM_APP_SOCKET_NOTIFICATION WM_APP+3
#define WM_APP_GETBEACON WM_APP+4


class CICSTrayIcon : public CWindowImpl<CICSTrayIcon>
{

public:
    BEGIN_MSG_MAP(CICSTrayIcon)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_APP_TRAYMESSAGE, OnTrayMessage)
        MESSAGE_HANDLER(WM_APP_ADDBEACON, OnAddBeacon)
        MESSAGE_HANDLER(WM_APP_REMOVEBEACON, OnRemoveBeacon)
        MESSAGE_HANDLER(WM_APP_SOCKET_NOTIFICATION, OnSocketNotification)
        MESSAGE_HANDLER(WM_APP_GETBEACON, OnGetBeacon)
        COMMAND_ID_HANDLER(IDM_TRAYICON_STATUS, OnStatus)
        COMMAND_ID_HANDLER(IDM_TRAYICON_PROPERTIES, OnProperties)
        COMMAND_ID_HANDLER(IDM_TRAYICON_CONNECT, OnConnect)
        COMMAND_ID_HANDLER(IDM_TRAYICON_DISCONNECT, OnDisconnect)
    END_MSG_MAP()
    
    CICSTrayIcon();
    ~CICSTrayIcon();
    
private:
    HRESULT GetInternetGateway(IInternetGateway** ppInternetGateway);
    HRESULT ShowTrayIcon(UINT uID);
    HRESULT HideTrayIcon(UINT uID);
    HRESULT StartSearch(void);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEndSession(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAddBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRemoveBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSocketNotification(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGetBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStatus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    IInternetGateway* m_pInternetGateway;
    HRESULT m_hShowIconResult;
    IUPnPDeviceFinder* m_pDeviceFinder;
    LONG m_lSearchCookie;
    SOCKET m_DummySocket;

    BOOL m_bShowingProperties;
    BOOL m_bShowingStatus;
    DWORD m_dwRegisterClassCookie;
    BOOL m_bFileVersionsAccepted;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\trayicon.cpp ===
#include "trayicon.h"
#include "resource.h"
#include "shellapi.h"
#include "windowsx.h"
#include "status.h"
#include "properties.h"
#include "util.h"
#include "stdio.h"
#include "client.h"
#include "InternetGatewayFinder.h"

CICSTrayIcon::CICSTrayIcon()
{
    m_pInternetGateway = NULL;
    m_hShowIconResult = E_FAIL;
    m_pDeviceFinder = NULL;
    m_DummySocket = INVALID_SOCKET;
    m_bShowingProperties = FALSE;
    m_bShowingStatus = FALSE;
    m_dwRegisterClassCookie = 0;
    m_bFileVersionsAccepted = FALSE;
}

CICSTrayIcon::~CICSTrayIcon()
{
}

LRESULT CICSTrayIcon::OnAddBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    IInternetGateway* pInternetGateway = reinterpret_cast<IInternetGateway*>(lParam);

    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled);
    
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();
    m_hShowIconResult = ShowTrayIcon(0);

    return 0;
}

LRESULT CICSTrayIcon::OnRemoveBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    BSTR UniqueDeviceName = reinterpret_cast<BSTR>(lParam);
    
    if(NULL != m_pInternetGateway)
    {
        if(NULL != UniqueDeviceName)
        {
            BSTR CurrentUniqueDeviceName;
            hr = m_pInternetGateway->GetUniqueDeviceName(&CurrentUniqueDeviceName);
            if(SUCCEEDED(hr))
            {
                if(0 != wcscmp(UniqueDeviceName, CurrentUniqueDeviceName))
                {
                    hr = E_FAIL;
                }
                SysFreeString(CurrentUniqueDeviceName);
            }
        }
        if(SUCCEEDED(hr))
        {
            if(SUCCEEDED(m_hShowIconResult))
            {
                HideTrayIcon(0);
            }
            
            m_pInternetGateway->Release();
            m_pInternetGateway = NULL;
        }
    }

    return 0;
}

LRESULT CICSTrayIcon::OnGetBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    IInternetGateway** ppInternetGateway = reinterpret_cast<IInternetGateway**>(lParam);

    hr = GetInternetGateway(ppInternetGateway);
   
    return SUCCEEDED(hr) ? 1 : 0;

}

HRESULT CICSTrayIcon::ShowTrayIcon(UINT uID)
{
    HRESULT hr = S_OK;
    hr = CPropertiesDialog::ShouldShowIcon();
    if(SUCCEEDED(hr))
    {
        int nHeight = GetSystemMetrics(SM_CYSMICON); // ok if these fails, LoadImage has default behavior
        int nWidth = GetSystemMetrics(SM_CXSMICON);
        
        NOTIFYICONDATA IconData;
        IconData.cbSize = NOTIFYICONDATA_V1_SIZE; // compat with pre IE5
        IconData.uID = uID;
        IconData.hWnd = m_hWnd; 
        IconData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        IconData.uCallbackMessage = WM_APP_TRAYMESSAGE;
        IconData.hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_TRAYICON), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR));
        lstrcpyn(IconData.szTip, TEXT("Internet Connection Sharing"), 64);
        if(FALSE == Shell_NotifyIcon(NIM_ADD, &IconData))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CICSTrayIcon::HideTrayIcon(UINT uID)
{
    HRESULT hr = S_OK;

    NOTIFYICONDATA IconData;
    IconData.cbSize = NOTIFYICONDATA_V1_SIZE; // compat with pre IE5
    IconData.hWnd = m_hWnd; 
    IconData.uID = uID;
    IconData.uFlags = 0;
    Shell_NotifyIcon(NIM_DELETE, &IconData);

    return hr;
}

HRESULT CICSTrayIcon::GetInternetGateway(IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;

    if(NULL != m_pInternetGateway)
    {
        *ppInternetGateway = m_pInternetGateway;
        m_pInternetGateway->AddRef();
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT CICSTrayIcon::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    
    // if not IE 5.01 we can't do UPnP, but the window must stay so it can later post error dialogs
    hr = EnsureFileVersion("wininet.dll", MakeQword4(5, 0, 2919, 6305)); 
    if(SUCCEEDED(hr))
    {
        hr = EnsureFileVersion("urlmon.dll", MakeQword4(5, 0, 2919, 6303)); 
    }
    
    if(SUCCEEDED(hr))
    {
        hr = EnsureFileVersion("msxml.dll", MakeQword4(5, 0, 2919, 6303)); 
    }
    
    if(SUCCEEDED(hr))
    {
        m_bFileVersionsAccepted = TRUE;

        IUPnPDeviceFinder* pDeviceFinder;
        hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&m_pDeviceFinder));
        if(SUCCEEDED(hr))
        {
            hr = StartSearch();
        }
        
        if(SUCCEEDED(hr))
        {
            m_DummySocket = socket(AF_INET, SOCK_DGRAM, 0);
            if(INVALID_SOCKET != m_DummySocket)
            {
                if(0 == WSAAsyncSelect(m_DummySocket, m_hWnd, WM_APP_SOCKET_NOTIFICATION, FD_ADDRESS_LIST_CHANGE))
                {
                    DWORD dwBytesReturned;
                    if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        
        if(SUCCEEDED(hr))
        {
            CComObject<CInternetGatewayFinderClassFactory>* pInternetGatewayFinderClassFactory;
            hr = CComObject<CInternetGatewayFinderClassFactory>::CreateInstance(&pInternetGatewayFinderClassFactory);
            if(SUCCEEDED(hr))
            {
                pInternetGatewayFinderClassFactory->AddRef();
                
                hr = pInternetGatewayFinderClassFactory->Initialize(m_hWnd);
                if(SUCCEEDED(hr))
                {
                    hr = CoRegisterClassObject(CLSID_CInternetGatewayFinder, pInternetGatewayFinderClassFactory, CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &m_dwRegisterClassCookie);
                }
                
                pInternetGatewayFinderClassFactory->Release();
            }
            
        }
        
    }
    return 0;
}

LRESULT CICSTrayIcon::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DestroyWindow();
    return 0;
}

LRESULT CICSTrayIcon::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled);
    
    if(NULL != m_pDeviceFinder)
    {
        m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie); 
        m_pDeviceFinder->Release();
        m_pDeviceFinder = NULL;
    }

    if(INVALID_SOCKET != m_DummySocket)
    {
        closesocket(m_DummySocket);
    }
    
    if(0 != m_dwRegisterClassCookie)
    {
        CoRevokeClassObject(m_dwRegisterClassCookie);
    }
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CICSTrayIcon::OnTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    switch(lParam)
    {
    case WM_RBUTTONDOWN:
        {
            IInternetGateway* pInternetGateway;
            hr = GetInternetGateway(&pInternetGateway);
            if(SUCCEEDED(hr))
            {
                NETCON_MEDIATYPE MediaType;
                hr = pInternetGateway->GetMediaType(&MediaType);
                if(SUCCEEDED(hr))
                {
                    IUPnPService* pWANConnectionService;
                    hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
                    if(SUCCEEDED(hr))
                    {
                        NETCON_STATUS Status;
                        hr = GetConnectionStatus(pWANConnectionService, &Status);
                        if(SUCCEEDED(hr))
                        {
                            HMENU hMenu;
                            LPTSTR pszMenuID = NULL;
                            
                            if(NCS_CONNECTED == Status)
                            {
                                pszMenuID = NCM_SHAREDACCESSHOST_LAN == MediaType ? MAKEINTRESOURCE(IDM_TRAYICON_LAN_CONNECT) : MAKEINTRESOURCE(IDM_TRAYICON_RAS_CONNECT);
                            }
                            else if (NCS_DISCONNECTED == Status)
                            {
                                pszMenuID = NCM_SHAREDACCESSHOST_LAN == MediaType ? MAKEINTRESOURCE(IDM_TRAYICON_LAN_DISCONNECT) : MAKEINTRESOURCE(IDM_TRAYICON_RAS_DISCONNECT);
                            }
                            
                            if(NULL != pszMenuID)
                            {
                                hMenu = LoadMenu(_Module.GetResourceInstance(), pszMenuID);
                                if(NULL != hMenu)
                                {
                                    HMENU hSubMenu = GetSubMenu(hMenu, 0);
                                    if(NULL != hSubMenu)
                                    {
                                        POINT CursorPosition;
                                        if(GetCursorPos(&CursorPosition))
                                        {
                                            SetForegroundWindow(m_hWnd); // this is to get the menu to go away when it loses focus.  
                                            
                                            TrackPopupMenu(hSubMenu, TPM_RIGHTBUTTON, CursorPosition.x, CursorPosition.y, 0, m_hWnd, NULL);
                                        }
                                    }
                                    
                                    DestroyMenu(hMenu);
                                }
                            }
                        }
                        pWANConnectionService->Release();
                    }
                }
                pInternetGateway->Release();
            }
            break;
        }
    case WM_MOUSEMOVE: // REVIEW: is there a better message?
        {
            IInternetGateway* pInternetGateway;
            hr = GetInternetGateway(&pInternetGateway);
            if(SUCCEEDED(hr))
            {
                IUPnPService* pWANConnectionService;
                hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
                if(SUCCEEDED(hr))
                {
                    NETCON_STATUS Status;
                    hr = GetConnectionStatus(pWANConnectionService, &Status);
                    if(SUCCEEDED(hr))
                    {
                        TCHAR szConnectionStatus[64];
                        hr = ConnectionStatusToString(Status, szConnectionStatus, sizeof(szConnectionStatus) / sizeof(TCHAR));
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szFormat[64];
                            if(0 != LoadString(_Module.GetResourceInstance(), IDS_TOOLTIP_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                            {
                                NOTIFYICONDATA NotifyIconData;
                                ZeroMemory(&NotifyIconData, sizeof(NotifyIconData));
                                NotifyIconData.cbSize = NOTIFYICONDATA_V1_SIZE;
                                NotifyIconData.hWnd = m_hWnd;
                                NotifyIconData.uID = 0;
                                NotifyIconData.uFlags = NIF_TIP;
                                _sntprintf(NotifyIconData.szTip, 64, szFormat, szConnectionStatus);
                                NotifyIconData.szTip[63] = TEXT('\0'); // make sure a maximum length string is null terminated
                                
                                Shell_NotifyIcon(NIM_MODIFY, &NotifyIconData);
                            }
                        }
                    }
                    pWANConnectionService->Release();
                }
                pInternetGateway->Release();
            }
            break;
        }
        
    default:
        bHandled = FALSE;
        break;
    }
    return 0;
}

LRESULT CICSTrayIcon::OnStatus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    if(FALSE == m_bShowingStatus)
    {
        m_bShowingStatus = TRUE;

        IInternetGateway* pInternetGateway;
        hr = GetInternetGateway(&pInternetGateway);
        if(SUCCEEDED(hr))
        {
            LPTSTR pszConnectionName;
            hr = GetConnectionName(pInternetGateway, &pszConnectionName);
            if(SUCCEEDED(hr))
            {
                TCHAR szFormat[32];
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_STATUS_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                {
                    
                    LPTSTR pszArguments[] = {pszConnectionName};
                    LPTSTR pszFormattedString;
                    if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedString), 0, pszArguments))
                    {
                        CStatusDialog StatusDialog(pInternetGateway);
                        HPROPSHEETPAGE hStatusPage = StatusDialog.Create();
                        if(NULL != hStatusPage)
                        {
                            
                            HPROPSHEETPAGE PropertySheetPages[1];
                            PropertySheetPages[0] = hStatusPage;
                            
                            PROPSHEETHEADER PropertySheetHeader;
                            ZeroMemory(&PropertySheetHeader, sizeof(PropertySheetHeader));
                            PropertySheetHeader.dwSize = PROPSHEETHEADER_V1_SIZE;
                            PropertySheetHeader.dwFlags = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
                            PropertySheetHeader.hwndParent = m_hWnd;
                            PropertySheetHeader.pszCaption = pszFormattedString;
                            PropertySheetHeader.hInstance = _Module.GetResourceInstance();
                            PropertySheetHeader.nPages = 1;
                            PropertySheetHeader.phpage = PropertySheetPages;
                            
                            PropertySheet(&PropertySheetHeader);
                        }
                        LocalFree(pszFormattedString);
                    }
                }
                LocalFree(pszConnectionName);
            }
            pInternetGateway->Release();
        }
        else // if not beacon was detected
        {
            TCHAR szTitle[128];
            TCHAR szText[1024];

            if(NULL != LoadString(_Module.GetResourceInstance(), IDS_APPTITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR)))
            {
                if(TRUE == m_bFileVersionsAccepted)
                {
                    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_BEACONNOTFOUND, szText, sizeof(szText) / sizeof(TCHAR)))
                    {
                        MessageBox(szText, szTitle);                    
                    }
                }
                else
                {
                    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_NEEDNEWERIE, szText, sizeof(szText) / sizeof(TCHAR)))
                    {
                        MessageBox(szText, szTitle);                    
                    }
                }
            }
        }
    
        m_bShowingStatus = FALSE;
    }
    return 0;
}

extern HPROPSHEETPAGE GetSharedAccessPropertyPage (IInternetGateway* pInternetGateway, HWND hwndOwner);   // in saprop.cpp
LRESULT CICSTrayIcon::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    if(FALSE == m_bShowingProperties)
    {
        m_bShowingProperties = TRUE;

        IInternetGateway* pInternetGateway;
        hr = GetInternetGateway(&pInternetGateway);
        if(SUCCEEDED(hr))
        {
            CPropertiesDialog PropertiesDialog(pInternetGateway);
            HPROPSHEETPAGE hStatusPage = PropertiesDialog.Create();
            if(NULL != hStatusPage)
            {
                LPTSTR pszConnectionName;
                hr = GetConnectionName(pInternetGateway, &pszConnectionName);
                if(SUCCEEDED(hr))
                {
                    TCHAR szFormat[32];
                    if(0 != LoadString(_Module.GetResourceInstance(), IDS_PROPERTIES_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                    {
                        
                        LPTSTR pszArguments[] = {pszConnectionName};
                        LPTSTR pszFormattedString;
                        if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedString), 0, pszArguments))
                        {
                            HPROPSHEETPAGE PropertySheetPages[2];
                            PropertySheetPages[0] = hStatusPage;
                            PropertySheetPages[1] = GetSharedAccessPropertyPage (pInternetGateway, hWndCtl);
                            
                            PROPSHEETHEADER PropertySheetHeader;
                            ZeroMemory(&PropertySheetHeader, sizeof(PropertySheetHeader));
                            PropertySheetHeader.dwSize = PROPSHEETHEADER_V1_SIZE;
                            PropertySheetHeader.dwFlags = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
                            PropertySheetHeader.hwndParent = m_hWnd;
                            PropertySheetHeader.pszCaption = pszFormattedString;
                            PropertySheetHeader.hInstance = _Module.GetResourceInstance();
                            PropertySheetHeader.phpage = PropertySheetPages;
                            PropertySheetHeader.nPages = PropertySheetPages[1] ? 2 : 1;
                            
                            PropertySheet(&PropertySheetHeader);
                            
                            HRESULT hShouldShowIcon = CPropertiesDialog::ShouldShowIcon();
                            if(SUCCEEDED(hShouldShowIcon))   // if we are now showing the icon
                            {
                                if(FAILED(m_hShowIconResult)) // and weren't before
                                {
                                    m_hShowIconResult = ShowTrayIcon(0); // show it
                                }
                            }
                            else // if we are not hiding the icon
                            {
                                if(SUCCEEDED(m_hShowIconResult)) // and were showing it before
                                {
                                    HideTrayIcon(0); // hide it
                                    m_hShowIconResult = E_FAIL;
                                }
                            }
                            
                            LocalFree(pszFormattedString);
                        }
                        
                    }
                    
                    LocalFree(pszConnectionName);
                }
            }
            pInternetGateway->Release();
        }
        m_bShowingProperties = FALSE;
    }
    return 0;
}

LRESULT CICSTrayIcon::OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    IInternetGateway* pInternetGateway;
    hr = GetInternetGateway(&pInternetGateway);
    if(SUCCEEDED(hr))
    {
        IUPnPService* pWANConnectionService;
        hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
        if(SUCCEEDED(hr))
        {
            VARIANT OutArgs;
            hr = InvokeVoidAction(pWANConnectionService, L"RequestConnection", &OutArgs);
            if(SUCCEEDED(hr))
            {
                VariantClear(&OutArgs);
            }
            else if(UPNP_ACTION_HRESULT(800) == hr)
            {
                ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
            }
            else if(UPNP_E_DEVICE_TIMEOUT != hr)
            {
                ShowErrorDialog(m_hWnd, IDS_CONNECTIONFAILED);
            }

            
            pWANConnectionService->Release();
        }
        pInternetGateway->Release();
    }
    return 0;
}

LRESULT CICSTrayIcon::OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    IInternetGateway* pInternetGateway;
    hr = GetInternetGateway(&pInternetGateway);
    if(SUCCEEDED(hr))
    {
        IUPnPService* pWANConnectionService;
        hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
        if(SUCCEEDED(hr))
        {
            VARIANT OutArgs;
            hr = InvokeVoidAction(pWANConnectionService, L"ForceTermination", &OutArgs);
            if(SUCCEEDED(hr))
            {
                VariantClear(&OutArgs);
            }
            else if(UPNP_ACTION_HRESULT(800) == hr)
            {
                ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
            }

            
            pWANConnectionService->Release();
        }
        pInternetGateway->Release();
    }

    return 0;
}


LRESULT CICSTrayIcon::OnSocketNotification(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr S_OK;

    if(FD_ADDRESS_LIST_CHANGE == WSAGETSELECTEVENT(lParam))
    {
        if(NULL != m_pDeviceFinder)
        {
            hr = m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie);
            hr = StartSearch();
        }
        
        DWORD dwBytesReturned;
        if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
        {
            hr = E_FAIL;
        }
    }

    return 0;
}

HRESULT CICSTrayIcon::StartSearch(void)
{
    HRESULT hr = S_OK;
    

    BOOL bHandled;
    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled); // dump out the cache
   
    CComObject<CBeaconFinder>* pBeaconFinder;
    hr = CComObject<CBeaconFinder>::CreateInstance(&pBeaconFinder);
    if(SUCCEEDED(hr))
    {
        pBeaconFinder->AddRef();
        
        hr = pBeaconFinder->Initialize(m_hWnd);
        if(SUCCEEDED(hr))
        {
            BSTR bstrTypeURI;
            bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:1");
            if (NULL != bstrTypeURI)
            {
                hr = m_pDeviceFinder->CreateAsyncFind(bstrTypeURI, 0, pBeaconFinder, &m_lSearchCookie);
                if(SUCCEEDED(hr))
                {
                    hr = m_pDeviceFinder->StartAsyncFind(m_lSearchCookie);
                    
                }
                
                if(FAILED(hr)) // we must close this here because later calls don't know if the cookie is valid
                {
                    m_pDeviceFinder->Release();
                    m_pDeviceFinder = NULL;
                    
                }
                
                SysFreeString(bstrTypeURI);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        pBeaconFinder->Release();
    }

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\util.cpp ===
#include "stdafx.h"
#include "util.h"
#include "upnp.h"
#include "stdio.h"
#include "resource.h"

HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;
    
    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName; 
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        
        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }
        
        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

HRESULT InvokeVoidAction(IUPnPService * pService, LPWSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        SAFEARRAYBOUND  rgsaBound[1];
        SAFEARRAY       * psa = NULL;

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

        if (psa)
        {
            LONG    lStatus;
            VARIANT varInArgs;
            VARIANT varReturnVal;

            VariantInit(&varInArgs);
            VariantInit(pOutParams);
            VariantInit(&varReturnVal);

            varInArgs.vt = VT_VARIANT | VT_ARRAY;

            V_ARRAY(&varInArgs) = psa;

            hr = pService->InvokeAction(bstrActionName,
                                        varInArgs,
                                        pOutParams,
                                        &varReturnVal);
            if(SUCCEEDED(hr))
            {
                VariantClear(&varReturnVal);
            }

            SafeArrayDestroy(psa);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }   

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT GetConnectionName(IInternetGateway* pInternetGateway, LPTSTR* ppszConnectionName) // use LocalFree to free ppszConnectionName
{
    HRESULT hr = S_OK;

    *ppszConnectionName = NULL;

    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        BSTR ConnectionName;
        hr = GetStringStateVariable(pWANConnectionService, L"X_Name", &ConnectionName);
        if(SUCCEEDED(hr))
        {
            LPSTR pszConnectionName;
            hr = UnicodeToAnsi(ConnectionName, SysStringLen(ConnectionName), &pszConnectionName);
            {
                IUPnPService* pOSInfoService;
                hr = pInternetGateway->GetService(SAHOST_SERVICE_OSINFO, &pOSInfoService);
                if(SUCCEEDED(hr))
                {
                    BSTR MachineName;
                    hr = GetStringStateVariable(pOSInfoService, L"OSMachineName", &MachineName);
                    if(SUCCEEDED(hr))
                    {
                        LPSTR pszMachineName;
                        hr = UnicodeToAnsi(MachineName, SysStringLen(MachineName), &pszMachineName);
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szFormat[16];
                            if(0 != LoadString(_Module.GetResourceInstance(), IDS_NAME_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                            {
                                LPTSTR pszArguments[] = {pszConnectionName, pszMachineName};
                                LPTSTR pszFormattedName;
                                if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedName), 0, pszArguments))
                                {
                                    *ppszConnectionName = pszFormattedName;
                                }
                                else
                                {
                                    hr = E_FAIL;
                                }
                                
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                            CoTaskMemFree(pszMachineName);
                        }
                        SysFreeString(MachineName);
                    }
                    pOSInfoService->Release();
                }
                CoTaskMemFree(pszConnectionName);
            }
            SysFreeString(ConnectionName);
        }
        pWANConnectionService->Release();
    }

    if(FAILED(hr))
    {
        hr = S_OK;
        
        LPTSTR pszDefaultName = reinterpret_cast<LPTSTR>(LocalAlloc(0, 128 * sizeof(TCHAR)));
        if(NULL != pszDefaultName)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_DEFAULTADAPTERNAME, pszDefaultName, 128))
            {
                *ppszConnectionName = pszDefaultName;
            }
            else
            {
                LocalFree(pszDefaultName);
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService)
{
    HRESULT hr = S_OK;

    *ppWANConnectionService = NULL;

    if(NULL != pInternetGateway)
    {
        NETCON_MEDIATYPE MediaType;
        hr = pInternetGateway->GetMediaType(&MediaType);
        if(SUCCEEDED(hr))
        {
            if(NCM_SHAREDACCESSHOST_LAN == MediaType)
            {
                hr = pInternetGateway->GetService(SAHOST_SERVICE_WANIPCONNECTION, ppWANConnectionService);
            }
            else if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                hr = pInternetGateway->GetService(SAHOST_SERVICE_WANPPPCONNECTION, ppWANConnectionService);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
            
            
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT UnicodeToAnsi(LPWSTR pszUnicodeString, ULONG ulUnicodeStringLength, LPSTR* ppszAnsiString)
{
    HRESULT hr = S_OK;

    int nSizeNeeded = WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, ulUnicodeStringLength + 1, NULL, 0, NULL, NULL);            
    if(nSizeNeeded != 0)
    {
        LPSTR pszAnsiString = reinterpret_cast<LPSTR>(CoTaskMemAlloc(nSizeNeeded));
        if(NULL != pszAnsiString)
        {
            if(0 != WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, ulUnicodeStringLength + 1, pszAnsiString, nSizeNeeded, NULL, NULL))
            {
                *ppszAnsiString = pszAnsiString;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT FormatTimeDuration(UINT uSeconds, LPTSTR pszTimeDuration, SIZE_T uTimeDurationLength)
{
    HRESULT hr = S_OK;

    TCHAR   szTimeSeperator[5]; // 4 is the maximum length for szTimeSeperator
    if(0 != GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTimeSeperator, sizeof(szTimeSeperator) / sizeof(TCHAR)))
    {
        UINT uMinutes = uSeconds / 60;

        uSeconds = uSeconds % 60;
        
        UINT uHours = uMinutes / 60;

        uMinutes = uMinutes % 60;

        UINT uDays = uHours / 24;

        uHours = uHours % 24;


        TCHAR szFormat[64];
        
        if(0 == uDays)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_ZERODAYS, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        } 
        else if (1 == uDays)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_ONEDAY, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_MANYDAYS, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uDays, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        pszTimeDuration[uTimeDurationLength - 1] = TEXT('\0');

    }
    else
    {
        hr = E_FAIL;
    }
    
    return S_OK;
}

HRESULT FormatBytesPerSecond(UINT uBytesPerSecond, LPTSTR pszBytesPerSecond, SIZE_T uBytesPerSecondLength)
{
    HRESULT hr = S_OK;
    
    enum            {eZero = 0, eKilo, eMega, eGiga, eTera, eMax};
    INT             iOffset             = 0;
    UINT            uiDecimal           = 0;
    const UINT c_uiKilo = 1000;

    for (iOffset = eZero; iOffset < eMax; iOffset++)
    {

        // If we still have data, increment the counter
        //
        if (c_uiKilo > uBytesPerSecond)
        {
            break;
        }

        // Divide up the string
        //
        uiDecimal   = (uBytesPerSecond % c_uiKilo);
        uBytesPerSecond       /= c_uiKilo;
    }

    // We only want one digit for the decimal
    //
    uiDecimal /= (c_uiKilo/10);

    // Get the string used to display
    //
    TCHAR szFormat[64];
    if(0 != LoadString(_Module.GetResourceInstance(), IDS_METRIC_ZERO + iOffset, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
    {
        _sntprintf(pszBytesPerSecond, uBytesPerSecondLength, szFormat, uBytesPerSecond, uiDecimal);
        pszBytesPerSecond[uBytesPerSecondLength - 1] = TEXT('\0');
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

HRESULT GetConnectionStatus(IUPnPService* pWANConnection, NETCON_STATUS* pStatus)
{
    HRESULT hr = S_OK;
    
    BSTR ConnectionStatus;
    hr = GetStringStateVariable(pWANConnection, L"ConnectionStatus", &ConnectionStatus);
    if(SUCCEEDED(hr))
    {
        if(0 == wcscmp(ConnectionStatus, L"Connected"))
        {
            *pStatus = NCS_CONNECTED;    
        }
        else if(0 == wcscmp(ConnectionStatus, L"Connecting"))
        {
            *pStatus = NCS_CONNECTING;    
        }
        else if(0 == wcscmp(ConnectionStatus, L"Disconnected"))
        {
            *pStatus = NCS_DISCONNECTED;
        }
        else if(0 == wcscmp(ConnectionStatus, L"Disconnecting"))
        {
            *pStatus = NCS_DISCONNECTING;
        }
        else
        {
            *pStatus = NCS_HARDWARE_DISABLED;
        }
        SysFreeString(ConnectionStatus);
    }

    return hr;
}

HRESULT ConnectionStatusToString(NETCON_STATUS Status, LPTSTR szBuffer, int nBufferSize)
{
    HRESULT hr = S_OK;
    UINT uStringID = 0;    
    
    switch(Status)
    {
    case NCS_CONNECTED:
        uStringID = IDS_CONNECTED;
        break;
    case NCS_CONNECTING:
        uStringID = IDS_CONNECTING;
        break;
    case NCS_DISCONNECTED:
        uStringID = IDS_DISCONNECTED;
        break;
    case NCS_DISCONNECTING:
        uStringID = IDS_DISCONNECTING;
        break;
    default:
        uStringID = IDS_UNCONFIGURED;
        break;
    }

    if(0 == LoadString(_Module.GetResourceInstance(), uStringID, szBuffer, nBufferSize))
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT ShowErrorDialog(HWND hParentWindow, UINT uiErrorString)
{
    TCHAR szTitle[128];
    TCHAR szText[1024];
    
    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_APPTITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR)))
    {
        if(NULL != LoadString(_Module.GetResourceInstance(), uiErrorString, szText, sizeof(szText) / sizeof(TCHAR)))
        {
            MessageBox(hParentWindow, szText, szTitle, MB_OK);                    
        }
    }

    return 0;
}

UINT64 MakeQword2(DWORD a, DWORD b)
{
    UINT64 qw = a;
    qw = qw << 32;
    qw |= b;
    return qw;    
}

UINT64 MakeQword4(WORD a, WORD b, WORD c, WORD d)
{
    UINT64 qw = a;
    qw = qw << 16;
    qw |= b;
    qw = qw << 16;
    qw |= c;
    qw = qw << 16;
    qw |= d;
    return qw;    
}

HRESULT EnsureFileVersion(LPTSTR pszModule, UINT64 qwDesiredVersion)
{
    HRESULT hr = S_OK;

    DWORD dwDummy;
    DWORD dwVersionSize = GetFileVersionInfoSize(pszModule, &dwDummy);
    if(0!= dwVersionSize)
    {
        void* pVersionInfo = CoTaskMemAlloc(dwVersionSize);
        if(NULL != pVersionInfo)
        {
            if(0 != GetFileVersionInfo(pszModule, 0, dwVersionSize, pVersionInfo))
            {
                void* pSubInfo;
                UINT uiSubInfoSize;
                if(0 != VerQueryValue(pVersionInfo, TEXT("\\"), &pSubInfo, &uiSubInfoSize))
                {
                    VS_FIXEDFILEINFO* pFixedFileInfo = reinterpret_cast<VS_FIXEDFILEINFO*>(pSubInfo);
                    UINT64 qwFileVersion = MakeQword2(pFixedFileInfo->dwProductVersionMS, pFixedFileInfo->dwProductVersionLS);
                    if(qwFileVersion < qwDesiredVersion)
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }

            CoTaskMemFree(pVersionInfo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\beaconrc.h ===
#pragma once

#define IDXML_LAN 1
#define IDXML_RAS 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Internet Connection Sharing Client"
#define VER_INTERNALNAME_STR            "ICSDCLT.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\util.h ===
#pragma once

#include "netconp.h"
#include "upnp.h"
    
#define UPNP_ACTION_HRESULT(lError) (UPNP_E_ACTION_SPECIFIC_BASE + (lError - FAULT_ACTION_SPECIFIC_BASE))

UINT64 MakeQword2(DWORD a, DWORD b);
UINT64 MakeQword4(WORD a, WORD b, WORD c, WORD d);

HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);
HRESULT InvokeVoidAction(IUPnPService * pService, LPWSTR pszCommand, VARIANT* pOutParams);
HRESULT GetConnectionName(IInternetGateway* pInternetGateway, LPTSTR* ppszConnectionName);
HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService);
HRESULT UnicodeToAnsi(LPWSTR pszUnicodeString, ULONG ulUnicodeStringLength, LPSTR* ppszAnsiString);
HRESULT FormatTimeDuration(UINT uSeconds, LPTSTR pszTimeDuration, SIZE_T uTimeDurationLength);
HRESULT FormatBytesPerSecond(UINT uBytesPerSecond, LPTSTR pszBytesPerSecond, SIZE_T uBytesPerSecondLength);
HRESULT GetConnectionStatus(IUPnPService* pWANConnection, NETCON_STATUS* pStatus);
HRESULT ConnectionStatusToString(NETCON_STATUS Status, LPTSTR szBuffer, int nBufferSize);
HRESULT EnsureFileVersion(LPTSTR pszModule, UINT64 qwDesiredVersion);

LRESULT ShowErrorDialog(HWND hParentWindow, UINT uiErrorString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\api.h ===
#pragma once

#include "InternetGatewayDevice.h"
#include "beacon.h" // public apis

HRESULT AdviseNATEvents(INATEventsSink* pNATEventsSink);
HRESULT UnadviseNATEvents(INATEventsSink* pNATEventsSink);
HRESULT FireNATEvent_PublicIPAddressChanged(void);
HRESULT FireNATEvent_PortMappingsChanged(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\beaconbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S D E V B A S E . H 
//
//  Contents:   Base include file for sdev.dll. Global defines.
//
//  Notes:      
//
//  Author:     mbend   25 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//#include "ncatl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cinternetgatewaydevice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . C P P 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "CInternetGatewayDevice.h"
#include "COSInfoService.h"
#include "CWANCommonInterfaceConfigService.h"
#include "CWANIPConnectionService.h"
#include "CWANPOTSLinkConfigService.h"


CInternetGatewayDevice::CInternetGatewayDevice()
{
    m_pOSInfoService = NULL;
    m_pWANCommonInterfaceConfigService = NULL;
}

HRESULT CInternetGatewayDevice::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    hr = CComObject<COSInfoService>::CreateInstance(&m_pOSInfoService);
    if(SUCCEEDED(hr))
    {
        m_pOSInfoService->AddRef();
    }
    
    if(SUCCEEDED(hr))
    {
        hr = CComObject<CWANCommonInterfaceConfigService>::CreateInstance(&m_pWANCommonInterfaceConfigService);
        if(SUCCEEDED(hr))
        {
            m_pWANCommonInterfaceConfigService->AddRef();
        }
    }
    return hr;

}

HRESULT CInternetGatewayDevice::FinalRelease()
{
    HRESULT hr = S_OK;
    
    if(NULL != m_pOSInfoService)
    {
        m_pOSInfoService->Release();
    }

    if(NULL != m_pWANCommonInterfaceConfigService)
    {
        m_pWANCommonInterfaceConfigService->Release();
    }

    return S_OK;
}


STDMETHODIMP CInternetGatewayDevice::Initialize(BSTR bstrXMLDesc, BSTR bstrDeviceIdentifier, BSTR bstrInitString)
{
    HRESULT hr = S_OK;

    IUPnPRegistrar* pRegistrar;
    hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
    if(SUCCEEDED(hr))
    {
        BSTR bstrUDN = NULL;
        BSTR bstrTemplateUDN = SysAllocString(L"DummyUDN");
        if(!bstrTemplateUDN)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            hr = pRegistrar->GetUniqueDeviceName(bstrDeviceIdentifier, bstrTemplateUDN, &bstrUDN);
            if(SUCCEEDED(hr))
            {
                SysFreeString(bstrUDN);
            }
            SysFreeString(bstrTemplateUDN);
        }
        pRegistrar->Release();
    }
    return hr;
}

STDMETHODIMP CInternetGatewayDevice::GetServiceObject(BSTR bstrUDN, BSTR bstrServiceId,IDispatch** ppdispService)
{
    HRESULT hr = E_NOINTERFACE;

    *ppdispService = NULL;

    if(0 == lstrcmp(bstrServiceId, L"urn:microsoft-com:serviceId:OSInfo1"))
    {
        hr = m_pOSInfoService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANCommonIFC1"))
    {
        hr = m_pWANCommonInterfaceConfigService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANPOTSLinkC1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANPOTSLinkConfigService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANPOTSLinkConfigService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANPPPConn1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANPPPConnectionService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANPPPConnectionService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANIPConn1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANIPConnectionService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANIPConnectionService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cinternetgatewaydevice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"

#include "COSInfoService.h"
#include "CWANCommonInterfaceConfigService.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CInternetGatewayDevice : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUPnPDeviceControl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CInternetGatewayDevice)
    COM_INTERFACE_ENTRY(IUPnPDeviceControl)
END_COM_MAP()

public:

    CInternetGatewayDevice();

    // IUPnPDeviceControl methods
    STDMETHOD(Initialize)(
       /*[in]*/ BSTR     bstrXMLDesc,
       /*[in]*/ BSTR     bstrDeviceIdentifier,
       /*[in]*/ BSTR     bstrInitString);
    STDMETHOD(GetServiceObject)(
       /*[in]*/          BSTR     bstrUDN,
       /*[in]*/          BSTR     bstrServiceId,
       /*[out, retval]*/ IDispatch ** ppdispService);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

    CComObject<COSInfoService>* m_pOSInfoService;
    CComObject<CWANCommonInterfaceConfigService>* m_pWANCommonInterfaceConfigService;

private:


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\api.cpp ===
#include "pch.h"
#pragma hdrstop
#include "api.h"
#include "upnphost.h"
#include "CInternetGatewayDevice.h"
#include "beaconrc.h"

HRESULT BeaconEnabled(void);

static const WCHAR c_szSharedAccessClientKeyPath[] = L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection";
static BSTR g_DeviceId = NULL;
static BOOL g_bStarted = FALSE;
static INATEventsSink* g_pNATEventsSink;

CRITICAL_SECTION g_RegistrationProtection;
CRITICAL_SECTION g_NATEventsProtection;

HRESULT GetXMLPath(BSTR* pPath)
{
    HRESULT hr = S_OK;

    *pPath = NULL;

    WCHAR szXMLDirectory[] = L"ICSXML";
    WCHAR szSystemDirectory[MAX_PATH + 1 + (sizeof(szXMLDirectory) / sizeof(WCHAR))];
    UINT uiSize = GetSystemDirectory(szSystemDirectory, MAX_PATH);
    if(0 != uiSize)
    {
        if(L'\\' != szSystemDirectory[uiSize])
        {
            szSystemDirectory[uiSize] = L'\\';
            uiSize++;
        }
        
        lstrcpy(&szSystemDirectory[uiSize], szXMLDirectory);
        *pPath = SysAllocString(szSystemDirectory);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT GetDescriptionDocument(INT nResource, BSTR* pDocument)
{
    HRESULT hr = E_FAIL;
    
    *pDocument = NULL;

    HRSRC hrsrc = FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(nResource), L"XML"); // REVIEW change this from 1
    if(hrsrc)
    {
        HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hrsrc);
        if(hGlobal)
        {
            void* pvData = LockResource(hGlobal);
            if(pvData)
            {
                long nLength = SizeofResource(_Module.GetResourceInstance(), hrsrc);
                WCHAR * sz = new WCHAR[nLength + 1];
                if(NULL != sz)
                {
                    if(0 != MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinterpret_cast<char*>(pvData), nLength, sz, nLength))
                    {
                        sz[nLength] = 0;
                        *pDocument = SysAllocString(sz);
                        if(NULL != *pDocument)
                        {
                            hr = S_OK;
                        }
                    }
                    delete [] sz;
                }
            }
            FreeResource(hGlobal);
        }
    }
    return hr;

}

HRESULT WINAPI InitializeBeaconSvr()
{
    __try 
    {
        InitializeCriticalSection(&g_RegistrationProtection);
        InitializeCriticalSection(&g_NATEventsProtection);
    } __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT WINAPI TerminateBeaconSvr()
{
    DeleteCriticalSection(&g_RegistrationProtection);
    DeleteCriticalSection(&g_NATEventsProtection);
    return S_OK;
}

HRESULT WINAPI StartBeaconSvr(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_RegistrationProtection);
    
    g_bStarted = TRUE;  

    if(NULL == g_DeviceId)
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
        if(SUCCEEDED(hr))
        {
            hr = BeaconEnabled();
            if(SUCCEEDED(hr))
            {
                IUPnPRegistrar* pRegistrar;
                hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
                if(SUCCEEDED(hr))
                {
                    
                    CComObject<CInternetGatewayDevice>* pGatewayDevice;
                    hr = CComObject<CInternetGatewayDevice>::CreateInstance(&pGatewayDevice);
                    if(SUCCEEDED(hr))
                    {
                        pGatewayDevice->AddRef();
                        
                        BSTR bstrData;
                        hr = GetDescriptionDocument(NCM_LAN == pGatewayDevice->m_pWANCommonInterfaceConfigService->m_MediaType ? IDXML_LAN : IDXML_RAS, &bstrData);
                        if(SUCCEEDED(hr))
                        {
                            BSTR bstrInitString = SysAllocString(L"Init");
                            if(NULL != bstrInitString)
                            {
                                BSTR pPath;
                                hr = GetXMLPath(&pPath);
                                if(SUCCEEDED(hr))
                                {
                                    hr = pRegistrar->RegisterRunningDevice(bstrData, static_cast<IUPnPDeviceControl*>(pGatewayDevice), bstrInitString, pPath, 1800, &g_DeviceId);
                                    
                                    SysFreeString(pPath);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                SysFreeString(bstrInitString);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            SysFreeString(bstrData);
                        }
                        pGatewayDevice->Release();
                    }
                    pRegistrar->Release();
                }
            }
            CoUninitialize();
        }
    }

    LeaveCriticalSection(&g_RegistrationProtection);

    return hr;
}

HRESULT WINAPI SignalBeaconSvr(void)
{
    HRESULT hr = S_OK;

    // go ahead and dump the whole object since the services need for the client are different.  
    
    if(TRUE == g_bStarted)
    {
        hr = StopBeaconSvr();
        if(SUCCEEDED(hr))
        {
            hr = StartBeaconSvr();
        }
    }
    return hr;
}

HRESULT WINAPI StopBeaconSvr(void)
{
    HRESULT hr = S_OK;
    IUPnPRegistrar* pRegistrar;


    EnterCriticalSection(&g_RegistrationProtection);

    if(NULL != g_DeviceId)
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
        if(SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
            if(SUCCEEDED(hr))
            {
                hr = pRegistrar->UnregisterDevice(g_DeviceId, TRUE);
                pRegistrar->Release();
            }
            SysFreeString(g_DeviceId);
            
            g_DeviceId = NULL;

            CoUninitialize();
        }

    }
    
    g_bStarted = FALSE;
    
    LeaveCriticalSection(&g_RegistrationProtection);

    return hr;
}

HRESULT BeaconEnabled(void)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_QUERY_VALUE, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, L"DisableBeacon", NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &dwSize))
        {
            if(REG_DWORD == dwType && 0 != dwValue) 
            {
                hr = E_FAIL;
            }
        }
        RegCloseKey(hKey);
    }

    return hr;
}


// This function must be called on an MTA thread          
HRESULT AdviseNATEvents(INATEventsSink* pNATEventsSink)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    if(NULL == g_pNATEventsSink)
    {
        g_pNATEventsSink = pNATEventsSink;
        g_pNATEventsSink->AddRef();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    LeaveCriticalSection(&g_NATEventsProtection);
    

    return hr;
}

// This function must be called on an MTA thread          
HRESULT UnadviseNATEvents(INATEventsSink* pNatEventsSink)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    if(NULL != g_pNATEventsSink)
    {
        g_pNATEventsSink->Release();
        g_pNATEventsSink = NULL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    LeaveCriticalSection(&g_NATEventsProtection);
    
    return hr;
}

HRESULT WINAPI FireNATEvent_PublicIPAddressChanged(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
    if(SUCCEEDED(hr))
    {
        if(NULL != g_pNATEventsSink)
        {
            g_pNATEventsSink->PublicIPAddressChanged();
        }
        CoUninitialize();
    }

    LeaveCriticalSection(&g_NATEventsProtection);

    return hr;
}

HRESULT WINAPI FireNATEvent_PortMappingsChanged(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
    if(SUCCEEDED(hr))
    {
        if(NULL != g_pNATEventsSink)
        {
            g_pNATEventsSink->PortMappingsChanged();
        }
        CoUninitialize();
    }

    LeaveCriticalSection(&g_NATEventsProtection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatdynamicportmappingservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "CNATDynamicPortMappingService.h"


CNATDynamicPortMappingService::CNATDynamicPortMappingService()
{
    m_pEventSink = NULL;
    m_pHNetConnection = NULL;
}

HRESULT CNATDynamicPortMappingService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT CNATDynamicPortMappingService::Initialize(IHNetConnection* pHNetConnection)
{
    HRESULT hr = S_OK;

    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
    
    return hr;
}


HRESULT CNATDynamicPortMappingService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATDynamicPortMappingService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPublicIP(BSTR* pDynamicPublicIP)
{
    *pDynamicPublicIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPort(ULONG* pulDynamicPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicProtocol(BSTR* pDynamicProtocol)
{
    *pDynamicProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPrivateIP(BSTR* pDynamicPrivateIP)
{
    *pDynamicPrivateIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicLeaseDuration(ULONG* pulDynamicLeaseDuration)
{
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::CreateDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, BSTR DynamicPrivateIP, BSTR DynamicLeaseDuration)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::DeleteDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::ExtendDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, ULONG ulDynamicLeaseDuration)
{
    HRESULT hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatdynamicportmappingservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATDynamicPortMappingService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATDynamicPortMappingService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATDynamicPortMappingService)
    COM_INTERFACE_ENTRY(INATDynamicPortMappingService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATDynamicPortMappingService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATDynamicPortMappingService
    STDMETHODIMP get_DynamicPublicIP(BSTR* pDynamicPublicIP);
    STDMETHODIMP get_DynamicPort(ULONG* pulDynamicPort);
    STDMETHODIMP get_DynamicProtocol(BSTR* pDynamicProtocol);
    STDMETHODIMP get_DynamicPrivateIP(BSTR* pDynamicPrivateIP);
    STDMETHODIMP get_DynamicLeaseDuration(ULONG* pulDynamicLeaseDuration);
    STDMETHODIMP CreateDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, BSTR DynamicPrivateIP, BSTR DynamicLeaseDuration);
    STDMETHODIMP DeleteDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol);
    STDMETHODIMP ExtendDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, ULONG ulDynamicLeaseDuration);


    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatstaticportmappingservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File      : CNATStaticPortMappingService.cpp
//
//  Contents  : CNATStaticPortMappingService implementation
//
//  Notes     :
//
//  Author    : savasg  28 February 2001
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "CNATStaticPortMappingService.h"

#include "ipnat.h"
#include "winsock2.h"
#include "debug.h"




//
// GLOBALS
//
IHNetIcsSettings*               g_IcsSettingsp = NULL;



HRESULT
SeekPortMapping(
                IN OPTIONAL LPOLESTR                    searchNamep,
                IN OPTIONAL USHORT                      searchPort,
                OUT         IHNetPortMappingProtocol    **Protocolpp
               )
//
// Seeks and retrieves a MappingProtocol by Name or Port
//
{
    HRESULT                         hr                    = S_OK;

    IHNetProtocolSettings*          ProtocolSettingsp     = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp        = NULL;

    IHNetPortMappingProtocol*       Protocolp             = NULL;

    LPOLESTR                        ProtocolNamep         = NULL;

    USHORT                          ProtocolPort          = 0;

    BOOLEAN                         bFound                = FALSE;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SeekPortMapping \n");

    do
    {
        hr = g_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Query Interface failed for ProtocolSettingsp e:%X", hr);

            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Enum Interface can't be retrieved \n");

            break;
        }

        while(
              (FALSE == bFound) &&
              (S_OK == EnumProtocolsp->Next(1, &Protocolp, NULL))
             )
        {
            hr = Protocolp->GetName(&ProtocolNamep);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"problemo name\n");
            } 
  

            hr = Protocolp->GetPort(&ProtocolPort);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L" problemo ");

                break;
            }

            if(searchNamep && 
               !( wcscmp(ProtocolNamep, searchNamep) )
              )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"The Name is hit %S\n", searchNamep);

                bFound = TRUE;    
            }

            if(searchPort &&
               (searchPort == ProtocolPort))
            {       
                bFound = TRUE;
            }

            CoTaskMemFree(ProtocolNamep);

            ProtocolNamep = NULL;
            
            if (FALSE == bFound) Protocolp->Release();
        }

        EnumProtocolsp->Release();

    } while ( FALSE );

    if(ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    if(Protocolpp && (bFound == TRUE) )
    {
        *Protocolpp = Protocolp;
    }

    return hr;
}

HRESULT
DeleteMappingByName(LPOLESTR ProtocolNamep)
{
    HRESULT                  hr         = S_OK;

    IHNetPortMappingProtocol* Protocolp = NULL;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > DeleteMappingByName \n");

    do
    {
        if(ProtocolNamep == NULL)
        {
            break;
        }
        
        hr = SeekPortMapping(ProtocolNamep,
                             0,
                             &Protocolp);
        if( FAILED(hr) || 
            (Protocolp == NULL))
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"No Such Protocol %S: %X", ProtocolNamep, hr);

            break;
        }

        DBG_SPEW(TM_STATIC, TL_ERROR, L"DELETING\n");

        hr = Protocolp->Delete();

        Protocolp->Release();

    } while ( FALSE );

    return hr;
}





CNATStaticPortMappingService::CNATStaticPortMappingService()
{
    m_pEventSink = NULL;

    m_pHNetConnection = NULL;
}

HRESULT CNATStaticPortMappingService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATStaticPortMappingService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT 
CNATStaticPortMappingService::Initialize(IHNetConnection* pHNetConnection)
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT                         hr                          = S_OK;

    IHNetConnection*                HomenetConnectionp          = NULL;

    IEnumHNetIcsPublicConnections*  EnumIcsPublicConnectionsp   = NULL;

    IHNetIcsPublicConnection*       PublicConnectionp           = NULL;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > Initialize \n");

    do 
    {
        hr = CoCreateInstance(CLSID_HNetCfgMgr,
                              NULL,
                              CLSCTX_SERVER,
                              IID_IHNetIcsSettings,
                              reinterpret_cast<void**>(&g_IcsSettingsp));

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" CoCreateInstance for IID_IHNetIcsSettings failed \n");

            break; 
        }
    
        //
        // Get the Enumeration Interface
        //
        hr = g_IcsSettingsp->EnumIcsPublicConnections(&EnumIcsPublicConnectionsp);
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Getting Interface for Enumeration of Public Connections has failed \n");

            break;
        }
    
        //
        // Find the Interface .. for now there is only one Public Interface
        // This is not the RRAS case
        //
        hr = EnumIcsPublicConnectionsp->Next(1,
                                             &PublicConnectionp,
                                             NULL);
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no Public Connection.. how come?\n");

            break;
        }


        hr = PublicConnectionp->QueryInterface(IID_IHNetConnection,
                                   reinterpret_cast<void**>(&HomenetConnectionp));

        _ASSERT( SUCCEEDED(hr) );

        if( FAILED(hr) )
        {
            EnumIcsPublicConnectionsp->Release();

            PublicConnectionp->Release();

            DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Get the IID_IHNetConnection Interface from the Public Connection\n");

            break;
        }
    
    } while( FALSE );
    
    //
    // Release the Ref counts
    //
    if(PublicConnectionp != NULL)
    {
        PublicConnectionp->Release();
    }

    if(EnumIcsPublicConnectionsp != NULL)
    {
        EnumIcsPublicConnectionsp->Release();
    }
    
    m_pHNetConnection = HomenetConnectionp;

/* Instead of Using the existing
    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
*/
    return hr;
}


HRESULT CNATStaticPortMappingService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;

    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATStaticPortMappingService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();

    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATStaticPortMappingService::get_StaticPortDescriptionList(BSTR* pStaticPortDescriptionList)
{
    HRESULT hr = S_OK;
    
    *pStaticPortDescriptionList = NULL;
    
    typedef struct tagNameEnablePair
    {
        LIST_ENTRY LinkField;
        LPOLESTR pName;
        ULONG ulNameSize;
        BOOLEAN bEnabled;
    } NameEnablePair;
    
    LIST_ENTRY PairList;
    InitializeListHead(&PairList);
    
    // First construct a linklist of NameEnablePairs with the info needed
    
    IEnumHNetPortMappingBindings *pBindingEnum = NULL;
    hr = m_pHNetConnection->EnumPortMappings(FALSE, &pBindingEnum);
    if(SUCCEEDED(hr))
    {
        IHNetPortMappingBinding* pBinding;
        while(S_OK == pBindingEnum->Next(1, &pBinding, NULL))
        {
            BOOLEAN bEnabled;
            
            hr = pBinding->GetEnabled(&bEnabled);
            if(SUCCEEDED(hr))
            {
                IHNetPortMappingProtocol* pProtocol;
                hr = pBinding->GetProtocol(&pProtocol);
                if(SUCCEEDED(hr))
                {
                    LPOLESTR pName;
                    hr = pProtocol->GetName(&pName);
                    if(SUCCEEDED(hr))
                    {
                        NameEnablePair* pPair = new NameEnablePair;
                        if(NULL != pPair)
                        {
                            pPair->pName = pName;
                            pPair->bEnabled = bEnabled;
                            
                            InsertTailList(&PairList, &pPair->LinkField);
                        }
                        //CoTaskMemFree(pName);
                    }
                    pProtocol->Release();
                }
            }
            pBinding->Release();
        }
        pBindingEnum->Release();
    }
    

    LIST_ENTRY* pCount;
    NameEnablePair* pContainingPair;

    if(SUCCEEDED(hr))
    {
        // Count the space needed in the return string
    
        unsigned int uSizeNeeded = 0;
        pCount = PairList.Flink;
        while(&PairList != pCount)
        {
            pContainingPair = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
            pContainingPair->ulNameSize = lstrlen(pContainingPair->pName);
            uSizeNeeded += 3 + pContainingPair->ulNameSize;  //Name:1,
            pCount = pCount->Flink;
        }

        BSTR pReturnString;
        if(0 != uSizeNeeded)
        {
            pReturnString = SysAllocStringLen(NULL, uSizeNeeded);
        }
        else
        {
            pReturnString = SysAllocString(L"");
        }
        
        if(NULL != pReturnString)
        {
            *pStaticPortDescriptionList = pReturnString;
            
            // Fill in the string
            pCount = PairList.Flink;
            while(&PairList != pCount)
            {
                pContainingPair = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
                
                
                lstrcpy(pReturnString, pContainingPair->pName);
                pReturnString += pContainingPair->ulNameSize;
                
                *pReturnString = L':';
                pReturnString++;
                
                *pReturnString = pContainingPair->bEnabled ? L'1' : L'0';
                pReturnString++;
                
                *pReturnString = (&PairList == pCount->Flink) ? L'\0' : L',';
                pReturnString++;
                
                pCount = pCount->Flink;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
            
    }

    // Clean up the linked list
    pCount = PairList.Flink;
    while(&PairList != pCount)
    {
        NameEnablePair* pDelete = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
        pCount = pCount->Flink;
        CoTaskMemFree(pDelete->pName);
        delete pDelete;
    }

    return hr;
}

HRESULT CNATStaticPortMappingService::get_StaticPort(ULONG* pulStaticPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortProtocol(BSTR* pStaticPortProtocol)
{
    *pStaticPortProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortClient(BSTR* pStaticPortClient)
{
    *pStaticPortClient = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortEnable(VARIANT_BOOL* pbStaticPortEnable)
{
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortDescription(BSTR* pStaticPortDescription)
{
    *pStaticPortDescription = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::GetStaticPortMappingList(BSTR* pStaticPortMappingList)
{
    HRESULT hr = S_OK;
    
    SysFreeString(*pStaticPortMappingList);

    *pStaticPortMappingList = NULL;

    hr = get_StaticPortDescriptionList(pStaticPortMappingList);
    
    return hr;
}

HRESULT 
CNATStaticPortMappingService::GetStaticPortMapping(
                                                   BSTR StaticPortMappingDescription,
                                                   ULONG* pulStaticPort,
                                                   BSTR* pStaticPortClient,
                                                   BSTR* pStaticPortProtocol
                                                  )
/*++

Routine Description:

     Retrieves the Port, Client Name/Address and the Protocol for a given 
     Mapping (redirect in NAT context)... Note that a Binding may not exist 
     for a Mapping.. Thus There might not be a Client Name/Address.

Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT                   hr            = S_OK;

    IHNetPortMappingProtocol* Protocolp     = NULL;

    IHNetPortMappingBinding*  Bindingp      = NULL;

    LPOLESTR                  ClientNamep   = NULL;

    ULONG                     ClientAddress = 0;

    USHORT                    ProtocolPort  = 0;

    UCHAR                     ProtocolType  = 0;


    
    DBG_SPEW(TM_STATIC, TL_ERROR, L" > GetStaticPortMapping");

    _ASSERT( StaticPortMappingDescription != NULL );
    _ASSERT( pulStaticPort                != NULL );
    _ASSERT( pStaticPortClient            != NULL );
    _ASSERT( pStaticPortProtocol          != NULL );
    
    SysFreeString(*pStaticPortClient);

    SysFreeString(*pStaticPortProtocol);

    *pStaticPortClient = NULL;

    *pStaticPortProtocol = NULL;

    do
    {
        hr = SeekPortMapping((LPOLESTR)StaticPortMappingDescription,
                             0,
                             &Protocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no such Port Mapping");

            break;
        }

        hr = Protocolp->GetPort(&ProtocolPort); //USHORT

        _ASSERT( SUCCEEDED(hr) );

        *pulStaticPort = ProtocolPort;
        
        //
        // Get the Type of the Protocol Mapping and put the appropriate
        // String
        //
        hr = Protocolp->GetIPProtocol(&ProtocolType); //UCHAR

        _ASSERT( SUCCEEDED(hr) );

        if ( ProtocolType == NAT_PROTOCOL_TCP )
        {
            *pStaticPortProtocol = SysAllocString(L"TCP");
        }
        else if ( ProtocolType == NAT_PROTOCOL_UDP )
        {
            *pStaticPortProtocol = SysAllocString(L"UDP");
        } 
        else
        {
            _ASSERT( FALSE );
        }

        
        //
        // A Binding may not exist.. That's Ok..
        //
        hr = m_pHNetConnection->GetBindingForPortMappingProtocol(Protocolp, &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" No Such Binding for that protocol.");

            hr = S_OK;

            break;
        }

        //
        // If the Address exist just process that.
        // Convert the Name to a OLESTR
        //
        hr = Bindingp->GetTargetComputerAddress(&ClientAddress);

        if ( SUCCEEDED(hr) )
        {
            ClientNamep = (LPOLESTR) CoTaskMemAlloc( (wcslen(INET_NTOW(ClientAddress)) + 1) * sizeof(WCHAR) );

            _ASSERT(ClientNamep != NULL);

            wcscpy( ClientNamep, INET_NTOW(ClientAddress) );
        }
        else
        {
            hr = Bindingp->GetTargetComputerName(&ClientNamep);
        }

        if( FAILED( hr ) || (ClientNamep == NULL))
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Retrieve Name or Address of Client from Binding ");

            break;
        }

        *pStaticPortClient = SysAllocString( ClientNamep );  

        if (*pStaticPortClient == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

    } while ( FALSE );

    if ( ClientNamep != NULL)
    {
        CoTaskMemFree( ClientNamep );
    }

    if ( Bindingp != NULL)
    {
        Bindingp->Release();
    }

    if ( Protocolp != NULL )
    {
        Protocolp->Release();
    }

    //
    // If there was a failure then clear up the allocated Strings
    //
    if ( FAILED(hr) && ( *pStaticPortProtocol != NULL ) )
    {
         SysFreeString( *pStaticPortProtocol );

         *pStaticPortProtocol = NULL;
    }

    return hr;
}

HRESULT 
CNATStaticPortMappingService::SetStaticPortMappingEnabled(
                                                          BSTR StaticPortMappingDescription, 
                                                          VARIANT_BOOL bStaticPortEnable
                                                         )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    IHNetPortMappingProtocol* Protocolp = NULL;

    IHNetPortMappingBinding*  Bindingp  = NULL;

    
    
    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SetStaticPortMappingEnabled");

    do
    {
        hr = SeekPortMapping((LPOLESTR)StaticPortMappingDescription,
                             NULL,
                             &Protocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no such Port Mapping");

            break;
        }
        
        hr = m_pHNetConnection->GetBindingForPortMappingProtocol(Protocolp, &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" No Such Binding for that protocol.");

            break;
        }

        if ( VARIANT_TRUE == bStaticPortEnable )
        {
            hr = Bindingp->SetEnabled(TRUE);
        }
        else if ( VARIANT_FALSE == bStaticPortEnable )
        {
            hr = Bindingp->SetEnabled(FALSE);
        }

        _ASSERT( SUCCEEDED(hr) );

    } while ( FALSE );

    if (Protocolp != NULL)
    {
        Protocolp->Release();
    }
    
    if (Bindingp != NULL)
    {
        Bindingp->Release();
    }

    return hr;
}

HRESULT 
CNATStaticPortMappingService::CreateStaticPortMapping(
                                                      BSTR  StaticPortMappingDescription, 
                                                      ULONG ulStaticPort, 
                                                      BSTR  StaticPortClient, 
                                                      BSTR  StaticPortProtocol
                                                     )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

{
    HRESULT                      hr                    = S_OK;

    UCHAR                        ProtocolType          = 0;

    IHNetProtocolSettings*       ProtocolSettingsp     = NULL;

    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;

    IHNetPortMappingBinding*     PortMappingBindingp   = NULL;

    ULONG                        ClientAddr            = 0;


    ASSERT( StaticPortMappingDescription != NULL );
    ASSERT( ulStaticPort == 0 );
    // ASSERT( StaticPortClient != NULL );
    ASSERT( StaticPortProtocol );

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > CreateStaticPortMapping");

    //
    // Check and transform the Protocol Value to its correct type.
    //
    if( wcscmp(StaticPortProtocol, L"TCP") == 0)
    {
        ProtocolType = NAT_PROTOCOL_TCP;
    } 
    else if ( wcscmp(StaticPortProtocol, L"UDP") == 0)
    {
        ProtocolType = NAT_PROTOCOL_UDP;
    }
    else
    {
        DBG_SPEW(TM_STATIC, TL_ERROR, L"Unknown Protocol Type\n");

        _ASSERT(FALSE);

        return E_INVALIDARG;
    }

    do
    {
        hr = g_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));

        _ASSERT( SUCCEEDED(hr) );
    
        if( FAILED(hr) )
        {
            break;
        }


        hr = ProtocolSettingsp->CreatePortMappingProtocol((LPOLESTR)StaticPortMappingDescription,
                                                          ProtocolType,
                                                          (USHORT)ulStaticPort,
                                                          &PortMappingProtocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Creating the PortMapping has failed");

            break;
        }

        //
        // If there is no 
        //
        if ( StaticPortClient != NULL )
        {
            hr = m_pHNetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                     &PortMappingBindingp);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L" GetBinding  for PORT Mapping has failed ");

                break;
            }

            //
            // Decide wether the given address is a Name or an valid IP address
            // ient_addrw will return an INADDR_NONE if the address is not 
            // decimal doted IP address
            //
            ClientAddr = INET_ADDR((LPOLESTR)StaticPortClient);

            if( ClientAddr == INADDR_NONE)
            {
                hr = PortMappingBindingp->SetTargetComputerName(StaticPortClient);

                _ASSERT( SUCCEEDED(hr) );
            }
            else
            {
                hr = PortMappingBindingp->SetTargetComputerAddress(ClientAddr);

                _ASSERT( SUCCEEDED(hr) );
            }

            //
            // It creates it enabled
            //
            hr = PortMappingBindingp->SetEnabled(TRUE);
        }
    } while (FALSE);

    if( PortMappingProtocolp != NULL)
    {
        PortMappingProtocolp->Release();
    }

    if( ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    return hr;
}

HRESULT
CNATStaticPortMappingService::DeleteStaticPortMapping(BSTR StaticPortMappingDescription)
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    DBG_SPEW(TM_STATIC, TL_ERROR, L"> DeleteStaticPortMapping");    

    _ASSERT( StaticPortMappingDescription != NULL );

    hr = DeleteMappingByName( (LPOLESTR) StaticPortMappingDescription );

    return hr;
}

HRESULT 
CNATStaticPortMappingService::SetStaticPortMapping(
                                                   BSTR StaticPortMappingDescription,
                                                   ULONG ulStaticPort, 
                                                   BSTR StaticPortClient, 
                                                   BSTR StaticPortProtocol
                                                  )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    hr = DeleteMappingByName((LPOLESTR) StaticPortMappingDescription);

    if ( SUCCEEDED(hr) )
    {
        hr = this->CreateStaticPortMapping(StaticPortMappingDescription,
                                           ulStaticPort, 
                                           StaticPortClient, 
                                           StaticPortProtocol);

        _ASSERT( SUCCEEDED(hr) );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatinfoservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATInfoService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATInfoService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATInfoService)
    COM_INTERFACE_ENTRY(INATInfoService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATInfoService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATInfoService
    STDMETHODIMP get_IPList(BSTR* pIPList);
    STDMETHODIMP get_PublicIP(BSTR* pPublicIP);
    STDMETHODIMP get_Port(ULONG* pulPort);
    STDMETHODIMP get_Protocol(BSTR* pProtocol);
    STDMETHODIMP get_PrivateIP(BSTR* pPrivateIP);
    STDMETHODIMP GetPublicIPList(BSTR* pIPList);
    STDMETHODIMP GetPortMappingPrivateIP(BSTR PublicIP, ULONG ulPort, BSTR Protocol, BSTR* pPrivateIP);
    STDMETHODIMP GetPortMappingPublicIP(BSTR PrivateIP, ULONG ulPort, BSTR Protocol, BSTR* pPublicIP);

    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatstaticportmappingservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATStaticPortMappingService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATStaticPortMappingService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATStaticPortMappingService)
    COM_INTERFACE_ENTRY(INATStaticPortMappingService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATStaticPortMappingService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATStaticPortMappingService
    STDMETHODIMP get_StaticPortDescriptionList(BSTR* pStaticPortDescriptionList);
    STDMETHODIMP get_StaticPort(ULONG* pulStaticPort);
    STDMETHODIMP get_StaticPortProtocol(BSTR* pStaticPortProtocol);
    STDMETHODIMP get_StaticPortClient(BSTR* pStaticPortClient);
    STDMETHODIMP get_StaticPortEnable(VARIANT_BOOL* pbStaticPortEnable);
    STDMETHODIMP get_StaticPortDescription(BSTR* pStaticPortDescription);
    STDMETHODIMP GetStaticPortMappingList(BSTR* pStaticPortMappingList);
    STDMETHODIMP GetStaticPortMapping(BSTR StaticPortMappingDescription, ULONG* pulStaticPort, BSTR* pStaticPortClient, BSTR* pStaticPortProtocol);
    STDMETHODIMP SetStaticPortMappingEnabled(BSTR StaticPortMappingDescription, VARIANT_BOOL bStaticPortEnable);
    STDMETHODIMP CreateStaticPortMapping(BSTR StaticPortMappingDescription, ULONG ulStaticPort, BSTR StaticPortClient, BSTR StaticPortProtocol);
    STDMETHODIMP DeleteStaticPortMapping(BSTR StaticPortMappingDescription);
    STDMETHODIMP SetStaticPortMapping(BSTR StaticPortMappingDescription, ULONG ulStaticPort, BSTR StaticPortClient, BSTR StaticPortProtocol);

    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cosinfoservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "COSInfoService.h"

COSInfoService::COSInfoService()
{
    m_MachineName = NULL;
    m_pEventSink = NULL;
}

HRESULT COSInfoService::FinalConstruct()
{
    HRESULT hr = S_OK;
    m_OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (0 == GetVersionEx(reinterpret_cast<LPOSVERSIONINFO>(&m_OSVersionInfo)))
    {
        hr = E_FAIL;
    }
    
    if(SUCCEEDED(hr))
    {
        TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = sizeof(szMachineName) / sizeof(TCHAR); // REVIEW: extend for DNS names?
        if(0 != GetComputerName(szMachineName, &dwSize))
        {
            m_MachineName = SysAllocString(szMachineName);
            if(NULL == m_MachineName)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT COSInfoService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_MachineName)
    {
        SysFreeString(m_MachineName);
    }

    return hr;
}

// IUPnPEventSource methods

STDMETHODIMP COSInfoService::Advise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    if(NULL == m_pEventSink)
    {
        m_pEventSink = pesSubscriber;
        m_pEventSink->AddRef();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP COSInfoService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

// Functions for IOSInfoService 

STDMETHODIMP COSInfoService::get_OSMajorVersion(LONG* pOSMajorVersion)
{
    HRESULT hr = S_OK;

    *pOSMajorVersion = m_OSVersionInfo.dwMajorVersion;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSMinorVersion(LONG* pOSMinorVersion)
{
    HRESULT hr = S_OK;

    *pOSMinorVersion = m_OSVersionInfo.dwMinorVersion;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSBuildNumber(LONG* pOSBuildNumber)
{
    HRESULT hr = S_OK;

    *pOSBuildNumber = m_OSVersionInfo.dwBuildNumber;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSMachineName(BSTR* pMachineName)
{
    HRESULT hr = S_OK;

    *pMachineName = SysAllocString(m_MachineName);
    if(NULL == *pMachineName)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP COSInfoService::MagicOn()
{
//    CHECK_POINTER(pbMagic);
//    TraceTag(ttidUPnPSampleDevice, "CInternetGatewayDevice::get_Magic");
    HRESULT hr = S_OK;

//    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CInternetGatewayDevice::get_Magic");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cnatinfoservice.cpp ===
#include "pch.h"
#pragma hdrstop


#include "precomp.h"

#include "CNATInfoService.h"

#include "pastif.h"


CNATInfoService::CNATInfoService()
{
    m_pEventSink = NULL;
    m_pHNetConnection = NULL;
}

HRESULT CNATInfoService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATInfoService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT CNATInfoService::Initialize(IHNetConnection* pHNetConnection)
{
    HRESULT hr = S_OK;

    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
    
    return hr;
}


HRESULT CNATInfoService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATInfoService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATInfoService::get_IPList(BSTR *pIPList)
{
    HRESULT hr = S_OK;

    *pIPList = SysAllocString(L"");
    if(NULL == *pIPList)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CNATInfoService::get_PublicIP(BSTR *pPublicIP)
{
    *pPublicIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_Port(ULONG* pPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_Protocol(BSTR* pProtocol)
{
    *pProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_PrivateIP(BSTR* pPrivateIP)
{
    *pPrivateIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::GetPublicIPList(BSTR* IPListp)
{
    HRESULT             hr           = S_OK;

    PPAST_INTERFACE     Interfacep   = NULL;
    
    PLIST_ENTRY         Linkp        = NULL;

    ULONG               AddressCount = 0;

    LPOLESTR            AddressListp = NULL;



    _ASSERT(IPListp != NULL);

    SysFreeString(*IPListp);

    *IPListp = NULL;


    EnterCriticalSection(&PastInterfaceLock);

    for(Linkp = PastInterfaceList.Flink;
        Linkp != &PastInterfaceList;
        Linkp = Linkp->Flink)
    {
        Interfacep = CONTAINING_RECORD(Linkp, PAST_INTERFACE, Link);

        if( NAT_IFC_BOUNDARY(Interfacep->Characteristics) )
        {
            //
            // Check for all IPs on the Boundary Interface(s)
            //
            for(ULONG i = 0;
                (i < Interfacep->BindingCount) &&
                (Interfacep->BindingArray[i].Address != INADDR_NONE) ;
                i++)
            {
                if( AddressCount > 0 )
                {
                    AddressListp = AppendAndAllocateWString(AddressListp, L",");
                }

                AddressListp = AppendAndAllocateWString(AddressListp, 
                                  INET_NTOW(Interfacep->BindingArray[i].Address));
                
                AddressCount++;
            }
        }
    }

    LeaveCriticalSection(&PastInterfaceLock);

    //
    // Allocate and construct the BSTR reply
    //
    if( AddressListp != NULL)
    {
        *IPListp = SysAllocString( AddressListp );

        if( *IPListp != NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CNATInfoService::GetPortMappingPrivateIP(
                                                 BSTR PublicIP,
                                                 ULONG ulPort,
                                                 BSTR Protocol,
                                                 BSTR* pPrivateIP
                                                )
{
    HRESULT hr = E_NOTIMPL;

    SysFreeString(*pPrivateIP);

    *pPrivateIP = NULL;

    return hr;
}

HRESULT CNATInfoService::GetPortMappingPublicIP(BSTR PrivateIP, ULONG ulPort, BSTR Protocol, BSTR* pPublicIP)
{
    HRESULT hr = E_NOTIMPL;

    SysFreeString(*pPublicIP);
    *pPublicIP = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cosinfoservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"

/////////////////////////////////////////////////////////////////////////////
// COSInfoService
class ATL_NO_VTABLE COSInfoService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<IOSInfoService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COSInfoService)
    COM_INTERFACE_ENTRY(IOSInfoService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

public:

    COSInfoService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);
        

    // IOSInfo methods
    STDMETHODIMP get_OSMajorVersion(LONG *pOSMajorVersion);
    STDMETHODIMP get_OSMinorVersion(LONG *pOSMinorVersion);
    STDMETHODIMP get_OSBuildNumber(LONG *pOSBuildNumber);
    STDMETHODIMP get_OSMachineName(BSTR* pOSMachineName);
    STDMETHODIMP MagicOn( void);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:

    IUPnPEventSink* m_pEventSink;
    VARIANT_BOOL m_vbMagic;

    OSVERSIONINFOEX m_OSVersionInfo;
    BSTR m_MachineName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwancommoninterfaceconfigservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"
#include "upnpp.h"

#include "CWANIPConnectionService.h"
#include "CWANPPPConnectionService.h"
#include "CWANPOTSLinkConfigService.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANCommonInterfaceConfigService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<ICommonInterfaceConfigService>,
    public IUPnPEventSource

{
public:
    CWANCommonInterfaceConfigService();

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWANCommonInterfaceConfigService)
    COM_INTERFACE_ENTRY(ICommonInterfaceConfigService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)

END_COM_MAP()

public:

    // IUPnPEventSource methods
    STDMETHOD(Advise)(
        /*[in]*/ IUPnPEventSink *pesSubscriber);
    STDMETHOD(Unadvise)(
        /*[in]*/ IUPnPEventSink *pesSubscriber);

    // ICommonInterfaceConfigService methods
    STDMETHODIMP get_WANAccessType(BSTR *pWANAccessType);
    STDMETHODIMP get_Layer1UpstreamMaxBitRate(ULONG *pLayer1UpstreamMaxBitRate);
    STDMETHODIMP get_Layer1DownstreamMaxBitRate(ULONG *pLayer1DownstreamMaxBitRate);
    STDMETHODIMP get_PhysicalLinkStatus(BSTR *pPhysicalLinkStatus);

    STDMETHODIMP get_TotalBytesSent(ULONG *pTotalBytesSent);
    STDMETHODIMP get_TotalBytesReceived(ULONG *pTotalBytesReceived);
    STDMETHODIMP get_TotalPacketsSent(ULONG *pTotalPacketsSent);
    STDMETHODIMP get_TotalPacketsReceived(ULONG *pTotalPacketsReceived);
    STDMETHODIMP get_WANAccessProvider(BSTR *pWANAccessProvider);
    STDMETHODIMP get_MaximumActiveConnections(USHORT *pMaximumActiveConnections);
    STDMETHODIMP get_X_PersonalFirewallEnabled(VARIANT_BOOL *pPersonalFirewallEnabled);
    STDMETHODIMP get_X_Uptime(ULONG* pUptime);
    STDMETHODIMP GetCommonLinkProperties(BSTR* pWANAccessType, ULONG* pLayer1UpstreamMaxBitRate, ULONG *pLayer1DownstreamMaxBitRate, BSTR *pPhysicalLinkStatus);
    STDMETHODIMP GetTotalBytesSent(ULONG *pTotalBytesSent);
    STDMETHODIMP GetTotalBytesReceived(ULONG *pTotalBytesReceived);
    STDMETHODIMP GetTotalPacketsSent(ULONG *pTotalPacketsSent);
    STDMETHODIMP GetTotalPacketsReceived(ULONG *pTotalPacketsReceived);
    STDMETHODIMP X_GetICSStatistics(ULONG *pTotalBytesSent, ULONG *pTotalBytesReceived, ULONG *pTotalPacketsSent, ULONG *pTotalPacketsReceived, ULONG *pSpeed, ULONG *pUptime);
    
    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

    CComObject<CWANIPConnectionService>* m_pWANIPConnectionService;
    CComObject<CWANPPPConnectionService>* m_pWANPPPConnectionService;
    CComObject<CWANPOTSLinkConfigService>* m_pWANPOTSLinkConfigService;

    NETCON_MEDIATYPE m_MediaType;

private:

    HRESULT GetConnections(IHNetConnection** ppPublicConnection, IHNetConnection** ppPrivateConnection);
    
    IUPnPEventSink* m_pEventSink;
    IUPnPDeviceHostICSSupport* m_pICSSupport;
    BOOL m_bFirewalled;
    IStatisticsProvider* m_pStatisticsProvider;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanipconnectionservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANIPConnectionService.h"
#include "ndispnp.h"
#include "ras.h"
#include "rasuip.h"
#include "util.h"

CWANIPConnectionService::CWANIPConnectionService()
{
}

HRESULT CWANIPConnectionService::get_LastConnectionError(BSTR *pLastConnectionError)
{
    HRESULT hr = S_OK;
    *pLastConnectionError = SysAllocString(L"ERROR_NONE");
    if(NULL == *pLastConnectionError)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANIPConnectionService::RequestConnection(void)
{
    HRESULT hr = S_OK;

    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Connect();
            pNetConnection->Release();
        } 
        
        if(FAILED(hr))
        {
            SetUPnPError(DCP_ERROR_CONNECTIONSETUPFAILED);
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    return hr;
}

HRESULT CWANIPConnectionService::ForceTermination(void)
{
    HRESULT hr = S_OK;


    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Disconnect();
            pNetConnection->Release();
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwancommoninterfaceconfigservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANCommonInterfaceConfigService.h"
#include "StatisticsProviders.h"

CWANCommonInterfaceConfigService::CWANCommonInterfaceConfigService()
{
    m_pEventSink = NULL;
    m_pWANIPConnectionService = NULL;
    m_pWANPPPConnectionService = NULL;
    m_pWANPOTSLinkConfigService = NULL;
    m_pICSSupport = NULL;
    m_bFirewalled = FALSE;
    m_pStatisticsProvider = NULL;
};

HRESULT CWANCommonInterfaceConfigService::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    IHNetConnection* pPublicConnection;
    IHNetConnection* pPrivateConnection;

    hr = GetConnections(&pPublicConnection, &pPrivateConnection);
    if(SUCCEEDED(hr))
    {
        GUID* pGuid;
        hr = pPublicConnection->GetGuid(&pGuid);
        if(SUCCEEDED(hr))
        {
            INetConnection* pNetConnection;
            hr = pPublicConnection->GetINetConnection(&pNetConnection);
            if(SUCCEEDED(hr))
            {
                NETCON_PROPERTIES* pProperties;
                hr = pNetConnection->GetProperties(&pProperties);
                if(SUCCEEDED(hr))
                {

                    // cache the firewall state, the beacon will be signaled (torn down and rebuilt) when the firewall status changes
                    
                    m_bFirewalled = (NCCF_FIREWALLED & pProperties->dwCharacter) == NCCF_FIREWALLED;
                    
                    m_MediaType = pProperties->MediaType;

                    if(NCM_LAN == m_MediaType)
                    {
                        CComObject<CLANStatisticsProvider>* pLANStatisticsProvider;
                        hr = CComObject<CLANStatisticsProvider>::CreateInstance(&pLANStatisticsProvider);
                        if(SUCCEEDED(hr))
                        {
                            pLANStatisticsProvider->AddRef();                                                                                

                            hr = pLANStatisticsProvider->Initialize(pGuid);
                            
                            // pass the reference
                            m_pStatisticsProvider = static_cast<IStatisticsProvider*>(pLANStatisticsProvider);
                        }
                            
                    }
                    else
                    {
                        CComObject<CRASStatisticsProvider>* pRASStatisticsProvider;
                        hr = CComObject<CRASStatisticsProvider>::CreateInstance(&pRASStatisticsProvider);
                        if(SUCCEEDED(hr))
                        {
                            pRASStatisticsProvider->AddRef();

                            hr = pRASStatisticsProvider->Initialize(pNetConnection);
                            
                            // pass the reference
                            m_pStatisticsProvider = static_cast<IStatisticsProvider*>(pRASStatisticsProvider);
                        }
                    }
                    
                    if(SUCCEEDED(hr))
                    {
                        if(NCM_LAN == m_MediaType)
                        {
                            hr = CComObject<CWANIPConnectionService>::CreateInstance(&m_pWANIPConnectionService);
                            if(SUCCEEDED(hr))
                            {
                                m_pWANIPConnectionService->AddRef();
                                hr = m_pWANIPConnectionService->Initialize(pGuid, pPublicConnection, m_pStatisticsProvider);
                            }
                        }
                        else
                        {
                            hr = CComObject<CWANPPPConnectionService>::CreateInstance(&m_pWANPPPConnectionService);
                            if(SUCCEEDED(hr))
                            {
                                m_pWANPPPConnectionService->AddRef();
                                hr = m_pWANPPPConnectionService->Initialize(pGuid, pPublicConnection, m_pStatisticsProvider);
                            }
                            
                            if(SUCCEEDED(hr))
                            {
                                hr = CComObject<CWANPOTSLinkConfigService>::CreateInstance(&m_pWANPOTSLinkConfigService);
                                if(SUCCEEDED(hr))
                                {
                                    m_pWANPOTSLinkConfigService->AddRef();
                                    hr = m_pWANPOTSLinkConfigService->Initialize(pNetConnection);
                                }
                            }
                        }
                    }

                    NcFreeNetconProperties(pProperties);
                }
                pNetConnection->Release();
            }
            CoTaskMemFree(pGuid);
        }

        if(SUCCEEDED(hr))
        {
            hr = pPrivateConnection->GetGuid(&pGuid);
            if(SUCCEEDED(hr))
            {
                hr = CoCreateInstance(CLSID_UPnPDeviceHostICSSupport, NULL, CLSCTX_SERVER, IID_IUPnPDeviceHostICSSupport, reinterpret_cast<void**>(&m_pICSSupport));                 
                if(SUCCEEDED(hr))
                {
                    hr = m_pICSSupport->SetICSInterfaces(1, pGuid);
                }
                CoTaskMemFree(pGuid);
            }
        }

        pPublicConnection->Release();
        pPrivateConnection->Release();
    }
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::FinalRelease()
{
    HRESULT hr = S_OK;
    
    
    if(NULL != m_pWANIPConnectionService)
    {
        m_pWANIPConnectionService->StopListening();
        m_pWANIPConnectionService->Release();
    }
    if(NULL != m_pWANPPPConnectionService)
    {
        m_pWANPPPConnectionService->StopListening();
        m_pWANPPPConnectionService->Release();
    }
    if(NULL != m_pWANPOTSLinkConfigService)
    {
        m_pWANPOTSLinkConfigService->Release();
    }
    if(NULL != m_pICSSupport)
    {
        m_pICSSupport->SetICSOff();
        m_pICSSupport->Release();
    }
    if(NULL != m_pStatisticsProvider)
    {
        m_pStatisticsProvider->Release();
    }


    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetConnections(IHNetConnection** ppPublicConnection, IHNetConnection** ppPrivateConnection)
{
    HRESULT hr = S_OK;

    *ppPublicConnection = NULL;
    *ppPrivateConnection = NULL;


    IHNetIcsSettings* pIcsSettings;
    hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_SERVER, IID_IHNetIcsSettings, reinterpret_cast<void**>(&pIcsSettings));
    if(SUCCEEDED(hr))
    {
        IHNetConnection* pHomenetConnection;
        
        IEnumHNetIcsPublicConnections* pEnumIcsPublicConnections;
        hr = pIcsSettings->EnumIcsPublicConnections(&pEnumIcsPublicConnections);
        if(SUCCEEDED(hr))
        {
            IHNetIcsPublicConnection* pPublicConnection;
            hr = pEnumIcsPublicConnections->Next(1, &pPublicConnection, NULL);
            if(S_OK == hr)
            {
                hr = pPublicConnection->QueryInterface(IID_IHNetConnection, reinterpret_cast<void**>(&pHomenetConnection));
                if(SUCCEEDED(hr))
                {
                    *ppPublicConnection = pHomenetConnection;
                }

                pPublicConnection->Release();
            }
            else if(S_FALSE == hr)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            pEnumIcsPublicConnections->Release();
        }

        if(SUCCEEDED(hr))
        {
            IEnumHNetIcsPrivateConnections* pEnumIcsPrivateConnections;
            hr = pIcsSettings->EnumIcsPrivateConnections(&pEnumIcsPrivateConnections);
            if(SUCCEEDED(hr))
            {
                IHNetIcsPrivateConnection* pPrivateConnection;
                hr = pEnumIcsPrivateConnections->Next(1, &pPrivateConnection, NULL);
                if(S_OK == hr)
                {
                    hr = pPrivateConnection->QueryInterface(IID_IHNetConnection, reinterpret_cast<void**>(&pHomenetConnection));
                    if(SUCCEEDED(hr))
                    {
                        *ppPrivateConnection = pHomenetConnection;
                    }
                    pPrivateConnection->Release();
                }
                else if(S_FALSE == hr)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
                pEnumIcsPrivateConnections->Release();
            }
            
            if(FAILED(hr))
            {
                if(NULL != *ppPublicConnection)
                {
                    (*ppPublicConnection)->Release();
                    *ppPublicConnection = NULL;
                }
            }
        }
        pIcsSettings->Release();
    }

    return hr;
}

// IUPnPEventSource methods

HRESULT CWANCommonInterfaceConfigService::Advise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    if(NULL != m_pEventSink)
    {
        m_pEventSink->Release();
        m_pEventSink = NULL;
    }
    return hr;
}

// Functions for IWANCommonInterfaceConfig

HRESULT CWANCommonInterfaceConfigService::get_WANAccessType(BSTR *pWANAccessType)
{
    HRESULT hr = S_OK;
    
    *pWANAccessType = SysAllocString(NCM_LAN == m_MediaType ? L"Ethernet" : L"POTS");
    if(NULL == *pWANAccessType)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_Layer1UpstreamMaxBitRate(ULONG *pLayer1UpstreamMaxBitRate)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pLayer1UpstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_Layer1DownstreamMaxBitRate(ULONG *pLayer1DownstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pLayer1DownstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_PhysicalLinkStatus(BSTR *pPhysicalLinkStatus)
{
    HRESULT hr = S_OK;
    *pPhysicalLinkStatus = SysAllocString(L"Up");

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalBytesSent(ULONG *pTotalBytesSent)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(pTotalBytesSent, NULL, NULL, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalBytesReceived(ULONG *pTotalBytesReceived)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, pTotalBytesReceived, NULL, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalPacketsSent(ULONG *pTotalPacketsSent)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, pTotalPacketsSent, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalPacketsReceived(ULONG *pTotalPacketsReceived)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, pTotalPacketsReceived, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_WANAccessProvider(BSTR *pWANAccessProvider)
{
    HRESULT hr = S_OK;
    *pWANAccessProvider = SysAllocString(L"");
    if(NULL == *pWANAccessProvider)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_MaximumActiveConnections(USHORT *pMaximumActiveConnections)
{
    HRESULT hr = S_OK;
    *pMaximumActiveConnections = 0;
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_X_PersonalFirewallEnabled(VARIANT_BOOL *pPersonalFirewallEnabled)
{
    HRESULT hr = S_OK;

    *pPersonalFirewallEnabled = m_bFirewalled ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_X_Uptime(ULONG *pUptime)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, NULL, pUptime); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetCommonLinkProperties(BSTR* pWANAccessType, ULONG* pLayer1UpstreamMaxBitRate, ULONG *pLayer1DownstreamMaxBitRate, BSTR *pPhysicalLinkStatus)
{
    HRESULT hr = S_OK;
    
    SysFreeString(*pWANAccessType);
    SysFreeString(*pPhysicalLinkStatus);
    *pWANAccessType = NULL;
    *pPhysicalLinkStatus = NULL;

    hr = get_WANAccessType(pWANAccessType);

    if(SUCCEEDED(hr))
    {
        hr = get_Layer1UpstreamMaxBitRate(pLayer1UpstreamMaxBitRate);
    }

    if(SUCCEEDED(hr))
    {
        hr = get_Layer1DownstreamMaxBitRate(pLayer1DownstreamMaxBitRate);
    }

    if(SUCCEEDED(hr))
    {
        hr = get_PhysicalLinkStatus(pPhysicalLinkStatus);
    }

    if(FAILED(hr))
    {
        SysFreeString(*pWANAccessType);
        SysFreeString(*pPhysicalLinkStatus);
        *pWANAccessType = NULL;
        *pPhysicalLinkStatus = NULL;
    }

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetTotalBytesSent(ULONG *pTotalBytesSent)
{
    return get_TotalBytesSent(pTotalBytesSent);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalBytesReceived(ULONG *pTotalBytesReceived)
{
    return get_TotalBytesReceived(pTotalBytesReceived);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalPacketsSent(ULONG *pTotalPacketsSent)
{
    return get_TotalPacketsSent(pTotalPacketsSent);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalPacketsReceived(ULONG *pTotalPacketsReceived)
{
    return get_TotalPacketsReceived(pTotalPacketsReceived);
}

HRESULT CWANCommonInterfaceConfigService::X_GetICSStatistics(ULONG *pTotalBytesSent, ULONG *pTotalBytesReceived, ULONG *pTotalPacketsSent, ULONG *pTotalPacketsReceived, ULONG *pSpeed, ULONG *pUptime)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(pTotalBytesSent, pTotalBytesReceived, pTotalPacketsSent, pTotalPacketsReceived, pSpeed, pUptime); 
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanipconnectionservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "resource.h"       // main symbols
#include "netconp.h"
#include "netcon.h"
#include "CWANConnectionBase.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANIPConnectionService : 
    public CWANConnectionBase
{
public:

    CWANIPConnectionService();

    STDMETHODIMP RequestConnection();
    STDMETHODIMP ForceTermination();
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError);

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanconnectionbase.h ===
#pragma once

#include "netconp.h"
#include "dispimpl2.h"
#include "upnphost.h"
#include "InternetGatewayDevice.h"
#include "api.h"
#include "hnetcfg.h"

class CWANConnectionBase :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUPnPEventSource,
    public INetConnectionNotifySink,
    public INATEventsSink,
    public IDelegatingDispImpl<IWANIPConnectionService>
{
public: 

    CWANConnectionBase();

    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CWANConnectionBase)
        COM_INTERFACE_ENTRY(IWANIPConnectionService)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IUPnPEventSource)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()
        
        

    
    HRESULT StopListening();
    HRESULT Initialize(GUID* pGuid, IHNetConnection* pSharedConnection, IStatisticsProvider* pStatisticsProvider);


     // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);

   // INetConnectionNotifySink
    STDMETHODIMP ConnectionAdded(const NETCON_PROPERTIES_EX* pProps);
    STDMETHODIMP ConnectionBandWidthChange(const GUID* pguidId);
    STDMETHODIMP ConnectionDeleted(const GUID* pguidId);
    STDMETHODIMP ConnectionModified(const NETCON_PROPERTIES_EX* pProps);
    STDMETHODIMP ConnectionRenamed(const GUID* pguidId, LPCWSTR pszwNewName);
    STDMETHODIMP ConnectionStatusChange(const GUID* pguidId, NETCON_STATUS Status);
    STDMETHODIMP ConnectionAddressChange(const GUID* pguidId);
    STDMETHODIMP ShowBalloon(const GUID* pguidId, const BSTR szCookie, const BSTR szBalloonText); 
    STDMETHODIMP RefreshAll();
    STDMETHODIMP DisableEvents(const BOOL fDisable, const ULONG ulDisableTimeout);

    // INATEventsSink
    STDMETHODIMP PublicIPAddressChanged(void);
    STDMETHODIMP PortMappingsChanged(void);

    // IWANPPPConnection and IWANIPConnection
    STDMETHODIMP get_ConnectionType(BSTR *pConnectionType);
    STDMETHODIMP get_PossibleConnectionTypes(BSTR *pPossibleConnectionTypes);
    STDMETHODIMP get_ConnectionStatus(BSTR *pConnectionStatus);
    STDMETHODIMP get_Uptime(ULONG *pUptime);
    STDMETHODIMP get_UpstreamMaxBitRate(ULONG *pUpstreamMaxBitRate);
    STDMETHODIMP get_DownstreamMaxBitRate(ULONG *pDownstreamMaxBitRate);
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError) = 0;
    STDMETHODIMP get_RSIPAvailable(VARIANT_BOOL *pRSIPAvailable);
    STDMETHODIMP get_NATEnabled(VARIANT_BOOL *pNATEnabled);
    STDMETHODIMP get_X_Name(BSTR* pName);
    STDMETHODIMP get_ExternalIPAddress(BSTR *pExternalIPAddress);
    STDMETHODIMP get_RemoteHost(BSTR *pRemoteHost);
    STDMETHODIMP get_ExternalPort(USHORT *pExternalPort);
    STDMETHODIMP get_InternalPort(USHORT *pInternalPort);
    STDMETHODIMP get_PortMappingProtocol(BSTR *pProtocol);
    STDMETHODIMP get_InternalClient(BSTR *pInternalClient);
    STDMETHODIMP get_PortMappingDescription(BSTR *pDescription);
    STDMETHODIMP get_PortMappingEnabled(VARIANT_BOOL *pEnabled);
    STDMETHODIMP get_PortMappingLeaseDuration(ULONG *LeaseDuration);
    STDMETHODIMP get_PortMappingNumberOfEntries(USHORT *pNumberOfEntries);
    

    STDMETHODIMP SetConnectionType(BSTR NewConnectionType);
    STDMETHODIMP GetConnectionTypeInfo(BSTR* pNewConnectionType, BSTR* pNewPossibleConnectionTypes);
    STDMETHODIMP RequestConnection() = 0;
    STDMETHODIMP ForceTermination() = 0;
    STDMETHODIMP GetStatusInfo(BSTR* pNewConnectionStatus, BSTR* pNewLastConnectionError, ULONG* pNewUptime);
    STDMETHODIMP GetNATRSIPStatus(VARIANT_BOOL* pNewRSIPAvailable, VARIANT_BOOL* pNewNATEnabled);
    STDMETHODIMP GetLinkLayerMaxBitRates(ULONG* pNewUpstreamMaxBitRate, ULONG* pNewDownstreamMaxBitRate);
    STDMETHODIMP GetGenericPortMappingEntry(USHORT uwIndex, BSTR* pRemoteHost, USHORT* puwExternalPort, BSTR* pProtocol, USHORT* puwInternalPort, BSTR* pInternalClient, VARIANT_BOOL* pbEnabled, BSTR* pDescription, ULONG* pulLeaseDuration);
    STDMETHODIMP GetSpecificPortMappingEntry(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT* puwInternalPort, BSTR* pInternalClient, VARIANT_BOOL* pbEnabled, BSTR* pDescription, ULONG* pulLeaseDuration);
    STDMETHODIMP AddPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);
    STDMETHODIMP DeletePortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol);
    STDMETHODIMP GetExternalIPAddress(BSTR* pExternalIPAddress);


    HRESULT FinalConstruct();
    HRESULT FinalRelease();
protected:

    HRESULT StartNetmanEvents(INetConnectionNotifySink* pSink);
    HRESULT ControlEnabled(void);
    HRESULT FireEvent(DISPID DispatchId);

    HRESULT AddDynamicPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);
    HRESULT AddStaticPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);

    IHNetConnection* m_pHomenetConnection;  
    GUID m_SharedGuid;
    IUPnPEventSink* m_pEventSink;
 
    //
    // Needed entries for the PortMappings
    //
    IHNetIcsSettings*       m_IcsSettingsp;

private:

    IConnectionPoint* m_pConnectionPoint;
    DWORD m_dwConnectionManagerConnectionPointCookie;
    IStatisticsProvider* m_pStatisticsProvider;
    HRESULT m_hAdviseNATEventsResult;

};

//
// Utility Functions.
//
enum MAPPING_TYPE
{
    ePortMappingInvalid = 0,
    ePortMappingDynamic,
    ePortMappingStatic
};


HRESULT
SearchPortMapping(
                  IN          IHNetIcsSettings*           IcsSettingsp,
                  IN OPTIONAL ULONG                       searchIndex,
                  IN OPTIONAL USHORT                      searchPort,
                  IN OPTIONAL UCHAR                       searchProtocol,
                  OUT         IHNetPortMappingProtocol    **Protocolpp
                 );

HRESULT
FillStaticMappingInformation(
                             IN          IHNetPortMappingProtocol*  MappingProtocolp,
                             IN OPTIONAL IHNetPortMappingBinding*   Bindingp,
                             OUT         PUSHORT                    uExternalPortp,
                             OUT         BSTR*                      Protocolp,
                             OUT         PUSHORT                    uInternalPortp,
                             OUT         BSTR*                      InternalClientp,
                             OUT         VARIANT_BOOL*              bEnabledp,
                             OUT         BSTR*                      Descriptionp
                            );

inline HRESULT
ValidatePortMappingParameters
(
 IN  BSTR          RemoteHost,
 IN  USHORT        uwExternalPort,
 IN  BSTR          Protocol,
 IN  USHORT        uwInternalPort,
 IN  BSTR          InternalClient,
 IN  VARIANT_BOOL  bEnabled,
 IN  BSTR          Description,
 IN  ULONG         ulLeaseDuration,
 OUT MAPPING_TYPE* pMappingType
);



#define RESOLVE_PROTOCOL_TYPE( _X_ , _Y_ ) \
if ( !_wcsicmp( (_Y_), L"TCP") )             \
{                                          \
     (_X_) = NAT_PROTOCOL_TCP;             \
}                                          \
else if ( !_wcsicmp((_Y_), L"UDP") )         \
{                                          \
     (_X_) = NAT_PROTOCOL_UDP;             \
}                                          \
else                                       \
{                                          \
    _ASSERT( FALSE );                      \
                                           \
    hr = E_INVALIDARG;                     \
                                           \
    break;                                 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanpotslinkconfigservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "CWANPOTSLinkConfigService.h"
#include "raserror.h"


CWANPOTSLinkConfigService::CWANPOTSLinkConfigService()
{
    m_pEventSink = NULL;
    m_pNetRasConnection = NULL;
}

HRESULT CWANPOTSLinkConfigService::Initialize(INetConnection* pNetConnection)
{
    HRESULT hr = S_OK;

    hr = pNetConnection->QueryInterface(IID_INetRasConnection, reinterpret_cast<void**>(&m_pNetRasConnection));
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::FinalRelease(void)
{
    HRESULT hr = S_OK;

    if(NULL != m_pNetRasConnection)
    {
        m_pNetRasConnection->Release();
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CWANPOTSLinkConfigService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_ISPPhoneNumber(BSTR* pISPPhoneNumber)
{
    HRESULT hr = S_OK;

    *pISPPhoneNumber = NULL;

    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pISPPhoneNumber = SysAllocString(pRasEntry->szLocalPhoneNumber);
        if(NULL == *pISPPhoneNumber)
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(pRasEntry);
    }
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_ISPInfo(BSTR *pISPInfo)
{
    HRESULT hr = S_OK;
    *pISPInfo = SysAllocString(L"");
    if(NULL == *pISPInfo)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_LinkType(BSTR *pLinkType)
{
    HRESULT hr = S_OK;
    *pLinkType = SysAllocString(L"PPP_Dialup");
    if(NULL == *pLinkType)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_NumberOfRetries(ULONG *pNumberOfRetries)
{
    HRESULT hr = S_OK;

    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pNumberOfRetries = pRasEntry->dwRedialCount;
        CoTaskMemFree(pRasEntry);
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_DelayBetweenRetries(ULONG *pDelayBetweenRetries)
{
    HRESULT hr = S_OK;
    
    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pDelayBetweenRetries = pRasEntry->dwRedialPause;
        CoTaskMemFree(pRasEntry);
    }
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetISPInfo(BSTR* pISPPhoneNumber, BSTR *pISPInfo, BSTR *pLinkType)
{
    HRESULT hr = S_OK;

    SysFreeString(*pISPPhoneNumber);
    SysFreeString(*pISPInfo);
    SysFreeString(*pLinkType);
    *pISPPhoneNumber = NULL;
    *pISPInfo = NULL;
    *pLinkType = NULL;
    
    hr = get_ISPPhoneNumber(pISPPhoneNumber);
    if(SUCCEEDED(hr))
    {
        hr = get_ISPInfo(pISPInfo);
    }
    if(SUCCEEDED(hr))
    {
        hr = get_LinkType(pLinkType);        
    }

    if(FAILED(hr))
    {
        SysFreeString(*pISPPhoneNumber);
        SysFreeString(*pISPInfo);
        SysFreeString(*pLinkType);
        *pISPPhoneNumber = NULL;
        *pISPInfo = NULL;
        *pLinkType = NULL;
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetCallRetryInfo(ULONG* pNumberOfRetries, ULONG *pDelayBetweenRetries)
{
    HRESULT hr = S_OK;

    hr = get_NumberOfRetries(pNumberOfRetries);
    if(SUCCEEDED(hr))
    {
        hr = get_DelayBetweenRetries(pDelayBetweenRetries);
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetRasEntry(RASENTRY** ppRasEntry)
{
    HRESULT hr = S_OK;

    *ppRasEntry = NULL;

    RASCON_INFO RasConnectionInfo;
    hr = m_pNetRasConnection->GetRasConnectionInfo(&RasConnectionInfo);
    if(SUCCEEDED(hr))
    {
        RASENTRY DummyRasEntry;
        ZeroMemory(&DummyRasEntry, sizeof(DummyRasEntry)); 
        DummyRasEntry.dwSize = sizeof(DummyRasEntry);
        DWORD dwEntrySize = sizeof(DummyRasEntry);
        DWORD dwError = RasGetEntryProperties(RasConnectionInfo.pszwPbkFile, RasConnectionInfo.pszwEntryName, &DummyRasEntry, &dwEntrySize, NULL, NULL);
        if(0 == dwError || ERROR_BUFFER_TOO_SMALL == dwError)
        {
            RASENTRY* pRasEntry = reinterpret_cast<RASENTRY*>(CoTaskMemAlloc(dwEntrySize));
            if(NULL != pRasEntry)
            {
                ZeroMemory(pRasEntry, dwEntrySize); 
                pRasEntry->dwSize = sizeof(RASENTRY);
                dwError = RasGetEntryProperties(RasConnectionInfo.pszwPbkFile, RasConnectionInfo.pszwEntryName, pRasEntry, &dwEntrySize, NULL, NULL);
                if(0 == dwError)
                {
                    *ppRasEntry = pRasEntry;                        

                }
                else
                {
                    hr = E_FAIL;
                }
                
                if(FAILED(hr))
                {
                    CoTaskMemFree(pRasEntry);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        CoTaskMemFree(RasConnectionInfo.pszwPbkFile);
        CoTaskMemFree(RasConnectionInfo.pszwEntryName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanconnectionbase.cpp ===
#include "pch.h"
#pragma hdrstop


#include "CWANConnectionBase.h"
#include "beacon.h"

#include <ipnat.h>
#include <iphlpapi.h>
#include <ntddip.h>
#include <winsock.h>


#include "debug.h"
#include "util.h"



extern "C"
ULONG
NhpAllocateAndGetInterfaceInfoFromStack(
    IP_INTERFACE_NAME_INFO** Table,
    PULONG Count,
    BOOL SortOutput,
    HANDLE AllocationHeap,
    ULONG AllocationFlags
    );


CWANConnectionBase::CWANConnectionBase()
{
    m_pConnectionPoint = NULL;
    m_pHomenetConnection = NULL;
    m_pEventSink = NULL;

    m_pStatisticsProvider = NULL;

    m_IcsSettingsp          = NULL;
    m_hAdviseNATEventsResult = E_FAIL;
}

HRESULT CWANConnectionBase::FinalConstruct()
{
    HRESULT hr = S_OK;
    hr = StartNetmanEvents(this);
    if(SUCCEEDED(hr))
    {
        hr = AdviseNATEvents(this);
        m_hAdviseNATEventsResult = hr;
    }
    return hr;
}

HRESULT CWANConnectionBase::FinalRelease()
{

    if ( NULL != m_pHomenetConnection)
    {
        m_pHomenetConnection->Release();
    }

    if ( NULL != m_IcsSettingsp)
    {
        m_IcsSettingsp->Release();
    }

    if(NULL != m_pStatisticsProvider)
    {
        m_pStatisticsProvider->Release();
    }
    DestroyDebugger();

    return S_OK;    
}

HRESULT CWANConnectionBase::StopListening()

{
    HRESULT hr = S_OK;

    if(NULL != m_pConnectionPoint)
    {
        hr = m_pConnectionPoint->Unadvise(m_dwConnectionManagerConnectionPointCookie);

        m_pConnectionPoint->Release();
        m_pConnectionPoint = NULL;
    }

    if(SUCCEEDED(m_hAdviseNATEventsResult))
    {
        UnadviseNATEvents(this);  
    }
    return hr;
}

HRESULT CWANConnectionBase::StartNetmanEvents(INetConnectionNotifySink* pSink)
{
    HRESULT hr = S_OK;

    INetConnectionManager* pConnectionManager;    
    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, reinterpret_cast<void**>(&pConnectionManager));
    if SUCCEEDED(hr)
    {
        IConnectionPointContainer* pConnectionPointContainer;
        hr = pConnectionManager->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pConnectionPointContainer));
        if(SUCCEEDED(hr))
        {
            hr = pConnectionPointContainer->FindConnectionPoint(IID_INetConnectionNotifySink, &m_pConnectionPoint);
            if(SUCCEEDED(hr))
            {
                hr = m_pConnectionPoint->Advise(pSink, &m_dwConnectionManagerConnectionPointCookie);
                if(FAILED(hr))
                {
                    m_pConnectionPoint->Release();
                    m_pConnectionPoint = NULL;
                }
                // release in stop listening on success
            }
            pConnectionPointContainer->Release();
        }
        pConnectionManager->Release();
    }                   


    return hr;
}



HRESULT
CWANConnectionBase::Initialize(
                               GUID*           pGuid, 
                               IHNetConnection* pHomenetConnection,
                               IStatisticsProvider* pStatisticsProvider
                              )
{
    HRESULT                         hr                          = S_OK;
    
    InitDebugger();

    DBG_SPEW(TM_STATIC, TL_INFO, L" > Initialize ");


    m_pStatisticsProvider = pStatisticsProvider;
    m_pStatisticsProvider->AddRef();
    
    m_pHomenetConnection = pHomenetConnection;
    m_pHomenetConnection->AddRef();

    CopyMemory(&m_SharedGuid, pGuid, sizeof(GUID));

    hr = CoCreateInstance(CLSID_HNetCfgMgr,
                          NULL,
                          CLSCTX_SERVER,
                          IID_IHNetIcsSettings,
                          reinterpret_cast<void**>(&m_IcsSettingsp));

    return hr;
}

HRESULT CWANConnectionBase::FireEvent(DISPID DispatchId)
{
    HRESULT hr = S_OK;

    IUPnPEventSink* pEventSink = NULL;

    Lock();

    if(NULL != m_pEventSink)
    {
        pEventSink = m_pEventSink;
        pEventSink->AddRef();
    }

    Unlock();

    if(NULL != pEventSink)
    {
        hr = pEventSink->OnStateChanged(1, &DispatchId);
        pEventSink->Release();            
    }

    return hr;
}

// IUPnPEventSource methods

HRESULT CWANConnectionBase::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    Lock();

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    Unlock();

    return hr;
}

HRESULT CWANConnectionBase::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    Lock();
    
    m_pEventSink->Release();
    m_pEventSink = NULL;

    Unlock();

    return hr;
}

// INATEventsNotifySink

HRESULT CWANConnectionBase::PublicIPAddressChanged(void)
{
    return FireEvent(IWANIPCONNECTION_DISPID_EXTERNALIPADDRESS);
}

HRESULT CWANConnectionBase::PortMappingsChanged(void)
{
    return FireEvent(IWANIPCONNECTION_DISPID_PORTMAPPINGNUMBEROFENTRIES);
}


// INetConnectionNotifySink methods

HRESULT CWANConnectionBase::ConnectionAdded(const NETCON_PROPERTIES_EX* pProps)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionBandWidthChange(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionDeleted(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionModified(const NETCON_PROPERTIES_EX* pProps)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CWANConnectionBase::ConnectionRenamed(const GUID* pguidId, LPCWSTR pszwNewName)
{
    HRESULT hr = S_OK;
    if(IsEqualGUID(*pguidId, m_SharedGuid))
    {
        hr = FireEvent(IWANIPCONNECTION_DISPID_NAME);
    }

    return hr;
}

HRESULT CWANConnectionBase::ConnectionStatusChange(const GUID* pguidId, NETCON_STATUS Status)
{
    HRESULT hr = S_OK;
    if(IsEqualGUID(*pguidId, m_SharedGuid))
    {
        hr = FireEvent(IWANIPCONNECTION_DISPID_CONNECTIONSTATUS);
    }
    return hr;
}

HRESULT CWANConnectionBase::ConnectionAddressChange(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    if ( IsEqualGUID(*pguidId, m_SharedGuid) )
    {
        hr = FireEvent( IWANIPCONNECTION_DISPID_EXTERNALIPADDRESS );
    }

    return hr;
}

HRESULT CWANConnectionBase::ShowBalloon(const GUID* pguidId, const BSTR szCookie, const BSTR szBalloonText)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT CWANConnectionBase::RefreshAll()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::DisableEvents(const BOOL fDisable, const ULONG ulDisableTimeout)
{
    HRESULT hr = S_OK;

    return hr;
}

// IWANIPConnection and IWANPPPConnection methods

HRESULT CWANConnectionBase::get_ConnectionType(BSTR *pConnectionType)
{
    HRESULT hr = S_OK;
    *pConnectionType = SysAllocString(L"IP_Routed");
    if(NULL == *pConnectionType)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANConnectionBase::get_PossibleConnectionTypes(BSTR *pPossibleConnectionTypes)
{
    HRESULT hr = S_OK;
    *pPossibleConnectionTypes = SysAllocString(L"IP_Routed");
    if(NULL == *pPossibleConnectionTypes)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANConnectionBase::get_ConnectionStatus(BSTR *pConnectionStatus)
{
    HRESULT hr = S_OK;

    *pConnectionStatus = NULL;

    INetConnection* pNetConnection;
    hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
    if(SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProperties;
        hr = pNetConnection->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            LPWSTR pszStatus;
            switch(pProperties->Status)
            {
            case NCS_AUTHENTICATION_SUCCEEDED:
            case NCS_CONNECTED:
                pszStatus = L"Connected";
                break;
            case NCS_DISCONNECTED:
                pszStatus = L"Disconnected";
                break;
            case NCS_AUTHENTICATING:
            case NCS_CONNECTING:
                pszStatus = L"Connecting";
                break;
            case NCS_DISCONNECTING:
                pszStatus = L"Disconnecting";
                break;
            case NCS_INVALID_ADDRESS:
            case NCS_CREDENTIALS_REQUIRED:
            case NCS_AUTHENTICATION_FAILED:
            case NCS_HARDWARE_DISABLED:
            case NCS_HARDWARE_MALFUNCTION:
            case NCS_HARDWARE_NOT_PRESENT:
            default:
                pszStatus = L"Unconfigured";
                break;
                
            }
            
            *pConnectionStatus = SysAllocString(pszStatus);
            if(NULL == *pConnectionStatus)
            {
                hr = E_OUTOFMEMORY;
            }
            
            NcFreeNetconProperties(pProperties);
        }
        pNetConnection->Release();
    }
    return hr;


}

HRESULT CWANConnectionBase::get_Uptime(ULONG *pUptime)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, NULL, pUptime); 
    
    return hr;
}

HRESULT CWANConnectionBase::get_UpstreamMaxBitRate(ULONG *pUpstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pUpstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANConnectionBase::get_DownstreamMaxBitRate(ULONG *pDownstreamMaxBitRate)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pDownstreamMaxBitRate, NULL); 

    return hr;
}

HRESULT CWANConnectionBase::get_RSIPAvailable(VARIANT_BOOL *pRSIPAvailable)
{
    HRESULT hr = S_OK;
    *pRSIPAvailable = VARIANT_FALSE;
    return hr;
}

HRESULT CWANConnectionBase::get_NATEnabled(VARIANT_BOOL *pNATEnabled)
{
    HRESULT hr = S_OK;
    *pNATEnabled = VARIANT_TRUE;
    return hr;
}

HRESULT CWANConnectionBase::get_X_Name(BSTR* pName)
{

    HRESULT hr = S_OK;

    *pName = NULL;
    
    INetConnection* pNetConnection;
    hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
    if(SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProperties;
        hr = pNetConnection->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            *pName = SysAllocString(pProperties->pszwName);
            if(NULL == *pName)
            {
                hr = E_OUTOFMEMORY;
            }
            NcFreeNetconProperties(pProperties);
        }
        pNetConnection->Release();
    }
    return hr;
}


HRESULT
get_HrLocalAdaptersInfo(PIP_ADAPTER_INFO* ppAdapter)
{
    HRESULT          hr = S_OK, dwErr = NO_ERROR;
    PIP_ADAPTER_INFO paAdapterInfo = NULL;
    ULONG            uBufLen = (2 * BUF_SIZE); 

    _ASSERT( ppAdapter != NULL );

    *ppAdapter = NULL;

    
    paAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc( uBufLen );

    if ( NULL == paAdapterInfo ) { return E_OUTOFMEMORY; }

    //
    // Discover How much Memory we need. If we need at all.

    // Note that paAdapterInfo may be non-NULL and that is desired.
    dwErr = GetAdaptersInfo( paAdapterInfo, &uBufLen );

    if ( ERROR_BUFFER_OVERFLOW == dwErr )
    {
        CoTaskMemFree( paAdapterInfo );

        paAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc( uBufLen );

        if ( paAdapterInfo != NULL)
        {
            dwErr = GetAdaptersInfo ( paAdapterInfo, &uBufLen );
        }
    }

    if ( paAdapterInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if ( ERROR_SUCCESS != dwErr )
    {
        DBG_SPEW( TM_INFO, TL_ERROR, 
                  L" GetAdapterInfo has failed with E(%u) BufSize(%u) ", 
                  dwErr, uBufLen );

        CoTaskMemFree(paAdapterInfo);

        return HRESULT_FROM_WIN32( dwErr );
    }

    if ( ppAdapter && paAdapterInfo ) { *ppAdapter = paAdapterInfo; }

    return hr;
}

// {c200e360-38c5-11ce-ae62-08002b2b79ef} - 38 chars 
#define GUID_STRING_LENGTH 38

PIP_ADAPTER_INFO
GetExternalAdapterInfo( GUID* pGUID )
{
    HRESULT hr = S_OK;
    WCHAR   szwGUID[ GUID_STRING_LENGTH + 1 ] = { 0 };
    char    ascGUID[ GUID_STRING_LENGTH + 1 ] = { 0 }; 
    PIP_ADAPTER_INFO pRetAdapter = NULL;
    PIP_ADAPTER_INFO pAdapterList = NULL, pTempAdapter = NULL;


    _ASSERT( pGUID != NULL );

    //
    // Change the given GUID to a String
    if ( StringFromGUID2( *pGUID, szwGUID, GUID_STRING_LENGTH + 1 ) == 0 )
    { return NULL; }

    if ( WideCharToMultiByte( CP_ACP, 0, szwGUID, -1, ascGUID, sizeof(ascGUID), NULL, NULL) == 0 )
    { return NULL; }

    hr = get_HrLocalAdaptersInfo( &pAdapterList );

    if ( FAILED(hr) || (pAdapterList == NULL) ) { return NULL; }

    pTempAdapter = pAdapterList;

    while ( pAdapterList != NULL )
    {
        if ( 0 == strcmp(ascGUID, pAdapterList->AdapterName) )
        {
            pRetAdapter = (PIP_ADAPTER_INFO) CoTaskMemAlloc( sizeof(IP_ADAPTER_INFO) );

            if ( NULL != pRetAdapter )
            {
                memcpy( pRetAdapter, pAdapterList, sizeof(IP_ADAPTER_INFO) );
                
                pRetAdapter->Next = NULL;
                
                break;
            }
        }

        pAdapterList = pAdapterList->Next;
    }
    
    CoTaskMemFree( pTempAdapter );
    
    return pRetAdapter;
}

                                                 




HRESULT CWANConnectionBase::get_ExternalIPAddress(BSTR *pExternalIPAddress)
{
    HRESULT         hr           = S_OK;
    ULONG           AddressCount = 0;
    LPOLESTR        swAddr       = NULL;
    PIP_ADAPTER_INFO pExternalAdapterInfo = NULL;
    ULONG numOfChar = 0, uTemp = 0, Error = NO_ERROR;

    WCHAR   szwGUID[ GUID_STRING_LENGTH + 1 ] = { 0 };
    IP_INTERFACE_NAME_INFO*  Table = NULL;
    ULONG  Count = 0;

    _ASSERT( pExternalIPAddress != NULL );
    
    if ( pExternalIPAddress != NULL )
    {
        *pExternalIPAddress = NULL;
    }
    else
    {
        return E_POINTER;
    }

    
    _ASSERT( pExternalIPAddress != NULL );

    StringFromGUID2( m_SharedGuid, szwGUID, GUID_STRING_LENGTH + 1 );

    DBG_SPEW(TM_INFO, TL_TRACE, L"> get_ExternalIpAddress Looking for GUID %s", szwGUID);

    Error = NhpAllocateAndGetInterfaceInfoFromStack(&Table, 
                                                    &Count, 
                                                    FALSE, 
                                                    GetProcessHeap(), 
                                                    0);
    
    if ( (NO_ERROR == Error) && (Table != NULL) )
    {
        for (ULONG i = 0; i < Count ; i++) 
        {
#if DBG
            StringFromGUID2( Table[i].DeviceGuid, szwGUID, GUID_STRING_LENGTH + 1 );
            DBG_SPEW(TM_INFO, TL_DUMP, L" DeviceGUID[%u] = %s", i, szwGUID);
            
            StringFromGUID2( Table[i].InterfaceGuid, szwGUID, GUID_STRING_LENGTH + 1 );
            DBG_SPEW(TM_INFO, TL_DUMP, L" DeviceGUID[%u] = %s", i, szwGUID);
#endif
            if ( IsEqualGUID((Table[i].InterfaceGuid), m_SharedGuid) )
            {
                pExternalAdapterInfo = GetExternalAdapterInfo( &Table[i].DeviceGuid );

                break;
            }
        }

        HeapFree(GetProcessHeap(), 0, Table);
    }

    if ( pExternalAdapterInfo == NULL )
    {
        pExternalAdapterInfo = GetExternalAdapterInfo( &m_SharedGuid );
    }
    

    if ( pExternalAdapterInfo != NULL )
    {
        if ( strcmp("0.0.0.0", pExternalAdapterInfo->IpAddressList.IpAddress.String) )
        {
            numOfChar = strlen( pExternalAdapterInfo->IpAddressList.IpAddress.String );
            
            swAddr = (LPOLESTR) CoTaskMemAlloc( (numOfChar + 1) * sizeof(WCHAR) );
    
            if ( swAddr != NULL )
            {
                memset( swAddr, 0, (numOfChar + 1) * sizeof(WCHAR));
    
                uTemp = _snwprintf( swAddr, numOfChar, L"%S",  
                                    pExternalAdapterInfo->IpAddressList.IpAddress.String );
    
                _ASSERT( numOfChar == uTemp );

                swAddr[ numOfChar] = L'\0';
    
                *pExternalIPAddress = SysAllocString( swAddr );
                
                CoTaskMemFree( swAddr );
            }
        }
        else
        {
            *pExternalIPAddress = SysAllocString( L"" );
        }

        CoTaskMemFree( pExternalAdapterInfo );
    }
    else
    {
        *pExternalIPAddress = SysAllocString( L"" );
    }


    if ( *pExternalIPAddress == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        DBG_SPEW(TM_INFO, TL_INFO, L"Returning IP String (%s)", *pExternalIPAddress);
    }

    return hr;
}

HRESULT CWANConnectionBase::get_RemoteHost(BSTR *pRemoteHost)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_ExternalPort(USHORT *pExternalPort)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_InternalPort(USHORT *pInternalPort)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingProtocol(BSTR *pProtocol)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_InternalClient(BSTR *pInternalClient)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingDescription(BSTR *pDescription)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingEnabled(VARIANT_BOOL *pEnabled)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingLeaseDuration(ULONG *LeaseDuration)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingNumberOfEntries(USHORT *pNumberOfEntries)
{
    HRESULT                         hr                 = S_OK;
    
    IHNetPortMappingProtocol*       MappingProtocolp   = NULL;

    IHNetProtocolSettings*          ProtocolSettingsp  = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp     = NULL;


    _ASSERT( pNumberOfEntries != NULL );

    *pNumberOfEntries = 0;

    do
    {
        
        hr = m_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Query Interface failed for ProtocolSettingsp E:(%X)", hr);

            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Enum Interface can't be retrieved E(%X)", hr);

            break;
        }

        while( S_OK == EnumProtocolsp->Next(1, &MappingProtocolp, NULL) )
        {
            (*pNumberOfEntries)++;

            _ASSERT( MappingProtocolp != NULL );

            MappingProtocolp->Release();
        }
    
    } while ( FALSE );

    


    if ( ProtocolSettingsp != NULL ) { ProtocolSettingsp->Release(); }

    if ( EnumProtocolsp != NULL) { EnumProtocolsp->Release(); }

    return hr;
}

HRESULT CWANConnectionBase::SetConnectionType(BSTR NewConnectionType)
{
    HRESULT hr = S_OK;
    
    if(0 != lstrcmp(NewConnectionType, L"IP_Routed"))
    {
        hr = E_FAIL; // we only support IP_Routed
    }

    return hr;
}


HRESULT CWANConnectionBase::GetConnectionTypeInfo(BSTR* pNewConnectionType, BSTR* pNewPossibleConnectionTypes)
{
    HRESULT hr = S_OK;

    SysFreeString(*pNewConnectionType);
    SysFreeString(*pNewPossibleConnectionTypes);
    *pNewConnectionType = NULL;
    *pNewPossibleConnectionTypes = NULL;

    hr = get_ConnectionType(pNewConnectionType);
    if(SUCCEEDED(hr))
    {
        hr = get_PossibleConnectionTypes(pNewPossibleConnectionTypes);
    }

    if(FAILED(hr))
    {
        if(NULL != *pNewConnectionType)
        {
            SysFreeString(*pNewConnectionType);
            *pNewConnectionType = NULL;
        }
    }
    return hr;
}

HRESULT CWANConnectionBase::GetStatusInfo(BSTR* pNewConnectionStatus, BSTR* pNewLastConnectionError, ULONG* pNewUptime)
{
    HRESULT hr = S_OK;

    SysFreeString(*pNewConnectionStatus);
    SysFreeString(*pNewLastConnectionError);
    *pNewConnectionStatus = NULL;
    *pNewLastConnectionError = NULL;
    
    hr = get_ConnectionStatus(pNewConnectionStatus);
    if(SUCCEEDED(hr))
    {
        hr = get_LastConnectionError(pNewLastConnectionError);
    }

    if(SUCCEEDED(hr) && 0 == lstrcmp(L"Connected", *pNewConnectionStatus))
    {
        hr = get_Uptime(pNewUptime);
    }
    else
    {
        *pNewUptime = 0;
    }

    if(FAILED(hr))
    {
        if(NULL != *pNewConnectionStatus)
        {
            SysFreeString(*pNewConnectionStatus);
            *pNewConnectionStatus = NULL;
        }
        
        if(NULL != *pNewLastConnectionError)
        {
            SysFreeString(*pNewLastConnectionError);
            *pNewLastConnectionError = NULL;
        }

    } 

    return hr;
}

HRESULT CWANConnectionBase::GetNATRSIPStatus(VARIANT_BOOL* pNewRSIPAvailable, VARIANT_BOOL* pNewNATEnabled)
{
    HRESULT hr = S_OK;

    hr = get_RSIPAvailable(pNewRSIPAvailable);
    if(SUCCEEDED(hr))
    {
        hr = get_NATEnabled(pNewNATEnabled);
    }

    return hr;
}

HRESULT CWANConnectionBase::GetLinkLayerMaxBitRates(ULONG* pNewUpstreamMaxBitRate, ULONG* pNewDownstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = get_UpstreamMaxBitRate(pNewUpstreamMaxBitRate);
    if(SUCCEEDED(hr))
    {
        hr = get_DownstreamMaxBitRate(pNewDownstreamMaxBitRate);
    }

    return hr;
}

HRESULT 
CWANConnectionBase::GetGenericPortMappingEntry(
                                  USHORT        ulIndex,
                                  BSTR*         RemoteHostp,
                                  USHORT*       uExternalPortp,
                                  BSTR*         Protocolp,
                                  USHORT*       uInternalPortp,
                                  BSTR*         InternalClientp,
                                  VARIANT_BOOL* bEnabledp,
                                  BSTR*         Descriptionp,
                                  ULONG*        ulLeaseDurationp
                                 )       
{
    HRESULT                     hr                 = S_OK;
    IHNetPortMappingProtocol*   MappingProtocolp   = NULL;
    IHNetPortMappingBinding*    Bindingp           = NULL;
    USHORT BoundaryPort = 0, InternalPort = 0;

    _ASSERT ( RemoteHostp      != NULL );
    _ASSERT ( uExternalPortp   != NULL );
    _ASSERT ( Protocolp        != NULL );
    _ASSERT ( uInternalPortp   != NULL );
    _ASSERT ( InternalClientp  != NULL );
    _ASSERT ( bEnabledp        != NULL );
    _ASSERT ( Descriptionp     != NULL );
    _ASSERT ( ulLeaseDurationp != NULL );

    //
    // In/Out Parameters to COM Interfaces needs cleanup
    //
    SysFreeString(*RemoteHostp);
    SysFreeString(*Protocolp);
    SysFreeString(*InternalClientp);
    SysFreeString(*Descriptionp);

    *RemoteHostp         = NULL;
    *Protocolp           = NULL;
    *InternalClientp     = NULL;
    *Descriptionp        = NULL;
    
    *ulLeaseDurationp    = 0;

    DBG_SPEW(TM_INFO, TL_TRACE, L"> GetGenericPortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) 
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Control Disabled returning E(%X)", hr);
        return hr; 
    }
    
    do
    {
        //
        // SECURITY - SECURITY - SECURITY
        // Here we're allowing the out-of-proc COM call
        // into our service to have SYSTEM access rights.
        //
        // REASON: UPnP works in LOCAL_SERVICE and COM
        //         Calls into our service which modify
        //         the WMI repository will FAIL. This
        //         Call alleviates that problem by changing
        //         The Security to that of the SYSTEM
        //         and is reverted back when the class
        //         is out of scope by the destructor of.
        //         CSwitchSecurityContext 
        //
        CSwitchSecurityContext SwSecCxt;
        
        hr = SearchPortMapping(m_IcsSettingsp,
                               ulIndex,
                               0,
                               0,
                               &MappingProtocolp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Seeking the port has failed E(%X)", hr);
            SetUPnPError(L"713"); 
            break;
        }

        //
        // Getting the binding - is this how it should be?
        //
        hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(MappingProtocolp,
                                                                    &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Error In Getting Binding for Protocol E(%X)", hr);

            break;
        }


        hr = FillStaticMappingInformation(MappingProtocolp,
                                          Bindingp,
                                          &BoundaryPort,
                                          Protocolp,
                                          &InternalPort,
                                          InternalClientp,
                                          bEnabledp,
                                          Descriptionp);

        _ASSERT( SUCCEEDED(hr) );

        if ( SUCCEEDED(hr) ) // correct the port Byte Ordering
        {
            *uExternalPortp = ntohs( BoundaryPort );
            *uInternalPortp = ntohs( InternalPort );
        }
        else
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Error In Getting Binding for Protocol E(%X)" , hr);
        }
    
    } while ( FALSE );

    if ( MappingProtocolp != NULL) MappingProtocolp->Release();

    if ( Bindingp != NULL ) Bindingp->Release();

    if ( FAILED(hr) )
    {
        DBG_SPEW(TM_INFO, TL_ERROR, 
                 L"Enum - GetGenericEntry has failed with E(%X)", hr);    
    }
    
    return hr;
} // GetArrayEntry

HRESULT 
CWANConnectionBase::GetSpecificPortMappingEntry(
                                   IN  BSTR          RemoteHost,
                                   IN  USHORT        uwExternalPort,
                                   IN  BSTR          Protocol,
                                   OUT USHORT*       puwInternalPort,
                                   OUT BSTR*         InternalClientp,
                                   OUT VARIANT_BOOL* pbEnabled,
                                   OUT BSTR*         Descriptionp,
                                   OUT ULONG*        pulLeaseDuration
                                  )
//
// Note that every port is expected to arrive in HOST order 
// and will be returned in HOST order
//
{
    HRESULT                     hr                  = S_OK;
    IHNetPortMappingProtocol*   MappingProtocolp    = NULL;
    IHNetPortMappingBinding*    Bindingp            = NULL;
    USHORT tempExtPort = 0, tempIntPort = 0;
    UCHAR                       searchProtocol      = NULL;

    _ASSERT( RemoteHost     != NULL );
    _ASSERT( uwExternalPort != 0    );
    _ASSERT( Protocol       != NULL );

    SysFreeString( *InternalClientp );
    SysFreeString( *Descriptionp );

    *InternalClientp = NULL;
    *Descriptionp    = NULL;

    tempExtPort = htons( uwExternalPort ); // flip to Network order

    DBG_SPEW(TM_INFO, TL_TRACE, L"> GetSpecificPortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) 
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Control is Disabled E(%X)", hr);
        return hr; 
    }
    
    if ( 0 == uwExternalPort)
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Parameters Incorrect Port(%hu)", uwExternalPort );
        SetUPnPError(L"402");
        return E_INVALIDARG;
    }


    do
    {
        //
        // SECURITY - SECURITY - SECURITY
        // Here we're allowing the out-of-proc COM call
        // into our service to have SYSTEM access rights.
        //
        // REASON: UPnP works in LOCAL_SERVICE and COM
        //         Calls into our service which modify
        //         the WMI repository will FAIL. This
        //         Call alleviates that problem by changing
        //         The Security to that of the SYSTEM
        //         and is reverted back when the class
        //         is out of scope by the destructor of.
        //         CSwitchSecurityContext 
        //
        CSwitchSecurityContext SwSecCxt;

    //
    // Resolve the Protocol to the appropriate enum.
    //
        RESOLVE_PROTOCOL_TYPE(searchProtocol, Protocol);

        DBG_SPEW(TM_INFO, TL_INFO, 
                 L"Search Specific - ExtPort (%hu) Protocol (%s)",
                 htons( tempExtPort ), 
                 (NAT_PROTOCOL_TCP == searchProtocol)?L"TCP":L"UDP");

        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               searchProtocol,
                               &MappingProtocolp);

        if ( FAILED(hr))
        {
            DBG_SPEW(TM_INFO, TL_ERROR, L"Error or can't get Search E(%X)", hr);
            SetUPnPError(L"714");
            break;
        }
        
        //
        // Getting the binding 
        //
        hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(MappingProtocolp,
                                                                    &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Error In Getting Binding for Protocol E(%X)", hr);

            break;
        }


        hr = FillStaticMappingInformation(MappingProtocolp,
                                          Bindingp,
                                          &tempExtPort,
                                          &Protocol,
                                          &tempIntPort,
                                          InternalClientp,
                                          pbEnabled,
                                          Descriptionp);
        _ASSERT( SUCCEEDED(hr) );

        *puwInternalPort = ntohs( tempIntPort );
        
        DBG_SPEW(TM_INFO, TL_TRACE,
                 L"Returning IntClient (%s) IntPort (%hu) IntProtocol (%s), Enabled (%s), Desc (%s)",
                 *InternalClientp,
                 *puwInternalPort,
                 Protocol,
                 (*pbEnabled == VARIANT_TRUE)?L"TRUE":L"FALSE",
                 *Descriptionp);

    
    } while ( FALSE );

    if ( MappingProtocolp != NULL)  MappingProtocolp->Release();

    if ( Bindingp != NULL ) Bindingp->Release();

    if ( FAILED(hr) )
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Error or can't get Search Done E(%X)", hr);
    }

    return hr;
}


HRESULT
CWANConnectionBase::AddPortMapping(
                                   BSTR         RemoteHost,
                                   USHORT       uwExternalPort,  
                                   BSTR         Protocol,
                                   USHORT       uwInternalPort,  
                                   BSTR         InternalClient,  
                                   VARIANT_BOOL bEnabled,        
                                   BSTR         Description,     
                                   ULONG        ulLeaseDuration
                                  )
{
    HRESULT       hr           = S_OK;
    MAPPING_TYPE  MappingType  = ePortMappingInvalid;

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> AddPortMapping");

    //
    // Check for Access status
    hr = this->ControlEnabled();

    if ( SUCCEEDED(hr) )
    {
        hr = ValidatePortMappingParameters(RemoteHost,
                                           uwExternalPort,
                                           Protocol,
                                           uwInternalPort,
                                           InternalClient,
                                           bEnabled,
                                           Description,
                                           ulLeaseDuration,
                                           &MappingType);

        if ( SUCCEEDED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_TRACE, 
                     L"Add PortMapping - ExtPort (%hu) Protocol (%s)",
                     uwExternalPort, Protocol);

            DBG_SPEW(TM_STATIC, TL_TRACE,
                     L"IntClient (%s) IntPort (%hu)  Enabled (%s), Desc (%s)",
                     InternalClient,
                     uwInternalPort,
                     (bEnabled == VARIANT_TRUE)?L"TRUE":L"FALSE",
                     Description);

            if ( ePortMappingStatic == MappingType )
            {
                //
                // SECURITY - SECURITY - SECURITY
                // Here we're allowing the out-of-proc COM call
                // into our service to have SYSTEM access rights.
                //
                // REASON: UPnP works in LOCAL_SERVICE and COM
                //         Calls into our service which modify
                //         the WMI repository will FAIL. This
                //         Call alleviates that problem by changing
                //         The Security to that of the SYSTEM
                //         and is reverted back when the class
                //         is out of scope by the destructor of.
                //         CSwitchSecurityContext 
                //
                CSwitchSecurityContext SwSecCxt;

                hr = AddStaticPortMapping(RemoteHost,
                                          uwExternalPort,
                                          Protocol,
                                          uwInternalPort,
                                          InternalClient,
                                          bEnabled,
                                          Description,
                                          ulLeaseDuration);
            }
            else
            {
                hr = AddDynamicPortMapping(RemoteHost,
                                           uwExternalPort,
                                           Protocol,
                                           uwInternalPort,
                                           InternalClient,
                                           bEnabled,
                                           Description,
                                           ulLeaseDuration);
            }
        }
    }
    else
    { 
        DBG_SPEW(TM_STATIC, TL_ERROR, L"Control Disabled E(%X)", hr);
    }

    return hr;
}

HRESULT
CWANConnectionBase::AddDynamicPortMapping(
                                          BSTR         RemoteHost,
                                          USHORT       uwExternalPort,  
                                          BSTR         Protocol,
                                          USHORT       uwInternalPort,  
                                          BSTR         InternalClient,  
                                          VARIANT_BOOL bEnabled,        
                                          BSTR         Description,     
                                          ULONG        ulLeaseDuration
                                         )
{
    
    //
    // We currently don't handle any Dynamic Port Redirections.
    //
    DBG_SPEW(TM_DYNAMIC, TL_ERROR, L"Only Static Mappings are allowed [Lease]");

    SetUPnPError(L"725");

    return E_INVALIDARG;
}

HRESULT
CWANConnectionBase::AddStaticPortMapping(
                                         BSTR         RemoteHost,
                                         USHORT       uwExternalPort,  
                                         BSTR         Protocol,
                                         USHORT       uwInternalPort,  
                                         BSTR         InternalClient,  
                                         VARIANT_BOOL bEnabled,        
                                         BSTR         Description,     
                                         ULONG        ulLeaseDuration
                                        )
{
    HRESULT                      hr                    = S_OK;
    UCHAR                        ProtocolType          = 0;
    IHNetProtocolSettings*       ProtocolSettingsp     = NULL;
    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;
    IHNetPortMappingBinding*     PortMappingBindingp   = NULL;
    ULONG                        ClientAddr            = 0;
    BOOLEAN                      bLetsEnable           = FALSE;
    BOOLEAN                      bCreatedProtocol      = FALSE;
    ULONG                        tempStrLen            = 0;
    WCHAR                        tempPortStr[]         = L"00000";
    LPOLESTR                     tempStr               = NULL;
    USHORT                       tempExtPort = 0, tempIntPort = 0;
    BSTR ProtocolFromBinding       = NULL;
    BSTR ClientFromBinding         = NULL;
    BSTR DescriptionFromBinding    = NULL;
    VARIANT_BOOL boolEnabled;




    _ASSERT( uwExternalPort );
    _ASSERT( uwInternalPort );

    //
    // Convert both ends to Network Order
    //
    tempExtPort       = htons( uwExternalPort );
    tempIntPort       = htons( uwInternalPort );


    //
    // Convert VARIANT_BOOL to boolean
    //
    bLetsEnable = ( bEnabled == VARIANT_TRUE );

    //
    // Process the Operation
    //
    do
    {
        RESOLVE_PROTOCOL_TYPE(ProtocolType, Protocol);

        //
        // IF there is no description crate one
        // using PORT and PROTOCOL
        //
        if ( wcscmp(Description, L"\0") == 0 ) 
        {   
            // Get Internal ClientName + the seperator
            tempStrLen = ( SysStringLen( InternalClient ) + 1 ); 
    
            // Get port len + plus the seperator
            _itow ( uwExternalPort, tempPortStr, 10);
    
            tempStrLen += (wcslen (tempPortStr) + 1);

            // Get Protocol Name
            tempStrLen += SysStringLen( Protocol );

    
            // Create out from these two
            tempStr = (LPOLESTR)CoTaskMemAlloc( (tempStrLen + 1) * sizeof(WCHAR) );
    
            if ( tempStr != NULL )
            {

                _snwprintf(tempStr, tempStrLen, L"%s-%s-%s", 
                           InternalClient, tempPortStr, Protocol);

                tempStr[ tempStrLen ] = L'\0';

                Description = SysAllocString ( tempStr );
            }
            
            if ( (tempStr == NULL) || (Description == NULL) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Initialize Strings - out of mem");

                hr = E_OUTOFMEMORY;

                break;
            }
        }


        //
        // Find Existing Mapping
        //
        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               ProtocolType,
                               &PortMappingProtocolp);
        //
        // if found it is in Edit Mode.
        //
        if ( SUCCEEDED(hr) )
        {

            hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                        &PortMappingBindingp);

            _ASSERT( SUCCEEDED(hr) );

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Can't get Binding for Port Mapping E(X)", hr);
                _ASSERT( FALSE );
                break;
            }

            //
            // Fill the information 
            //
            hr = FillStaticMappingInformation(PortMappingProtocolp,
                                              PortMappingBindingp,
                                              &tempExtPort, 
                                              &ProtocolFromBinding, 
                                              &tempIntPort,
                                              &ClientFromBinding,
                                              &boolEnabled,
                                              &DescriptionFromBinding);

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Filling has failed for Mapping Information E(%X)", hr);
                break;
            }
                                        
            //
            // If the existin Mapping was disabled we should be able to change
            // the Internal Client
            //
            if ( boolEnabled == VARIANT_TRUE )
            {
                if ( _wcsicmp( InternalClient, ClientFromBinding) != 0 ) // if diff then error
                {
                    hr = E_INVALIDARG;
                    DBG_SPEW(TM_STATIC, TL_ERROR, 
                             L"Will not change the internal client for an enabled PortMapping");
                    SetUPnPError(L"718");
                    break;
                }
            }

            //
            // if the Internal Port has changed reflect the change
            //
            if ( tempIntPort != htons( uwInternalPort ) )
            {
                tempIntPort = htons( uwInternalPort );

                hr = PortMappingBindingp->SetTargetPort( tempIntPort ); 

                _ASSERT( SUCCEEDED(hr) );

                if ( FAILED(hr) )
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Changin Internal Port has Failed E(%X)", hr);
                    break;
                }
            }

            //
            // Set the description if changed
            //
            if ( _wcsicmp(DescriptionFromBinding, Description) != 0)
            {
                hr = PortMappingProtocolp->SetName(Description);
                if ( FAILED(hr) )
                {
                    hr = E_INVALIDARG;
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Set Name has failed E(%X)", hr);
                    break;
                }
            }
        }
        else
        {
            //
            // Start Getting the Interface
            //
            hr = m_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                                reinterpret_cast<void**>(&ProtocolSettingsp));

            if ( SUCCEEDED(hr) )
            {
                hr = ProtocolSettingsp->CreatePortMappingProtocol(Description,
                                                                  ProtocolType,
                                                                  tempExtPort,
                                                                  &PortMappingProtocolp);

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                                &PortMappingBindingp);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = PortMappingBindingp->SetTargetPort( tempIntPort );

                        _ASSERT( SUCCEEDED(hr) );

                        if ( FAILED(hr) )
                        {
                            DBG_SPEW(TM_STATIC, TL_ERROR, L"Set Target Port has Failed E(%X)", hr);
                        }
                        
                        bCreatedProtocol = TRUE;

                    }
                    else
                    {
                        DBG_SPEW(TM_STATIC, TL_ERROR, 
                                 L"Getting Binding has Failed E(X)", hr);
                        PortMappingProtocolp->Delete();
                        break;
                    }
                }
                else
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, 
                             L"Creating the PortMapping has Failed E(%X)", hr);
                    break;
                }

            }
            else
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Getting the Protocol Settings has failed E(X)", hr);
                break;
            }
        }

        //
        // Setting the Client name / address
        // For Edit mode we already checked wether this code will be run or not.
        //
        if ( 
            ( wcscmp(L"0.0.0.0", InternalClient) != 0 ) &&
            ( InternalClient[0] != L'\0' )
           )
        {
            ClientAddr = INET_ADDR((LPOLESTR) InternalClient );

            //
            // if the address is not valid (INADDR_NONE)
            // and if the address is different than Broadcast address (which also is INADDR_NONE)
            //
            if ( (ClientAddr == INADDR_NONE) && wcscmp(L"255.255.255.255", InternalClient) )
            {
                hr = PortMappingBindingp->SetTargetComputerName( InternalClient );
            }
            else
            {
                hr = PortMappingBindingp->SetTargetComputerAddress( ClientAddr );
            }

            _ASSERT( SUCCEEDED(hr) );

            if ( SUCCEEDED(hr) )
            {
                hr = PortMappingBindingp->SetEnabled( bLetsEnable );
            }

            if ( FAILED(hr) ) DBG_SPEW(TM_STATIC, TL_ERROR, L"Client Add/Edit IntClient failed - E(%X)", hr);
        }

        if ( FAILED(hr) && (TRUE == bCreatedProtocol) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Client Add / Edit failed - E(%X)", hr);
            hr = PortMappingProtocolp->Delete();
        }

    } while ( FALSE );

    if ( tempStr != NULL) 
    {
        CoTaskMemFree ( tempStr );
        SysFreeString ( Description ); // you can free a NULL string.
    }

    if ( ProtocolFromBinding )    SysFreeString(ProtocolFromBinding);

    if ( ClientFromBinding )      SysFreeString(ClientFromBinding);

    if ( DescriptionFromBinding ) SysFreeString(DescriptionFromBinding);
                                
    if ( PortMappingBindingp != NULL ) PortMappingBindingp->Release();

    if ( PortMappingProtocolp != NULL ) PortMappingProtocolp->Release();

    if ( ProtocolSettingsp != NULL ) ProtocolSettingsp->Release();

    if ( FAILED(hr) ) { DBG_SPEW(TM_STATIC, TL_ERROR, L"Error Returning hr (%X)", hr); }

    return hr;
} // CWANConnectionBase :: AddStaticPortMapping






HRESULT 
CWANConnectionBase::DeletePortMapping(
                                      BSTR      RemoteHost,
                                      USHORT    uwExternalPort, 
                                      BSTR      Protocol
                                     )
{
    HRESULT hr = S_OK;

    UCHAR                        ProtocolType          = 0;

    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;

    USHORT                       tempExtPort              = 0;

    //
    // SECURITY - SECURITY - SECURITY
    // Here we're allowing the out-of-proc COM call
    // into our service to have SYSTEM access rights.
    //
    // REASON: UPnP works in LOCAL_SERVICE and COM
    //         Calls into our service which modify
    //         the WMI repository will FAIL. This
    //         Call alleviates that problem by changing
    //         The Security to that of the SYSTEM
    //         and is reverted back when the class
    //         is out of scope by the destructor of.
    //         CSwitchSecurityContext 
    //
    CSwitchSecurityContext SwSecCxt;


    _ASSERT( RemoteHost     != NULL );
    _ASSERT( uwExternalPort != 0    );
    _ASSERT( Protocol       != NULL );

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> DeletePortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) { return hr; }
    
    //
    // Convert to Network order
    // 
    tempExtPort = htons(uwExternalPort );

    DBG_SPEW(TM_STATIC, TL_INFO, 
             L"Search Specific - ExtPort (%hu) Protocol (%s)",
             uwExternalPort, Protocol);
    

    do
    {
        RESOLVE_PROTOCOL_TYPE( ProtocolType, Protocol );

        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               ProtocolType,
                               &PortMappingProtocolp);
        
        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Error in Searching E(%X)", hr );
            SetUPnPError(L"714"); 
            break;
        }

        hr = PortMappingProtocolp->Delete();

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"ProtocolMapping deletion failure, Might be Built in E(%X)", hr );
        }
        
        PortMappingProtocolp->Release();

    } while ( FALSE );


    if ( FAILED(hr) ) DBG_SPEW(TM_STATIC, TL_ERROR, L"Delete failed with hr - %X", hr);

    return hr;
}

HRESULT CWANConnectionBase::GetExternalIPAddress(BSTR* pExternalIPAddress)
{
    HRESULT hr = S_OK;

    SysFreeString(*pExternalIPAddress);
    *pExternalIPAddress = NULL;

    hr = get_ExternalIPAddress(pExternalIPAddress);

    return hr;
}



HRESULT CWANConnectionBase::ControlEnabled()
{
    HRESULT hr = S_OK;

    // check the reg key.  Only disable if key exists and is 0.  

    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS == dwError) // if this fails we assume it is on, set the box, and commit on apply
    {
        DWORD dwType;
        DWORD dwData = 0;
        DWORD dwSize = sizeof(dwData);
        dwError = RegQueryValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, &dwType, reinterpret_cast<LPBYTE>(&dwData), &dwSize);
        if(ERROR_SUCCESS == dwError && REG_DWORD == dwType && 0 == dwData)
        {
            hr = E_ACCESSDENIED;
        }
        RegCloseKey(hKey);
    }

    return hr;
}



HRESULT
SearchPortMapping(
                  IN          IHNetIcsSettings*           IcsSettingsp,
                  IN OPTIONAL ULONG                       searchIndex,
                  IN OPTIONAL USHORT                      searchPort,
                  IN OPTIONAL UCHAR                       searchProtocol,
                  OUT         IHNetPortMappingProtocol    **Protocolpp
                 )
//
// Two ways of Seeking an entry..
// 1) By Index.. Enumerate until you hit the giventh Index.
// 2) Seeks and retrieves Port and ProtocolType
//
{
    HRESULT                         hr                    = S_OK;

    IHNetProtocolSettings*          ProtocolSettingsp     = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp        = NULL;

    IHNetPortMappingProtocol*       tempProtocolp             = NULL;

    USHORT                          ProtocolPort          = 0;

    UCHAR                           ProtocolType          = 0;

    BOOLEAN                         bFound                = FALSE;

    ULONG                           iIndex                = 0;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SearchPortMapping ");


    //
    // Index = 0 is a valid search
    // searchPort and searcProtocol should exist both or not.
    //
    _ASSERT( !((searchPort == NULL) ^  (searchProtocol == 0)) );
    

    _ASSERT( IcsSettingsp != NULL );
    _ASSERT( Protocolpp   != NULL );


    do
    {
        hr = IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Query Interface failed for ProtocolSettingsp E(%X)", hr);
            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Enum Interface can't be retrieved E(%X)", hr);
            break;
        }

        while( (FALSE == bFound) &&
               (S_OK == EnumProtocolsp->Next(1, &tempProtocolp, NULL)) )
        {
            if ( searchPort != 0 )
            {
                hr = tempProtocolp->GetPort( &ProtocolPort );

                if ( SUCCEEDED(hr) )
                {
                    hr = tempProtocolp->GetIPProtocol(&ProtocolType);
                }
                
                if( FAILED(hr) )
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Search info Failure E(%X)", hr);
                }
                else if((searchPort == ProtocolPort) &&
                        (ProtocolType == searchProtocol))
                {       
                    bFound = TRUE;
                }
            }
            else // if the search key == the Index
            {
                if ( iIndex == searchIndex )
                {
                    bFound = TRUE;
                }
            }
            
            //
            // if Nothing is found
            if (FALSE == bFound) 
            {
                tempProtocolp->Release();
            }
            
            iIndex++;
        }

        EnumProtocolsp->Release();

    } while ( FALSE );

    if(ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    if( (bFound == TRUE)     &&
        (tempProtocolp != NULL))
    {
        *Protocolpp = tempProtocolp;
    }
    else
    {
        return E_INVALIDARG;
    }

    return hr;
}


HRESULT
FillStaticMappingInformation(
                             IN          IHNetPortMappingProtocol*  MappingProtocolp,
                             IN OPTIONAL IHNetPortMappingBinding*   Bindingp,
                             OUT         PUSHORT                    uExternalPortp,
                             OUT         BSTR*                      Protocolp,
                             OUT         PUSHORT                    uInternalPortp,
                             OUT         BSTR*                      InternalClientp,
                             OUT         VARIANT_BOOL*              bEnabledp,
                             OUT         BSTR*                      Descriptionp
                            )
//
// Note that Will return the port in Network Byte Order
//
{
    HRESULT                     hr                 = S_OK;
    
    UCHAR                       ProtocolType       = NULL;
    LPOLESTR                    szInternalHostAddr = NULL;
    LPOLESTR                    szDescription      = NULL;
    BOOLEAN                     bEnabled           = FALSE;
    BOOLEAN                     bUseName           = FALSE;
    ULONG                       InternalHostAddr   = 0;
    

    _ASSERT ( uExternalPortp   != NULL );
    _ASSERT ( Protocolp        != NULL );
    _ASSERT ( InternalClientp  != NULL );
    _ASSERT ( bEnabledp        != NULL );
    _ASSERT ( Descriptionp     != NULL );
    _ASSERT ( MappingProtocolp != NULL );
    _ASSERT ( Bindingp         != NULL );

    *uExternalPortp  = 0;
    *Protocolp       = NULL;
    *InternalClientp = NULL;
    *bEnabledp       = VARIANT_FALSE;
    *Descriptionp    = NULL;

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> FillStaticMappingInformation");

    do
    {
        //
        // Description
        //
        hr = MappingProtocolp->GetName(&szDescription);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Getting the Name has failed E(%X)", hr);
            break;
        }

        BOOLEAN fBuiltin = FALSE;

        hr = MappingProtocolp->GetBuiltIn( &fBuiltin );

        _ASSERT( SUCCEEDED(hr) );

        if ( fBuiltin ) 
        {
            #define BUILTIN_KEY L" [MICROSOFT]"
            
            UINT uiLength  = wcslen(szDescription );
            uiLength      += wcslen(BUILTIN_KEY);
            *Descriptionp = SysAllocStringLen(NULL, uiLength);

            if ( *Descriptionp ) 
            {
                wcscpy (*Descriptionp, szDescription);
                wcscat (*Descriptionp, BUILTIN_KEY);
            }
        } 
        else 
        {
            *Descriptionp = SysAllocString(szDescription);
        }

        if(*Descriptionp == NULL)
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Memory Allocation for Description has Failed");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Protocol
        //
        hr = MappingProtocolp->GetIPProtocol(&ProtocolType);

        _ASSERT( SUCCEEDED(hr) );

        if ( ProtocolType == NAT_PROTOCOL_TCP )
        {
            *Protocolp = SysAllocString(L"TCP");
        }
        else if ( ProtocolType == NAT_PROTOCOL_UDP )
        {
            *Protocolp = SysAllocString(L"UDP");
        } 
        else
        {
            _ASSERT( FALSE );
        }

        if (*Protocolp == NULL)
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Memory Allocation for Description has Failed");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // External Port
        //
        hr = MappingProtocolp->GetPort( uExternalPortp );


        _ASSERT( SUCCEEDED(hr) );

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR,
                     L"GetPort for Protocol has failed E(%X)", hr);
            break;
        }

        // Getting the Binding Information
        if ( Bindingp != NULL )
        {
            //
            // Enabled
            hr = Bindingp->GetEnabled(&bEnabled);

            _ASSERT( SUCCEEDED(hr) );

            if ( bEnabled == TRUE)
            {
                *bEnabledp = VARIANT_TRUE;
            }
            else
            {
                *bEnabledp = VARIANT_FALSE;
            }

            hr = Bindingp->GetTargetPort( uInternalPortp );

            _ASSERT( SUCCEEDED(hr) );

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR,
                         L"GetPort for Binding has  failed E(%X)", hr);

                break;
            }

            //
            // InternalClient
            hr = Bindingp->GetCurrentMethod(&bUseName);

            if( SUCCEEDED(hr) )
	        {
                if ( bUseName == TRUE)
                {
                    hr = Bindingp->GetTargetComputerName(&szInternalHostAddr);
    
                    if ( FAILED(hr) )
                    {
                        break;
                    }
    
                    _ASSERT( SUCCEEDED(hr) );
                }
                else
                {
                    hr = Bindingp->GetTargetComputerAddress(&InternalHostAddr);
    
                    _ASSERT( SUCCEEDED(hr) );
    
                    if ( FAILED(hr) )
                    {
                        break;
                    }
    
                    //
                    // IF the address is Loopback change it to a name which would make more
                    // sense to any client who sees it.
                    //
                    if ( INADDR_LOOPBACK == htonl(InternalHostAddr) )
                    {
                        ULONG uCount = 0;
    
                        if ( 0 == GetComputerNameEx( ComputerNameDnsHostname, NULL, &uCount) )
                        {
                            if ( (ERROR_MORE_DATA == GetLastError()) )
                            {
                                szInternalHostAddr = 
                                    (LPOLESTR) CoTaskMemAlloc( uCount * sizeof(WCHAR) );
    
                                if ( NULL != szInternalHostAddr )
                                {
                                    if (!GetComputerNameEx(ComputerNameDnsHostname,
                                                           szInternalHostAddr,
                                                           &uCount))
                                    {
                                        hr = HRESULT_FROM_WIN32( GetLastError() );
    
                                        break;
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
    
                                    break;
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
    
                                break;
                            }
                        }
                    }
                    else if ( 0 != InternalHostAddr )
                    {
                        szInternalHostAddr = INET_NTOW_TS( InternalHostAddr );
                    }
                    else
                    {
                        szInternalHostAddr = (LPOLESTR) CoTaskMemAlloc( sizeof(WCHAR) );
    
                        if ( NULL != szInternalHostAddr) szInternalHostAddr[0] = 0;
                    }
    
                    if ( szInternalHostAddr == NULL )
                    {
                        hr = E_OUTOFMEMORY;
    
                        break;
                    }
                } // if Name method
        	}

            *InternalClientp = SysAllocString( szInternalHostAddr );

            if ( *InternalClientp == NULL)
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"Mem Allocation for Internal Client Name");

                hr = E_OUTOFMEMORY;

                break;
            }
        } // if bindingp

    } while ( FALSE );

    if ( szDescription )        CoTaskMemFree( szDescription );
    
    if ( szInternalHostAddr )   CoTaskMemFree( szInternalHostAddr );

    if ( FAILED(hr) )
    {
        if(*Protocolp)       { SysFreeString(*Protocolp);       *Protocolp = NULL; }

        if(*InternalClientp) { SysFreeString(*InternalClientp); *InternalClientp = NULL;}

        if(*Descriptionp)    { SysFreeString(*Descriptionp);   *Descriptionp = NULL;}
    }
    
    return hr;
}


inline HRESULT
ValidatePortMappingParameters
(
 IN  BSTR          RemoteHost,
 IN  USHORT        uwExternalPort,
 IN  BSTR          Protocol,
 IN  USHORT        uwInternalPort,
 IN  BSTR          InternalClient,
 IN  VARIANT_BOOL  bEnabled,
 IN  BSTR          Description,
 IN  ULONG         ulLeaseDuration,
 OUT MAPPING_TYPE* pMappingType
)
//
// Decide wether a Mapping is to be dynamic or static
// Validate the parameters pre-emptively
//
{
    MAPPING_TYPE  MappingType   = ePortMappingInvalid;

    _ASSERT( RemoteHost     != NULL );
    _ASSERT( Protocol       != NULL );
    _ASSERT( Protocol[0]    != 0    );
    _ASSERT( Description    != NULL );
    _ASSERT( uwInternalPort != 0    );
    _ASSERT( pMappingType   != NULL );
    _ASSERT( InternalClient != NULL );
    _ASSERT( RemoteHost[0]  == 0    );


    //
    // An Internal Port as well as an external Port should exist all time
    //
    if ( (0 == uwInternalPort) || (0 == uwExternalPort) )
    {
        SetUPnPError(L"716");

        return E_INVALIDARG;
    }

    //
    // is this a dynamic request?
    //
    if ( 0 != ulLeaseDuration )
    {
        MappingType = ePortMappingDynamic;
    }                                     
    else
    {
        MappingType = ePortMappingStatic;
    }


    //
    // A Dynamic Port Mapping needs to be with
    // an Internal Client
    // 
    if (
        ( ePortMappingDynamic == MappingType ) &&
        ( InternalClient[0] == L'\0' )
       )
    {
        SetUPnPError(L"402");

        return E_INVALIDARG;
    }

    //
    // A remote Host is defined.. we can't process this
    // 
    if ( RemoteHost[0]  != L'\0' )
    {
        SetUPnPError(L"726");

        return E_INVALIDARG;
    }

    //
    // Check the bEnabled bool value
    //
    if ( (bEnabled != VARIANT_TRUE) && (bEnabled != VARIANT_FALSE) )
    {
        SetUPnPError(L"402");

        return E_INVALIDARG;
    }
    
    *pMappingType = MappingType;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanpotslinkconfigservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "netconp.h"
#include "netcon.h"
#include "ras.h"


class ATL_NO_VTABLE CWANPOTSLinkConfigService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<IWANPOTSLinkConfigService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWANPOTSLinkConfigService)
    COM_INTERFACE_ENTRY(IWANPOTSLinkConfigService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CWANPOTSLinkConfigService();

    HRESULT Initialize(INetConnection* pNetConnection);
    HRESULT FinalRelease(void);
    
    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);

    // IWANPOTSLinkConfigService
    STDMETHODIMP get_ISPPhoneNumber(BSTR* pISPPhoneNumber);    
    STDMETHODIMP get_ISPInfo(BSTR *pISPInfo);
    STDMETHODIMP get_LinkType(BSTR *pLinkType);
    STDMETHODIMP get_NumberOfRetries(ULONG *pNumberOfRetries);
    STDMETHODIMP get_DelayBetweenRetries(ULONG *pDelayBetweenRetries);

    STDMETHODIMP GetISPInfo(BSTR* pISPPhoneNumber, BSTR *pISPInfo, BSTR *pLinkType);
    STDMETHODIMP GetCallRetryInfo(ULONG* pNumberOfRetries, ULONG *pDelayBetweenRetries);

private:
    HRESULT GetRasEntry(RASENTRY** ppRasEntry);
    
    IUPnPEventSink* m_pEventSink;
    INetRasConnection* m_pNetRasConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanpppconnectionservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANPPPConnectionService.h"
#include "ndispnp.h"
#include "ras.h"
#include "rasuip.h"
#include "util.h"
#include "raserror.h"
#include "rasdlg.h"

CWANPPPConnectionService::CWANPPPConnectionService()
{
    m_dwLastConnectionError = 0;
}

HRESULT CWANPPPConnectionService::get_LastConnectionError(BSTR *pLastConnectionError)
{
    HRESULT hr = S_OK;
    
    LPOLESTR pszError = NULL;
    switch(m_dwLastConnectionError)
    {
    case 0:
        pszError = L"ERROR_NONE";
        break;
    case ERROR_PPP_TIMEOUT:
    case ERROR_REQUEST_TIMEOUT:
        pszError = L"ERROR_ISP_TIME_OUT"; 
        break;
//    case : // no mapping
//        pszError = L"ERROR_COMMAND_ABORTED"; 
//        break;
//    case : // no mapping
//        pszError = L"ERROR_NOT_ENABLED_FOR_INTERNET"; 
//        break;
    case ERROR_BAD_PHONE_NUMBER:
        pszError = L"ERROR_BAD_PHONE_NUMBER"; 
        break;
    case ERROR_USER_DISCONNECTION:
        pszError = L"ERROR_USER_DISCONNECT"; 
        break;
    case ERROR_REMOTE_DISCONNECTION:
        pszError = L"ERROR_ISP_DISCONNECT"; 
        break;
//    case : // no mapping
//        pszError = L"ERROR_IDLE_DISCONNECT"; 
//        break;
//    case : // no mapping
//        pszError = L"ERROR_FORCED_DISCONNECT"; 
//        break;
    case ERROR_SERVER_OUT_OF_RESOURCES:
        pszError = L"ERROR_SERVER_OUT_OF_RESOURCES"; 
        break;
    case ERROR_RESTRICTED_LOGON_HOURS:
        pszError = L"ERROR_RESTRICTED_LOGON_HOURS"; 
        break;
    case ERROR_ACCT_DISABLED:
        pszError = L"ERROR_ACCOUNT_DISABLED"; 
        break;
    case ERROR_ACCT_EXPIRED:
        pszError = L"ERROR_ACCOUNT_EXPIRED"; 
        break;
    case ERROR_PASSWD_EXPIRED:
        pszError = L"ERROR_PASSWORD_EXPIRED"; 
        break;
    case ERROR_AUTHENTICATION_FAILURE:
        pszError = L"ERROR_AUTHENTICATION_FAILURE"; 
        break;
    case ERROR_NO_DIALTONE:
        pszError = L"ERROR_NO_DIALTONE"; 
        break;
    case ERROR_NO_CARRIER:
        pszError = L"ERROR_NO_CARRIER"; 
        break;
    case ERROR_NO_ANSWER:
        pszError = L"ERROR_NO_ANSWER"; 
        break;
    case ERROR_LINE_BUSY:
        pszError = L"ERROR_LINE_BUSY"; 
        break;
    case ERROR_UNSUPPORTED_BPS:
        pszError = L"ERROR_UNSUPPORTED_BITSPERSECOND"; 
        break;
    case ERROR_TOO_MANY_LINE_ERRORS:
        pszError = L"ERROR_TOO_MANY_LINE_ERRORS"; 
        break;
    case ERROR_IP_CONFIGURATION:
        pszError = L"ERROR_IP_CONFIGURATION"; 
        break;
    default:
        pszError = L"ERROR_UNKNOWN";
        break;
    }
    
    *pLastConnectionError = SysAllocString(pszError);
    if(NULL == *pLastConnectionError)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPPPConnectionService::RequestConnection(void)
{
    HRESULT hr = S_OK;

    m_dwLastConnectionError = 0;
    
    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        DWORD dwErr;
        RASSHARECONN rsc;
        dwErr = RasQuerySharedConnection(&rsc);
        if(NO_ERROR == dwErr)
        {
            RASCREDENTIALSW rc;
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
            dwErr = RasGetCredentials(rsc.name.szPhonebookPath, rsc.name.szEntryName, &rc);
            if (NO_ERROR == dwErr) 
            {
                RASDIALEXTENSIONS rde;
                RASDIALPARAMSW rdp;

                ZeroMemory(&rde, sizeof(rde));
                rde.dwSize = sizeof(rde);
                rde.dwfOptions = RDEOPT_NoUser;
                
                ZeroMemory(&rdp, sizeof(rdp));
                rdp.dwSize = sizeof(rdp);
                lstrcpyW(rdp.szEntryName, rsc.name.szEntryName);
                lstrcpyW(rdp.szUserName, rc.szUserName);
                lstrcpyW(rdp.szDomain, rc.szDomain);
                lstrcpyW(rdp.szPassword, rc.szPassword);
                ZeroMemory(&rc, sizeof(rc)); // zero crendentials

                HRASCONN hrasconn = NULL;
                dwErr = RasDial(&rde, rsc.name.szPhonebookPath, &rdp, 0, NULL, &hrasconn);
                ZeroMemory(&rdp, sizeof(rdp)); // zero credentials
                
                if (E_NOTIMPL == dwErr)
                {
                    //
                    // This is possibly a Connection Manager connection since it's returning E_NOTIMPL,
                    // we should check the phonebook entry for the type and then call the RasDialDlg 
                    // with the RASDDFLAG_NoPrompt flag.
                    // 
                    RASDIALDLG info;
                    BOOL fRetVal = FALSE;
                    RASENTRY re;
                    DWORD dwRasEntrySize;
                    DWORD dwIgnore;
                    HINSTANCE hRasDlgDll = NULL;
                    FARPROC lpfnRasDialDlg = NULL;
                    typedef BOOL (*lpfnRasDialDlgFunc)(LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);
                    
                    ZeroMemory(&info, sizeof(info));
                    info.dwSize = sizeof(info);

                    ZeroMemory(&re, sizeof(re));
                    dwRasEntrySize = sizeof(re);
                    re.dwSize = dwRasEntrySize;

                    dwErr = RasGetEntryProperties(
                                      rsc.name.szPhonebookPath,
                                      rsc.name.szEntryName,
                                      &re,
                                      &dwRasEntrySize,
                                      NULL,
                                      &dwIgnore);

                    if (ERROR_SUCCESS == dwErr)
                    {
                        dwErr = ERROR_NOT_SUPPORTED;

                        //
                        // Check if this is a Connection Manager entry
                        //
                        if (RASET_Internet == re.dwType)
                        {
                            //
                            // Prevent the DialerDialog
                            //
                            info.dwFlags |= RASDDFLAG_NoPrompt;
                            
                            hRasDlgDll = LoadLibrary(L"RASDLG.DLL");
                            if (hRasDlgDll)
                            {
                                lpfnRasDialDlgFunc lpfnRasDialDlg = (lpfnRasDialDlgFunc)GetProcAddress(hRasDlgDll, "RasDialDlgW");

                                if (lpfnRasDialDlg)
                                {
                                    fRetVal = (BOOL)(lpfnRasDialDlg)(rsc.name.szPhonebookPath, rsc.name.szEntryName, NULL, &info );
                                    if (fRetVal)
                                    {
                                        dwErr = NO_ERROR;
                                    }
                                }
                                FreeLibrary(hRasDlgDll);
                                hRasDlgDll = NULL;
                            }
                        }
                    }
                }

                m_dwLastConnectionError = dwErr;
                
                if(NO_ERROR != dwErr)
                {
                    hr = E_FAIL;

                    if(NULL != hrasconn)
                    {
                        RasHangUp(hrasconn);
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        if(FAILED(hr))
        {
            SetUPnPError(DCP_ERROR_CONNECTIONSETUPFAILED);
        }

    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    
    return hr;
}

HRESULT CWANPPPConnectionService::ForceTermination(void)
{
    HRESULT hr = S_OK;

    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Disconnect();
            pNetConnection->Release();
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\cwanpppconnectionservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "resource.h"       // main symbols
#include "netconp.h"
#include "netcon.h"
#include "CWANConnectionBase.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANPPPConnectionService : 
    public CWANConnectionBase
{
public:

    CWANPPPConnectionService();

    STDMETHODIMP RequestConnection();
    STDMETHODIMP ForceTermination();
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError);

private:

    DWORD m_dwLastConnectionError;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\debug.h ===
//****************************************************************************
//
//  Module:     IPNATHLP.DLL
//  File:       debug.h
//  Content:    This file contains the debug definitions
//
//  Revision History:
//  
//  Date
//  -------- ---------- -------------------------------------------------------
//  03/06/01 savasg   Created
//
//****************************************************************************

#ifndef _BCON_DBG_H_
#define _BCON_DBG_H_
//
// Name of this overall binary
//

#define SZ_MODULE              L"Beacon" 
#define TRACE_FLAG_NEUTR       ((ULONG)0x08000000 | TRACE_USE_MASK)
#define BUF_SIZE               512

#define is ==


//****************************************************************************
//  Typedef's
//****************************************************************************

typedef struct _DEBUG_MODULE_INFO {
    ULONG dwModule;    
    ULONG dwLevel;    
    TCHAR  szModuleName[80];    
    TCHAR  szDebugKey[80];    
} DEBUG_MODULE_INFO, *PDEBUG_MODULE_INFO;


//****************************************************************************
//  Extern
//****************************************************************************



//
// Trace Modules
//

#define TM_DEFAULT      0
#define TM_STATIC       1
#define TM_INFO         2
#define TM_DYNAMIC      3


//
// Boolean value Module
//
#define TB_FILE         4  



//
// Trace Levels
//

#define TL_NONE         0
#define TL_CRIT         1
#define TL_ERROR        2
#define TL_INFO         3
#define TL_TRACE        4
#define TL_DUMP         5


#if DBG   // checked build




#ifndef _DEBUG // DEBUG_CRT is not enabled.

#undef _ASSERT
#undef _ASSERTE


#define _ASSERT(expr)                   \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("UPnP-Nat: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)
    
#define _ASSERTE(expr)                  \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("UPnP-Nat: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)
#endif // _DEBUG


    
    

#define DBG_SPEW DbgPrintEx

#else // DBG

#define DBG_SPEW DEBUG_DO_NOTHING

#endif // DBG


//************************************************************
//  Prototypes
//************************************************************

//void DbgPrintX(LPCSTR pszMsg, ...);

void DbgPrintEx(
                ULONG Module,
                ULONG ErrorLevel,
                LPOLESTR pszMsg,
                ...
               );

void  
DEBUG_DO_NOTHING(
                 ULONG Module,
                 ULONG ErrorLevel, 
                 LPOLESTR pszMsg,
                 ...
                );


void InitDebugger( void );

void DestroyDebugger( void );


LPOLESTR
AppendAndAllocateWString(
                         LPOLESTR oldString,
                         LPOLESTR newString
                        );




#endif // _BCON_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\dispimpl2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D I S P I M P L 2 . H 
//
//  Contents:   Implementation of IDispatch without dual interfaces
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

//  -IDelegatingDispImpl for implementing IDispatch by delegation
//   to another interface (typically a custom interface).
//
// These classes are useful because ATL's IDispatchImpl can
// only implement duals.
//
/////////////////////////////////////////////////////////////////////////////
//
// IDelegatingDispImpl: For implementing IDispatch in terms of another
// (typically custom) interface, e.g.:
//
// [oleautomation]
// interface IFoo : IUnknown
// {
//    ...
// }
//
// IDelegatingDispImpl implements all four IDispatch methods.
// IDelegatingDispImpl gets the IDispatch vtbl entries by deriving from
// IDispatch in addition to the implementation interface.
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo>
//
// In the case where the coclass is intended to represent a control,
// there is a need for the coclass to have a [default] dispinterface.
// Otherwise, some control containers (notably VB) throw arcane error when
// the control is loaded.  For a control that you intend to provide the
// custom interface and delegating dispatch mechanism, you will have to
// provide a dispinterface defined in terms of a custom interface like
// so:
//
// dispinterface DFoo
// {
//    interface IFoo;
// }
//
// coclass Foo
// {
//  [default] interface DFoo;
//  interface IFoo;
// };
//
// For every other situation, declaring a dispinterface in terms of a
// custom interface is not necessary to use IDelegatingDispatchImpl.
// However, if you'd like DFoo to be in the base class list (as needed
// for the caveat control), you may use DFoo as the base class instead
// of the default template argument IDispatch like so:
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo, &IID_IFoo, DFoo>
//

#pragma once
#ifndef INC_DISPIMPL2
#define INC_DISPIMPL2

/////////////////////////////////////////////////////////////////////////////
// IDelegatingDispImpl

template <class T, const IID* piid = &__uuidof(T), class D = IDispatch,
          const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
          WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDelegatingDispImpl : public T, public D
{
public:
    typedef tihclass _tihclass;

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {
        *pctinfo = 1;
        return S_OK;
    }

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {
        return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
    }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
        LCID lcid, DISPID* rgdispid)
    {
        return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }
    
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
    {
        // NOTE: reinterpret_cast because CComTypeInfoHolder makes the mistaken
        //       assumption that the typeinfo can only Invoke using an IDispatch*.
        //       Since the implementation only passes the itf onto
        //       ITypeInfo::Invoke (which takes a void*), this is a safe cast
        //       until the ATL team fixes CComTypeInfoHolder.
        return _tih.Invoke(reinterpret_cast<IDispatch*>(static_cast<T*>(this)),
                           dispidMember, riid, lcid, wFlags, pdispparams,
                           pvarResult, pexcepinfo, puArgErr);
    }

protected:
    static _tihclass _tih;

    static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    {
        return _tih.GetTI(lcid, ppInfo);
    }
};

template <class T, const IID* piid, class D, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tihclass
    IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tih =
    { piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0 };

#endif  // INC_DISPIMPL2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\debug.cpp ===
#include "pch.h"
#pragma hdrstop


#include <rtutils.h>
#include "tchar.h"

#include "debug.h"
//#include "ipnat.h"



//****************************************************************************
//  Global Parameters
//****************************************************************************
TCHAR g_szDebugKey[] = _T("SOFTWARE\\Microsoft\\Tracing\\Beacon\\Debug");


DEBUG_MODULE_INFO g_DebugInfo[] = {
    {TM_DEFAULT,  TL_CRIT,  _T("<default> "),  _T("DebugLevel")},   //
    {TM_STATIC,   TL_TRACE, _T("STATIC "),     _T("StaticDebugLevel")}, //
    {TM_INFO,     TL_TRACE, _T("INFO "),       _T("InfoDebugLevel")}, //
    {TM_DYNAMIC,  TL_TRACE, _T("DYN "),        _T("DynamicDebugLevel")}, //
    {TB_FILE,     TL_NONE,  _T("FILE "),       _T("LogToFile")}, //
};

WCHAR   g_szModule[]      = SZ_MODULE;

ULONG   g_uTraceId        = INVALID_TRACEID;

BOOLEAN bEnabled          = FALSE;



void 
DestroyDebugger(VOID) 
{
    if ( g_uTraceId != INVALID_TRACEID )
    {
        TraceDeregister(g_uTraceId);
        
        g_uTraceId = INVALID_TRACEID;
    }
}



void 
InitDebugger()
{
    HKEY        hkey;
    DWORD       dwType, cb;
    DWORD       dwLevel;
    int         iModule;         
    int         nModules;         

    
    
    //
    // Open the registry key that contains the debug configuration info
    //
    if (RegOpenKeyEx((HKEY) HKEY_LOCAL_MACHINE,
                     g_szDebugKey,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS) 
    {
        cb = sizeof(dwLevel);

        //
        // Enable Debugging
        bEnabled = TRUE;

        //
        // Initialize all the modules to the base value or their custom value
        //

        nModules = (sizeof(g_DebugInfo)/sizeof(DEBUG_MODULE_INFO));

        for (iModule=0; iModule < nModules; iModule++) 
        {

            //
            // Open each custom debug level if present
            //

            if ((RegQueryValueEx(hkey, 
                                 g_DebugInfo[iModule].szDebugKey,
                                 NULL, 
                                 &dwType, 
                                 (PUCHAR) 
                                 &dwLevel, 
                                 &cb) == ERROR_SUCCESS) && (dwType == REG_DWORD)) 
            {
                g_DebugInfo[iModule].dwLevel = dwLevel; 
            } 
            else 
            {
                g_DebugInfo[iModule].dwLevel = g_DebugInfo[TM_DEFAULT].dwLevel; 
            }
            
            if( (TB_FILE == iModule) &&
                (1 == dwLevel))
            {
                // Init the Trace Manager
                g_uTraceId = TraceRegister(g_szModule);

            }
        }

        RegCloseKey(hkey);
    } 
    else 
    {
        // Debug Key Doesn't exist
    }

    return;
}








//
// use _vsnwprintf instead
//
void  
DbgPrintEx(ULONG Module, ULONG ErrorLevel, LPOLESTR pszMsg, ...)
{
    va_list VaList;
	
    WCHAR msg[BUF_SIZE];
    
    int len = 0;

    if ( (bEnabled is TRUE) &&
        (ErrorLevel  <= g_DebugInfo[Module].dwLevel ))
    {
        len = swprintf(msg, L"%s-", g_szModule);

        wcscat(msg, g_DebugInfo[Module].szModuleName);

        len += wcslen(g_DebugInfo[Module].szModuleName);

        

        _vsnwprintf(&msg[len], 
                    BUF_SIZE,
                    pszMsg, 
                    (va_list)(&pszMsg + 1));

        wcscat(msg, L"\n");


        if ( g_uTraceId is INVALID_TRACEID )
        {
            OutputDebugString(msg);
        }
        else
        {
            TracePrintfExW(g_uTraceId, 
                            TRACE_FLAG_NEUTR,
                            L"%s",
                            msg); 
        }
    }
}

void  
DEBUG_DO_NOTHING(ULONG Module, ULONG ErrorLevel, LPOLESTR pszMsg, ...)
{
}


//
// UTILITY Functions
//



LPOLESTR
AppendAndAllocateWString(
                         LPOLESTR oldString,
                         LPOLESTR newString
                        )
{
    LPOLESTR retString = NULL;

    ULONG retStringSize = 0, oldStringSize = 0, newStringSize = 0;

    if ( oldString != NULL )
    {
        oldStringSize = wcslen( oldString );
    }

    if ( newString != NULL )
    {
        newStringSize = wcslen(newString);
    }

    
    retStringSize = oldStringSize + newStringSize + 1;

    retString = (LPOLESTR) CoTaskMemAlloc( retStringSize * sizeof(OLECHAR) );

    if(retString != NULL)
    {
        ZeroMemory(retString, retStringSize * sizeof(OLECHAR));

        if(oldString) 
        {
            wcscat(retString, oldString);

            CoTaskMemFree(oldString);

            oldString = NULL;
        }

        if(newString)
        { 
            wcscat(retString, oldString);
        }

        return retString;
    }

    return oldString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <wchar.h>

#include "beaconbase.h"
//#include "ncmem.h"
//#include "ncbase.h"
//#include "ncdebug.h"
//#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\main.cpp ===
#include "pch.h"
#pragma hdrstop
#include "upnphost.h"
#include <stdio.h>
#include "resource.h"
#include "CInternetGatewayDevice.h"
#include "..\idl\obj\i386\InternetGatewayDevice_i.c"

#include "CWANDevice.h"
#include "CWANCommonDevice.h"

CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

void Test()
{
    HRESULT hr = S_OK;

    IUPnPRegistrar* pRegistrar;
    hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
    if(SUCCEEDED(hr))
    {
        HRSRC hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDX_DESC_DOC), L"XML");
        if(hrsrc)
        {
            HGLOBAL hGlobal = LoadResource(GetModuleHandle(NULL), hrsrc);
            if(hGlobal)
            {
                void * pvData = LockResource(hGlobal);
                BSTR bstrData = NULL;
                if(pvData)
                {
                    long nLength = SizeofResource(GetModuleHandle(NULL), hrsrc);
                    wchar_t * sz = new wchar_t[nLength + 1];
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinterpret_cast<char*>(pvData), nLength, sz, nLength);
                    sz[nLength] = 0;
                    bstrData = SysAllocString(sz);
                    delete [] sz;
                }
                if(bstrData)
                {
                    BSTR bstrId = NULL;
                    BSTR bstrInitString = SysAllocString(L"Init");
                    BSTR bstrPath = SysAllocString(L"C:\\upnp\\");
                    
                    IUPnPDeviceControl* pDevice;
                    //hr = CoCreateInstance(CLSID_CInternetGatewayDevice, NULL, CLSCTX_INPROC, IID_IUPnPDeviceControl, reinterpret_cast<void**>(&pDevice));
                    
                    CComObject<CInternetGatewayDevice>* pDevice2;
                    hr = CComObject<CInternetGatewayDevice>::CreateInstance(&pDevice2);
                    
                    if(SUCCEEDED(hr))
                    {
                        pDevice = pDevice2;
                        pDevice->AddRef();
                    }
                       
                    if(SUCCEEDED(hr))
                    {
                        wchar_t szFilename[1024];
                        GetModuleFileName(NULL, szFilename, 1024);
                        ITypeLib * pTlb = NULL;
                        hr = LoadTypeLib(L"beacon.exe", &pTlb);
                        pTlb->Release();
                        if(FAILED(hr))
                        {
                            printf("type lib failed\n");
                        }
                    }
                    if(SUCCEEDED(hr))
                    {
                        
                        hr = pRegistrar->RegisterRunningDevice(
                            bstrData,
                            pDevice,
                            bstrInitString,
                            bstrPath,
                            10,
                            &bstrId);
                        if(FAILED(hr))
                        {
                            printf("rrd failed %x\n", hr);

                            IErrorInfo* pErrorInfo;
                            hr = GetErrorInfo(0, &pErrorInfo);
                            if(S_OK == hr)
                            {
                                BSTR pDesc;
                                hr = pErrorInfo->GetDescription(&pDesc);
                                if(SUCCEEDED(hr))
                                {
                                    wprintf(L"error desc %s\n", pDesc);
                                    SysFreeString(pDesc);
                                }
                            }

                            hr = E_FAIL;
                        }

                        printf("press q to exit, u to update connection status\n");
                        char buf[255];
                        
                        while(gets(buf))
                        {
                            if('q' == *buf)
                            {
                                break;
                            }
                            else if('u' == *buf)
                            {
                                CComObject<CWANDevice>* pWANDevice = pDevice2->m_pWANDevice;
                                CComObject<CWANCommonDevice>* pWANCommonDevice = pWANDevice->m_pWANCommonDevice;
                                pWANCommonDevice->UpdateConnectionStatus();
                            }
                        }
                        
                        if(SUCCEEDED(hr))
                        {
                            hr = pRegistrar->UnregisterDevice(bstrId, TRUE);
                            if(FAILED(hr))
                            {
                                printf("rrd failed\n");
                            }
                        }

                    }
                    
                    SysFreeString(bstrInitString);
                    SysFreeString(bstrPath);
                    if(SUCCEEDED(hr))
                    {
                        SysFreeString(bstrId);
                    }
                    SysFreeString(bstrData);
                }
                FreeResource(hGlobal);
            }
        }
    }
}

void TestDisconnect()
{
//    CLanControl LanControl;
//
//
//    LanControl.FinalConstruct();
//    LanControl.Disconnect();
}

void TestConnect()
{
//    CLanControl LanControl;
//
//    LanControl.FinalConstruct();
//    LanControl.Connect();
}

int __cdecl main(int argc, char* argv[])
{

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _Module.Init(ObjectMap, GetModuleHandle(NULL), &LIBID_UPnPInternetGatewayDeviceLib);
    Test();
    //    if(argc == 1)
//    {
//        TestConnect();
//    }
//    else
//    {
//        TestDisconnect();
//    }
    _Module.Term();
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\statisticsproviders.cpp ===
#include "pch.h"
#pragma hdrstop
#include "StatisticsProviders.h"
#include "ras.h"
#include "rasuip.h"
#include "ndispnp.h"


CLANStatisticsProvider::CLANStatisticsProvider()
{

}

HRESULT CLANStatisticsProvider::Initialize(GUID* pGuid)
{
    HRESULT hr = S_OK;

    lstrcpy(m_pszDeviceString, L"\\Device\\");
    StringFromGUID2(*pGuid, m_pszDeviceString + (sizeof(L"\\Device\\") / sizeof(WCHAR) - 1), 54);
    RtlInitUnicodeString(&m_Device, m_pszDeviceString);

    return hr;
}

HRESULT CLANStatisticsProvider::FinalRelease()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CLANStatisticsProvider::GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime)
{
    HRESULT hr = S_OK;

    
    NIC_STATISTICS  nsNewLanStats;
    ZeroMemory(&nsNewLanStats, sizeof(nsNewLanStats));
    nsNewLanStats.Size = sizeof(NIC_STATISTICS);
    
    if (NdisQueryStatistics(&m_Device, &nsNewLanStats))
    {
        
        if(NULL != pulBytesSent)
        {
            *pulBytesSent = static_cast<ULONG>(nsNewLanStats.BytesSent);
        }
        if(NULL != pulBytesReceived)
        {
            *pulBytesReceived = static_cast<ULONG>(nsNewLanStats.DirectedBytesReceived);
        }
        if(NULL != pulPacketsSent)
        {
            *pulPacketsSent = static_cast<ULONG>(nsNewLanStats.PacketsSent);
        }
        if(NULL != pulPacketsReceived)
        {
            *pulPacketsReceived = static_cast<ULONG>(nsNewLanStats.DirectedPacketsReceived);
        }
        if(NULL != pulUptime)
        {
            *pulUptime = nsNewLanStats.ConnectTime;
        }
        if(NULL != pulSpeedbps)
        {
            *pulSpeedbps = nsNewLanStats.LinkSpeed * 100;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


CRASStatisticsProvider::CRASStatisticsProvider()
{
    m_pNetRasConnection = NULL;
}

HRESULT CRASStatisticsProvider::Initialize(INetConnection* pNetConnection)
{
    HRESULT hr = S_OK;

    hr = pNetConnection->QueryInterface(IID_INetRasConnection, reinterpret_cast<void**>(&m_pNetRasConnection));
    
    return hr;
}

HRESULT CRASStatisticsProvider::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pNetRasConnection)
    {
        m_pNetRasConnection->Release();
    }

    return hr;
}

HRESULT CRASStatisticsProvider::GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime)
{
    HRESULT hr = S_OK;
    
    HRASCONN hRasConnection;
    hr = m_pNetRasConnection->GetRasConnectionHandle(reinterpret_cast<ULONG_PTR*>(&hRasConnection));
    if(SUCCEEDED(hr))
    {
        RAS_STATS Statistics;
        Statistics.dwSize = sizeof(RAS_STATS);
        if(0 == RasGetConnectionStatistics(hRasConnection, &Statistics))
        {
            if(NULL != pulBytesSent)
            {
                *pulBytesSent = Statistics.dwBytesXmited;
            }
            if(NULL != pulBytesReceived)
            {
                *pulBytesReceived = Statistics.dwBytesRcved;
            }
            if(NULL != pulPacketsSent)
            {
                *pulPacketsSent = Statistics.dwFramesXmited;
            }
            if(NULL != pulPacketsReceived)
            {
                *pulPacketsReceived = Statistics.dwFramesRcved;
            }
            if(NULL != pulUptime)
            {
                *pulUptime = Statistics.dwConnectDuration / 1000;
            }
            if(NULL != pulSpeedbps)
            {
                *pulSpeedbps = Statistics.dwBps;
            }
        }
        else
        {
            hr = E_FAIL;
        }
        // any cleanup here?
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\resource.h ===
#define IDX_DESC_DOC 100
#define IDR_SAMPLE_DEVICE 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\util.cpp ===
#pragma once

#include "pch.h"
#pragma hdrstop 
#include "winsock2.h"
#include "util.h"

HRESULT SetUPnPError(LPOLESTR pszError)
{
    HRESULT hr = S_OK;

    ICreateErrorInfo* pCreateErrorInfo;
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if(SUCCEEDED(hr))
    {
        hr = pCreateErrorInfo->SetSource(pszError);
        if(SUCCEEDED(hr))
        {
            
            IErrorInfo* pErrorInfo;
            hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, reinterpret_cast<void**>(&pErrorInfo));
            if(SUCCEEDED(hr))
            {
                hr = SetErrorInfo(0, pErrorInfo);
                pErrorInfo->Release();
            }
        }
        pCreateErrorInfo->Release();
    }

    return hr;
}


DWORD WINAPI
INET_ADDR(LPCWSTR     szAddressW) 
//
// The 3 "." testing is for the sole purpose of preventing computer 
// names with digits to be catched appropriately.
// so we strictly assume a valid IP is  number.number.number.number
//
{

    CHAR   szAddressA[16];
    int    iCount = 0;
    LPCWSTR tmp    = szAddressW;

    // Check wether it is a non-shortcut IPs.
    while(tmp = wcschr(tmp, L'.'))
    {   tmp++; iCount++;   }

    if ( iCount < 3)
    { return INADDR_NONE; }


    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}


WCHAR * WINAPI
INET_NTOW( ULONG addr ) 
{
    struct in_addr  dwAddress;
    static WCHAR szAddress[16];

    dwAddress.S_un.S_addr = addr;

    char* pAddr = inet_ntoa(*(struct in_addr *) &dwAddress);

    if (pAddr)
    {
	    // mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);
	    MultiByteToWideChar(CP_ACP, 0, pAddr, -1, szAddress, 16);

	    return szAddress;
	}
	else
		return NULL;
}

WCHAR * WINAPI
INET_NTOW_TS( ULONG addr )
{
    WCHAR* retString = NULL;

    CHAR* asciiString = NULL;

    struct in_addr dwAddress;

    dwAddress.S_un.S_addr = addr;

    retString = (WCHAR*)CoTaskMemAlloc( 16 * sizeof(WCHAR) );

    if ( NULL == retString )
    {
        return NULL;
    }

    //
    // note that inet_nota is thread safe
    // altough it uses static buffer
    //
    asciiString = inet_ntoa( dwAddress);

    if (asciiString != NULL)
    {
        MultiByteToWideChar(CP_ACP, 0, asciiString, -1, retString, 16);

        return retString;
    }
    
    return NULL;
}



CSwitchSecurityContext::CSwitchSecurityContext( )
    :m_pOldCtx( NULL )
{
    HRESULT hr;

    hr = CoSwitchCallContext( NULL, &m_pOldCtx );
    
    _ASSERT( SUCCEEDED(hr) );
    _ASSERT( NULL != m_pOldCtx );
}

CSwitchSecurityContext::~CSwitchSecurityContext( )
{
    HRESULT hr;
    IUnknown * pGarb;

    _ASSERT( NULL != m_pOldCtx );

    hr = CoSwitchCallContext( m_pOldCtx, &pGarb );
    
    _ASSERT( SUCCEEDED(hr) );

    //
    //  m_pOldCtx->Release();
    //  and pGarb->Release();
    //  Should not be released
    //  Documentation is flawed; the interface is not 
    //  a COM interface actually
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\statisticsproviders.h ===
#pragma once

#include "InternetGatewayDevice.h"
#include "netconp.h"


class ATL_NO_VTABLE CLANStatisticsProvider : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IStatisticsProvider
{
public:
    CLANStatisticsProvider();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLANStatisticsProvider)
    COM_INTERFACE_ENTRY(IStatisticsProvider)
END_COM_MAP()

public:

    HRESULT Initialize(GUID* pGuid);
    HRESULT FinalRelease(void);

    STDMETHODIMP GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime);

private:

    WCHAR m_pszDeviceString[64];
    UNICODE_STRING m_Device;

};

class ATL_NO_VTABLE CRASStatisticsProvider : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IStatisticsProvider
{
public:
    CRASStatisticsProvider();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLANStatisticsProvider)
    COM_INTERFACE_ENTRY(IStatisticsProvider)
END_COM_MAP()

public:

    HRESULT Initialize(INetConnection* pNetConnection);
    HRESULT FinalRelease(void);

    STDMETHODIMP GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime);

private:

    INetRasConnection* m_pNetRasConnection;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\server\util.h ===
#pragma once

#define DCP_CUSTOM_ERROR_ACCESSDENIED L"800"
#define DCP_ERROR_CONNECTIONSETUPFAILED L"704"

HRESULT SetUPnPError(LPOLESTR pszError);

DWORD WINAPI INET_ADDR( LPCWSTR szAddressW );

WCHAR * WINAPI INET_NTOW( ULONG addr );

WCHAR * WINAPI INET_NTOW_TS( ULONG addr );

class CSwitchSecurityContext
{
public:
    CSwitchSecurityContext();

    ~CSwitchSecurityContext();

private:
    
    IUnknown *m_pOldCtx;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\exe\bridge.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.c

Abstract:

    Ethernet MAC level bridge.

    SAMPLE program illustrating how to interface with the bridge
    driver via IOCTLs

Author:

    Mark Aiken

Environment:

    User mode

Revision History:

    Apr  2000 - Original version

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <process.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include "bioctl.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

HANDLE              gThreadQuitEvent = NULL;
HANDLE              gBridgeDevice = NULL;

// ===========================================================================
//
// FUNCTIONS
//
// ===========================================================================

VOID
PrintError(
    IN DWORD            Error
    )
/*++

Routine Description:

    Prints a description of a system error

Arguments:

    Error               The error code

--*/

{
    TCHAR               msg[200];

    printf( "(%08x): ", Error );

    if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, Error, 0, msg, sizeof(msg), NULL ) > 0 )
    {
        printf( "%s", msg );
    }
}

VOID
PrintNotification(
    IN PBRIDGE_NOTIFY_HEADER        pNotify,
    IN DWORD                        DataBytes
    )
/*++

Routine Description:

    Prints a notification from the bridge driver

Arguments:

    pNotify                         The notification block
    DataBytes                       Total size of the notification block

--*/
{
    BOOLEAN                 bPrintAdapterInfo = TRUE;

    printf( "\n\nNotification on Adapter %p: ", pNotify->Handle );

    switch( pNotify->NotifyType )
    {
    case BrdgNotifyEnumerateAdapters:
        printf( "Enumeration was requested\n" );
        break;

    case BrdgNotifyAddAdapter:
        printf( "Adapter was added\n" );
        break;

    case BrdgNotifyRemoveAdapter:
        printf( "Adapter was removed\n" );
        bPrintAdapterInfo = FALSE;
        break;

    case BrdgNotifyLinkSpeedChange:
        printf( "Link speed changed\n" );
        break;

    case BrdgNotifyMediaStateChange:
        printf( "Media state changed\n" );
        break;

    case BrdgNotifyAdapterStateChange:
        printf( "Forwarding state changed\n" );
        break;

    default:
        printf( "UNKNOWN NOTIFICATION\n" );
        bPrintAdapterInfo = FALSE;
        break;
    }

    if( bPrintAdapterInfo )
    {
        PBRIDGE_ADAPTER_INFO    pInfo = (PBRIDGE_ADAPTER_INFO)((PUCHAR)pNotify + sizeof(BRIDGE_NOTIFY_HEADER));
        printf("Adapter information:\n\n");
        printf("Link Speed:       %iMbps\n", pInfo->LinkSpeed / 10000);
        printf("Media State:      %s\n", pInfo->MediaState == NdisMediaStateConnected ? "CONNECTED" : "DISCONNECTED" );
        printf("Physical Medium:  %08x\n", pInfo->PhysicalMedium);

        printf("Forwarding state: ");

        switch( pInfo->State )
        {
        case Disabled:
            printf("** DISABLED **\n");
            break;

        case Blocking:
            printf("BLOCKING\n");
            break;

        case Listening:
            printf("Listening\n");
            break;

        case Learning:
            printf("Learning\n");
            break;

        case Forwarding:
            printf("Forwarding\n");
            break; 
        }

        printf("MAC Address:      %02x-%02x-%02x-%02x-%02x-%02x\n", pInfo->MACAddress[0], pInfo->MACAddress[1],
                pInfo->MACAddress[2], pInfo->MACAddress[3], pInfo->MACAddress[4], pInfo->MACAddress[5]);
    }
}

VOID __cdecl
NotificationThread(
    PVOID               pv
    )
/*++

Routine Description:

    Notification-listening thread

    Pends an IOCTL call and waits for notifications from the bridge driver

--*/
{
    BOOLEAN             bQuit = FALSE;
    HANDLE              Handles[2];
    DWORD               WaitResult, WrittenBytes;
    UCHAR               OutBuffer[sizeof(BRIDGE_NOTIFY_HEADER) + 1514];
    OVERLAPPED          Overlap;

    Handles[0] = gThreadQuitEvent;

    // Create an event to sleep against for the request
    Handles[1] = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( Handles[1] == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        _endthread();
    }

    Overlap.Offset = Overlap.OffsetHigh = 0L;
    Overlap.hEvent = Handles[1];

    while( ! bQuit )
    {
        // Ask for a notification
        if( ! DeviceIoControl( gBridgeDevice, BRIDGE_IOCTL_REQUEST_NOTIFY, NULL, 0L, OutBuffer,
                               sizeof(OutBuffer), &WrittenBytes, &Overlap ) )
        {
            DWORD       Error = GetLastError();

            if( Error != ERROR_IO_PENDING )
            {
                printf( "DeviceIoControl returned an error: " );
                PrintError( Error );
                _endthread();
            }
        }
         
        // Wait against the completion event and the kill event
        WaitResult = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );

        if( WaitResult == WAIT_OBJECT_0 )
        {
            // The quit event was signaled
            bQuit = TRUE;
        }
        else if( WaitResult != WAIT_OBJECT_0 + 1 )
        {
            printf( "Error waiting: " );
            PrintError( GetLastError() );
            _endthread();
        }
        else
        {
            // The completion event was signaled.

            // Try to retrieve the number of bytes read
            if( !GetOverlappedResult(gBridgeDevice, &Overlap, &WrittenBytes, FALSE) )
            {
                printf( "Couldn't get the device call result: " );
                PrintError( GetLastError() );
                _endthread();
            }

            PrintNotification( (PBRIDGE_NOTIFY_HEADER)OutBuffer, WrittenBytes );
        }
    }

    printf("Notification thread exiting.\n");

    _endthread();
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
/*++

Routine Description:

    Opens a device

Arguments:

    pDeviceName                 The device's name

Return Value:

    A handle to the opened device or INVALID_HANDLE_VALUE on failure;

--*/
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle = NULL;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}

BOOL
DoBlockingRequest(
    IN DWORD            IOCTL,
    IN PVOID            inBuff,
    IN DWORD            inSize,
    IN PVOID            outBuff,
    IN DWORD            outSize,
    OUT OPTIONAL PDWORD pWrittenBytes
    )
/*++

Routine Description:

    Makes an IOCTL call to a driver and blocks until the request completes

Arguments:

    IOCTL               The IOCTL code
    inBuff              The input data buffer
    inSize              The size of the input buffer
    outBuff             The output buffer
    outSize             The size of the output buffer
    pWrittenBytes       (optional) returns the number of bytes written to outBuff

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    DWORD               WrittenBytes;
    OVERLAPPED          Overlap;

    if( pWrittenBytes == NULL )
    {
        pWrittenBytes = &WrittenBytes;
    }

    // Create an event to sleep against for the request
    Overlap.hEvent = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( Overlap.hEvent == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        return FALSE;
    }

    Overlap.Offset = Overlap.OffsetHigh = 0L;

    // Make the request
    if( ! DeviceIoControl( gBridgeDevice, IOCTL, inBuff, inSize, outBuff,
                           outSize,pWrittenBytes, &Overlap ) )
    {
        DWORD       Error = GetLastError();

        if( Error != ERROR_IO_PENDING )
        {
            return FALSE;
        }
    }

    // Wait for the result
    if( !GetOverlappedResult(gBridgeDevice, &Overlap,pWrittenBytes, TRUE) )
    {
        return FALSE;
    }

    return TRUE;
}

PVOID
GetVariableData(
    IN ULONG        IOCTL,
    IN PVOID        inBuff,
    IN ULONG        inBuffSize,
    OUT PULONG      pNumBytes,
    IN ULONG        safetyBuffer
    )
/*++

Routine Description:

    Makes an IOCTL call that returns variable-sized data (for which two calls must
    be made, one to determine the size of the data and the other to retrieve it)

Arguments:

    IOCTL               The IOCTL code
    inBuff              The input data buffer
    inBuffSize          The size of the input buffer
    pNumBytes           The size of the allocated buffer holding the result

    safetyBuffer        A count of bytes to allocate beyond the claimed size of
                        the data (a safeguard against dynamically changing data)

Return Value:

    A freshly allocated buffer, *pNumBytes large, with the return data
    NULL on failure

--*/
{
    // First make a request to discover the number of necessary bytes
    if( ! DoBlockingRequest( IOCTL, inBuff, inBuffSize, NULL, 0L, pNumBytes ) )
    {
        DWORD       Error = GetLastError();

        // Expect the error to be ERROR_MORE_DATA since we didn't provide an output buffer!
        if( Error == ERROR_MORE_DATA )
        {
            if( *pNumBytes > 0L )
            {
                // Allocate safetyBuffer extra bytes in case the data is dynamic
                PUCHAR      pData = (PUCHAR)HeapAlloc(GetProcessHeap(), 0, *pNumBytes + safetyBuffer);
                ULONG       i;

                if( pData == NULL )
                {
                    printf( "Failed to allocate %i bytes of memory: ", *pNumBytes + safetyBuffer );
                    PrintError( GetLastError() );
                    return NULL;
                }

                // Make the request again to actually retrieve the addresses
                if( ! DoBlockingRequest( IOCTL, inBuff, inBuffSize, pData, *pNumBytes + safetyBuffer, pNumBytes ) )
                {
                    HeapFree( GetProcessHeap(), 0, pData );
                    printf( "Failed to read variable-length data: " );
                    PrintError( GetLastError() );
                    return NULL;
                }

                // Success. Hand back the data buffer.
                return pData;
            }
            else
            {
                printf( "Driver returned zero bytes: " );
                PrintError( GetLastError() );
                return NULL;
            }
        }
        else
        {
            printf( "Failed to get the number of necessary bytes: " );
            PrintError( GetLastError() );
            return NULL;
        }
    }

    return NULL;
}

_inline VOID
PrintByteString(
    IN PUCHAR                       pData,
    IN UINT                         numChars
    )
{
    UINT        i;

    for( i = 0; i < numChars; i++ )
    {
        printf( "%02x", pData[i] );

        if( i != numChars - 1 )
        {
            printf( "-" );
        }
    }

    printf( "\n" );
}

VOID
PrintAdapterSTAInfo(
    IN BRIDGE_ADAPTER_HANDLE        Handle
    )
{
    BRIDGE_STA_ADAPTER_INFO         info;

    if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTER_STA_INFO, &Handle, sizeof(Handle), &info, sizeof(info), NULL) )
    {
        printf( "Couldn't request STA information for adapter %p : ", Handle );
        PrintError( GetLastError() );
    }
    else
    {
        printf( "\nSTA Information for adapter %p:\n\n", Handle );
        printf( "Port unique ID       : %i\n", info.ID );
        printf( "Path Cost            : %i\n", info.PathCost );
        printf( "Designated Root      : " );
        PrintByteString( info.DesignatedRootID, BRIDGE_ID_LEN );
        printf( "Designated Cost      : %i\n", info.DesignatedCost );
        printf( "Designated Bridge    : " );
        PrintByteString( info.DesignatedBridgeID, BRIDGE_ID_LEN );
        printf( "Designated Port      : %i\n\n", info.DesignatedPort );
    }
}

VOID
PrintSTAInfo(
    )
{
    BRIDGE_STA_GLOBAL_INFO          info;

    if(! DoBlockingRequest(BRIDGE_IOCTL_GET_GLOBAL_STA_INFO, NULL, 0L, &info, sizeof(info), NULL) )
    {
        printf( "Couldn't request global STA information : " );
        PrintError( GetLastError() );
    }
    else
    {
        printf( "This bridge's ID        : " );
        PrintByteString( info.OurID, BRIDGE_ID_LEN );

        printf( "Designated Root         : " );
        PrintByteString( info.DesignatedRootID, BRIDGE_ID_LEN );

        printf( "Cost to root            : %i\n", info.RootCost );
        printf( "Root adapter            : %p\n", info.RootAdapter );
        printf( "MaxAge                  : %i\n", info.MaxAge );
        printf( "HelloTime               : %i\n", info.HelloTime );
        printf( "ForwardDelay            : %i\n", info.ForwardDelay );

        printf( "TopologyChangeDetected  : " );
        
        if( info.bTopologyChangeDetected )
        {
            printf( "TRUE\n" );
        }
        else
        {
            printf( "FALSE\n" );
        }

        printf( "TopologyChange          : " );
        
        if( info.bTopologyChange )
        {
            printf( "TRUE\n\n" );
        }
        else
        {
            printf( "FALSE\n\n" );
        }
    }
}


VOID
PrintTableEntries(
    IN BRIDGE_ADAPTER_HANDLE        Handle
    )
/*++

Routine Description:

    Retrieves and prints the MAC table entries for a particular adapter

Arguments:

    Handle                          The adapter

--*/
{
    PUCHAR          pAddresses;
    ULONG           i, numBytes;

    pAddresses = GetVariableData( BRIDGE_IOCTL_GET_TABLE_ENTRIES, &Handle, sizeof(Handle), &numBytes, 60L );

    if( pAddresses == NULL )
    {
        printf( "Failed to read table entries: " );
        PrintError( GetLastError() );
        return;
    }

    printf( "Forwarding table entries for adapter %x: \n", Handle );

    for( i = 0L; i < numBytes / ETH_LENGTH_OF_ADDRESS; i++ )
    {
        PrintByteString( pAddresses, ETH_LENGTH_OF_ADDRESS );
        pAddresses += ETH_LENGTH_OF_ADDRESS;
    }

    HeapFree( GetProcessHeap(), 0, pAddresses );
}

VOID
PrintPacketStats(
    IN PBRIDGE_PACKET_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_PACKET_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    printf("Bridge packet statistics:\n\n");

    printf("Transmitted Frames:            %16I64u\n", pStats->TransmittedFrames);
    printf("Transmitted Frames w/Errors:   %16I64u\n", pStats->TransmittedErrorFrames);
    printf("Transmitted Directed Frames:   %16I64u\n", pStats->DirectedTransmittedFrames);
    printf("Transmitted Multicast Frames:  %16I64u\n", pStats->MulticastTransmittedFrames);
    printf("Transmitted Broadcast Frames:  %16I64u\n\n", pStats->BroadcastTransmittedFrames);

    printf("Transmitted Bytes:             %16I64u\n", pStats->TransmittedBytes);
    printf("Transmitted Directed Bytes     %16I64u\n", pStats->DirectedTransmittedBytes);
    printf("Transmitted Multicast Bytes:   %16I64u\n", pStats->MulticastTransmittedBytes);
    printf("Transmitted Broadcast Bytes:   %16I64u\n\n", pStats->BroadcastTransmittedBytes);

    printf("Indicated Frames:              %16I64u\n", pStats->IndicatedFrames);
    printf("Indicated Frames w/Errors:     %16I64u\n\n", pStats->IndicatedDroppedFrames);
    printf("Indicated Directed Frames:     %16I64u\n", pStats->DirectedIndicatedFrames);
    printf("Indicated Multicast Frames:    %16I64u\n", pStats->MulticastIndicatedFrames);
    printf("Indicated Broadcast Frames:    %16I64u\n\n", pStats->BroadcastIndicatedFrames);

    printf("Indicated Bytes:               %16I64u\n", pStats->IndicatedBytes);
    printf("Indicated Directed Bytes:      %16I64u\n", pStats->DirectedIndicatedBytes);
    printf("Indicated Multicast Bytes:     %16I64u\n", pStats->MulticastIndicatedBytes);
    printf("Indicated Broadcast Bytes:     %16I64u\n\n", pStats->BroadcastIndicatedBytes);

    printf("Received Frames (incl. relay): %16I64u\n", pStats->ReceivedFrames);
    printf("Received Bytes (incl. relay):  %16I64u\n", pStats->ReceivedBytes);
    printf("Received Frames w/Copy:        %16I64u\n", pStats->ReceivedCopyFrames);
    printf("Received Bytes w/Copy:         %16I64u\n", pStats->ReceivedCopyBytes);
    printf("Received Frames w/No Copy:     %16I64u\n", pStats->ReceivedNoCopyFrames);
    printf("Received Bytes w/No Copy:      %16I64u\n", pStats->ReceivedNoCopyBytes);
}

VOID
PrintAdapterPacketStats(
    IN PBRIDGE_ADAPTER_PACKET_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_ADAPTER_PACKET_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    PUCHAR              pc = (PUCHAR)pStats;

    printf("Bridge per-adapter packet statistics:\n\n");
    printf("Transmitted Frames:              %16I64u\n", pStats->SentFrames);
    printf("Transmitted Bytes:               %16I64u\n", pStats->SentBytes);
    printf("Transmitted Local-Source Frames: %16I64u\n", pStats->SentLocalFrames);
    printf("Transmitted Local-Source Bytes:  %16I64u\n", pStats->SentLocalBytes);
    printf("Received Frames:                 %16I64u\n", pStats->ReceivedFrames);
    printf("Received Bytes:                  %16I64u\n\n", pStats->ReceivedBytes);
}

VOID
PrintBufferStats(
    IN PBRIDGE_BUFFER_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_BUFFER_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    printf("Bridge buffer statistics:\n\n");

    printf("Copy Packets In Use:              %4lu\n", pStats->UsedCopyPackets);
    printf("Total Copy Packets Available:     %4lu\n", pStats->MaxCopyPackets);
    printf("Safety Copy Packets:              %4lu\n", pStats->SafetyCopyPackets);
    printf("Copy Pool Overflows:        %10I64u\n\n", pStats->CopyPoolOverflows);

    printf("Wrapper Packets In Use:           %4lu\n", pStats->UsedWrapperPackets);
    printf("Total Wrapper Packets Available:  %4lu\n", pStats->MaxWrapperPackets);
    printf("Safety Wrapper Packets:           %4lu\n", pStats->SafetyWrapperPackets);
    printf("Wrapper Pool Overflows:     %10I64u\n\n", pStats->WrapperPoolOverflows);

    printf("Surprise Alloc Failures:    %10I64u\n", pStats->AllocFailures);
}

BOOLEAN
ReadUlongArg(
    IN PUCHAR                       inbuf,
    OUT PULONG                      arg
    )
/*++

Routine Description:

    Reads an unsigned decimal value from a string and returns it
    The value must occur as the second word of the string

Arguments:

    inbuf                           The input string

    arg                             The resulting number

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    UCHAR               scratch[100];

    if( sscanf(inbuf, "%s %lu", scratch, arg) < 2 )
    {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ReadHexPtrArg(
    IN PUCHAR                       inbuf,
    OUT PULONG_PTR                  arg
    )
/*++

Routine Description:

    Reads an unsigned hexidecimal value from a string and returns it
    The value must occur as the second word of the string

Arguments:

    inbuf                           The input string

    arg                             The resulting number

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    UCHAR               scratch[100];
    INT                 read;

    if( sizeof(*arg) <= sizeof(ULONG) )
    {
        read = sscanf(inbuf, "%s %lx", scratch, arg);
    }
    else
    {
        read = sscanf(inbuf, "%s %I64x", scratch, arg);
    }

    if( (read != EOF) && (read < 2) )
    {
        return FALSE;
    }

    return TRUE;
}


VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{
    CHAR        inbuf[100], command[100];
    BOOLEAN     bQuit = FALSE;

    printf("\nSAMPLE MAC Bridge control program\n");

    // Open the bridge device
    gBridgeDevice = OpenDevice( BRIDGE_DOS_DEVICE_NAME );

    if( gBridgeDevice == INVALID_HANDLE_VALUE )
    {
        printf( "Couldn't open bridge device: " );
        PrintError( GetLastError() );
        return;
    }

    // Create the thread-quit notification event
    gThreadQuitEvent = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( gThreadQuitEvent == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        return;
    }

    // Spin up a thread to handle notifications
    _beginthread( NotificationThread, 0, NULL );

    while( ! bQuit )
    {
        PCHAR           pSpace;

        printf( "> " );

        // Get a line of input
        gets( inbuf );

        // Find the first word delimiter
        pSpace = strchr( inbuf, ' ' );

        // Copy over the first word
        if( pSpace != NULL )
        {
            strncpy( command, inbuf, pSpace - inbuf );
            command[pSpace-inbuf] = '\0';
        }
        else
        {
            strcpy( command, inbuf );
        }

        if( _stricmp(command, "enum")  == 0 )
        {
            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTERS, NULL, 0L, NULL, 0L, NULL) )
            {
                printf( "Couldn't request an adapter re-enumeration : " );
                PrintError( GetLastError() );
            }
            else
            {
                printf("Requested an adapter re-enumeration.\n" );
            }
        }
        else if( (_stricmp(command, "devicename")  == 0) ||
                 (_stricmp(command, "friendlyname")  == 0) )
        {
            ULONG                   IOCTL = (_stricmp(command, "devicename")  == 0) ? BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME :
                                            BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME;

            BRIDGE_ADAPTER_HANDLE   Handle;
            PWCHAR                  pName;
            ULONG                   numBytes;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                printf("Must supply an adapter handle for this command.\n");
            }
            else
            {
                pName = (PWCHAR)GetVariableData( IOCTL, &Handle, sizeof(Handle), &numBytes, 0L );

                if( pName == NULL )
                {
                    printf("Couldn't get name for adapter %p: ", Handle);
                    PrintError( GetLastError() );
                }
                else
                {
                    printf("The name is: %S\n", pName);
                }

                HeapFree( GetProcessHeap(), 0, pName );
            }
        }
        else if( _stricmp(command, "table")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE       Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                printf("Must supply an adapter handle for this command.\n");
            }
            else
            {
                PrintTableEntries(Handle);
            }
        }
        else if( _stricmp(command, "mac")  == 0 )
        {
            UCHAR               addr[ETH_LENGTH_OF_ADDRESS];

            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_MAC_ADDRESS, NULL, 0L, addr, sizeof(addr), NULL) )
            {
                printf("Attempt to query MAC address failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                printf( "Bridge MAC address is %02x-%02x-%02x-%02x-%02x-%02x\n", addr[0], addr[1],
                        addr[2], addr[3], addr[4], addr[5] );
            }
        }
        else if( _stricmp(command, "onretain")  == 0 )
        {
            if(! DoBlockingRequest(BRIDGE_IOCTL_RETAIN_PACKETS, NULL, 0L, NULL, 0L, NULL) )
            {
                printf("Attempt to turn ON packet retention failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                printf("Packet retention ENABLED.\n");
            }
        }
        else if( _stricmp(command, "offretain")  == 0 )
        {
            if(! DoBlockingRequest(BRIDGE_IOCTL_NO_RETAIN_PACKETS, NULL, 0L, NULL, 0L, NULL) )
            {
                printf("Attempt to turn OFF packet retention failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                printf("Packet retention DISABLED.\n");
            }
        }
        else if( _stricmp(command, "packetstats")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE       Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                BRIDGE_PACKET_STATISTICS    Stats;

                if(! DoBlockingRequest(BRIDGE_IOCTL_GET_PACKET_STATS, NULL, 0L, &Stats, sizeof(Stats), NULL) )
                {
                    printf("Attempt to retrieve global packet statistics failed: ");
                    PrintError( GetLastError() );
                }
                else
                {
                    PrintPacketStats(&Stats);
                }
            }
            else
            {
                BRIDGE_ADAPTER_PACKET_STATISTICS        Stats;

                if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS, &Handle, sizeof(Handle), &Stats, sizeof(Stats), NULL) )
                {
                    printf("Attempt to retrieve packet statistics for adapter %p failed: ", Handle);
                    PrintError( GetLastError() );
                }
                else
                {
                    PrintAdapterPacketStats(&Stats);
                }
            }
        }
        else if( _stricmp(command, "bufferstats")  == 0 )
        {
            BRIDGE_BUFFER_STATISTICS    Stats;

            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_BUFFER_STATS, NULL, 0L, &Stats, sizeof(Stats), NULL) )
            {
                printf("Attempt to retrieve buffer statistics failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                PrintBufferStats(&Stats);
            }
        }
        else if( _stricmp(command, "stainfo")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE   Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                PrintSTAInfo();
            }
            else
            {
                PrintAdapterSTAInfo( Handle );
            }
        }
        else if( _stricmp( command, "quit" ) == 0 )
        {
            
            printf( "Signalling an exit...\n" );

            if( ! SetEvent( gThreadQuitEvent ) )
            {
                printf( "Couldn't signal an event: " );
                PrintError( GetLastError() );
                return;
            }

            bQuit = TRUE;
        }
        else
        {
            // Print a list of commands to help the user
            printf( "\n\nSupported commands:\n\n" );
            printf( "ENUM                   - Enumerates adapters\n" );
            printf( "DEVICENAME <handle>    - Retrieves the device name of the indicated adapter\n" );
            printf( "FRIENDLYNAME <handle>  - Retrieves the friendly name of the indicated adapter\n" );
            printf( "TABLE <handle>         - Prints the forwarding table for the indicated adapter\n" );
            printf( "MAC                    - Prints the bridge's MAC address\n" );
            printf( "ONRETAIN               - Turns ON NIC packet retention\n" );
            printf( "OFFRETAIN              - Turns OFF NIC packet retention\n" );
            printf( "PACKETSTATS [<handle>] - Retrieves packet-handling statistics for a particular\n" );
            printf( "                         adapter (or global data if no adapter handle is\n" );
            printf( "                         provided)\n" );
            printf( "BUFFERSTATS            - Retrieves buffer-management statistics\n" );
            printf( "STAINFO [<handle>]     - Retrieves STA info for a particular adapter (or global\n" );
            printf( "                         info if no adapter handle is provided)\n" );
            printf( "QUIT                   - Exits\n\n" );
        }
    }

    CloseHandle( gBridgeDevice );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\inc\bioctl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.h

Abstract:

    Ethernet MAC bridge.
    IOCTL interface definitions

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

// ===========================================================================
//
// CONSTANTS / TYPES
//
// ===========================================================================

// The bridge's device name when using it from user-mode
#define	BRIDGE_DOS_DEVICE_NAME          "\\\\.\\BRIDGE"

// Opaque handle uniquely identifying an adapter
typedef ULONG_PTR                       BRIDGE_ADAPTER_HANDLE, *PBRIDGE_ADAPTER_HANDLE;

// Length of an Ethernet MAC address
#define ETH_LENGTH_OF_ADDRESS 6

// No reported physical medium (assume 802.3)
#define BRIDGE_NO_MEDIUM                (NDIS_PHYSICAL_MEDIUM)-1

// Types of notifications
typedef enum
{
    BrdgNotifyEnumerateAdapters,
    BrdgNotifyAddAdapter,
    BrdgNotifyRemoveAdapter,
    BrdgNotifyLinkSpeedChange,
    BrdgNotifyMediaStateChange,
    BrdgNotifyAdapterStateChange        // This only occurs when the STA is active
} BRIDGE_NOTIFICATION_TYPE;

//
// Possible states for an adapter. If the STA is not compiled in, adapters are
// always in the Forwarding state.
//
typedef enum _PORT_STATE
{
    Disabled,           // The STA is disabled on this adapter. This happens when the adapter's
                        // media is disconnected.
    Blocking,           // Not learning or relaying
    Listening,          // Transitory
    Learning,           // Learning but not relaying
    Forwarding          // Learning and relaying
} PORT_STATE;

//
// STA types and constants
//

// Time values are exchanged between bridges as 16-bit unsigned values
// in units of 1/256th of a second
typedef USHORT          STA_TIME;

// Path costs are 32-bit unsigned values
typedef ULONG           PATH_COST;

// Port identifiers are 2-byte unsigned values
typedef USHORT          PORT_ID;

// Size of bridge identifiers
#define BRIDGE_ID_LEN   8

#if( BRIDGE_ID_LEN < ETH_LENGTH_OF_ADDRESS )
#error "BRIDGE_ID_LEN must be >= ETH_LENGTH_OF_ADDRESS"
#endif

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

//
// Common notification header
//
typedef struct _BRIDGE_NOTIFY_HEADER
{
    //
    // If NotifyType == BrdgNotifyRemoveAdapter, there is no further data.
    //
    // If NotifyType != BrdgNotifyRemoveAdapter, the header is followed by
    // a BRIDGE_ADAPTER_INFO structure.
    //
    BRIDGE_NOTIFICATION_TYPE            NotifyType;
    BRIDGE_ADAPTER_HANDLE               Handle;

} BRIDGE_NOTIFY_HEADER, *PBRIDGE_NOTIFY_HEADER;

//
// Data provided with adapter notifications
//
typedef struct _BRIDGE_ADAPTER_INFO
{
    // These fields can be the subject of a specific change notification
    ULONG                               LinkSpeed;
    NDIS_MEDIA_STATE                    MediaState;
    PORT_STATE                          State;

    // These fields are never the subject of a change notification
    UCHAR                               MACAddress[ETH_LENGTH_OF_ADDRESS];
    NDIS_PHYSICAL_MEDIUM                PhysicalMedium;

} BRIDGE_ADAPTER_INFO, *PBRIDGE_ADAPTER_INFO;

//
// Data provided in response to 
//
typedef struct _BRIDGE_STA_ADAPTER_INFO
{

    PORT_ID                             ID;
    ULONG                               PathCost;
    UCHAR                               DesignatedRootID[BRIDGE_ID_LEN];
    PATH_COST                           DesignatedCost;
    UCHAR                               DesignatedBridgeID[BRIDGE_ID_LEN];
    PORT_ID                             DesignatedPort;

} BRIDGE_STA_ADAPTER_INFO, *PBRIDGE_STA_ADAPTER_INFO;

//
// Data provided with BrdgNotifySTAGlobalInfoChange
//
typedef struct _BRIDGE_STA_GLOBAL_INFO
{
    UCHAR                               OurID[BRIDGE_ID_LEN];
    UCHAR                               DesignatedRootID[BRIDGE_ID_LEN];
    PATH_COST                           RootCost;
    BRIDGE_ADAPTER_HANDLE               RootAdapter;
    BOOLEAN                             bTopologyChangeDetected;
    BOOLEAN                             bTopologyChange;
    STA_TIME                            MaxAge;
    STA_TIME                            HelloTime;
    STA_TIME                            ForwardDelay;

} BRIDGE_STA_GLOBAL_INFO, *PBRIDGE_STA_GLOBAL_INFO;

//
// This structure is used to report statistics relating to the bridge's packet handling.
//
typedef struct _BRIDGE_PACKET_STATISTICS
{
    // Local-source frames
    LARGE_INTEGER                       TransmittedFrames;

    // Local-source frames whose transmission failed because of errors
    LARGE_INTEGER                       TransmittedErrorFrames;

    // Local-source bytes
    LARGE_INTEGER                       TransmittedBytes;

    // Breakdown of transmitted frames
    LARGE_INTEGER                       DirectedTransmittedFrames;
    LARGE_INTEGER                       MulticastTransmittedFrames;
    LARGE_INTEGER                       BroadcastTransmittedFrames;

    // Breakdown of transmitted bytes
    LARGE_INTEGER                       DirectedTransmittedBytes;
    LARGE_INTEGER                       MulticastTransmittedBytes;
    LARGE_INTEGER                       BroadcastTransmittedBytes;

    // Frames indicated to the local machine
    LARGE_INTEGER                       IndicatedFrames;

    // Frames that should have been indicated to the local machine but
    // were not due to errors
    LARGE_INTEGER                       IndicatedDroppedFrames;

    // Bytes indicated to the local machine
    LARGE_INTEGER                       IndicatedBytes;

    // Breakdown of indicated frames
    LARGE_INTEGER                       DirectedIndicatedFrames;
    LARGE_INTEGER                       MulticastIndicatedFrames;
    LARGE_INTEGER                       BroadcastIndicatedFrames;

    // Breakdown of indicated bytes
    LARGE_INTEGER                       DirectedIndicatedBytes;
    LARGE_INTEGER                       MulticastIndicatedBytes;
    LARGE_INTEGER                       BroadcastIndicatedBytes;

    // Total received frames / bytes, including frames not indicated
    LARGE_INTEGER                       ReceivedFrames;
    LARGE_INTEGER                       ReceivedBytes;

    // Breakdown of how many frames were received with/without copying 
    LARGE_INTEGER                       ReceivedCopyFrames ;
    LARGE_INTEGER                       ReceivedCopyBytes;

    LARGE_INTEGER                       ReceivedNoCopyFrames;
    LARGE_INTEGER                       ReceivedNoCopyBytes;

} BRIDGE_PACKET_STATISTICS, *PBRIDGE_PACKET_STATISTICS;

//
// This structure is used to report the packet-handling statistics for a particular
// adapter
//
typedef struct _BRIDGE_ADAPTER_PACKET_STATISTICS
{
   
    // These include all sent packets (including relay)
    LARGE_INTEGER                       SentFrames;
    LARGE_INTEGER                       SentBytes;

    // These include only packets sent by the local machine
    LARGE_INTEGER                       SentLocalFrames;
    LARGE_INTEGER                       SentLocalBytes;

    // These include all received packets (including relay)
    LARGE_INTEGER                       ReceivedFrames;
    LARGE_INTEGER                       ReceivedBytes;
    
} BRIDGE_ADAPTER_PACKET_STATISTICS, *PBRIDGE_ADAPTER_PACKET_STATISTICS;

//
// This structure is used to report statistics relating the bridge's internal
// buffer management
//
typedef struct _BRIDGE_BUFFER_STATISTICS
{
    // Packets of each type currently used
    ULONG                               UsedCopyPackets;
    ULONG                               UsedWrapperPackets;

    // Size of each pool
    ULONG                               MaxCopyPackets;
    ULONG                               MaxWrapperPackets;

    // Size of the safety buffer for each pool
    ULONG                               SafetyCopyPackets;
    ULONG                               SafetyWrapperPackets;

    // Number of times alloc requests from each pool have been denied because the
    // pool was completely full
    LARGE_INTEGER                       CopyPoolOverflows;
    LARGE_INTEGER                       WrapperPoolOverflows;

    // Number of times memory allocations have failed unexpectedly (presumably
    // because of low system resources)
    LARGE_INTEGER                       AllocFailures;

} BRIDGE_BUFFER_STATISTICS, *PBRIDGE_BUFFER_STATISTICS;

// ===========================================================================
//
// IOCTLS
//
// ===========================================================================

//
// This IOCTL will pend until the bridge has a notification to send up to the caller.
//
// Associated structures: BRIDGE_NOTIFY_HEADER and BRIDGE_ADAPTER_INFO
//
// The buffer provided with IOCTLs of this type must be at least sizeof(BRIDGE_NOTIFY_HEADER) +
// sizeof(BRIDGE_ADAPTER_INFO) large, in order to accomodate notifications that include adapter
// information
//
#define	BRIDGE_IOCTL_REQUEST_NOTIFY             CTL_CODE(FILE_DEVICE_NETWORK, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL causes the bridge driver to send a new notification for every bound adapter, with
// BrdgNotifyEnumerateAdapters as the notification type.
//
#define	BRIDGE_IOCTL_GET_ADAPTERS               CTL_CODE(FILE_DEVICE_NETWORK, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These codes retrieve the device name / friendly name for a bound adapter. Input buffer must be the adapter handle.
//
// As many bytes as possible of the name are read into the supplied buffer. If the buffer is not large enough,
// the number of necessary bytes is returned as the number of written bytes.
//
#define	BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME      CTL_CODE(FILE_DEVICE_NETWORK, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME    CTL_CODE(FILE_DEVICE_NETWORK, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code retrieves the MAC address of the bridge component (which is different from the MAC address
// of any particular adapter).
//
// The associated buffer must be at least ETH_LENGTH_OF_ADDRESS bytes long
//
#define	BRIDGE_IOCTL_GET_MAC_ADDRESS            CTL_CODE(FILE_DEVICE_NETWORK, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code retrieves packet statistics from the bridge
//
// Associated structure: BRIDGE_PACKET_STATISTICS
//
#define	BRIDGE_IOCTL_GET_PACKET_STATS           CTL_CODE(FILE_DEVICE_NETWORK, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code retrieves packet statistics for a particular adapter
//
// Associated structure: BRIDGE_ADAPTER_PACKET_STATISTICS
//
#define	BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS   CTL_CODE(FILE_DEVICE_NETWORK, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code retrieves buffer management statistics from the bridge
//
// Associated structure: BRIDGE_BUFFER_STATISTICS
//
#define	BRIDGE_IOCTL_GET_BUFFER_STATS           CTL_CODE(FILE_DEVICE_NETWORK, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These codes allow the caller to enable/disable packet retention
//
#define	BRIDGE_IOCTL_RETAIN_PACKETS             CTL_CODE(FILE_DEVICE_NETWORK, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	BRIDGE_IOCTL_NO_RETAIN_PACKETS          CTL_CODE(FILE_DEVICE_NETWORK, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code retrieves all forwarding table entries associated with the adapter whose handle
// is given in the input buffer
//
// Data is output as an array of MAC addresses, each ETH_LENGTH_OF_ADDRESS bytes long.
// If the provided buffer is too small to handle all entries, as many as possible are copied, the result
// status is STATUS_BUFFER_OVERFLOW (a warning value) and the count of written bytes is actually the
// required number of bytes to hold all table entries
//
#define	BRIDGE_IOCTL_GET_TABLE_ENTRIES          CTL_CODE(FILE_DEVICE_NETWORK, 0x80a, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// STA IOCTLs
//

//
// This code queries for the STA information for a particular adapter
//
// Input is an adapter handle. Output is the BRIDGE_STA_ADAPTER_INFO structure.
//
#define	BRIDGE_IOCTL_GET_ADAPTER_STA_INFO       CTL_CODE(FILE_DEVICE_NETWORK, 0x80b, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This code queries for global STA information
//
// No data is input. Output is the BRIDGE_STA_GLOBAL_INFO structure.
//
#define	BRIDGE_IOCTL_GET_GLOBAL_STA_INFO        CTL_CODE(FILE_DEVICE_NETWORK, 0x80c, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgbuf.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgbuf.h

Abstract:

    Ethernet MAC level bridge.
    Buffer management section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#include "brdgpkt.h"

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef enum
{
    BrdgOwnCopyPacket,
    BrdgOwnWrapperPacket,
    BrdgNotOwned
} PACKET_OWNERSHIP;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgBufDriverInit();

VOID
BrdgBufCleanup();

PNDIS_PACKET
BrdgBufGetBaseCopyPacket(
    OUT PPACKET_INFO        *pppi
    );

VOID
BrdgBufFreeWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi,
    IN PADAPT               pQuotaOwner
    );

VOID
BrdgBufFreeBaseCopyPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    );

VOID
BrdgBufFreeBaseWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    );

BOOLEAN
BrdgBufAssignBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

VOID
BrdgBufReleaseBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

PNDIS_PACKET
BrdgBufGetWrapperPacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pAdapt
    );

NDIS_STATUS
BrdgBufChainCopyBuffers(
    IN PNDIS_PACKET         pTargetPacket,
    IN PNDIS_PACKET         pSourcePacket
    );

PACKET_OWNERSHIP
BrdgBufGetPacketOwnership(
    IN PNDIS_PACKET         pPacket
    );

VOID
BrdgBufGetStatistics(
    PBRIDGE_BUFFER_STATISTICS   pStats
    );


// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Retrieves the first NDIS_BUFFER chained to a given packet (NULL if none)
//
__forceinline
PNDIS_BUFFER
BrdgBufPacketHeadBuffer(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pBuffer;
    SAFEASSERT( pPacket != NULL );
    NdisQueryPacket( pPacket, NULL, NULL, &pBuffer, NULL );
    return pBuffer;
}

//
// Retrieves the total size of all buffers chained to a packet
//
__forceinline
UINT
BrdgBufTotalPacketSize(
    IN PNDIS_PACKET         pPacket
    )
{
    UINT                    size;
    SAFEASSERT( pPacket != NULL );
    NdisQueryPacket( pPacket, NULL, NULL, NULL, &size );
    return size;
}

//
// Retrieves the virtual address of the data in the first buffer chained
// to a packet (holds the Ethernet header)
//
__forceinline
PVOID
BrdgBufGetPacketHeader(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pBuffer;
    PVOID                   pHeader;
    UINT                    Length;

    SAFEASSERT( pPacket != NULL );
    pBuffer = BrdgBufPacketHeadBuffer( pPacket );
    SAFEASSERT( pBuffer != NULL );
    NdisQueryBufferSafe( pBuffer, &pHeader, &Length, NormalPagePriority );
    SAFEASSERT( pHeader != NULL );
    return pHeader;
}

//
// Unchains and frees all buffers chained to a given packet
//
__forceinline
VOID
BrdgBufUnchainCopyBuffers(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pCurBuf;

    NdisUnchainBufferAtFront( pPacket, &pCurBuf );

    while( pCurBuf != NULL )
    {
        NdisFreeBuffer( pCurBuf );
        NdisUnchainBufferAtFront( pPacket, &pCurBuf );
    }
}

//
// Determines whether this packet was allocated from our copy pool
//
__forceinline
BOOLEAN
BrdgBufIsCopyPacket(
    IN PNDIS_PACKET         pPacket
    )
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);
    return  (BOOLEAN)(Own == BrdgOwnCopyPacket);
}

//
// Determines whether this packet was allocated from our wrapper pool
//
__forceinline
BOOLEAN
BrdgBufIsWrapperPacket(
    IN PNDIS_PACKET         pPacket
    )
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);
    return (BOOLEAN)(Own == BrdgOwnWrapperPacket);
}

//
// Initializes an ADAPTER_QUOTA structure
//
__forceinline
VOID
BrdgBufInitializeQuota(
    IN PADAPTER_QUOTA   pQuota
    )
{
    pQuota->UsedPackets[0] = pQuota->UsedPackets[1] = 0L;
}

// DO NOT use this variable directly outside of BrdgBuf.c
extern NDIS_HANDLE gWrapperBufferPoolHandle;

//
// Allocates an NDIS_BUFFER from our pool
//
__forceinline
PNDIS_BUFFER
BrdgBufAllocateBuffer(
    IN PVOID            p,
    IN UINT             len
    )
{
    PNDIS_BUFFER        pBuf;
    NDIS_STATUS         Status;

    NdisAllocateBuffer( &Status, &pBuf, gWrapperBufferPoolHandle, p, len );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(BUF, ("Failed to allocate a MDL in BrdgBufAllocateBuffer: %08x\n", Status));
        return NULL;
    }

    return pBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\inf\makefile.inc ===
STAMPINF_CMD=stampinf -f $@
_INF=obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)
.SUFFIXES : .inf .inx

make_infs:\
    $(_INF)\netbrdgs.inf    \
    $(_INF)\netbrdgm.inf

{}.inx{$(_INF)\}.inf:
     prodfilt -s $(@B).inx $@ +$(TARGET_DIRECTORY)
     $(STAMPINF_CMD)
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgcach.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgcach.h

Abstract:

    Ethernet MAC level bridge.
    Cache implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    December  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef struct _CACHE_ENTRY
{
    UINT32          key;
    UINT32          data;
    UINT64          hits;
    UINT64          misses;
} CACHE_ENTRY, *PCACHE_ENTRY;

typedef struct _CACHE
{
    // lock protects all cache fields
    NDIS_SPIN_LOCK  lock;

    // stats
    UINT64          hits;
    UINT64          misses;

    // 2^shiftFactor is the number of entries
    USHORT          shiftFactor;

    // Pointer to the array of entries
    PCACHE_ENTRY    pEntries;
} CACHE, *PCACHE;

//
// Determines the cache slot for key k in cache c. The slot is determined
// as the bottom bits of k.
//
#define CACHE_INDEX(c, k) (k & ((1 << c->shiftFactor) - 1))

// ===========================================================================
//
// INLINES
//
// ===========================================================================

__inline
VOID
BrdgClearCache(
    IN PCACHE       pCache
    )
{
    NdisAcquireSpinLock( &pCache->lock );
    memset( pCache->pEntries, 0, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor) );
    NdisReleaseSpinLock( &pCache->lock );
}

__inline
NDIS_STATUS
BrdgInitializeCache(
    IN PCACHE       pCache,
    IN USHORT       shiftFactor
    )
{
    ULONG           numEntries = 1 << shiftFactor;
    NDIS_STATUS     status;

    pCache->shiftFactor = shiftFactor;
    NdisAllocateSpinLock( &pCache->lock );
    status = NdisAllocateMemoryWithTag( &pCache->pEntries, sizeof(CACHE_ENTRY) * numEntries, 'gdrB' );
    pCache->hits = 0L;
    pCache->misses = 0L;

    if( status != NDIS_STATUS_SUCCESS )
    {
        return status;
    }

    // Zero out the array of entries
    memset( pCache->pEntries, 0, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor) );
    return NDIS_STATUS_SUCCESS;
}

__inline
VOID
BrdgFreeCache(
    IN PCACHE       pCache
    )
{
    NdisFreeMemory( pCache->pEntries, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor), 0 );
}

__inline
UINT32
BrdgProbeCache(
    IN PCACHE       pCache,
    IN UINT32       key
    )
{
    UINT32          index = CACHE_INDEX(pCache, key);
    PCACHE_ENTRY    pEntry = &pCache->pEntries[index];
    UINT32          data = 0L;

    NdisAcquireSpinLock( &pCache->lock );

    if( pEntry->key == key )
    {
        data = pEntry->data;
        pEntry->hits++;
        pCache->hits++;
    }
    else
    {
        pEntry->misses++;
        pCache->misses++;
    }

    NdisReleaseSpinLock( &pCache->lock );

    return data;
}

__inline
BOOLEAN
BrdgUpdateCache(
    IN PCACHE       pCache,
    IN UINT32       key,
    IN UINT32       data
    )
{
    UINT32          index = CACHE_INDEX(pCache, key);
    PCACHE_ENTRY    pEntry = &pCache->pEntries[index];
    BOOLEAN         bUpdated = FALSE;

    NdisAcquireSpinLock( &pCache->lock );

    if( pEntry->key != key &&
        (pEntry->hits < pEntry->misses) )
    {
        pEntry->key = key;
        pEntry->data = data;
        pEntry->hits = 0L;
        pEntry->misses = 0L;
        bUpdated = TRUE;
    }

    NdisReleaseSpinLock( &pCache->lock );

    return bUpdated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgbuf.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgbuf.c

Abstract:

    Ethernet MAC level bridge.
    Buffer management section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgbuf.h"
#include "brdgprot.h"
#include "brdgmini.h"

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

//
// A guess at how many buffer descriptors an average packet indicated on the
// no-copy path is likely to have.
//
// The size of the pool of MDLs used to construct wrapper packets is based on this
// guess
//
#define GUESS_BUFFERS_PER_PACKET        3

//
// Transit unicast packets on the no-copy path require one packet descriptor to wrap
// them for relay.
//
// Transit broadcast packets require n descriptors (where n == # of adapters) to
// wrap them for relay.
//
// We can't allow our descriptor usage to reach n^2, which is the worst case to handle
// broadcast traffic from all adapters. This number is a guess at how many wrapping
// descriptors we will need, on **average**, per packet. The idea is to not run out
// of packet descriptors under regular traffic conditions. If running on a machine
// with lots of adapters and lots of broadcast traffic, the # of wrapper descriptors
// may become a limiting factor if this guess is wrong.
//
// The size of the wrapper packet descriptor pool is based on this guess.
//
#define GUESS_AVERAGE_FANOUT            2

//
// In case we can't read it out of the registry, use this default value for the
// size of the copy packet pool safety buffer.
//
#define DEFAULT_SAFETY_MARGIN           10              // A percentage (10%)

//
// In case we can't read it out of the registry, use this default value for the
// total memory footprint we are allowed.
//
#define DEFAULT_MAX_BUF_MEMORY          2 * 1024 * 1024 // 2MB in bytes

//
// Registry values that hold our config values
//
const PWCHAR            gMaxBufMemoryParameterName = L"MaxBufferMemory";
const PWCHAR            gSafetyMarginParameterName = L"SafetyMargin";

//
// Constant for different types of quota-restricted packets
//
typedef enum
{
    BrdgQuotaCopyPacket = 0,
    BrdgQuotaWrapperPacket = 1
} QUOTA_PACKET_TYPE;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// List of free packet descriptors for copy-receives
BSINGLE_LIST_HEAD       gFreeCopyPacketList;
NDIS_SPIN_LOCK          gFreeCopyPacketListLock;

// List of free packet descriptors for wrapper packets
BSINGLE_LIST_HEAD       gFreeWrapperPacketList;
NDIS_SPIN_LOCK          gFreeWrapperPacketListLock;

// Look-aside list for copy-receive buffers
NPAGED_LOOKASIDE_LIST   gCopyBufferList;
BOOLEAN                 gInitedCopyBufferList = FALSE;

// Look-aside list for packet info blocks
NPAGED_LOOKASIDE_LIST   gPktInfoList;
BOOLEAN                 gInitedPktInfoList = FALSE;

// Packet descriptor pools for copy receives and wrapper packets
NDIS_HANDLE             gCopyPacketPoolHandle = NULL;
NDIS_HANDLE             gWrapperPacketPoolHandle = NULL;

// MDL pools for copy receives and wrapper packets
NDIS_HANDLE             gCopyBufferPoolHandle = NULL;
NDIS_HANDLE             gWrapperBufferPoolHandle = NULL;

// Spin lock to protect quota information
NDIS_SPIN_LOCK          gQuotaLock;

// Quota information for the local miniport
ADAPTER_QUOTA           gMiniportQuota;

//
// Maximum number of available packets of each type
//
// [0] == Copy packets
// [1] == Wrapper packets
//
ULONG                   gMaxPackets[2] = { 0L, 0L };

//
// Number of packets currently allocated from each pool
//
// [0] == Copy packets
// [1] == Wrapper packets
//
ULONG                   gUsedPackets[2] = { 0L, 0L };

#if DBG
ULONG                   gMaxUsedPackets[2] = { 0L, 0L };
#endif

//
// Amount of packets to keep as a buffer in each pool (the maximum consumption
// of any single adapter is gMaxPackets[X] - gSafetyBuffer[X].
//
// These values are computed from the safety margin proportion, which can
// optionally be specified by a registry value
//
ULONG                   gSafetyBuffer[2] = { 0L, 0L };

//
// Number of times we have had to deny an allocation request even though we wanted
// to allow it because we were flat out of packets. For debugging performance.
//
LARGE_INTEGER           gStatOverflows[2] = {{ 0L, 0L }, {0L, 0L}};

//
// Number of times we failed to allocated memory unexpectedly (i.e., when we had
// not allocated up to the preset maximum size of our resource pool). Should only
// occur if the host machine is actually out of non-paged memory (yikes!)
//
LARGE_INTEGER           gStatFailures = { 0L, 0L };

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

PNDIS_PACKET
BrdgBufCommonGetNewPacket(
    IN NDIS_HANDLE          Pool,
    OUT PPACKET_INFO        *pppi
    );

PNDIS_PACKET
BrdgBufGetNewCopyPacket(
    OUT PPACKET_INFO        *pppi
    );

// Type of function to pass to BrgBufCommonGetPacket
typedef PNDIS_PACKET (*PNEWPACKET_FUNC)(PPACKET_INFO*);

PNDIS_PACKET
BrdgBufCommonGetPacket(
    OUT PPACKET_INFO        *pppi,
    IN PNEWPACKET_FUNC      pNewPacketFunc,
    IN PBSINGLE_LIST_HEAD   pCacheList,
    IN PNDIS_SPIN_LOCK      ListLock
    );

BOOLEAN
BrdgBufAssignQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt,
    IN BOOLEAN              bCountAlloc
    );

VOID
BrdgBufReleaseQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Allocates a new wrapper packet
//
__forceinline PNDIS_PACKET
BrdgBufGetNewWrapperPacket(
    OUT PPACKET_INFO        *pppi
    )
{
    return BrdgBufCommonGetNewPacket( gWrapperPacketPoolHandle, pppi );
}

//
// Handles the special LOCAL_MINIPORT pseudo-pointer value
//
__forceinline PADAPTER_QUOTA
QUOTA_FROM_ADAPTER(
    IN PADAPT               pAdapt
    )
{
    SAFEASSERT( pAdapt != NULL );
    if( pAdapt == LOCAL_MINIPORT )
    {
        return &gMiniportQuota;
    }
    else
    {
        return &pAdapt->Quota;
    }
}

//
// Switches from the packet type constant to an index
//
__forceinline UINT
INDEX_FROM_TYPE(
    IN QUOTA_PACKET_TYPE    type
    )
{
    SAFEASSERT( (type == BrdgQuotaCopyPacket) || (type == BrdgQuotaWrapperPacket) );
    return (type == BrdgQuotaCopyPacket) ? 0 : 1;
}

//
// Reinitializes a packet for reuse later
//
__forceinline
VOID
BrdgBufScrubPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
{
    // This scrubs NDIS's state
    NdisReinitializePacket( pPacket );

    // Aggressively forget previous state to catch bugs
    NdisZeroMemory( ppi, sizeof(PACKET_INFO) );
    ppi->pOwnerPacket = pPacket;
}

//
// Decrements an adapter's used packet count
//
__forceinline
VOID
BrdgBufReleaseQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt
    )
{
    PADAPTER_QUOTA          pQuota = QUOTA_FROM_ADAPTER(pAdapt);
    UINT                    index = INDEX_FROM_TYPE(type);

    NdisAcquireSpinLock( &gQuotaLock );

    SAFEASSERT( pQuota->UsedPackets[index] > 0L );
    pQuota->UsedPackets[index] --;

    NdisReleaseSpinLock( &gQuotaLock );
}

//
// Decrements the global usage count
//
__forceinline
VOID
BrdgBufCountDealloc(
    IN QUOTA_PACKET_TYPE    type
    )
{
    UINT                    index = INDEX_FROM_TYPE(type);

    NdisAcquireSpinLock( &gQuotaLock );
    SAFEASSERT( gUsedPackets[index] > 0L );
    gUsedPackets[index]--;
    NdisReleaseSpinLock( &gQuotaLock );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgBufGetStatistics(
    PBRIDGE_BUFFER_STATISTICS   pStats
    )
/*++

Routine Description:

    Retrieves our internal statistics on buffer management.

Arguments:

    pStats                      The statistics structure to fill in

Return Value:

    None

--*/
{
    pStats->CopyPoolOverflows = gStatOverflows[0];
    pStats->WrapperPoolOverflows = gStatOverflows[1];

    pStats->AllocFailures = gStatFailures;

    pStats->MaxCopyPackets = gMaxPackets[0];
    pStats->MaxWrapperPackets = gMaxPackets[1];

    pStats->SafetyCopyPackets = gSafetyBuffer[0];
    pStats->SafetyWrapperPackets = gSafetyBuffer[1];

    NdisAcquireSpinLock( &gQuotaLock );

    pStats->UsedCopyPackets = gUsedPackets[0];
    pStats->UsedWrapperPackets = gUsedPackets[1];

    NdisReleaseSpinLock( &gQuotaLock );
}

PACKET_OWNERSHIP
BrdgBufGetPacketOwnership(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Returns a value indicating who owns this packet (i.e., whether we own this
    packet and it is from our copy pool, we own it and it's from our wrapper
    pool, or we don't own the packet at all).

Arguments:

    pPacket                 The packet to examine

Return Value:

    Ownership enumerated value

--*/
{
    NDIS_HANDLE             Pool = NdisGetPoolFromPacket(pPacket);

    if( Pool == gCopyPacketPoolHandle )
    {
        return BrdgOwnCopyPacket;
    }
    else if ( Pool == gWrapperPacketPoolHandle )
    {
        return BrdgOwnWrapperPacket;
    }

    return BrdgNotOwned;
}

VOID
BrdgBufFreeWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi,
    IN PADAPT               pQuotaOwner
    )
/*++

Routine Description:

    Frees a packet allocated from the wrapper pool and releases the quota previously
    assigned to the owning adapter

Arguments:

    pPacket                 The packet
    ppi                     The packet's associated info block
    pQuotaOwner             The adapter previously "charged" for this packet

Return Value:

    None

--*/
{
    SAFEASSERT( pQuotaOwner != NULL );
    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( ppi != NULL );

    // Free the packet
    BrdgBufFreeBaseWrapperPacket( pPacket, ppi );

    // Account for this packet having been returned
    BrdgBufReleaseQuota( BrdgQuotaWrapperPacket, pQuotaOwner );
}


PNDIS_PACKET
BrdgBufGetBaseCopyPacket(
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Returns a new copy packet and associated info block from our pools
    WITHOUT CHECKING FOR QUOTA against any particular adapter

    This call is made to allocated copy packets for wrapping inbound packets before
    any target adapter has been identified.

Arguments:

    pppi                    Receives the info block pointer (NULL if the alloc fails)

Return Value:

    The new packet or NULL if the target adapter failed quota

--*/
{
    PNDIS_PACKET            pPacket;
    BOOLEAN                 bAvail = FALSE;

    NdisAcquireSpinLock( &gQuotaLock );

    if( gUsedPackets[BrdgQuotaCopyPacket] < gMaxPackets[BrdgQuotaCopyPacket] )
    {
        // There are packets still available in the pool. Grab one.
        bAvail = TRUE;
        gUsedPackets[BrdgQuotaCopyPacket]++;

#if DBG
        // Keep track of the maximum used packets
        if( gMaxUsedPackets[BrdgQuotaCopyPacket] < gUsedPackets[BrdgQuotaCopyPacket] )
        {
            gMaxUsedPackets[BrdgQuotaCopyPacket] = gUsedPackets[BrdgQuotaCopyPacket];
        }
#endif
    }
    else if( gUsedPackets[BrdgQuotaCopyPacket] == gMaxPackets[BrdgQuotaCopyPacket] )
    {
        // We are at our limit. Hopefully this doesn't happen too often
        ExInterlockedAddLargeStatistic( &gStatOverflows[BrdgQuotaCopyPacket], 1L );
        bAvail = FALSE;
    }
    else
    {
        // This should never happen; it means we are over our limit somehow
        SAFEASSERT( FALSE );
        bAvail = FALSE;
    }

    NdisReleaseSpinLock( &gQuotaLock );

    if( ! bAvail )
    {
        // None available
        *pppi = NULL;
        return NULL;
    }

    pPacket =  BrdgBufCommonGetPacket( pppi, BrdgBufGetNewCopyPacket, &gFreeCopyPacketList,
                                       &gFreeCopyPacketListLock );

    if( pPacket == NULL )
    {
        // Our allocation failed. Reverse the usage increment.
        BrdgBufCountDealloc( BrdgQuotaCopyPacket );
    }

    return pPacket;
}


PNDIS_PACKET
BrdgBufGetWrapperPacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Returns a new packet and associated info block from the wrapper pool, unless the
    owning adapter does not does pass a quota check

Arguments:

    pppi                    Receives the info block pointer (NULL if the target
                            adapter fails quota)

    pAdapt                  The adapter to be "charged" for this packet

Return Value:

    The new packet or NULL if the target adapter failed quota

--*/
{
    PNDIS_PACKET            NewPacket = NULL;

    *pppi = NULL;

    if( BrdgBufAssignQuota(BrdgQuotaWrapperPacket, pAdapt, TRUE/*Count the alloc we are about to do*/) )
    {
        // Passed quota. We can allocate.
        NewPacket =  BrdgBufCommonGetPacket( pppi, BrdgBufGetNewWrapperPacket, &gFreeWrapperPacketList,
                                             &gFreeWrapperPacketListLock );

        if( NewPacket == NULL )
        {
            // We failed to allocate even though we haven't yet hit the ceiling on our
            // resource pool. This should only happen if we are physically out of non-paged
            // memory.

            // Reverse the adapter's quota bump
            BrdgBufReleaseQuota( BrdgQuotaWrapperPacket, pAdapt );

            // Reverse the usage count in BrdgBufAssignQuota
            BrdgBufCountDealloc( BrdgQuotaWrapperPacket );
        }
    }

    return NewPacket;
}

VOID
BrdgBufReleaseBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called to release the previously assigned cost of a wrapper packet. The packet
    provided can be any packet, even one we don't own. If we own the packet, we
    decrement the appropriate usage count in the adapter's quota structure.

Arguments:

    pPacket                 The packet the indicated adapter is no longer referring to

    pAdapt                  The adapter no longer referring to pPacket

Return Value:

    NULL

--*/
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);

    // This gets called for any base packet, even ones we don't own. Just NOOP if we
    // don't own it.
    if( Own != BrdgNotOwned )
    {
        BrdgBufReleaseQuota( (Own == BrdgOwnCopyPacket) ? BrdgQuotaCopyPacket : BrdgQuotaWrapperPacket,
                             pAdapt );
    }
}

BOOLEAN
BrdgBufAssignBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called to assign the cost of a base packet to an adapter, which is presumably attempting
    to construct a child wrapper packet that refers to the given base packet. A "cost" is
    assigned to pAdapt because by building a child wrapper packet that refers to the given
    base packet, pAdapt will cause it to not be disposed until it is done using it.

    It's OK for the input packet to be a packet we don't own; in that case, there is no cost
    to assign so we do nothing.

Arguments:

    pPacket                 The base packet that pAdapt wishes to build a child wrapper packet
                            referring to.

    pAdapt                  The adapter wishing to refer to pPacket

Return Value:

    TRUE    :   The adapter is permitted to refer to the given base packet
    FALSE   :   The adapter did not pass qutoa and may not refer to the given base packet

--*/
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);

    // We get called for any base packet, even if we don't own it.
    if( Own != BrdgNotOwned )
    {
        return BrdgBufAssignQuota( (Own == BrdgOwnCopyPacket) ? BrdgQuotaCopyPacket : BrdgQuotaWrapperPacket,
                                   pAdapt, FALSE/*We aren't going to do an alloc for this quota bump*/);
    }
    else
    {
        return TRUE;
    }
}

PNDIS_PACKET
BrdgBufCommonGetPacket(
    OUT PPACKET_INFO        *pppi,
    IN PNEWPACKET_FUNC      pNewPacketFunc,
    IN PBSINGLE_LIST_HEAD   pCacheList,
    IN PNDIS_SPIN_LOCK      ListLock
    )
/*++

Routine Description:

    Common processing for retrieving a new packet from either the copy pool or the wrapper pool

    Since we know how many packets we've allocated from each pool at all times, the only time this
    function should fail is if the host machine is physically out of memory.

Arguments:

    pppi                Receives the new info block (NULL if the alloc fails, which it shouldn't)
    pNewPacketFunc      Function to call to alloc a packet if the cache is empty
    pCacheList          Queue of cached packets that can be used to satisfy the alloc
    ListLock            The lock to use when manipulating the cache queue

Return Value:

    The newly allocated packet, or NULL if severe memory constraints cause the allocation to fail
    (this should be unusual)

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;
    PBSINGLE_LIST_ENTRY     entry;

    // Try to get a packet out of our cache.
    entry = BrdgInterlockedRemoveHeadSingleList( pCacheList, ListLock );

    if( entry == NULL )
    {
        // Try to allocate a packet and info block from our underlying pools
        pPacket = (*pNewPacketFunc)( &ppi );

        if( (pPacket == NULL) || (ppi == NULL) )
        {
            // This should only occur if our host machine is actually out
            // of nonpaged memory; we should normally be able to allocate
            // up to our preset limit from our pools.
            ExInterlockedAddLargeStatistic( &gStatFailures, 1L );
        }
    }
    else
    {
        ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
        pPacket = ppi->pOwnerPacket;
        SAFEASSERT( pPacket != NULL );
    }

    *pppi = ppi;
    return pPacket;
}

VOID
BrdgBufFreeBaseCopyPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
/*++

Routine Description:

    Frees a packet allocated from the copy pool without quota adjustements. This is called directly
    from non-buffer-management code to free base packets because the cost for base packets is
    assigned and released directly with calls to BrdgBuf<Assign|Release>BasePacketQuota.

Arguments:

    pPacket                 The packet to free
    ppi                     Its info block to free

Return Value:

    None

--*/
{
    // If we're holding less than our cache amount, free the packet by putting it on the
    // cache list
    ULONG                   holding;
    PNDIS_BUFFER            pBuffer = BrdgBufPacketHeadBuffer( pPacket );

    SAFEASSERT( (ppi != NULL) && (pPacket != NULL) );
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( pBuffer != NULL );

    // Return this packet descriptor to its original state
    NdisAdjustBufferLength(pBuffer, MAX_PACKET_SIZE);

    NdisAcquireSpinLock( &gFreeCopyPacketListLock );
    holding = BrdgQuerySingleListLength( &gFreeCopyPacketList );

    if( holding < gSafetyBuffer[BrdgQuotaCopyPacket] )
    {
        // Prep the packet for reuse

        // This blows away the buffer chain
        BrdgBufScrubPacket( pPacket, ppi );

        // Put the buffer back on
        SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) == NULL );
        NdisChainBufferAtFront( pPacket, pBuffer );

        // Push the packet onto the list
        BrdgInsertHeadSingleList( &gFreeCopyPacketList, &ppi->List );

        NdisReleaseSpinLock( &gFreeCopyPacketListLock );
    }
    else
    {
        PVOID               pBuf;
        UINT                Size;

        NdisReleaseSpinLock( &gFreeCopyPacketListLock );

        NdisQueryBufferSafe( pBuffer, &pBuf, &Size, NormalPagePriority );

        // Free the packet, the packet info block and the copy buffer to the underlying pools
        NdisFreeBuffer( pBuffer );
        NdisFreePacket( pPacket );
        NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );

        if( pBuf != NULL )
        {
            NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
        }
        else
        {
            // Shouldn't be possible since the alloced memory is in kernel space
            SAFEASSERT( FALSE );
        }
    }

    // Note the deallocation
    BrdgBufCountDealloc( BrdgQuotaCopyPacket );
}

VOID
BrdgBufFreeBaseWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
/*++

Routine Description:

    Frees a packet allocated from the wrapper pool without quota adjustements. This is called directly
    from non-buffer-management code to free base packets because the cost for base packets is
    assigned and released directly with calls to BrdgBuf<Assign|Release>BasePacketQuota.

Arguments:

    pPacket                 The packet to free
    ppi                     Its info block to free

Return Value:

    None

--*/
{
    // If we're holding less than our cache amount, free the packet by putting it on the
    // cache list
    ULONG                   holding;

    SAFEASSERT( (ppi != NULL) && (pPacket != NULL) );
    SAFEASSERT( ppi->pOwnerPacket == pPacket );

    NdisAcquireSpinLock( &gFreeWrapperPacketListLock );

    holding = BrdgQuerySingleListLength( &gFreeWrapperPacketList );

    if( holding < gSafetyBuffer[BrdgQuotaWrapperPacket] )
    {
        // Prep the packet for reuse
        SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) == NULL );
        BrdgBufScrubPacket( pPacket, ppi );

        // Push the packet onto the list
        BrdgInsertHeadSingleList( &gFreeWrapperPacketList, &ppi->List );

        NdisReleaseSpinLock( &gFreeWrapperPacketListLock );
    }
    else
    {
        NdisReleaseSpinLock( &gFreeWrapperPacketListLock );

        // Free the packet and packet info block to the underlying pools
        NdisFreePacket( pPacket );
        NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
    }

    // Note the deallocation
    BrdgBufCountDealloc( BrdgQuotaWrapperPacket );
}

NDIS_STATUS
BrdgBufChainCopyBuffers(
    IN PNDIS_PACKET         pTargetPacket,
    IN PNDIS_PACKET         pSourcePacket
    )
/*++

Routine Description:

    Allocates and chains buffer descriptors onto the target packet so it describes exactly
    the same areas of memory as the source packet

Arguments:

    pTargetPacket           Target packet
    pSourcePacket           Source packet

Return Value:

    Status of the operation. We have a limited-size pool of packet descriptors, so this
    operation can fail if we run out.

--*/
{
    PNDIS_BUFFER            pCopyBuffer, pCurBuf = BrdgBufPacketHeadBuffer( pSourcePacket );
    NDIS_STATUS             Status;

    SAFEASSERT( BrdgBufPacketHeadBuffer(pTargetPacket) == NULL );

    // There must be something in the source packet!
    if( pCurBuf == NULL )
    {
        SAFEASSERT( FALSE );
        return NDIS_STATUS_RESOURCES;
    }

    while( pCurBuf != NULL )
    {
        PVOID               p;
        UINT                Length;

        // Pull the virtual address and size out of the MDL being copied
        NdisQueryBufferSafe( pCurBuf, &p, &Length, NormalPagePriority );

        if( p == NULL )
        {
            BrdgBufUnchainCopyBuffers( pTargetPacket );
            return NDIS_STATUS_RESOURCES;
        }

        // Is wacky to have a MDL describing no memory
        if( Length > 0 )
        {
            // Get a new MDL from our pool and point it to the same address
            NdisAllocateBuffer( &Status, &pCopyBuffer, gWrapperBufferPoolHandle, p, Length );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                THROTTLED_DBGPRINT(BUF, ("Failed to allocate a MDL in BrdgBufChainCopyBuffers: %08x\n", Status));
                BrdgBufUnchainCopyBuffers( pTargetPacket );
                return Status;
            }

            // Use the new MDL to chain to the target packet
            NdisChainBufferAtBack( pTargetPacket, pCopyBuffer );
        }
        else
        {
            SAFEASSERT( FALSE );
        }

        NdisGetNextBuffer( pCurBuf, &pCurBuf );
    }

    return NDIS_STATUS_SUCCESS;
}

NTSTATUS
BrdgBufDriverInit( )
/*++

Routine Description:

    Driver-load-time initialization routine.

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS causes the driver load to fail.
    Any event causing an error return code must be logged.

--*/
{
    NDIS_STATUS                     Status;
    ULONG                           NumCopyPackets, ConsumptionPerCopyPacket, SizeOfPacket, i;
    ULONG                           MaxMemory = 0L, SafetyMargin = 0L;
    NTSTATUS                        NtStatus;

    // Initialize protective locks
    NdisAllocateSpinLock( &gFreeCopyPacketListLock );
    NdisAllocateSpinLock( &gFreeWrapperPacketListLock );
    NdisAllocateSpinLock( &gQuotaLock );

    // Initialize cache lists
    BrdgInitializeSingleList( &gFreeCopyPacketList );
    BrdgInitializeSingleList( &gFreeWrapperPacketList );

    // Initialize look-aside lists for receive buffers and packet info blocks
    NdisInitializeNPagedLookasideList( &gCopyBufferList, NULL, NULL, 0, MAX_PACKET_SIZE, 'gdrB', 0 );
    NdisInitializeNPagedLookasideList( &gPktInfoList, NULL, NULL, 0, sizeof(PACKET_INFO), 'gdrB', 0 );

    // Initialize the miniport's quota information
    BrdgBufInitializeQuota( &gMiniportQuota );

    //
    // Read in registry values. Substitute default values on failure.
    //
    NtStatus = BrdgReadRegDWord( &gRegistryPath, gMaxBufMemoryParameterName, &MaxMemory );

    if( NtStatus != STATUS_SUCCESS )
    {
        MaxMemory = DEFAULT_MAX_BUF_MEMORY;
        DBGPRINT(BUF, ( "Using DEFAULT maximum memory of %i\n", MaxMemory ));
    }

    NtStatus = BrdgReadRegDWord( &gRegistryPath, gSafetyMarginParameterName, &SafetyMargin );

    if( NtStatus != STATUS_SUCCESS )
    {
        SafetyMargin = DEFAULT_SAFETY_MARGIN;
        DBGPRINT(BUF, ( "Using DEFAULT safety margin of %i%%\n", SafetyMargin ));
    }

    //
    // Figure out the maximum number of packet descriptors in each pool we can allocate in order to
    // fit in the prescribed maximum memory space.
    //
    // For every copy packet, we allow ourselves GUESS_AVERAGE_FANOUT wrapper packets.
    // *Each* wrapper packet is allowed to consume GUESS_BUFFERS_PER_PACKET MDLs.
    // Given these relationships, we can calculate the number of copy packets that will fit in a given
    // memory footprint. The max for all other resources are set in relationship to that number.
    //

    SizeOfPacket = NdisPacketSize( PROTOCOL_RESERVED_SIZE_IN_PACKET );
    ConsumptionPerCopyPacket =  SizeOfPacket * (GUESS_AVERAGE_FANOUT + 1) +         // Packet decriptor memory
                                MAX_PACKET_SIZE +                                   // Copy buffer memory
                                sizeof(PACKET_INFO) * (GUESS_AVERAGE_FANOUT + 1) +  // Packet info block memory
                                sizeof(NDIS_BUFFER) * ((GUESS_AVERAGE_FANOUT * GUESS_BUFFERS_PER_PACKET) + 1);  // MDL memory

    NumCopyPackets = MaxMemory / ConsumptionPerCopyPacket;

    // Allocate the packet pools
    NdisAllocatePacketPool( &Status, &gCopyPacketPoolHandle, NumCopyPackets, PROTOCOL_RESERVED_SIZE_IN_PACKET );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate copy-packet pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisAllocatePacketPool( &Status, &gWrapperPacketPoolHandle, GUESS_AVERAGE_FANOUT * NumCopyPackets, PROTOCOL_RESERVED_SIZE_IN_PACKET );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate wrapper packet pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the buffer pools
    NdisAllocateBufferPool( &Status, &gCopyBufferPoolHandle, NumCopyPackets );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisFreePacketPool( gWrapperPacketPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate copy buffer pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisAllocateBufferPool( &Status, &gWrapperBufferPoolHandle, GUESS_AVERAGE_FANOUT * GUESS_BUFFERS_PER_PACKET * NumCopyPackets );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisFreePacketPool( gWrapperPacketPoolHandle );
        NdisFreeBufferPool( gCopyBufferPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate wrapper buffer pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    gInitedCopyBufferList = gInitedPktInfoList = TRUE;

    // Note the number of each packet type
    gMaxPackets[BrdgQuotaCopyPacket] = NumCopyPackets;
    gMaxPackets[BrdgQuotaWrapperPacket] = NumCopyPackets * GUESS_AVERAGE_FANOUT;

    // Calculate the safety buffer size in packets
    SAFEASSERT( SafetyMargin > 0L );
    gSafetyBuffer[BrdgQuotaCopyPacket] = (gMaxPackets[BrdgQuotaCopyPacket] * SafetyMargin) / 100;
    gSafetyBuffer[BrdgQuotaWrapperPacket] = (gMaxPackets[BrdgQuotaWrapperPacket] * SafetyMargin) / 100;

    DBGPRINT(BUF, (  "Max memory usage of %d == %d copy packets, %d wrapper packets, %d copy-buffer space, %d/%d safety packets\n",
                MaxMemory, gMaxPackets[0], gMaxPackets[1], NumCopyPackets * MAX_PACKET_SIZE, gSafetyBuffer[0], gSafetyBuffer[1] ));

    // Pre-allocate the appropriate number of packets from each pool for perf.
    for( i = 0; i < gSafetyBuffer[BrdgQuotaCopyPacket]; i++ )
    {
        PNDIS_PACKET        pPacket;
        PPACKET_INFO        ppi;

        pPacket = BrdgBufGetNewCopyPacket( &ppi );

        // Should be impossible for this to fail
        if( (pPacket != NULL) && (ppi != NULL) )
        {
            // Count the usage ourselves because we're not going through normal channels
            gUsedPackets[BrdgQuotaCopyPacket]++;

            // This should retain the packet in memory and decrement the usage count
            BrdgBufFreeBaseCopyPacket( pPacket, ppi );
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    for( i = 0; i < gSafetyBuffer[BrdgQuotaWrapperPacket]; i++ )
    {
        PNDIS_PACKET        pPacket;
        PPACKET_INFO        ppi;

        pPacket = BrdgBufGetNewWrapperPacket( &ppi );

        // Should be impossible for this to fail
        if( (pPacket != NULL) && (ppi != NULL) )
        {
            // Count the usage ourselves because we're not going through normal channels
            gUsedPackets[BrdgQuotaWrapperPacket]++;

            // This should retain the packet in memory and decrement the usage count
            BrdgBufFreeBaseWrapperPacket( pPacket, ppi );
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    return STATUS_SUCCESS;
}

VOID
BrdgBufCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_HANDLE     TmpHandle;

    if( gCopyPacketPoolHandle != NULL )
    {
        PBSINGLE_LIST_ENTRY     entry;

        TmpHandle = gCopyPacketPoolHandle;
        gCopyPacketPoolHandle = NULL;

        // Free all cached packets before freeing the pool
        entry = BrdgInterlockedRemoveHeadSingleList( &gFreeCopyPacketList, &gFreeCopyPacketListLock );

        while( entry != NULL )
        {
            PNDIS_PACKET            pPacket;
            PPACKET_INFO            ppi;
            PNDIS_BUFFER            pBuffer;

            ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
            pPacket = ppi->pOwnerPacket;
            SAFEASSERT( pPacket != NULL );

            // Pull off the data buffer
            NdisUnchainBufferAtFront( pPacket, &pBuffer );

            if( pBuffer != NULL )
            {
                PVOID                   pBuf;
                UINT                    Size;

                NdisQueryBufferSafe( pBuffer, &pBuf, &Size, NormalPagePriority );

                if( pBuf != NULL )
                {
                    // Ditch the data buffer
                    NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
                }
                // else can only fail under extreme memory pressure

                NdisFreeBuffer( pBuffer );
            }
            else
            {
                // This packet should have a chained buffer
                SAFEASSERT( FALSE );
            }

            NdisFreePacket( pPacket );
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );

            entry = BrdgInterlockedRemoveHeadSingleList( &gFreeCopyPacketList, &gFreeCopyPacketListLock );
        }

        // Free the pool now that all packets have been returned
        NdisFreePacketPool( TmpHandle );
    }

    if( gWrapperPacketPoolHandle != NULL )
    {
        PBSINGLE_LIST_ENTRY     entry;

        TmpHandle = gWrapperPacketPoolHandle;
        gWrapperPacketPoolHandle = NULL;

        // Free all cached packets before freeing the pool
        entry = BrdgInterlockedRemoveHeadSingleList( &gFreeWrapperPacketList, &gFreeWrapperPacketListLock );

        while( entry != NULL )
        {
            PNDIS_PACKET            pPacket;
            PPACKET_INFO            ppi;

            ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
            pPacket = ppi->pOwnerPacket;
            SAFEASSERT( pPacket != NULL );
            NdisFreePacket( pPacket );
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );

            entry = BrdgInterlockedRemoveHeadSingleList( &gFreeWrapperPacketList, &gFreeWrapperPacketListLock );
        }

        // Free the pool now that all packets have been returned
        NdisFreePacketPool( TmpHandle );
    }

    // The two lookaside lists should now be empty as well
    if( gInitedCopyBufferList )
    {
        gInitedCopyBufferList = FALSE;
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
    }

    if( gInitedPktInfoList )
    {
        gInitedPktInfoList = FALSE;
        NdisDeleteNPagedLookasideList( &gPktInfoList );

    }

    if( gCopyBufferPoolHandle != NULL )
    {
        TmpHandle = gCopyBufferPoolHandle;
        gCopyBufferPoolHandle = NULL;
        NdisFreeBufferPool( TmpHandle );
    }

    if( gWrapperBufferPoolHandle != NULL )
    {
        TmpHandle = gWrapperBufferPoolHandle;
        gWrapperBufferPoolHandle = NULL;
        NdisFreeBufferPool( TmpHandle );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgBufAssignQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt,
    IN BOOLEAN              bCountAlloc
    )
/*++

Routine Description:

    Determines whether a particular adapter should be permitted to allocate a new packet
    from a particular pool. Implements our quota algorithm.

    This can be called either to pre-approve an actual memory allocation or to check if
    an adapter should be permitted to refer to a base packet in constructing a child
    wrapper packet

Arguments:

    type                    Type of packet pAdapt wishes to allocate or refer to
    pAdapt                  The adapter involved

    bCountAlloc             Whether this is a check before an actual allocation. If it
                            is, the global usage counts will be incremented within the
                            gQuotaLock spin lock so everything is atomic

Return Value:

    TRUE        :       The adapter is permitted to allocate / refer
    FALSE       :       The adapter is not permitted to allocate / refer

--*/
{
    BOOLEAN                 rc;
    PADAPTER_QUOTA          pQuota = QUOTA_FROM_ADAPTER(pAdapt);
    UINT                    index = INDEX_FROM_TYPE(type);

    // Freeze this value for the duration of the function
    ULONG                   numAdapters = gNumAdapters;

    NdisAcquireSpinLock( &gQuotaLock );

    if( (numAdapters > 0) && (pQuota->UsedPackets[index] < (gMaxPackets[index] - gSafetyBuffer[index]) / numAdapters) )
    {
        // This adapter is under its "fair share"; it can allocate if there are actually
        // any packets left!

        if( gUsedPackets[index] < gMaxPackets[index] )
        {
            // There are packets left. This is the normal case.
            rc = TRUE;
        }
        else if( gUsedPackets[index] == gMaxPackets[index] )
        {
            // This should be unusual; we've blown past our safety buffer. Hopefully this is
            // transitory.
            ExInterlockedAddLargeStatistic( &gStatOverflows[index], 1L );
            rc = FALSE;
        }
        else
        {
            // This should never happen; it means we have allocated more than we should be able
            // to.
            SAFEASSERT( FALSE );
            rc = FALSE;
        }
    }
    else
    {
        // This adapter is over its "fair share"; it can allocate only if there are more packets
        // left than the safety buffer calls for

        if( gMaxPackets[index] - gUsedPackets[index] > gSafetyBuffer[index] )
        {
            rc = TRUE;
        }
        else
        {
            // We're too close to the wire; deny the request.
            rc = FALSE;
        }
    }

    if( rc )
    {
        pQuota->UsedPackets[index]++;

        if( bCountAlloc )
        {
            // The caller will allocate. Count the allocation before releasing the spin lock.
            gUsedPackets[index]++;

#if DBG
            // Keep track of the maximum used packets
            if( gMaxUsedPackets[index] < gUsedPackets[index] )
            {
                gMaxUsedPackets[index] = gUsedPackets[index];
            }
#endif
        }
    }

    NdisReleaseSpinLock( &gQuotaLock );
    return rc;
}

PNDIS_PACKET
BrdgBufGetNewCopyPacket(
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Allocates a brand new packet from the copy-packet pool. Every copy packet comes with
    an associated data buffer large enough to hold a complete Ethernet frame, so the allocation
    attempt has several steps

Arguments:

    pppi                    The packet's info block, or NULL if the allocation fails

Return Value:

    The new packet

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;

    // Try to allocate a packet and info block from our underlying pools
    pPacket = BrdgBufCommonGetNewPacket( gCopyPacketPoolHandle, &ppi );

    if( (pPacket == NULL) || (ppi == NULL) )
    {
        SAFEASSERT( (pPacket == NULL) && (ppi == NULL) );
    }
    else
    {
        PVOID           pBuf;

        // Allocate a copy buffer for the packet
        pBuf = NdisAllocateFromNPagedLookasideList( &gCopyBufferList );

        if( pBuf == NULL )
        {
            NdisFreePacket( pPacket );
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
            ppi = NULL;
            pPacket = NULL;
        }
        else
        {
            NDIS_STATUS     Status;
            PNDIS_BUFFER    pBuffer;

            // Allocate a buffer descriptor for the copy buffer
            NdisAllocateBuffer( &Status, &pBuffer, gCopyBufferPoolHandle, pBuf, MAX_PACKET_SIZE );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                NdisFreePacket( pPacket );
                NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
                NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
                ppi = NULL;
                pPacket = NULL;
            }
            else
            {
                SAFEASSERT( pBuffer != NULL );
                NdisChainBufferAtFront( pPacket, pBuffer );
            }
        }
    }

    *pppi = ppi;
    return pPacket;
}

PNDIS_PACKET
BrdgBufCommonGetNewPacket(
    IN NDIS_HANDLE          Pool,
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Common logic for allocating a brand new packet from either the wrapper pool or the copy pool.
    Every packet of any flavor comes with an associated info block. Both the alloc of the
    packet descriptor and the info block must succeed for the packet allocation to succeed.

Arguments:

    Pool                    The pool to allocate from
    pppi                    The allocated info block or NULL if the alloc failed

Return Value:

    The new packet or NULL if the alloc failed

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;
    NDIS_STATUS             Status;

    // Try to allocate a new packet descriptor
    NdisAllocatePacket( &Status, &pPacket, Pool );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        *pppi = NULL;
        return NULL;
    }

    SAFEASSERT( pPacket != NULL );

    // Try to allocate a new packet info block
    ppi = NdisAllocateFromNPagedLookasideList( &gPktInfoList );

    if( ppi == NULL )
    {
        NdisFreePacket( pPacket );
        pPacket = NULL;
    }
    else
    {
        ppi->pOwnerPacket = pPacket;
    }

    *pppi = ppi;
    return pPacket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgcomp.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgsta.h

Abstract:

    Ethernet MAC level bridge
    Compatibility-Mode section header file

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    September 2000 - Original version

--*/

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgCompDriverInit();

VOID
BrdgCompCleanup();

BOOLEAN
BrdgCompRequiresCompatWork(
    IN PADAPT           pAdapt,
    IN PUCHAR           pPacketData,
    IN UINT             dataSize
    );

BOOLEAN
BrdgCompProcessInboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pAdapt,
    IN BOOLEAN          bCanRetain
    );

VOID
BrdgCompProcessOutboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pTargetAdapt
    );

VOID
BrdgCompNotifyNetworkAddresses(
    IN PNETWORK_ADDRESS_LIST    pAddressList,
    IN ULONG                    infoLength
    );

VOID
BrdgCompNotifyMACAddress(
    IN PUCHAR           pBridgeMACAddr
    );

VOID
BrdgCompScrubAdapter(
    IN PADAPT           pAdapt
    );

VOID 
BrdgCompScrubAllAdapters();

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Whether or not ANY compatibility-mode adapters exist.
// Must be updated with a write lock on the global adapter list.
extern BOOLEAN          gCompatAdaptersExist;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgcomp.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    brdgcomp.c

Abstract:

    Ethernet MAC level bridge.
    Compatibility-Mode section

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    September 2000 - Original version

Notes

    Currently, this code only works with traditional Ethernet framing (dest, src, ethertype).
    Much of the code would need to be changed to support IEEE 802.3-style framing
    (dest, src, size, LLC DSAP, LLC SSAP, LLC type).

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>

// TCPIP.SYS structure definitions
#include <ipinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgcomp.h"

#include "brdgfwd.h"
#include "brdgbuf.h"

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// An IPv4 address
typedef UINT32      IPADDRESS;
typedef PUINT32     PIPADDRESS;

// Types of ARP packets
typedef enum
{
    ArpRequest,
    ArpReply
} ARP_TYPE;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

// Size of the payload of an IPv4 ARP packet
#define SIZE_OF_ARP_DATA            28      // bytes

// Total size of an IPv4 ARP packet, including framing
#define SIZE_OF_ARP_PACKET          (SIZE_OF_ARP_DATA + ETHERNET_HEADER_SIZE)

// Size of a basic IPv4 header, not including options
#define SIZE_OF_BASIC_IP_HEADER     20      // bytes

// Minimum amount of frame data we need to parse the IP header
#define MINIMUM_SIZE_FOR_IP         (ETHERNET_HEADER_SIZE + SIZE_OF_BASIC_IP_HEADER)

// Size of a basic UDP header
#define SIZE_OF_UDP_HEADER          8       // bytes

// Minimum size of the payload of a BOOTP packet
#define SIZE_OF_BASIC_BOOTP_PACKET  236     // bytes

// The IP Ethertype
const USHORT IP_ETHERTYPE         = 0x0800;

// The ARP Ethertype
const USHORT ARP_ETHERTYPE        = 0x0806;

// The UDP IP protocol type
const UCHAR UDP_PROTOCOL          = 0x11;

// Number of hash buckets in the IP and pending-ARP tables. This must
// be a power of 2 for our hash function to work propery.
#define NUM_HASH_BUCKETS            256

// Number of hash buckets for the pending-DHCP table. This
// must be a power of 2 for our hash function to work properly.
#define NUM_DHCP_HASH_BUCKETS       32

// The "shift factor" for our IP next-hop cache. The number of entries
// in the cache is 2 ^ (this number)
#define HOP_CACHE_SHIFT_FACTOR      8               // 256 cache entries

// Default size cap for the IP forwarding table
#define DEFAULT_MAX_IP_TABLE_SIZE   (500 * 1024)    // 500K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxIPTableSizeParameterName = L"MaxIPTableSize";

// Default size cap for the pending-ARP table
#define DEFAULT_MAX_ARP_TABLE_SIZE  (100 * 1024)    // 100K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxARPTableSizeParameterName = L"MaxARPTableSize";

// Default size cap for the pending-DHCP table
#define DEFAULT_MAX_DHCP_TABLE_SIZE (50 * 1024)     // 50K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxDHCPTableSizeParameterName = L"MaxDHCPTableSize";

//
// Timeout length for IP forwarding table entries
//
// This should be somewhat longer than the time it takes hosts to age out
// their ARP table entries, since we learn the location of IP hosts
// by ARP traffic. Current Windows implementations age out their
// ARP table entries after 2 minutes if there has been no traffic from
// the station corresponding to the entry.
//
// We keep our forwarding table entries alive indefinitely as long as we
// continue to see IP traffic from the hosts we have information about.
// Windows implementations will age out their ARP entries under those
// conditions after 20mins or so.
//
#define MAX_IP_ENTRY_AGE            (5 * 60 * 1000)     // 5 minutes in ms

//
// Timeout length for pending-ARP table entries
//
// This should be somewhat longer than the maximum time hosts will wait to
// hear the results of an ARP discovery before timing out. Windows boxes
// have a giveup time of 1s.
//
// Note that it is not destructive to deliver ARP reply packets to a station
// after it has given up or even after its initial discovery was
// satisfied.
//
#define MAX_ARP_ENTRY_AGE           (10 * 1000)         // 10 seconds

//
// Timeout length for pending-DHCP table entries
//
// RFC 2131 mentions that clients may wait as long as 60 seconds for an
// ACK. Have the timeout be somewhat longer than even that.
//
#define MAX_DHCP_ENTRY_AGE          (90 * 1000)         // 1 1/2 minutes

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

// Structure to express the information carried in ARP packets
typedef struct _ARPINFO
{

    ARP_TYPE            type;
    IPADDRESS           ipSource, ipTarget;
    UCHAR               macSource[ETH_LENGTH_OF_ADDRESS];
    UCHAR               macTarget[ETH_LENGTH_OF_ADDRESS];

} ARPINFO, *PARPINFO;

// Structure to express the information carried in an IP header
typedef struct _IP_HEADER_INFO
{

    UCHAR               protocol;
    IPADDRESS           ipSource, ipTarget;
    USHORT              headerSize;

} IP_HEADER_INFO, *PIP_HEADER_INFO;

// Structure of our IP forwarding hash table entries
typedef struct _IP_TABLE_ENTRY
{

    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    PADAPT              pAdapt;
    UCHAR               macAddr[ETH_LENGTH_OF_ADDRESS];

} IP_TABLE_ENTRY, *PIP_TABLE_ENTRY;

//
// Structure of the pending-ARP table keys. We want this to get
// packet into 8 bytes.
//
typedef struct _ARP_TABLE_KEY
{
    IPADDRESS           ipTarget;
    IPADDRESS           ipReqestor;
} ARP_TABLE_KEY, *PARP_TABLE_KEY;

// Structure of our pending-ARP hash table entries
typedef struct _ARP_TABLE_ENTRY
{

    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    // Information on the station that was trying to discover this host
    // The discovering station's IP address is part of the entry key.
    PADAPT              pOriginalAdapt;
    UCHAR               originalMAC[ETH_LENGTH_OF_ADDRESS];

} ARP_TABLE_ENTRY, *PARP_TABLE_ENTRY;

// Structure of our DHCP-relay table entries
typedef struct _DHCP_TABLE_ENTRY
{
    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    UCHAR               requestorMAC[ETH_LENGTH_OF_ADDRESS];
    PADAPT              pRequestorAdapt;
} DHCP_TABLE_ENTRY, *PDHCP_TABLE_ENTRY;

// Structure for deferring an ARP packet transmission
typedef struct _DEFERRED_ARP
{
    ARPINFO             ai;
    PADAPT              pTargetAdapt;
} DEFERRED_ARP, *PDEFERRED_ARP;

// Per-adapter rewriting function
typedef VOID (*PPER_ADAPT_EDIT_FUNC)(PUCHAR, PADAPT, PVOID);

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

//
// Whether or not there are *any* compatibility-mode adapters in our list
// at the moment. Is updated in the protocol module with a write lock
// held on the global adapter list
//
BOOLEAN                         gCompatAdaptersExist = FALSE;

//
// Our list of the bridge machine's IP addresses (passed down through an
// OID). The list is allocated on the heap and is protected by
// gLocalIPAddressLock.
//
PIPADDRESS                      gLocalIPAddressList = NULL;
ULONG                           gLocalIPAddressListLength = 0L;
NDIS_RW_LOCK                    gLocalIPAddressListLock;

//
// The IP address-based forwarding table
//
PHASH_TABLE                     gIPForwardingTable;

//
// Our table to hold pending ARP requests so we can proxy back replies
//
PHASH_TABLE                     gPendingARPTable;

//
// Our table to hold pending DHCP requests so we can translate DHCP packets
// appropriately (the MAC address of the requesting station is carried
// in a DHCP request and has to be edited when we relay it)
//
PHASH_TABLE                     gPendingDHCPTable;

//
// A cache of IP next-hop information to avoid hammering the IP drivers's
// route table
//
CACHE                           gNextHopCache;

// Special IP address indicating a negative cache entry (we tried previously
// and got no answer)
const IPADDRESS                 NO_ADDRESS = 0xFFFFFFFF;

// Whether we have an overall MAC address for the bridge miniport yet
BOOLEAN                         gCompHaveMACAddress = FALSE;

// Our overall MAC address (cached here instead of calling the miniport
// section all the time to increase perf)
UCHAR                           gCompMACAddress[ETH_LENGTH_OF_ADDRESS];

// Pointers and handles for interacting with TCP
HANDLE                          gTCPFileHandle = NULL;
PFILE_OBJECT                    gTCPFileObject = NULL;
PDEVICE_OBJECT                  gTCPDeviceObject = NULL;

// Pointers and handles for interacting with IP
HANDLE                          gIPFileHandle = NULL;
PFILE_OBJECT                    gIPFileObject = NULL;
PDEVICE_OBJECT                  gIPDeviceObject = NULL;

// Lock to protect the references above
NDIS_SPIN_LOCK                  gTCPIPLock;

// IRP posted to TCPIP for notifications of when the route table changes.
// Manipulated with InterlockedExchange.
PIRP                            gIPRouteChangeIRP = NULL;

// Refcount to allow us to block and wait when people are using the TCP
// driver
WAIT_REFCOUNT                   gTCPIPRefcount;

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

BOOLEAN
BrdgCompDecodeARPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     dataLen,
    OUT PARPINFO                pARPInfo
    );

VOID
BrdgCompTransmitARPPacket(
    IN PADAPT                   pAdapt,
    IN PARPINFO                 pARPInfo
    );

BOOLEAN
BrdgCompDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PIP_HEADER_INFO         piphi
    );

BOOLEAN
BrdgCompProcessOutboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    );

BOOLEAN
BrdgCompProcessOutboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    );

BOOLEAN
BrdgCompProcessInboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    );

BOOLEAN
BrdgCompProcessInboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    );

VOID
BrdgCompTransmitDeferredARP(
    IN PVOID                    pData
    );

BOOLEAN
BrdgCompProcessInboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData
    );

BOOLEAN
BrdgCompProcessOutboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt,
    IN PUCHAR                   pBootPData,
    IN PIP_HEADER_INFO          piphi
    );

BOOLEAN
BrdgCompIsUnicastIPAddress(
    IN IPADDRESS        ip
    );

VOID
BrdgCompAttachToTCPIP(
    IN PVOID            ignored
    );

VOID
BrdgCompDetachFromTCPIP(
    IN PVOID            ignored
    );

BOOLEAN
BrdgCompIsLocalIPAddress(
    IN IPADDRESS                ipAddr
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
//  This retrieves the Ethertype of an Ethernet frame from a pointer
//  to its header.
//
__forceinline
USHORT
BrdgCompGetEtherType(
    IN PUCHAR           pEtherHeader
    )
{
    USHORT              retVal;

    // The two bytes immediately following the source and destination addresses
    // encode the Ethertype, most significant byte first.
    retVal = 0L;
    retVal |= (pEtherHeader[2 * ETH_LENGTH_OF_ADDRESS]) << 8;
    retVal |= pEtherHeader[2 * ETH_LENGTH_OF_ADDRESS + 1];

    return retVal;
}

//
// Transmits a packet on an adapter after rewriting the source MAC address
// to be the adapter's own MAC address.
//
// The caller relinquishes ownership of the packet with this call.
//
__forceinline
VOID
BrdgCompSendPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt
    )
{
    // Rewrite the source MAC address to be our address
    ETH_COPY_NETWORK_ADDRESS(pPacketData + ETH_LENGTH_OF_ADDRESS, pAdapt->MACAddr);
    BrdgFwdSendPacketForCompat(pPacket, pAdapt);
}

//
// Transmits a packet, dealing with an optional editing function if one is
// present
//
__forceinline
VOID
BrdgCompEditAndSendPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pFunc,
    IN PVOID                    pData
    )
{
    if( pFunc != NULL )
    {
        (*pFunc)(pPacketData, pAdapt, pData);
    }

    BrdgCompSendPacket( pPacket, pPacketData, pAdapt );
}

//
// Transmits a packet, dealing with the possibility that we are not allowed to
// retain the packet and setting the destination MAC address to a specified
// value
//
// Returns whether the input packet was retained
//
__inline
BOOLEAN
BrdgCompEditAndSendPacketOrPacketCopy(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pDestMAC,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pFunc,
    IN PVOID                    pData
    )
{
    UINT                        dataLen;

    SAFEASSERT( (pPacket != NULL) && (pPacketData != NULL) );

    if( !bCanRetain )
    {
        // We aren't allowed to use the original packet. Make a copy.
        pPacket = BrdgFwdMakeCompatCopyPacket(pPacket, &pPacketData, &dataLen, FALSE);
    }

    if( (pPacket != NULL) && (pPacketData != NULL) )
    {
        // Poke the destination MAC address
        ETH_COPY_NETWORK_ADDRESS(pPacketData, pDestMAC);
        BrdgCompEditAndSendPacket(pPacket, pPacketData, pAdapt, pFunc, pData);
    }

    // If we were allowed to retain the packet, we did.
    return bCanRetain;
}

//
// Indicates a packet to the local machine. If the target MAC address was previously
// the adapter's hardware MAC address, it is rewritten to the bridge adapter's
// overall MAC address.
//
// The caller relinquishes ownership of the packet with this call.
//
__inline
VOID
BrdgCompIndicatePacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt          // Receiving adapter
    )
{
    // No packet indications can occur until we have a MAC address
    if( gCompHaveMACAddress )
    {
        UINT                    Result;

        // See if this frame was targeted at this adapter's MAC address.
        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketData, pAdapt->MACAddr, &Result);

        if( Result == 0 )
        {
            ETH_COPY_NETWORK_ADDRESS( pPacketData, gCompMACAddress );
        }
        else
        {
            // We expect to only be indicating frames unicast to this machine
            // or sent to bcast / multicast hardware addresses.
            SAFEASSERT( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) );
        }

        BrdgFwdIndicatePacketForCompat( pPacket );
    }
}

//
// Indicates a packet to the local machine, making a copy of the packet if
// necessary.
//
__inline
BOOLEAN
BrdgCompIndicatePacketOrPacketCopy(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
{
    if( bCanRetain )
    {
        if( pEditFunc != NULL )
        {
            (*pEditFunc)(pPacketData, LOCAL_MINIPORT, pData);
        }

        BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
    }
    else
    {
        UINT                    packetLen;

        // Make our own copy of the packet for indication
        pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

        if( pPacket != NULL )
        {
            if( pEditFunc != NULL )
            {
                (*pEditFunc)(pPacketData, LOCAL_MINIPORT, pData);
            }

            BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
        }
        else
        {
            DBGPRINT(COMPAT, ("Failed to acquire a packet for indication in BrdgCompIndicatePacketOrPacketCopy\n"));
        }
    }

    // If we were allowed to retain the packet, we did.
    return bCanRetain;
}

//
// The IP and UDP checksums treat the data they are checksumming as a
// sequence of 16-bit words. The checksum is carried as the bitwise
// inverse of the actual checksum (~C). The formula for calculating
// the new checksum as transmitted, ~C', given that a 16-bit word of
// the checksummed data has changed from w to w' is
//
//      ~C' = ~C + w + ~w' (addition in ones-complement)
//
// This function returns the updated checksum given the original checksum
// and the original and new values of a word in the checksummed data.
//
__forceinline
USHORT
BrdgCompRecalcChecksum(
    IN USHORT                   oldChecksum,
    IN USHORT                   oldWord,
    IN USHORT                   newWord
    )
{
    ULONG                       sum;

    sum = oldChecksum + oldWord + ((~(newWord)) & 0xFFFF);
    return (USHORT)((sum & 0xFFFF) + (sum >> 16));
}

//
// Rewrites a BootP packet so the client MAC address in the packet payload
// is the given new MAC address
//
__inline
BrdgCompRewriteBootPClientAddress(
    IN PUCHAR                   pPacketData,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   newMAC
    )
{
    USHORT                      checkSum;
    PUCHAR                      pBootPData, pCheckSum, pDestMAC, pSrcMAC;
    UINT                        i;

    // The BOOTP packet lives right after the UDP header
    pBootPData = pPacketData + ETHERNET_HEADER_SIZE + piphi->headerSize + SIZE_OF_UDP_HEADER;

    // The checksum lives at offset 7 in the UDP packet.
    pCheckSum = pPacketData + ETHERNET_HEADER_SIZE + piphi->headerSize + 6;
    checkSum = 0;
    checkSum = pCheckSum[0] << 8;
    checkSum |= pCheckSum[1];

    // Replace the client's hardware address, updating the checksum as we go.
    // The client's hardware address lives at offset 29 in the BOOTP packet
    pSrcMAC = newMAC;
    pDestMAC = &pBootPData[28];

    for( i = 0 ; i < ETH_LENGTH_OF_ADDRESS / 2; i++ )
    {
        checkSum = BrdgCompRecalcChecksum( checkSum,
                                           (USHORT)(pDestMAC[0] << 8 | pDestMAC[1]),
                                           (USHORT)(pSrcMAC[0] << 8 | pSrcMAC[1]) );

        pDestMAC[0] = pSrcMAC[0];
        pDestMAC[1] = pSrcMAC[1];

        pDestMAC += 2;
        pSrcMAC += 2;
    }

    // Write the new checksum back out
    pCheckSum[0] = (UCHAR)(checkSum >> 8);
    pCheckSum[1] = (UCHAR)(checkSum & 0xFF);
}

//
// Rewrites an oubound ARP packet so the source MAC address carried in the payload
// matches the MAC address of the outbound adapter
//
VOID
BrdgCompRewriteOutboundARPPacket(
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PVOID                    ignored
    )
{
    //
    // Rewrite the source MAC address so it is the MAC address of the adapter the
    // request is going out on.
    //
    pPacketData[22] = pAdapt->MACAddr[0];
    pPacketData[23] = pAdapt->MACAddr[1];
    pPacketData[24] = pAdapt->MACAddr[2];
    pPacketData[25] = pAdapt->MACAddr[3];
    pPacketData[26] = pAdapt->MACAddr[4];
    pPacketData[27] = pAdapt->MACAddr[5];

    // Leave the rewriting of the MAC address in the actual Ethernet header to
    // BrdgCompSendPacket(), which always overwrites the source MAC address
    // with the adapter's MAC address.
}

//
// Provides a PDEVICE_OBJECT and a PFILE_OBJECT that can be used to talk to
// TCPIP.SYS. Returns TRUE if a channel is open and the pointers can be used,
// FALSE otherwise.
//
__inline
BOOLEAN
BrdgCompAcquireTCPIP(
    OUT PDEVICE_OBJECT OPTIONAL     *pTCPpdo,
    OUT PFILE_OBJECT OPTIONAL       *pTCPpfo,
    OUT PDEVICE_OBJECT OPTIONAL     *pIPpdo,
    OUT PFILE_OBJECT OPTIONAL       *pIPpfo
    )
{
    BOOLEAN             rc = FALSE;

    if( BrdgIncrementWaitRef(&gTCPIPRefcount) )
    {
        NdisAcquireSpinLock( &gTCPIPLock );

        SAFEASSERT( gTCPDeviceObject != NULL );
        SAFEASSERT( gTCPFileHandle != NULL );
        SAFEASSERT( gTCPFileObject != NULL );
        SAFEASSERT( gIPFileHandle != NULL );
        SAFEASSERT( gIPDeviceObject != NULL );
        SAFEASSERT( gIPFileObject != NULL );

        if( pTCPpdo != NULL )
        {
            *pTCPpdo = gTCPDeviceObject;
        }

        if( pTCPpfo != NULL )
        {
            *pTCPpfo = gTCPFileObject;
        }

        if( pIPpdo != NULL )
        {
            *pIPpdo = gIPDeviceObject;
        }

        if( pIPpfo != NULL )
        {
            *pIPpfo = gIPFileObject;
        }

        rc = TRUE;
        NdisReleaseSpinLock( &gTCPIPLock );
    }

    return rc;
}

//
// Releases the refcount on our connection to the TCPIP driver after a
// previous call to BrdgCompAcquireTCPIP().
//
__inline
VOID
BrdgCompReleaseTCPIP()
{
    BrdgDecrementWaitRef( &gTCPIPRefcount );
}

// ====================================================================
//
// These small helper functions would be inline except we need to pass
// pointers to them
//
// ====================================================================

//
// Rewrites a BootP packet for a particular adapter
//
VOID
BrdgCompRewriteBootPPacketForAdapt(
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PVOID                    pData
    )
{
    PIP_HEADER_INFO             piphi = (PIP_HEADER_INFO)pData;

    //
    // pAdapt can be LOCAL_MINIPORT if we're being used to edit a packet
    // for indication to the local machine. No rewriting is necessary
    // in that case.
    //
    if( pAdapt != LOCAL_MINIPORT )
    {
        SAFEASSERT( pAdapt != NULL );
        BrdgCompRewriteBootPClientAddress( pPacketData, piphi, pAdapt->MACAddr );
    }
}

//
// Hashes an IP address. Used for the IP forwarding table as well as
// the pending-ARP table, which uses an extended key made up of
// the target IP address and the requesting station's IP address
//
ULONG
BrdgCompHashIPAddress(
    IN PUCHAR                   pKey
    )
{
    // Our hash function consists of taking the lower portion of the IP
    // address. The number of hash buckets has to be a power of 2 for
    // this to work propery.
    return (*(PULONG)pKey) & (NUM_HASH_BUCKETS - 1);
}

//
// Hashes a DHCP transaction id
//
ULONG
BrdgCompHashXID(
    IN PUCHAR                   pXid
    )
{
    // Our hash function consists of taking the lower portion of the
    // XID. The number of hash buckets has to be a power of 2 for
    // this to work propery.
    return (*(PULONG)pXid) & (NUM_DHCP_HASH_BUCKETS - 1);
}

//
// Returns true if the given IP table entry refers to a certain
// adapter
BOOLEAN
BrdgCompIPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PIP_TABLE_ENTRY             pipte = (PIP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pipte->pAdapt == pAdapt);
}

//
// Returns true if the given ARP table entry refers to a certain
// adapter
//
BOOLEAN
BrdgCompARPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PARP_TABLE_ENTRY            pate = (PARP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pate->pOriginalAdapt == pAdapt);
}

//
// Returns true if the given DHCP table entry refers to a certain
// adapter
//
BOOLEAN
BrdgCompDHCPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PDHCP_TABLE_ENTRY           pdhcpte = (PDHCP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pdhcpte->pRequestorAdapt == pAdapt);
}

//
// Completion function for route lookup IRPs. Returns
// STATUS_MORE_PROCESSING_REQUIRED to prevent the IO manager
// from mucking with the IRP (which we free ourselves).
//
NTSTATUS
BrdgCompCompleteRouteLookupIRP(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pirp,
    IN PVOID            ignored
    )
{
    IoFreeIrp( pirp );
    return STATUS_MORE_PROCESSING_REQUIRED;
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCompDriverInit()
/*++

Routine Description:

    Driver-initialization function for the compatibility module

Arguments:

    None

Return Value:

    Status. Anything other than STATUS_SUCCESS aborts the driver load.

--*/
{
    ULONG           MaxSize, MaxEntries;

    // Initialize the next-hop cache
    if( BrdgInitializeCache(&gNextHopCache, HOP_CACHE_SHIFT_FACTOR) != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE NEXT-HOPE CACHE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // See if the registry specifies a max table size for the IP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxIPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_IP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(IP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping IP forwarding table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));

    gIPForwardingTable = BrdgHashCreateTable( BrdgCompHashIPAddress, NUM_HASH_BUCKETS, sizeof(IP_TABLE_ENTRY),
                                              MaxEntries, MAX_IP_ENTRY_AGE, MAX_IP_ENTRY_AGE, sizeof(IPADDRESS) );

    if( gIPForwardingTable == NULL )
    {
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE IP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Our Pending-ARP table uses ARP_TABLE_KEY structures as a key, but we still use the BrdgCompHashIPAddress
    // routine to hash the keys. This will result in the hash being based on the first part of the key alone (the
    // target IP address), which is what we want, since all the entries for a single target must end up in the
    // same bucket for our multi-match retrieval to work.
    //

    // See if the registry specifies a max table size for the ARP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxARPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_ARP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(ARP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping Pending-ARP table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));
    gPendingARPTable = BrdgHashCreateTable( BrdgCompHashIPAddress, NUM_HASH_BUCKETS, sizeof(ARP_TABLE_ENTRY),
                                            MaxEntries, MAX_ARP_ENTRY_AGE, MAX_ARP_ENTRY_AGE, sizeof(ARP_TABLE_KEY) );

    if( gPendingARPTable == NULL )
    {
        BrdgHashFreeHashTable( gIPForwardingTable );
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE ARP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // See if the registry specifies a max table size for the DHCP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxDHCPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_DHCP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(DHCP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping Pending-DHCP table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));
    gPendingDHCPTable = BrdgHashCreateTable( BrdgCompHashXID, NUM_DHCP_HASH_BUCKETS, sizeof(DHCP_TABLE_ENTRY),
                                             MaxEntries, MAX_DHCP_ENTRY_AGE, MAX_DHCP_ENTRY_AGE, sizeof(ULONG) );

    if( gPendingDHCPTable == NULL )
    {
        BrdgHashFreeHashTable( gIPForwardingTable );
        BrdgHashFreeHashTable( gPendingARPTable );
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE DHCP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize synchronization objects
    NdisInitializeReadWriteLock( &gLocalIPAddressListLock );
    NdisAllocateSpinLock( &gTCPIPLock );
    BrdgInitializeWaitRef( &gTCPIPRefcount, FALSE );

    // We start out with no connection to TCPIP so the waitref needs to be in the shutdown state
    BrdgShutdownWaitRefOnce( &gTCPIPRefcount );

    return STATUS_SUCCESS;
}

VOID
BrdgCompCleanup()
/*++

Routine Description:

    One-time cleanup for the compatibility module

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_STATE          LockState;

    // Detach from TCPIP
    BrdgCompDetachFromTCPIP(NULL);

    // Dump the next-hop cache
    BrdgFreeCache( &gNextHopCache );

    // Dump the forwarding hash table
    BrdgHashFreeHashTable( gIPForwardingTable );
    gIPForwardingTable = NULL;

    // Dump the pending-ARP hash table
    BrdgHashFreeHashTable( gPendingARPTable );
    gPendingARPTable = NULL;

    // Dump the pending-DHCP table
    BrdgHashFreeHashTable( gPendingDHCPTable );
    gPendingDHCPTable = NULL;

    // Clean up the list of network addresses.
    NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-Write*/, &LockState );

    if( gLocalIPAddressListLength > 0L )
    {
        NdisFreeMemory( gLocalIPAddressList, gLocalIPAddressListLength, 0 );
        gLocalIPAddressList = NULL;
        gLocalIPAddressListLength = 0L;
    }

    NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );
}

VOID
BrdgCompScrubAdapter(
                     IN PADAPT           pAdapt
                     )
/*++

Routine Description:

    Removes all table entries that refer to a given adapter; called when that
    adapter is being removed (future references to this adapter are illegal)

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(COMPAT, ("Scrubbing Adapter %p from the compatibility tables...\n", pAdapt));
    
    // Remove all entries referencing this adapter from the IP table
    BrdgHashRemoveMatching( gIPForwardingTable, BrdgCompIPEntriesMatchAdapter, pAdapt );
    
    // Remove all entries referencing this adapter from the pending-ARP table
    BrdgHashRemoveMatching( gPendingARPTable, BrdgCompARPEntriesMatchAdapter, pAdapt );
    
    // Remove all entries referencing this adapter from the DHCP table
    BrdgHashRemoveMatching( gPendingDHCPTable, BrdgCompDHCPEntriesMatchAdapter, pAdapt );
}

VOID BrdgCompScrubAllAdapters()
/*++

Routine Description:

    This function cleans all the adapters from the IP tables (this is in the case of a GPO changing
    our bridging settings)
  
Arguments:

    None

Return Value:

    None

--*/
{
    PADAPT                      pAdapt = NULL;
    LOCK_STATE                  LockStateAdapterList;
    
    //
    // We don't want an adapter to go away while we're running through the list of adapters.
    //
    NdisAcquireReadWriteLock(&gAdapterListLock, FALSE /* Read Only */, &LockStateAdapterList);
    
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Scrub the adapter from the Compatibility tables.
        BrdgCompScrubAdapter(pAdapt);
    }
    
    NdisReleaseReadWriteLock(&gAdapterListLock, &LockStateAdapterList);
}


VOID
BrdgCompNotifyMACAddress(
    IN PUCHAR           pBridgeMACAddr
    )
/*++

Routine Description:

    Called by the miniport module to notify us of the MAC address of the miniport

Arguments:

    pBridgeMACAddr      Our MAC address

Return Value:

    None

--*/
{
    ETH_COPY_NETWORK_ADDRESS( &gCompMACAddress, pBridgeMACAddr );
    gCompHaveMACAddress = TRUE;
}

BOOLEAN
BrdgCompRequiresCompatWork(
    IN PADAPT           pAdapt,
    IN PUCHAR           pPacketData,
    IN UINT             dataSize
    )
/*++

Routine Description:

    Called during the processing of inbound packets to determine whether a
    packet will require compatibility-mode work.

    The compatibility code requires that its packets be flat, whereas packets
    indicated from underlying miniports can be arbitrarily fragmented. The
    forwarding engine uses the result of this call to determine whether an
    inbound packet must be copied to a flat data buffer in a copy packet that
    we own or whether it can be handled along fast-track paths that don't
    care about packet fragmentation.

Arguments:

    pAdapt              Adapter on which the packet was received
    pPacketDataq        A pointer to the beginning of the packet data
    dataSize            The amount of data pointed to

Return Value:

    TRUE: The forwarding engine should call BrdgCompProcessInboundPacket at
    a later time to process this packet

    FALSE: BrdgCompProcessInboundPacket should never be called for this packet

--*/
{
    UINT                result;
    USHORT              etherType;

    // Weird runty packets are of no use to anyone
    if( dataSize < ETHERNET_HEADER_SIZE )
    {
        return FALSE;
    }

    //
    // No compatibility-mode work is required if there are no compatibility-mode
    // adapters.
    //
    if( !gCompatAdaptersExist )
    {
        return FALSE;
    }

    // All frames that arrive on a compatibility adapter are processed
    if( pAdapt->bCompatibilityMode )
    {
        return TRUE;
    }

    // Broadcast or multicast frames always require compatibility processing
    if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
    {
        return TRUE;
    }

    //
    // The packet was unicast. If it wasn't sent to the adapter's MAC address,
    // it does not require compatibility-mode processing.
    //
    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pPacketData, pAdapt->MACAddr, &result );

    if( result != 0 )
    {
        return FALSE;
    }

    //
    // The packet is only of interest if it is ARP or IP (on a non-compat
    // adapter)
    //
    etherType = BrdgCompGetEtherType( pPacketData );
    return (BOOLEAN)( (etherType == ARP_ETHERTYPE) || (etherType == IP_ETHERTYPE) );
}

BOOLEAN
BrdgCompProcessInboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pAdapt,
    IN BOOLEAN          bCanRetain
    )
/*++

Routine Description:

    Called to hand an inbound packet to the compatibility module for processing.

    If the packet arrived on a non-compatibility adapter, the compatibility
    code should NEVER indicate the packet, as that will be done by the
    regular forwarding engine code. On the other hand, if the packet
    arrived on a compatibility-mode adapter, the compatibility code MUST
    indicate the packet if appropriate. Why the disparity? A packet
    arriving on a compatibility adapter will likely require editing before
    indication, whereas a packet arriving on a non-compatibility adapter
    will not.

    The compatibility module may retain the packet if bCanRetain is TRUE
    (in which case we must return TRUE). If bCanRetain is FALSE, the
    compatibility code may NOT retain the packet. If it needs to forward
    the packet data or indicate the packet, it must make a copy
    packet and use that instead of the original.

Arguments:

    pPacket             The received packet
    pAdapt              The adapter the packet was received on
    bCanRetain          Whether we can hang on to the packet

Return Value:

    TRUE: The packet was retained (should never be returned if bCanRetain == FALSE)
    The caller should not use this packet or attempt to free it.

    FALSE: The packet was not retained. The caller still has ownership of the
    packet and should arrange for it to be freed when appropriate.

--*/
{
    PNDIS_BUFFER        pBuffer;
    PUCHAR              pBufferData;
    UINT                bufferLen = 0;
    UINT                totLen;
    USHORT              etherType;
    BOOLEAN             bRetained;

    NdisGetFirstBufferFromPacketSafe( pPacket, &pBuffer, &pBufferData, &bufferLen,
                                      &totLen, NormalPagePriority );

    if( pBufferData == NULL )
    {
        // The packet was empty or the system is under severe memory pressure
        // We didn't retain the packet.
        return FALSE;
    }

    if( totLen < ETHERNET_HEADER_SIZE )
    {
        return FALSE;
    }

    // The packet should be flat
    SAFEASSERT( totLen == bufferLen );
    etherType = BrdgCompGetEtherType( pBufferData );

    if( etherType == ARP_ETHERTYPE )
    {
        bRetained = BrdgCompProcessInboundARPPacket( pPacket, pAdapt, bCanRetain, pBufferData, bufferLen );
    }
    else
    {
        bRetained = BrdgCompProcessInboundNonARPPacket( pPacket, pAdapt, bCanRetain, pBufferData, bufferLen );
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}


VOID
BrdgCompProcessOutboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pTargetAdapt
    )
/*++

Routine Description:

    Called to hand an outbound packet to the compatibility module for processing.

    Because the packet passed to us is from an overlying protocol driver, we
    are not allowed to do anything with it. The packet may be arbitrarily
    fragmented, and its data buffers must be treated as read-only.

    This function is only called if a packet is bound for an adapter in
    compatibility mode (so we can do any necessary packet editing) or for a packet
    for which we have no known outbound adapter (i.e., it is a packet we are
    flooding).

    In the case that pTargetAdapt == NULL (a flood), the compatibility code is
    responsible for sending the packet out all *compatibility mode* adapters.
    Sending the packet out regular-mode adapters is the job of the regular
    code in the forwarding engine.

Arguments:

    pPacket             The outbound packet
    pTargetAdapt        The target adapter, as determined by a previous lookup in
                        the MAC forwarding table. This can be NULL to indicate
                        a flood.

Return Value:

    None

--*/
{
    PNDIS_PACKET        pCopyPacket;
    PUCHAR              pCopyPacketData;
    UINT                copyPacketSize;

    // There's no point in calling us for a packet that is bound for a MAC
    // address which is known to be reachable on a non-compat adapter
    SAFEASSERT( (pTargetAdapt == NULL) || (pTargetAdapt->bCompatibilityMode) );

    // There is no work to do if there are no compatibility adapters
    if( !gCompatAdaptersExist )
    {
        return;
    }

    // Prepare the flattened copy packet so our functions can edit
    // the packet as appropriate. The packet will be counted as a local-source
    // transmission when / if it is used.
    pCopyPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pCopyPacketData, &copyPacketSize, TRUE );

    if( pCopyPacket != NULL )
    {
        BOOLEAN             bRetained = FALSE;

        if( copyPacketSize >= ETHERNET_HEADER_SIZE )
        {
            USHORT              etherType;

            etherType = BrdgCompGetEtherType(pCopyPacketData);

            if( etherType == ARP_ETHERTYPE )
            {
                bRetained = BrdgCompProcessOutboundARPPacket(pCopyPacket, pCopyPacketData, copyPacketSize, pTargetAdapt);
            }
            else
            {
                bRetained = BrdgCompProcessOutboundNonARPPacket(pCopyPacket, pCopyPacketData, copyPacketSize, pTargetAdapt);
            }
        }
        // else the packet was really small!

        if( ! bRetained )
        {
            // The functions above decided not to hang on to the packet after all.
            // Release it.
            BrdgFwdReleaseCompatPacket( pCopyPacket );
        }
    }
    // Else we didn't get a packet
}


VOID
BrdgCompNotifyNetworkAddresses(
    IN PNETWORK_ADDRESS_LIST    pAddressList,
    IN ULONG                    infoLength
    )
/*++

Routine Description:

    Called by the miniport code when we get an OID indicating our network-layer
    addresses to us. We copy out the list of our IP addresses. The buffer
    passed to us can also be formatted in such a way as to indicate that we
    should dump our list of network addresses.

Arguments:

    pAddressList                The data buffer passed down in the OID
    infoLength                  The size of the buffer

Return Value:

    None

--*/
{
    PIPADDRESS                  pOldList;
    UINT                        oldListLength;
    LOCK_STATE                  LockState;

    if( infoLength < sizeof(NETWORK_ADDRESS_LIST) - sizeof(NETWORK_ADDRESS) )
    {
        // The structure is too small to hold anything interesting.
        return;
    }

    if( pAddressList->AddressCount > 0 )
    {
        USHORT                          i, numAddresses, copiedAddresses = 0;
        NETWORK_ADDRESS UNALIGNED       *pNetAddress;
        NDIS_STATUS                     Status;
        PIPADDRESS                      pNewList;

        //
        // Make sure the structure can hold the number of addresses it claims to.
        // NETWORK_ADDRESS_LIST is defined with one NETWORK_ADDRESS at its tail,
        // so knock one off pAddressList->AddressCount when calculating the
        // size of the total structure.
        //
        if( infoLength < sizeof(NETWORK_ADDRESS_LIST) +
                         ( sizeof(NETWORK_ADDRESS) * (pAddressList->AddressCount - 1) ) )
        {
            // The structure is too small to contain the number of addresses
            // it claims to.

            SAFEASSERT( FALSE );
            return;
        }

        // Make a first pass to count the number of IP addresses in the list
        pNetAddress = pAddressList->Address;

        for( i = 0, numAddresses = 0; i < pAddressList->AddressCount; i++ )
        {
            if( pNetAddress->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
            {
                numAddresses++;
            }

            pNetAddress = (NETWORK_ADDRESS UNALIGNED*)(((PUCHAR)pNetAddress) + pNetAddress->AddressLength);
        }

        if( numAddresses == 0 )
        {
            // There are no IP addresses in this list. Nothing to do.
            return;
        }

        // Allocate enough room to hold the addresses
        Status = NdisAllocateMemoryWithTag( &pNewList, sizeof(IPADDRESS) * numAddresses, 'gdrB' );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(COMPAT, ("NdisAllocateMemoryWithTag failed while recording IP address list\n"));

            // Clobber the old list with a NULL, since we know that the old list is outdated,
            // but we failed to record the new info
            pNewList = NULL;
        }
        else
        {
            SAFEASSERT( pNewList != NULL );

            // Copy the IP addresses to our list
            pNetAddress = pAddressList->Address;

            for( i = 0; i < pAddressList->AddressCount; i++ )
            {
                if( pNetAddress->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
                {
                    NETWORK_ADDRESS_IP UNALIGNED    *pIPAddr;
                    PUCHAR                           pIPNetAddr;

                    SAFEASSERT( copiedAddresses < numAddresses );

                    pIPAddr = (NETWORK_ADDRESS_IP UNALIGNED*)&pNetAddress->Address[0];
                    pIPNetAddr = (PUCHAR)&pIPAddr->in_addr;

                    // IP passes down the IP address in the opposite byte order that we use
                    pNewList[copiedAddresses] = 0L;
                    pNewList[copiedAddresses] |= pIPNetAddr[3];
                    pNewList[copiedAddresses] |= pIPNetAddr[2] << 8;
                    pNewList[copiedAddresses] |= pIPNetAddr[1] << 16;
                    pNewList[copiedAddresses] |= pIPNetAddr[0] << 24;

                    DBGPRINT(COMPAT, ("Noted local IP address %i.%i.%i.%i\n",
                                      pIPNetAddr[0], pIPNetAddr[1], pIPNetAddr[2], pIPNetAddr[3] ));

                    copiedAddresses++;
                }

                pNetAddress = (NETWORK_ADDRESS UNALIGNED*)(((PUCHAR)pNetAddress) + pNetAddress->AddressLength);
            }

            SAFEASSERT( copiedAddresses == numAddresses );
        }

        // Swap in the new list (even if it's NULL)
        NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-write*/, &LockState );

        pOldList = gLocalIPAddressList;
        oldListLength = gLocalIPAddressListLength;

        gLocalIPAddressList = pNewList;

        if( pNewList != NULL )
        {
            gLocalIPAddressListLength = sizeof(IPADDRESS) * numAddresses;
        }
        else
        {
            gLocalIPAddressListLength = 0L;
        }

        NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

        // Ditch the old list if there was one
        if( pOldList != NULL )
        {
            SAFEASSERT( oldListLength > 0L );
            NdisFreeMemory( pOldList, oldListLength, 0 );
        }

        // Only attach to TCPIP if we actually learned some IP addresses
        if( numAddresses > 0 )
        {
            // We are at DISPATCH_LEVEL in this function. Defer the call to BrdgCompAttachToTCPIP
            // so we open a channel of communication to the TCPIP driver.
            BrdgDeferFunction( BrdgCompAttachToTCPIP, NULL );
        }
    }
    else
    {
        // This is a request to clear out our list of network-layer
        // addresses.
        if( pAddressList->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
        {
            DBGPRINT(COMPAT, ("Flushing list of IP addresses\n"));

            // Dump our list of network addresses
            NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-write*/, &LockState );

            pOldList = gLocalIPAddressList;
            oldListLength = gLocalIPAddressListLength;

            gLocalIPAddressList = NULL;
            gLocalIPAddressListLength = 0L;

            NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

            if( oldListLength > 0L )
            {
                SAFEASSERT( pOldList != NULL );
                NdisFreeMemory( pOldList, oldListLength, 0 );
            }

            // Detach from the TCPIP driver at lower IRQL
            BrdgDeferFunction( BrdgCompDetachFromTCPIP, NULL );
        }
    }
}

// ===========================================================================
//
// PRIVATE UTILITY FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCompRouteChangeCompletion(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                pirp,
    PVOID               Context
    )
/*++

Routine Description:

    Called when the IRP we post to TCPIP.SYS completes, indicating a change
    in the IP routing table

Arguments:

    DeviceObject        Unused
    pirp                The completed IRP
    Context             Unused


Return Value:

    STATUS_SUCCESS, indicating we are done with this IRP
    STATUS_MORE_PROCESSING_REQUIRED when we reuse this IRP by reposting it

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PDEVICE_OBJECT          pdo;
    PFILE_OBJECT            pfo;

    DBGPRINT(COMPAT, ("IP route table changed; flushing route cache.\n"));

    // Flush the route cache
    BrdgClearCache( &gNextHopCache );

    //
    // If gIPRouteChangeIRP != pirp, it indicates that we are either detached
    // from TCPIP (gIPRouteChangeIRP == NULL) or we have detached and
    // reattached (gIPRouteChangeIRP != NULL && gIPRouteChangeIRP != pirp).
    // In either case, we should stop reusing this IRP to post route-change
    // notification requests.
    //
    if( (gIPRouteChangeIRP == pirp) && (BrdgCompAcquireTCPIP(NULL, NULL, &pdo, &pfo)) )
    {
        NTSTATUS            status;

        //
        // Reinitialize the IRP structure and submit it again
        // for further notification.
        //

        pirp->Cancel = FALSE;
        pirp->IoStatus.Status = 0;
        pirp->IoStatus.Information = 0;
        pirp->AssociatedIrp.SystemBuffer = NULL;
        IoSetCompletionRoutine( pirp, BrdgCompRouteChangeCompletion,
                                NULL, TRUE, FALSE, FALSE );

        IrpSp = IoGetNextIrpStackLocation(pirp);
        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

        status = IoCallDriver(pdo, pirp);
        BrdgCompReleaseTCPIP();

        if (!NT_SUCCESS(status))
        {
            // We failed to call TCPIP. Release the IRP.
            DBGPRINT(COMPAT, ("Failed to call TCPIP for route notification: %08x\n", status));
            return STATUS_SUCCESS;
        }
        else
        {
            // We keep the IRP since we reposted it to TCPIP
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else
    {
        // We must be detaching or detached from TCPIP. Don't repost the IRP.
        DBGPRINT(COMPAT, ("Stopping our route change notifications...\n"));
        return STATUS_SUCCESS;
    }
}


VOID
BrdgCompAttachToTCPIP(
    IN PVOID            ignored
    )
/*++

Routine Description:

    Establishes a connection to TCPIP for sending future route-lookup requests.
    Opens a connection to the TCPIP driver and posts an IRP for route change
    notifications.

Arguments:

    ignored             ignored


Return Value:

    None

--*/
{
    NTSTATUS            status;
    HANDLE              TCPFileHandle, IPFileHandle;
    PFILE_OBJECT        pTCPFileObject, pIPFileObject;
    PDEVICE_OBJECT      pTCPDeviceObject, pIPDeviceObject;
    BOOLEAN             bAbort = FALSE;

    // Check if there is already a connection open to TCP
    if( BrdgCompAcquireTCPIP(NULL, NULL, NULL, NULL) )
    {
        BrdgCompReleaseTCPIP();
        return;
    }

    // There doesn't appear to currently be a connection to the TCPIP driver.
    // Open one.
    status = BrdgOpenDevice( DD_TCP_DEVICE_NAME, &pTCPDeviceObject, &TCPFileHandle, &pTCPFileObject );

    if( ! NT_SUCCESS(status) )
    {
        DBGPRINT(ALWAYS_PRINT, ("Couldn't open TCP device: %08x\n", status));
        return;
    }

    status = BrdgOpenDevice( DD_IP_DEVICE_NAME, &pIPDeviceObject, &IPFileHandle, &pIPFileObject );

    if( ! NT_SUCCESS(status) )
    {
        DBGPRINT(ALWAYS_PRINT, ("Couldn't open IP device: %08x\n", status));
        BrdgCloseDevice(TCPFileHandle, pTCPFileObject, pTCPDeviceObject);
        return;
    }

    NdisAcquireSpinLock( &gTCPIPLock );

    if( gTCPDeviceObject == NULL )
    {
        SAFEASSERT( gTCPFileHandle == NULL );
        SAFEASSERT( gTCPFileObject == NULL );
        SAFEASSERT( gIPDeviceObject == NULL );
        SAFEASSERT( gIPFileHandle == NULL );
        SAFEASSERT( gIPFileObject ==  NULL );

        // Swap in the info we just obtained.
        gTCPDeviceObject = pTCPDeviceObject;
        gTCPFileHandle = TCPFileHandle;
        gTCPFileObject = pTCPFileObject;
        gIPDeviceObject = pIPDeviceObject;
        gIPFileHandle = IPFileHandle;
        gIPFileObject = pIPFileObject;

        // Let people acquire the TCPIP driver
        BrdgResetWaitRef( &gTCPIPRefcount );
    }
    else
    {
        // Someone else opened TCPIP.SYS between our initial call to BrdgCompAcquireTCPIP
        // and now. This should be rather rare.
        SAFEASSERT( gTCPFileHandle != NULL );
        SAFEASSERT( gTCPFileObject != NULL );
        SAFEASSERT( gIPDeviceObject != NULL );
        SAFEASSERT( gIPFileHandle != NULL );
        SAFEASSERT( gIPFileObject !=  NULL );

        bAbort = TRUE;
    }

    NdisReleaseSpinLock( &gTCPIPLock );

    if( bAbort )
    {
        // Need to back out of the attempt to open TCPIP.SYS
        BrdgCloseDevice( TCPFileHandle, pTCPFileObject, pTCPDeviceObject );
        BrdgCloseDevice( IPFileHandle, pIPFileObject, pIPDeviceObject );
    }
    else
    {
        if( BrdgCompAcquireTCPIP(NULL, NULL, &pIPDeviceObject, &pIPFileObject) )
        {
            NTSTATUS        status;
            PIRP            pirp;

            // Set up the route-change notification IRP
            pirp = IoBuildDeviceIoControlRequest( IOCTL_IP_RTCHANGE_NOTIFY_REQUEST, pIPDeviceObject,
                                                  NULL, 0, NULL, 0, FALSE, NULL, NULL );

            if( pirp == NULL )
            {
                DBGPRINT(COMPAT, ("Failed to allocate an IRP for route-change notification!\n"));
            }
            else
            {
                if( InterlockedExchangePointer(&gIPRouteChangeIRP, pirp) != NULL )
                {
                    //
                    // Oops; someone else created an IRP to post to TCPIP at the same time as us.
                    // Abort our attempt.
                    //
                    IoCompleteRequest( pirp, IO_NO_INCREMENT );
                }
                else
                {
                    IoSetCompletionRoutine( pirp, BrdgCompRouteChangeCompletion, NULL, TRUE, FALSE, FALSE );

                    status = IoCallDriver( pIPDeviceObject, pirp );

                    if( ! NT_SUCCESS(status) )
                    {
                        DBGPRINT(COMPAT, ("Failed to post IRP to TCPIP for route-change notification: %08x\n", status));
                    }
                    else
                    {
                        DBGPRINT(COMPAT, ("Posted route-change notification request to TCPIP\n"));
                    }
                }
            }

            BrdgCompReleaseTCPIP();
        }
        // else someone shut down the connection to TCPIP very quickly after we set it up
    }
}

VOID
BrdgCompDetachFromTCPIP(
    IN PVOID            ignored
    )
/*++

Routine Description:

    Severs the current connection, if any, to TCPIP.SYS.

Arguments:

    ignored             ignored

Return Value:

    None

--*/
{
    HANDLE              TCPFileHandle, IPFileHandle;
    PFILE_OBJECT        pTCPFileObject, pIPFileObject;
    PDEVICE_OBJECT      pTCPDeviceObject, pIPDeviceObject;
    PIRP                pRouteIRP;

    // Wait for everyone to be done using the driver
    // Ignore return value because we are multi-shutdown-safe.
    BrdgShutdownWaitRef( &gTCPIPRefcount );

    // Cancel the IRP we use for route change notifications.
    pRouteIRP = InterlockedExchangePointer( &gIPRouteChangeIRP, NULL );

    // pRouteIRP can be NULL if someone is shutting down the connection
    // at the same time as us, or if the connection was already shut down
    if( pRouteIRP != NULL )
    {
        IoCancelIrp( pRouteIRP );
    }

    // Flush the route cache
    BrdgClearCache( &gNextHopCache );

    // Copy out the pointers and NULL them
    NdisAcquireSpinLock( &gTCPIPLock );
    TCPFileHandle = gTCPFileHandle;
    gTCPFileHandle = NULL;
    pTCPFileObject = gTCPFileObject;
    gTCPFileObject = NULL;
    pTCPDeviceObject = gTCPDeviceObject;
    gTCPDeviceObject = NULL;
    IPFileHandle = gIPFileHandle;
    gIPFileHandle = NULL;
    pIPFileObject = gIPFileObject;
    gIPFileObject = NULL;
    pIPDeviceObject = gIPDeviceObject;
    gIPDeviceObject = NULL;
    NdisReleaseSpinLock( &gTCPIPLock );

    // The global pointers can be NULL if someone else is shutting down the
    // connection concurrently with us, or if the connection was already
    // shut down.
    if( pTCPFileObject != NULL )
    {
        SAFEASSERT( TCPFileHandle != NULL );
        SAFEASSERT( pTCPDeviceObject != NULL );
        SAFEASSERT( IPFileHandle != NULL );
        SAFEASSERT( pIPFileObject != NULL );
        SAFEASSERT( pIPDeviceObject != NULL );

        BrdgCloseDevice( TCPFileHandle, pTCPFileObject, pTCPDeviceObject );
        BrdgCloseDevice( IPFileHandle, pIPFileObject, pIPDeviceObject );
    }
    else
    {
        SAFEASSERT( TCPFileHandle == NULL );
        SAFEASSERT( pTCPDeviceObject == NULL );
        SAFEASSERT( IPFileHandle == NULL );
        SAFEASSERT( pIPFileObject == NULL );
        SAFEASSERT( pIPDeviceObject == NULL );
    }
}

BOOLEAN
BrdgCompIsUnicastIPAddress(
    IN IPADDRESS        ip
    )
/*++

Routine Description:

    Determines whether a given IP address is a unicast address (i.e., one that
    can reasonably designate a single station)

Arguments:

    ip                  The IP address

Return Value:

    TRUE: The address appears to be a unicast address
    FALSE: The opposite is true

--*/
{
    UCHAR               highByte;

    // The broadcast address is not cool
    if( ip == 0xFFFFFFFF )
    {
        return FALSE;
    }

    // The zero address is no good
    if( ip == 0L )
    {
        return FALSE;
    }

    // Any class D (multicast) or class E (currently undefined) is similarly uncool
    highByte = (UCHAR)(ip >> 24);
    if( (highByte & 0xF0) == 0xE0 || (highByte & 0xF0) == 0xF0 )
    {
        return FALSE;
    }

    // Check each address class to see if this is a net-directed (or all-subnets)
    // broadcast
    if( (highByte & 0x80) && ((ip & 0x00FFFFFF) == 0x00FFFFFFFF) )
    {
        // Class A net-directed or all-subnets broadcast.
        return FALSE;
    }
    else if( ((highByte & 0xC0) == 0x80) && ((ip & 0x0000FFFF) == 0x0000FFFF) )
    {
        // Class B net-directed or all-subnets broadcast.
        return FALSE;
    }
    else if( ((highByte & 0xE0) == 0xC) && ((UCHAR)ip == 0xFF) )
    {
        // Class C net-directed or all-subnets broadcast.
        return FALSE;
    }

    //
    // This address appears to be OK, although note that since we have no way of
    // knowing the subnet prefix in use on the local links, we cannot detect
    // subnet-directed broadcasts.
    //
    return TRUE;
}

BOOLEAN
BrdgCompGetNextHopForTarget(
    IN IPADDRESS                ipTarget,
    OUT PIPADDRESS              pipNextHop
    )
/*++

Routine Description:

    Calls into the TCPIP.SYS driver to determine the next-hop address for a
    given target IP.

Arguments:

    ipTarget                    The target address
    pipNextHop                  Receives the next-hop address

Return Value:

    TRUE if the next-hop lookup succeeded and *pipNextHop is valid, FALSE
    otherwise.

--*/
{
    BOOLEAN                     rc = FALSE;

    // First look for the information in our next-hop cache
    *pipNextHop = BrdgProbeCache( &gNextHopCache, (UINT32)ipTarget );

    if( *pipNextHop != 0L )
    {
        if( *pipNextHop != NO_ADDRESS )
        {
            // The cache contained a valid next hop
            rc = TRUE;
        }
        else
        {
            // We asked TCPIP before about this target address and it
            // told us it doesn't know.
            rc = FALSE;
        }
    }
    else
    {
        PDEVICE_OBJECT      pdo;
        PFILE_OBJECT        pfo;

        if( BrdgCompAcquireTCPIP(&pdo, &pfo, NULL, NULL) )
        {
            PIRP            pirp;

            pirp = IoAllocateIrp( pdo->StackSize, FALSE );

            if( pirp != NULL )
            {
                TCP_REQUEST_QUERY_INFORMATION_EX    trqiBuffer;
                IPRouteLookupData                   *pRtLookupData;
                TDIObjectID                         *lpObject;
                IPRouteEntry                        routeEntry;
                PIO_STACK_LOCATION                  irpSp;
                NTSTATUS                            status;

                RtlZeroMemory (&trqiBuffer, sizeof (trqiBuffer));

                pRtLookupData = (IPRouteLookupData *)trqiBuffer.Context;
                pRtLookupData->SrcAdd  = 0;

                // IP uses the opposite byte ordering from us.
                ((PUCHAR)&pRtLookupData->DestAdd)[0] = ((PUCHAR)&ipTarget)[3];
                ((PUCHAR)&pRtLookupData->DestAdd)[1] = ((PUCHAR)&ipTarget)[2];
                ((PUCHAR)&pRtLookupData->DestAdd)[2] = ((PUCHAR)&ipTarget)[1];
                ((PUCHAR)&pRtLookupData->DestAdd)[3] = ((PUCHAR)&ipTarget)[0];

                lpObject = &trqiBuffer.ID;
                lpObject->toi_id = IP_MIB_SINGLE_RT_ENTRY_ID;
                lpObject->toi_class = INFO_CLASS_PROTOCOL;
                lpObject->toi_type = INFO_TYPE_PROVIDER;
                lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
                lpObject->toi_entity.tei_instance = 0;

                irpSp = IoGetNextIrpStackLocation(pirp);
                SAFEASSERT( irpSp != NULL );

                irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_TCP_QUERY_INFORMATION_EX;
                irpSp->DeviceObject = pdo;
                irpSp->FileObject = pfo;
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &trqiBuffer;
                irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(trqiBuffer);
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(routeEntry);

                pirp->UserBuffer = &routeEntry;
                pirp->RequestorMode = KernelMode;
                IoSetCompletionRoutine( pirp, BrdgCompCompleteRouteLookupIRP, NULL, TRUE, TRUE, TRUE );

                status = IoCallDriver( pdo, pirp );

                // STATUS_PENDING will bugcheck the machine since we passed buffers that
                // are on the stack.
                SAFEASSERT( status != STATUS_PENDING );

                if( status == STATUS_SUCCESS )
                {
                    //
                    // TCPIP signals failure by setting the interface designator
                    // on the reply to 0xFFFFFFFF
                    //
                    if( routeEntry.ire_index != 0xFFFFFFFF )
                    {
                        // IP uses the opposite byte ordering from us.
                        ((PUCHAR)pipNextHop)[3] = ((PUCHAR)&routeEntry.ire_nexthop)[0];
                        ((PUCHAR)pipNextHop)[2] = ((PUCHAR)&routeEntry.ire_nexthop)[1];
                        ((PUCHAR)pipNextHop)[1] = ((PUCHAR)&routeEntry.ire_nexthop)[2];
                        ((PUCHAR)pipNextHop)[0] = ((PUCHAR)&routeEntry.ire_nexthop)[3];

                        if( ! BrdgCompIsLocalIPAddress(*pipNextHop) )
                        {
                            // Poke the new data into the cache
                            BrdgUpdateCache( &gNextHopCache, ipTarget, *pipNextHop );
                            rc = TRUE;
                        }
                        else
                        {
                            THROTTLED_DBGPRINT(COMPAT, ("TCPIP gave a bridge IP address as next hop for %i.%i.%i.%i\n",
                                                       ((PUCHAR)&ipTarget)[3], ((PUCHAR)&ipTarget)[2], ((PUCHAR)&ipTarget)[1],
                                                       ((PUCHAR)&ipTarget)[0] ));

                            BrdgUpdateCache( &gNextHopCache, ipTarget, NO_ADDRESS );
                        }
                    }
                    else
                    {
                        // Poke a negative entry into the cache so we don't keep trying to look this up.
                        THROTTLED_DBGPRINT(COMPAT, ("TCPIP found no route entry for %i.%i.%i.%i\n", ((PUCHAR)&ipTarget)[3], ((PUCHAR)&ipTarget)[2],
                                                   ((PUCHAR)&ipTarget)[1], ((PUCHAR)&ipTarget)[0] ));

                        BrdgUpdateCache( &gNextHopCache, ipTarget, NO_ADDRESS );
                    }
                }
                else
                {
                    DBGPRINT(COMPAT, ("TPCIP failed route lookup IRP: %08x\n", status));
                }
            }
            else
            {
                DBGPRINT(COMPAT, ("Failed to allocate an IRP in BrdgCompGetNextHopForTarget!\n"));
            }

            // We are done talking to TCPIP
            BrdgCompReleaseTCPIP();
        }
        // else no open channel to TCPIP
    }

    return rc;
}

BOOLEAN
BrdgCompIsLocalIPAddress(
    IN IPADDRESS                ipAddr
    )
/*++

Routine Description:

    Determines whether a given IP address is one of our local addresses.

Arguments:

    ipAddr                      The address

Return Value:

    TRUE if the given address is on our list of local addresses, FALSE
    otherwise

--*/
{
    LOCK_STATE                  LockState;
    ULONG                       i;
    PIPADDRESS                  pAddr = (PIPADDRESS)gLocalIPAddressList;
    BOOLEAN                     bFound = FALSE;

    NdisAcquireReadWriteLock( &gLocalIPAddressListLock, FALSE/*Read only*/, &LockState );

    // There should be an integral number of IP addresses in the list!
    SAFEASSERT( (gLocalIPAddressListLength % sizeof(IPADDRESS)) == 0 );
    SAFEASSERT( (gLocalIPAddressListLength == 0) || (gLocalIPAddressList != NULL) );

    for( i = 0L; i < gLocalIPAddressListLength / sizeof(IPADDRESS); i++ )
    {
        if( pAddr[i] == ipAddr )
        {
            bFound = TRUE;
            break;
        }
    }

    NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

    return bFound;
}


BOOLEAN
BrdgCompSendToMultipleAdapters(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pOriginalAdapt,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN BOOLEAN                  bAllAdapters,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Sends a packet (or a copy thereof) to multiple adapters. Usually used to send around
    a broadcast packet.

Arguments:

    pPacket                     The packet to send (or to send a copy of)
    pOriginalAdapt              The adapter the packet was originally received on (so
                                    we can skip it). This can be NULL
    pPacketData                 A pointer to the packet's data buffer
    bCanRetain                  Whether we can retain the packet
    bAllAdapters                TRUE: Send to all adapters FALSE: send only to
                                    adapters in compatibility mode
    pEditFunc                   Optional function that gets called before sending to
                                    each adapter (to edit the packet)
    pData                       Cookie to pass to pEditFunc as context

Return Value:

    TRUE if pPacket was retained, FALSE otherwise

--*/
{
    UINT                        numTargets = 0L, i;
    PADAPT                      pAdapt;
    PADAPT                      SendList[MAX_ADAPTERS];
    LOCK_STATE                  LockState;
    BOOLEAN                     bSentOriginal = FALSE;   // Whether we have sent the packet we were given yet

    //
    // First we need a list of the adapters we intend to send this packet to
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

    // Note each adapter to send to
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Don't need to acquire the global adapter characteristics lock to read the
        // media state because we don't care about the global consistency of the
        // adapters' characteristics here
        if( (pAdapt != pOriginalAdapt) &&
            (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
            (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
            (! pAdapt->bResetting) )                            // Adapter must not be resetting
        {
            // If we're not trying to send to every single adapter, make sure
            // this one is in compatibility mode
            if( bAllAdapters || (pAdapt->bCompatibilityMode) )
            {
                if( numTargets < MAX_ADAPTERS )
                {
                    // We will use this adapter outside the list lock; bump its refcount
                    BrdgAcquireAdapterInLock(pAdapt);
                    SendList[numTargets] = pAdapt;
                    numTargets++;
                }
                else
                {
                    // Too many copies to send!
                    SAFEASSERT( FALSE );
                }
            }
        }
    }

    // Can let go of the adapter list now; we have copied out all the target adapters
    // and incremented the refcount for the adapters we will be using.
    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    for( i = 0; i < numTargets; i++ )
    {
        PNDIS_PACKET            pPacketToSend;
        PUCHAR                  pPacketToSendData;

        if( bCanRetain && (! bSentOriginal) && (i == (numTargets - 1)) )
        {
            //
            // Use the packet we were given.
            // We must do this only with the last adapter since we need to be
            // able to copy from it for every adapter before the last one.
            //
            pPacketToSend = pPacket;
            pPacketToSendData = pPacketData;
            bSentOriginal = TRUE;
        }
        else
        {
            UINT                pPacketToSendSize;

            // Duplicate the original packet yet another time so we have an editable
            // copy for this target adapter
            pPacketToSend = BrdgFwdMakeCompatCopyPacket(pPacket, &pPacketToSendData, &pPacketToSendSize, FALSE);
        }

        if( pPacketToSend != NULL )
        {
            BrdgCompEditAndSendPacket( pPacketToSend, pPacketToSendData, SendList[i], pEditFunc, pData );
        }

        // Done with this adapter
        BrdgReleaseAdapter( SendList[i] );
    }

    return bSentOriginal;
}

VOID
BrdgCompRefreshOrInsertIPEntry(
    IN IPADDRESS            IPAddr,
    IN PADAPT               pAdapt,
    IN PUCHAR               pMACAddr
    )
/*++

Routine Description:

    Inserts a new entry into the IP forwarding table or refreshes an existing entry

Arguments:

    IPAddr                  The address to insert
    pAdapt                  The adapter to associate with the IP address
    pMACAddr                The MAC address to associate with the IP address

Return Value:

    None

--*/
{
    PIP_TABLE_ENTRY         pEntry;
    BOOLEAN                 bIsNewEntry;
    LOCK_STATE              LockState;

    if( BrdgCompIsUnicastIPAddress(IPAddr) )
    {
        pEntry = (PIP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gIPForwardingTable, (PUCHAR)&IPAddr,
                                                           &bIsNewEntry, &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // This is a brand new table entry. Initialize it.
                NdisAllocateSpinLock( &pEntry->lock );
                pEntry->pAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->macAddr, pMACAddr );

                DBGPRINT(COMPAT, ("Learned the location of %i.%i.%i.%i\n", ((PUCHAR)&IPAddr)[3], ((PUCHAR)&IPAddr)[2],
                                  ((PUCHAR)&IPAddr)[1], ((PUCHAR)&IPAddr)[0]));
            }
            else
            {
                // This is an existing entry and we may only have a read lock
                // held on the hash table. Use the entry's spin lock to protect
                // us while we monkey with the contents
                NdisAcquireSpinLock( &pEntry->lock );

                pEntry->pAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->macAddr, pMACAddr );

                NdisReleaseSpinLock( &pEntry->lock );
            }

            // Since we got a non-NULL result we must release the table lock
            NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
        }
    }
    else
    {
        //
        // We shouldn't be getting called with non-unicast source IP addresses
        //
        THROTTLED_DBGPRINT(COMPAT, ("WARNING: Not noting non-unicast source IP address %i.%i.%i.%i from adapter %p!\n",
                                    ((PUCHAR)&IPAddr)[3], ((PUCHAR)&IPAddr)[2], ((PUCHAR)&IPAddr)[1], ((PUCHAR)&IPAddr)[0],
                                    pAdapt ));
    }
}

PUCHAR
BrdgCompIsBootPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi
    )
/*++

Routine Description:

    Determines whether a given packet is a BOOTP packet

Arguments:

    pPacketData                 Pointer to the packet's data buffer
    packetLen                   Amount of data at pPacketDaa
    piphi                       Info about the IP header of this packet

Return Value:

    A pointer to the BOOTP payload within the packet, or NULL if the packet was not
    a BOOTP Packet.

--*/
{
    // After the IP header, there must be enough room for a UDP header and
    // a basic BOOTP packet
    if( packetLen < ETHERNET_HEADER_SIZE + (UINT)piphi->headerSize + SIZE_OF_UDP_HEADER +
                    SIZE_OF_BASIC_BOOTP_PACKET)
    {
        return NULL;
    }

    // Protocol must be UDP
    if( piphi->protocol != UDP_PROTOCOL )
    {
        return NULL;
    }

    // Jump to the beginning of the UDP packet by skipping the IP header
    pPacketData += ETHERNET_HEADER_SIZE + piphi->headerSize;

    // The first two bytes are the source port and should be the
    // BOOTP Client port (0x0044) or the BOOTP Server port (0x0043)
    if( (pPacketData[0] != 00) ||
        ((pPacketData[1] != 0x44) && (pPacketData[1] != 0x43)) )
    {
        return NULL;
    }

    // The next two bytes are the destination port and should be the BOOTP
    // server port (0x0043) or the BOOTP client port (0x44)
    if( (pPacketData[2] != 00) ||
        ((pPacketData[3] != 0x43) && (pPacketData[3] != 0x44)) )
    {
        return NULL;
    }

    // Skip ahead to the beginning of the BOOTP packet
    pPacketData += SIZE_OF_UDP_HEADER;

    // The first byte is the op code and should be 0x01 for a request
    // or 0x02 for a reply
    if( pPacketData[0] > 0x02 )
    {
        return NULL;
    }

    // The next byte is the hardware type and should be 0x01 for Ethernet
    if( pPacketData[1] != 0x01 )
    {
        return NULL;
    }

    // The next byte is the address length and should be 0x06 for Ethernet
    if( pPacketData[2] != 0x06 )
    {
        return NULL;
    }

    // Everything checks out; this looks like a BOOTP request packet.
    return pPacketData;
}

BOOLEAN
BrdgCompDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PIP_HEADER_INFO         piphi
    )
/*++

Routine Description:

    Decodes basic information from the IP header (no options)

Arguments:

    pHeader                     Pointer to an IP header
    piphi                       Receives the info

Return Value:

    TRUE: header was valid
    FALSE: packet is not an IP packet

--*/
{
    // First nibble of the header encodes the packet version, which must be 4.
    if( (*pHeader >> 4) != 0x04 )
    {
        return FALSE;
    }

    // Next nibble of the header encodes the length of the header in 32-bit words.
    // This length must be at least 20 bytes or something is amiss.
    piphi->headerSize = (*pHeader & 0x0F) * 4;
    if( piphi->headerSize < 20 )
    {
        return FALSE;
    }

    // Retrieve the protocol byte (offset 10)
    piphi->protocol = pHeader[9];

    // The source IP address begins at the 12th byte (most significant byte first)
    piphi->ipSource = 0L;
    piphi->ipSource |= pHeader[12] << 24;
    piphi->ipSource |= pHeader[13] << 16;
    piphi->ipSource |= pHeader[14] << 8;
    piphi->ipSource |= pHeader[15];

    // The destination IP address is next
    piphi->ipTarget = 0L;
    piphi->ipTarget |= pHeader[16] << 24;
    piphi->ipTarget |= pHeader[17] << 16;
    piphi->ipTarget |= pHeader[18] << 8;
    piphi->ipTarget |= pHeader[19];

    return TRUE;
}

BOOLEAN
BrdgCompDecodeARPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     dataLen,
    OUT PARPINFO                pARPInfo
    )
/*++

Routine Description:

    Decodes an ARP packet

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    dataLen                     Amount of data at pPacketData
    pARPInfo                    Receives the info

Return Value:

    TRUE: packet was valid
    FALSE: packet is not an ARP packet

--*/
{
    SAFEASSERT( pPacketData != NULL );
    SAFEASSERT( pARPInfo != NULL );

    // We can't process this if it's too small
    if( dataLen < SIZE_OF_ARP_PACKET )
    {
        return FALSE;
    }

    // Check the ethertype for consistency (0x0806 is ARP)
    if( (pPacketData[12] != 0x08) || (pPacketData[13] != 0x06) )
    {
        return FALSE;
    }

    // Check the hardware type for consistency (0x0001 is classic Ethernet;
    // 802 has a seperate value)
    if( (pPacketData[14] != 0x00) || (pPacketData[15] != 0x01) )
    {
        return FALSE;
    }

    // Check the protocol type for consistency (0x0800 is IPv4)
    if( (pPacketData[16] != 0x08) || (pPacketData[17] != 0x00) )
    {
        return FALSE;
    }

    // Check the length of the hardware address for consistency (must be 6 bytes)
    if( pPacketData[18] != 0x06 )
    {
        return FALSE;
    }

    // Check the length of the protocol address for consistency (must be 4 bytes)
    if( pPacketData[19] != 0x04 )
    {
        return FALSE;
    }

    // Next two bytes are the operation (0x0001 == request, 0x0002 == reply)
    if( pPacketData[20] != 0x00 )
    {
        return FALSE;
    }

    if( pPacketData[21] == 0x01 )
    {
        pARPInfo->type = ArpRequest;
    }
    else if( pPacketData[21] == 0x02 )
    {
        pARPInfo->type = ArpReply;
    }
    else
    {
        return FALSE;
    }

    // Next 6 bytes are the sender's MAC address
    pARPInfo->macSource[0] = pPacketData[22];
    pARPInfo->macSource[1] = pPacketData[23];
    pARPInfo->macSource[2] = pPacketData[24];
    pARPInfo->macSource[3] = pPacketData[25];
    pARPInfo->macSource[4] = pPacketData[26];
    pARPInfo->macSource[5] = pPacketData[27];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    pARPInfo->ipSource = 0;
    pARPInfo->ipSource |= pPacketData[28] << 24;
    pARPInfo->ipSource |= pPacketData[29] << 16;
    pARPInfo->ipSource |= pPacketData[30] << 8;
    pARPInfo->ipSource |= pPacketData[31];

    //
    // Next 6 bytes are the target's MAC address. For a request, these bytes are
    // meaningless.
    //
    pARPInfo->macTarget[0] = pPacketData[32];
    pARPInfo->macTarget[1] = pPacketData[33];
    pARPInfo->macTarget[2] = pPacketData[34];
    pARPInfo->macTarget[3] = pPacketData[35];
    pARPInfo->macTarget[4] = pPacketData[36];
    pARPInfo->macTarget[5] = pPacketData[37];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    pARPInfo->ipTarget = 0;
    pARPInfo->ipTarget |= pPacketData[38] << 24;
    pARPInfo->ipTarget |= pPacketData[39] << 16;
    pARPInfo->ipTarget |= pPacketData[40] << 8;
    pARPInfo->ipTarget |= pPacketData[41];

    return TRUE;
}

VOID
BrdgCompTransmitDeferredARP(
    IN PVOID                    pData
    )
/*++

Routine Description:

    Transmits an ARP packet whose transmission was deferred

Arguments:

    pData                       Info on the deferred ARP packet to
                                be transmitted

Return Value:

    None

--*/
{
    PDEFERRED_ARP               pda = (PDEFERRED_ARP)pData;

    BrdgCompTransmitARPPacket( pda->pTargetAdapt, &pda->ai );

    // We incremented this adapter's refcount when setting up the
    // function deferral
    BrdgReleaseAdapter( pda->pTargetAdapt );

    // Free the memory for this request
    NdisFreeMemory( pda, sizeof(DEFERRED_ARP), 0 );
}

VOID
BrdgCompTransmitARPPacket(
    IN PADAPT                   pAdapt,
    IN PARPINFO                 pARPInfo
    )
/*++

Routine Description:

    Transmits an ARP packet

Arguments:

    pAdapt                      Adapter to transmit on
    pARPInfo                    The info to transmit as an ARP packet

Return Value:

    None

--*/
{
    NDIS_STATUS                 Status;
    UCHAR                       ARPPacket[SIZE_OF_ARP_PACKET];

    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( pARPInfo != NULL );
    SAFEASSERT( (pARPInfo->type == ArpRequest) || (pARPInfo->type == ArpReply) );

    //
    // Fill in the destination MAC address. If the operation is a discovery,
    // the target MAC address is the broadcast address. If it is a reply, the
    // target MAC address is the target machine's MAC address.
    //
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[0] = ARPPacket[1] = ARPPacket[2] = ARPPacket[3] =
            ARPPacket[4] = ARPPacket[5] = 0xFF;
    }
    else
    {
        ARPPacket[0] = pARPInfo->macTarget[0];
        ARPPacket[1] = pARPInfo->macTarget[1];
        ARPPacket[2] = pARPInfo->macTarget[2];
        ARPPacket[3] = pARPInfo->macTarget[3];
        ARPPacket[4] = pARPInfo->macTarget[4];
        ARPPacket[5] = pARPInfo->macTarget[5];
    }

    // Fill in the source MAC address
    ARPPacket[6] = pARPInfo->macSource[0];
    ARPPacket[7] = pARPInfo->macSource[1];
    ARPPacket[8] = pARPInfo->macSource[2];
    ARPPacket[9] = pARPInfo->macSource[3];
    ARPPacket[10] = pARPInfo->macSource[4];
    ARPPacket[11] = pARPInfo->macSource[5];

    // Next 2 bytes are the EtherType (0x0806 == ARP)
    ARPPacket[12] = 0x08;
    ARPPacket[13] = 0x06;

    // Next 2 bytes are 0x0001 for classic Ethernet
    // (802 has a seperate value)
    ARPPacket[14] = 0x00;
    ARPPacket[15] = 0x01;

    // Next 2 bytes indicate that this is ARP for IPv4 traffic
    ARPPacket[16] = 0x08;
    ARPPacket[17] = 0x00;

    // Next byte indicates the length of the hardware address (6 bytes)
    ARPPacket[18] = 0x6;

    // Next byte indicates the length of the protocol address (4 bytes)
    ARPPacket[19] = 0x4;

    // Next byte is the operation (1 == request, 2 == reply)
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[20] = 0x00;
        ARPPacket[21] = 0x01;
    }
    else
    {
        ARPPacket[20] = 0x00;
        ARPPacket[21] = 0x02;
    }

    // Next 6 bytes are the sender's MAC address (LSB first)
    ARPPacket[22] = pARPInfo->macSource[0];
    ARPPacket[23] = pARPInfo->macSource[1];
    ARPPacket[24] = pARPInfo->macSource[2];
    ARPPacket[25] = pARPInfo->macSource[3];
    ARPPacket[26] = pARPInfo->macSource[4];
    ARPPacket[27] = pARPInfo->macSource[5];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    ARPPacket[28] = (UCHAR)((pARPInfo->ipSource >> 24) & 0xFF);
    ARPPacket[29] = (UCHAR)((pARPInfo->ipSource >> 16) & 0xFF);
    ARPPacket[30] = (UCHAR)((pARPInfo->ipSource >> 8) & 0xFF);
    ARPPacket[31] = (UCHAR)(pARPInfo->ipSource & 0xFF);

    //
    // Next 6 bytes are the target's MAC address. For a request, these bytes are
    // ignored and set to zero.
    //
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[32] = ARPPacket[33] = ARPPacket[34] = ARPPacket[35] =
            ARPPacket[36] = ARPPacket[37] = 0x00;
    }
    else
    {
        // MAC address is transmitted LSB first.
        ARPPacket[32] = pARPInfo->macTarget[0];
        ARPPacket[33] = pARPInfo->macTarget[1];
        ARPPacket[34] = pARPInfo->macTarget[2];
        ARPPacket[35] = pARPInfo->macTarget[3];
        ARPPacket[36] = pARPInfo->macTarget[4];
        ARPPacket[37] = pARPInfo->macTarget[5];
    }

    // Next 4 bytes are the target's protocol address (most significant byte first)
    ARPPacket[38] = (UCHAR)((pARPInfo->ipTarget >> 24) & 0xFF);
    ARPPacket[39] = (UCHAR)((pARPInfo->ipTarget >> 16) & 0xFF);
    ARPPacket[40] = (UCHAR)((pARPInfo->ipTarget >> 8) & 0xFF);
    ARPPacket[41] = (UCHAR)(pARPInfo->ipTarget & 0xFF);

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pAdapt, ARPPacket, sizeof(ARPPacket) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(COMPAT, ("ARP packet send failed: %08x\n", Status));
    }
}

//
// pTargetAdapt comes back with incremented refcount if
// *pbIsRequest == FALSE and *pTargetAdapt != NULL
//
BOOLEAN
BrdgCompPreprocessBootPPacket(
    IN PUCHAR                   pPacketData,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    IN PADAPT                   pAdapt,         // Receiving adapt (or NULL for outbound from local machine)
    OUT PBOOLEAN                pbIsRequest,
    OUT PADAPT                 *ppTargetAdapt,  // Only if bIsRequest == FALSE
    OUT PUCHAR                  targetMAC       // Only if bIsRequest == FALSE
    )
/*++

Routine Description:

    Does preliminary processing of a BOOTP packet common to the inbound and outbound case

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    piphi                       Info on the packet's IP header
    pBootPData                  Pointer to the BOOTP payload within the packet
    pAdapt                      Receiving adapter (or NULL if this packet is outbound from
                                    the local machine)
    pbIsRequest                 Receives a flag indicating if this is a BOOTP request
    ppTargetAdapt               Receives the target adapter this packet should be relayed to
                                    (only valid if bIsRequest == FALSE and return == TRUE)
    targetMAC                   The MAC address this packet should be relayed to (valid under
                                    same conditions as ppTargetAdapt)

Return Value:

    TRUE : packet was processed successfully
    FALSE : an error occured or something is wrong with the packet

--*/
{
    PDHCP_TABLE_ENTRY           pEntry;
    ULONG                       xid;
    LOCK_STATE                  LockState;

    SAFEASSERT( pbIsRequest != NULL );
    SAFEASSERT( ppTargetAdapt != NULL );
    SAFEASSERT( targetMAC != NULL );

    // Decode the xid (bytes 5 through 8)
    xid = 0L;
    xid |= pBootPData[4] << 24;
    xid |= pBootPData[5] << 16;
    xid |= pBootPData[6] << 8;
    xid |= pBootPData[7];

    // Byte 0 is the operation; 1 for a request, 2 for a reply
    if( pBootPData[0] == 0x01 )
    {
        BOOLEAN                 bIsNewEntry;

        // This is a request. We need to note the correspondence betweeen
        // this client's XID and its adapter and MAC address
        pEntry = (PDHCP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingDHCPTable, (PUCHAR)&xid, &bIsNewEntry,
                                                             &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // Initialize the entry.
                // The client's hardware address is at offset 29
                NdisAllocateSpinLock( &pEntry->lock );
                ETH_COPY_NETWORK_ADDRESS( pEntry->requestorMAC, &pBootPData[28] );
                pEntry->pRequestorAdapt = pAdapt;   // Can be NULL for local machine

                DBGPRINT(COMPAT, ("Saw new DHCP XID: %x\n", xid));
            }
            else
            {
                //
                // An entry already existed for this XID. This is fine if the existing information
                // matches what we're trying to record, but it's also possible that two stations
                // decided independently to use the same XID, or that the same station changed
                // apparent MAC address and/or adapter due to topology changes. Our scheme breaks
                // down under these circumstances.
                //
                // Either way, use the most recent information possible; clobber the existing
                // information with the latest.
                //

                NdisAcquireSpinLock( &pEntry->lock );

#if DBG
                {
                    UINT            Result;
                    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pEntry->requestorMAC, &pBootPData[28], &Result );

                    // Warn if the data changed, as this probably signals a problem
                    if( Result != 0 )
                    {
                        DBGPRINT(COMPAT, ("[COMPAT] WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x is using DHCP XID %x at the same time as station %02x:%02x:%02x:%02x:%02x:%02x!\n",
                                          pBootPData[28], pBootPData[29], pBootPData[30], pBootPData[31], pBootPData[32], pBootPData[33],
                                          xid, pEntry->requestorMAC[0], pEntry->requestorMAC[1], pEntry->requestorMAC[2],
                                          pEntry->requestorMAC[3], pEntry->requestorMAC[4], pEntry->requestorMAC[5] ));
                    }
                    else if( pEntry->pRequestorAdapt != pAdapt )
                    {
                        DBGPRINT(COMPAT, ("[COMPAT] WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x appeared to change from adapter %p to adapter %p during DHCP request!\n",
                                           pBootPData[28], pBootPData[29], pBootPData[30],
                                           pBootPData[31], pBootPData[32], pBootPData[33],
                                           pEntry->pRequestorAdapt, pAdapt ));
                    }
                }
#endif

                ETH_COPY_NETWORK_ADDRESS( pEntry->requestorMAC, &pBootPData[28] );
                pEntry->pRequestorAdapt = pAdapt;   // Can be NULL for local machine

                NdisReleaseSpinLock( &pEntry->lock );
            }

            NdisReleaseReadWriteLock( &gPendingDHCPTable->tableLock, &LockState );
        }
        else
        {
            // This packet could not be processed
            DBGPRINT(COMPAT, ("Couldn't create table entry for BOOTP packet!\n"));
            return FALSE;
        }

        *pbIsRequest = TRUE;
        // ppTargetAdapt and targetMAC are not defined for this case
        return TRUE;
    }
    else if ( pBootPData[0] == 0x02 )
    {
        // Look up the xid for this transaction to recover the MAC address of the client
        pEntry = (PDHCP_TABLE_ENTRY)BrdgHashFindEntry( gPendingDHCPTable, (PUCHAR)&xid, &LockState );

        if( pEntry != NULL )
        {
            NdisAcquireSpinLock( &pEntry->lock );
            ETH_COPY_NETWORK_ADDRESS( targetMAC, pEntry->requestorMAC );
            *ppTargetAdapt = pEntry->pRequestorAdapt;
            NdisReleaseSpinLock( &pEntry->lock );

            //
            // We will use this adapter outside the table lock. NULL is a permissible
            // value that indicates that the local machine is the requestor for
            // this xid.
            //
            if( *ppTargetAdapt != NULL )
            {
                BrdgAcquireAdapterInLock( *ppTargetAdapt );
            }

            NdisReleaseReadWriteLock( &gPendingDHCPTable->tableLock, &LockState );
        }

        if( pEntry != NULL )
        {
            *pbIsRequest = FALSE;
            return TRUE;
        }
        else
        {
            DBGPRINT(COMPAT, ("Couldn't find a table entry for XID %x!\n", xid));
            return FALSE;
        }
    }
    else
    {
        // Someone passed us a crummy packet
        return FALSE;
    }
}


// ===========================================================================
//
// INBOUND PACKET PROCESSING
//
// ===========================================================================

VOID
BrdgCompSendProxyARPRequests(
    IN PARPINFO                 pai,
    IN PADAPT                   pOriginalAdapt,
    IN BOOLEAN                  bSendToNonCompat
    )
/*++

Routine Description:

    Floods ARP requests out appropriate adapters in response to an ARP request
    for which we did not have information about the target.

Arguments:

    pai                         Info on the inbound request
    pOriginalAdapt              Adapter the request was indicated on
    bSendToNonCompat            Whether we need to send the request to all adapters
                                    or just compatibility adapters


Return Value:

    None

--*/
{
    UINT                        numTargets = 0L, i;
    PADAPT                      pAdapt;
    PADAPT                      SendList[MAX_ADAPTERS];
    LOCK_STATE                  LockState;

    SAFEASSERT( pai->type == ArpRequest );

    //
    // First we need a list of the adapters we intend to send this packet to
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

    // Note each adapter to send to
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Don't need to acquire the global adapter characteristics lock to read the
        // media state because we don't care about the global consistency of the
        // adapters' characteristics here
        if( (pAdapt != pOriginalAdapt ) &&                      // Don't send on the original adapter
            (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
            (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
            (! pAdapt->bResetting) )                            // Adapter must not be resetting
        {
            // If we're not trying to send to every single adapter, make sure
            // this one is in compatibility mode
            if( bSendToNonCompat || (pAdapt->bCompatibilityMode) )
            {
                if( numTargets < MAX_ADAPTERS )
                {
                    // We will use this adapter outside the list lock; bump its refcount
                    BrdgAcquireAdapterInLock(pAdapt);
                    SendList[numTargets] = pAdapt;
                    numTargets++;
                }
                else
                {
                    // Too many copies to send!
                    SAFEASSERT( FALSE );
                }
            }
        }
    }

    // Can let go of the adapter list now; we have copied out all the target adapters
    // and incremented the refcount for the adapters we will be using.
    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    for( i = 0; i < numTargets; i++ )
    {
        // For each adapter, the source MAC address is the adapter's MAC address
        ETH_COPY_NETWORK_ADDRESS( pai->macSource, SendList[i]->MACAddr );

        // Send the ARP request
        BrdgCompTransmitARPPacket( SendList[i], pai );

        // Done with this adapter
        BrdgReleaseAdapter( SendList[i] );
    }
}

VOID
BrdgCompAnswerPendingARP(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Sends a reply to a station that is waiting for an ARP reply. Called when we find
    an entry to this effect in our pending-ARP table.

    We do not send an ARP reply to the discovering station if it turns out that the
    station it is looking for is on the same segment as it.

Arguments:

    pEntry                      The entry in the pending-ARP table telling us about
                                    the station waiting for information

    pData                       The adapter we received an ARP reply on that
                                    triggered this operation


Return Value:

    None

--*/
{
    PARP_TABLE_ENTRY            pate = (PARP_TABLE_ENTRY)pEntry;
    PADAPT                      pReceivedAdapt = (PADAPT)pData;
    PARP_TABLE_KEY              pKey;

    pKey = (PARP_TABLE_KEY)pate->hte.key;

    if( pKey->ipReqestor != 0L )
    {
        PADAPT                  pOriginalAdapt;
        UCHAR                   originalMAC[ETH_LENGTH_OF_ADDRESS];

        // Copy the information out of the table entry
        NdisAcquireSpinLock( &pate->lock );
        pOriginalAdapt = pate->pOriginalAdapt;
        ETH_COPY_NETWORK_ADDRESS( originalMAC, pate->originalMAC );
        NdisReleaseSpinLock( &pate->lock );

        //
        // The station we just discovered must be on a different segment
        // from the discovering station for us to send back a reply.
        //
        if( pOriginalAdapt != pReceivedAdapt )
        {
            PDEFERRED_ARP           pda;
            NDIS_STATUS             Status;

            // The adapters are different. We should send a reply.
            // We need to defer the actual transmission of the reply so we
            // don't perform it with a lock held on the pending ARP
            // table.
            Status = NdisAllocateMemoryWithTag( &pda, sizeof(DEFERRED_ARP), 'gdrB' );

            if( Status == NDIS_STATUS_SUCCESS )
            {
                pda->pTargetAdapt = pOriginalAdapt;

                // We will use the adapter pointer outside the table lock
                BrdgAcquireAdapterInLock( pda->pTargetAdapt );

                pda->ai.ipTarget = pKey->ipReqestor;
                ETH_COPY_NETWORK_ADDRESS( pda->ai.macTarget, originalMAC );

                // Pretend to be the IP address the requestor is looking for
                pda->ai.ipSource = pKey->ipTarget;
                ETH_COPY_NETWORK_ADDRESS( pda->ai.macSource, pda->pTargetAdapt->MACAddr );

                pda->ai.type = ArpReply;

                // Queue up the call to BrdgCompTransmitDeferredARP
                BrdgDeferFunction( BrdgCompTransmitDeferredARP, pda );
            }
            else
            {
                // We failed the allocation. Not much we can do.
                DBGPRINT(COMPAT, ("Memory allocation failed in BrdgCompAnswerPendingARP!\n"));
            }
        }
        // else the discovering station and the station we discovered are on the same
        // adapter; don't reply.
    }
    else
    {
        // This entry exists only to indicate that the local machine is also trying to discover
        // this IP address. Ignore it.
    }
}


BOOLEAN
BrdgCompIndicateInboundARPReply(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Indicates an ARP reply to the local machine

Arguments:

    pPacket                     The ARP reply packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    PUCHAR                      pTargetMAC;
    UINT                        Result;

    if( ! bCanRetain )
    {
        // We're not allowed to use the packet we're given to indicate.
        // Allocate a new one to hold the data.
        pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

        if( pPacket == NULL )
        {
            // We failed to get a packet.
            return FALSE;
        }
    }

    // Rewrite the target MAC address in the ARP reply. This portion
    // of the packet is at offset 32.
    pTargetMAC = pPacketData + 32;

    // Check to see if the target MAC address is the adapter's MAC address,
    // as it should be
    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pTargetMAC, pAdapt->MACAddr, &Result );

    if( Result == 0 )
    {
        // Rewrite the target MAC address to the bridge's MAC address
        ETH_COPY_NETWORK_ADDRESS( pTargetMAC, gCompMACAddress );
    }
    else
    {
        DBGPRINT(COMPAT, ("WARNING: Mismatch between frame MAC target and ARP payload target in ARP reply!\n"));
    }

    BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );

    return bCanRetain;
}

BOOLEAN
BrdgCompProcessInboundARPRequest(
    IN PARPINFO                 pai,
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound ARP request

Arguments:

    pai                         The decoded info
    pPacket                     The ARP request packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    PIP_TABLE_ENTRY             pipte;
    LOCK_STATE                  LockState;
    BOOLEAN                     bSendReply = FALSE;

    SAFEASSERT( pai->type == ArpRequest );

    // See if we already have the target IP address in our table
    pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&pai->ipTarget,
                                                &LockState );

    if( pipte != NULL )
    {
        //
        // Compare the adapter the target is reachable on to the adapter that
        // we got the request on while we still have the table lock.
        //
        // We should only send an ARP reply if the requesting station is on
        // a different adapter than the station he is trying to discover.
        //
        bSendReply = (BOOLEAN)(pipte->pAdapt != pAdapt);

        // Release the table lock.
        NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
    }

    if( bSendReply )
    {
        IPADDRESS           ipTransmitter = pai->ipSource;

        DBGPRINT(COMPAT, ("ANSWERING ARP request for %i.%i.%i.%i\n",
                          ((PUCHAR)&pai->ipTarget)[3], ((PUCHAR)&pai->ipTarget)[2],
                          ((PUCHAR)&pai->ipTarget)[1], ((PUCHAR)&pai->ipTarget)[0] ));

        // We found the target station. Use our ARPINFO structure to build a
        // reply right back to the sending station.
        pai->type = ArpReply;

        // Pretend to be the IP station the transmitting station is asking for
        pai->ipSource = pai->ipTarget;

        // Send to the requesting station
        ETH_COPY_NETWORK_ADDRESS( pai->macTarget, pai->macSource );
        pai->ipTarget = ipTransmitter;

        // Fill in the adapter's own MAC address as the source
        ETH_COPY_NETWORK_ADDRESS( pai->macSource, pAdapt->MACAddr );

        // Transmit the answer right now!
        BrdgCompTransmitARPPacket( pAdapt, pai );
    }
    else
    {
        // We didn't find the address the transmitting station is asking for.
        // We'll need to proxy the request onto other adapters to discover
        // the target station.

        // We need to proxy onto regular adapters too if the original adapter
        // was compatibility-mode.
        BOOLEAN             bSendToNonCompat = pAdapt->bCompatibilityMode;
        PARP_TABLE_ENTRY    pEntry;
        LOCK_STATE          LockState;
        BOOLEAN             bIsNewEntry;
        ARP_TABLE_KEY       atk;

        // Record the fact that we've proxied out this request
        atk.ipReqestor = pai->ipSource;
        atk.ipTarget = pai->ipTarget;
        pEntry = (PARP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingARPTable, (PUCHAR)&atk,
                                                            &bIsNewEntry, &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // This is a new table entry, as expected. Initialize it.
                NdisAllocateSpinLock( &pEntry->lock );
                pEntry->pOriginalAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->originalMAC, pai->macSource );
            }
            else
            {
                // There was already a pending-ARP entry for this source and target
                // IP address. Refresh the information in the entry on the slim
                // chance that the requesting machine has changed apparent MAC
                // address or adapter due to topology changes or the like.
                NdisAcquireSpinLock( &pEntry->lock );
                pEntry->pOriginalAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->originalMAC, pai->macSource );
                NdisReleaseSpinLock( &pEntry->lock );
            }

            // We are responsible for releasing the table lock since
            // BrdgHashRefreshOrInsert() came back non-NULL
            NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
        }

        // This function twiddles the ARPINFO structure you pass it,
        // but that's OK by us.
        BrdgCompSendProxyARPRequests( pai, pAdapt, bSendToNonCompat );
    }

    // Always indicate ARP requests to the local machine so it can note the
    // information about the sender and reply if it wants.
    return BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, NULL, NULL );
}

// Returns whether the packet was retained
BOOLEAN
BrdgCompProcessInboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound ARP packet

Arguments:

    pPacket                     The ARP request packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    ARPINFO                     ai;

    if( BrdgCompDecodeARPPacket(pPacketData, packetLen, &ai) )
    {
        BOOLEAN                 bRetained;

        // Regardless of what kind of packet this is, we always note
        // the correspondence between the sender's IP address and
        // MAC address.
        BrdgCompRefreshOrInsertIPEntry( ai.ipSource, pAdapt, ai.macSource );

        // Always see if the information we just learned would let us
        // proxy back a reply to a station doing a discovery.
        BrdgHashPrefixMultiMatch( gPendingARPTable, (PUCHAR)&ai.ipSource, sizeof(IPADDRESS),
                                  BrdgCompAnswerPendingARP, pAdapt );

        if( ai.type == ArpReply )
        {
            BOOLEAN             bIndicateReply;
            ARP_TABLE_KEY       atk;
            LOCK_STATE          LockState;

            //
            // The packet is an ARP reply.
            //

            // See if there's a table entry indicating that the local machine is trying to
            // resolve this target address
            atk.ipTarget = ai.ipSource;
            atk.ipReqestor = 0L;

            if( BrdgHashFindEntry(gPendingARPTable, (PUCHAR)&atk, &LockState) != NULL )
            {
                bIndicateReply = TRUE;
                NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
            }
            else
            {
                bIndicateReply = FALSE;
            }

            // We can't indicate the reply if we don't have the bridge's overall
            // MAC address available
            if( bIndicateReply && gCompHaveMACAddress )
            {
                bRetained = BrdgCompIndicateInboundARPReply( pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
            }
            else
            {
                bRetained = FALSE;
            }
        }
        else
        {
            //
            // The packet is an ARP request.
            //

            // This function trashes ai, but that's OK.
            bRetained = BrdgCompProcessInboundARPRequest( &ai, pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
        }

        // Sanity
        if( ! bCanRetain )
        {
            SAFEASSERT( !bRetained );
        }

        return bRetained;
    }
    else
    {
        // The inbound ARP packet is somehow invalid. Process it as a regular packet
        // (which should indicate it to the local machine) in case it's carrying something
        // we don't understand.
        return BrdgCompProcessInboundNonARPPacket( pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
    }
}

BOOLEAN
BrdgCompProcessInboundIPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PIP_HEADER_INFO          piphi,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Processes an inbound IP packet

Arguments:

    pPacket                     The IP packet
    piphi                       Decoded IP header information
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer
    pEditFunc                   Optional function that must be called
                                    for each adapter before transmission
    pData                       Context cookie for pEditFunc


Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained;
    PIP_TABLE_ENTRY             pipte;
    LOCK_STATE                  LockState;

    //
    // We refresh our forwarding table with each IP packet we see. Find the entry
    // for this IP address
    //
    if( BrdgCompIsUnicastIPAddress(piphi->ipSource) )
    {
        pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&piphi->ipSource, &LockState );

        if( pipte != NULL )
        {
            BOOLEAN             bInfoMatches = FALSE;

            //
            // Make sure the information in this entry is correct. If it's not, we do NOT clobber the old
            // information, nor do we refresh the old entry; we want it to time out in due course.
            //
            // We only create IP forwarding table entries in response to ARP packets, as that is the only
            // officially sanctioned way of learning the correspondence between an IP address and a MAC address.
            //
            NdisAcquireSpinLock( &pipte->lock );
            if( pipte->pAdapt == pAdapt )
            {
                UINT            Result;

                ETH_COMPARE_NETWORK_ADDRESSES_EQ( pipte->macAddr, &pPacketData[ETH_LENGTH_OF_ADDRESS], &Result );

                if( Result == 0 )
                {
                    bInfoMatches = TRUE;
                }
            }
            NdisReleaseSpinLock( &pipte->lock );

            if( bInfoMatches )
            {
                // Refresh the entry
                BrdgHashRefreshEntry( (PHASH_TABLE_ENTRY)pipte );
            }
            else
            {
                // The info is mismatched; let the entry fester
                THROTTLED_DBGPRINT(COMPAT, ("WARNING: Saw a packet from %i.%i.%i.%i that did not match its forwarding table entry! Table is %02x:%02x:%02x:%02x:%02x:%02x, packet is %02x:%02x:%02x:%02x:%02x:%02x\n",
                                            ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
                                            ((PUCHAR)&piphi->ipSource)[0], pipte->macAddr[0], pipte->macAddr[1], pipte->macAddr[2],
                                            pipte->macAddr[3], pipte->macAddr[4], pipte->macAddr[5], pPacketData[ETH_LENGTH_OF_ADDRESS],
                                            pPacketData[ETH_LENGTH_OF_ADDRESS + 1], pPacketData[ETH_LENGTH_OF_ADDRESS + 2], pPacketData[ETH_LENGTH_OF_ADDRESS + 3],
                                            pPacketData[ETH_LENGTH_OF_ADDRESS + 4], pPacketData[ETH_LENGTH_OF_ADDRESS + 5] ));
            }

            NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
        }
        else
        {
            // CONSIDER: Make a forwarding table entry here? Are there cases where this would be undesirable?
            //
            //THROTTLED_DBGPRINT(COMPAT, ("WARNING: Saw IP packet before ARP from %i.%i.%i.%i\n",
            //                            ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
            //                            ((PUCHAR)&piphi->ipSource)[0] ));
        }
    }
    else
    {
        //
        // The source IP address on this packet is to be ignored.
        // Just about the only thing we expect is the zero address
        //
        if( piphi->ipSource != 0L )
        {
            THROTTLED_DBGPRINT(COMPAT, ("Saw a packet with a non-unicast source IP address %i.%i.%i.%i on adapter %p!\n",
                                        ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
                                        ((PUCHAR)&piphi->ipSource)[0], pAdapt));
        }
    }

    //
    // Now that we have refreshed the IP forwarding table entry for the sending station,
    // figure out where to send the packet based on its destination.
    //

    // The target MAC address is the first thing in the Ethernet frame
    if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
    {
        //
        // Packet is broadcast / multicast at the Ethernet level.
        //
        // We need to send it on all other compatibility-mode adapters
        // (and regular adapters too if this came in on a compatibility
        // adapter)
        //

        bRetained = BrdgCompSendToMultipleAdapters( pPacket, pAdapt, pPacketData,
                                                    bCanRetain && (!pAdapt->bCompatibilityMode), // TRUE == can retain
                                                    // If this is a compat adapter, send to all adapters
                                                    pAdapt->bCompatibilityMode,
                                                    pEditFunc, pData );

        if( (!bCanRetain) || (pAdapt->bCompatibilityMode) )
        {
            SAFEASSERT( !bRetained );
        }

        if( pAdapt->bCompatibilityMode )
        {
            // It's our job to indicate this packet.
            bRetained = BrdgCompIndicatePacketOrPacketCopy(pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
        }
        // else the regular-mode processing will indicate this frame
    }
    else
    {
        //
        // Packet is unicast at the Ethernet level. Verify that it's targeted at a unicast IP address.
        //
        BOOLEAN         bIsUnicast = BrdgCompIsUnicastIPAddress(piphi->ipTarget);

        if( !bIsUnicast )
        {
            //
            // Strange; this packet is unicast to us at the Ethernet level but is for a
            // broadcast, multicast or zero target IP address.
            //
            // We will have no entries for this in our forwarding table, and we assume the
            // IP stack will have no next-hop information for this address, so we just indicate
            // it right away and let the IP driver figure out what this thing is.
            //
            THROTTLED_DBGPRINT(COMPAT, ("Packet with non-unicast target IP address %i.%i.%i.%i received in unicast Ethernet frame on adapter %p",
                                        ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2], ((PUCHAR)&piphi->ipTarget)[1],
                                        ((PUCHAR)&piphi->ipTarget)[0], pAdapt ));

            // Process the packet below as if it were unicast to us.
        }

        if( (!bIsUnicast) || BrdgCompIsLocalIPAddress(piphi->ipTarget) )
        {
            //
            // It's only appropriate for us to indicate the packet if the adapter
            // on which the packet was received is a compatibility-mode adapter.
            // Otherwise, the packet is indicated along regular codepaths without
            // the need to edit it in any way.
            //
            if( pAdapt->bCompatibilityMode )
            {
                bRetained = BrdgCompIndicatePacketOrPacketCopy(pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
            }
            else
            {
                bRetained = FALSE;
            }
        }
        else
        {
            //
            // This packet is not for us. Look it up in our forwarding table to see if
            // we know where the target machine is.
            //
            pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&piphi->ipTarget, &LockState );

            if( pipte != NULL )
            {
                PADAPT          pTargetAdapt;
                UCHAR           targetMAC[ETH_LENGTH_OF_ADDRESS];

                // Copy out the information we need within the spin lock
                NdisAcquireSpinLock( &pipte->lock );
                pTargetAdapt = pipte->pAdapt;
                ETH_COPY_NETWORK_ADDRESS( targetMAC, pipte->macAddr );
                NdisReleaseSpinLock( &pipte->lock );

                // We will use the adapter outside the table lock
                BrdgAcquireAdapterInLock( pTargetAdapt );

                // Done with the table entry
                NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );

                // It is strange to receive traffic that needs to be retransmitted on the same adapter.
                if( pTargetAdapt == pAdapt )
                {
                    THROTTLED_DBGPRINT(COMPAT, ("WARNING: retransmitting traffic for %i.%i.%i.%i on Adapter %p\n",
                                                ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2],
                                                ((PUCHAR)&piphi->ipTarget)[1], ((PUCHAR)&piphi->ipTarget)[0], pAdapt));
                }

                bRetained = BrdgCompEditAndSendPacketOrPacketCopy(pPacket, pPacketData, bCanRetain, targetMAC,
                                                                  pTargetAdapt, pEditFunc, pData );

                BrdgReleaseAdapter( pTargetAdapt );
            }
            else
            {
                IPADDRESS           ipNextHop;

                //
                // This packet was unicast to us at the Ethernet level but is for an IP address
                // that isn't in our forwarding table. Assuming the transmitting station had a
                // good reason for sending us this packet, and that our forward tables are working
                // correctly and aren't corrupt, two possibilities remain:
                //
                // a) The packet needs to be routed off the subnet by the local machine (this is
                //    why the target IP address doesn't appear in our tables; one does not ARP for
                //    an off-subnet machine before transmitting to it; one sends packets to one's
                //    default gateway)
                //
                // b) The packet needs to be routed off the subnet by some other machine. Unfortunately
                //    we don't know which one, since all packets that come to us have the same target
                //    MAC address and the target IP address is no use; what we really want is the
                //    first-hop IP address.
                //
                // To sort this out, we call TCPIP to do a route lookup for the packet's target IP
                // address. If the resulting next-hop IP address appears in our forwarding table
                // (i.e., it is reachable on the bridged network), we send the packet on to that
                // destination. If TCPIP gives us no first-hop, or the first-hop isn't in our table
                // (as would occur if the next hop is reachable through some non-bridged adapter)
                // we indicate the packet so TCPIP can deal with it. In such a case, the packet is
                // either not routable (and IP will drop it) or was meant to be routed by the local
                // machine (in which case IP will route it to its next hop).
                //

                if( BrdgCompGetNextHopForTarget(piphi->ipTarget, &ipNextHop) )
                {
                    // We got a next-hop address. See if that address is in our forwarding table.
                    pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&ipNextHop, &LockState );

                    if( pipte != NULL )
                    {
                        PADAPT          pNextHopAdapt;
                        UCHAR           nextHopMAC[ETH_LENGTH_OF_ADDRESS];

                        // Must copy out the information inside the entry's spin lock
                        NdisAcquireSpinLock( &pipte->lock );
                        pNextHopAdapt = pipte->pAdapt;
                        ETH_COPY_NETWORK_ADDRESS( nextHopMAC, pipte->macAddr );
                        NdisReleaseSpinLock( &pipte->lock );

                        // We will use the adapter outside the table lock
                        BrdgAcquireAdapterInLock( pNextHopAdapt );

                        // We're done with the forwarding table
                        NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );

                        // Something strange is afoot if the next hop is reachable through the same adapter
                        if( pNextHopAdapt == pAdapt )
                        {
                            THROTTLED_DBGPRINT(COMPAT, ("WARNING: retransmitting traffic for %i.%i.%i.%i on Adapter %p to next-hop %i.%i.%i.%i\n",
                                                        ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2],
                                                        ((PUCHAR)&piphi->ipTarget)[1], ((PUCHAR)&piphi->ipTarget)[0], pAdapt,
                                                        ((PUCHAR)&ipNextHop)[3], ((PUCHAR)&ipNextHop)[2],
                                                        ((PUCHAR)&ipNextHop)[1], ((PUCHAR)&ipNextHop)[0]));
                        }

                        // Send the packet out the appropriate adapter
                        bRetained = BrdgCompEditAndSendPacketOrPacketCopy(  pPacket, pPacketData, bCanRetain, nextHopMAC,
                                                                            pNextHopAdapt, pEditFunc, pData );

                        BrdgReleaseAdapter( pNextHopAdapt );
                    }
                    else
                    {
                        //
                        // The next hop isn't in our forwarding table. This means that the next hop machine
                        // isn't reachable on the bridged network, unless we're in a screwy state with
                        // respect to the transmitting machine (i.e., it never ARPed for the router it
                        // wanted because it had a static ARP entry or some other such weirdness).
                        // At any rate, conclude at this point that the local machine should handle the packet.
                        //
                        bRetained = BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
                    }
                }
                else
                {
                    //
                    // No usable next-hop information. Conclude that the packet should be handled by
                    // the local machine. Indicate.
                    //
                    bRetained = BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
                }
            }
        }
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}

// Returns whether the packet was retained
BOOLEAN
BrdgCompProcessInboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound non-ARP packet

Arguments:

    pPacket                     The packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained = FALSE;
    IP_HEADER_INFO              iphi;

    SAFEASSERT( (pPacket != NULL) && (pPacketData != NULL) );

    if( packetLen >= MINIMUM_SIZE_FOR_IP )
    {
        if( BrdgCompDecodeIPHeader(pPacketData + ETHERNET_HEADER_SIZE, &iphi) )
        {
            PUCHAR              pBootPData;

            pBootPData = BrdgCompIsBootPPacket( pPacketData, packetLen, &iphi );

            if ( pBootPData != NULL )
            {
                // This is a BOOTP packet; do BOOTP-specific processing
                bRetained = BrdgCompProcessInboundBootPPacket( pPacket, pAdapt, bCanRetain, pPacketData, packetLen, &iphi, pBootPData );
            }
            else
            {
                // Do generic IP processing
                bRetained = BrdgCompProcessInboundIPPacket(pPacket, &iphi, pAdapt, bCanRetain, pPacketData, packetLen, NULL, NULL);
            }
        }
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessInboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData
    )
/*++

Routine Description:

    Processes an inbound BOOTP packet

Arguments:

    pPacket                     The packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer
    piphi                       Decoded IP header info
    pBootPData                  Pointer to BOOTP payload within the packet


Return Value:

    Whether we retained the packet

--*/
{
    UCHAR                       targetMAC[ETH_LENGTH_OF_ADDRESS];
    BOOLEAN                     bIsRequest;
    PADAPT                      pTargetAdapt = NULL;

    if( BrdgCompPreprocessBootPPacket(pPacketData, piphi, pBootPData, pAdapt, &bIsRequest, &pTargetAdapt, targetMAC) )
    {
        if( bIsRequest )
        {
            //
            // This is a request packet. It can be processed as a regular inbound IP packet,
            // subject to appropriate rewriting at each step.
            //
            SAFEASSERT( pTargetAdapt == NULL );
            return BrdgCompProcessInboundIPPacket( pPacket, piphi, pAdapt, bCanRetain, pPacketData, packetLen,
                                                   BrdgCompRewriteBootPPacketForAdapt, piphi );
        }
        else
        {
            BOOLEAN                 bUsingCopyPacket, bRetained;

            //
            // This is a reply packet. We can rewrite it once for all purposes.
            //

            // Make a copy if necessary so we can edit.
            if( ! bCanRetain )
            {
                pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

                if( (pPacket == NULL) || (pPacketData == NULL) )
                {
                    // Free the target adapter before bailing out
                    if( pTargetAdapt !=  NULL )
                    {
                        BrdgReleaseAdapter( pTargetAdapt );
                    }

                    return FALSE;
                }

                bUsingCopyPacket = TRUE;
            }
            else
            {
                bUsingCopyPacket = FALSE;
            }

            // Rewrite the packet to the retrieved MAC address.
            BrdgCompRewriteBootPClientAddress( pPacketData, piphi, targetMAC );

            if( pTargetAdapt != NULL )
            {
                // If the reply was sent by broadcast, respect this, even if we think
                // we know the unicast MAC address of the target.
                if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
                {
                    // Broadcast around the reply
                    bRetained = BrdgCompSendToMultipleAdapters( pPacket, pAdapt, pPacketData, TRUE, pAdapt->bCompatibilityMode,
                                                                NULL, NULL );
                }
                else
                {
                    // Unicast back the reply
                    ETH_COPY_NETWORK_ADDRESS( pPacketData, targetMAC );
                    BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

                    bRetained = TRUE;
                }

                // The target adapter came back with an incremented refcount
                BrdgReleaseAdapter( pTargetAdapt );
            }
            else
            {
                // This reply is for the local machine!
                UINT                Result;

                // The recorded MAC address should be the MAC address of the bridge.
                SAFEASSERT( gCompHaveMACAddress );
                ETH_COMPARE_NETWORK_ADDRESSES_EQ( targetMAC, gCompMACAddress, &Result );
                SAFEASSERT( Result == 0 );

                // Indicate the edited reply
                BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
                bRetained = TRUE;
            }

            if( bUsingCopyPacket )
            {
                if( !bRetained )
                {
                    // Our copy packet was not retained.
                    BrdgFwdReleaseCompatPacket( pPacket );
                }

                // If we were using a copy packet, we definitely did not retain the packet passed in
                bRetained = FALSE;
            }

            return bRetained;
        }
    }
    else
    {
        // Something went wrong in the preprocessing.
        return FALSE;
    }
}



// ===========================================================================
//
// OUTBOUND PACKET PROCESSING
//
// ===========================================================================


BOOLEAN
BrdgCompProcessOutboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    )
/*++

Routine Description:

    Processes an outbound non-ARP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup


Return Value:

    Whether we retained the packet

--*/
{
    IP_HEADER_INFO              iphi;
    BOOLEAN                     bRetained = FALSE, bIsMulticast;

    if( packetLen >= MINIMUM_SIZE_FOR_IP &&
        BrdgCompDecodeIPHeader(pPacketData + ETHERNET_HEADER_SIZE, &iphi) )
    {
        PUCHAR                  pBootPData;

        pBootPData = BrdgCompIsBootPPacket(pPacketData, packetLen, &iphi);

        if( pBootPData != NULL )
        {
            // Do special BOOTP processing
            return BrdgCompProcessOutboundBootPPacket( pPacket, pPacketData, packetLen, pTargetAdapt, pBootPData, &iphi );
        }
    }

    bIsMulticast = (BOOLEAN)(ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData));

    // We edit and transmit the packet even if it doesn't appear to be IP.
    if( (pTargetAdapt == NULL) || bIsMulticast )
    {
        // Don't expect a target adapter when the outbound frame is broadcast
        if( bIsMulticast )
        {
            SAFEASSERT( pTargetAdapt == NULL );
        }

        // We need to send this packet to all compat adapters.
        bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, /*Can retain*/
                                                    FALSE /* Compat-mode adapters only*/,
                                                    NULL /*No editing function*/, NULL );
    }
    else
    {
        BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

        // The packet has been handed off to the forwarding engine
        bRetained = TRUE;
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessOutboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    )
/*++

Routine Description:

    Processes an outbound ARP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup

Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained = FALSE, bIsMulticast;
    ARPINFO                     ai;

    if( packetLen < SIZE_OF_ARP_PACKET )
    {
        // Packet is too small to be ARP; process as non-ARP
        return BrdgCompProcessOutboundNonARPPacket( pPacket, pPacketData, packetLen, pTargetAdapt );
    }

    if( BrdgCompDecodeARPPacket(pPacketData, packetLen, &ai) )
    {
        if( ai.type == ArpRequest )
        {
            ARP_TABLE_KEY           atk;
            PARP_TABLE_ENTRY        pEntry;
            LOCK_STATE              LockState;
            BOOLEAN                 bIsNewEntry;

            // Note that the local machine is trying to resolve this target IP address by
            // inserting or refreshing an entry with 0.0.0.0 as the requestor
            atk.ipReqestor = 0L;    // Special value for local machine
            atk.ipTarget = ai.ipTarget;

            pEntry = (PARP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingARPTable, (PUCHAR)&atk, &bIsNewEntry,
                                                                &LockState );

            if( pEntry != NULL )
            {
                if( bIsNewEntry)
                {
                    // Even though this entry isn't really ever used, initialize it so
                    // functions walking across table entries don't get confused or crash.
                    NdisAllocateSpinLock( &pEntry->lock );
                    pEntry->pOriginalAdapt = NULL;
                    pEntry->originalMAC[0] = pEntry->originalMAC[1] = pEntry->originalMAC[2] =
                        pEntry->originalMAC[3] = pEntry->originalMAC[4] =pEntry->originalMAC[5] = 0;
                }

                NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
            }
        }

        // Check if this frame looks like it should be relayed to all compat adapters
        bIsMulticast = (BOOLEAN)(ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData));

        if( (pTargetAdapt == NULL) || bIsMulticast )
        {
            // Don't expect a target adapter when the outbound frame is broadcast
            if( bIsMulticast )
            {
                SAFEASSERT( pTargetAdapt == NULL );
            }

            // We need to send this packet to all compat adapters.
            bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE,/*Can retain*/
                                                        FALSE /* Compat-mode adapters only*/,
                                                        BrdgCompRewriteOutboundARPPacket, NULL );
        }
        else
        {
            // Edit the packet for the outbound adapter
            BrdgCompRewriteOutboundARPPacket( pPacketData, pTargetAdapt, NULL );

            // Send the packet on its way
            BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

            // The packet has been handed off to the forwarding engine
            bRetained = TRUE;
        }
    }
    else
    {
        // The packet didn't look like an ARP packet. Process it otherwise.
        return BrdgCompProcessOutboundNonARPPacket( pPacket, pPacketData, packetLen, pTargetAdapt );
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessOutboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt,
    IN PUCHAR                   pBootPData,
    IN PIP_HEADER_INFO          piphi
    )
/*++

Routine Description:

    Processes an outbound BOOTP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup
    pBootPData                  Pointer to the BOOTP payload within the packet
    piphi                       Decoded info from the packet's IP header

Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bIsRequest, bRetained;
    PADAPT                      pRequestorAdapt = NULL;
    UCHAR                       macRequestor[ETH_LENGTH_OF_ADDRESS];

    if( BrdgCompPreprocessBootPPacket( pPacketData, piphi, pBootPData, NULL, &bIsRequest, &pRequestorAdapt, macRequestor ) )
    {
        if( bIsRequest )
        {
            //
            // This is a BOOTP request. Transmit as appropriate but rewrite for each adapter.
            //
            SAFEASSERT( pRequestorAdapt == NULL );

            if( (pTargetAdapt == NULL) || ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
            {
                bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, FALSE, BrdgCompRewriteBootPPacketForAdapt,
                                                            piphi );
            }
            else
            {
                // Rewrite the packet before transmission
                BrdgCompRewriteBootPPacketForAdapt( pPacketData, pTargetAdapt, piphi );

                // Unicast out the packet
                BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );
                bRetained = TRUE;
            }
        }
        else
        {
            //
            // This is a BOOTP reply. No editing is necessary; just send it.
            //
            if( (pTargetAdapt == NULL) || ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
            {
                bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, FALSE, NULL, NULL );
            }
            else
            {
                UINT            Result;

                // Verify for sanity that the target we're sending it to matches the information
                // in the table.
                ETH_COMPARE_NETWORK_ADDRESSES_EQ( macRequestor, pPacketData, &Result );
                SAFEASSERT( Result == 0 );
                SAFEASSERT( pTargetAdapt == pRequestorAdapt );

                // This packet is unicast, probably part of an established conversation with a
                // DHCP server.
                BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );
                bRetained = TRUE;
            }

            // This comes back with its refcount incremented
            if( pRequestorAdapt != NULL )
            {
                BrdgReleaseAdapter( pRequestorAdapt );
            }
        }
    }
    else
    {
        // Preprocessing failed
        bRetained = FALSE;
    }

    return bRetained;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgfwd.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgfwd.c

Abstract:

    Ethernet MAC level bridge.
    Forwarding engine section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgtbl.h"
#include "brdgfwd.h"
#include "brdgbuf.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

//
// Number of queued packets we will process back-to-back at DISPATCH level before
// dropping back to PASSIVE to let the scheduler run
//
#define MAX_PACKETS_AT_DPC      10

// The STA multicast address
UCHAR                           STA_MAC_ADDR[ETH_LENGTH_OF_ADDRESS] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x00 };

// The flags we change on packet descriptor when sending them. For a fast-track
// send, these flags should be put back the way they were before returning
// the overlying protocol's packet descriptor.
#define CHANGED_PACKET_FLAGS    (NDIS_FLAGS_LOOPBACK_ONLY | NDIS_FLAGS_DONT_LOOPBACK)

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

//
// Pointers to the KTHREAD structure for each active thread
//
PVOID                   gThreadPtrs[MAXIMUM_PROCESSORS];

//
// The number of created threads
//
UINT                    gNumThreads = 0L;

// Global kill signal for threads
KEVENT                  gKillThreads;

//
// These auto-reset events signal the queue-draining threads to re-enumerate the
// adapter list (strobed when the adapter list is changed)
//
KEVENT                  gThreadsCheckAdapters[MAXIMUM_PROCESSORS];

//
// Whether or not we should hang on to NIC's packets when they are indicated on the
// copy path. If FALSE, we always copy packets.
//
BOOLEAN                 gRetainNICPackets = FALSE;

//
// DEBUG-ONLY: Set this to a particular MAC address to break when receiving a packet
// from that address.
//
#if DBG
BOOLEAN                 gBreakOnMACAddress = FALSE;
UCHAR                   gBreakMACAddress[ETH_LENGTH_OF_ADDRESS] = {0, 0, 0, 0, 0, 0};
BOOLEAN                 gBreakIfNullPPI = FALSE;
#endif

//
// XPSP1: 565471
// We start out with this disabled.  Once we know that it's allowed, we re-allow bridging to 
// take place.
//
BOOLEAN gBridging = FALSE;

BOOLEAN gPrintPacketTypes = FALSE;

extern BOOLEAN gHaveID;

// ===========================================================================
//
// STATISTICS
//
// ===========================================================================

LARGE_INTEGER   gStatTransmittedFrames = { 0L, 0L };            // Local-source frames sent successfully to at least
                                                                // one adapter

LARGE_INTEGER   gStatTransmittedErrorFrames = { 0L, 0L };       // Local-source frames not sent AT ALL due to errors

LARGE_INTEGER   gStatTransmittedBytes = { 0L, 0L };             // Local-source bytes sent successfully to at least
                                                                // one adapter

// Breakdown of transmitted frames
LARGE_INTEGER   gStatDirectedTransmittedFrames = { 0L, 0L };
LARGE_INTEGER   gStatMulticastTransmittedFrames = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastTransmittedFrames = { 0L, 0L };

// Breakdown of transmitted bytes
LARGE_INTEGER   gStatDirectedTransmittedBytes = { 0L, 0L };
LARGE_INTEGER   gStatMulticastTransmittedBytes = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastTransmittedBytes = { 0L, 0L };


LARGE_INTEGER   gStatIndicatedFrames = { 0L, 0L };              // # of inbound frames indicated up

LARGE_INTEGER   gStatIndicatedDroppedFrames = { 0L, 0L };       // # of inbound frames we would have indicated but couldn't
                                                                // because of resources / error

LARGE_INTEGER   gStatIndicatedBytes = { 0L, 0L };               // # of inbound bytes indicated up

// Breakdown of indicated frames
LARGE_INTEGER   gStatDirectedIndicatedFrames = { 0L, 0L };
LARGE_INTEGER   gStatMulticastIndicatedFrames = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastIndicatedFrames = { 0L, 0L };

// Breakdown of indicated bytes
LARGE_INTEGER   gStatDirectedIndicatedBytes = { 0L, 0L };
LARGE_INTEGER   gStatMulticastIndicatedBytes = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastIndicatedBytes = { 0L, 0L };

//
// The following stats are not reported to NDIS; they're here for our own amusement
//
LARGE_INTEGER   gStatReceivedFrames = { 0L, 0L };               // Total # of processed inbound packets
LARGE_INTEGER   gStatReceivedBytes = { 0L, 0L };                // Total inbound processed bytes

LARGE_INTEGER   gStatReceivedCopyFrames = { 0L, 0L };           // Total # of processed inbound packets WITH COPY
LARGE_INTEGER   gStatReceivedCopyBytes = { 0L, 0L };            // Total inbound processed bytes WITH COPY

LARGE_INTEGER   gStatReceivedNoCopyFrames = { 0L, 0L };         // Total # of processed inbound packets WITHOUT COPY
LARGE_INTEGER   gStatReceivedNoCopyBytes = { 0L, 0L };          // Total inbound processed bytes WITHOUT COPY

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

// Undocumented kernel function
extern KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

VOID
BrdgFwdSendOnLink(
    IN  PADAPT          pAdapt,
    IN  PNDIS_PACKET    pPacket
    );

VOID
BrdgFwdReleaseBasePacket(
    IN PNDIS_PACKET         pPacket,
    PPACKET_INFO            ppi,
    PACKET_OWNERSHIP        Own,
    NDIS_STATUS             Status
    );

// This is the type of function to be passed to BrdgFwdHandlePacket()
typedef PNDIS_PACKET (*PPACKET_BUILD_FUNC)(PPACKET_INFO*, PADAPT, PVOID, PVOID, UINT, UINT);

NDIS_STATUS
BrdgFwdHandlePacket(
    IN PACKET_DIRECTION     PacketDirection,
    IN PADAPT               pTargetAdapt,
    IN PADAPT               pOriginalAdapt,
    IN BOOLEAN              bShouldIndicate,
    IN NDIS_HANDLE          MiniportHandle,
    IN PNDIS_PACKET         pBasePacket,
    IN PPACKET_INFO         ppi,
    IN PPACKET_BUILD_FUNC   pFunc,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

VOID
BrdgFwdWrapPacketForReceive(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    );

VOID
BrdgFwdWrapPacketForSend(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    );

// The type of function to pass to BrdgFwdCommonAllocAndWrapPacket
typedef VOID (*PWRAPPER_FUNC)(PNDIS_PACKET, PNDIS_PACKET);

PNDIS_PACKET
BrdgFwdCommonAllocAndWrapPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt,
    IN PWRAPPER_FUNC        pFunc
    );

VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    );

BOOLEAN
BrdgFwdNoCopyFastTrackReceive(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt,
    IN NDIS_HANDLE          MiniportHandle,
    IN PUCHAR               DstAddr,
    OUT BOOLEAN             *bRetainPacket
    );

PNDIS_PACKET
BrdgFwdMakeCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PVOID                pHeader,
    IN PVOID                pData,
    IN UINT                 HeaderSize,
    IN UINT                 DataSize,
    IN UINT                 SizeOfPacket,
    IN BOOLEAN              bCountAsReceived,
    IN PADAPT               pOwnerAdapt,
    PVOID                   *ppBuf
    );

PNDIS_PACKET
BrdgFwdMakeNoCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

PNDIS_PACKET
BrdgFwdMakeSendBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

// This is the per-processor queue-draining function
VOID
BrdgFwdProcessQueuedPackets(
    IN PVOID                Param1
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Tells us if we're allowed to bridge, or if GPO's are currently disallowing 
// bridging
//

__forceinline
BOOLEAN
BrdgFwdBridgingNetworks()
{
    return gBridging;
}

//
// Frees a packet that was used to wrap a base packet
//
__forceinline
VOID
BrdgFwdFreeWrapperPacket(
    IN PNDIS_PACKET     pPacket,
    IN PPACKET_INFO     ppi,
    IN PADAPT           pQuotaOwner
    )
{
    SAFEASSERT( BrdgBufIsWrapperPacket(pPacket) );
    BrdgBufUnchainCopyBuffers( pPacket );
    BrdgBufFreeWrapperPacket( pPacket, ppi, pQuotaOwner );
}

//
// Frees a base packet that wraps a packet descriptor from an overlying protocol
// or underlying NIC that we were allowed to hang on to
//
__forceinline
VOID
BrdgFwdFreeBaseWrapperPacket(
    IN PNDIS_PACKET     pPacket,
    IN PPACKET_INFO     ppi
    )
{
    SAFEASSERT( BrdgBufIsWrapperPacket(pPacket) );
    BrdgBufUnchainCopyBuffers( pPacket );
    BrdgBufFreeBaseWrapperPacket( pPacket, ppi );
}

//
// Allocates a new wrapper packet, chains on buffer descriptors so that the new
// packet points to the same data buffers as the old packet, and copies per-packet
// information appropriate for using the new packet for indications
//
__forceinline
PNDIS_PACKET
BrdgFwdAllocAndWrapPacketForReceive(
    IN PNDIS_PACKET         pPacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt
    )
{
    return BrdgFwdCommonAllocAndWrapPacket( pPacket, pppi, pTargetAdapt, BrdgFwdWrapPacketForReceive );
}

//
// Allocates a new wrapper packet, chains on buffer descriptors so that the new
// packet points to the same data buffers as the old packet, and copies per-packet
// information appropriate for using the new packet for transmits
//
__forceinline
PNDIS_PACKET
BrdgFwdAllocAndWrapPacketForSend(
    IN PNDIS_PACKET         pPacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt
    )
{
    return BrdgFwdCommonAllocAndWrapPacket( pPacket, pppi, pTargetAdapt, BrdgFwdWrapPacketForSend );
}

//
// Checks if an address is one of the reserved group addresses for the Spanning Tree Algorithm.
//
__forceinline
BOOLEAN
BrdgFwdIsSTAGroupAddress(
    IN PUCHAR               pAddr
    )
{
    return( (pAddr[0] == STA_MAC_ADDR[0]) && (pAddr[1] == STA_MAC_ADDR[1]) &&
            (pAddr[2] == STA_MAC_ADDR[2]) && (pAddr[3] == STA_MAC_ADDR[4]) &&
            (pAddr[4] == STA_MAC_ADDR[4]) );
}

//
// Checks that PacketDirection has been assigned
//
__forceinline
VOID
BrdgFwdValidatePacketDirection(
    IN PACKET_DIRECTION     Direction
    )
{
    SAFEASSERT( (Direction == BrdgPacketInbound) || (Direction == BrdgPacketOutbound) ||
                (Direction == BrdgPacketCreatedInBridge) );
}

//
// Queues a packet for deferred processing
//
_inline
VOID
BrdgFwdQueuePacket(
    IN PPACKET_Q_INFO       ppqi,
    IN PADAPT               pAdapt
    )
{
    BOOLEAN                 bSchedule = FALSE, bIncremented;

    // The queue lock protects the bServiceInProgress flag
    NdisAcquireSpinLock( &pAdapt->QueueLock );

    // Add the packet to the queue
    BrdgInsertTailSingleList( &pAdapt->Queue, &ppqi->List );
    bIncremented = BrdgIncrementWaitRef( &pAdapt->QueueRefcount );
    SAFEASSERT( bIncremented );
    SAFEASSERT( (ULONG)pAdapt->QueueRefcount.Refcount == pAdapt->Queue.Length );

    // Check if anyone is already working on the queue
    if( ! pAdapt->bServiceInProgress )
    {
        // Signal the queue event so someone will wake up
        pAdapt->bServiceInProgress = TRUE;
        bSchedule = TRUE;
    }

    NdisReleaseSpinLock( &pAdapt->QueueLock );

    if( bSchedule )
    {
        KeSetEvent( &pAdapt->QueueEvent, EVENT_INCREMENT, FALSE );
    }
}

//
// Decrements a base packet's refcount and calls BrdgFwdReleaseBasePacket if the refcount
// reaches zero
//
_inline
BOOLEAN
BrdgFwdDerefBasePacket(
    IN PADAPT           pQuotaOwner,    // Can be NULL to not count quota
    IN PNDIS_PACKET     pBasePacket,
    IN PPACKET_INFO     ppi,
    IN NDIS_STATUS      Status
    )
{
    BOOLEAN             rc = FALSE;
    LONG                RefCount;

    SAFEASSERT( pBasePacket != NULL );
    SAFEASSERT( ppi != NULL );

    RefCount = NdisInterlockedDecrement( &ppi->u.BasePacketInfo.RefCount );
    SAFEASSERT( RefCount >= 0 );

    if( RefCount == 0 )
    {
        BrdgFwdReleaseBasePacket( pBasePacket, ppi, BrdgBufGetPacketOwnership( pBasePacket ), Status );
        rc = TRUE;
    }

    // Do quota bookkeeping if necessary
    if( pQuotaOwner != NULL )
    {
        BrdgBufReleaseBasePacketQuota( pBasePacket, pQuotaOwner );
    }

    return rc;
}

//
// Updates statistics to reflect a transmitted packet
//
_inline
VOID
BrdgFwdCountTransmittedPacket(
    IN PADAPT               pAdapt,
    IN PUCHAR               DstAddr,
    IN ULONG                PacketSize
    )
{
    SAFEASSERT( DstAddr != NULL );

    ExInterlockedAddLargeStatistic( &gStatTransmittedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatTransmittedBytes, PacketSize );

    ExInterlockedAddLargeStatistic( &pAdapt->SentFrames, 1L );
    ExInterlockedAddLargeStatistic( &pAdapt->SentBytes, PacketSize );

    ExInterlockedAddLargeStatistic( &pAdapt->SentLocalFrames, 1L );
    ExInterlockedAddLargeStatistic( &pAdapt->SentLocalBytes, PacketSize );

    if( ETH_IS_MULTICAST(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatMulticastTransmittedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatMulticastTransmittedBytes, PacketSize );

        if( ETH_IS_BROADCAST(DstAddr) )
        {
            ExInterlockedAddLargeStatistic( &gStatBroadcastTransmittedFrames, 1L );
            ExInterlockedAddLargeStatistic( &gStatBroadcastTransmittedBytes, PacketSize );
        }
    }
    else
    {
        ExInterlockedAddLargeStatistic( &gStatDirectedTransmittedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatDirectedTransmittedBytes, PacketSize );
    }
}

//
// Updates statistics to reflect an indicated packet
//
_inline
VOID
BrdgFwdCountIndicatedPacket(
    IN PUCHAR               DstAddr,
    IN ULONG                PacketSize
    )
{
    ExInterlockedAddLargeStatistic( &gStatIndicatedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatIndicatedBytes, PacketSize );

    if( ETH_IS_MULTICAST(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatMulticastIndicatedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatMulticastIndicatedBytes, PacketSize );

        if( ETH_IS_BROADCAST(DstAddr) )
        {
            ExInterlockedAddLargeStatistic( &gStatBroadcastIndicatedFrames, 1L );
            ExInterlockedAddLargeStatistic( &gStatBroadcastIndicatedBytes, PacketSize );
        }
    }
    else
    {
        ExInterlockedAddLargeStatistic( &gStatDirectedIndicatedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatDirectedIndicatedBytes, PacketSize );
    }
}

//
// Indicates a packet, counting it as such.
//
_inline
VOID
BrdgFwdIndicatePacket(
    IN PNDIS_PACKET         pPacket,
    IN NDIS_HANDLE          MiniportHandle
    )
{
    PVOID                   pHeader = BrdgBufGetPacketHeader(pPacket);

    SAFEASSERT( MiniportHandle != NULL );

    if( pHeader != NULL )
    {
        BrdgFwdCountIndicatedPacket( pHeader, BrdgBufTotalPacketSize(pPacket) );
    }
    // pHeader can only == NULL under heavy system stress

    NdisMIndicateReceivePacket( MiniportHandle, &pPacket, 1 );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================


NTSTATUS
BrdgFwdDriverInit()
/*++

Routine Description:

    Initialization code.

    A return status other than STATUS_SUCCESS causes the driver load to abort.
    Any event causing an error return code must be logged.

    Must be called at PASSIVE_LEVEL

Arguments:

    None

Return Value:

    None

--*/
{
    INT             i;
    HANDLE          ThreadHandle;
    NTSTATUS        Status;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Initialize our thread synchronization primitives
    KeInitializeEvent( &gKillThreads, NotificationEvent, FALSE );

    for(i = 0; i < KeNumberProcessors; i++)
    {
        KeInitializeEvent( &gThreadsCheckAdapters[i], SynchronizationEvent, FALSE );

        // Spin up a thread for this processor
        Status = PsCreateSystemThread( &ThreadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
                                       BrdgFwdProcessQueuedPackets, (PVOID)(INT_PTR)i );

        if(! NT_SUCCESS(Status) )
        {
            // Abort startup
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_THREAD_CREATION_FAILED, 0L, 0L, NULL,
                                    sizeof(NTSTATUS), &Status );
            DBGPRINT(FWD, ("Failed to create a system thread: %08x\n", Status));
            BrdgFwdCleanup();
            return Status;
        }

        // Retrieve a pointer to the thread object and reference it so we can wait for
        // its termination safely.
        Status = ObReferenceObjectByHandle( ThreadHandle, STANDARD_RIGHTS_ALL, NULL, KernelMode,
                                            &gThreadPtrs[i], NULL );

        if(! NT_SUCCESS(Status) )
        {
            // Abort startup
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_THREAD_REF_FAILED, 0L, 0L, NULL,
                                    sizeof(NTSTATUS), &Status );
            DBGPRINT(FWD, ("Couldn't retrieve a thread pointer: %08x\n", Status));
            BrdgFwdCleanup();
            return Status;
        }

        gNumThreads++;
    }

    return STATUS_SUCCESS;
}

VOID
BrdgFwdCleanup()
/*++

Routine Description:

    Unload-time orderly cleanup

    This function is guaranteed to be called exactly once

    Must be called at < DISPATCH_LEVEL since we wait on an event

Arguments:

    None

Return Value:

    None

--*/
{
    KWAIT_BLOCK         WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    NTSTATUS            Status;
    UINT                i;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    // Signal the threads to exit
    KeSetEvent( &gKillThreads, EVENT_INCREMENT, FALSE );

    // Block waiting for all threads to exit
    Status = KeWaitForMultipleObjects( gNumThreads, gThreadPtrs, WaitAll, Executive,
                                       KernelMode, FALSE, NULL, WaitBlocks );

    if( ! NT_SUCCESS(Status) )
    {
        // This really shouldn't happen
        DBGPRINT(FWD, ("KeWaitForMultipleObjects failed in BrdgFwdCleanup! %08x\n", Status));
        SAFEASSERT(FALSE);
    }

    // Dereference all thread objects to allow them to be destroyed
    for( i = 0; i < gNumThreads; i++ )
    {
        ObDereferenceObject( gThreadPtrs[i] );
    }
}

PNDIS_PACKET
BrdgFwdMakeCompatCopyPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PUCHAR             *pPacketData,
    OUT PUINT               packetDataSize,
    BOOLEAN                 bCountAsLocalSend
    )
/*++

Routine Description:

    Allocates a copy packet and fills it with a copy of the data from the given base
    packet. Used by the compatibility-mode code to make a copy packet that it can
    edit easily

Arguments:

    pBasePacket             Packet to copy from
    pPacketData             Receives a pointer to the flat data buffer of the new packet
    packetDataSize          Receives the size of the copied data
    bBasePacketIsInbound    TRUE if the packet being copied is outbound from higher-level
                            protocols; the packet will be counted as a miniport
                            transmission if / when it is send out an adapter.
                            FALSE causes the packet to not be counted as a local transmission.

Return Value:

    The new packet

--*/
{
    PNDIS_PACKET            pCopyPacket;
    PPACKET_INFO            ppi;
    UINT                    copiedBytes;

    // Find out how much data is in the base packet
    NdisQueryPacket( pBasePacket, NULL, NULL, NULL, packetDataSize );

    // Make a base copy packet with no data in it
    pCopyPacket = BrdgFwdMakeCopyBasePacket( &ppi, NULL, NULL, 0, 0, *packetDataSize, FALSE, NULL, pPacketData );

    if( pCopyPacket == NULL )
    {
        return NULL;
    }

    SAFEASSERT( ppi != NULL );
    SAFEASSERT( *pPacketData != NULL );

    // Set the original direction flags
    if( bCountAsLocalSend )
    {
        ppi->Flags.OriginalDirection = BrdgPacketOutbound;
    }
    else
    {
        ppi->Flags.OriginalDirection = BrdgPacketCreatedInBridge;
    }

    // Copy the data from the base packet to the copy packet
    NdisCopyFromPacketToPacket( pCopyPacket, 0, *packetDataSize, pBasePacket, 0, &copiedBytes );

    if( copiedBytes != *packetDataSize )
    {
        // We couldn't copy all the data. Bail out.
        THROTTLED_DBGPRINT(FWD, ("Failed to copy into a copy packet for compatibility processing\n"));
        BrdgFwdReleaseBasePacket(pCopyPacket, ppi, BrdgBufGetPacketOwnership(pCopyPacket), NDIS_STATUS_RESOURCES);
        return NULL;
    }

    // Put a pointer to the ppi where we expect to find it on completion
    *((PPACKET_INFO*)pCopyPacket->ProtocolReserved) = ppi;
    *((PPACKET_INFO*)pCopyPacket->MiniportReserved) = ppi;

    // Do fixups usually performed by BrdgFwdHandlePacket()
    ppi->u.BasePacketInfo.RefCount = 1L;
    ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

    // The packet is now ready to be sent. We expect the compatibility code to do its work
    // and call BrdgFwdSendPacketForComp() to transmit the packet.
    return pCopyPacket;
}

VOID
BrdgFwdSendPacketForCompat(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Transmits a packet on behalf of the compatibility-mode module.
    The packet must have been previously allocated with BrdgFwdMakeCompatCopyPacket.

Arguments:

    pPacket                 The packet to transmit
    pAdapt                  The adapter to transmit on

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;
    NDIS_STATUS             status;

    // Make sure the packet hasn't been monkeyed with inappropriately
    ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // Make sure this is a one-shot packet
    ppi->u.BasePacketInfo.RefCount = 1L;

    // We must do a quota check before sending the packet, as the packet completion
    // logic assumes all sent packets have been assigned to their outbound adapters
    if( BrdgBufAssignBasePacketQuota(pPacket, pAdapt) )
    {
        // We passed quota. Transmit the packet.
        BrdgFwdSendOnLink( pAdapt, pPacket );
    }
    else
    {
        // We didn't pass quota. Fail the transmission.
        DBGPRINT(FWD, ("Failed to send a compatibility packet because of quota failure\n"));
        status = NDIS_STATUS_RESOURCES;
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
    }
}

VOID
BrdgFwdIndicatePacketForCompat(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Indicates a packet on behalf of the compatibility-mode module.
    The packet must be a base copy packet that we own.

Arguments:

    pPacket                 The packet to indicate

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;
    NDIS_STATUS             status;
    NDIS_HANDLE             MiniportHandle;

    // Make sure the packet is a base packet and isn't out of
    // whack
    ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // Packets that come to us for indication from the compatibility
    // module are our own base packets that haven't had their refcount
    // set yet. Set the packet's refcount to 1, since its buffers
    // should never be shared.
    ppi->u.BasePacketInfo.RefCount = 1L;

    MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

    if( MiniportHandle != NULL )
    {
        // Check the quota for the local miniport
        if( BrdgBufAssignBasePacketQuota(pPacket, LOCAL_MINIPORT) )
        {
            // We passed quota.
            BrdgFwdIndicatePacket( pPacket, MiniportHandle );
        }
        else
        {
            // We didn't pass quota. Fail the transmission.
            DBGPRINT(FWD, ("Failed to indicate a compatibility packet because of quota failure\n"));
            status = NDIS_STATUS_RESOURCES;
            BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
        }

        BrdgMiniReleaseMiniportForIndicate();
    }
    else
    {
        // No miniport. Ditch the packet.
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_SUCCESS);
    }
}

VOID BrdgFwdReleaseCompatPacket(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Releases a packet previously allocated with BrdgFwdMakeCompatCopyPacket.

Arguments:

    pPacket                 The packet to release

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;

    // Retrieve the PACKET_INFO pointer
    ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );
    BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
BrdgFwdSendBuffer(
    IN PADAPT               pAdapt,
    IN PUCHAR               pPacketData,
    IN UINT                 DataSize
    )
/*++

Routine Description:

    Sends a raw buffer on a particular adapter. Used to send frames in response
    to user-mode requests.

Arguments:

    pAdapt                  The adapter to send on
    pPacketData             The frame
    DataSize                The size of the supplied frame

Return Value:

    Status of the packet transmission

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;

    // Build a packet around this buffer
    pPacket = BrdgFwdMakeCopyBasePacket( &ppi, pPacketData, NULL, DataSize, 0, DataSize, FALSE, NULL, NULL );

    if( pPacket == NULL )
    {
        return NDIS_STATUS_RESOURCES;
    }

    SAFEASSERT( ppi != NULL );

    // We must do a quota check before sending the packet, as the packet completion
    // logic assumes all sent packets have been assigned to their outbound adapters
    if( ! BrdgBufAssignBasePacketQuota(pPacket, pAdapt) )
    {
        // We didn't pass quota. Fail the transmission.
        DBGPRINT(FWD, ("Failed to send a raw buffer because of quota failure\n"));
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
        return NDIS_STATUS_RESOURCES;
    }

    // Put a pointer to the ppi where we expect to find it on completion
    *((PPACKET_INFO*)pPacket->ProtocolReserved) = ppi;

    // Do fixups usually performed by BrdgFwdHandlePacket()
    ppi->u.BasePacketInfo.RefCount = 1L;
    ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

    // Send the packet
    BrdgFwdSendOnLink( pAdapt, pPacket );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
BrdgFwdReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               pHeader,
    IN  UINT                HeaderSize,
    IN  PVOID               pLookAheadBuffer,
    IN  UINT                LookAheadSize,
    IN  UINT                PacketSize
    )
/*++

Routine Description:

    NDIS copy-path entry point. Receives an inbound packet on the copy path.

    Because the indicated data buffers are valid only for the duration of this
    function, we must copy the indicated data to our own packet descriptor
    before proceeding.

Arguments:

    ProtocolBindingContext  The receiving adapter
    MacReceiveContext       Must be passed as a param to certain Ndis APIs
    pHeader                 Packet header buffer
    HeaderSize              Size of pHeader
    pLookAheadBuffer        Buffer with packet data
    LookAheadSize           Size of pLookAheadBuffer
    PacketSize              Total packet size

Return Value:

    Status of the receive (cannot be NDIS_STATUS_PENDING)

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext, TargetAdapt = NULL;
    PUCHAR              SrcAddr = ((PUCHAR)pHeader) + ETH_LENGTH_OF_ADDRESS, DstAddr = pHeader;
    PNDIS_PACKET        pNewPacket;
    PPACKET_INFO        ppi;
    PPACKET_Q_INFO      ppqi;
    UINT                SizeOfPacket = HeaderSize + PacketSize;
    BOOLEAN             bIsSTAPacket = FALSE, bIsUnicastToBridge = FALSE, bRequiresCompatWork = FALSE;

#if DBG
    // Paranoia check for incorrectly looped-back packets
    {
        PNDIS_PACKET    pPacket = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);

        if( pPacket != NULL )
        {
            SAFEASSERT( BrdgBufGetPacketOwnership(pPacket) == BrdgNotOwned );
        }
    }

    // Break on packets from gBreakMACAddress
    if( gBreakOnMACAddress )
    {
        UINT result;

        ETH_COMPARE_NETWORK_ADDRESSES_EQ( SrcAddr, gBreakMACAddress, &result );

        if( result == 0 )
        {
            KdBreakPoint();
        }
    }
#endif

    // Don't accept packets if we are shutting down or this adapter is being torn down or reset
    if( (gShuttingDown) || (pAdapt->bResetting) || (! BrdgAcquireAdapter(pAdapt)) )
    {
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    // Must have at least a complete Ethernet header!
    if( HeaderSize < ETHERNET_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Too-small header seen in BrdgFwdReceive!\n"));
        BrdgReleaseAdapter( pAdapt );
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    // Packet can't be larger than the maximum size we can handle
    if( SizeOfPacket > MAX_PACKET_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Too-large packet seen in BrdgFwdReceive!\n"));
        BrdgReleaseAdapter( pAdapt );
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    // If this is an STA packet, we go through all the receive motions regardless of
    // our state
    //
    if( BrdgFwdIsSTAGroupAddress(DstAddr) )
    {
        if( DstAddr[5] == STA_MAC_ADDR[5] )
        {
            bIsSTAPacket = TRUE;
            TargetAdapt = NULL;
        }
        else
        {
            // Packet was sent to a reserved multicast address that we don't use.
            // We mustn't forward the frame.
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }
    }

    if( ! bIsSTAPacket )
    {
        // Note the MAC address of the frame if this adapter is learning
        if( (pAdapt->State == Learning) || (pAdapt->State == Forwarding) )
        {
            BrdgTblNoteAddress(SrcAddr, pAdapt);
        }

        //
        // Check if we are accepting packets or not
        //
        if( pAdapt->State != Forwarding )
        {
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        //
        // Look up the target in our table.
        // ** TargetAdapt comes back with its refcount incremented!
        //
        TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

        // If the target host is known to be on the same segment as the received
        // packet, there is no need to forward the packet.
        //
        // Also bail out here if the target adapter is resetting
        if( (TargetAdapt == pAdapt) ||
            ((TargetAdapt != NULL) && (TargetAdapt->bResetting)) )
        {
            BrdgReleaseAdapter( TargetAdapt );
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        // Learn if this packet requires compatibility-mode processing later
        // (this forces us to copy the packet to our own buffers and queue it)
        bRequiresCompatWork = BrdgCompRequiresCompatWork( pAdapt, pHeader, HeaderSize );

        // If the packet came in on a compatibility adapter, or is going to
        // a compatibility-mode adapter, but the compatibility code is not
        // interested in it, there is nothing further to be done with the packet.
        if( (pAdapt->bCompatibilityMode || ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)))
                &&
            (! bRequiresCompatWork) )
        {
            if( TargetAdapt != NULL )
            {
                BrdgReleaseAdapter( TargetAdapt );
            }

            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        bIsUnicastToBridge = BrdgMiniIsUnicastToBridge(DstAddr);

        // Sanity
        if( bIsUnicastToBridge && (TargetAdapt != NULL) )
        {
            //
            // This indicates that someone else on the network is using our MAC address,
            // or that there is an undetected loop such that we are seeing our own traffic!
            // Either way, this is very bad.
            //
            THROTTLED_DBGPRINT(FWD, ("*** Have a table entry for our own MAC address! PROBABLE NET LOOP!\n"));

            // Ditch the target adapter since we won't be using it
            BrdgReleaseAdapter( TargetAdapt );
            TargetAdapt = NULL;
        }
    }
    // else was STA packet; continue processing below

    //
    // There is no fast-track on the copy-receive path. Copy the packet data into our
    // own descriptor and queue the packet for processing later.
    //
    if (LookAheadSize == PacketSize)
    {
        // A normal, non-fragmented indicate. Copy the data to a new packet.
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, pHeader, pLookAheadBuffer, HeaderSize, LookAheadSize,
                                                SizeOfPacket, TRUE, pAdapt, NULL );

        if( pNewPacket == NULL )
        {
            // We failed to get a copy packet to wrap this data
            goto failure;
        }

        SAFEASSERT( ppi != NULL );

        // Queue the new packet for processing
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;

        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->pInfo = ppi;
        ppqi->Flags.bIsSTAPacket = bIsSTAPacket;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        BrdgFwdQueuePacket( ppqi, pAdapt );
    }
    else
    {
        NDIS_STATUS         Status;
        UINT                transferred;
        PNDIS_BUFFER        pBufDesc;
        PUCHAR              pBuf;

        //
        // This is an unusual code path in this day and age; the underlying driver
        // is an old NDIS driver that still does fragmented receives.
        //
        SAFEASSERT( LookAheadSize < PacketSize );

        // Get copy packet and copy in the header data (but NOT the lookahead)
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, pHeader, NULL, HeaderSize, 0, SizeOfPacket, TRUE, pAdapt, &pBuf );

        if( pNewPacket == NULL )
        {
            // We failed to get a copy packet
            goto failure;
        }

        SAFEASSERT( ppi != NULL );
        SAFEASSERT( pBuf != NULL );

        //
        // NdisTransferData is kind of a crummy API; it won't copy the entire packet
        // (i.e., you have to copy the header separately), and it won't let you specify
        // an offset in the receiving packet to copy to. The NIC wants to copy into the
        // beginning of the first buffer chained to the packet.
        //
        // Because of this silliness, we copy the header into the beginning of our copy
        // packet's data buffer (done in the call to BrdgFwdMakeCopyBasePacket above).
        //
        // Then we grab a NEW buffer descriptor, point it to the area of the data buffer
        // *after* the header, and chain it to the front of the packet. Then we request
        // that all data (other than the header) be copied.
        //
        // In BrdgFwdTransferComplete, we rip off the leading buffer descriptor and
        // dispose of it, leaving a single buffer descriptor that correctly describes
        // the (single) data buffer, now containing all data.
        //
        pBufDesc = BrdgBufAllocateBuffer( pBuf + HeaderSize, PacketSize );

        if( pBufDesc == NULL )
        {
            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }

        // Chain this to the front of the packet where it will be used during the copy
        NdisChainBufferAtFront( pNewPacket, pBufDesc );

        // Set up the queuing structure in the packet's ProtocolReserved area
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;
        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->pInfo = ppi;
        ppqi->Flags.bIsSTAPacket = bIsSTAPacket;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        // Ask the NIC to copy the packet's data into the new packet
        NdisTransferData( &Status, pAdapt->BindingHandle, MacReceiveContext, 0, PacketSize,
                          pNewPacket, &transferred );

        if( Status == NDIS_STATUS_SUCCESS )
        {
            // Call BrdgFwdTransferComplete by hand to postprocess the packet.
            BrdgFwdTransferComplete( (NDIS_HANDLE)pAdapt, pNewPacket, Status, transferred );
        }
        else if( Status != NDIS_STATUS_PENDING )
        {
            // The transfer failed for some reason.
            NdisUnchainBufferAtFront( pNewPacket, &pBufDesc );

            if( pBufDesc != NULL )
            {
                NdisFreeBuffer( pBufDesc );
            }
            else
            {
                SAFEASSERT( FALSE );
            }

            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }
        // else BrdgFwdTransferComplete will be called to postprocess the packet.
    }

    BrdgReleaseAdapter( pAdapt );
    return NDIS_STATUS_SUCCESS;

failure:
    if( TargetAdapt != NULL )
    {
        BrdgReleaseAdapter( TargetAdapt );
    }

    if( BrdgMiniShouldIndicatePacket(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
    }

    BrdgReleaseAdapter( pAdapt );
    return NDIS_STATUS_NOT_ACCEPTED;
}

VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    )
/*++

Routine Description:

    NDIS entry point, registered in BrdgProtRegisterProtocol. Called when a
    call to NdisTransferData() that returned NDIS_STATUS_PENDING completes
    (we also call this by hand to postprocess a call that completes immediately).

    If the data copy from the underlying NIC was successful, the packet is
    queued for processing on the owner adapter's queue. Otherwise the packet
    is released.

Arguments:

    ProtocolBindingContext      The receiving adapter
    pPacket                     The base packet into which data was being copied
    Status                      Status of the copy
    BytesTransferred            Number of transferred bytes (unused)

Return Value:

    None

--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;
    PPACKET_Q_INFO          ppqi = (PPACKET_Q_INFO)&pPacket->ProtocolReserved;
    PNDIS_BUFFER            pBuf;

    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( ppqi->pInfo != NULL );
    SAFEASSERT( ppqi->pInfo->pOwnerPacket == pPacket );
    SAFEASSERT( ppqi->Flags.bFastTrackReceive == FALSE );

    // Remove the extra buffer descriptor on the front of the packet and dispose of it
    // (see comments in BrdgFwdReceive() for details)
    NdisUnchainBufferAtFront( pPacket, &pBuf );

    if( pBuf != NULL )
    {
        NdisFreeBuffer( pBuf );
    }
    else
    {
        // Should never happen
        SAFEASSERT( FALSE );
    }

    // We should still have the original buffer descriptor describing the entire data buffer
    // chained to the packet
    SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) != NULL );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // The copy failed. Undo everything.
        if( ppqi->u.pTargetAdapt != NULL )
        {
            BrdgReleaseAdapter( ppqi->u.pTargetAdapt );
        }

        if( ppqi->Flags.bShouldIndicate )
        {
            ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
        }

        BrdgFwdReleaseBasePacket( pPacket, ppqi->pInfo, BrdgBufGetPacketOwnership(pPacket), Status );
    }
    else
    {
        // Success! Queue the packet for processing
        BrdgFwdQueuePacket( ppqi, pAdapt );
    }
}

INT
BrdgFwdReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket
    )
/*++

Routine Description:

    NDIS no-copy entry point

    Receives a packet on the no-copy path

Arguments:

    ProtocolBindingContext  The adapter on which the packet is received
    pPacket                 The received packet

Return Value:

    The number of times we will call NdisReturnPackets() to free this packet.
    We return 0 to complete immediately or 1 to pend.

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext, TargetAdapt;
    UINT                PacketSize;
    PNDIS_BUFFER        Buffer;
    PUCHAR              DstAddr, SrcAddr;
    UINT                Size;
    PPACKET_Q_INFO      ppqi;
    INT                 rc;
    BOOLEAN             bForceCopy = FALSE, bFastTrack = FALSE, bIsUnicastToBridge = FALSE,
                        bRequiresCompatWork = FALSE;

    // Paranoia check for incorrectly looped-back packets
    SAFEASSERT( BrdgBufGetPacketOwnership(pPacket) == BrdgNotOwned );

    // Don't receive packets if we are shutting down or this adapter is being torn down or reset
    if ( gShuttingDown || (pAdapt->bResetting) || (! BrdgAcquireAdapter(pAdapt)) )
    {
        return 0;
    }

    NdisQueryPacket(pPacket, NULL, NULL, &Buffer, &PacketSize);
    NdisQueryBufferSafe(Buffer, &DstAddr, &Size, NormalPagePriority);

    if( DstAddr == NULL )
    {
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Must have at least a complete Ethernet header!
    if( Size < ETHERNET_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Packet smaller than Ethernet header seen!\n"));
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Packet can't be larger than the maximum we can handle
    if( Size > MAX_PACKET_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Over-large packet seen!\n"));
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    SrcAddr = DstAddr + ETH_LENGTH_OF_ADDRESS;

#if DBG
    // Break on packets from gBreakMACAddress
    if( gBreakOnMACAddress )
    {
        UINT result;

        ETH_COMPARE_NETWORK_ADDRESSES_EQ( SrcAddr, gBreakMACAddress, &result );

        if( result == 0 )
        {
            KdBreakPoint();
        }
    }
#endif

    //
    // If this is an STA packet, don't process it, but hand it off
    //
    if( BrdgFwdIsSTAGroupAddress(DstAddr) )
    {
        if( (! gDisableSTA) && (DstAddr[5] == STA_MAC_ADDR[5]))
        {
            if (BrdgFwdBridgingNetworks())
            {
                // Hand off this packet for processing
                BrdgSTAReceivePacket( pAdapt, pPacket );
            }
        }

        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Note the MAC address of the frame if this adapter is learning
    if( (pAdapt->State == Learning) || (pAdapt->State == Forwarding) )
    {
        BrdgTblNoteAddress(SrcAddr, pAdapt);
    }

    //
    // Check if we are accepting packets or not
    //
    if( pAdapt->State != Forwarding )
    {
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Look up the target in our table
    TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

    // If the target host is known to be on the same segment as the received
    // packet, there is no need to forward the packet.
    //
    // Also bail out if the target adapter is resetting
    if( (TargetAdapt == pAdapt) ||
        ((TargetAdapt != NULL) && (TargetAdapt->bResetting)) )
    {
        BrdgReleaseAdapter( TargetAdapt );
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Check if the packet will require compatibility-mode processing
    bRequiresCompatWork = BrdgCompRequiresCompatWork( pAdapt, DstAddr, Size );

    // If a packet requires compatibility work, we MUST copy it so the
    // compatibility code has a flat, editable buffer to work with.
    if( bRequiresCompatWork )
    {
        bForceCopy = TRUE;
    }

    // If the packet came in on a compatibility adapter, or is going to
    // a compatibility-mode adapter, but the compatibility code is not
    // interested in it, there is nothing further to be done with the packet.
    if( (pAdapt->bCompatibilityMode || ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)))
            &&
        (! bRequiresCompatWork) )
    {
        if( TargetAdapt != NULL )
        {
            BrdgReleaseAdapter( TargetAdapt );
        }

        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    //
    // If this packet is a unicast packet ONLY for the local machine,
    // we can fast-track it by just passing through the indication to
    // upper-layer protocols.
    //
    // We can't pull this stunt if the packet requires compatibility-mode
    // processing.
    //

    bIsUnicastToBridge = BrdgMiniIsUnicastToBridge(DstAddr);

    if( bIsUnicastToBridge && (!bRequiresCompatWork) )
    {
        NDIS_HANDLE         MiniportHandle;
        BOOLEAN             bRemaining, bRetain;

        if( TargetAdapt != NULL )
        {
            //
            // This indicates that someone else on the network is using our MAC address,
            // or that there is an undetected loop such that we are seeing our own traffic!
            // Either way, this is very bad.
            //
            THROTTLED_DBGPRINT(FWD, ("** Have a table entry for our own MAC address! PROBABLE NET LOOP!\n"));

            // We won't be needing the target adapter
            BrdgReleaseAdapter( TargetAdapt );
            TargetAdapt = NULL;
        }

        MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

        if( MiniportHandle == NULL )
        {
            // Nothing to do with this packet since we don't have a miniport to
            // indicate it with!
            BrdgReleaseAdapter( pAdapt );
            return 0;
        }

        //
        // Figure out if it's possible to fast-track this packet
        //
        NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

        if( bRemaining )
        {
            //
            // We can fast-track right away if the packet queue for this adapter
            // is empty. Otherwise, we would be cutting ahead of other packets from this
            // adapter.
            //
            if( ! pAdapt->bServiceInProgress )
            {
                // We can fast-track this packet right now.

                if( BrdgFwdNoCopyFastTrackReceive(pPacket, pAdapt, MiniportHandle, DstAddr, &bRetain) )
                {
                    // bRetain tells us whether to retain ownership of this packet or not
                    BrdgReleaseAdapter( pAdapt );
                    BrdgMiniReleaseMiniportForIndicate();
                    return bRetain ? 1 : 0;
                }
                else
                {
                    // This should never happen since we checked to see if there was stack room
                    SAFEASSERT( FALSE );

                    bForceCopy = TRUE;
                    bFastTrack = FALSE;
                }
            }
            else
            {
                // We want to fast-track this packet but the processing queue is not
                // empty. Flag it for fast-tracking in the queue draining thread.
                bFastTrack = TRUE;
                bForceCopy = FALSE;
            }
        }
        else
        {
            // Force this packet to be copied into a base packet since
            // we know it can't be fast-tracked.
            bForceCopy = TRUE;
            bFastTrack = FALSE;
        }

        // Allow the miniport to shut down
        BrdgMiniReleaseMiniportForIndicate();
    }

    //
    // We couldn't fast-track the packet. We will have to queue it for processing.
    //

    if( bForceCopy || ((!bFastTrack) && (!gRetainNICPackets)) || (NDIS_GET_PACKET_STATUS(pPacket) == NDIS_STATUS_RESOURCES) )
    {
        // We must copy this packet's data.
        PNDIS_PACKET        pNewPacket;
        PPACKET_INFO        ppi;
        UINT                copied;

        // Get a new copy packet with nothing copied in yet.
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, NULL, NULL, 0, 0, PacketSize, TRUE, pAdapt, NULL );

        if( pNewPacket == NULL )
        {
            // Failed to get a copy packet to hold the data.
            goto failure;
        }

        SAFEASSERT( ppi != NULL );

        // Copy data out of the old packet into the new one
        NdisCopyFromPacketToPacket( pNewPacket, 0, PacketSize, pPacket, 0, &copied );

        if( copied != PacketSize )
        {
            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }

        // Queue the new base packet for processing
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;
        ppqi->pInfo = ppi;
        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->Flags.bIsSTAPacket = FALSE;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        // The NIC gets its packet back immediately since we copied its data
        rc = 0;
    }
    else
    {
        // Queue the original packet for processing
        ppqi = (PPACKET_Q_INFO)&pPacket->ProtocolReserved;
        ppqi->pInfo = NULL;
        ppqi->Flags.bIsSTAPacket = FALSE;
        ppqi->Flags.bIsUnicastToBridge = bIsUnicastToBridge;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bFastTrack )
        {
            SAFEASSERT( bIsUnicastToBridge );
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bFastTrackReceive = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
            ppqi->u.pOriginalAdapt = pAdapt;
        }
        else
        {
            ppqi->Flags.bFastTrackReceive = FALSE;
            ppqi->u.pTargetAdapt = TargetAdapt;

            if( bIsUnicastToBridge )
            {
                SAFEASSERT( TargetAdapt == NULL );
                ppqi->Flags.bShouldIndicate = TRUE;
            }
            else
            {
                ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
            }
        }

        // We require the use of the packet until our processing is complete
        rc = 1;
    }

    // Queue the packet for processing
    BrdgFwdQueuePacket( ppqi, pAdapt );

    BrdgReleaseAdapter( pAdapt );
    return rc;

failure:
    if( TargetAdapt != NULL )
    {
        BrdgReleaseAdapter( TargetAdapt );
    }

    if( BrdgMiniShouldIndicatePacket(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
    }

    BrdgReleaseAdapter( pAdapt );

    // We are done with this packet
    return 0;
}

NDIS_STATUS
BrdgFwdSendPacket(
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    Called to handle the transmission of a packet from an overlying protocol

Arguments:

    pPacket             The packet to send

Return Value:

    Status of the send (NDIS_STATUS_PENDING means the send will be completed later)

--*/
{
    PNDIS_BUFFER        Buffer;
    PUCHAR              DstAddr;
    UINT                Size;
    PADAPT              TargetAdapt;
    BOOLEAN             bRemaining;
    NDIS_STATUS         Status;
    PNDIS_PACKET_STACK  pStack;

    NdisQueryPacket(pPacket, NULL, NULL, &Buffer, NULL);
    NdisQueryBufferSafe(Buffer, &DstAddr, &Size, NormalPagePriority);

    if( DstAddr == NULL )
    {
        return NDIS_STATUS_RESOURCES;
    }

    //
    // See if we know the adapter to reach the target through
    //
    TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

    // Fail silently if the target adapter is resetting
    if( (TargetAdapt != NULL) && (TargetAdapt->bResetting) )
    {
        BrdgReleaseAdapter( TargetAdapt );
        return NDIS_STATUS_SUCCESS;
    }

    // Do compatibility processing, unless the packet is going to
    // a known target that isn't on a compatibility adapter (in
    // which case no compatibility processing is required).
    if( (TargetAdapt == NULL) || (TargetAdapt->bCompatibilityMode) )
    {
        BrdgCompProcessOutboundPacket( pPacket, TargetAdapt );
    }

    // If the target adapter is in compatibility-mode, no processing
    // other than the compatibility processing is required.
    if( (TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode) )
    {
        // We're done with this packet!
        BrdgReleaseAdapter( TargetAdapt );
        return NDIS_STATUS_SUCCESS;
    }

    //
    // We can fast-track the packet if there is an NDIS stack slot available
    // for use and there is a single target adapter to send on.
    //
    pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

    if( (TargetAdapt != NULL) && bRemaining && (pStack != NULL) )
    {
        // We fiddle with some of the packet flags when sending a packet. Remember the
        // state of the flags we change so we can restore them before handing back the
        // packet when the send completes.
        *((PUINT)(pStack->IMReserved)) = NdisGetPacketFlags(pPacket) & CHANGED_PACKET_FLAGS;

        // Just fast-track it out the target adapter
        BrdgFwdSendOnLink( TargetAdapt, pPacket );

        // Done with the adapter pointer
        BrdgReleaseAdapter( TargetAdapt );

        // We retain the buffers until we're done
        return NDIS_STATUS_PENDING;
    }

    //
    // Can't fast-track for whatever reason. We need to take the slow path through BrdgFwdHandlePacket
    //
    Status = BrdgFwdHandlePacket( BrdgPacketOutbound, TargetAdapt, NULL /* No source adapter */, FALSE /* Do not indicate */,
                                  NULL /*No miniport handle because no indication*/, NULL, NULL, /*No base packet yet*/
                                  BrdgFwdMakeSendBasePacket, pPacket, NULL, 0, 0 );

    if( TargetAdapt != NULL )
    {
        // We're done with this adapter pointer
        BrdgReleaseAdapter( TargetAdapt );
    }

    return Status;
}

VOID
BrdgFwdCleanupPacket(
    IN  PADAPT              pAdapt,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    NDIS entry point called when a packet transmission has completed

Arguments:

    ProtocolBindingContext  The adapter on which the packet was send
    pPacket                 The transmitted packet
    Status                  The status of the send

Return Value:

    None

--*/
{
    PACKET_OWNERSHIP        Own;

    // Find out whether we own this packet
    Own = BrdgBufGetPacketOwnership(pPacket);

    if( Own == BrdgNotOwned )
    {
        NDIS_HANDLE             MiniportHandle;
        PNDIS_PACKET_STACK      pStack;
        BOOLEAN                 bRemaining;

        // This packet must have been a fast-track send. Return it to
        // its upper-layer owner.

        // Restore the flags that we change on a packet send by retrieving the
        // stored state of these flags that we stashed in IMReserved in
        // BrdgFwdSendPacket.
        pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

        if( (pStack != NULL) && bRemaining )
        {
            NdisClearPacketFlags( pPacket, CHANGED_PACKET_FLAGS );
            NdisSetPacketFlags( pPacket, *((PUINT)(pStack->IMReserved)) );
        }
        else
        {
            // There was stack room on the way down so this shouldn't happen.
            SAFEASSERT( FALSE );
        }

        if( Status == NDIS_STATUS_SUCCESS )
        {
            PVOID               pHeader = BrdgBufGetPacketHeader(pPacket);

            if( pHeader != NULL )
            {
                BrdgFwdCountTransmittedPacket( pAdapt, pHeader, BrdgBufTotalPacketSize(pPacket) );
            }
            // pHeader can only be NULL under heavy system stress
        }
        else
        {
            ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
        }

        // NDIS should prevent the miniport from shutting down while
        // there is still a send pending.
        MiniportHandle = BrdgMiniAcquireMiniport();
        SAFEASSERT( MiniportHandle != NULL );
        NdisMSendComplete( MiniportHandle, pPacket, Status );
        BrdgMiniReleaseMiniport();
    }
    else
    {
        //
        // We allocated this packet ourselves.
        //

        // Recover the info pointer from our reserved area in the packet header
        PPACKET_INFO        ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved),
                            baseppi;
        PNDIS_PACKET        pBasePacket;

        if( ppi->Flags.bIsBasePacket == FALSE )
        {
            // This packet is using buffers from another packet.
            baseppi = ppi->u.pBasePacketInfo;
            SAFEASSERT( baseppi != NULL );
            pBasePacket = baseppi->pOwnerPacket;
            SAFEASSERT( pBasePacket != NULL );
        }
        else
        {
            // This packet tracks its own buffers.
            pBasePacket = pPacket;
            baseppi = ppi;
        }

        // Contribute to the composite status of this packet
        if( Status == NDIS_STATUS_SUCCESS )
        {
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_SUCCESS;
        }

        {
            UCHAR               DstAddr[ETH_LENGTH_OF_ADDRESS];
            UINT                PacketSize;
            PVOID               pHeader = BrdgBufGetPacketHeader(pBasePacket);
            NDIS_STATUS         PacketStatus;
            PACKET_DIRECTION    PacketDirection;

            // Pull out some information before we try to free the packet
            if( pHeader != NULL )
            {
                ETH_COPY_NETWORK_ADDRESS( DstAddr, pHeader );
            }
            // pHeader can only == NULL under heavy system stress

            PacketStatus = baseppi->u.BasePacketInfo.CompositeStatus;
            PacketDirection = baseppi->Flags.OriginalDirection;
            BrdgFwdValidatePacketDirection( PacketDirection );
            PacketSize = BrdgBufTotalPacketSize(pBasePacket);

            // Now deref the packet
            if( BrdgFwdDerefBasePacket( pAdapt, pBasePacket, baseppi, PacketStatus ) )
            {
                // The base packet was freed. Now ILLEGAL to reference pHeader, baseppi or pBasepacket

                if( PacketDirection == BrdgPacketOutbound )
                {
                    // This was a local-source packet.
                    if( PacketStatus == NDIS_STATUS_SUCCESS )
                    {
                        if( pHeader != NULL )
                        {
                            BrdgFwdCountTransmittedPacket( pAdapt, DstAddr, PacketSize );
                        }
                    }
                    else
                    {
                        ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
                    }
                }
                else
                {
                    // This was a relayed packet.
                    ExInterlockedAddLargeStatistic( &pAdapt->SentFrames, 1L );
                    ExInterlockedAddLargeStatistic( &pAdapt->SentBytes, PacketSize );
                }
            }
        }

        if( pBasePacket != pPacket )
        {
            // Owned copy packets are always base packets, so this should be a no-copy packet.
            SAFEASSERT( Own == BrdgOwnWrapperPacket );
            BrdgFwdFreeWrapperPacket( pPacket, ppi, pAdapt );
        }
    }
}



VOID
BrdgFwdSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    NDIS entry point called when a packet transmission has completed

Arguments:

    ProtocolBindingContext  The adapter on which the packet was send
    pPacket                 The transmitted packet
    Status                  The status of the send

Return Value:

    None

--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;

    SAFEASSERT( pAdapt != NULL );

    if (pAdapt)
    {
        if( Status != NDIS_STATUS_SUCCESS )
        {
            THROTTLED_DBGPRINT(FWD, ("Packet send failed with %08x\n", Status));
        }
    
        BrdgFwdCleanupPacket(pAdapt, pPacket, Status);

        BrdgDecrementWaitRef(&pAdapt->Refcount);
    }
}


VOID
BrdgFwdReturnIndicatedPacket(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    NDIS entry point called when a packet indication has completed

Arguments:

    MiniportAdapterContext  Ignored
    pPacket                 The transmitted packet

Return Value:

    None

--*/
{
    PACKET_OWNERSHIP    Own;

    // Find out whether we own this packet
    Own = BrdgBufGetPacketOwnership(pPacket);

    if( Own == BrdgNotOwned )
    {
        // This packet must have been a fast-track receive. Return it to
        // its lower-layer owner.
        BOOLEAN                 bRemaining;
        PNDIS_PACKET_STACK      pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);
        PADAPT                  pOwnerAdapt;

        // If we fast-tracked this packet, it MUST have had room for us to stash our
        // pointer to the owning adapter
        SAFEASSERT( pStack != NULL );
        SAFEASSERT( bRemaining );

        // We incremented the owning adapter's refcount when we first received the packet
        pOwnerAdapt = (PADAPT)pStack->IMReserved[0];
        SAFEASSERT( pOwnerAdapt != NULL );

        // Here you go
        NdisReturnPackets( &pPacket, 1 );

        // Release the owning NIC after the packet release
        BrdgReleaseAdapter( pOwnerAdapt );

        // Illegal to refer to pPacket now
        pPacket = NULL;
    }
    else
    {
        // Recover our packet info block from our reserved area in the packet header
        PPACKET_INFO        ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);

        // Indications are always made with the base packet
        SAFEASSERT( ppi->Flags.bIsBasePacket );

        // Let go of the base packet
        BrdgFwdDerefBasePacket( LOCAL_MINIPORT, pPacket, ppi, ppi->u.BasePacketInfo.CompositeStatus );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgFwdServiceQueue(
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Services the inbound packet queue of a particular adapter

    This routine raises IRQL to DISPATCH to service the queue. It will
    service up to MAX_PACKETS_AT_DPC packets at DISPATCH and then
    return, even if the adapter's queue has not been drained.

    The bServiceInProgress flag is cleared if this routine manages to
    drain the adapter's queue. If the queue is non-empty when the
    routine exits, the bServiceInProgress flag is left set.

Arguments:

    pAdapt                  The adapter to service

Return Value:

    TRUE == the adapter's queue was drained FALSE == there are still queued
    packets to be serviced in the adapter's queue.

--*/
{
    PPACKET_Q_INFO          pqi;
    NDIS_HANDLE             MiniportHandle = NULL;
    KIRQL                   oldIrql;
    ULONG                   HandledPackets = 0L;
    BOOLEAN                 bQueueWasEmptied;

    SAFEASSERT( pAdapt != NULL );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    // We should only be scheduled when there's something to deal with
    SAFEASSERT( BrdgQuerySingleListLength(&pAdapt->Queue) > 0 );
    SAFEASSERT( pAdapt->bServiceInProgress );

    // Get a handle on the miniport for the entire function duration
    MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

    //
    // The queue lock protects bServiceInProgress as well. Use it to dequeue
    // packets and update the flag atomically.
    //
    NdisDprAcquireSpinLock( &pAdapt->QueueLock);

    pqi = (PPACKET_Q_INFO)BrdgRemoveHeadSingleList(&pAdapt->Queue);

    while( pqi != NULL )
    {
        PNDIS_PACKET        pPacket;
        PADAPT              TargetAdapt = NULL, OriginalAdapt = NULL;

        //
        // QueueRefcount reflects the number of elements in the processing queue
        // so people can block on it becoming empty
        //
        BrdgDecrementWaitRef( &pAdapt->QueueRefcount );
        SAFEASSERT( (ULONG)pAdapt->QueueRefcount.Refcount == pAdapt->Queue.Length );

        NdisDprReleaseSpinLock( &pAdapt->QueueLock );

        // Demultiplex the union
        if( pqi->Flags.bFastTrackReceive )
        {
            OriginalAdapt = pqi->u.pOriginalAdapt;
        }
        else
        {
            TargetAdapt = pqi->u.pTargetAdapt;
        }

        // Recover the packet pointer from the ProtocolReserved offset
        pPacket = CONTAINING_RECORD(pqi, NDIS_PACKET, ProtocolReserved);

        // Deal with this packet
        if( pqi->pInfo != NULL )
        {
            if( pqi->Flags.bIsSTAPacket )
            {
                if( ! gDisableSTA && BrdgFwdBridgingNetworks() )
                {
                    // Hand this packet off to the STA code
                    BrdgSTAReceivePacket( pAdapt, pPacket );
                }

                // We're done with this packet
                BrdgFwdReleaseBasePacket( pPacket, pqi->pInfo, BrdgBufGetPacketOwnership(pPacket),
                                          NDIS_STATUS_SUCCESS );

                // It is an error to use any of these variables now
                pPacket = NULL;
                pqi = NULL;
            }
            else
            {
                BOOLEAN         bShouldIndicate = pqi->Flags.bShouldIndicate,
                                bIsUnicastToBridge = pqi->Flags.bIsUnicastToBridge,
                                bRequiresCompatWork = pqi->Flags.bRequiresCompatWork,
                                bCompatOnly;
                NDIS_STATUS     Status;
                PPACKET_INFO    ppi = pqi->pInfo;
                BOOLEAN         bRetained = FALSE;

                //
                // This is an already-wrapped packet from the copy path.
                //
                SAFEASSERT( ! pqi->Flags.bFastTrackReceive );

                // Before passing this packet along for processing, we must put a pointer to the packet's
                // info block back into its MiniportReserved and ProtocolReserved areas so completion
                // routines can recover the info block.
                //
                SAFEASSERT( ppi->pOwnerPacket == pPacket );
                *((PPACKET_INFO*)pPacket->ProtocolReserved) = ppi;
                *((PPACKET_INFO*)pPacket->MiniportReserved) = ppi;

                // It is an error to use pqi anymore since it points into the ProtocolReserved area
                pqi = NULL;

                // If this packet arrived on a compatibility adapter or is bound for a
                // compatibility adapter, only compatibility-mode work is required.
                bCompatOnly = (BOOLEAN)((pAdapt->bCompatibilityMode) ||
                              ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)));

                // Do compatibility work first if required
                if( bRequiresCompatWork )
                {
                    bRetained = BrdgCompProcessInboundPacket( pPacket, pAdapt, bCompatOnly );
                    Status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    // Packet shouldn't have gotten here if there's nothing to do with it
                    SAFEASSERT( ! bCompatOnly );
                    bRetained = FALSE;
                    Status = NDIS_STATUS_SUCCESS;
                }

                if( ! bCompatOnly )
                {
                    // We told the compatibility module not to retain the packet
                    SAFEASSERT( ! bRetained );

                    if( bIsUnicastToBridge )
                    {
                        SAFEASSERT( TargetAdapt == NULL );
                        bRetained = FALSE;
                        Status = NDIS_STATUS_FAILURE;

                        if( MiniportHandle != NULL )
                        {
                            if( BrdgBufAssignBasePacketQuota(pPacket, LOCAL_MINIPORT) )
                            {
                                // Do fixups usually done in BrdgFwdHandlePacket
                                ppi->u.BasePacketInfo.RefCount = 1L;
                                ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

                                // Indicate the packet up
                                BrdgFwdIndicatePacket( pPacket, MiniportHandle );
                                bRetained = TRUE;
                            }
                            else
                            {
                                THROTTLED_DBGPRINT(FWD, ("Local miniport over quota on queued receive!\n"));
                            }
                        }
                    }
                    else
                    {
                        // Hand off this packet for general processing
                        Status = BrdgFwdHandlePacket( BrdgPacketInbound, TargetAdapt, pAdapt, bShouldIndicate,
                                                      MiniportHandle, pPacket, ppi, NULL, NULL, NULL, 0, 0 );

                        if( Status == NDIS_STATUS_PENDING )
                        {
                            bRetained = TRUE;
                        }
                        else
                        {
                            // The base packet we previously created was not actually used by BrdgFwdHandlePacket.
                            bRetained = FALSE;
                        }
                    }
                }

                // If our processing did not retain the packet for later release, release it now.
                if( ! bRetained )
                {
                    BrdgFwdReleaseBasePacket( pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), Status );
                }
            }
        }
        else
        {
            // Can't have unwrapped STA packets
            SAFEASSERT( ! pqi->Flags.bIsSTAPacket );

            // Can't have unwrapped packets for compatibility processing
            SAFEASSERT( ! pqi->Flags.bRequiresCompatWork );

            // Packet should not be here (unwrapped) if it arrived from a compatibility-mode
            // adapter.
            SAFEASSERT( ! pAdapt->bCompatibilityMode );

            // BrdgFwdReceivePacket should copy unicast packets that can't be fast-tracked
            // into base packets before queuing them; we shouldn't end up with unwrapped
            // packets that are unicast to the bridge but aren't tagged for fast-tracking.
            if( pqi->Flags.bIsUnicastToBridge )
            {
                SAFEASSERT( pqi->Flags.bFastTrackReceive );
            }

            if( pqi->Flags.bFastTrackReceive )
            {
                BOOLEAN     bRetained = FALSE;

                SAFEASSERT( pqi->Flags.bIsUnicastToBridge );

                if( MiniportHandle != NULL )
                {
                    PUCHAR      DstAddr = BrdgBufGetPacketHeader(pPacket);

                    if( DstAddr != NULL )
                    {
                        // This is unicast to the bridge only; we are asked to try to fast-track it straight up to
                        // overlying protocols.
                        if( BrdgFwdNoCopyFastTrackReceive(pPacket, OriginalAdapt, MiniportHandle, DstAddr, &bRetained ) )
                        {
                            // We had better be able to retain ownership of the original packet because we've already
                            // hung on to it past the return of FwdReceivePacket!
                            SAFEASSERT( bRetained );
                        }
                        else
                        {
                            // BrdgFwdReceivePacket is supposed to make sure packets can be fast-tracked
                            // before queuing them up
                            SAFEASSERT( FALSE );
                        }
                    }
                    // DstAddr can only == NULL under heavy system stress
                }

                if( !bRetained )
                {
                    // Error of some sort or the miniport isn't available for indications. Ditch the packet.
                    NdisReturnPackets( &pPacket, 1 );

                    // Illegal to refer to the packet now
                    pPacket = NULL;
                }
            }
            else
            {
                NDIS_STATUS     Status;

                // Packet should not be here (unwrapped) if it is bound for a compatibility-mode adapter.
                SAFEASSERT( ! TargetAdapt->bCompatibilityMode );

                // This is not a packet unicast to the bridge. Do the more general processing.
                Status = BrdgFwdHandlePacket( BrdgPacketInbound, TargetAdapt, pAdapt, pqi->Flags.bShouldIndicate,
                                              MiniportHandle, NULL, NULL, BrdgFwdMakeNoCopyBasePacket, pPacket, pAdapt, 0, 0 );

                if( Status != NDIS_STATUS_PENDING )
                {
                    // The unwrapped packet from the underlying NIC was not used. Release it now.
                    NdisReturnPackets( &pPacket, 1 );

                    // Illegal to refer to the packet now
                    pPacket = NULL;
                }
            }
        }

        // Release the target adapter if there was one
        if( TargetAdapt )
        {
            BrdgReleaseAdapter( TargetAdapt );
        }

        // Acquire the spin lock before either exiting or grabbing the next packet
        NdisDprAcquireSpinLock( &pAdapt->QueueLock );

        // If we've processed too many packets, bail out even if the queue is not empty
        HandledPackets++;

        if( HandledPackets >= MAX_PACKETS_AT_DPC )
        {
            break;
        }

        // Get the next packet off the queue
        pqi = (PPACKET_Q_INFO)BrdgRemoveHeadSingleList(&pAdapt->Queue);
    }

    //
    // Clear bServiceInProgress only if we emptied the queue. Otherwise, leave it set to
    // prevent spurious signalling of the QueueEvent, which would cause more than one
    // draining thread to service the same queue!
    //
    if( BrdgQuerySingleListLength(&pAdapt->Queue) == 0L )
    {
        bQueueWasEmptied = TRUE;
        pAdapt->bServiceInProgress = FALSE;
    }
    else
    {
        bQueueWasEmptied = FALSE;
    }

    NdisDprReleaseSpinLock( &pAdapt->QueueLock );

    // Let go of the miniport until next time
    if( MiniportHandle != NULL )
    {
        BrdgMiniReleaseMiniportForIndicate();
    }

    KeLowerIrql(oldIrql);

    return bQueueWasEmptied;
}

VOID
BrdgFwdProcessQueuedPackets(
    IN PVOID                Param1
    )
/*++

Routine Description:

    Per-adapter inbound packet queue draining function

    There is one instance of this function running per processor.
    This routine sleeps until there is work to be done, and then calls
    BrdgFwdServiceQueue to service whichever adapter needs attention.
    It does this by blocking against the QueueEvent object for each
    adapter's queue, as well as the global gKillThreads and the
    gThreadsCheckAdapters event for this processor.

    When the block returns, there is an event needing attention; it
    may be the fact that the thread has been signaled to exit, that
    this thread is supposed to re-enumerate adapters, or that an
    adapter needs its inbound queue serviced.

    This routine increments the refcount of every adapter that it
    sleeps against; the gThreadsCheckAdapters event causes the thread
    to re-examine the adapter list and release its refcount on any
    adapters that were removed (or notice new additions).

    Must be called at < DISPATCH_LEVEL since we wait on an event

Arguments:

    Param1              The processor on which we should execute
                        (is not necessarily the processor on which
                        we are first scheduled)

Return Value:

    None

--*/
{
    // Double cast to tell the IA64 compiler we really mean to truncate
    UINT                Processor = (UINT)(ULONG_PTR)Param1;
    PVOID               WaitObjects[MAXIMUM_WAIT_OBJECTS];
    KWAIT_BLOCK         WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    ULONG               numWaitObjects;
    BOOLEAN             bDie = FALSE;
    PVOID               pThread = KeGetCurrentThread();

    // Constants
    const ULONG         KILL_EVENT = 0L, CHECK_EVENT = 1L;

    DBGPRINT(FWD, ("Spinning up a thread on processor %i\n", Processor));

    // Elevate our priority
    KeSetPriorityThread(pThread, LOW_REALTIME_PRIORITY);

    // Attach ourselves to our designated processor
    KeSetAffinityThread(pThread, (KAFFINITY)(1<<Processor));

    // Start off waiting against just the kill event and the re-enumerate event.
    WaitObjects[KILL_EVENT] = &gKillThreads;
    WaitObjects[CHECK_EVENT] = &gThreadsCheckAdapters[Processor];
    numWaitObjects = 2L;

    while( ! bDie )
    {
        NTSTATUS        Status;
        ULONG           firedObject;

        //
        // Block until we are told to exit, re-enumerate, or until a processor's
        // queue signals that it needs servicing.
        //
        SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
        Status = KeWaitForMultipleObjects( numWaitObjects, WaitObjects, WaitAny, Executive,
                                           KernelMode, FALSE, NULL, WaitBlocks );

        if( ! NT_SUCCESS(Status) )
        {
            // This really shouldn't happen
            DBGPRINT(FWD, ("KeWaitForMultipleObjects failed! %08x\n", Status));
            SAFEASSERT(FALSE);

            // Pretend this was a signal to exit
            firedObject = KILL_EVENT;
        }
        else
        {
            firedObject = (ULONG)Status - (ULONG)STATUS_WAIT_0;
        }

        if( firedObject == KILL_EVENT )
        {
            // We are asked to exit.
            DBGPRINT(FWD, ("Exiting queue servicing thread on processor %i\n", Processor));
            bDie = TRUE;
        }
        else if( firedObject == CHECK_EVENT )
        {
            LOCK_STATE      LockState;
            UINT            i;
            PADAPT          pAdapt;

            DBGPRINT(FWD, ("Re-enumerating adapters on processor %i\n", Processor));

            // We must re-enumerate the list of adapters. First decrement the refcount on any
            // adapters we're already holding
            for( i = 2; i < numWaitObjects; i++ )
            {
                pAdapt = CONTAINING_RECORD( WaitObjects[i], ADAPT, QueueEvent );
                BrdgReleaseAdapter( pAdapt );
            }

            numWaitObjects = 2;

            // Now walk the adapter list and retrieve a pointer to each one's queue event.
            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                // We will be using this adapter outside the list lock
                BrdgAcquireAdapterInLock(pAdapt);
                WaitObjects[numWaitObjects] = &pAdapt->QueueEvent;
                numWaitObjects++;
            }

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
        }
        else
        {
            // An adapter needs queue servicing.
            PADAPT      pAdapt = CONTAINING_RECORD( WaitObjects[firedObject], ADAPT, QueueEvent );

            if( ! BrdgFwdServiceQueue( pAdapt ) )
            {
                // The adapter's queue was serviced but not emptied. Signal the queue event so
                // someone (maybe us!) will be scheduled to service the queue
                KeSetEvent( &pAdapt->QueueEvent, EVENT_INCREMENT, FALSE );
            }
        }
    }

    // Shoot ourselves in the head
    PsTerminateSystemThread( STATUS_SUCCESS );
}

PNDIS_PACKET
BrdgFwdMakeSendBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Passed as a parameter to BrdgFwdHandlePacket and called back as necessary

    Builds a base packet from a packet outbound from overlying protocols

Arguments:

    pppi                    The info block of the new base packet or NULL if the
                            allocation failed

    Target                  The adapter to "charge" the new base packet to
    Param1                  The outbound packet
    Param2 - Param4         Unused

Return Value:

    The new base packet or NULL if the allocation failed (usually because the
    target adapter didn't pass quota)

--*/
{
    PNDIS_PACKET            pPacket = (PNDIS_PACKET)Param1;
    PNDIS_PACKET            pNewPacket;

    SAFEASSERT( pPacket != NULL );

    // Get a wrapper packet to be the base packet
    pNewPacket = BrdgFwdAllocAndWrapPacketForSend( pPacket, pppi, Target );

    if( pNewPacket == NULL )
    {
        // We didn't pass quota for this target
        return NULL;
    }

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)pNewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)pNewPacket->MiniportReserved) = *pppi;

    SAFEASSERT( *pppi != NULL );
    (*pppi)->u.BasePacketInfo.pOriginalPacket = pPacket;
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = NULL;
    (*pppi)->Flags.OriginalDirection = BrdgPacketOutbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Signal that the underlying NIC can hang on to the buffers
    NDIS_SET_PACKET_STATUS( pNewPacket, NDIS_STATUS_SUCCESS );

    return pNewPacket;
}

PNDIS_PACKET
BrdgFwdMakeNoCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Passed as a parameter to BrdgFwdHandlePacket and called back as necessary

    Builds a new base packet from a packet received on the no-copy path

Arguments:

    pppi                    The info block for the new packet or NULL if the alloc
                            failed

    Target                  The adapter to "charge" the new packet to
    Param1                  The originally indicated packet descriptor
    Param2                  The adapter on which the packet was received
    Param3, Param4          Unused

Return Value:

    A new base packet or NULL if the allocation failed (usually because the
    target adapter did not pass quota)

--*/
{
    PNDIS_PACKET            pPacket = (PNDIS_PACKET)Param1;
    PADAPT                  pOwnerAdapt = (PADAPT)Param2;
    PNDIS_PACKET            NewPacket;

    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( pOwnerAdapt != NULL );

    // Get a new wrapper packet
    NewPacket = BrdgFwdAllocAndWrapPacketForReceive( pPacket, pppi, Target );

    if (NewPacket == NULL)
    {
        // We didn't pass quota for this target
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)NewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)NewPacket->MiniportReserved) = *pppi;

    //
    // We must ensure that the adapter we just got this packet from is not unbound until we are
    // done with its packet. Bump the adapter's refcount here. The adapter's refcount will be
    // decremented again when this base packet is freed.
    //
    BrdgReacquireAdapter( pOwnerAdapt );
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = pOwnerAdapt;

    (*pppi)->u.BasePacketInfo.pOriginalPacket = pPacket;
    (*pppi)->Flags.OriginalDirection = BrdgPacketInbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Make sure the packet indicates that it's OK to hang on to buffers
    NDIS_SET_PACKET_STATUS( NewPacket, NDIS_STATUS_SUCCESS );

    // Count this packet as received
    ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatReceivedBytes, BrdgBufTotalPacketSize(pPacket) );
    ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyBytes, BrdgBufTotalPacketSize(pPacket) );

    ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedFrames, 1L );
    ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedBytes, BrdgBufTotalPacketSize(pPacket) );

    return NewPacket;
}

PNDIS_PACKET
BrdgFwdMakeCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PVOID                pHeader,
    IN PVOID                pData,
    IN UINT                 HeaderSize,
    IN UINT                 DataSize,
    IN UINT                 SizeOfPacket,
    IN BOOLEAN              bCountAsReceived,
    IN PADAPT               pOwnerAdapt,
    PVOID                   *ppBuf
    )
/*++

Routine Description:

    Builds a new copy packet to hold inbound data on the copy path or on the
    no-copy path if a packet arrives with STATUS_RESOURCES.

    The new packet has NO ATTRIBUTED QUOTA to any adapter. This is because
    at the time of the initial receive, a target adapter is not yet known
    and the inbound data must be wrapped in a copy packet to be queued for
    processing.

    The cost of the base packet is assigned to target adapters as it is
    processed in the queue-draining thread.

Arguments:

    pppi                    Output of the new info block associated with the
                            new packet (NULL if alloc failed)

    pHeader                 Pointer to the header buffer originally indicated
                            Can be NULL to not copy the header

    pData                   Pointer to the data buffer originally indicated
                            Can be NULL to not copy the data buffer

    HeaderSize              Size of the header buffer
    DataSize                Size of the data buffer

    SizeOfPacket            Size to set the packet's buffer to. Can be different
                            from HeaderSize+DataSize if the caller plans to
                            copy more data in later

    bCountAsReceived        Whether to count this packet as received

    pOwnerAdapt             Adapter this packet was received on (purely for
                            statistics purposes). Can be NULL if bCountAsReceived == FALSE

    ppBuf                   (optionally) receives a pointer to the data buffer
                            of the freshly allocated packet

Return Value:

    A new base packet or NULL if the allocation failed

--*/
{
    PNDIS_PACKET            NewPacket;
    PNDIS_BUFFER            pBuffer;
    PVOID                   pvBuf;
    UINT                    bufLength;

    // Get a copy packet to carry the data
    NewPacket = BrdgBufGetBaseCopyPacket( pppi );

    if (NewPacket == NULL)
    {
        // Our copy packet pool is full!
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Get a pointer to the preallocated buffer in this packet
    pBuffer = BrdgBufPacketHeadBuffer(NewPacket);
    SAFEASSERT( pBuffer != NULL );
    NdisQueryBufferSafe( pBuffer, &pvBuf, &bufLength, NormalPagePriority );

    if( pvBuf == NULL )
    {
        // This shouldn't be possible because the data buffer should have been
        // alloced from kernel space
        SAFEASSERT(FALSE);
        BrdgBufFreeBaseCopyPacket( NewPacket, *pppi );
        *pppi = NULL;
        return NULL;
    }

    SAFEASSERT( bufLength == MAX_PACKET_SIZE );

    if( ppBuf != NULL )
    {
        *ppBuf = pvBuf;
    }

    // Copy the packet data into our own preallocated buffers
    if( pHeader != NULL )
    {
        NdisMoveMemory(pvBuf, pHeader, HeaderSize);
    }
    else
    {
        SAFEASSERT( HeaderSize == 0 );
    }

    if( pData != NULL )
    {
        NdisMoveMemory((PUCHAR)pvBuf + HeaderSize, pData, DataSize);
    }
    else
    {
        SAFEASSERT( DataSize == 0 );
    }

    // Tweak the size of the buffer so it looks like the right length
    NdisAdjustBufferLength(pBuffer, SizeOfPacket);

    (*pppi)->u.BasePacketInfo.pOriginalPacket = NULL;
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = NULL;
    (*pppi)->Flags.OriginalDirection = BrdgPacketInbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Make the header size correct
    NDIS_SET_PACKET_HEADER_SIZE(NewPacket, ETHERNET_HEADER_SIZE);

    // Indicate that upper-layer protocols can hang on to these buffers
    NDIS_SET_PACKET_STATUS( NewPacket, NDIS_STATUS_SUCCESS );

    // Count this packet as received
    if( bCountAsReceived )
    {
        ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedBytes, SizeOfPacket );
        ExInterlockedAddLargeStatistic( &gStatReceivedCopyFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedCopyBytes, SizeOfPacket );

        SAFEASSERT( pOwnerAdapt != NULL );
        ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedBytes, SizeOfPacket );
    }

    return NewPacket;
}

VOID
BrdgFwdSendOnLink(
    IN  PADAPT          pAdapt,
    IN  PNDIS_PACKET    pPacket
    )
/*++

Routine Description:

    Sends a packet to a particular adapter

Arguments:

    pAdapt              The adapter to send to
    pPacket             The packet to send

Return Value:

    None

--*/
{
    PPACKET_INFO ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);
    PACKET_DIRECTION PacketDirection = BrdgPacketImpossible;
    BOOLEAN Bridging = BrdgFwdBridgingNetworks();
    BOOLEAN Incremented = FALSE;

    // Make sure this doesn't loop back
    NdisClearPacketFlags( pPacket, NDIS_FLAGS_LOOPBACK_ONLY );
    NdisSetPacketFlags( pPacket, NDIS_FLAGS_DONT_LOOPBACK );
    
    //
    // Logic is like this:
    // If the packet is an Outbound packet then we send it.
    // If the packet has been created in the bridge, then we check
    // the base packet to see if it is outbound, if it is then we send the packet.
    //

    if (!Bridging)
    {
        if (!ppi)
        {
            ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
        }

        if (ppi)
        {
            if (((ppi->Flags.OriginalDirection == BrdgPacketOutbound) || 
                ((ppi->Flags.OriginalDirection == BrdgPacketCreatedInBridge) && 
                 (ppi->u.pBasePacketInfo != NULL && 
                  ppi->u.pBasePacketInfo->Flags.OriginalDirection == BrdgPacketOutbound)
                )
                )
               )
            {
                PacketDirection = BrdgPacketOutbound;
            }
        }
#if DBG
        else
        {
            if (gBreakIfNullPPI)
            {
                KdBreakPoint();
            }
        }
#endif // DBG
    }
    
    Incremented = BrdgIncrementWaitRef(&pAdapt->Refcount);

    if (Incremented && 
        (PacketDirection == BrdgPacketOutbound || Bridging))
    {

#if DBG
        if (gPrintPacketTypes)
        {
            if (PacketDirection == BrdgPacketOutbound)
            {
                THROTTLED_DBGPRINT(FWD, ("Sending Outbound packet\r\n"));
            }
            else
            {
                THROTTLED_DBGPRINT(FWD, ("Forwarding packet\r\n"));
            }
        }
#endif // DBG

        // Send!
        NdisSendPackets( pAdapt->BindingHandle, &pPacket, 1 );
    }
    else
    {

#if DBG
        if (Bridging && gPrintPacketTypes)
        {
            THROTTLED_DBGPRINT(FWD, ("Not allowed to send packet\r\n"));
        }
#endif // DBG
        
        //
        // We incremented this, but we're not going to be going through any path that
        // decrements this, so we need to do this here.
        //
        if (Incremented)
        {
            BrdgDecrementWaitRef(&pAdapt->Refcount);
        }

        BrdgFwdCleanupPacket(pAdapt, pPacket, NDIS_STATUS_CLOSING);
    }
}

VOID
BrdgFwdReleaseBasePacket(
    IN PNDIS_PACKET         pPacket,
    PPACKET_INFO            ppi,
    IN PACKET_OWNERSHIP     Own,
    IN NDIS_STATUS          Status
    )
/*++

Routine Description:

    Frees a base packet. Called when a base packet's refcount reaches zero.

Arguments:

    pPacket                 The base packet to free
    ppi                     The packet's info block
    Own                     The result of a call to BrdgBufGetPacketOwnership(pPacket)

    Status                  The status to be returned to the entity owning the
                            original packet wrapped by the base packet (if any)

Return Value:

    None

--*/
{
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    if( Own == BrdgOwnCopyPacket )
    {
        // This packet was allocated to wrap copied buffers. Free it back to our pool.
        BrdgFwdValidatePacketDirection( ppi->Flags.OriginalDirection );
        BrdgBufFreeBaseCopyPacket( pPacket, ppi );
    }
    else
    {
        // This packet was allocated to wrap a protocol or miniport's buffers.
        // Return the packet to its original owner.
        SAFEASSERT( Own == BrdgOwnWrapperPacket );
        SAFEASSERT( ppi->u.BasePacketInfo.pOriginalPacket != NULL );

        if( ppi->Flags.OriginalDirection == BrdgPacketInbound )
        {
            // Wraps a lower-layer miniport packet.
            NdisReturnPackets( &ppi->u.BasePacketInfo.pOriginalPacket, 1 );

            // We incremented the adapter's refcount when we first received the packet
            // to prevent the adapter from shutting down while we still held some of
            // its packets
            SAFEASSERT( ppi->u.BasePacketInfo.pOwnerAdapter != NULL );
            BrdgReleaseAdapter( ppi->u.BasePacketInfo.pOwnerAdapter );
        }
        else
        {
            NDIS_HANDLE         MiniportHandle;

            // Wraps a higher-layer protocol packet
            SAFEASSERT( ppi->Flags.OriginalDirection == BrdgPacketOutbound );

            // Shuttle back per-packet information before returning the original descriptor
            NdisIMCopySendCompletePerPacketInfo (ppi->u.BasePacketInfo.pOriginalPacket, pPacket);

            // Give back the original descriptor.
            // NDIS should prevent the miniport from shutting down while there is still an
            // indicate pending.
            MiniportHandle = BrdgMiniAcquireMiniport();
            SAFEASSERT( MiniportHandle != NULL );
            NdisMSendComplete( MiniportHandle, ppi->u.BasePacketInfo.pOriginalPacket, Status );
            BrdgMiniReleaseMiniport();
        }

        // Don't forget to free the wrapper packet as well
        BrdgFwdFreeBaseWrapperPacket( pPacket, ppi );
    }
}

VOID
BrdgFwdWrapPacketForReceive(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    )
/*++

Routine Description:

    Copies state information into a wrapper packet for the purposes of indicating
    the new packet up to overlying protocols

Arguments:

    pOriginalPacket         The packet to copy state out of
    pNewPacket              The wrapper packet to copy state into

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;

    // Copy other header and OOB data
    NDIS_SET_ORIGINAL_PACKET(pNewPacket, NDIS_GET_ORIGINAL_PACKET(pOriginalPacket));
    NdisSetPacketFlags( pNewPacket, NdisGetPacketFlags(pOriginalPacket) );
    Status = NDIS_GET_PACKET_STATUS(pOriginalPacket);
    NDIS_SET_PACKET_STATUS(pNewPacket, Status);
    NDIS_SET_PACKET_HEADER_SIZE(pNewPacket, NDIS_GET_PACKET_HEADER_SIZE(pOriginalPacket));
}

VOID
BrdgFwdWrapPacketForSend(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    )
/*++

Routine Description:

    Copies state information into a wrapper packet for the purposes of transmitting the
    new packet to underlying NICs

Arguments:

    pOriginalPacket         The packet to copy state out of
    pNewPacket              The wrapper packet to copy state into

Return Value:

    None

--*/
{
    PVOID                   MediaSpecificInfo = NULL;
    ULONG                   MediaSpecificInfoSize = 0;

    NdisSetPacketFlags( pNewPacket, NdisGetPacketFlags(pOriginalPacket) );

    //
    // Copy the OOB Offset from the original packet to the new
    // packet.
    //
    NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(pNewPacket),
                   NDIS_OOB_DATA_FROM_PACKET(pOriginalPacket),
                   sizeof(NDIS_PACKET_OOB_DATA));

    //
    // Copy the per packet info into the new packet
    // This includes ClassificationHandle, etc.
    // Make sure other stuff is not copied !!!
    //
    NdisIMCopySendPerPacketInfo(pNewPacket, pOriginalPacket);

    //
    // Copy the Media specific information
    //
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(pOriginalPacket,
                                        &MediaSpecificInfo,
                                        &MediaSpecificInfoSize);

    if (MediaSpecificInfo || MediaSpecificInfoSize)
    {
        NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(pNewPacket,
                                            MediaSpecificInfo,
                                            MediaSpecificInfoSize);
    }
}

PNDIS_PACKET
BrdgFwdCommonAllocAndWrapPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt,
    IN PWRAPPER_FUNC        pFunc
    )
/*++

Routine Description:

    Common logic for creating a wrapper packet

    Creates a new wrapper packet and calls the supplied function to copy
    state information from the original packet into the wrapper

Arguments:

    pBasePacket             The packet to wrap
    pppi                    Returns the new wrapper packet's info block or
                            NULL if the allocation fails

    pTargetAdapt            The adapter to charge the new wrapper packet (and
                            the cost of hanging onto the base packet) to

    pFunc                   The function to call to copy state from the original
                            packet to the new wrapper

Return Value:

    The newly allocated wrapper packet or NULL if the allocation failed (usually
    because the target adapter did not pass quota)

--*/
{
    PNDIS_PACKET            pNewPacket;
    NDIS_STATUS             Status;

    SAFEASSERT( pTargetAdapt != NULL );

    // Must first determine if the target can handle the quota of
    // holding onto the base packet.
    //
    // If we do not own the base packet, this has no effect.
    if( ! BrdgBufAssignBasePacketQuota(pBasePacket, pTargetAdapt) )
    {
        *pppi = NULL;
        return NULL;
    }

    // Try to get a wrapper packet
    pNewPacket = BrdgBufGetWrapperPacket( pppi, pTargetAdapt );

    if( pNewPacket == NULL )
    {
        SAFEASSERT( *pppi == NULL );

        // Reverse the previous accounting for holding onto the base packet
        BrdgBufReleaseBasePacketQuota( pBasePacket, pTargetAdapt );
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Point the new packet to the old buffers
    Status = BrdgBufChainCopyBuffers( pNewPacket, pBasePacket );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgBufReleaseBasePacketQuota( pBasePacket, pTargetAdapt );
        BrdgBufFreeWrapperPacket( pNewPacket, *pppi, pTargetAdapt );
        *pppi = NULL;
        return NULL;
    }

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)pNewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)pNewPacket->MiniportReserved) = *pppi;

    // Copy whatever state needs to be copied for the direction this packet is heading
    (*pFunc)(pBasePacket, pNewPacket);

    return pNewPacket;
}

//
// Paranoid checking of base packets
//
#if DBG
_inline VOID
BrdgFwdCheckBasePacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
{
    SAFEASSERT( ppi != NULL );

    // Packets should come prepared so the PACKET_INFO structure is recoverable from
    // both the MiniportReserved and ProtocolReserved areas, so it won't matter whether
    // we use the packet for a send or an indicate.
    SAFEASSERT( *((PPACKET_INFO*)pPacket->ProtocolReserved) == ppi );
    SAFEASSERT( *((PPACKET_INFO*)pPacket->MiniportReserved) == ppi );

    // The base packet refcounts its own buffers
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // The base packet must allow the upper-layer protocol to hang onto its buffers
    SAFEASSERT( NDIS_GET_PACKET_STATUS( pPacket ) == NDIS_STATUS_SUCCESS );
}
#else
#define BrdgFwdCheckBasePacket(A,B) {}
#endif


NDIS_STATUS
BrdgFwdHandlePacket(
    IN PACKET_DIRECTION     PacketDirection,
    IN PADAPT               pTargetAdapt,
    IN PADAPT               pOriginalAdapt,
    IN BOOLEAN              bShouldIndicate,
    IN NDIS_HANDLE          MiniportHandle,
    IN PNDIS_PACKET         pBasePacket,
    IN PPACKET_INFO         baseppi,
    IN PPACKET_BUILD_FUNC   pFunc,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Common logic for handling packets that cannot be fast-tracked

    A base packet can optionally be passed in. This is only done when handling
    packets from the copy path or the no-copy path when packets arrived with
    STATUS_RESOURCES set, since those types of packets must be wrapped just to
    be queued for processing.

    If a base packet is passed in, it is assumed that NO QUOTA has been assigned
    to any adapter for that base packet. The cost of the base packet is assigned
    to any prospective target via BrdgBufAssignBasePacketQuota().

    If a base packet is not passed in, a function pointer must be supplied that
    can build a base packet on demand from the supplied parameters. When base
    packets are built on the fly, they DO require immediate quota assignments.

    Note that if a base packet is passed in, it is possible for this function to
    release the base packet itself (via BrdgFwdReleaseBasePacket) and return
    NDIS_STATUS_PENDING.

Arguments:

    PacketDirection         The original direction of the packet being handled

    pTargetAdapt            The adapter corresponding to the packet's target
                            MAC address, or NULL if not known. A non-NULL value
                            implies that bShouldIndicate == FALSE, since it doesn't
                            make sense for a unicast packet bound for another
                            adapter to require indication to the local machine.

    pOriginalAdapt          The adapter on which the original packet was received

    bShouldIndicate         Whether the packet should be indicated to overlying protocols

    MiniportHandle          The handle to our local miniport (CALLER IS RESPONSIBLE
                            FOR ENSURING THE MINIPORT'S EXISTENCE DURING THIS CALL!)

    pBasePacket             The base packet to use if one has already been built (this
                            occurs on the copy-receive path)

    baseppi                 The base packet's PACKET_INFO if one exists.

    pFunc                   A function that, when passed Param1 - Param4, can build
                            a base packet from the originally received packet for
                            a particular target adapter.

    Param1 - Param4         Parameters to pass to pFunc

    If a base packet is not supplied, pFunc must be non-NULL. Conversely, if a base
    packet is supplied, pFunc should be NULL because it will never be called.

Return Value:

    NDIS_STATUS_PENDING     Indicates that the base packet passed in was used successfully
                            or that a base packet was successfully built and used with
                            the help of pFunc. The base packet and any wrapper packets
                            build by BrdgFwdHandlePacket will be automatically deallocated
                            in the future; the caller need not take any additional action.

    OTHER RETURN CODE       No targets were found or none passed quota check. If a base
                            packet was passed in, the caller should free it. If there is
                            an underlying packet that was to be used to build a base packet,
                            the caller should free it.

--*/
{
    BOOLEAN                 dataRetained = FALSE;
    PACKET_DIRECTION        tmpPacketDirection;

    tmpPacketDirection = PacketDirection;

    SAFEASSERT( (PacketDirection == BrdgPacketInbound) ||
                (PacketDirection == BrdgPacketOutbound) );

    SAFEASSERT( (pBasePacket != NULL) || (pFunc != NULL) );

    SAFEASSERT( (pTargetAdapt == NULL) || (bShouldIndicate == FALSE) );

    if( pBasePacket != NULL )
    {
        SAFEASSERT( baseppi != NULL );
        BrdgFwdCheckBasePacket( pBasePacket, baseppi );
    }

    if( bShouldIndicate )
    {
        // Don't try to indicate if the miniport doesn't exist
        if( MiniportHandle == NULL )
        {
            // Count this as a failed indicate
            ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
            bShouldIndicate = FALSE;
        }
    }

    // Not allowed to pass in a target adapter in compatibility-mode, since
    // only the compatibility-mode code is supposed to deal with those.
    if( pTargetAdapt != NULL )
    {
        SAFEASSERT( !pTargetAdapt->bCompatibilityMode );
    }

    if( (pTargetAdapt != NULL) && (! bShouldIndicate) )
    {
        // This packet is going to a single destination.
        if( pBasePacket != NULL )
        {
            // We were passed in a base packet. See if the target adapter can accept
            // the quota of the base packet.
            if( ! BrdgBufAssignBasePacketQuota(pBasePacket, pTargetAdapt) )
            {
                // The target is over quota and can't accept this packet. We will
                // return an error code to indicate that we never used the caller's base
                // packet.
                pBasePacket = NULL;
                baseppi = NULL;
            }
            // else we continue processing below
        }
        else
        {
            // Alloc a base packet with the supplied function
            SAFEASSERT( pFunc != NULL );
            pBasePacket = (*pFunc)(&baseppi, pTargetAdapt, Param1, Param2, Param3, Param4);
        }

        if( pBasePacket != NULL )
        {
            // Paranoia
            BrdgFwdCheckBasePacket( pBasePacket, baseppi );
            baseppi->u.BasePacketInfo.RefCount = 1L;
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;
            BrdgFwdSendOnLink( pTargetAdapt, pBasePacket );

            // We're using the base packet or the underlying packet used to build the
            // base packet
            dataRetained = TRUE;
        }
        else
        {
            THROTTLED_DBGPRINT(FWD, ("Over quota for single target adapter\n"));

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }
        }
    }
    else
    {
        //
        // Our packet isn't bound for a single destination. Do the slow processing.
        //
        UINT                numTargets = 0L, actualTargets, i;
        PADAPT              pAdapt;
        PADAPT              SendList[MAX_ADAPTERS];
        LOCK_STATE          LockState;
        BOOLEAN             sentBase = FALSE;   // Whether we have sent the base packet yet

        //
        // First we need a list of the adapters we intend to send this packet to
        //

        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

        // Always indicate with the base packet
        if( bShouldIndicate )
        {
            SendList[0] = LOCAL_MINIPORT;
            numTargets = 1L;
        }

        if( pTargetAdapt != NULL )
        {
            BrdgReacquireAdapter( pTargetAdapt );
            SendList[numTargets] = pTargetAdapt;
            numTargets++;
        }
        else
        {
            // Note each adapter to send to
            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                // Don't need to acquire the global adapter characteristics lock to read the
                // media state because we don't care about the global consistency of the
                // adapters' characteristics here
                if( (pAdapt != pOriginalAdapt) &&
                    (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
                    (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
                    (! pAdapt->bResetting) &&                           // Adapter must not be resetting
                    (! pAdapt->bCompatibilityMode) )                    // Adapter can't be in compat-mode
                {
                    if( numTargets < MAX_ADAPTERS )
                    {
                        // We will use this adapter outside the list lock; bump its refcount
                        BrdgAcquireAdapterInLock(pAdapt);
                        SendList[numTargets] = pAdapt;
                        numTargets++;
                    }
                    else
                    {
                        // Too many copies to send!
                        SAFEASSERT( FALSE );
                    }
                }
            }
        }

        // Can let go of the adapter list now; we have copied out all the target adapters
        // and incremented the refcount for the adapters we will be using.
        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

        if( numTargets == 0 )
        {
            //
            // Nowhere to send the packet! Nothing to do.
            //
            // This should not happen often. If the packet is a local send, our media status
            // should be DISCONNECTED, so there should be no transmits from above.
            //

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit (although the caller probably
                // shouldn't have sent the packet in the first place since our media status
                // should be DISCONNECTED
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }

            //
            // Indicate to the caller that no send occurred
            //
            return NDIS_STATUS_NO_CABLE;
        }

        actualTargets = numTargets;

        // If we had a base packet passed in, set its refcount now that we know how many
        // adapters we will be targeting
        if( pBasePacket != NULL )
        {
            baseppi->u.BasePacketInfo.RefCount = actualTargets;
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

            // We now need ownership of the base packet passed in; even if all our send
            // attempts fail, we will release the base packet ourselves below, so the
            // caller should not dispose of the base packet himself.
            dataRetained = TRUE;
        }

        //
        // Walk the list of targets and try to send to each
        //
        for( i = 0L; i < numTargets; i++ )
        {
            PADAPT              OutAdapt = SendList[i];
            PNDIS_PACKET        pPacketToSend = NULL;
            PPACKET_INFO        ppiToSend = NULL;

            SAFEASSERT(tmpPacketDirection == PacketDirection);

            if( pBasePacket == NULL )
            {
                //
                // We weren't passed in a base packet and we haven't built one yet. Build one now
                // that we have a specific target adapter.
                //
                pBasePacket = (*pFunc)(&baseppi, OutAdapt, Param1, Param2, Param3, Param4);

                if( pBasePacket != NULL )
                {
                    // Paranoia
                    BrdgFwdCheckBasePacket( pBasePacket, baseppi );
                    SAFEASSERT( actualTargets > 0L );
                    baseppi->u.BasePacketInfo.RefCount = actualTargets;
                    baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

                    pPacketToSend = pBasePacket;
                    ppiToSend = baseppi;
                    sentBase = TRUE;
                }
                else
                {
                    // We failed to build a base packet. Just pretend there was one less target
                    // for the next time through
                    actualTargets--;
                }
            }
            else
            {
                if( ! sentBase )
                {
                    //
                    // We have a base packet but we haven't sent it yet. Send to this target if quota allows.
                    //
                    if( BrdgBufAssignBasePacketQuota(pBasePacket, OutAdapt) )
                    {
                        // This target can accept the base packet.
                        pPacketToSend = pBasePacket;
                        ppiToSend = baseppi;
                        sentBase = TRUE;
                    }
                    else
                    {
                        // The target is over quota and can't accept this packet.
                        pPacketToSend = NULL;
                        ppiToSend = NULL;

                        // bookkeeping on the base packet done below
                    }
                }
                else
                {
                    //
                    // We have a base packet and we have already sent it. Use wrapper packets for each additional
                    // send.
                    //
                    if( baseppi->Flags.OriginalDirection == BrdgPacketInbound )
                    {
                        pPacketToSend = BrdgFwdAllocAndWrapPacketForReceive( pBasePacket, &ppiToSend, OutAdapt );
                    }
                    else
                    {
                        SAFEASSERT( baseppi->Flags.OriginalDirection == BrdgPacketOutbound );
                        pPacketToSend = BrdgFwdAllocAndWrapPacketForSend( pBasePacket, &ppiToSend, OutAdapt );
                    }

                    if( pPacketToSend != NULL )
                    {
                        // Signal that the upper-layer protocol can hang on to these buffers
                        NDIS_SET_PACKET_STATUS(pPacketToSend, NDIS_STATUS_SUCCESS);

                        // Set up the wrapper's info block
                        SAFEASSERT( ppiToSend != NULL );
                        ppiToSend->Flags.OriginalDirection = BrdgPacketCreatedInBridge;
                        ppiToSend->Flags.bIsBasePacket = FALSE;
                        ppiToSend->u.pBasePacketInfo = baseppi;
                    }
                    // else bookkeeping done below
                }
            }

            if( pPacketToSend == NULL )
            {
                // Record the failed attempt as appropriate
                SAFEASSERT( ppiToSend == NULL );

                if( OutAdapt == LOCAL_MINIPORT )
                {
                    THROTTLED_DBGPRINT(FWD, ("Over quota for local miniport during processing\n"));
                    ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
                }
                else
                {
                    THROTTLED_DBGPRINT(FWD, ("Over quota for adapter during processing\n"));
                }

                if( pBasePacket != NULL )
                {
                    // We failed to send or wrap the base packet to this target. Do bookkeeping.
                    SAFEASSERT( baseppi != NULL );

                    if( BrdgFwdDerefBasePacket( NULL/*The cost of the base packet never got assigned to OutAdapt*/,
                                                pBasePacket, baseppi, NDIS_STATUS_FAILURE ) )
                    {
                        // We should have been the last target in the list to cause the base packet
                        // to actually be freed.
                        SAFEASSERT( i == numTargets - 1 );
                        pBasePacket = NULL;
                        baseppi = NULL;

                        // We just disposed of the caller's base packet, so we should not cause him to
                        // try to do that again on return
                        SAFEASSERT( dataRetained );
                    }
                }
            }
            else
            {
                // We have a packet to send.
                SAFEASSERT( ppiToSend != NULL );

                if( OutAdapt == LOCAL_MINIPORT )
                {
                    // We are indicating this packet
                    SAFEASSERT( MiniportHandle != NULL );
                    BrdgFwdIndicatePacket( pPacketToSend, MiniportHandle );
                }
                else
                {
                    // We are sending to an adapter, not the local miniport
                    BrdgFwdSendOnLink( OutAdapt, pPacketToSend );
                }

                // We definitely need ownership of the underlying data since we just handed it off
                // to a target
                dataRetained = TRUE;
            }

            if( OutAdapt != LOCAL_MINIPORT )
            {
                // We're done with this adapter now
                BrdgReleaseAdapter( OutAdapt );
            }
        }

        if( ! dataRetained )
        {
            // If we're not claiming ownership of the underlying data, we had better not have
            // actually used it
            SAFEASSERT( ! sentBase );

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }
        }
        else
        {
            // If we are claiming owernship of the underlying data, we must have used it or
            // disposed of the base packet ourselves.
            SAFEASSERT( sentBase || (pBasePacket == NULL) );
        }
    }

    // Tell the caller whether we are hanging into his data or not
    return dataRetained ? NDIS_STATUS_PENDING : NDIS_STATUS_FAILURE;
}

BOOLEAN
BrdgFwdNoCopyFastTrackReceive(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt,
    IN NDIS_HANDLE          MiniportHandle,
    IN PUCHAR               DstAddr,
    OUT BOOLEAN             *bRetainPacket
    )
/*++

Routine Description:

    Called to indicate a packet descriptor from an underlying NIC straight up to
    overlying protocols without wrapping.

Arguments:

    pPacket                 The packet to indicate
    pAdapt                  The adapter that owns this packet descriptor
    MiniportHandle          The miniport handle (must be != NULL)
    DstAddr                 The target MAC address of the packet

    bRetainPacket           Whether the caller should retain ownership of the
                            given packet descriptor or not. TRUE if the original
                            packet's status was not STATUS_RESOURCES, FALSE otherwise.
                            Undefined if return value != TRUE

Return Value:

    TRUE if the indication succeeded, FALSE otherwise.

--*/
{
    BOOLEAN                 bRemaining;
    NDIS_STATUS             Status;
    PNDIS_PACKET_STACK      pStack;

    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( MiniportHandle != NULL );
    SAFEASSERT( bRetainPacket != NULL );

    *bRetainPacket = FALSE;

    // The fast-track is possible only if NDIS has room left in its packet stack
    pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

    if ( bRemaining )
    {
        Status = NDIS_GET_PACKET_STATUS(pPacket);

        if( Status != NDIS_STATUS_RESOURCES )
        {
            SAFEASSERT( (Status == NDIS_STATUS_SUCCESS) || (Status == NDIS_STATUS_PENDING) );

            //
            // The upper-layer protocol gets to hang on to this packet until it's done.
            // We must ensure that this adapter is not allowed to shut down while we are
            // still holding its packet. As a special case for fast-track receives, we
            // stash a pointer to the adapter's PADAPT struct in the magic NDIS stack
            // area reserved for intermediate drivers. This allows us to decrement the
            // adapter's refcount when the indication completes.
            //
            BrdgReacquireAdapter( pAdapt );
            pStack->IMReserved[0] = (ULONG_PTR)pAdapt;

            // Tell the caller to retain ownership of the packet
            *bRetainPacket = TRUE;
        }
        else
        {
            // Paranoia: zero out the area we use to stash the PADAPT pointer in case
            // we get confused about the path this packet took
            pStack->IMReserved[0] = 0L;

            // Tell the owner not to retain ownership of the packet
            *bRetainPacket = FALSE;
        }

        // Count the packet as received
        ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedBytes, BrdgBufTotalPacketSize(pPacket) );
        ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyBytes, BrdgBufTotalPacketSize(pPacket) );
        ExInterlockedAddLargeStatistic( &pAdapt->ReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &pAdapt->ReceivedBytes, BrdgBufTotalPacketSize(pPacket) );

        // Hand up to overlying protocols
        BrdgFwdIndicatePacket( pPacket, MiniportHandle );

        // Fast-track succeeded.
        return TRUE;
    }

    // Can't fast-track.
    return FALSE;
}

//
// Changes Bridging Status due to a GPO change
//

VOID
BrdgFwdChangeBridging(
    IN BOOLEAN Bridging
                      )
{
    //
    // Since we don't want to empty our tables if the settings are the same, we check
    // this before updating anything.  If nothing has changed, we just return
    //
    if (gBridging != Bridging)
    {
        gBridging = Bridging;
        // Remove all MAC addresses from tables
        BrdgTblScrubAllAdapters();
        // Remove all IP addresses from tables
        BrdgCompScrubAllAdapters();
        if (!Bridging)
        {
            DBGPRINT(FWD, ("Bridging is now OFF.\r\n"));
            if (gHaveID)
            {
                BrdgSTACancelTimersGPO();
            }
        }
        else
        {
            DBGPRINT(FWD, ("Bridging is now ON.\r\n"));
            if (gHaveID)
            {
                BrdgSTARestartTimersGPO();
                BrdgSTAResetSTAInfoGPO();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgctl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.h

Abstract:

    Ethernet MAC level bridge.
    IOCTL processing code header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgCtlDriverInit();

VOID
BrdgCtlCleanup();

VOID
BrdgCtlHandleCreate();

VOID
BrdgCtlHandleCleanup();

NTSTATUS
BrdgCtlHandleIoDeviceControl(
    IN PIRP                         Irp,
    IN PFILE_OBJECT                 FileObject,
    IN OUT PVOID                    Buffer,
    IN ULONG                        InputBufferLength,
    IN ULONG                        OutputBufferLength,
    IN ULONG                        IoControlCode,
    OUT PULONG                      Information
    );

VOID
BrdgCtlNotifyAdapterChange(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type
    );

VOID
BrdgCtlNotifySTAPacket(
    IN PADAPT                       pAdapt,
    IN PNDIS_PACKET                 pPacket
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgctl.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.c

Abstract:

    Ethernet MAC level bridge.
    IOCTL processing code

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

#include "brdgmini.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdgfwd.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgsta.h"

// IoSetCancelRoutine causes these warnings; disable them
#pragma warning( disable: 4054 )
#pragma warning( disable: 4055 )

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

//
// Maximum number of notifications we will queue up if the user-mode
// code hasn't given us any IRPs to use
//
#define MAX_NOTIFY_QUEUE_LENGTH                     20

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Structure for queueing a notification
typedef struct _DEFERRED_NOTIFY
{

    BSINGLE_LIST_ENTRY          List;               // For queuing
    UINT                        DataSize;           // Size of data at end

    BRIDGE_NOTIFY_HEADER        Header;             // The notification header
    // DataSize bytes of data follows

} DEFERRED_NOTIFY, *PDEFERRED_NOTIFY;

// Type of function to pass to BrdgCtlCommonNotify
typedef VOID (*PNOTIFY_COPY_FUNC)(PVOID, PVOID);

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Queue of pending notifications
BSINGLE_LIST_HEAD               gNotificationsList;
NDIS_SPIN_LOCK                  gNotificationsListLock;

// Queue of pending notification IRPs
LIST_ENTRY                      gIRPList;
NDIS_SPIN_LOCK                  gIRPListLock;

// A flag controlling whether new entries are allowed onto the queue of pending
// notifications or not. != 0 means new entries are allowed
ULONG                           gAllowQueuedNotifies = 0L;

// ===========================================================================
//
// LOCAL PROTOTYPES
//
// ===========================================================================

PIRP
BrdgCtlDequeuePendingIRP();

VOID
BrdgCtlCopyAdapterInfo(
    OUT PBRIDGE_ADAPTER_INFO        pInfo,
    IN PADAPT                       pAdapt
    );

NTSTATUS
BrdgCtlQueueAndPendIRP(
    IN PIRP             pIrp
    );

PADAPT
BrdgCtlValidateAcquireAdapter(
    IN BRIDGE_ADAPTER_HANDLE   Handle
    );

VOID
BrdgCtlEmptyIRPList(
    PLIST_ENTRY     pList
    );

VOID
BrdgCtlCancelPendingIRPs();

VOID
BrdgCtlReleaseQueuedNotifications();

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCtlDriverInit()
/*++

Routine Description:

    Main driver entry point. Called at driver load time

Arguments:

    None

Return Value:

    Status of our initialization. A status != STATUS_SUCCESS aborts the
    driver load and we don't get called again.

--*/
{
    BrdgInitializeSingleList( &gNotificationsList );
    InitializeListHead( &gIRPList );

    NdisAllocateSpinLock( &gNotificationsListLock );
    NdisAllocateSpinLock( &gIRPListLock );

    return STATUS_SUCCESS;
}

VOID
BrdgCtlHandleCreate()
/*++

Routine Description:

    Called when a user-mode component opens our device object. We allow notifications
    to be queued up until we are closed.

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(CTL, ("BrdgCtlHandleCreate()\n"));

    // Permit notifications to be queued
    InterlockedExchangeULong( &gAllowQueuedNotifies, 1L );
}

VOID
BrdgCtlHandleCleanup()
/*++

Routine Description:

    Called when our device object has no more references to it. We disallow notification
    queuing and flush existing queued notifications and pending IRPs.

Arguments:

    None

Return Value:

    None

--*/
{
    // Forbid new notifications from being queued
    ULONG prev = InterlockedExchangeULong( &gAllowQueuedNotifies, 0L );

    DBGPRINT(CTL, ("BrdgCtlHandleCleanup()\n"));

    // Write in this roundabout way otherwise compiler complains about
    // prev not being used in the FRE build
    if( prev == 0L )
    {
        SAFEASSERT( FALSE );
    }

    // Complete any pending IRPs
    BrdgCtlCancelPendingIRPs();

    // Ditch any queued notifications
    BrdgCtlReleaseQueuedNotifications();
}

VOID
BrdgCtlCommonNotify(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type,
    IN ULONG                        DataSize,
    IN OPTIONAL PNOTIFY_COPY_FUNC   pFunc,
    IN PVOID                        Param1
    )
/*++

Routine Description:

    Common processing for notifications to user-mode

    This routine completes a pending IRP from user mode if one is
    available. Otherwise, it queues up a new DEFERRED_NOTIFY
    structure with the notification data.

Arguments:

    pAdapt                          The adapter involved in the notification
    Type                            Type of notification

    DataSize                        Required amount of data required to store
                                    the notification information

    pFunc                           A function that can copy the notification
                                    data to an IRP's buffer or a new DEFERRED_NOTIFY
                                    structure. Can be NULL if no copying is
                                    required.

    Param1                          A context pointer to pass to the helper
                                    function

Return Value:

    None

--*/
{
    PIRP                            pIrp;

    // Check if there is an IRP waiting to receive this notification
    pIrp = BrdgCtlDequeuePendingIRP();

    if( pIrp != NULL )
    {
        PBRIDGE_NOTIFY_HEADER       pHeader;

        // There's an IRP waiting to be completed. Fill it in
        pHeader = (PBRIDGE_NOTIFY_HEADER)pIrp->AssociatedIrp.SystemBuffer;

        // Fill in the notification header
        pHeader->Handle = (BRIDGE_ADAPTER_HANDLE)pAdapt;
        pHeader->NotifyType = Type;

        // Fill in the remaining data if necessary
        if( pFunc != NULL )
        {
            (*pFunc)( ((PUCHAR)pIrp->AssociatedIrp.SystemBuffer) + sizeof(BRIDGE_NOTIFY_HEADER), Param1 );
        }

        // Complete the IRP
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = sizeof(BRIDGE_NOTIFY_HEADER) + DataSize;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    else
    {
        // No pending IRP. Queue up the notification if that's currently allowed.
        if( gAllowQueuedNotifies )
        {
            NDIS_STATUS                     Status;
            PDEFERRED_NOTIFY                pNewNotify, pOldEntry = NULL;

            Status = NdisAllocateMemoryWithTag( &pNewNotify, sizeof(DEFERRED_NOTIFY) + DataSize, 'gdrB' );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                DBGPRINT(CTL, ("Failed to allocate memory for an adapter change notification: %08x\n", Status));
                return;
            }

            // Fill in the notification
            pNewNotify->DataSize = DataSize;
            pNewNotify->Header.Handle = (BRIDGE_ADAPTER_HANDLE)pAdapt;
            pNewNotify->Header.NotifyType = Type;

            // Fill the remaining data if necessary
            if( pFunc != NULL )
            {
                (*pFunc)( ((PUCHAR)pNewNotify) + sizeof(DEFERRED_NOTIFY), Param1 );
            }

            NdisAcquireSpinLock( &gNotificationsListLock );
            SAFEASSERT( BrdgQuerySingleListLength(&gNotificationsList) <= MAX_NOTIFY_QUEUE_LENGTH );

            // Enforce the maximum notification queue length
            if( BrdgQuerySingleListLength(&gNotificationsList) == MAX_NOTIFY_QUEUE_LENGTH )
            {
                // Dequeue and ditch the head (oldest) notification
                pOldEntry = (PDEFERRED_NOTIFY)BrdgRemoveHeadSingleList( &gNotificationsList );
            }

            // Enqueue our entry
            BrdgInsertTailSingleList( &gNotificationsList, &pNewNotify->List );

            NdisReleaseSpinLock( &gNotificationsListLock );

            if( pOldEntry != NULL )
            {
                // Release the old entry that we bumped off
                NdisFreeMemory( pOldEntry, sizeof(DEFERRED_NOTIFY) + pOldEntry->DataSize, 0 );
            }
        }
    }
}

VOID
BrdgCtlNotifyAdapterChange(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type
    )
/*++

Routine Description:

    Produces a notification to user-mode signalling a change in an adapter.

Arguments:

    pAdapt                          The adapter involved
    Type                            Type of notification

Return Value:

    None

--*/
{
    if( Type == BrdgNotifyRemoveAdapter )
    {
        // We don't pass any additional data in the notification for remove events
        BrdgCtlCommonNotify( pAdapt, Type, 0, NULL, NULL );
    }
    else
    {
       BrdgCtlCommonNotify( pAdapt, Type, sizeof(BRIDGE_ADAPTER_INFO), BrdgCtlCopyAdapterInfo, pAdapt );
    }
}

NTSTATUS
BrdgCtlHandleIoDeviceControl(
    IN PIRP                 Irp,
    IN PFILE_OBJECT         FileObject,
    IN OUT PVOID            Buffer,
    IN ULONG                InputBufferLength,
    IN ULONG                OutputBufferLength,
    IN ULONG                IoControlCode,
    OUT PULONG              Information
    )
/*++

Routine Description:

    This routine handles all Device-control requests.

Arguments:

    Irp                     The IRP
    FileObject              The file object of the bridge
    Buffer                  Input / output buffer
    InputBufferLength       Size of inbound data
    OutputBufferLength      Maximum allowable output data
    IoControlCode           The control code

    Information             Code-specific information returned
                            (usually the number of written bytes or
                            bytes required on overflow)

Return Value:

    Status of the operation

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;

    *Information = 0;

    switch (IoControlCode)
    {
        //
        // Request for notification
        //
    case BRIDGE_IOCTL_REQUEST_NOTIFY:
        {
            PDEFERRED_NOTIFY                pDeferred = NULL;

            if( OutputBufferLength < sizeof(BRIDGE_NOTIFY_HEADER) + MAX_PACKET_SIZE )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                // See if there is a pending notification waiting for an IRP
                NdisAcquireSpinLock( &gNotificationsListLock );

                if( BrdgQuerySingleListLength(&gNotificationsList) > 0L )
                {
                    PBSINGLE_LIST_ENTRY     pList = BrdgRemoveHeadSingleList(&gNotificationsList);

                    if( pList != NULL )
                    {
                        pDeferred = CONTAINING_RECORD( pList, DEFERRED_NOTIFY, List );
                    }
                    else
                    {
                        // Should be impossible
                        SAFEASSERT(FALSE);
                    }
                }

                NdisReleaseSpinLock( &gNotificationsListLock );

                if( pDeferred != NULL )
                {
                    UINT                SizeToCopy = sizeof(BRIDGE_NOTIFY_HEADER) + pDeferred->DataSize;

                    // We have a notification to return immediately
                    NdisMoveMemory( Buffer, &pDeferred->Header, SizeToCopy );
                    *Information = SizeToCopy;

                    // Free the holding structure
                    NdisFreeMemory( pDeferred, sizeof(DEFERRED_NOTIFY) + pDeferred->DataSize, 0 );
                }
                else
                {
                    // No pending notification to send. queue the IRP for use later
                    status = BrdgCtlQueueAndPendIRP( Irp );
                }
            }
        }
        break;

        //
        // Request to be notified about all adapters
        //
    case BRIDGE_IOCTL_GET_ADAPTERS:
        {
            // Send a notification for each adapter
            PADAPT              pAdapt;
            LOCK_STATE          LockState;

            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyEnumerateAdapters );
            }

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
        }
        break;

        //
        // Request for an adapter's device name
        //
    case BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       bytesToCopy;

                    // We need enough room to add a trailing NULL
                    if( OutputBufferLength < pAdapt->DeviceName.Length + sizeof(WCHAR) )
                    {
                        if( OutputBufferLength >= sizeof(WCHAR) )
                        {
                            bytesToCopy = OutputBufferLength - sizeof(WCHAR);
                        }
                        else
                        {
                            bytesToCopy = 0L;
                        }

                        status = STATUS_BUFFER_OVERFLOW;
                    }
                    else
                    {
                        bytesToCopy = pAdapt->DeviceName.Length;
                    }

                    if( bytesToCopy > 0L )
                    {
                        NdisMoveMemory( Buffer, pAdapt->DeviceName.Buffer, bytesToCopy );
                    }

                    // Put a trailing NULL WCHAR at the end
                    *((PWCHAR)((PUCHAR)Buffer + bytesToCopy)) = 0x0000;

                    // Tell the caller how many bytes we wrote / are needed
                    *Information = pAdapt->DeviceName.Length + sizeof(WCHAR);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request for an adapter's friendly name
        //
    case BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       bytesToCopy;

                    // We need enough room to add a trailing NULL
                    if( OutputBufferLength < pAdapt->DeviceDesc.Length + sizeof(WCHAR) )
                    {
                        if( OutputBufferLength >= sizeof(WCHAR) )
                        {
                            bytesToCopy = OutputBufferLength - sizeof(WCHAR);
                        }
                        else
                        {
                            bytesToCopy = 0L;
                        }

                        status = STATUS_BUFFER_OVERFLOW;
                    }
                    else
                    {
                        bytesToCopy = pAdapt->DeviceDesc.Length;
                    }

                    if( bytesToCopy > 0L )
                    {
                        NdisMoveMemory( Buffer, pAdapt->DeviceDesc.Buffer, bytesToCopy );
                    }

                    // Put a trailing NULL WCHAR at the end
                    *((PWCHAR)((PUCHAR)Buffer + bytesToCopy)) = 0x0000;

                    // Tell the caller how many bytes we wrote / are needed
                    *Information = pAdapt->DeviceDesc.Length + sizeof(WCHAR);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request to retrieve the bridge's MAC address
        //
    case BRIDGE_IOCTL_GET_MAC_ADDRESS:
        {
            if( OutputBufferLength < ETH_LENGTH_OF_ADDRESS )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                if( ! BrdgMiniReadMACAddress((PUCHAR)Buffer) )
                {
                    // We don't actually have a MAC address right now
                    // (shouldn't really be possible since the user-mode code would have
                    // to be making this request before we bound to any adapters)
                    status = STATUS_UNSUCCESSFUL;
                }
                else
                {
                    *Information = ETH_LENGTH_OF_ADDRESS;
                }
            }
        }
        break;

        //
        // Request to retrieve packet-handling statistics
        //
    case BRIDGE_IOCTL_GET_PACKET_STATS:
        {
            if( OutputBufferLength < sizeof(BRIDGE_PACKET_STATISTICS) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PBRIDGE_PACKET_STATISTICS       pStats = (PBRIDGE_PACKET_STATISTICS)Buffer;

                // These are only statistics and have no associated locks so just read them
                // without protection
                pStats->TransmittedFrames = gStatTransmittedFrames;
                pStats->TransmittedErrorFrames = gStatTransmittedErrorFrames;
                pStats->TransmittedBytes = gStatTransmittedBytes;
                pStats->DirectedTransmittedFrames = gStatDirectedTransmittedFrames;
                pStats->MulticastTransmittedFrames = gStatMulticastTransmittedFrames;
                pStats->BroadcastTransmittedFrames = gStatBroadcastTransmittedFrames;
                pStats->DirectedTransmittedBytes = gStatDirectedTransmittedBytes;
                pStats->MulticastTransmittedBytes = gStatMulticastTransmittedBytes;
                pStats->BroadcastTransmittedBytes = gStatBroadcastTransmittedBytes;
                pStats->IndicatedFrames = gStatIndicatedFrames;
                pStats->IndicatedDroppedFrames = gStatIndicatedDroppedFrames;
                pStats->IndicatedBytes = gStatIndicatedBytes;
                pStats->DirectedIndicatedFrames = gStatDirectedIndicatedFrames;
                pStats->MulticastIndicatedFrames = gStatMulticastIndicatedFrames;
                pStats->BroadcastIndicatedFrames = gStatBroadcastIndicatedFrames;
                pStats->DirectedIndicatedBytes = gStatDirectedIndicatedBytes;
                pStats->MulticastIndicatedBytes = gStatMulticastIndicatedBytes;
                pStats->BroadcastIndicatedBytes = gStatBroadcastIndicatedBytes;
                pStats->ReceivedFrames = gStatReceivedFrames;
                pStats->ReceivedBytes = gStatReceivedBytes;
                pStats->ReceivedCopyFrames = gStatReceivedCopyFrames;
                pStats->ReceivedCopyBytes = gStatReceivedCopyBytes;
                pStats->ReceivedNoCopyFrames = gStatReceivedNoCopyFrames;
                pStats->ReceivedNoCopyBytes = gStatReceivedNoCopyBytes;

                *Information = sizeof(BRIDGE_PACKET_STATISTICS);
            }
        }
        break;

        //
        // Request to retrieve packet-handling statistics for an adapter
        //
    case BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS:
        {
            if( (InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE)) ||
                (OutputBufferLength < sizeof(BRIDGE_ADAPTER_PACKET_STATISTICS)) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    PBRIDGE_ADAPTER_PACKET_STATISTICS       pStats = (PBRIDGE_ADAPTER_PACKET_STATISTICS)Buffer;

                    // These are only statistics and have no associated locks so just read them
                    // without protection
                    pStats->SentFrames = pAdapt->SentFrames;
                    pStats->SentBytes = pAdapt->SentBytes;
                    pStats->SentLocalFrames = pAdapt->SentLocalFrames;
                    pStats->SentLocalBytes = pAdapt->SentLocalBytes;
                    pStats->ReceivedFrames = pAdapt->ReceivedFrames;
                    pStats->ReceivedBytes = pAdapt->ReceivedBytes;

                    *Information = sizeof(BRIDGE_ADAPTER_PACKET_STATISTICS);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request to retrieve buffer-handling statistics
        //
    case BRIDGE_IOCTL_GET_BUFFER_STATS:
        {
            if( OutputBufferLength < sizeof(BRIDGE_BUFFER_STATISTICS) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                BrdgBufGetStatistics((PBRIDGE_BUFFER_STATISTICS)Buffer);

                *Information = sizeof(BRIDGE_BUFFER_STATISTICS);
            }
        }
        break;

        //
        // Request to alter the packet-retention policy
        //
    case BRIDGE_IOCTL_RETAIN_PACKETS:
    case BRIDGE_IOCTL_NO_RETAIN_PACKETS:
        {
            // This global flag is not protected by any lock
            gRetainNICPackets = (BOOLEAN)(IoControlCode == BRIDGE_IOCTL_RETAIN_PACKETS);
        }
        break;

        //
        // Request to retrieve the contents of the forwarding table for
        // a particular adapter
        //
    case BRIDGE_IOCTL_GET_TABLE_ENTRIES:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       ReqdBytes;

                    // Try to read the contents of the forwarding table for this adapter
                    ReqdBytes = BrdgTblReadTable( pAdapt, Buffer, OutputBufferLength );

                    if( ReqdBytes > OutputBufferLength )
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }

                    *Information = ReqdBytes;

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

    case BRIDGE_IOCTL_GET_ADAPTER_STA_INFO:
        {
            if( gDisableSTA )
            {
                // Can't collect STA information when it's not running!
                status = STATUS_INVALID_PARAMETER;
            }
            else if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) ||
                     OutputBufferLength < sizeof(BRIDGE_STA_ADAPTER_INFO) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    BrdgSTAGetAdapterSTAInfo( pAdapt, (PBRIDGE_STA_ADAPTER_INFO)Buffer );
                    *Information = sizeof(BRIDGE_STA_ADAPTER_INFO);
                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

    case BRIDGE_IOCTL_GET_GLOBAL_STA_INFO:
        {
            if( gDisableSTA )
            {
                // Can't collect STA information when it's not running!
                status = STATUS_INVALID_PARAMETER;
            }
            else if( OutputBufferLength < sizeof(BRIDGE_STA_GLOBAL_INFO) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                BrdgSTAGetSTAInfo( (PBRIDGE_STA_GLOBAL_INFO)Buffer );
                *Information = sizeof(BRIDGE_STA_GLOBAL_INFO);
            }
        }
        break;

    default:
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    }

    return status;
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgCtlCopyAdapterInfo(
    OUT PBRIDGE_ADAPTER_INFO        pInfo,
    IN PADAPT                       pAdapt
    )
/*++

Routine Description:

    Helper function for BrdgCtlCommonNotify. Copies data about an adapter
    to a buffer.

Arguments:

    pInfo                           Structure to fill with information
    pAdapt                          Adapter to copy from

Return Value:

    None

--*/
{
    LOCK_STATE          LockState;

    // Take a read lock on gAdapterCharacteristicsLock to ensure that all these
    // are consistent
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, FALSE/*Read only*/, &LockState );

    pInfo->LinkSpeed = pAdapt->LinkSpeed;
    pInfo->MediaState = pAdapt->MediaState;
    pInfo->State = pAdapt->State;

    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

    // These values don't change after assignment, and so need no lock.
    ETH_COPY_NETWORK_ADDRESS( pInfo->MACAddress, pAdapt->MACAddr );
    pInfo->PhysicalMedium = pAdapt->PhysicalMedium;
}

PADAPT
BrdgCtlValidateAcquireAdapter(
    IN BRIDGE_ADAPTER_HANDLE   Handle
    )
/*++

Routine Description:

    Checks to ensure that a BRIDGE_ADAPTER_HANDLE passed from user-mode code
    actually corresponds to an adapter still in our list.

    If the adapter is found, its refcount is incremented.

Arguments:

    Handle                      A handle from user-mode code

Return Value:

    The handle recast as a PADAPT, or NULL if the adapter could not be found.

--*/
{
    PADAPT              pAdapt = (PADAPT)Handle, anAdapt;
    LOCK_STATE          LockState;

    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

    for( anAdapt = gAdapterList; anAdapt != NULL; anAdapt = anAdapt->Next )
    {
        if( anAdapt == pAdapt )
        {
            // The adapter is in the list. Increment its refcount inside the lock
            // and return
            BrdgAcquireAdapterInLock( pAdapt );
            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
            return pAdapt;
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    return NULL;
}

VOID
BrdgCtlCancelIoctl(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                pIrp
    )
/*++

Routine Description:

    IRP Cancellation function

Arguments:

    DeviceObject        The bridge's device-object

    pIrp                The IRP to be cancelled

Return Value:

    none.

Environment:

    Invoked with the cancel spin-lock held by the I/O manager.
    It is this routine's responsibility to release the lock.

--*/
{
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    // Take the IRP off our list
    NdisAcquireSpinLock( &gIRPListLock );
    RemoveEntryList( &pIrp->Tail.Overlay.ListEntry );
    InitializeListHead( &pIrp->Tail.Overlay.ListEntry );
    NdisReleaseSpinLock( &gIRPListLock );

    // Complete the IRP
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
}


NTSTATUS
BrdgCtlQueueAndPendIRP(
    IN PIRP             pIrp
    )
/*++

Routine Description:

    Safely inserts an IRP into our queue of pending IRPs.

Arguments:

    pIrp                The IRP to queue

Return Value:

    The status to return from IRP processing (can be STATUS_CANCELLED
    if the IRP was cancelled right after we received it. Otherwise
    is STATUS_PENDING so caller knows the IRP is pending).

--*/
{
    KIRQL               CancelIrql;

    // If the IRP has already been cancelled, forget it.
    IoAcquireCancelSpinLock( &CancelIrql );
    NdisDprAcquireSpinLock( &gIRPListLock );

    if ( pIrp->Cancel )
    {
        NdisDprReleaseSpinLock( &gIRPListLock );
        IoReleaseCancelSpinLock(CancelIrql);
        return STATUS_CANCELLED;
    }

    // Queue the IRP
    InsertTailList( &gIRPList, &pIrp->Tail.Overlay.ListEntry);

    // Install our cancel-routine
    IoMarkIrpPending( pIrp );
    IoSetCancelRoutine( pIrp, BrdgCtlCancelIoctl );

    NdisDprReleaseSpinLock( &gIRPListLock );
    IoReleaseCancelSpinLock( CancelIrql );

    return STATUS_PENDING;
}

PIRP
BrdgCtlDequeuePendingIRP()
/*++

Routine Description:

    Safely dequeues an IRP on our pending list for use to communicate
    a notification

Return Value:

    A dequeued IRP if one was available; NULL otherwise.

--*/
{
    PLIST_ENTRY                     Link;
    PIRP                            pIrp = NULL;

    while( pIrp == NULL )
    {
        NdisAcquireSpinLock( &gIRPListLock );

        if ( IsListEmpty(&gIRPList) )
        {
            NdisReleaseSpinLock( &gIRPListLock );
            return NULL;
        }

        // Dequeue a pending IRP
        Link = RemoveHeadList( &gIRPList );
        pIrp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

        // After this call, it is safe for our cancel routine to call
        // RemoveHeadList again on this IRP
        InitializeListHead( Link );

        // Make the IRP uncancellable so we can complete it.
        if( IoSetCancelRoutine( pIrp, NULL ) == NULL )
        {
            // This IRP must have already been cancelled but our cancel
            // routine hasn't gotten control yet. Loop again to get a
            // usable IRP.
            pIrp = NULL;
        }

        NdisReleaseSpinLock( &gIRPListLock );
    }

    return pIrp;
}

VOID
BrdgCtlCancelPendingIRPs()
/*++

Routine Description:

    Cancels all pending IRPs

Return Value:

    None

--*/
{
    PIRP            pIrp;

    NdisAcquireSpinLock( &gIRPListLock );

    while ( !IsListEmpty(&gIRPList) )
    {
        //
        // Take the next IRP off the list
        //
        pIrp = CONTAINING_RECORD( gIRPList.Flink, IRP, Tail.Overlay.ListEntry );
        RemoveEntryList( &pIrp->Tail.Overlay.ListEntry );

        // Clean up the ListEntry in case our cancel routine gets called
        InitializeListHead( &pIrp->Tail.Overlay.ListEntry );

        // Cancel it if necessary
        if ( IoSetCancelRoutine( pIrp, NULL ) != NULL )
        {
            // Our cancel routine will not be called. Complete this IRP ourselves.
            NdisReleaseSpinLock( &gIRPListLock );

            // Complete the IRP
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );

            // Resume emptying the list
            NdisAcquireSpinLock( &gIRPListLock );
        }
        // else our cancel routine will be called for this IRP
    }

    NdisReleaseSpinLock( &gIRPListLock );
}

VOID
BrdgCtlReleaseQueuedNotifications()
/*++

Routine Description:

    Frees any queued notifications

Return Value:

    None

--*/
{
    BSINGLE_LIST_HEAD       list;

    NdisAcquireSpinLock( &gNotificationsListLock );

    // Grab a copy of the whole list head
    list = gNotificationsList;

    // Set the list head back to empty
    BrdgInitializeSingleList( &gNotificationsList );

    NdisReleaseSpinLock( &gNotificationsListLock );

    // Now free all the items on the list
    while( BrdgQuerySingleListLength(&list) > 0L )
    {
        PDEFERRED_NOTIFY        pDeferred = NULL;
        PBSINGLE_LIST_ENTRY     pList = BrdgRemoveHeadSingleList(&list);

        if( pList != NULL )
        {
            pDeferred = CONTAINING_RECORD( pList, DEFERRED_NOTIFY, List );
            NdisFreeMemory( pDeferred, sizeof(DEFERRED_NOTIFY) + pDeferred->DataSize, 0 );
        }
        else
        {
            // Should be impossible
            SAFEASSERT(FALSE);
        }
    }
}

VOID
BrdgCtlCleanup()
/*++

Routine Description:

    Cleanup routine; called at shutdown

    This function is guaranteed to be called exactly once

Return Value:

    None

--*/
{
    BrdgCtlCancelPendingIRPs();
    BrdgCtlReleaseQueuedNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgdbg.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgdbg.h

Abstract:

    Ethernet MAC level bridge.
    Debugging header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    December  2000 - Original version

--*/

// Alias for KeGetCurrentIrql()
#define CURRENT_IRQL            (KeGetCurrentIrql())
            
// Module identifiers for debug spew control
#define MODULE_ALWAYS_PRINT     0x0000000
#define MODULE_GENERAL          0x0000001
#define MODULE_FWD              0x0000002
#define MODULE_PROT             0x0000004
#define MODULE_MINI             0x0000008
#define MODULE_BUF              0x0000010
#define MODULE_STA              0x0000020
#define MODULE_COMPAT           0x0000040
#define MODULE_CTL              0x0000080
#define MODULE_TDI              0x0000100
#define MODULE_GPO              0x0000200

// Spew control flags
extern ULONG                    gSpewFlags;

#if DBG
// Interval for debug messages that risk flooding the debugger console (i.e.,
// per-packet status messages)
#define DBG_PRINT_INTERVAL      1000
extern ULONG                    gLastThrottledPrint;

extern BOOLEAN                  gSoftAssert;
extern LARGE_INTEGER            gTime;
extern const LARGE_INTEGER      gCorrection;
extern TIME_FIELDS              gTimeFields;

// HACKHACK: Calling RtlSystemTimeToLocalTime or ExSystemTimeToLocalTime appears to be
// forbidden for WDM drivers, so just subtract a constant amount from the system time
// to recover Pacific Time.
_inline VOID
BrdgDbgPrintDateTime()
{
    KeQuerySystemTime( &gTime );
    gTime.QuadPart -= gCorrection.QuadPart;
    RtlTimeToTimeFields( &gTime, &gTimeFields );
    DbgPrint( "%02i/%02i/%04i %02i:%02i:%02i : ", gTimeFields.Month, gTimeFields.Day,
              gTimeFields.Year, gTimeFields.Hour, gTimeFields.Minute,
              gTimeFields.Second );
}

#define DBGPRINT( Module, Args )                \
{                                               \
    if( (MODULE_ ## Module == MODULE_ALWAYS_PRINT) || (gSpewFlags & MODULE_ ## Module) )         \
    {                                           \
        DbgPrint( "## BRIDGE[" #Module "] " );  \
        BrdgDbgPrintDateTime();                 \
        DbgPrint Args;                          \
    }                                           \
}

#define SAFEASSERT( test )  \
if( ! (test) )              \
{                           \
    if( gSoftAssert )       \
    {                       \
        DBGPRINT(ALWAYS_PRINT, ("ASSERT FAILED: " #test " at " __FILE__ " line %i -- Continuing anyway!\n", __LINE__)); \
    }                       \
    else                    \
    {                       \
        ASSERT( test );     \
    }                       \
}

_inline BOOLEAN
BrdgCanThrottledPrint()
{
    ULONG               NowTime;

    NdisGetSystemUpTime( &NowTime );

    if( NowTime - gLastThrottledPrint > DBG_PRINT_INTERVAL )
    {
        // It's been longer than the interval
        gLastThrottledPrint = NowTime;
        return TRUE;
    }
    else
    {
        // It has not been longer than the interval
        return FALSE;
    }
}

#define THROTTLED_DBGPRINT( Module, Args ) if(BrdgCanThrottledPrint()) { DBGPRINT(Module, Args); }

#else

#define DBGPRINT( Module, Args )
#define THROTTLED_DBGPRINT( Module, Args )
#define SAFEASSERT( test )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgfwd.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgfwd.h

Abstract:

    Ethernet MAC level bridge.
    Forwarding engine section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgFwdDriverInit();

VOID
BrdgFwdCleanup();

NDIS_STATUS
BrdgFwdSendBuffer(
    IN PADAPT               pAdapt,
    IN PUCHAR               pPacketData,
    IN UINT                 DataSize
    );

// This serves as a ProtocolReceive function
NDIS_STATUS
BrdgFwdReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               pHeader,
    IN  UINT                HeaderSize,
    IN  PVOID               pLookAheadBuffer,
    IN  UINT                LookAheadSize,
    IN  UINT                PacketSize
    );

// This serves as a ProtocolTransferDataComplete function
VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    );

// This serves as a ProtocolReceivePacket function
INT
BrdgFwdReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet
    );

// This serves as a MiniportSendPackets function
NDIS_STATUS
BrdgFwdSendPacket(
    IN PNDIS_PACKET         pPacket
    );

// This serves as a ProtocolSendComplete function
VOID
BrdgFwdSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    );

// This serves as a MiniportReturnPacket function
VOID
BrdgFwdReturnIndicatedPacket(
    IN NDIS_HANDLE          MiniportAdapterContext,
    IN PNDIS_PACKET         pPacket
    );

// Compatibility-mode support functions
PNDIS_PACKET
BrdgFwdMakeCompatCopyPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PUCHAR             *pPacketData,
    OUT PUINT               packetDataSize,
    BOOLEAN                 bCountAsLocalSend
    );

VOID
BrdgFwdSendPacketForCompat(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

VOID BrdgFwdReleaseCompatPacket(
    IN PNDIS_PACKET         pPacket
    );

VOID
BrdgFwdIndicatePacketForCompat(
    IN PNDIS_PACKET         pPacket
    );

BOOLEAN
BrdgFwdBridgingNetworks();

VOID
BrdgFwdChangeBridging(
    IN BOOLEAN Bridging
    );

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

extern PHASH_TABLE          gMACForwardingTable;

// Thread synchronization
extern KEVENT               gThreadsCheckAdapters[MAXIMUM_PROCESSORS];

// Whether we hang on to NIC packets when possible or not
extern BOOLEAN              gRetainNICPackets;

// Statistics
extern LARGE_INTEGER        gStatTransmittedFrames;
extern LARGE_INTEGER        gStatTransmittedErrorFrames;
extern LARGE_INTEGER        gStatTransmittedBytes;
extern LARGE_INTEGER        gStatDirectedTransmittedFrames;
extern LARGE_INTEGER        gStatMulticastTransmittedFrames;
extern LARGE_INTEGER        gStatBroadcastTransmittedFrames;
extern LARGE_INTEGER        gStatDirectedTransmittedBytes;
extern LARGE_INTEGER        gStatMulticastTransmittedBytes;
extern LARGE_INTEGER        gStatBroadcastTransmittedBytes;
extern LARGE_INTEGER        gStatIndicatedFrames;
extern LARGE_INTEGER        gStatIndicatedDroppedFrames;
extern LARGE_INTEGER        gStatIndicatedBytes;
extern LARGE_INTEGER        gStatDirectedIndicatedFrames;
extern LARGE_INTEGER        gStatMulticastIndicatedFrames;
extern LARGE_INTEGER        gStatBroadcastIndicatedFrames;
extern LARGE_INTEGER        gStatDirectedIndicatedBytes;
extern LARGE_INTEGER        gStatMulticastIndicatedBytes;
extern LARGE_INTEGER        gStatBroadcastIndicatedBytes;

extern LARGE_INTEGER        gStatReceivedFrames;
extern LARGE_INTEGER        gStatReceivedBytes;
extern LARGE_INTEGER        gStatReceivedCopyFrames;
extern LARGE_INTEGER        gStatReceivedCopyBytes;
extern LARGE_INTEGER        gStatReceivedNoCopyFrames;
extern LARGE_INTEGER        gStatReceivedNoCopyBytes;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdghash.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdghash.c

Abstract:

    Ethernet MAC level bridge.
    Hash Table section

    This module implements a flexible hash table with support
    for timing out entries automatically

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    October  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgHashTimer(
    IN  PVOID                   DeferredContext
    );

PHASH_TABLE_ENTRY
BrdgHashInternalFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey
    );

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Interval at which the timer runs to clean out table entries
#define TIMER_INTERVAL          (10 * 1000)         // 10 seconds in milliseconds

// Maximum number of table entries the timer should look at each time through
#define MAX_TIMER_EXAMINES      1000

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Returns TRUE if the two keys of the given length are equal.
//
__forceinline
BOOLEAN
BrdgHashKeysAreEqual(
    IN PUCHAR                   pKeyA,
    IN PUCHAR                   pKeyB,
    IN UINT                     keyLen
    )
{
    BOOLEAN                     bEqual = TRUE;
    UINT                        i;

    for( i = 0; i < keyLen; i++ )
    {
        if( pKeyA[i] != pKeyB[i] )
        {
            bEqual = FALSE;
            break;
        }
    }

    return bEqual;
}

//
// Copies the data at pSrcKey to pDestKey
//
__forceinline
VOID
BrdgHashCopyKey(
    IN PUCHAR                   pDestKey,
    IN PUCHAR                   pSrcKey,
    IN UINT                     keyLen
    )
{
    UINT                        i;

    for( i = 0; i < keyLen; i++ )
    {
        pDestKey[i] = pSrcKey[i];
    }
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

PHASH_TABLE
BrdgHashCreateTable(
    IN PHASH_FUNCTION           pHashFunction,
    IN ULONG                    numBuckets,
    IN ULONG                    entrySize,
    IN ULONG                    maxEntries,
    IN ULONG                    startTimeoutAge,
    IN ULONG                    maxTimeoutAge,
    IN UINT                     keySize
    )
/*++

Routine Description:

    Initializes a hash table.

Arguments:

    pHashFunction               The function that can hash a key to a bucket number
    numBuckets                  The number of hash buckets to use
    entrySize                   The total size of each bucket entry (must be at
                                    least sizeof(HASH_TABLE_ENTRY) )
    maxEntries                  A maximum number of entries to enforce
    startTimeoutAge             The starting timeout value for table entries
                                    (can be changed later)
    maxTimeoutAge               The highest value the timeout age will ever be
                                    (for sanity checking timestamp delta
                                    calculations)
    keySize                     The size of key to use

Return Value:

    The new hash table or NULL if a memory allocation failed

--*/
{
    NDIS_STATUS                 Status;
    PHASH_TABLE                 pTable;
    ULONG                       i;

    SAFEASSERT( pHashFunction != NULL );
    SAFEASSERT( keySize <= MAX_SUPPORTED_KEYSIZE );
    SAFEASSERT( entrySize >= sizeof(HASH_TABLE_ENTRY) );

    // Allocate memory for the table info
    Status = NdisAllocateMemoryWithTag( &pTable, sizeof(HASH_TABLE), 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        return NULL;
    }

    SAFEASSERT( pTable != NULL );

    // Allocate memory for the list of bucket heads
    Status = NdisAllocateMemoryWithTag( (PVOID*)&pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * numBuckets, 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
        return NULL;
    }

    SAFEASSERT( pTable->pBuckets != NULL );

    // Zero out the bucket heads
    for( i = 0L; i < numBuckets; i++ )
    {
        pTable->pBuckets[i] = NULL;
    }

#if DBG
    // Allocate memory for the list where we keep track of the number
    // of items currently in each bucket (debug only)
    Status = NdisAllocateMemoryWithTag( &pTable->bucketSizes, sizeof(UINT) * numBuckets, 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * numBuckets, 0 );
        NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
        return NULL;
    }

    SAFEASSERT( pTable->bucketSizes != NULL );

    // Zero out the bucket counts
    for( i = 0L; i < numBuckets; i++ )
    {
        pTable->bucketSizes[i] = 0;
    }
#endif

    pTable->pHashFunction = pHashFunction;
    pTable->entrySize = entrySize;
    pTable->numBuckets = numBuckets;
    pTable->maxEntries = maxEntries;
    pTable->numEntries = 0L;
    pTable->nextTimerBucket = 0L;
    pTable->keySize = keySize;
    pTable->timeoutAge = startTimeoutAge;
    pTable->maxTimeoutAge = maxTimeoutAge;

    NdisInitializeReadWriteLock( &pTable->tableLock );

    // Initialize the lookaside list for allocating entries
    NdisInitializeNPagedLookasideList( &pTable->entryPool, NULL, NULL, 0, entrySize, 'hsaH', 0 );

    // Initialize and start the timer
    SAFEASSERT( pTable->timeoutAge != 0L );
    SAFEASSERT( pTable->maxTimeoutAge >= pTable->timeoutAge );
    BrdgInitializeTimer( &pTable->timer, BrdgHashTimer, pTable );
    BrdgSetTimer( &pTable->timer, TIMER_INTERVAL, TRUE /*Recurring*/ );

    return pTable;
}

VOID
BrdgHashFreeHashTable(
    IN PHASH_TABLE      pTable
    )
/*++

Routine Description:

    Frees an existing hash table structure. Must be called at
    low IRQL. Caller is responsible for ensuring that no other
    thread can access the table after this function is called.

Arguments:

    pTable              The table to free

Return Value:

    None

--*/
{
    // Cancel the timer
    BrdgShutdownTimer( &pTable->timer );

    // Dump all memory for the hash table entries
    NdisDeleteNPagedLookasideList( &pTable->entryPool );

    // Dump the memory used for the bucket heads
    NdisFreeMemory( pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * pTable->numBuckets, 0 );
    pTable->pBuckets = NULL;

#if DBG
    // Dump the memory used to track the number of entries in each bucket
    NdisFreeMemory( pTable->bucketSizes, sizeof(UINT) * pTable->numBuckets, 0 );
    pTable->bucketSizes = NULL;
#endif

    // Dump the memory for the table itself
    NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
}


PHASH_TABLE_ENTRY
BrdgHashFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    IN LOCK_STATE              *pLockState
    )
/*++

Routine Description:

    Finds the table entry with the given key.

    If this function returns with a non-NULL result, THE TABLE LOCK IS STILL HELD!

    This allows the table entry to be examined without the risk of it being removed
    from the table. The caller can copy out any data it is interested in before
    releasing the RW lock

Arguments:

    pTable                      The table to search in
    pKey                        The key to find
    pLockState                  Receives the table lock state


Return Value:

    The entry whose key matches pKey or NULL if no entry matches

--*/
{
    PHASH_TABLE_ENTRY           pEntry;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, pLockState);

    pEntry = BrdgHashInternalFindEntry(pTable, pKey);

    if( pEntry != NULL )
    {
        ULONG                   LastSeen = pEntry->LastSeen;
        ULONG                   CurrentTime;

        // Always get the current time after having read LastSeen so we know that
        // CurrentTime > LastSeen.
        NdisGetSystemUpTime( &CurrentTime );

        // Check to make sure the entry hasn't expired before using it
        // This can happen if our timer function hasn't gotten around to removing
        // this entry yet
        //
        // There is no sensible maximum removal time for hash table entries
        if( BrdgDeltaSafe(LastSeen, CurrentTime, MAXULONG) >= pTable->timeoutAge )
        {
            // We're going to return NULL, so release the table lock
            NdisReleaseReadWriteLock( &pTable->tableLock, pLockState );
            pEntry = NULL;
        }
        else
        {
            // RETURN WITHOUT RELEASING LOCK!
        }
    }
    else
    {
        NdisReleaseReadWriteLock( &pTable->tableLock, pLockState );
    }

    return pEntry;
}

PHASH_TABLE_ENTRY
BrdgHashRefreshOrInsert(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    OUT BOOLEAN                *pIsNewEntry,
    OUT PLOCK_STATE             pLockState
    )
/*++

Routine Description:

    Inserts a new entry with the given key or refreshes an existing entry
    that already has that key.

    Care is taken to avoid taking a write lock (and blocking other procs
    from accessing the table) if at all possible.

    The return value is the entry corresponding to the key, or the new
    entry that has been linked into the table; the pIsNewEntry value
    distinguishes the cases.

    THE FUNCTION RETURNS WITH THE TABLE LOCK IS HELD IF THE RETURNED
    VALUE IS != NULL.

    A NULL return value indicates that the table is full or an error
    occured allocating a new entry. The lock is not held in such a case.

    If the return value is not NULL:

        If *pIsNewEntry is FALSE, the returned value is an existing entry.
        A READ LOCK may be held (under certain circumstances a write lock
        is held, but the caller should assume the weaker lock). The
        caller may  take the opportunity to refresh data in the existing
        entry, but he should take care to allow for synchronization of the
        data, as other threads may be reading the data.

        If *pIsNewEntry is TRUE, the returned value is a new entry, and
        a WRITE LOCK is held. The caller may initialize the new table entry
        in any way he wishes without worrying about other threads reading
        the entry.

    THE CALLER IS REPONSIBLE FOR FREEING THE TABLE LOCK IF THE RETURN
    VALUE IS != NULL!

Arguments:

    pTable                      The table

    pKey                        The key

    pIsNewEntry                 TRUE if the returned entry is a newly
                                    allocated entry needing initialization
                                FALSE if the returned entry is an existing
                                    entry

    pLockState                  Receives the state of the table lock

Return Value:

    The existing entry (so the caller can refresh it) or the new entry
    (so the caller can initialize it), or NULL, signalling that the
    table is full or an error occurred.

--*/
{
    PHASH_TABLE_ENTRY           pRetVal = NULL;
    ULONG                       hash;
    ULONG                       CurrentTime;

    SAFEASSERT( pIsNewEntry != NULL );
    SAFEASSERT( pLockState != NULL );

    NdisGetSystemUpTime( &CurrentTime );

    // First see if an entry already exists that we can tweak without taking a write lock
    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, pLockState);

    pRetVal = BrdgHashInternalFindEntry(pTable, pKey);

    if( pRetVal != NULL )
    {
        // It was already recorded. Update the LastSeen with interlocked instructions.
        InterlockedExchangeULong( &pRetVal->LastSeen, CurrentTime );

        // Return without releasing the lock to let the caller refresh the entry
        *pIsNewEntry = FALSE;
    }
    else
    {
        // Sanity
        SAFEASSERT( pTable->numEntries <= pTable->maxEntries );

        if( pTable->numEntries == pTable->maxEntries )
        {
            // The table is full. Don't put anything more in.
            THROTTLED_DBGPRINT(GENERAL, ("Table %p full at %i entries!\n", pTable, pTable->maxEntries));

            // Release the lock; we will return NULL.
            NdisReleaseReadWriteLock(&pTable->tableLock, pLockState);
        }
        else
        {
            // We will need a write lock to link in a new entry, so release the read lock.
            NdisReleaseReadWriteLock(&pTable->tableLock, pLockState);

            // Allocate the new table entry outside a lock for perf. Note that it's possible
            // we'll have to dealloc this without using it below.
            pRetVal = NdisAllocateFromNPagedLookasideList( &pTable->entryPool );

            if( pRetVal == NULL )
            {
                DBGPRINT(GENERAL, ("Allocation failed in BrdgHashRefreshOrInsert\n"));
                // We will return NULL and we are not holding the lock.
            }
            else
            {
                PHASH_TABLE_ENTRY       pSneakedEntry;

                // Fill in the new entry
                pRetVal->LastSeen = CurrentTime;
                BrdgHashCopyKey( pRetVal->key, pKey, pTable->keySize );

                // We will need a write lock to add the entry
                NdisAcquireReadWriteLock(&pTable->tableLock, TRUE /*Read-Write*/, pLockState);

                // An entry could have been made between the release of the read lock
                // and the acquisition of the write lock. Check for this.
                pSneakedEntry = BrdgHashInternalFindEntry(pTable, pKey);

                if( pSneakedEntry != NULL )
                {
                    // Someone snuck in with a new entry for this key.
                    // This code path should be unusual. Just refresh the entry's values.
                    InterlockedExchangeULong( &pSneakedEntry->LastSeen, CurrentTime );

                    // Ditch the tentatively allocated new entry
                    NdisFreeToNPagedLookasideList( &pTable->entryPool, pRetVal );

                    // We will return the sneaked entry and the caller can refresh it
                    pRetVal = pSneakedEntry;
                    *pIsNewEntry = FALSE;
                }
                else
                {
                    // Nobody snuck in between the lock release and acquire to make a new
                    // entry for this key. Link in the new entry we alloced above.
                    hash = (*pTable->pHashFunction)(pKey);

                    // Insert at the head of the bucket's list
                    pRetVal->Next = pTable->pBuckets[hash];
                    pTable->pBuckets[hash] = pRetVal;
#if DBG
                    pTable->bucketSizes[hash]++;
#endif
                    pTable->numEntries++;

                    // We will return the new entry, which the caller will initialize.
                    *pIsNewEntry = TRUE;
                }

                // Return without the lock to let the user initialize or update the entry
            }
        }
    }

    return pRetVal;
}


VOID
BrdgHashRemoveMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    PVOID                       pData
    )
/*++

Routine Description:

    Deletes all table entries that match, according to a supplied matching
    function. This should be called sparingly as it requies walking the
    entire table with a write lock held.

Arguments:

    pTable                      The table

    pMatchFunc                  A function that return TRUE if an entry meets
                                    its criteria or FALSE otherwise

    pData                       A cookie to pass to pMatchFunc

Return Value:

    None

--*/
{
    PHASH_TABLE_ENTRY           pEntry, *pPrevPtr;
    ULONG                       i;
    LOCK_STATE                  LockState;

    NdisAcquireReadWriteLock( &pTable->tableLock, TRUE /*Write access*/, &LockState);

    for (i = 0; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];
        pPrevPtr = &pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            if( (*pMatchFunc)(pEntry, pData) )
            {
                PHASH_TABLE_ENTRY      pNextEntry;

                pNextEntry = pEntry->Next;

                // Remove from the list
                SAFEASSERT( pPrevPtr != NULL );
                *pPrevPtr = pEntry->Next;

                // Deallocate
                NdisFreeToNPagedLookasideList( &pTable->entryPool, pEntry );

                pEntry = pNextEntry;
#if DBG
                pTable->bucketSizes[i]--;
#endif
                SAFEASSERT( pTable->numEntries >= 1L );
                pTable->numEntries--;
            }
            else
            {
                pPrevPtr = &pEntry->Next;
                pEntry = pEntry->Next;
            }
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}

ULONG
BrdgHashCopyMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    IN PHASH_COPY_FUNCTION      pCopyFunction,
    IN ULONG                    copyUnitSize,
    IN PVOID                    pData,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    )
/*++

Routine Description:

    Copies data out of table entries that meet certain criteria into a buffer.
    This should be called sparingly, as it requires walking the entire
    table (albeit with only a read lock held).

Arguments:

    pTable                      The table
    pMatchFunc                  A function that returns TRUE if it is
                                    interested in copying data out of an
                                    entry and FALSE otherwise
    pCopyFunction               A function that copies whatever it is
                                    interested in out of a chosen entry
                                    and into a data buffer
    copyUnitSize                The size of the data copied out of each entry
    pData                       A cookie to pass to the two supplied functions
    pBuffer                     A buffer to copy into
    BufferLength                Room available at pBuffer

Return Value:

    The number of bytes necessary to store all matching data. If the returned value is
    <= BufferLength, all entries  were written to pBuffer.

    If the returned value is > BufferLength, BufferLength - (BufferLength %  copyUnitSize)
    bytes were written to pBuffer and there are additional entries that did not fit.

--*/
{
    PHASH_TABLE_ENTRY           pEntry;
    ULONG                       i;
    LOCK_STATE                  LockState;
    ULONG                       EntryLimit, WrittenEntries, TotalEntries;

    EntryLimit = BufferLength / copyUnitSize;
    WrittenEntries = TotalEntries = 0L;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE/*Read only*/, &LockState);

    for (i = 0L; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            if( (*pMatchFunc)(pEntry, pData) )
            {
                if( WrittenEntries < EntryLimit )
                {
                    (*pCopyFunction)(pEntry, pBuffer);
                    pBuffer += copyUnitSize;
                    WrittenEntries++;
                }

                TotalEntries++;
            }

            pEntry = pEntry->Next;
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );

    return TotalEntries * copyUnitSize;
}

VOID
BrdgHashPrefixMultiMatch(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pPrefixKey,
    IN UINT                     prefixLen,
    IN PMULTIMATCH_FUNC         pFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Locates all table entries whose keys BEGIN with the given key
    prefix and calls pFunc for each one.

    For this to work, the caller must have previously set up the
    hash table with a hash function that uses only the prefix portion
    of the keys for hashing (i.e., this function relies on all the
    desired entries being in the same hash bucket).

Arguments:

    pTable                      The table
    pPrefixKey                  The key prefix
    prefixLen                   The length of the prefix
    pFunc                       A function to call for each match
    pData                       An argument to pass to pFunc

Return Value:

    None.

--*/
{
    ULONG                       hash = (*pTable->pHashFunction)(pPrefixKey);
    PHASH_TABLE_ENTRY           pEntry = NULL;
    LOCK_STATE                  LockState;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, &LockState );

    SAFEASSERT( hash < pTable->numBuckets );
    SAFEASSERT( prefixLen <= pTable->keySize );

    pEntry = pTable->pBuckets[hash];

    while( pEntry != NULL )
    {
        // Check if the prefix of the key matches
        if( BrdgHashKeysAreEqual(pEntry->key, pPrefixKey, prefixLen) )
        {
            (*pFunc)(pEntry, pData);
        }

        pEntry = pEntry->Next;
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

PHASH_TABLE_ENTRY
BrdgHashInternalFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey
    )
/*++

Routine Description:

    Locates the table entry with a given key

    CALLER IS RESPONSIBLE FOR OBTAINING THE TABLE LOCK

Arguments:

    pTable                      The table
    pKey                        The key to locate

Return Value:

    The entry matching the given key or NULL if none was found.

--*/
{
    ULONG                       hash = (*pTable->pHashFunction)(pKey);
    PHASH_TABLE_ENTRY           pEntry = NULL, pFoundEntry = NULL;

    SAFEASSERT( hash < pTable->numBuckets );

    pEntry = pTable->pBuckets[hash];

    while( pEntry != NULL )
    {
        if( BrdgHashKeysAreEqual(pEntry->key, pKey, pTable->keySize) )
        {
            pFoundEntry = pEntry;
            break;
        }

        pEntry = pEntry->Next;
    }

    return pEntry;
}

VOID
BrdgHashTimer(
    IN  PVOID                   tablePointer
    )
/*++

Routine Description:

    This function is called periodically (currently every 10 seconds)
    to age out table entries.

    The function checks after traversing each bucket whether it has
    examined more than MAX_TIMER_EXAMINES. If it has, it exits. The bucket
    to be examined on the next invocation is stored in the nextTimerBucket
    field of the hash table..

    This can still result in a worst-case of the timer function examining
    an unbounded number of entries, but if the table entries are reasonably
    well balanced and the order of the number of entries is the same or less
    as the order of MAX_TIMER_EXAMINES, the timer function should limit
    itself to a number of examines resembling MAX_TIMER_EXAMINES per
    invocation.

Arguments:

    tablePointer                A pointer to the table to traverse
    All others                  Ignored

Return Value:

    None

--*/
{
    PHASH_TABLE                 pTable = (PHASH_TABLE)tablePointer;
    PHASH_TABLE_ENTRY           pEntry, *pPrevPtr;
    ULONG                       i, seenEntries = 0L;
    LOCK_STATE                  LockState;

    // Get write access to the table
    NdisAcquireReadWriteLock( &pTable->tableLock, TRUE /*Read-Write*/, &LockState);

    if( pTable->nextTimerBucket >= pTable->numBuckets )
    {
        // Start again at the beginning
        pTable->nextTimerBucket = 0L;
    }

    for (i = pTable->nextTimerBucket; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];
        pPrevPtr = &pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            ULONG       LastSeen = pEntry->LastSeen;
            ULONG       CurrentTime;

            // Always read the current time after reading LastSeen, so we know
            // CurrentTime > LastSeen.
            NdisGetSystemUpTime( &CurrentTime );

            // There is no sensible maximum removal time for hash table entries
            if( BrdgDeltaSafe(LastSeen, CurrentTime, MAXULONG) >= pTable->timeoutAge )
            {
                // Entry is too old. Remove it.
                PHASH_TABLE_ENTRY       pNextEntry = pEntry->Next;

                SAFEASSERT( pPrevPtr != NULL );

                // Remove from list
                *pPrevPtr = pNextEntry;
                NdisFreeToNPagedLookasideList( &pTable->entryPool, pEntry );

                pEntry = pNextEntry;
#if DBG
                pTable->bucketSizes[i]--;
#endif
                SAFEASSERT( pTable->numEntries >= 1L );
                pTable->numEntries--;
            }
            else
            {
                pPrevPtr = &pEntry->Next;
                pEntry = pEntry->Next;
            }

            seenEntries++;
        }

        pTable->nextTimerBucket = i + 1;

        if( seenEntries >= MAX_TIMER_EXAMINES )
        {
            // We've looked at too many table entries. Bail out.
            break;
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdggpo.h ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.h

Abstract:

    Ethernet MAC level bridge.
    Gpo registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/

// ===========================================================================
//
// DEFINES
//
// ===========================================================================

#define MAX_GUID_LEN                39
#define MAX_IP4_STRING_LEN          17
#define BRDG_ON_SAME_NETWORK        TRUE
#define BRDG_ON_DIFFERENT_NETWORK   FALSE
#define BRDG_STATUS_EMPTY_LIST      ((NTSTATUS)(0x0000000F))

// ===========================================================================
//
// TYPES
//
// ===========================================================================

typedef struct _BRDG_GPO_NETWORKS BRDG_GPO_NETWORKS, *PBRDG_GPO_NETWORKS;

typedef struct _BRDG_GPO_NETWORKS
{
    LIST_ENTRY                  ListEntry;
    PUNICODE_STRING             Identifier;
    PUNICODE_STRING             NetworkName;
} BRDG_GPO_NETWORKS, *PBRDG_GPO_NETWORKS;

typedef struct _BRDG_GPO_THREAD_PARAMS
{
    PLIST_ENTRY                 NotifyList;
    PNDIS_RW_LOCK               NotifyListLock;
    PKEVENT                     NotifyEvent;
    PKEVENT                     KillEvent;
} BRDG_GPO_THREAD_PARAMS, *PBRDG_GPO_THREAD_PARAMS;

typedef struct _BRDG_GPO_GLOBALS
{
    UNICODE_STRING              GroupPolicyNetworkName;
    BOOLEAN                     RegisteredForGroupPolicyChanges;
    BOOLEAN                     RegisteredForGroupPolicyHistoryChanges;
    BOOLEAN                     RegisteredForNetworkConnectionsGroupPolicyChanges;
    BOOLEAN                     PolicyBridge;
    BOOLEAN                     WaitingOnSoftwareHive;
    BOOLEAN                     ProcessingNotifications;
    PNDIS_RW_LOCK               NetworkListLock;
    BRIDGE_TIMER                RegistrationTimer;
    PLIST_ENTRY                 ListHeadNetworks;
    PLIST_ENTRY                 ListHeadNotify;
    PNDIS_RW_LOCK               NotifyListLock;
    HANDLE                      NotificationsThread;
    BRDG_GPO_THREAD_PARAMS      QueueInfo;
} BRDG_GPO_GLOBALS, *PBRDG_GPO_GLOBALS;

// The joys of a multi-pass compiler allow us to not have 
// to forward declare this.  If you need a single pass compile
// you'll have to add a forward to the struct below.
typedef VOID (*PBRDG_GPO_REG_CALLBACK)(PBRDG_GPO_NOTIFY_KEY);

typedef NTSTATUS (*PBRDG_GPO_REGISTER)();

typedef struct _BRDG_GPO_NOTIFY_KEY
{
    LIST_ENTRY                  ListEntry;
    HANDLE                      RegKey;
    ULONG                       Buffer;
    ULONG                       BufferSize;
    IO_STATUS_BLOCK             IoStatus;
    UNICODE_STRING              RegValue;
    UNICODE_STRING              RegKeyName;
    UNICODE_STRING              Identifier;
    WORK_QUEUE_ITEM             RegChangeWorkItem;
    PVOID                       WorkItemContext;
    BOOLEAN                     Recurring;
    PBRDG_GPO_REG_CALLBACK      FunctionCallback;
    BOOLEAN                     WatchTree;
    ULONG                       CompletionFilter;
    BOOLEAN                     Modified;
    PBOOLEAN                    SuccessfulRegistration;
    WAIT_REFCOUNT               RefCount;
    LONG                        PendingNotification;
    PBRDG_GPO_REGISTER          FunctionRegister;
} BRDG_GPO_NOTIFY_KEY, *PBRDG_GPO_NOTIFY_KEY;

typedef struct _BRDG_GPO_QUEUED_NOTIFY
{
    LIST_ENTRY                  ListEntry;
    PBRDG_GPO_NOTIFY_KEY        Notify;
} BRDG_GPO_QUEUED_NOTIFY, *PBRDG_GPO_QUEUED_NOTIFY;


// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgGpoDriverInit();

VOID
BrdgGpoCleanup();

NTSTATUS
BrdgGpoNewAddressNotification(
    IN PWSTR    DeviceId
    );

NTSTATUS
BrdgGpoNotifyRegKeyChange(
    IN      PBRDG_GPO_NOTIFY_KEY    Notify,
    IN      PIO_APC_ROUTINE         ApcRoutine,
    IN      PVOID                   ApcContext,
    IN      ULONG                   CompletionFilter,
    IN      BOOLEAN                 WatchTree);

NTSTATUS
BrdgGpoInitializeNetworkList();

VOID
BrdgGpoUninitializeNetworkList();

VOID
BrdgGpoAcquireNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN      BOOLEAN          fWrite,
    IN OUT  PLOCK_STATE      LockState);

VOID
BrdgGpoReleaseNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN OUT  PLOCK_STATE      LockState);

NTSTATUS
BrdgGpoAllocateAndInitializeNetwork(
    IN OUT PBRDG_GPO_NETWORKS*  Network,
    IN PWCHAR                   Identifier,
    IN PWCHAR                   NetworkName);

NTSTATUS
BrdgGpoInsertNetwork(
    IN      PLIST_ENTRY         NetworkList,
    IN      PLIST_ENTRY         Network,
    IN      PNDIS_RW_LOCK       NetworkListLock);

VOID
BrdgGpoFreeNetworkAndData(
    IN      PBRDG_GPO_NETWORKS  Network);

NTSTATUS
BrdgGpoDeleteNetwork(
    IN      PLIST_ENTRY         NetworkList,
    IN      PUNICODE_STRING     NetworkIdentifier,
    IN      PNDIS_RW_LOCK       NetworkListLock);
                     
NTSTATUS
BrdgGpoFindNetwork(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         NetworkIdentifier,
    IN  PNDIS_RW_LOCK           NetworkListLock,
    OUT PBRDG_GPO_NETWORKS*     Network);

NTSTATUS
BrdgGpoMatchNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock);

NTSTATUS
BrdgGpoUpdateNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         Identifier,
    IN  PWCHAR                  NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock);
                         
NTSTATUS
BrdgGpoEmptyNetworkList(
    IN OUT  PLIST_ENTRY         NetworkList,
    IN      PNDIS_RW_LOCK       NetworkListLock);

NTSTATUS BrdgGpoGetCurrentNetwork(
    IN  PUNICODE_STRING RegKeyName,
    OUT PWCHAR*         NetworkName);


//
// Notify filter values
//
#define REG_NOTIFY_CHANGE_NAME          (0x00000001L) // Create or delete (child)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L) // time stamp
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
    (REG_NOTIFY_CHANGE_NAME          |\
    REG_NOTIFY_CHANGE_ATTRIBUTES    |\
    REG_NOTIFY_CHANGE_LAST_SET      |\
REG_NOTIFY_CHANGE_SECURITY)

typedef enum _REG_ACTION {
        KeyAdded,
        KeyRemoved,
        KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION {
    ULONG           NextEntryOffset;
    REG_ACTION      Action;
    ULONG           KeyLength;
    WCHAR           Key[1];     // Variable size
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

NTSTATUS
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdggpo.c ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdggpo.c

Abstract:

    Ethernet MAC level bridge.
    Group Policy code for Network Bridge.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    April  2002 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <tdikrnl.h>
#include <ntstatus.h>
#include <wchar.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdggpo.h"

#include "brdgsta.h"
#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdgtdi.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

BRDG_GPO_GLOBALS g_BrdgGpoGlobals;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

const WCHAR HiveListKey[]           = {L"\\Registry\\Machine\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\HIVELIST"};
const WCHAR SoftwareHiveKey[]       = {L"\\REGISTRY\\MACHINE\\SOFTWARE"};
const WCHAR PolicyBaseKey[]         = {L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows"};
const WCHAR NetworkPoliciesKey[]    = {L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows\\Network Connections"};
const WCHAR GroupPolicyKey[]        = {L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy"};
const WCHAR BridgePolicyValue[]     = {L"NC_AllowNetBridge_NLA"};
const WCHAR TcpipInterfacesKey[]    = {L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"};
const WCHAR HistoryKey[]            = {L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"};

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
static
BrdgGpoRegNotify(
    IN  PVOID               Context
    );

NTSTATUS
BrdgGpoBuildNotifyForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify,
    IN LPWSTR                   Identifier,
    IN LPWSTR                   RegKeyName,
    IN LPWSTR                   RegValueName,
    IN PWORKER_THREAD_ROUTINE   ApcRoutine,
    IN PVOID                    ApcContext,
    IN ULONG                    CompletionFilter,
    IN BOOLEAN                  WatchTree,
    IN PBRDG_GPO_REG_CALLBACK   FunctionCallback,
    IN BOOLEAN                  Recurring,
    IN PBOOLEAN                 SuccessfulRegistration,
    IN PBRDG_GPO_REGISTER       FunctionRegister);
                                  
NTSTATUS
BrdgGpoRegisterForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify);

NTSTATUS
BrdgGpoRequestNotification(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoProcessNotifications(
IN PVOID                Context);

PLIST_ENTRY
BrdgGpoGetNotifyListHead();

PKEVENT
BrdgGpoGetNotifyEvent();

PKEVENT
BrdgGpoGetKillEvent();

PNDIS_RW_LOCK
BrdgGpoGetNotifyListLock();

NTSTATUS
BrdgGpoFindNotify(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_RW_LOCK           ListLock,
    IN  LPWSTR                  Identifier,
    OUT PBRDG_GPO_NOTIFY_KEY*   Notify
    );

NTSTATUS
BrdgGpoInitializeNotifyList(
    OUT PLIST_ENTRY*    ListHead,
    OUT PNDIS_RW_LOCK*  ListLock,
    OUT PKEVENT*        WaitEvent,
    OUT PKEVENT*        KillEvent);

VOID
BrdgGpoFreeNotifyList();

BOOLEAN
BrdgGpoAllowedToBridge();

VOID
BrdgGpoUpdateBridgeMode(
    BOOLEAN NetworkMatch);

VOID
BrdgGpoCheckForMatchAndUpdateMode();

NTSTATUS
BrdgGpoRegisterForGroupPolicyNetworkNameNotification();

NTSTATUS
BrdgGpoRegisterForWindowsGroupPolicyNotification();

NTSTATUS
BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();

NTSTATUS
BrdgGpoRegisterForGroupPolicyNotification();

VOID
BrdgGpoRegisterForHiveListNotification();

NTSTATUS
BrdgGpoAllocateAndInitializeNotifyStruct(
    OUT PBRDG_GPO_NOTIFY_KEY* Notify);

NTSTATUS 
BrdgGpoUpdateGroupPolicyNetworkName();

VOID
BrdgGpoFreeNotifyStructAndData(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

BOOLEAN
BrdgGpoWaitingOnSoftwareHive();
                                
//
// We need this if the regkey for Network Connections Group Policy doesn't exist yet.
//

VOID
BrdgGpoWindowsGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoNetworkConnectionsGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoTcpipInterfacesChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoGroupPolicyNetworkNameChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoHiveListCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryNetworkConnectionsValue(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryTcpipInterfacesValues(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryGroupPolicyNetworkName(
    IN PBRDG_GPO_NOTIFY_KEY Notify);


// ===========================================================================
//
// BRIDGE GPO IMPLEMENTATION
//
// ===========================================================================

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGELK, BrdgGpoRegNotify) 
#endif 

NTSTATUS
BrdgGpoDriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            status;
    HANDLE              ThreadHandle;

    DBGPRINT(GPO, ("BrdgGpoDriverInit\r\n"));

    g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer = NULL;

    status = BrdgGpoInitializeNetworkList();

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to initialize Network List\r\n"));
        goto cleanup;
    }

    status = BrdgGpoInitializeNotifyList(   &g_BrdgGpoGlobals.QueueInfo.NotifyList,
                                            &g_BrdgGpoGlobals.QueueInfo.NotifyListLock,
                                            &g_BrdgGpoGlobals.QueueInfo.NotifyEvent,
                                            &g_BrdgGpoGlobals.QueueInfo.KillEvent);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to initialize Notify List\r\n"));
        goto cleanup;
    }
    
    //
    // Since the Software hive is not up at this point, we use this to make sure we only register for
    // Group Policy changes once (we'll handle this in the Add Address notification, since the software
    // hive is up by the time this gets called.  Will check with reg guys to see if there's a way to know
    // when the software hive is up.  We'll use the timer to re-attempt the registration until it is up.
    //
    
    g_BrdgGpoGlobals.NotificationsThread = NULL;
    g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges = FALSE;
    g_BrdgGpoGlobals.WaitingOnSoftwareHive = TRUE;

    // Create a thread for handling the notifications.
    status = PsCreateSystemThread(  &ThreadHandle,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    BrdgGpoProcessNotifications,
                                    &g_BrdgGpoGlobals.QueueInfo);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to created Notification Processing thread\r\n"));
        goto cleanup;
    }
    
    // Retrieve a pointer to the thread object and reference it so we can wait for
    // its termination safely.
    status = ObReferenceObjectByHandle( ThreadHandle, STANDARD_RIGHTS_ALL, NULL, KernelMode,
                                        &g_BrdgGpoGlobals.NotificationsThread, NULL );

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to reference thread handle\r\n"));
        goto cleanup;
    }
    
cleanup:

    if (!NT_SUCCESS(status))
    {
        BrdgGpoCleanup();
    }
 
    return status;
}

VOID
BrdgGpoCleanup()
/*++

Routine Description:

    Driver shutdown cleanup

Return Value:

    None

Locking Constraints:

Top-level function. Assumes no locks are held by caller.
            
--*/
{
    NTSTATUS                status;
    PNPAGED_LOOKASIDE_LIST  LookasideQueueList;
    LOCK_STATE              LockState;
    PLIST_ENTRY             pListEntry;
    PNDIS_RW_LOCK           ListLock;
    PLIST_ENTRY             ListHead;
    PLIST_ENTRY             QueuedList;
    PBRDG_GPO_QUEUED_NOTIFY QueuedNotify;

    DBGPRINT(GPO, ("BrdgGpoCleanup\r\n"));

    g_BrdgGpoGlobals.ProcessingNotifications = FALSE;
    
    LookasideQueueList = ExAllocatePoolWithTag(NonPagedPool, sizeof(NPAGED_LOOKASIDE_LIST), 'gdrB');
    if (NULL == LookasideQueueList)
    {
        return;
    }

    QueuedList = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL == QueuedList)
    {
        ExFreePool(LookasideQueueList);
        return;
    }

    ListHead = BrdgGpoGetNotifyListHead();
    ListLock = BrdgGpoGetNotifyListLock();

    ExInitializeNPagedLookasideList(LookasideQueueList, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    sizeof(BRDG_GPO_QUEUED_NOTIFY), 
                                    'grbQ',
                                    0);

    InitializeListHead(QueuedList);

    DBGPRINT(GPO, ("Acquiring Read-Write Lock and clearing list\r\n"));
    //
    // We use a temporary list to close each key, since we can't close them at
    // DISPATCH_LEVEL
    //
    NdisAcquireReadWriteLock(ListLock, TRUE /* Write-access */, &LockState);

    //
    // Loop through the list of notifications that we have.
    //
    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    Notify;

        Notify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);

        //
        // We're going to be shutting this down soon, so block it now
        // so that no-one else can increment this.
        //
        BrdgBlockWaitRef(&Notify->RefCount);

        //
        // We don't want any notifications the fire to run either.
        //
        Notify->Recurring = FALSE;

        QueuedNotify = ExAllocateFromNPagedLookasideList(LookasideQueueList);
        QueuedNotify->Notify = Notify;

        InsertTailList(QueuedList, &QueuedNotify->ListEntry);
    }
    
    while (!IsListEmpty(ListHead))
    {
        //
        // We'll be freeing this from our sencondary list.
        //
        pListEntry = RemoveHeadList(ListHead);
    }

    NdisReleaseReadWriteLock(ListLock, &LockState);

    DBGPRINT(GPO, ("Closing and Freeing Notifications\r\n"));
    
    //
    // We're back at PASSIVE_LEVEL so we can now do the registration for the changes.
    //
    
    for (pListEntry = QueuedList->Flink; pListEntry != QueuedList; pListEntry = pListEntry->Flink)
    {
        HANDLE                  hKey;
        PBRDG_GPO_NOTIFY_KEY    Notify;

        QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);
        
        Notify = QueuedNotify->Notify;
        
        DBGPRINT(GPO, ("Closing Regkey and Freeing Notification: %S\r\n", Notify->Identifier.Buffer));
        
        hKey = Notify->RegKey;
        Notify->RegKey = NULL;

        if (hKey)
        {
            ZwClose(hKey);
        }
        
        DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", Notify->Identifier.Buffer, Notify->RefCount.Refcount));

        //
        // Since we're freeing this notification, we decrement the refcount
        //
        BrdgDecrementWaitRef(&Notify->RefCount);
        
        //
        // This will block until the ref count is zero.  Any attempts to increment the waitref will
        // fail.
        //
        BrdgShutdownWaitRef(&Notify->RefCount);

        //
        // We NULL these out so that the free routine below doesn't try to remove us from
        // the notify list.
        //
        QueuedNotify->Notify->ListEntry.Blink = NULL;
        QueuedNotify->Notify->ListEntry.Flink = NULL;
        
        //
        // Free the data associated with this struct, and the struct itself.
        //
        BrdgGpoFreeNotifyStructAndData(QueuedNotify->Notify);
    }

    //
    // Free the temporary list.
    //
    while (!IsListEmpty(QueuedList))
    {
        pListEntry = RemoveHeadList(QueuedList);

        QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);

        ExFreeToNPagedLookasideList(LookasideQueueList, QueuedNotify);
    }

    if (g_BrdgGpoGlobals.NotificationsThread)
    {
        //
        // Set the Event to kill the thread so that the notifications are no longer waiting.
        //
        KeSetEvent(BrdgGpoGetKillEvent(), EVENT_INCREMENT, TRUE);
        status = KeWaitForSingleObject(g_BrdgGpoGlobals.NotificationsThread, Executive, KernelMode, TRUE, NULL);

        KeLowerIrql(0);

        //
        // De-reference the thread handle to allow the thread to be destroyed.
        //
        ObDereferenceObject(g_BrdgGpoGlobals.NotificationsThread);

        SAFEASSERT(NT_SUCCESS(status));
    }


    DBGPRINT(GPO, ("Freeing List structures\r\n"));

    ExDeleteNPagedLookasideList(LookasideQueueList);

    ExFreePool(LookasideQueueList);
    ExFreePool(QueuedList);

    //
    // Free any remaining data.
    //
    if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
    {
        ExFreePool(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
    }

    status = BrdgGpoEmptyNetworkList(g_BrdgGpoGlobals.ListHeadNetworks, g_BrdgGpoGlobals.NetworkListLock);
    SAFEASSERT(NT_SUCCESS(status));

    if (g_BrdgGpoGlobals.ListHeadNetworks)
    {
        ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
    }
    if (g_BrdgGpoGlobals.NetworkListLock)
    {
        ExFreePool(g_BrdgGpoGlobals.NetworkListLock);
    }

    BrdgGpoFreeNotifyList();

    DBGPRINT(GPO, ("BrdgGpoCleanup complete\r\n"));
}

BOOLEAN
BrdgGpoWaitingOnSoftwareHive()
{
    return g_BrdgGpoGlobals.WaitingOnSoftwareHive;
}

NTSTATUS
BrdgGpoRegisterForAdapterAddressChangeNotification(
    IN  LPWSTR                  NetworkIdentifier,
    IN  LPWSTR                  RegKeyName)
{
    NTSTATUS                status;
    PBRDG_GPO_NOTIFY_KEY    Notify;

    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                NetworkIdentifier,
                                &Notify);
    
    if (NT_SUCCESS(status) && (STATUS_OBJECT_NAME_EXISTS != status))
    {
        UNICODE_STRING      RegKey;

        RtlInitUnicodeString(&RegKey, RegKeyName);

        if ((STATUS_OBJECT_NAME_EXISTS != status) && NT_SUCCESS(status))
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);

            if (NT_SUCCESS(status))
            {
                Notify->Recurring = TRUE;

                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            NetworkIdentifier,
                                                            RegKeyName,
                                                            L"DhcpDomain",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoTcpipInterfacesChangeCallback,
                                                            TRUE,
                                                            NULL,
                                                            NULL);

            }
        }
    }

    if (NT_SUCCESS(status))
    {
        SAFEASSERT(Notify);
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif
    }

    return status;
}

NTSTATUS
BrdgGpoNewAddressNotification(
    IN PWSTR    DeviceId
    )
/*++

Routine Description:

    Called when a our TDI AddAddress handler receives a new IP Address.

Arguments:
    DeviceID - GUID Identifying the adapter

Return Value:

    NTSTATUS - Possible values include:
                STATUS_INSUFFICIENT_RESOURCES (not enough memory)
                STATUS_SUCCESS
                

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;

    DBGPRINT(GPO, ("BrdgGpoNewAddressNotification\r\n"));
    
    if (FALSE == g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges)
    {
        BrdgGpoRegisterForHiveListNotification();
        BrdgGpoRegisterForGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();

        g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges = TRUE;        
    }

    DBGPRINT(GPO, ("Device: %S\r\n", DeviceId));

    if (NULL != DeviceId)
    {
        PBRDG_GPO_NETWORKS  Network = NULL;
        UNICODE_STRING      RegKey;
        PWCHAR              NetworkIdentifier = NULL;
        PWCHAR              RegNetworkName = NULL;
        PWCHAR              NetworkName = NULL;
        ULONG               NetworkNameLen = 0;
        PWCHAR              RegString = NULL;

        status = ( NdisAllocateMemoryWithTag( &RegString,
                                            ((UINT)wcslen(TcpipInterfacesKey) + 1 + (UINT)wcslen(DeviceId) + 1) * sizeof(WCHAR), 
                                            'gdrB'));
        if (NT_SUCCESS(status))
        {
            wcscpy(RegString, TcpipInterfacesKey);
            wcscat(RegString, L"\\");
            wcsncat(RegString, DeviceId, MAX_GUID_LEN - 1);

            NetworkIdentifier = DeviceId;

            RtlInitUnicodeString(&RegKey, RegString);
        
            status = BrdgReadRegUnicode(&RegKey,
                                        L"DhcpDomain",
                                        &RegNetworkName,
                                        &NetworkNameLen);
        
            if (!NT_SUCCESS(status) || (0 == NetworkNameLen))
            {
                //  
                // Either we didn't get a network name back, or the name is blank.
                // in both cases we go to the ipaddress and subnetmask to determine
                // the network that we're on.
                // We AND the two together to get this.
                // For example: Address: 10.251.1.3 Subnet: 255.0.0.0 gives us a 
                // network of: 10.0.0.0
                //
                status = BrdgGpoGetCurrentNetwork(&RegKey, &RegNetworkName);
            }

            if (NT_SUCCESS(status))
            {
                ULONG NetworkNameByteLen =(ULONG) ((wcslen(RegNetworkName) + 1) * sizeof(WCHAR));

                //
                // Copy the network name from the reg into a NonPagedPool string 
                // (since it will be accessed at DISPATCH_LEVEL)
                //

                NetworkName = ExAllocatePoolWithTag(NonPagedPool, NetworkNameByteLen, 'gdrB');
                if(NetworkName)
                {
                    RtlZeroMemory(NetworkName, NetworkNameByteLen);
                    RtlCopyMemory(NetworkName, RegNetworkName, NetworkNameByteLen);
                }

                //
                // Check if we match the current GP network.
                //
                if ((0 != g_BrdgGpoGlobals.GroupPolicyNetworkName.Length) &&
                    (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer))
                {
                    if(_wcsicmp(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer, NetworkName) == 0)
                    {
                        //
                        // We do match the network.
                        //
                        BrdgGpoUpdateBridgeMode(BRDG_ON_SAME_NETWORK);
                    }
                    else
                    {
                        //
                        // No, we're not, so look at other adapters
                        //
                        BrdgGpoCheckForMatchAndUpdateMode();
                    }                        
                }
                else
                {
                    //
                    // We don't have a Group Policy network.
                    //
                    BrdgGpoUpdateBridgeMode(BRDG_ON_DIFFERENT_NETWORK);
                }

                status = BrdgGpoAllocateAndInitializeNetwork(   &Network,
                                                                NetworkIdentifier,
                                                                RegNetworkName);

                if (NT_SUCCESS(status))
                {
                    //
                    // We first try to insert the Network into the list
                    //
                    status = BrdgGpoInsertNetwork(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Network->ListEntry,
                                                    g_BrdgGpoGlobals.NetworkListLock);

                    if (STATUS_DUPLICATE_NAME == status)
                    {
                        UNICODE_STRING Identifier;

                        //
                        // This Network already exists in the list, so we free it update the
                        // NetworkName in the existing entry.
                        //

                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;

                        RtlInitUnicodeString(&Identifier, NetworkIdentifier);
                        status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                            &Identifier,
                                                            NetworkName,
                                                            g_BrdgGpoGlobals.NetworkListLock);
                    }
                    else if (!NT_SUCCESS(status))
                    {
                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;
                    }
                }

                //
                // We've made a copy of this, so let's free it.
                //
                NdisFreeMemory(RegNetworkName, NetworkNameLen, 0);
            }
            
            if (NetworkName)
            {
                ExFreePool(NetworkName);
            }

            if (NT_SUCCESS(status))
            {
                status = BrdgGpoRegisterForAdapterAddressChangeNotification(NetworkIdentifier,
                                                                            RegString);
            }

#if DBG
            if (Network)
            {
                SAFEASSERT(Network->ListEntry.Blink && Network->ListEntry.Flink);
            }
#endif
            NdisFreeMemory(RegString, (UINT)wcslen(RegString) + 1, 0);
        }
    }
    
    return status;
}

// ===========================================================================
//
// REGISTRY CHANGE NOTIFICATION FUNCTIONS
//
// ===========================================================================

__forceinline
PLIST_ENTRY
BrdgGpoGetNotifyListHead()
/*++

Routine Description:

    
Arguments:

    None.

Return Value:

    Returns a pointer to the head of the Notifications List.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyList;
}

__forceinline
PKEVENT
BrdgGpoGetNotifyEvent()
/*++

Routine Description:

    
Arguments:

    None.

Return Value:

    Returns a pointer to the Event used for signaling the Processing 
    Thread to start processing notification requests.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyEvent;
}

__forceinline
PKEVENT
BrdgGpoGetKillEvent()
/*++

Routine Description:
    
Arguments:


Return Value:

  Returns a pointer to the Event used for signaling the Processing 
  Thread to exit.
  
--*/
{
    return g_BrdgGpoGlobals.QueueInfo.KillEvent;
}

__forceinline
PNDIS_RW_LOCK
BrdgGpoGetNotifyListLock()
/*++

Routine Description:
    
Arguments:


Return Value:

    Returns a pointer to the Read-Write lock that protects the 
    notification request list.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyListLock;
}

__forceinline
BOOLEAN
BrdgGpoProcessingNotifications()
/*++

Routine Description:
    
Arguments:


Return Value:

    TRUE    -   We're still processing Notifications (ie. we're not shutting down).
    FALSE   -   We're shutting down, don't add anything else to the list.

--*/
{
    return g_BrdgGpoGlobals.ProcessingNotifications;
}

NTSTATUS
BrdgGpoFindNotify(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_RW_LOCK           ListLock,
    IN  LPWSTR                  Identifier,
    OUT PBRDG_GPO_NOTIFY_KEY*   Notify
                  )
/*++

Routine Description:

    Since we don't want to have duplicate Notifications in the list, 
    this function is used to find an existing item if has already been added.
  
Arguments:

    ListHead    -   Pointer to the head of a Notifications list.

    ListLock    -   Read-Write lock for protecting the list.

    Identifier  -   A unique identifier associated with the item.  For NICs this is the
                    GUID assigned to the NIC.  For other items like the Group Policies, 
                    it is just a name we assign for example: "GroupPolicyNetworkName".
    Notify      -   An out param the contains either a pointer to the Notify we found,
                    or NULL if we didn't find a matching entry.

Return Value:

    STATUS_SUCCESS              We didn't find a matching entry.
    STATUS_OBJECT_NAME_EXISTS   We found a match, so we'll use that instead 
                                of allocating a new item.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    LOCK_STATE      LockState;
    PLIST_ENTRY     pListEntry;

    if (NULL != Notify)
    {
        *Notify = NULL;
    }

    if (NULL == ListHead ||
        NULL == ListLock ||
        NULL == Identifier ||
        NULL == Notify
        )
    {
        return STATUS_INVALID_PARAMETER;
    }

    BrdgGpoAcquireNetworkListLock(ListLock, FALSE /* Read */, &LockState);
    
    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    CurrentNotify;
        
        CurrentNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
        if ((CurrentNotify->Identifier.Buffer) &&
            (0 == _wcsicmp(CurrentNotify->Identifier.Buffer, Identifier)))
        {
            *Notify = CurrentNotify;
            status = STATUS_OBJECT_NAME_EXISTS;
            break;
        }
    }
    
    BrdgGpoReleaseNetworkListLock(ListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoInitializeNotifyList(
    OUT PLIST_ENTRY*    ListHead,
    OUT PNDIS_RW_LOCK*  ListLock,
    OUT PKEVENT*        WaitEvent,
    OUT PKEVENT*        KillEvent)
/*++

Routine Description:
    
      Initializes the Notifications List and associated objects.

Arguments:

    ListHead    -   [OUT] Pointer to the list head that we'll allocate.

    ListLock    -   [OUT] Pointer to the Read-Write lock that we'll allocate.

    WaitEvent   -   [OUT] Pointer to the WaitEvent we'll allocate

    KillEvent   -   [OUT] Pointer to the KillEvent we'll allocate

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   (unable to allocate everything).
    STATUS_INVALID_PARAMETER        (we were passed a NULL pointer to a pointer).
    STATUS_SUCCESS                  (we were able to allocate everything successfully).

--*/
{
    NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
    PLIST_ENTRY     pListHead;
    PNDIS_RW_LOCK   pListLock;
    PKEVENT         pWaitEvent;
    PKEVENT         pKillEvent;

    if (NULL == ListHead || 
        NULL == ListLock ||
        NULL == WaitEvent ||
        NULL == KillEvent)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *ListHead = NULL;
    *ListLock = NULL;
    *WaitEvent = NULL;
    *KillEvent = NULL;
    pListHead = NULL;
    pListLock = NULL;
    pWaitEvent = NULL;
    pKillEvent = NULL;
    
    pListHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (pListHead)
    {
        InitializeListHead(pListHead);
        pListLock = ExAllocatePoolWithTag(NonPagedPool, sizeof(NDIS_RW_LOCK), 'gdrB');
        if (pListLock)
        {
            NdisInitializeReadWriteLock(pListLock);

            pWaitEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'gdrB');

            if (pWaitEvent)
            {
                KeInitializeEvent(pWaitEvent, SynchronizationEvent, FALSE);

                pKillEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'gdrB');
                if (pKillEvent)
                {
                    KeInitializeEvent(pKillEvent, SynchronizationEvent, FALSE);

                    *ListHead = pListHead;
                    *ListLock = pListLock;
                    *WaitEvent = pWaitEvent;
                    *KillEvent = pKillEvent;
                    g_BrdgGpoGlobals.ProcessingNotifications = TRUE;

                    status = STATUS_SUCCESS;
                }
            }
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pListHead)
        {
            ExFreePool(pListHead);
        }
        if (pListLock)
        {
            ExFreePool(pListLock);
        }
        if (pWaitEvent)
        {
            ExFreePool(pWaitEvent);
        }
        if (pKillEvent)
        {
            ExFreePool(pKillEvent);
        }
        
    }

    return status;
}

VOID
BrdgGpoFreeNotifyList()
/*++

Routine Description:

    Frees the notify list and all it's associated entries.

Arguments:

    None.
                          
Return Value:

    None.

--*/
{
    if (g_BrdgGpoGlobals.QueueInfo.NotifyList)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyList);
        g_BrdgGpoGlobals.QueueInfo.NotifyList = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.NotifyListLock)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyListLock);
        g_BrdgGpoGlobals.QueueInfo.NotifyListLock = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.NotifyEvent)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyEvent);
        g_BrdgGpoGlobals.QueueInfo.NotifyEvent = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.KillEvent)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.KillEvent);
        g_BrdgGpoGlobals.QueueInfo.KillEvent = NULL;
    }
}

NTSTATUS
BrdgGpoRequestNotification(
    IN PBRDG_GPO_NOTIFY_KEY Notify)
/*++

Routine Description:

    Adds the Notification request to the list and signals the processing thread
    to re-check the list and register for any outstanding notifications.

Arguments:

    Notify  -   Notify struct that contains all the information necessary to register 
                for registry key changes.
                          
Return Value:

    STATUS_SHUTDOWN_IN_PROGRESS -   We're no longer processing notifications as we're 
                                    shutting down.
    STATUS_UNSUCCESSFUL         -   We were unable to get a valid list or lock.

    STATUS_SUCCESS              -   We successfully notified the processing thread to 
                                    request notification on this item.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PLIST_ENTRY     ListHead;
    PNDIS_RW_LOCK   ListLock;
    LOCK_STATE      LockState;
    PLIST_ENTRY     pListEntry;
    PKEVENT         WaitEvent;
    BOOLEAN         NewEntry = TRUE;
    BOOLEAN         ShuttingDown = FALSE;

    ListLock = BrdgGpoGetNotifyListLock();
    ListHead = BrdgGpoGetNotifyListHead();

    if (NULL == ListLock || NULL == ListHead)
    {
        return STATUS_UNSUCCESSFUL;
    }

    NdisAcquireReadWriteLock(ListLock, TRUE /* Write */, &LockState);

    ShuttingDown = !BrdgGpoProcessingNotifications();

    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    CurrentNotify;
        
        CurrentNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
        if (0 == _wcsicmp(CurrentNotify->Identifier.Buffer, Notify->Identifier.Buffer))
        {
            NewEntry = FALSE;
            break;
        }
    }

    if (!ShuttingDown)
    {
        if (NewEntry)
        {
            InsertTailList(ListHead, &Notify->ListEntry);
        }

        Notify->Modified = TRUE;
    }

    NdisReleaseReadWriteLock(ListLock, &LockState);

    if (ShuttingDown)
    {
        status = STATUS_SHUTDOWN_IN_PROGRESS;
    }
    else
    {
        WaitEvent = BrdgGpoGetNotifyEvent();

        KeSetEvent(WaitEvent, 0, FALSE);
    }

    return status;
}

VOID
BrdgGpoProcessNotifications(
    IN PVOID                Context)
/*++

Routine Description:

    This is the processing thread worker function that is responsible to doing 
    all notifications that we are interested in.

    WARNING: Don't try to remove this thread or have it exit until you're 
             no longer interested in notifications.  The registery 
             notifications mechanism stores the notifications information
             in the _ETHREAD structure, so exiting the thread loses all
             remaining notifications.

Arguments:

    Context -   PBRDG_GPO_THREAD_PARAMS structure that contains a pointer to the
                notify list, it's lock and the notify and kill events.
                          
Return Value:

    None.

--*/
{
    PBRDG_GPO_THREAD_PARAMS ThreadParms = (PBRDG_GPO_THREAD_PARAMS) Context;
    BOOLEAN                 Exiting = FALSE;
    PNDIS_RW_LOCK           ListLock;
    PLIST_ENTRY             ListHead;
    PVOID                   WaitObjects[2];
    PLIST_ENTRY             QueuedList;
    PBRDG_GPO_QUEUED_NOTIFY QueuedNotify;
    PNPAGED_LOOKASIDE_LIST  LookasideQueueList;

    DBGPRINT(GPO, ("Notification Processing Thread Routine Running\r\n"));

    //
    // The lookaside list and Queuedlist need to live in NonPaged Pool because we utilize them 
    // at DISPATCH_LEVEL
    //
    LookasideQueueList = ExAllocatePoolWithTag(NonPagedPool, sizeof(NPAGED_LOOKASIDE_LIST), 'gdrB');
    if (NULL == LookasideQueueList)
    {
        return;
    }

    QueuedList = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL == QueuedList)
    {
        ExFreePool(LookasideQueueList);
        return;
    }

    ExInitializeNPagedLookasideList(LookasideQueueList, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    sizeof(BRDG_GPO_QUEUED_NOTIFY), 
                                    'grbQ',
                                    0);

    InitializeListHead(QueuedList);

    //
    //  We passed in the list through the context of this thread.
    //
    ListHead = ThreadParms->NotifyList;
    ListLock = ThreadParms->NotifyListLock;
    WaitObjects[0]= (PVOID)ThreadParms->NotifyEvent;
    WaitObjects[1]= (PVOID)ThreadParms->KillEvent;

    while (!Exiting)
    {
        NTSTATUS                status;
        LOCK_STATE              LockState;
        PLIST_ENTRY             pListEntry;
        ULONG                   FiredEvent;

        //
        // We only do this if we're still processing notifications, otherwise we're waiting on 
        // the kill event.
        //
        if (BrdgGpoProcessingNotifications())
        {
            //
            // We use a temporary list to fire off the notifications, since we can't
            // register for RegKey notifications at DISPATCH_LEVEL.
            // 

            NdisAcquireReadWriteLock(ListLock, FALSE /* Read-only */, &LockState);

            //
            // Loop through the list of notifications looking for any that have changed.
            //

            for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
            {
                PBRDG_GPO_NOTIFY_KEY    Notify;

                Notify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
                if (TRUE == Notify->Modified)
                {
                    //
                    // We've found an item that has changed, add it to the list that we'll
                    // use to do the actual work from (at PASSIVE_LEVEL).
                    //

                    if (FALSE == Notify->PendingNotification)
                    {
                        if (BrdgIncrementWaitRef(&Notify->RefCount))
                        {
                            QueuedNotify = ExAllocateFromNPagedLookasideList(LookasideQueueList);
                            QueuedNotify->Notify = Notify;
                            InsertTailList(QueuedList, &QueuedNotify->ListEntry);
                        }
                    }

                    //
                    // We're going to handle this request so set the Modified value to FALSE
                    // so that we don't do anything with it if we run through the list again 
                    // due to another item being added.
                    //
                    Notify->Modified = FALSE;
                }
            }

            NdisReleaseReadWriteLock(ListLock, &LockState);

            //
            // We're back at PASSIVE_LEVEL so we can now do the registration for the changes.
            //

            for (pListEntry = QueuedList->Flink; pListEntry != QueuedList; pListEntry = pListEntry->Flink)
            {
                QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);
            
                DBGPRINT(GPO, ("Processing Notification: %S\r\n", QueuedNotify->Notify->Identifier.Buffer));

                //
                // Do the actual registration for the key change notification.  Since we can also be
                // passed in a pointer to a BOOLEAN that is used elsewhere, we set that accordingly
                // if we have one.
                //

                DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", QueuedNotify->Notify->Identifier.Buffer, QueuedNotify->Notify->RefCount));
                
                status = BrdgGpoRegisterForRegKeyChange(QueuedNotify->Notify);
                if (QueuedNotify->Notify->SuccessfulRegistration)
                {
                    *(QueuedNotify->Notify->SuccessfulRegistration) = (BOOLEAN)NT_SUCCESS(status);
                    BrdgGpoCheckForMatchAndUpdateMode();
                    if (QueuedNotify->Notify->FunctionRegister)
                    {
                        NTSTATUS tmpStatus;
                        tmpStatus = QueuedNotify->Notify->FunctionRegister();
                        DBGPRINT(GPO, ("Function returned: 0x%x\r\n", tmpStatus));
                    }
                }

                if (NT_SUCCESS(status))
                {
                    InterlockedExchange(&QueuedNotify->Notify->PendingNotification, TRUE);
                }
                else
                {
                    InterlockedExchange(&QueuedNotify->Notify->PendingNotification, FALSE);
                    BrdgDecrementWaitRef(&QueuedNotify->Notify->RefCount);
                }
            }

            //
            // Free the temporary list.
            //
            while (!IsListEmpty(QueuedList))
            {
                pListEntry = RemoveHeadList(QueuedList);
            
                QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);

                ExFreeToNPagedLookasideList(LookasideQueueList, QueuedNotify);
            }
        }
        
        //
        // We're done, we'll wait here until the event has fired, ie, one of the items needs to be re-registered,
        // or a new item has been added to the list and we need to register for notifications.
        //
        status = KeWaitForMultipleObjects(2, WaitObjects, WaitAny, Executive, KernelMode, FALSE, FALSE, NULL);

        if (!NT_SUCCESS(status))
        {
            FiredEvent = 1L;  // We're going to terminate the thread.
            DBGPRINT(GPO, ("KeWaitForMultipleObjects returned an error"));
        }
        else
        {
            FiredEvent = (ULONG)status - (ULONG)STATUS_WAIT_0;
        }

        if (1L == FiredEvent)
        {
            Exiting = TRUE;
        }
    }

    ExDeleteNPagedLookasideList(LookasideQueueList);

    ExFreePool(LookasideQueueList);
    ExFreePool(QueuedList);

    DBGPRINT(GPO, ("Notification Processing Thread Routine Exiting\r\n"));

    // We're done, kill this thread.
    PsTerminateSystemThread( STATUS_SUCCESS );
}


NTSTATUS
BrdgGpoRegisterForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify)
{
    NTSTATUS status;

    if (!BrdgGpoProcessingNotifications())
    {
        return STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Call our notify worker function (this does the real request for notification).
    //
    status = BrdgGpoNotifyRegKeyChange( Notify,
                                        (PIO_APC_ROUTINE)(ULONG_PTR)&Notify->RegChangeWorkItem,
                                        Notify->WorkItemContext,
                                        Notify->CompletionFilter,
                                        Notify->WatchTree);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", Notify->RegKeyName.Buffer, status));
    }

    return status;
}

NTSTATUS
BrdgGpoBuildNotifyForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify,
    IN LPWSTR                   Identifier,
    IN LPWSTR                   RegKeyName,
    IN LPWSTR                   RegValueName,
    IN PWORKER_THREAD_ROUTINE   ApcRoutine,
    IN PVOID                    ApcContext,
    IN ULONG                    CompletionFilter,
    IN BOOLEAN                  WatchTree,
    IN PBRDG_GPO_REG_CALLBACK   FunctionCallback,
    IN BOOLEAN                  Recurring,
    IN PBOOLEAN                 SuccessfulRegistration,
    IN PBRDG_GPO_REGISTER       FunctionRegister
    )
/*++

Routine Description:
    
    Builds a Notify structure used for Registry Key and Value changes.

Arguments:

    Notify                  -   If ReRegister is FALSE, then this structure has simply been 
                                initialized with some basic information.  The rest will be 
                                filled in here.  If ReRegister is TRUE, then this structure 
                                contains all the information necessary to redo the notification
                                request, this saves us having to pass all the data in each time.

    Identifier              -   Identifies this Notify structure.  Can be a name, or a GUID for an adapter.
    
    RegKeyName              -   The Registry key that we're interesting in waiting on.

    RegValueName            -   The Value that we need (or "Default" if we don't care about it")

    ApcRoutine              -   The routine that we which to be notified on.

    ApcContext              -   Information that we want to be passed back (we expect a valid Notify Struct).

    CompletionFilter        -   What type of change we're interested in.  ie. New Subkey added, or Value changed etc.

    WatchTree               -   Do we want to what for changes on all subkeys as well.

    FunctionCallback        -   Our own internal callback functions

    Recurring               -   Do we want to re-do the notification once we're done handling it.

    SuccessfulRegistration  -   A pointer to a BOOLEAN that we set if the registration is successful.

Return Value:

    STATUS_SUCCESS or a specific error code.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    LPWSTR      lpszIdentifier = NULL;
    LPWSTR      lpszRegKeyName = NULL;
    LPWSTR      lpszRegValueName = NULL;
    
    if (NULL == Notify || 
        NULL == Identifier || 
        NULL == RegKeyName || 
        NULL == RegValueName || 
        NULL == ApcRoutine ||  
        NULL == ApcContext || 
        NULL == FunctionCallback
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // This buffer is not used by ZwNotifyChangeKey.  So no need to really allocate anything for it.
    //
    Notify->Buffer = 0L;
    Notify->BufferSize = sizeof(ULONG);

    //
    // We Allocate these from NonPagedPool because they're passed as part of a struct that can be used at
    // DISPATCH_LEVEL
    //
    lpszIdentifier = ExAllocatePoolWithTag(NonPagedPool, (wcslen(Identifier) + 1) * sizeof(WCHAR), 'gdrB');
    if (lpszIdentifier)
    {
        lpszRegKeyName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(RegKeyName) + 1) * sizeof(WCHAR), 'gdrB');
        if (lpszRegKeyName)
        {
            lpszRegValueName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(RegValueName) + 1) * sizeof(WCHAR), 'gdrB');
            if (lpszRegValueName)
            {
                BOOLEAN Success;
                
                RtlZeroMemory(lpszIdentifier, (wcslen(Identifier) + 1) * sizeof(WCHAR));
                RtlZeroMemory(lpszRegKeyName, (wcslen(RegKeyName) + 1) * sizeof(WCHAR));
                RtlZeroMemory(lpszRegValueName, (wcslen(RegValueName) + 1) * sizeof(WCHAR));

                //
                // We need to allocate new strings because the RtlInitUnicodeString function just sets its buffer
                // to the LPWSTR we pass it and these values need to be used outside the scope of these functions.
                //
                wcscpy(lpszIdentifier, Identifier);
                wcscpy(lpszRegKeyName, RegKeyName);
                wcscpy(lpszRegValueName, RegValueName);

                //
                // Set the strings inside our struct.  This enables us to fully rebuild the information required
                // for keeping track of the different keys that we need to be notified about.
                //
                RtlInitUnicodeString(&Notify->Identifier, lpszIdentifier);
                RtlInitUnicodeString(&Notify->RegKeyName, lpszRegKeyName);
                RtlInitUnicodeString(&Notify->RegValue, lpszRegValueName);

                //
                // Recurring will tell us if we need to re-register once a change is fired.
                //
                Notify->Recurring = Recurring;

                //
                // Rather than have the BrdgGpoRegNotify function do everything, we have seperate functions
                // for each one.  This also means that we don't have to keep all of them in the paged-locked 
                // section, since they will be called at PASSIVE_LEVEL.
                //
                Notify->FunctionCallback = FunctionCallback;

                //
                // We are using a Workitem to get called back on.  We pass in the notify structure
                // which has enough info to re-notify if necessary.  The context is generally just
                // the Deferred work queue.
                //
                ExInitializeWorkItem(&Notify->RegChangeWorkItem, ApcRoutine, Notify);
                Notify->WorkItemContext = ApcContext;

                //
                // We store the WatchTree and CompletionFilter so that we can renotify needing any
                // additional parameters, since we're probably ddoing this from a different thread.
                //
                Notify->WatchTree = WatchTree;
                Notify->CompletionFilter = CompletionFilter;

                //
                // We set this once we have successfully registered for notification on the key of 
                // interest.
                //
                Notify->SuccessfulRegistration = SuccessfulRegistration;

                //
                // Increment this once so that we can decrement it in the cleanup code and have it only go to Zero then.
                //
                BrdgInitializeWaitRef(&Notify->RefCount, FALSE);

                //
                // Since we're initializing this object, there is no way that this should fail.
                //
                Success = BrdgIncrementWaitRef(&Notify->RefCount);
                SAFEASSERT(Success);
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    else
    {
        return STATUS_INSUFFICIENT_RESOURCES;                
    }

    if (!NT_SUCCESS(status))
    {
        if (lpszIdentifier)
        {
            ExFreePool(lpszIdentifier);
        }
        if (lpszRegKeyName)
        {
            ExFreePool(lpszRegKeyName);
        }
        if (lpszRegValueName)
        {
            ExFreePool(lpszRegValueName);
        }
    }

    return status;    
}

NTSTATUS
BrdgGpoNotifyRegKeyChange(
                          IN      PBRDG_GPO_NOTIFY_KEY    Notify,
                          IN      PIO_APC_ROUTINE         ApcRoutine,
                          IN      PVOID                   ApcContext,
                          IN      ULONG                   CompletionFilter,
                          IN      BOOLEAN                 WatchTree)
/*++

Routine Description:

    This calls ZwNotifyChangeKey to register us for notifications on individual keys. 
    We close the key in the callback functions because you can only listen once per handle.

Arguments:

    Notify              -   Structure containing relevant information about the notification.  Allows us to
                            know what values to read to get the relevant data that we need.
    ApcRoutine          -   The routine that we which to be notified on.

    ApcContext          -   Information that we want to be passed back (we expect a valid Notify Struct).

    CompletionFilter    -   What type of change we're interested in.  ie. New Subkey added, or Value changed etc.

    WatchTree           -   Do we want to what for changes on all subkeys as well.
                          
Return Value:

    STATUS_SUCCESS or a specific error code.

--*/
{
    OBJECT_ATTRIBUTES   ObAttr;
    NTSTATUS            status;
    
    InitializeObjectAttributes(&ObAttr, &Notify->RegKeyName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);
    
    status = ZwOpenKey( &Notify->RegKey,
        KEY_READ | KEY_NOTIFY | KEY_WRITE,
        &ObAttr);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Opened Regkey successfully\r\n"));
        status = ZwNotifyChangeKey( Notify->RegKey,
                                    NULL,
                                    ApcRoutine,
                                    ApcContext,
                                    &Notify->IoStatus,
                                    CompletionFilter,
                                    WatchTree,
                                    &Notify->Buffer,
                                    Notify->BufferSize,
                                    TRUE
                                    );
    }
    else
    {
        //
        // Set it to NULL so that we don't try to close it accidentally during shutdown.
        //
        Notify->RegKey = NULL;
    }
    
    return status;
}

VOID
static
BrdgGpoRegNotify(
                 IN  PVOID               Context)
/*++

Routine Description:
    
    This is the central callback function that we are notified on.

    This is called on an Executive worker thread at PASSIVE_LEVEL.
Arguments:

    Context -   Is just our Notify structure that we passed in 
                to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    PBRDG_GPO_NOTIFY_KEY    Notify = (PBRDG_GPO_NOTIFY_KEY)Context;
    
    DBGPRINT(GPO, ("APC routine called\r\n"));
    DBGPRINT(GPO, ("Current IRQL: %d\r\n", CURRENT_IRQL));
    
    if (Notify)
    {
        LONG RefCount;
        InterlockedExchange(&Notify->PendingNotification, FALSE);
        Notify->FunctionCallback(Notify);
        RefCount = Notify->RefCount.Refcount - 1;
        DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", Notify->Identifier.Buffer, RefCount));
        BrdgDecrementWaitRef(&Notify->RefCount);
    }
}

NTSTATUS
BrdgGpoAllocateAndInitializeNotifyStruct(
    OUT PBRDG_GPO_NOTIFY_KEY* Notify)
/*++

Routine Description:
    
    Allocates and initializes the Notify struct to all zeros.

Arguments:

    Notify  -   A pointer to pointer to a Notify struct that is allocated
                from NonPagedPool.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to filfull the request.
    STATUS_INVALID_PARAMETER        -   We were passed a NULL Pointer to pointer 
                                        to a Notify struct.
    STATUS_SUCCESS                  -   We successfully allocated space for the structure.

--*/
{
    NTSTATUS    status = STATUS_INSUFFICIENT_RESOURCES;

    if (NULL == Notify)
    {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // We allocate this from NonPagedPool because it will be accessed at DISPATCH_LEVEL
    //
    *Notify = ExAllocatePoolWithTag(NonPagedPool, sizeof(BRDG_GPO_NOTIFY_KEY), 'gdrB');
    if (*Notify)
    {
        //
        // Zero it out so that we don't try and free invalid strings when we free it.
        //
        RtlZeroMemory(*Notify, sizeof(BRDG_GPO_NOTIFY_KEY));
        status = STATUS_SUCCESS;
    }
    return status;
}

VOID
BrdgGpoFreeNotifyStructAndData(
    IN PBRDG_GPO_NOTIFY_KEY Notify)
/*++

Routine Description:
    
    Frees all data associated with a Notify struct and then frees the struct
    itself.

    Note:   This will not free a structure that is still in a list.
            If you need to free something, use RemoveListEntry and then
            set the Notify->ListEntry Blink and Flink = NULL and then call
            this.

    WARNING:
            Since it's possible that this structure is still being used by
            the a waiting registration, it's better to leave them alone until
            shutdown as it's possible that a notification may be fired once 
            this has been freed and that will result in a system crash since
            the struct will be invalid.

Arguments:

    Notify  -   A pointer to the Notify struct to be freed.

Return Value:

    None.

--*/
{
    if (Notify)
    {
        if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
        {
            if (Notify->Identifier.Buffer)
            {
                ExFreePool(Notify->Identifier.Buffer);
            }
            if (Notify->RegKeyName.Buffer)
            {
                ExFreePool(Notify->RegKeyName.Buffer);
            }
            if (Notify->RegValue.Buffer)
            {
                ExFreePool(Notify->RegValue.Buffer);
            }
            ExFreePool(Notify);
        }
        else
        {
            if (BrdgGpoProcessingNotifications())
            {
                DBGPRINT(GPO, ("Attempt to free a Notify that is still in a list\r\nWhile we're still processing Notifications\r\n"));
            }
        }
    }
}

// ===========================================================================
//
// NOTIFICATION REGISTRATION FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgGpoRegisterForGroupPolicyNetworkNameNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\History"
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          RegKeyName;
    PWCHAR                  RegValue;
    ULONG                   DataLen;

    if (g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges)
    {
        DBGPRINT(GPO, ("Already Registered for Group Policy Network Name Notification\r\n"));
        return STATUS_SUCCESS;
    }
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForGroupPolicyNetworkNameNotification\r\n"));

    RtlInitUnicodeString(&RegKeyName, (LPWSTR) HistoryKey);
    
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegUnicode(&RegKeyName,
                                L"NetworkName",
                                &RegValue,
                                &DataLen);
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Group Policy Network Name: %S\r\n", RegValue));
        
        if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
        {
            ExFreePool(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
        }

        //
        // Success.  Now store the value for later use.
        //
        RtlInitUnicodeString(&g_BrdgGpoGlobals.GroupPolicyNetworkName, RegValue);
        
        //
        // Since something changed, we'll just re-verify that we're in
        // the correct bridging mode.
        //        
        BrdgGpoCheckForMatchAndUpdateMode();
    }
    else
    {
        //
        // We failed to get a value for this. It probably isn't there yet - this can happen if this 
        // is the first boot after joining a domain.  We'll be waiting on this key so if we get one later
        // we'll update this value.
        //
        g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer = NULL;
        g_BrdgGpoGlobals.GroupPolicyNetworkName.Length = 0;
        g_BrdgGpoGlobals.GroupPolicyNetworkName.MaximumLength = 0;
    }
 
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"GroupPolicyNetworkName",
                                &Notify);
    if (NT_SUCCESS(status))    
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"GroupPolicyNetworkName",
                                                            (LPWSTR)HistoryKey,
                                                            L"NetworkName",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoGroupPolicyNetworkNameChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges,
                                                            BrdgGpoUpdateGroupPolicyNetworkName);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to Build notification on %S.  Status: 0x%x\r\n", NetworkPoliciesKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif
    
    return status;
}

NTSTATUS
BrdgGpoRegisterForGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy"

    This is the parent to the History key and is always on a system.
    If will be notified if the History Key is created in which case
    we will register for notifications on that key.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForGroupPolicyNotification\r\n"));
    
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"GroupPolicyParent",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"GroupPolicyParent",
                                                            (LPWSTR)GroupPolicyKey,
                                                            L"Default",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_NAME,
                                                            FALSE,
                                                            BrdgGpoGroupPolicyChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges,
                                                            BrdgGpoRegisterForGroupPolicyNetworkNameNotification);
            }
        }
        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", GroupPolicyKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif

    return status;
}

NTSTATUS
BrdgGpoRegisterForWindowsGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    HKLM\SOFTWARE\Policies\Microsoft\Windows

    If this gets notified, then we'll attempt to wait on the 
    Network Connections key below this.
    
Arguments:

    None.

Return Value:

      STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to allocate the structure.
      STATUS_SUCCESS                  -   We were able to post the request successfully.
                                          This doesn't mean we've successfully requested 
                                          notification though, it only means we've added it 
                                          to the Notifications list and have signaled the 
                                          processing thread to attempt a notification.
  
--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;

    DBGPRINT(GPO, ("BrdgGpoRegisterForWindowsGroupPolicyNotification\r\n"));
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"WindowsGroupPolicies",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"WindowsGroupPolicies",
                                                            (LPWSTR)PolicyBaseKey,
                                                            (LPWSTR)L"Default",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_NAME,
                                                            FALSE,
                                                            BrdgGpoWindowsGroupPolicyChangeCallback,
                                                            TRUE,
                                                            NULL,
                                                            BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", PolicyBaseKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif
    
    return status;
}

VOID
BrdgGpoRegisterForHiveListNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\System\CurrentControlSet\Control\HiveList"

    Each time this is fired we attempt to open the Software hive, if this
    open is successful then we request notification on all the keys that
    we are interested in under the software hive.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          Software;
    OBJECT_ATTRIBUTES       ObAttr;
    HANDLE                  hKey;
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForHiveListNotification\r\n"));

    //
    // We attempt to open this key now in case the hives are already loaded.
    //

    RtlInitUnicodeString(&Software, SoftwareHiveKey);
    
    InitializeObjectAttributes( &ObAttr,
                                &Software,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );
    
    status = ZwOpenKey(&hKey, KEY_READ, &ObAttr);
    
    if (NT_SUCCESS(status))
    {
        //
        // The software hive is already loaded, no need to register for changes
        // to this.  Just attempt to register for all other changes.
        //

        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNotification();
        
        //
        // To avoid turning the bridge on and then off again, we set this just after 
        // verifying the Network Connections policy setting.
        //
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
        g_BrdgGpoGlobals.WaitingOnSoftwareHive = FALSE;
        
        ZwClose(hKey);
    }
    else
    {
        //
        // We don't want to allocate these twice, so we first try to find an existing notify struct.
        //
        status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                    BrdgGpoGetNotifyListLock(),
                                    L"HiveList",
                                    &Notify);
        if (NT_SUCCESS(status))
        {
            if (STATUS_OBJECT_NAME_EXISTS != status)
            {
                //
                // The item doesn't exist yet, so allocate it from the NonPagedPool and 
                // attempt build a notification request.
                //
                status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
                if (NT_SUCCESS(status))
                {
                    status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                                L"HiveList",
                                                                (LPWSTR)HiveListKey,
                                                                (LPWSTR)L"Default",
                                                                BrdgGpoRegNotify,
                                                                (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                                REG_NOTIFY_CHANGE_LAST_SET,
                                                                FALSE,
                                                                BrdgGpoHiveListCallback,
                                                                TRUE,
                                                                NULL,
                                                                NULL);
                }
            }
            if (!NT_SUCCESS(status))
            {
                DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", PolicyBaseKey, status));
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
            else
            {
                SAFEASSERT(Notify);
                //
                // We have a valid Notify structure, post a notification request to the
                // processing thread.
                //
                status = BrdgGpoRequestNotification(Notify);
                if (STATUS_SHUTDOWN_IN_PROGRESS == status)
                {
                    if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                    {
                        BrdgDecrementWaitRef(&Notify->RefCount);
                        BrdgGpoFreeNotifyStructAndData(Notify);
                        Notify = NULL;
                    }
                }
                else if (!NT_SUCCESS(status))
                {
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
        }
    
#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif
    }
}

NTSTATUS
BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Network Connections"

    We also read any value that may already be there and act upon it.
  
Arguments:

    None.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to allocate the structure.
    STATUS_SUCCESS                  -   We were able to post the request successfully.
                                        This doesn't mean we've successfully requested 
                                        notification though, it only means we've added it 
                                        to the Notifications list and have signaled the 
                                        processing thread to attempt a notification.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          RegKeyName;
    ULONG                   RegValue;

    if (g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges)
    {
        DBGPRINT(GPO, ("Already Registered for Network Connections Group Policy Notification\r\n"));
        return STATUS_SUCCESS;
    }

    DBGPRINT(GPO, ("BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification\r\n"));
    
    RtlInitUnicodeString(&RegKeyName, (LPWSTR)NetworkPoliciesKey);
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegDWord(  &RegKeyName,
                                (LPWSTR)BridgePolicyValue,
                                &RegValue);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Bridge Policy Setting: %d\r\n", RegValue));
        
        //
        // Since something changed, we'll just re-verify that we're in
        // the correct bridging mode.
        //
        BrdgGpoCheckForMatchAndUpdateMode();
    }
    
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"NetworkConnectionsGroupPolicies",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"NetworkConnectionsGroupPolicies",
                                                            (LPWSTR)NetworkPoliciesKey,
                                                            (LPWSTR)BridgePolicyValue,
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoNetworkConnectionsGroupPolicyChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges,
                                                            NULL);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", NetworkPoliciesKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif

    return status;
}

// ===========================================================================
//
// REGISTRY CHANGE CALLBACK FUNCTIONS
//
// ===========================================================================

VOID
BrdgGpoTcpipInterfacesChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the an the TcpIp interfaces key changes for 
    and adapter that we're interested in (any Non-NdisWan adapter).

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PWCHAR   RegValue;
    ULONG    StringLen = 0;

    DBGPRINT(GPO, ("BrdgGpoTcpipInterfacesChangeCallback\r\n"));
    
    DBGPRINT(GPO, ("Called for Key: %S re-registering.\r\n", Notify->RegKeyName.Buffer));
    
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegUnicode(&Notify->RegKeyName,
                                Notify->RegValue.Buffer,
                                &RegValue,
                                &StringLen);

    if (!NT_SUCCESS(status))
    {
        status = BrdgGpoGetCurrentNetwork(  &Notify->RegKeyName,
                                            &RegValue);
        if (NT_SUCCESS(status))
        {
            StringLen = (UINT)wcslen(RegValue);
        }
    }

    if (NT_SUCCESS(status))
    {
        PBRDG_GPO_NETWORKS  Network;
        LPWSTR              NetworkName;
        
        DBGPRINT(GPO, ("Current Network: %S\r\n", RegValue));

        NetworkName = ExAllocatePoolWithTag(NonPagedPool, (StringLen + 1) * sizeof(WCHAR), 'gdrB');

        if (NULL != NetworkName)
        {
            RtlZeroMemory(NetworkName, (StringLen + 1) * sizeof(WCHAR));
            wcscpy(NetworkName, RegValue);
            
            //
            // Try to find a match for the current network identifier (generally the adapter guid)
            //
            status = BrdgGpoFindNetwork(g_BrdgGpoGlobals.ListHeadNetworks,
                                        &Notify->Identifier,
                                        g_BrdgGpoGlobals.NetworkListLock,
                                        &Network);
            
            if (STATUS_NOT_FOUND == status)
            {
                //
                // No match so this is a new key (very unlikely code path).
                //
                status = BrdgGpoAllocateAndInitializeNetwork(   &Network,
                                                                Notify->Identifier.Buffer,
                                                                NetworkName);
                if (NT_SUCCESS(status))
                {
                    status = BrdgGpoInsertNetwork(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Network->ListEntry,
                                                    g_BrdgGpoGlobals.NetworkListLock);
                
                    if (!NT_SUCCESS(status))
                    {
                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;
                    }
                }
            }
            else
            {
                //
                // This is expected to happen most times, if not always.
                //
                status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Notify->Identifier,
                                                    NetworkName,
                                                    g_BrdgGpoGlobals.NetworkListLock);
                
            }

#if DBG
            if (Network)
            {
                SAFEASSERT(Network->ListEntry.Blink && Network->ListEntry.Flink);
            }
#endif
            
            if (NetworkName)
            {
                ExFreePool(NetworkName);
            }

            NdisFreeMemory(RegValue, StringLen, 0);
        }
    }
    else
    {
        //
        // We change the name to NULL since the key appears to have disappeared.
        //
        status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                            &Notify->Identifier,
                                            NULL,
                                            g_BrdgGpoGlobals.NetworkListLock);
    }
    
    //
    // Since something changed, we'll just re-verify that we're in
    // the correct bridging mode.
    //
    BrdgGpoCheckForMatchAndUpdateMode();
    
    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        //
        // Re-register.  The notify object contains enough info to do this.
        //
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
    }
}

VOID
BrdgGpoWindowsGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Windows Group Policy key changes.

    We attempt to register for the Network Connections key changes
    if we haven't already done so.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    DBGPRINT(GPO, ("BrdgGpoWindowsGroupPolicyChangeCallback\r\n"));

    if (!g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges)
    {
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        NTSTATUS    status;
        
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}

VOID
BrdgGpoHiveListCallback(
    IN  PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the HiveList key changes.

    If it does, we attempt to open the software hive. If that succeeds then
    we attempt to register for the keys that we're interested in under
    the Software Hive.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      Software;
    OBJECT_ATTRIBUTES   ObAttr;
    HANDLE              hKey;

    DBGPRINT(GPO, ("BrdgGpoHiveListCallback\r\n"));

    RtlInitUnicodeString(&Software, SoftwareHiveKey);

    InitializeObjectAttributes( &ObAttr,
                                &Software,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    status = ZwOpenKey(&hKey, KEY_READ, &ObAttr);

    if (NT_SUCCESS(status))
    {
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNotification();

        //
        // To avoid turning the bridge on and then off again, we set this just after 
        // verifying the Network Connections policy setting.
        //
        
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
        g_BrdgGpoGlobals.WaitingOnSoftwareHive = FALSE;
        Notify->Recurring = FALSE;
        ZwClose(hKey);
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }

    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    


VOID
BrdgGpoGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Group Policy key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    DBGPRINT(GPO, ("BrdgGpoGroupPolicyChangeCallback\r\n"));

    if (!g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges)
    {
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        NTSTATUS    status;

        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    

VOID
BrdgGpoNetworkConnectionsGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Network Connection Policy key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS    status;
    ULONG       RegValue;
    
    DBGPRINT(GPO, ("BrdgGpoNetworkConnectionsGroupPolicyChangeCallback\r\n"));

    DBGPRINT(GPO, ("Called for Key: %S re-registering.\r\n", Notify->RegKeyName.Buffer));
    
    status = BrdgReadRegDWord(  &Notify->RegKeyName,
                                Notify->RegValue.Buffer, 
                                &RegValue);
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Bridge Policy Setting: %d\r\n", RegValue));
    }

    //
    // Since something changed, we'll just re-verify that we're in
    // the correct bridging mode.
    //
    BrdgGpoCheckForMatchAndUpdateMode();
    
    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    

NTSTATUS 
BrdgGpoUpdateGroupPolicyNetworkName()
{
    NTSTATUS        status = STATUS_OBJECT_NAME_NOT_FOUND;
    PWCHAR          RegValue = NULL;
    LPWSTR          GroupPolicyNetwork = NULL;
    ULONG           DataLen = 0;
    UNICODE_STRING  RegKeyName;
    
    RtlInitUnicodeString(&RegKeyName, HistoryKey);

    //
    // Read the current value from the registry
    //
    status = BrdgReadRegUnicode(&RegKeyName,
                                L"NetworkName", 
                                &RegValue, 
                                &DataLen);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Group Policy Network Name: %S\r\n", RegValue));
        
        //
        // Almost always checked at DISPATCH_LEVEL, so we allocate from NonPagedPool
        //
        GroupPolicyNetwork = ExAllocatePoolWithTag(NonPagedPool, (DataLen + 1) * sizeof(WCHAR), 'gdrB');
        
        if (GroupPolicyNetwork)
        {
            if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
            {
                ExFreePool( g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
            }
            
            RtlZeroMemory(GroupPolicyNetwork, (DataLen + 1) * sizeof(WCHAR));
            
            wcsncpy(GroupPolicyNetwork, RegValue, DataLen);
            
            RtlInitUnicodeString(&g_BrdgGpoGlobals.GroupPolicyNetworkName, GroupPolicyNetwork);
            
            //
            // Since something changed, we'll just re-verify that we're in
            // the correct bridging mode.
            //            
            BrdgGpoCheckForMatchAndUpdateMode();
        }
        NdisFreeMemory(RegValue, DataLen, 0);        
    }

    return status;
}

VOID
BrdgGpoGroupPolicyNetworkNameChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Group Policy History key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS    status;
    
    //
    // Read the current value from the registry
    //
    
    status = BrdgGpoUpdateGroupPolicyNetworkName();
    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
    }
}

// ===========================================================================
//
// GROUP POLICY NETWORK VERIFICATION FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgGpoAllowedToBridge()
/*++

Routine Description:
    
    Checks the Network Connections policy key for the Bridge Policy setting.

    
Arguments:

    None.
    
Return Value:

    TRUE if we couldn't find a Policy Value, or the Value is 1.
    FALSE if the policy exists and contains a value of 0.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  RegKey;
    ULONG           RegValue;
    BOOLEAN         CanBridge = TRUE;  // If there is no key then we're allowed to bridge.

    RtlInitUnicodeString(&RegKey, NetworkPoliciesKey);
    
    status = BrdgReadRegDWord(&RegKey, (LPWSTR) BridgePolicyValue, &RegValue);

    if (NT_SUCCESS(status))
    {
        if (FALSE == RegValue)
        {
            CanBridge = FALSE;
        }
    }
    
    return CanBridge;
}

VOID
BrdgGpoUpdateBridgeMode(
    BOOLEAN NetworkMatch
    )
/*++

Routine Description:

    Checks for a Network Match and if we're not allowed to bridge then 
    turns bridging off, otherwise it turns it on.
    
Arguments:

    NetworkMatch    -   Do we have a match for the group policy network?
    
Return Value:

    None.

--*/
{
    //
    // If we're still waiting on the software hive then
    // we shouldn't do any further processing for this.
    //
    if (BrdgGpoWaitingOnSoftwareHive())
    {
        return;
    }

    if (NetworkMatch && !BrdgGpoAllowedToBridge())
    {
        BrdgFwdChangeBridging(FALSE);
    }
    else
    {
        BrdgFwdChangeBridging(TRUE);
    }
}

VOID
BrdgGpoCheckForMatchAndUpdateMode()
/*++

Routine Description:
    
    This looks for a matching network and group policy network and
    attempts to update the bridging status accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    status;

    if (NULL != g_BrdgGpoGlobals.ListHeadNetworks)
    {
        status = BrdgGpoMatchNetworkName(   g_BrdgGpoGlobals.ListHeadNetworks, 
                                            &g_BrdgGpoGlobals.GroupPolicyNetworkName,
                                            g_BrdgGpoGlobals.NetworkListLock);
        
        if (BRDG_STATUS_EMPTY_LIST != status)
        {
            if (STATUS_SUCCESS == status)
            {
                //
                // We found a match.  Check if we're allowed to run.
                //
                BrdgGpoUpdateBridgeMode(BRDG_ON_SAME_NETWORK);
            }
            else if (STATUS_NO_MATCH == status)
            {
                //
                // No match, but we may need to turn bridging back on.
                //
                BrdgGpoUpdateBridgeMode(BRDG_ON_DIFFERENT_NETWORK);
            }
            else
            {
                // We should never get here.
                SAFEASSERT(FALSE);
            }
        }
        else if (BrdgGpoAllowedToBridge())
        {
            BrdgFwdChangeBridging(TRUE);
        }
    }
}

NTSTATUS BrdgGpoGetCurrentNetwork(
    IN  PUNICODE_STRING RegKeyName,
    OUT PWCHAR*         NetworkName)
/*++

Routine Description:
    
    Determines the current network that we are on.  This either uses the DHCP Domain name,
    or the IP Address ANDed with the Subnet mask.
    
    For example: 10.251.1.3 AND 255.0.0.0 results in a network of 10.0.0.0
    
    This routine MUST be called at IRQL = PASSIVE_LEVEL.

Arguments:

    RegKeyName  (IN)    -   The RegistryKey for the adapter we're interested in.
    
    NetworkName (OUT)   -   The network we're currently one.
    

Return Value(s):

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER
    STATUS_NO_IP_ADDRESSES - if we've released the only address we have.
    
    Out of memory can also be returned.

--*/
{
    NTSTATUS    status;
    PWCHAR      lpszNetworkName = NULL;
    BOOLEAN     HaveNetwork = FALSE;
    BOOLEAN     HaveDhcpDomain = FALSE;
    WCHAR       BaseNetwork[MAX_IP4_STRING_LEN];
    PWCHAR      DhcpIPAddress = NULL;
    ULONG       DhcpIPAddrLen = 0;
    
    if (!RegKeyName || !NetworkName)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(BaseNetwork, MAX_IP4_STRING_LEN * sizeof(WCHAR));

    *NetworkName = NULL;
    
    //
    // We don't have a valid Network Name.  Attempt to build one
    // from the DhcpIPAddess and DhcpSubnetMask.
    //
    status = BrdgReadRegUnicode(RegKeyName,
                                L"DhcpIPAddress",
                                &DhcpIPAddress,
                                &DhcpIPAddrLen);
    if (NT_SUCCESS(status))
    {
        PWCHAR  DhcpSubnetMask = NULL;
        ULONG   DhcpSubnetMaskLen = 0;

        status = BrdgReadRegUnicode(RegKeyName, 
                                    L"DhcpSubnetMask",
                                    &DhcpSubnetMask,
                                    &DhcpSubnetMaskLen);
        if (NT_SUCCESS(status))
        {
            LPWSTR Terminator;
            in_addr ipaddr;
            in_addr subnet;
            //
            // We and the two values together to get the Network.
            // For example: 10.251.1.3 AND 255.0.0.0 gives 10.0.0.0
            //
            status = BrdgTdiIpv4StringToAddress(DhcpIPAddress, 
                                                FALSE,
                                                &Terminator,
                                                &ipaddr);

            if (NT_SUCCESS(status))
            {
                in_addr network;
                status = BrdgTdiIpv4StringToAddress(DhcpSubnetMask,
                                                    FALSE,
                                                    &Terminator,
                                                    &subnet);
                network.S_un.S_addr = ipaddr.S_un.S_addr & subnet.S_un.S_addr;
                DBGPRINT(GPO, 
                        ("in_addr  = %u.%u.%u.%u\r\n",
                          network.S_un.S_un_b.s_b1, network.S_un.S_un_b.s_b2,
                          network.S_un.S_un_b.s_b3, network.S_un.S_un_b.s_b4));
                
                //
                // Do we have a valid IPaddress
                //
                if (0 != ipaddr.S_un.S_addr)
                {
                    _snwprintf( BaseNetwork,
                                MAX_IP4_STRING_LEN,
                                L"%u.%u.%u.%u",
                                network.S_un.S_un_b.s_b1,
                                network.S_un.S_un_b.s_b2,
                                network.S_un.S_un_b.s_b3,
                                network.S_un.S_un_b.s_b4);
                    HaveNetwork = TRUE;
                }
            }
        }
    }

    if (!HaveNetwork)
    {
        PWCHAR  IPAddress = NULL;
        ULONG   IPAddrLen = 0;

        status = BrdgReadRegUnicode(RegKeyName,
                                    L"IPAddress",
                                    &IPAddress,
                                    &IPAddrLen);
        if (NT_SUCCESS(status))
        {
            PWCHAR  SubnetMask = NULL;
            ULONG   SubnetMaskLen = 0;
        
            status = BrdgReadRegUnicode(RegKeyName, 
                                        L"SubnetMask",
                                        &SubnetMask,
                                        &SubnetMaskLen);
            if (NT_SUCCESS(status))
            {
                LPWSTR Terminator;
                in_addr ipaddr;
                in_addr subnet;

                //
                // We and the two values together to get the Network.
                // For example: 10.251.1.3 AND 255.0.0.0 gives 10.0.0.0
                //
                status = BrdgTdiIpv4StringToAddress(IPAddress, 
                                                    FALSE,
                                                    &Terminator,
                                                    &ipaddr);
            
                if (NT_SUCCESS(status))
                {
                    in_addr network;
                    status = BrdgTdiIpv4StringToAddress(SubnetMask,
                                                        FALSE,
                                                        &Terminator,
                                                        &subnet);

                    network.S_un.S_addr = ipaddr.S_un.S_addr & subnet.S_un.S_addr;

                    DBGPRINT(GPO, 
                            ("in_addr  = %u.%u.%u.%u\r\n",
                            network.S_un.S_un_b.s_b1, network.S_un.S_un_b.s_b2,
                            network.S_un.S_un_b.s_b3, network.S_un.S_un_b.s_b4));
                
                    //
                    // Do we have a valid IPaddress
                    //
                    if (0 != ipaddr.S_un.S_addr)
                    {
                        _snwprintf( BaseNetwork,
                                    MAX_IP4_STRING_LEN,
                                    L"%u.%u.%u.%u",
                                    network.S_un.S_un_b.s_b1,
                                    network.S_un.S_un_b.s_b2,
                                    network.S_un.S_un_b.s_b3,
                                    network.S_un.S_un_b.s_b4);
                        HaveNetwork = TRUE;
                    }
                }
            }
        }
    }

    if (!HaveNetwork)
    {
        //
        // Returning this will cause us not to update the network name this
        // card.
        //
        status = STATUS_NO_IP_ADDRESSES;
    }
    else if (HaveDhcpDomain)
    {
        *NetworkName = lpszNetworkName;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = NdisAllocateMemoryWithTag(NetworkName,
                                           ((UINT)wcslen(BaseNetwork) + 1) * sizeof(WCHAR), 
                                           'gdrB');
        wcscpy(*NetworkName, BaseNetwork);
    }

    return status;
}


// ===========================================================================
//
// NETWORK LIST MANIPULATION FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgGpoInitializeNetworkList()
/*++

Routine Description:
    
    Initializes the Network List and Lock.

    This can can be called at any IRQL (but since it's called from driver entry, 
    it will most likely be called at PASSIVE_LEVEL).

Arguments:

    None.

Return Value(s):

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

    g_BrdgGpoGlobals.ListHeadNetworks = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL != g_BrdgGpoGlobals.ListHeadNetworks)
    {
        InitializeListHead(g_BrdgGpoGlobals.ListHeadNetworks);
        g_BrdgGpoGlobals.NetworkListLock = ExAllocatePoolWithTag(NonPagedPool, sizeof(NDIS_RW_LOCK), 'gdrB');
        if (g_BrdgGpoGlobals.NetworkListLock)
        {
            NdisInitializeReadWriteLock(g_BrdgGpoGlobals.NetworkListLock);
            status = STATUS_SUCCESS;
        }
        else
        {
            ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
        }
    }

    return status;
}

VOID
BrdgGpoUninitializeNetworkList()
/*++

Routine Description:
    
    Frees the memory associated with the Network List.

    This can be called at IRQL <= DISPATCH_LEVEL but is likely
    to be called at PASSIVE_LEVEL as it's during shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
    ExFreePool(g_BrdgGpoGlobals.NetworkListLock);
}


VOID
BrdgGpoAcquireNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN      BOOLEAN          fWrite,
    IN OUT  PLOCK_STATE      LockState
    )
/*++

Routine Description:
    
    Acquires the NetworkList read-write lock.  We support a NULL Lock
    as it allows us to acquire for write and then call functions that 
    need the lock for read without locking up the system (by 
    supplying NULL for the lock).

    This can be called at IRQL <= DISPATCH_LEVEL

Arguments:

    NetworkListLock     -   Read-Write Lock to be acquired.

    fWrite              -   TRUE == Write Access, FALSE == Read Access

    LockState           -   Opaque value used by NDIS.


Return Value:

    None.

--*/
{
    if (NetworkListLock)
    {
        NdisAcquireReadWriteLock(NetworkListLock, fWrite, LockState);
    }
}

VOID
BrdgGpoReleaseNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN OUT  PLOCK_STATE      LockState
    )
/*++

Routine Description:
    
    Releases the NetworkList read-write lock.  We support a NULL Lock
    as it allows us to acquire for write and then call functions that 
    need the lock for read without locking up the system (by 
    supplying NULL for the lock).

    This can be called at IRQL <= DISPATCH_LEVEL

Arguments:

    NetworkListLock     -   Read-Write Lock to be released.

    LockState           -   Opaque value used by NDIS.

Return Value:

    None.

--*/
{
    if (NetworkListLock)
    {
        NdisReleaseReadWriteLock(NetworkListLock, LockState);
    }
}

NTSTATUS
BrdgGpoAllocateAndInitializeNetwork(
    IN OUT PBRDG_GPO_NETWORKS*  Network,
    IN PWCHAR                   Identifier,
    IN PWCHAR                   NetworkName
    )
/*++

Routine Description:

    Allocates the memory needed for a Network structure from the NonPaged pool
    and copies the data into the structure.

    Must be called at IRQL <= APC_LEVEL.
    
Arguments:

    Network     -   The structure to be allocated and initialized with the data.

    Identifier  -   The AdapterID for this network structure.

    NetworkName -   The current network that we are on.  This can be NULL if we 
                    haven't determined a network yet.

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PBRDG_GPO_NETWORKS  pNetwork;
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    
    *Network = NULL;

    if (!BrdgGpoProcessingNotifications())
    {
        return STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Everything in this struct will be used at DISPATCH_LEVEL, so all of it is
    // allocated from the NonPagedPool
    //
    pNetwork = ExAllocatePoolWithTag(NonPagedPool, sizeof(BRDG_GPO_NETWORKS), 'gdrB');
    if (NULL != pNetwork)
    {
        PUNICODE_STRING pIdentifier = NULL;
        PUNICODE_STRING pNetworkName = NULL;
        LPWSTR lpszIdentifier = NULL;
        LPWSTR lpszNetworkName = NULL;

        pIdentifier = ExAllocatePoolWithTag(NonPagedPool, sizeof(UNICODE_STRING), 'gdrB');
        if (pIdentifier)
        {
            pNetworkName = ExAllocatePoolWithTag(NonPagedPool, sizeof(UNICODE_STRING), 'gdrB');
            if (pNetworkName)
            {
                lpszIdentifier = ExAllocatePoolWithTag(NonPagedPool, (wcslen(Identifier) + 1) * sizeof(WCHAR), 'gdrB');
                if (lpszIdentifier)
                {
                    RtlZeroMemory(lpszIdentifier, wcslen(Identifier) + 1);
                    wcscpy(lpszIdentifier, Identifier);

                    //
                    // A NULL Network name is valid, so we only allocate it if we are passed one.
                    //

                    if (NetworkName)
                    {
                        lpszNetworkName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(NetworkName) + 1) * sizeof(WCHAR), 'gdrB');
                        if (lpszNetworkName)
                        {
                            RtlZeroMemory(lpszNetworkName, wcslen(NetworkName) + 1);
                            wcscpy(lpszNetworkName, NetworkName);
                        }
                    }

                    //
                    // This is a Logical AND operation:
                    // Either we have both or we have neither.  We can't have one and not the other, if we do 
                    // then we didn't succeed the last allocate.
                    //
                    if ((NetworkName && lpszNetworkName) || (!NetworkName && !lpszNetworkName))
                    {
                        RtlInitUnicodeString(pIdentifier, lpszIdentifier);
                        //
                        // This may be NULL, but that's fine, since it means we'll add it when it gets written.
                        //
                        RtlInitUnicodeString(pNetworkName, lpszNetworkName);

                        pNetwork->Identifier = pIdentifier;
                        pNetwork->NetworkName = pNetworkName;
                        pNetwork->ListEntry.Blink = NULL;
                        pNetwork->ListEntry.Flink = NULL;

                        *Network = pNetwork;
                        status = STATUS_SUCCESS;
                    }
                }
            }
        }

        if (!NT_SUCCESS(status))
        {
            if (lpszIdentifier)
            {
                ExFreePool(lpszIdentifier);
            }
            if (pIdentifier)
            {
                ExFreePool(pIdentifier);
            }
            if (pNetworkName)
            {
                ExFreePool(pNetworkName);
            }
            if (pNetwork)
            {
                ExFreePool(pNetwork);
            }
        }
    }

    return status;
}

VOID
BrdgGpoFreeNetworkAndData(
    IN  PBRDG_GPO_NETWORKS  Network)
/*++

Routine Description:
    
    This frees any data associated with a particular network.

    This can be called IRQL <= DISPATCH_LEVEL.

Arguments:

    Network -   Structure containing an ID and Network name
                for an adapter.

Return Value:

    None.

--*/
{
    //
    // First free the data associated with this entry
    //
    if (Network->Identifier)
    {
        if (Network->Identifier->Buffer)
        {
            ExFreePool(Network->Identifier->Buffer);
        }
        ExFreePool(Network->Identifier);
    }
    if (Network->NetworkName)
    {
        if (Network->NetworkName->Buffer)
        {
            ExFreePool(Network->NetworkName->Buffer);
        }
        ExFreePool(Network->NetworkName);
    }
    //
    // Now free the structure
    //
    ExFreePool(Network);
}

NTSTATUS
BrdgGpoEmptyNetworkList(
    IN      PLIST_ENTRY         NetworkList,
    IN      PNDIS_RW_LOCK       NetworkListLock)
/*++

Routine Description:
    
    Empties the existing list and frees all the items.
    Do not acquire the list lock before calling this function.

Arguments:

    NetworkList     -   The list of current networks.

    NetworkListLock -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    LOCK_STATE              LockState;

    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);
    //
    // Loop through the list deleting the entries.
    //
    while (!IsListEmpty(NetworkList))
    {
        PBRDG_GPO_NETWORKS  Network;
        PLIST_ENTRY         pListEntry;

        pListEntry = RemoveHeadList(NetworkList);

        Network = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);
        BrdgGpoFreeNetworkAndData(Network);
    }

    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}
                     
NTSTATUS
BrdgGpoInsertNetwork(
    IN PLIST_ENTRY              NetworkList,
    IN PLIST_ENTRY              Network,
    IN PNDIS_RW_LOCK            NetworkListLock)
/*++

Routine Description:
    
    This routine is responsible for adding a new Network to the list.  
    If someone attempts to insert an existing item, an error is returned.
    The caller is responsible for calling BrdgGpoUpdateNetworkName instead.

    This routine can be called at IRQL <= DISPATCH_LEVEL.

Arguments:

    NetworkList     -   The list of current networks.

    Network         -   The new Network entry to add to the list.
  
    NetworkListLock -   Ndis Read Write Lock for synchronizing changes to the list.
    
Return Value:

    STATUS_SHUTDOWN_IN_PROGRESS -   We're busy shutting down, so the item was not added.
    STATUS_INVALID_PARAMETER    -   One or more of the parameters was NULL.
    STATUS_DUPLICATE_NAME       -   This entry already exists in the list.
    STATUS_SUCCESS              -   We successfully added the entry to the list.


--*/
{
    PBRDG_GPO_NETWORKS          pNetwork = NULL;
    PBRDG_GPO_NETWORKS          NewNetwork = NULL;
    LOCK_STATE                  LockState;
    NTSTATUS                    status;
    BOOLEAN                     ShuttingDown;

    if (!NetworkList || !Network || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lock the list for update
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);

    ShuttingDown = !BrdgGpoProcessingNotifications();

    if (!ShuttingDown)
    {
        NewNetwork = CONTAINING_RECORD(Network, BRDG_GPO_NETWORKS, ListEntry);
    
        //
        // We do this to prevent us accidentally inserting a duplicate item.  We grab the lock before so that
        // we can't insert the same item twice.
        //
        status = BrdgGpoFindNetwork(    NetworkList,
                                        NewNetwork->Identifier,
                                        NULL,  // We have already grabbed the lock for Write access.
                                        &pNetwork);

        if (STATUS_NOT_FOUND == status)
        {
            InsertTailList(NetworkList, Network);
            status = STATUS_SUCCESS;
        }
        else if (STATUS_SUCCESS == status)
        {
            status = STATUS_DUPLICATE_NAME;
        }
    }
    else
    {
        status = STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Release the lock, we're done updating
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoDeleteNetwork(
    IN PLIST_ENTRY              NetworkList,
    IN PUNICODE_STRING          NetworkIdentifier,
    IN PNDIS_RW_LOCK            NetworkListLock)
/*++

Routine Description:
    
    Deletes an existing network entry.

Arguments:

    NetworkList         -   The list of current networks.

    NetworkIdentifier   -   A unique identifier that identifies which Network entry to remove.
    
    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_NOT_FOUND    -   We couldn't find and entry matching the identifier.
    STATUS_SUCCESS      -   We were able to remove the entry successfully.

*/
{
    PBRDG_GPO_NETWORKS          pNetwork = NULL;
    LOCK_STATE                  LockState;
    NTSTATUS                    status = STATUS_NOT_FOUND;
   
    //
    // Lock the list for update
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);
    
    //
    // Find the entry;
    //
    status = BrdgGpoFindNetwork(    NetworkList,
                                    NetworkIdentifier,
                                    NULL,  // We have already grabbed the lock for Write access.
                                    &pNetwork);
    
    if (NT_SUCCESS(status))
    {
        RemoveEntryList(&pNetwork->ListEntry);
        BrdgGpoFreeNetworkAndData(pNetwork);

        pNetwork = NULL;
        status = STATUS_SUCCESS;
    }
    
    //
    // Release the lock, we're done updating
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoFindNetwork(
    IN  PLIST_ENTRY         NetworkList,
    IN  PUNICODE_STRING     NetworkIdentifier,
    IN  PNDIS_RW_LOCK       NetworkListLock,
    OUT PBRDG_GPO_NETWORKS* Network
                   )
/*++

Routine Description:

    Finds a particular Network in the list of networks.
  
Arguments:

    NetworkList         -   The list of current networks.

    NetworkIdentifier   -   A unique identifier that identifies which Network entry to remove.

    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

    Network             -   The item if found, NULL otherwise.
    
Return Value:

    STATUS_NOT_FOUND    -   No entry matching the identifier could be found.
    STATUS_SUCCESS      -   The entry was successfully found.

--*/
{
    PLIST_ENTRY         pListEntry;
    LOCK_STATE          LockState;
    NTSTATUS            status = STATUS_NOT_FOUND;
    
    if (!NetworkIdentifier || !Network)  // We can have a NULL list lock.
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Set the value to NULL so it isn't accidentally used by someone who doesn't realise
    // that they didn't really get a record back.
    //
    *Network = NULL;
    
    if (IsListEmpty(NetworkList))
    {
        return STATUS_NOT_FOUND;
    }

    //
    // Lock the list for read
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, FALSE /* Read-only */, &LockState);

    //
    // Loop through the list looking for an entry with the same identifier
    //
    for (pListEntry = NetworkList->Flink; pListEntry != NetworkList; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NETWORKS CurrentNetwork;

        CurrentNetwork = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);

        //
        // Compare this entries network to the network name that was passed in.
        //

        if ((NULL != CurrentNetwork->NetworkName->Buffer) && 
            (0 == _wcsicmp(CurrentNetwork->Identifier->Buffer, NetworkIdentifier->Buffer)))
        {
            *Network = CurrentNetwork;
            status = STATUS_SUCCESS;
            break;
        }
    }

    //
    // Release the lock, we're done searching
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}

NTSTATUS
BrdgGpoMatchNetworkName(
    IN  PLIST_ENTRY         NetworkList,
    IN  PUNICODE_STRING     NetworkName,
    IN  PNDIS_RW_LOCK       NetworkListLock
                       )
/*++

Routine Description:
    

    Enumerates through the list looking for a match for the supplied Network Name.
    
    This can be called on IRQL <= DISPATCH_LEVEL
    
Arguments:

    NetworkList     -   The list through which to enumerate.

    NetworkName     -   The name to look for.

    NetworkListLock -   The NDIS read-write lock for the list.


Return Value:

    STATUS_NO_MATCH -   No match could be found.
    STATUS_SUCCESS  -   We found a matching Network Name.

--*/
{
    PLIST_ENTRY         pListEntry;
    LOCK_STATE          LockState;
    NTSTATUS            status = STATUS_NO_MATCH;

    if (!NetworkList || !NetworkName || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lock the list for read
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, FALSE /* Read */, &LockState);

    if (!IsListEmpty(NetworkList))
    {
        //
        // Loop through the list looking for an entry with the same NetworkName
        //
        for (pListEntry = NetworkList->Flink; pListEntry != NetworkList; pListEntry = pListEntry->Flink)  
        {
            PBRDG_GPO_NETWORKS  CurrentNetwork;

            CurrentNetwork = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);
        
            //
            // The network name can be empty, so we don't want to compare if this is the case.
            //
            if ((NULL != CurrentNetwork->NetworkName->Buffer) && 
                (NULL != NetworkName->Buffer) &&
                (0 == _wcsicmp(CurrentNetwork->NetworkName->Buffer, NetworkName->Buffer)))
            {
                status = STATUS_SUCCESS;
                break;
            }
        }
    }
    else
    {
        status = BRDG_STATUS_EMPTY_LIST;
    }

    //
    // Release the lock, we're done searching
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);    

    return status;
}

NTSTATUS
BrdgGpoUpdateNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         Identifier,
    IN  PWCHAR                  NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock
                        )
/*++

Routine Description:

    Finds a particular Network in the list of networks.
  
Arguments:

    NetworkList         -   The list of current networks.

    Identifier          -   A unique identifier that identifies which Network entry to update.

    NetworkName         -   The new network name for this identifier.

    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_NOT_FOUND    -   No entry matching the identifier could be found.
    STATUS_SUCCESS      -   The entry was successfully found.

--*/
{
    PBRDG_GPO_NETWORKS  pNetwork;
    NTSTATUS            status = STATUS_SUCCESS;
    LOCK_STATE          LockState;
    PUNICODE_STRING     pNetworkName = NULL;
    LPWSTR              lpszNetworkName = NULL;
    
    if (!NetworkList || !Identifier || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate space for the new network name from NonPagedPool 
    // (it will be accessed from DISPATCH_LEVEL
    //
    pNetworkName = ExAllocatePool(NonPagedPool, sizeof(UNICODE_STRING));
    if (pNetworkName)
    {
        RtlZeroMemory(pNetworkName, sizeof(UNICODE_STRING));
        if (NetworkName)
        {
            lpszNetworkName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(NetworkName) + 1) * sizeof(WCHAR), 'gdrB');
            if (NULL == lpszNetworkName)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                wcscpy(lpszNetworkName, NetworkName);
            }
        }

        if (NT_SUCCESS(status))
        {
            RtlInitUnicodeString(pNetworkName, lpszNetworkName);
        }
        else
        {
            //
            // We failed to allocate the actual string, so free the PUNICODE_STRING
            // as well.
            //
            ExFreePool(pNetworkName);
            return status;
        }
    }
    else
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    //
    // Lock the list for update (this will pend until all readers have released the lock).
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);

    //
    // We pass NULL as the RW-Lock here because we've already locked it and 
    // we don't want this entry going away while we're still busy with it 
    // (which could happen between a find and an update if we locked twice).
    //
    status = BrdgGpoFindNetwork(NetworkList, Identifier, NULL, &pNetwork);
    if (NT_SUCCESS(status))
    {
        //
        // We first free the current networkname associated with this networkid.
        //
        if (pNetwork->NetworkName->Buffer)
        {
            ExFreePool(pNetwork->NetworkName->Buffer);
        }
        ExFreePool(pNetwork->NetworkName);
    
        //
        // We do this even if we were passed a NULL network name (ie.  the Value/Key has been deleted).
        // Since this means we're probably not on the same network or we've gone to static address and,
        // GPO wise, we're not on the same network.
        //
        pNetwork->NetworkName = pNetworkName;
    }
    else
    {
        ExFreePool(pNetworkName);
    }

    //
    // We're done with the update, so we can release the lock.
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgmini.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgmini.c

Abstract:

    Ethernet MAC level bridge.
    Miniport section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgmini.h"
#include "brdgfwd.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// NDIS Wrapper handle
NDIS_HANDLE     gNDISWrapperHandle = NULL;

// Handle to our miniport driver
NDIS_HANDLE     gMiniPortDriverHandle = NULL;

// ----------------------------------------------
// The handle of the miniport (NULL if not initialized)
NDIS_HANDLE     gMiniPortAdapterHandle = NULL;

// Refcount to allow waiting for other code to finish using the miniport
WAIT_REFCOUNT   gMiniPortAdapterRefcount;

// Refcount indicating whether the bridge miniport is media-connected
WAIT_REFCOUNT   gMiniPortConnectedRefcount;

// Refcount indicating whether the bridge miniport is in the middle of a media
// state toggle.
WAIT_REFCOUNT   gMiniPortToggleRefcount;
// ----------------------------------------------
//
// Refcount for use in passing through requests to underlying NICs
// This works because NDIS doesn't make requests re-entrantly. That
// is, only one SetInfo operation can be pending at any given time.
//
LONG            gRequestRefCount;
// ----------------------------------------------
// Virtual characteristics of the bridge adapter
ULONG           gBridgeLinkSpeed = 10000L,          // Start at 1Mbps, since reporting
                                                    // zero makes some components unhappy.
                                                    // Measured in 100's of bps.
                gBridgeMediaState = NdisMediaStateDisconnected;

// MAC Address of the bridge. This does not change once
// it has been set.
UCHAR           gBridgeAddress[ETH_LENGTH_OF_ADDRESS];

// Whether we have chosen an address yet
BOOLEAN         gHaveAddress;

// Current bridge packet filter
ULONG           gPacketFilter = 0L;

// Current multicast list
PUCHAR          gMulticastList = NULL;
ULONG           gMulticastListLength = 0L;

// Device name of the bridge miniport (from the registry)
PWCHAR          gBridgeDeviceName = NULL;
ULONG           gBridgeDeviceNameSize = 0L;

// RW lock to protect all above bridge variables
NDIS_RW_LOCK    gBridgeStateLock;
//-----------------------------------------------
// Name of the registry entry for the device name
const PWCHAR    gDeviceNameEntry = L"Device";

// Description of our miniport
const PCHAR     gDriverDescription = "Microsoft MAC Bridge Virtual NIC";
// ----------------------------------------------
// Device object so user-mode code can talk to us
PDEVICE_OBJECT  gDeviceObject = NULL;

// NDIS handle to track the device object
NDIS_HANDLE     gDeviceHandle = NULL;
// ----------------------------------------------

// List of supported OIDs
NDIS_OID        gSupportedOIDs[] =
{
    // General characteristics
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,

    // Set only characteristics (relayed)
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    OID_GEN_TRANSPORT_HEADER_OFFSET,

    // General statistics
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,

    // Ethernet characteristics
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,

    // Ethernet statistics
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,

    // PnP OIDs
    OID_PNP_QUERY_POWER,
    OID_PNP_SET_POWER,

    // tcp oids
    OID_TCP_TASK_OFFLOAD

};



// 1394 specific related global variables
#define OID_1394_ENTER_BRIDGE_MODE                  0xFF00C914
#define OID_1394_EXIT_BRIDGE_MODE                   0xFF00C915

// Set when the bridge knows that tcpip has been loaded
// set on receiving the OID_TCP_TASK_OFFLOAD Oid
BOOLEAN g_fIsTcpIpLoaded = FALSE;


// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgMiniHalt(
    IN NDIS_HANDLE      MiniportAdapterContext
    );

NDIS_STATUS
BrdgMiniInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN PNDIS_MEDIUM     MediumArray,
    IN UINT             MediumArraySize,
    IN NDIS_HANDLE      MiniportAdapterHandle,
    IN NDIS_HANDLE      WrapperConfigurationContext
    );

NDIS_STATUS
BrdgMiniQueryInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesWritten,
    OUT PULONG          BytesNeeded
    );

NDIS_STATUS
BrdgMiniReset(
    OUT PBOOLEAN        AddressingReset,
    IN NDIS_HANDLE      MiniportAdapterContext
    );

VOID
BrdgMiniSendPackets(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PPNDIS_PACKET    PacketArray,
    IN UINT             NumberOfPackets
    );

NDIS_STATUS
BrdgMiniSetInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesRead,
    OUT PULONG          BytesNeeded
    );

BOOLEAN
BrdgMiniAddrIsInMultiList(
    IN PUCHAR               pTargetAddr
    );

VOID
BrdgMiniRelayedRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       unused
    );

VOID
BrdgMiniReAcquireMiniport();

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================


NTSTATUS
BrdgMiniDriverInit()
/*++

Routine Description:

    Load-time initialization function

    Must run at PASSIVE_LEVEL since we call NdisRegisterDevice().

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS causes driver load
    to fail. Any event causing a failure return code must be logged, as it
    prevents us from loading successfully.

--*/
{
    NDIS_MINIPORT_CHARACTERISTICS   MiniPortChars;
    NDIS_STATUS                     NdisStatus;
    PDRIVER_DISPATCH                DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];
    NDIS_STRING                     DeviceName, LinkName;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    NdisInitializeReadWriteLock( &gBridgeStateLock );
    BrdgInitializeWaitRef( &gMiniPortAdapterRefcount, FALSE );
    BrdgInitializeWaitRef( &gMiniPortConnectedRefcount, TRUE );
    BrdgInitializeWaitRef( &gMiniPortToggleRefcount, FALSE );

    // Put the miniport refcount into shutdown mode (so a refcount can't be acquired)
    // since we don't have a miniport yet
    BrdgShutdownWaitRefOnce( &gMiniPortAdapterRefcount );

    // We start out disconnected so shutdown the media-connect waitref too.
    BrdgShutdownWaitRefOnce( &gMiniPortConnectedRefcount );

    NdisInitUnicodeString( &DeviceName, DEVICE_NAME );
    NdisInitUnicodeString( &LinkName, SYMBOLIC_NAME );

    // Must first tell NDIS we're a miniport driver and initializing
    NdisMInitializeWrapper( &gNDISWrapperHandle, gDriverObject, &gRegistryPath, NULL );

    // Fill in the description of our miniport
    NdisZeroMemory(&MiniPortChars, sizeof(MiniPortChars));
    MiniPortChars.MajorNdisVersion = 5;
    MiniPortChars.MinorNdisVersion = 0;

    MiniPortChars.HaltHandler = BrdgMiniHalt;
    MiniPortChars.InitializeHandler  = BrdgMiniInitialize;
    MiniPortChars.QueryInformationHandler  = BrdgMiniQueryInfo;
    MiniPortChars.ResetHandler = BrdgMiniReset;
    MiniPortChars.SendPacketsHandler = BrdgMiniSendPackets;
    MiniPortChars.SetInformationHandler  = BrdgMiniSetInfo;

    //
    // Wire the ReturnPacketHandler straight into the forwarding engine
    //
    MiniPortChars.ReturnPacketHandler = BrdgFwdReturnIndicatedPacket;

    // Create a virtual NIC
    NdisStatus = NdisIMRegisterLayeredMiniport( gNDISWrapperHandle, &MiniPortChars, sizeof(MiniPortChars),
                                                &gMiniPortDriverHandle );


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPORT_REGISTER_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(MINI, ("Failed to create an NDIS virtual NIC: %08x\n", NdisStatus));
        NdisTerminateWrapper( gNDISWrapperHandle, NULL );
        return NdisStatus;
    }

    //
    // Initialize Dispatch Table array before setting selected members
    //
    NdisZeroMemory( DispatchTable, sizeof( DispatchTable ) );

    //
    // Register a device object and symbolic link so user-mode code can talk to us
    //
    DispatchTable[IRP_MJ_CREATE] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_CLEANUP] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_CLOSE] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_DEVICE_CONTROL] = BrdgDispatchRequest;

    NdisStatus = NdisMRegisterDevice( gNDISWrapperHandle, &DeviceName, &LinkName, DispatchTable,
                                      &gDeviceObject, &gDeviceHandle );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_DEVICE_CREATION_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(MINI, ("Failed to create a device object and sym link: %08x\n", NdisStatus));
        NdisIMDeregisterLayeredMiniport( gMiniPortDriverHandle );
        NdisTerminateWrapper( gNDISWrapperHandle, NULL );
        return NdisStatus;
    }

    // Register the unload function
    NdisMRegisterUnloadHandler(gNDISWrapperHandle, BrdgUnload);

    return STATUS_SUCCESS;
}

VOID
BrdgMiniCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown function

    This function is guaranteed to be called exactly once

    Must run at PASSIVE_LEVEL since we call NdisIMDeInitializeDeviceInstance

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS     NdisStatus;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(MINI, ("BrdgMiniCleanup\n"));

    if( gMiniPortAdapterHandle != NULL )
    {
        SAFEASSERT( gNDISWrapperHandle != NULL );

        // This should cause a call to BrdgMiniHalt where gMiniPortAdapterHandle
        // is NULLed out

        NdisStatus = NdisIMDeInitializeDeviceInstance( gMiniPortAdapterHandle );
        SAFEASSERT( NdisStatus == NDIS_STATUS_SUCCESS );
    }
    else
    {
        //
        // Tear down our device object. This is normally done when the miniport
        // shuts down, but in scenarios where the miniport was never created,
        // the device object still exists at this point.
        //
        NDIS_HANDLE     Scratch = gDeviceHandle;

        if( Scratch != NULL )
        {
            // Tear down the device object
            gDeviceHandle = gDeviceObject = NULL;
            NdisMDeregisterDevice( Scratch );
        }
    }

    // Unregister ourselves as an intermediate driver
    NdisIMDeregisterLayeredMiniport( gMiniPortDriverHandle );
}

BOOLEAN
BrdgMiniIsBridgeDeviceName(
    IN PNDIS_STRING         pDeviceName
    )
/*++

Routine Description:

    Compares a device name to the current device name of the bridge miniport.

    This actually requires that we allocate memory, so it should be called sparingly.

Arguments:

    pDeviceName             The name of a device

Return Value:

    TRUE if the names match (case is ignored), FALSE otherwise.

--*/
{
    LOCK_STATE              LockState;
    BOOLEAN                 rc = FALSE;
    NDIS_STATUS             Status;
    ULONG                   BridgeNameCopySize = 0L;
    PWCHAR                  pBridgeNameCopy = NULL;

    // The bridge device name must be read inside the gBridgeStateLock
    NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE/*Read access*/, &LockState );

    if( gBridgeDeviceName != NULL )
    {
        if( gBridgeDeviceNameSize > 0 )
        {
            // Alloc memory for the copy of the name
            Status = NdisAllocateMemoryWithTag( &pBridgeNameCopy, gBridgeDeviceNameSize, 'gdrB' );

            if( Status == NDIS_STATUS_SUCCESS )
            {
                // Copy the name
                NdisMoveMemory( pBridgeNameCopy, gBridgeDeviceName, gBridgeDeviceNameSize );
                BridgeNameCopySize = gBridgeDeviceNameSize;
            }
            else
            {
                SAFEASSERT( pBridgeNameCopy == NULL );
            }
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    if( pBridgeNameCopy != NULL )
    {
        NDIS_STRING         NdisStr;

        NdisInitUnicodeString( &NdisStr, pBridgeNameCopy );

        if( NdisEqualString( &NdisStr, pDeviceName, TRUE/*Ignore case*/ ) )
        {
            rc = TRUE;
        }

        NdisFreeMemory( pBridgeNameCopy, BridgeNameCopySize, 0 );
    }

    return rc;
}

VOID
BrdgMiniInstantiateMiniport()
/*++

Routine Description:

    Instantiates the virtual NIC we expose to overlying protocols.

    At least one adapter must be in the global adapter list, since we build
    our MAC address with the MAC address of the first bound adapter.

    Must run at < DISPATCH_LEVEL since we call NdisIMInitializeDeviceInstanceEx

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    NTSTATUS                NtStatus;
    NDIS_STRING             NdisString;
    LOCK_STATE              LockState;
    PWCHAR                  pDeviceName;
    ULONG                   DeviceNameSize;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    DBGPRINT(MINI, ("About to instantiate the miniport...\n"));

    //
    // Retrieve our device name from the registry
    // (it is written there by our notify object during install)
    //
    NtStatus = BrdgReadRegUnicode( &gRegistryPath, gDeviceNameEntry, &pDeviceName, &DeviceNameSize );

    if( NtStatus != STATUS_SUCCESS )
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING, 0, 0, NULL,
                                sizeof(NTSTATUS), &NtStatus );
        DBGPRINT(MINI, ("Failed to retrieve the miniport's device name: %08x\n", NtStatus));
        return;
    }

    SAFEASSERT( pDeviceName != NULL );
    DBGPRINT(MINI, ("Initializing miniport with device name %ws\n", pDeviceName));

    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

    if( ! gHaveAddress )
    {
        // We don't have a MAC address yet. This is fatal.
        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(MINI, ("Failed to determine a MAC address: %08x\n", Status));
        NdisFreeMemory( pDeviceName, DeviceNameSize, 0 );
        return;
    }

    //
    // Save the device name in our global for use until we reinitialize.
    // Must do this before calling NdisIMInitializeDeviceInstanceEx, since NDIS calls
    // BrdgProtBindAdapter in the context of our call to NdisIMInitializeDeviceInstanceEx
    // and we want to consult the bridge's device name when binding
    //

    if( gBridgeDeviceName != NULL )
    {
        // Free the old name
        NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
    }

    gBridgeDeviceName = pDeviceName;
    gBridgeDeviceNameSize = DeviceNameSize;

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    // Go ahead and intantiate the miniport.
    NdisInitUnicodeString( &NdisString, pDeviceName );
    Status = NdisIMInitializeDeviceInstanceEx(gMiniPortDriverHandle, &NdisString, NULL);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Log this error since it means we can't create the miniport
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPORT_INIT_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );

        DBGPRINT(MINI, ("NdisIMInitializeDeviceInstanceEx failed: %08x\n", Status));

        // Destroy the stored device name for the miniport
        NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

        if( gBridgeDeviceName != NULL )
        {
            // Free the old name
            NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
        }

        gBridgeDeviceName = NULL;
        gBridgeDeviceNameSize = 0L;

        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
    }
}

BOOLEAN
BrdgMiniShouldIndicatePacket(
    IN PUCHAR               pTargetAddr
    )
/*++

Routine Description:

    Determines whether an inbound packet should be indicated to overlying protocols through
    our virtual NIC

Arguments:

    pTargetAddr             The target MAC address of a packet

Return Value:

    TRUE          :         The packet should be indicated
    FALSE         :         The packet should not be indicated

--*/
{
    BOOLEAN                 bIsBroadcast, bIsMulticast, bIsLocalUnicast, rc = FALSE;
    LOCK_STATE              LockState;

    if( gMiniPortAdapterHandle == NULL )
    {
        // Yikes! The miniport isn't set up yet. Definitely don't indicate!
        return FALSE;
    }

    bIsBroadcast = ETH_IS_BROADCAST(pTargetAddr);
    bIsMulticast = ETH_IS_MULTICAST(pTargetAddr);
    bIsLocalUnicast = BrdgMiniIsUnicastToBridge(pTargetAddr);

    // Get read access to the packet filter
    NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read-only*/, &LockState );

    do
    {
        // Promiscuous / ALL_LOCAL means indicate everything
        if( (gPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) != 0 )
        {
            rc = TRUE;
            break;
        }

        if( ((gPacketFilter & NDIS_PACKET_TYPE_BROADCAST) != 0) && bIsBroadcast )
        {
            rc = TRUE;
            break;
        }

        if( ((gPacketFilter & NDIS_PACKET_TYPE_DIRECTED) != 0) && bIsLocalUnicast )
        {
            rc = TRUE;
            break;
        }

        if( bIsMulticast )
        {
            if( (gPacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) != 0 )
            {
                rc = TRUE;
                break;
            }
            else if( (gPacketFilter & NDIS_PACKET_TYPE_MULTICAST) != 0 )
            {

                rc = BrdgMiniAddrIsInMultiList( pTargetAddr );
            }
        }
    }
    while (FALSE);

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    return rc;
}

BOOLEAN
BrdgMiniIsUnicastToBridge (
    IN PUCHAR               Address
    )
/*++

Routine Description:

    Determines whether a given packet is a directed packet unicast straight to
    the bridge's host machine

Arguments:

    Address                 The target MAC address of a packet

Return Value:

    TRUE            :       This is a directed packet destined for the local machine
    FALSE           :       The above is not true

--*/
{
    UINT                    Result;

    if( gHaveAddress )
    {
        // Not necessary to acquire a lock to read gBridgeAddress since it cannot
        // change once it is set.
        ETH_COMPARE_NETWORK_ADDRESSES_EQ( Address, gBridgeAddress, &Result );
    }
    else
    {
        // We have no MAC address, so this can't be addressed to us!
        Result = 1;         // Inequality
    }

    return (BOOLEAN)(Result == 0);   // Zero is equality
}

VOID
BrdgMiniAssociate()
/*++

Routine Description:

    Associates our miniport with our protocol

    Must run at PASSIVE_LEVEL

Arguments:

    None

Return Value:

    None

--*/
{
    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Associate ourselves with the protocol section in NDIS's tortured mind
    NdisIMAssociateMiniport( gMiniPortDriverHandle, gProtHandle );
}

VOID
BrdgMiniDeferredMediaDisconnect(
    IN PVOID            arg
    )
/*++

Routine Description:

    Signals a media-disconnect to NDIS

    Must run at PASSIVE IRQL, since we have to wait for all packet indications
    to complete before indicating media-disconnect.

Arguments:

    arg                 The bridge miniport handle (must be released)

Return Value:

    None

--*/
{
    NDIS_HANDLE         MiniportHandle = (NDIS_HANDLE)arg;

    if( BrdgShutdownBlockedWaitRef(&gMiniPortConnectedRefcount) )
    {
        // Nobody can indicate packets anymore.

        LOCK_STATE      LockState;

        //
        // Close a timing window: we may have just gone media-connect but our high-IRQL
        // processing may not yet have reset the wait-refcount. Serialize here so it's
        // impossible for us to signal a disconnect to NDIS after we have actually
        // gone media-connect.
        //
        // This RELIES on high-IRQL processing acquiring gBridgeStateLock to set
        // gBridgeMediaState to NdisMediaStateConnected BEFORE signalling the
        // media-connected state to NDIS.
        //
        NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read access*/, &LockState );

        if( gBridgeMediaState == NdisMediaStateDisconnected )
        {
            DBGPRINT(MINI, ("Signalled media-disconnect from deferred function\n"));
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0L );
        }
        else
        {
            DBGPRINT(MINI, ("Aborted deferred media-disconnect: media state inconsistent\n"));
        }

        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
    }
    else
    {
        // Someone set us back to the connected state before we got executed
        DBGPRINT(MINI, ("Aborted deferred media-disconnect: wait-ref reset\n"));
    }

    BrdgMiniReleaseMiniport();
}

VOID
BrdgMiniDeferredMediaToggle(
    IN PVOID            arg
    )
/*++

Routine Description:

    Signals a media-disconnect to NDIS followed quickly by a media-connect. Used
    to indicate to upper-layer protocols like TCPIP that the bridge may have
    disconnected from a network segment it could previously reach, or that we may
    now be able to reach a network segment that we couldn't before.

    Must run at PASSIVE IRQL, since we have to wait for all packet indications
    to complete before indicating media-disconnect.

Arguments:

    arg                 The bridge miniport handle (must be released)

Return Value:

    None

--*/
{
    NDIS_HANDLE         MiniportHandle = (NDIS_HANDLE)arg;

    // We need a guarantee that the miniport is media-connect to be able to do
    // the toggle properly.
    if( BrdgIncrementWaitRef(&gMiniPortConnectedRefcount) )
    {
        // Stop people from indicating packets
        if( BrdgShutdownWaitRef(&gMiniPortToggleRefcount) )
        {
            DBGPRINT(MINI, ("Doing deferred media toggle\n"));

            // Toggle our media state with NDIS
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0L );
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_CONNECT, NULL, 0L );

            // Allow people to indicate packets again
            BrdgResetWaitRef( &gMiniPortToggleRefcount );
        }
        else
        {
            DBGPRINT(MINI, ("Multiple toggles in progress simultaneously\n"));
        }

        BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
    }
    // else the miniport isn't media-connect, so the toggle makes no sense.

    BrdgMiniReleaseMiniport();
}

VOID
BrdgMiniUpdateCharacteristics(
    IN BOOLEAN              bConnectivityChange
    )
/*++

Routine Description:

    Recalculates the link speed and media status (connected / disconnected) that
    our virtual NIC exposes to overlying protocols

Arguments:

    bConnectivityChange     Whether the change that prompted this call is a change
                            in connectivity (i.e., we acquired or lost an adapter).

Return Value:

    None

--*/
{
    LOCK_STATE              LockState, ListLockState, AdaptersLockState;
    PADAPT                  pAdapt;
    ULONG                   MediaState = NdisMediaStateDisconnected;
    ULONG                   FastestSpeed = 0L;
    BOOLEAN                 UpdateSpeed = FALSE, UpdateMediaState = FALSE;
    NDIS_HANDLE             MiniportHandle;

    // Need to read the adapter list and also have the adapters' characteristics not change
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read-only*/, &ListLockState );
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, FALSE /*Read-only*/, &AdaptersLockState );

    pAdapt = gAdapterList;

    while( pAdapt != NULL )
    {
        // An adapter must be connected and actively handling packets to change our
        // virtual media state.
        if( (pAdapt->MediaState == NdisMediaStateConnected) && (pAdapt->State == Forwarding) )
        {
            // We're connected if at least one NIC is connected
            MediaState = NdisMediaStateConnected;

            // The NIC must be connected for us to consider its speed
            if( pAdapt->LinkSpeed > FastestSpeed )
            {
                FastestSpeed = pAdapt->LinkSpeed;
            }
        }

        pAdapt = pAdapt->Next;
    }

    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &AdaptersLockState );
    NdisReleaseReadWriteLock( &gAdapterListLock, &ListLockState );

    // Update the characteristics
    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Write access*/, &LockState );

    //
    // Only update our virtual link speed if we actually got at least one real speed
    // from our NICs. If everything is disconnected, the resulting FastestSpeed is
    // zero. In this case, we don't want to actually report a zero speed up to
    // overlying protocols; we stick at the last known speed until someone reconnects.
    //
    if( (gBridgeLinkSpeed != FastestSpeed) && (FastestSpeed != 0L) )
    {
        UpdateSpeed = TRUE;
        gBridgeLinkSpeed = FastestSpeed;
        DBGPRINT(MINI, ("Updated bridge speed to %iMbps\n", FastestSpeed / 10000));
    }

    if( gBridgeMediaState != MediaState )
    {
        UpdateMediaState = TRUE;
        gBridgeMediaState = MediaState;

        if( MediaState == NdisMediaStateConnected )
        {
            DBGPRINT(MINI, ("CONNECT\n"));
        }
        else
        {
            DBGPRINT(MINI, ("DISCONNECT\n"));
        }
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    MiniportHandle = BrdgMiniAcquireMiniport();

    if( MiniportHandle != NULL )
    {
        if( UpdateMediaState )
        {
            // Our link state has changed.
            if( MediaState == NdisMediaStateConnected )
            {
                //
                // Tell NDIS we will be indicating packets again.
                //
                // NOTE: BrdgMiniDeferredMediaDisconnect RELIES on us doing this after
                // having updated gBridgeMediaState inside gBridgeStateLock so it can
                // close the timing window between this call and the BrdgResetWaitRef() call.
                //
                NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_CONNECT, NULL, 0L );

                // Re-enable packet indication.
                BrdgResetWaitRef( &gMiniPortConnectedRefcount );
            }
            else
            {
                SAFEASSERT( MediaState == NdisMediaStateDisconnected );

                // Stop people from indicating packets
                BrdgBlockWaitRef( &gMiniPortConnectedRefcount );

                // We hand MiniportHandle to our deferred function
                BrdgMiniReAcquireMiniport();

                // Have to do the media-disconnect indication at PASSIVE level, since we must
                // first wait for everyone to finish indicating packets.
                if( BrdgDeferFunction( BrdgMiniDeferredMediaDisconnect, MiniportHandle ) != NDIS_STATUS_SUCCESS )
                {
                    // Failed to defer the function. Avoid leaking a refcount
                    BrdgMiniReleaseMiniport();
                }
            }
        }
        else if( bConnectivityChange )
        {
            //
            // There was no actual change to our media state. However, if the change that prompted this call
            // is a connectivity change and our media state is currently CONNECTED, we toggle it to
            // DISCONNECTED and back again to "hint" to upper-layer protocols like IP that the underlying
            // network may have changed. For example, in IP's case, a DHCP server may have become visible
            // (or a previously visible server may have disappeared) because of a connectivity change.
            // The hint causes IP to look for a DHCP server afresh.
            //
            if( MediaState == NdisMediaStateConnected )
            {
                // We hand MiniportHandle to our deferred function
                BrdgMiniReAcquireMiniport();

                // Toggle has to be done at PASSIVE level.
                if( BrdgDeferFunction( BrdgMiniDeferredMediaToggle, MiniportHandle ) != NDIS_STATUS_SUCCESS )
                {
                    // Failed to defer the function. Avoid leaking a refcount
                    BrdgMiniReleaseMiniport();
                }
            }
        }

        if( UpdateSpeed )
        {
            // Tell overlying protocols that our speed has changed
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_LINK_SPEED_CHANGE, &FastestSpeed, sizeof(ULONG) );
        }

        BrdgMiniReleaseMiniport();
    }
}

NDIS_HANDLE
BrdgMiniAcquireMiniportForIndicate()
/*++

Routine Description:

    Acquires the bridge miniport handle for the purpose of indicating packets.
    In addition to guaranteeing that the miniport will exist until the caller calls
    BrdgMiniReleaseMiniportForIndicate(), the caller is also allowed to indicate
    packets using the returned miniport handle until the miniport is released.

Arguments:

    None

Return Value:

    The NDIS handle for the virtual NIC. This can be used to indicate packets
    until a reciprocal call to BrdgMiniReleaseMiniportForIndicate().

--*/
{
    if( BrdgIncrementWaitRef(&gMiniPortAdapterRefcount) )
    {
        SAFEASSERT( gMiniPortAdapterHandle != NULL );

        // The miniport needs to be media-connect to indicate packets.
        if( BrdgIncrementWaitRef(&gMiniPortConnectedRefcount) )
        {
            // A media-state toggle had better not be in progress
            if( BrdgIncrementWaitRef(&gMiniPortToggleRefcount) )
            {
                // Caller can use the miniport
                return gMiniPortAdapterHandle;
            }
            // else miniport exists but is toggling its state

            BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
        }
        // else miniport exists but is media-disconnected

        BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
    }
    // else miniport does not exist.

    return NULL;
}

NDIS_HANDLE
BrdgMiniAcquireMiniport()
/*++

Routine Description:

    Increments the miniport's refcount so it cannot be torn down until a corresponding
    BrdgMiniReleaseMiniport() call is made.

    The caller may NOT use the returned miniport handle to indicate packets, since the
    miniport is not guaranteed to be in an appropriate state.

Arguments:

    None

Return Value:

    The NDIS handle for the virtual NIC. This can be used safely until a reciprocal call
    to BrdgMiniReleaseMiniport().

--*/
{
    if( BrdgIncrementWaitRef(&gMiniPortAdapterRefcount) )
    {
        SAFEASSERT( gMiniPortAdapterHandle != NULL );
        return gMiniPortAdapterHandle;
    }
    // else miniport does not exist.

    return NULL;
}

VOID
BrdgMiniReAcquireMiniport()
/*++

Routine Description:

    Reacquires the miniport (caller must have previously called BrdgMiniAcquireMiniport()
    and not yet called BrdgMiniReleaseMiniport().

Arguments:

    None

Return Value:

    None. The caller should already be holding a handle for the miniport.

--*/
{
    BrdgReincrementWaitRef(&gMiniPortAdapterRefcount);
}

VOID
BrdgMiniReleaseMiniport()
/*++

Routine Description:

    Decrements the miniport's refcount. The caller should no longer use the handle
    previously returned by BrdgMiniAcquireMiniport().

Arguments:

    None

Return Value:

    None

--*/
{
    BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
}

VOID
BrdgMiniReleaseMiniportForIndicate()
/*++

Routine Description:

    Decrements the miniport's refcount. The caller should no longer use the handle
    previously returned by BrdgMiniAcquireMiniportForIndicate().

Arguments:

    None

Return Value:

    None

--*/
{
    BrdgDecrementWaitRef( &gMiniPortToggleRefcount );
    BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
    BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
}


BOOLEAN
BrdgMiniReadMACAddress(
    OUT PUCHAR              pAddr
    )
/*++

Routine Description:

    Reads the bridge miniport's MAC address.

Arguments:

    Address of a buffer to receive the address

Return Value:

    TRUE if the value was copied out successfully
    FALSE if we don't yet have a MAC address (nothing was copied)

--*/
{
    BOOLEAN                 rc;

    if( gHaveAddress )
    {
        // Not necessary to acquire a lock to read the address since
        // it cannot change once it is set
        ETH_COPY_NETWORK_ADDRESS( pAddr, gBridgeAddress );
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    return rc;
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgMiniInitFromAdapter(
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called by the protocol section to give us a chance to establish the bridge's
    MAC address when a new adapter arrives. If we succeed in determining a MAC
    address from the given adapter, we in turn call the STA module to tell it
    our MAC address, which it needs as early as possible.

    The MAC address of the bridge is set as the MAC address of the given adapter
    with the "locally administered" bit set. This should (hopefully) make the
    address unique in the local network as well as unique within our machine.

    This function is called for every new adapter but we only need to initialize
    once.

Arguments:

    pAdapt                  An adapter to use to initialize

Return Value:

    Status of the operation

--*/
{
    if( ! gHaveAddress )
    {
        LOCK_STATE              LockState;

        NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

        // Possible for the gHaveAddress flag to have changed before acquiring the lock
        if( ! gHaveAddress )
        {
            // Copy out the NIC's MAC address
            ETH_COPY_NETWORK_ADDRESS( gBridgeAddress, pAdapt->MACAddr );

            //
            // Set the second-least significant bit of the NIC's MAC address. This moves the address
            // into the locally administered space.
            //
            gBridgeAddress[0] |= (UCHAR)0x02;

            DBGPRINT(MINI, ("Using MAC Address %02x-%02x-%02x-%02x-%02x-%02x\n",
                      (UINT)gBridgeAddress[0], (UINT)gBridgeAddress[1], (UINT)gBridgeAddress[2],
                      (UINT)gBridgeAddress[3], (UINT)gBridgeAddress[4], (UINT)gBridgeAddress[5]));

            gHaveAddress = TRUE;

            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            if( !gDisableSTA )
            {
                // We are responsible for calling the STA module to complete its initialization once
                // we know our MAC address.
                BrdgSTADeferredInit( gBridgeAddress );
            }

            // We are also responsible for letting the compatibility-mode code know about our
            // MAC address once it is set.
            BrdgCompNotifyMACAddress( gBridgeAddress );
        }
        else
        {
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
        }
    }
}

BOOLEAN
BrdgMiniAddrIsInMultiList(
    IN PUCHAR               pTargetAddr
    )
/*++

Routine Description:

    Determines whether a given multicast address is in the list of addresses that
    we must indicate to overlying protocols

    The caller is responsible for synchronization; it must have AT LEAST a read lock on
    gBridgeStateLock.

Arguments:

    pTargetAddr             The address to analyze

Return Value:

    TRUE            :       This address is a multicast address that we have been asked
                            to indicate

    FALSE           :       The above is not true

--*/
{
    PUCHAR                  pCurAddr = gMulticastList;
    ULONG                   i;
    BOOLEAN                 rc = FALSE;

    // The list must have an integral number of addresses!
    SAFEASSERT( (gMulticastListLength % ETH_LENGTH_OF_ADDRESS) == 0 );

    for( i = 0;
         i < (gMulticastListLength / ETH_LENGTH_OF_ADDRESS);
         i++, pCurAddr += ETH_LENGTH_OF_ADDRESS
       )
    {
        UINT   Result;
        ETH_COMPARE_NETWORK_ADDRESSES_EQ( pTargetAddr, pCurAddr, &Result );

        if( Result == 0 )
        {
            rc = TRUE;
            break;
        }
    }

    return rc;
}

VOID
BrdgMiniHalt(
    IN NDIS_HANDLE      MiniportAdapterContext
    )
/*++

Routine Description:

    Called when the virtual NIC is de-instantiated. We NULL out the miniport handle and
    stall the tear-down until everyone is done using the miniport.

    Must be called at PASSIVE_LEVEL since we wait on an event

Arguments:

    MiniportAdapterContext  Ignored

Return Value:

    None

--*/
{
    NDIS_HANDLE     Scratch = gDeviceHandle;
    LOCK_STATE      LockState;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(MINI, ("BrdgMiniHalt\n"));

    if( Scratch != NULL )
    {
        // Tear down the device object
        gDeviceHandle = gDeviceObject = NULL;
        NdisMDeregisterDevice( Scratch );
    }

    if( gMiniPortAdapterHandle != NULL )
    {
        // Stall before returning until everyone is done using the miniport handle.
        // This also prevents people from acquiring the miniport handle.
        BrdgShutdownWaitRefOnce( &gMiniPortAdapterRefcount );
        gMiniPortAdapterHandle = NULL;
        DBGPRINT(MINI, ("Done stall\n"));
    }

    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

    if( gBridgeDeviceName != NULL )
    {
        NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
        gBridgeDeviceName = NULL;
        gBridgeDeviceNameSize = 0L;
    }

    // Ditch our packet filter and multicast list
    gPacketFilter = 0L;

    if( gMulticastList != NULL )
    {
        SAFEASSERT( gMulticastListLength > 0L );
        NdisFreeMemory( gMulticastList, gMulticastListLength, 0 );
        gMulticastList = NULL;
        gMulticastListLength = 0L;
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
}

NDIS_STATUS
BrdgMiniInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN PNDIS_MEDIUM     MediumArray,
    IN UINT             MediumArraySize,
    IN NDIS_HANDLE      MiniPortAdapterHandle,
    IN NDIS_HANDLE      WrapperConfigurationContext
    )
/*++

Routine Description:

    NDIS entry point called to initialize our virtual NIC following a call to
    NdisIMInitializeDeviceInstance

    Must run at PASSIVE_LEVEL since we call NdisMSetAttributesEx

Arguments:

    OpenErrorStatus                 Where to return the specific error code if an open fails
    SelectedMediumIndex             Where to specify which media we selected from MediumArray
    MediumArray                     A list of media types to choose from
    MediumArraySize                 Number of entries in MediumArray
    MiniPortAdapterHandle           The handle for our virtual NIC (we save this)
    WrapperConfigurationContext     Not used

Return Value:

    Status of the initialization. A result != NDIS_STATUS_SUCCESS fails the NIC initialization
    and the miniport is not exposed to upper-layer protocols

--*/
{
    UINT                i;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    DBGPRINT(MINI, ("BrdgMiniInitialize\n"));

    for( i = 0; i < MediumArraySize; i++ )
    {
        if( MediumArray[i] == NdisMedium802_3 ) // Ethernet
        {
            *SelectedMediumIndex = NdisMedium802_3;
            break;
        }
    }

    if( i == MediumArraySize )
    {
        // Log this error since it's fatal
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_ETHERNET_NOT_OFFERED, 0L, 0L, NULL, 0L, NULL );
        DBGPRINT(MINI, ("Ethernet not offered; failing\n"));
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    NdisMSetAttributesEx(   MiniPortAdapterHandle,
                            NULL,
                            0,                                      // CheckForHangTimeInSeconds
                            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    |
                            NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                            NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                            NDIS_ATTRIBUTE_DESERIALIZE |
                            NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                            0);

    // Save the adapter handle for future use
    gMiniPortAdapterHandle = MiniPortAdapterHandle;

    // Allow people to acquire the miniport
    BrdgResetWaitRef( &gMiniPortAdapterRefcount );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
BrdgMiniReset(
    OUT PBOOLEAN        AddressingReset,
    IN NDIS_HANDLE      MiniportAdapterContext
    )
/*++

Routine Description:

    NDIS entry point called reset our miniport. We do nothing in response to this.

Arguments:

    AddressingReset             Whether NDIS needs to prod us some more by calling MiniportSetInformation
                                after we return to restore various pieces of state

    MiniportAdapterContext      Ignored

Return Value:

    Status of the reset

--*/
{
    DBGPRINT(MINI, ("BrdgMiniReset\n"));
    return NDIS_STATUS_SUCCESS;
}

VOID
BrdgMiniSendPackets(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PPNDIS_PACKET    PacketArray,
    IN UINT             NumberOfPackets
    )
/*++

Routine Description:

    NDIS entry point called to send packets through our virtual NIC.

    We just call the forwarding logic code to handle each packet.

Arguments:

    MiniportAdapterContext      Ignored
    PacketArray                 Array of packet pointers to send
    NumberOfPacket              Like it says

Return Value:

    None

--*/
{
    UINT                i;
    NDIS_STATUS         Status;

    for (i = 0; i < NumberOfPackets; i++)
    {
        PNDIS_PACKET    pPacket = PacketArray[i];

        // Hand this packet to the forwarding engine for processing
        Status = BrdgFwdSendPacket( pPacket );

        if( Status != NDIS_STATUS_PENDING )
        {
            // The forwarding engine completed immediately

            // NDIS should prevent the miniport from being shut down
            // until we return from this function
            SAFEASSERT( gMiniPortAdapterHandle != NULL );
            NdisMSendComplete(gMiniPortAdapterHandle, pPacket, Status);
        }
        // else the forwarding engine will call NdisMSendComplete()
    }
}

NDIS_STATUS
BrdgMiniQueryInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesWritten,
    OUT PULONG          BytesNeeded
    )
/*++

Routine Description:

    NDIS entry point called to retrieve various pieces of info from our miniport

Arguments:

    MiniportAdapterContext      Ignored
    Oid                         The request code
    InformationBuffer           Place to return information
    InformationBufferLength     Size of InformationBuffer
    BytesWritten                Output of the number of written bytes
    BytesNeeded                 If the provided buffer is too small, this is how many we need.

Return Value:

    Status of the request

--*/
{
    // Macros for use in this function alone
    #define REQUIRE_AT_LEAST(n) \
        { \
            if(InformationBufferLength < (n)) \
            { \
                *BytesNeeded = (n); \
                return NDIS_STATUS_INVALID_LENGTH; \
            }\
        }

    #define RETURN_BYTES(p,n) \
        { \
            NdisMoveMemory( InformationBuffer, (p), (n) ); \
            *BytesWritten = (n); \
            return NDIS_STATUS_SUCCESS; \
        }

    switch( Oid )
    {
    // General characteristics
    case OID_GEN_SUPPORTED_LIST:
        {
            REQUIRE_AT_LEAST( sizeof(gSupportedOIDs) );
            RETURN_BYTES( gSupportedOIDs, sizeof(gSupportedOIDs));
        }
        break;

    case OID_GEN_HARDWARE_STATUS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            *((ULONG*)InformationBuffer) = NdisHardwareStatusReady;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // We support Ethernet only
            *((ULONG*)InformationBuffer) = NdisMedium802_3;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_TRANSMIT_BUFFER_SPACE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Lie and claim to have 15K of send space, a common
            // Ethernet card value.
            // REVIEW: Is there a better value?
            *((ULONG*)InformationBuffer) = 15 * 1024;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_RECEIVE_BUFFER_SPACE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Lie and claim to have 150K of receive space, a common
            // Ethernet card value.
            // REVIEW: Is there a better value?
            *((ULONG*)InformationBuffer) = 150 * 1024;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAXIMUM_SEND_PACKETS:
    case OID_802_3_MAXIMUM_LIST_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Return a generic large integer
            // REVIEW: Is there a better value to hand out?
            *((ULONG*)InformationBuffer) = 0x000000FF;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAXIMUM_FRAME_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Ethernet payloads can be up to 1500 bytes
            *((ULONG*)InformationBuffer) = 1500L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // We indicate full packets up to NDIS, so these values are the same and
    // equal to the maximum size of a packet
    case OID_GEN_MAXIMUM_LOOKAHEAD:
    case OID_GEN_CURRENT_LOOKAHEAD:

    // These are also just the maximum total size of a frame
    case OID_GEN_MAXIMUM_TOTAL_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
    case OID_GEN_TRANSMIT_BLOCK_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // Ethernet frames with header can be up to 1514 bytes
            *((ULONG*)InformationBuffer) = 1514L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAC_OPTIONS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We have no internal loopback support
            *((ULONG*)InformationBuffer) = NDIS_MAC_OPTION_NO_LOOPBACK;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_LINK_SPEED:
        {
            LOCK_STATE          LockState;
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gBridgeLinkSpeed;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Ethernet characteristics
    case OID_802_3_PERMANENT_ADDRESS:
    case OID_802_3_CURRENT_ADDRESS:
        {
            SAFEASSERT( gHaveAddress );

            // Don't need a read lock because the address shouldn't change once set
            REQUIRE_AT_LEAST( sizeof(gBridgeAddress) );
            RETURN_BYTES( gBridgeAddress, sizeof(gBridgeAddress));
        }
        break;

    case OID_GEN_MEDIA_CONNECT_STATUS:
        {
            LOCK_STATE          LockState;
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gBridgeMediaState;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;


    case OID_GEN_VENDOR_ID:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We don't have an IEEE-assigned ID so use this constant
            *((ULONG*)InformationBuffer) = 0xFFFFFF;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        {
            UINT    len = (UINT)strlen( gDriverDescription ) + 1;
            REQUIRE_AT_LEAST( len );
            RETURN_BYTES( gDriverDescription, len);
        }
        break;

    case OID_GEN_VENDOR_DRIVER_VERSION:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We are version 1.0
            *((ULONG*)InformationBuffer) = 0x00010000;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DRIVER_VERSION:
        {
            REQUIRE_AT_LEAST( sizeof(USHORT) );

            // We are using version 5.0 of NDIS
            *((USHORT*)InformationBuffer) = 0x0500;
            *BytesWritten = sizeof(USHORT);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    //
    // General Statistics
    //
    case OID_GEN_XMIT_OK:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of local-sourced sent frames
            *((ULONG*)InformationBuffer) = gStatTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_XMIT_ERROR:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of local-sourced frames sent with errors
            *((ULONG*)InformationBuffer) = gStatTransmittedErrorFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_RCV_OK:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of indicated frames
            *((ULONG*)InformationBuffer) = gStatIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Answer the same for these two
    case OID_GEN_RCV_NO_BUFFER:
    case OID_GEN_RCV_ERROR:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatIndicatedDroppedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            *((ULONG*)InformationBuffer) = gStatDirectedTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Ethernet statistics
    case OID_802_3_RCV_ERROR_ALIGNMENT:
    case OID_802_3_XMIT_ONE_COLLISION:
    case OID_802_3_XMIT_MORE_COLLISIONS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // We have no way of collecting this information sensibly from lower NICs, so
            // pretend these types of events never happen.
            *((ULONG*)InformationBuffer) = 0L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_CURRENT_PACKET_FILTER:
        {
            LOCK_STATE          LockState;

            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gPacketFilter;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_802_3_MULTICAST_LIST:
        {
            LOCK_STATE          LockState;

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );

            if(InformationBufferLength < gMulticastListLength)
            {
                *BytesNeeded = gMulticastListLength;
                NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
                return NDIS_STATUS_INVALID_LENGTH;
            }

            NdisMoveMemory( InformationBuffer, gMulticastList, gMulticastListLength );
            *BytesWritten = gMulticastListLength;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_PNP_QUERY_POWER:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_TCP_TASK_OFFLOAD:
        {
            // Mark that Tcp.ip has been loaded
            g_fIsTcpIpLoaded = TRUE;
            // Set the underlying 1394 miniport to ON
            BrdgSetMiniportsToBridgeMode(NULL,TRUE);
            return NDIS_STATUS_NOT_SUPPORTED;
        }
        break;
    }


    // We don't understand the OID
    return NDIS_STATUS_NOT_SUPPORTED;

#undef REQUIRE_AT_LEAST
#undef RETURN_BYTES
}

NDIS_STATUS
BrdgMiniSetInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesRead,
    OUT PULONG          BytesNeeded
    )
/*++

Routine Description:

    NDIS entry point called to set various pieces of info to our miniport

Arguments:

    MiniportAdapterContext      Ignored
    Oid                         The request code
    InformationBuffer           Input information buffer
    InformationBufferLength     Size of InformationBuffer
    BytesRead                   Number of bytes read from InformationBuffer
    BytesNeeded                 If the provided buffer is too small, this is how many we need.

Return Value:

    Status of the request

--*/
{
    LOCK_STATE              LockState;
    NDIS_STATUS             Status;

    switch( Oid )
    {
    case OID_GEN_CURRENT_PACKET_FILTER:
        {
            SAFEASSERT( InformationBufferLength == sizeof(ULONG) );

            // Get write access to the packet filter
            NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Read-Write*/, &LockState );
            gPacketFilter = *((ULONG*)InformationBuffer);
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            DBGPRINT(MINI, ("Set the packet filter to %08x\n", gPacketFilter));
            *BytesRead = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_802_3_MULTICAST_LIST:
        {
            PUCHAR              pOldList, pNewList;
            ULONG               oldListLength;

            // The incoming buffer should contain an integral number of Ethernet MAC
            // addresses
            SAFEASSERT( (InformationBufferLength % ETH_LENGTH_OF_ADDRESS) == 0 );

            DBGPRINT(MINI, ("Modifying the multicast list; now has %i entries\n",
                      InformationBufferLength / ETH_LENGTH_OF_ADDRESS));

            // Alloc and copy to the new multicast list
            if( InformationBufferLength > 0 )
            {
                Status = NdisAllocateMemoryWithTag( &pNewList, InformationBufferLength, 'gdrB' );

                if( Status != NDIS_STATUS_SUCCESS )
                {
                    DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while recording multicast list\n"));
                    return NDIS_STATUS_NOT_ACCEPTED;
                }

                // Copy the list
                NdisMoveMemory( pNewList, InformationBuffer, InformationBufferLength );
            }
            else
            {
                pNewList = NULL;
            }

            // Swap in the new list
            NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Read-Write*/, &LockState );

            pOldList = gMulticastList;
            oldListLength = gMulticastListLength;

            gMulticastList = pNewList;
            gMulticastListLength = InformationBufferLength;

            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            // Free the old multicast list if there was one
            if( pOldList != NULL )
            {
                NdisFreeMemory( pOldList, oldListLength, 0 );
            }

            *BytesRead = InformationBufferLength;
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:
    case OID_GEN_PROTOCOL_OPTIONS:
        {
            // We accept these but do nothing
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Overlying protocols telling us about their network addresses
    case OID_GEN_NETWORK_LAYER_ADDRESSES:
        {
            // Let the compatibility-mode code note the addresses
            BrdgCompNotifyNetworkAddresses( InformationBuffer, InformationBufferLength );
        }
        //
        // DELIBERATELY FALL THROUGH
        //

    // All relayed OIDs go here
    case OID_GEN_TRANSPORT_HEADER_OFFSET:
        {
            LOCK_STATE              LockState;
            PADAPT                  Adapters[MAX_ADAPTERS], pAdapt;
            LONG                    NumAdapters = 0L, i;
            PNDIS_REQUEST_BETTER    pRequest;
            NDIS_STATUS             Status, rc;

            // We read the entire request
            *BytesRead = InformationBufferLength;

            // Pass these straight through to underlying NICs
            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

            // Make a list of the adapters to send the request to
            pAdapt = gAdapterList;

            while( pAdapt != NULL )
            {
                if( NumAdapters < MAX_ADAPTERS )
                {
                    Adapters[NumAdapters] = pAdapt;

                    // We will be using this adapter outside the list lock
                    BrdgAcquireAdapterInLock( pAdapt );
                    NumAdapters++;
                }
                else
                {
                    SAFEASSERT( FALSE );
                    DBGPRINT(MINI, ("Too many adapters to relay a SetInfo request to!\n"));
                }

                pAdapt = pAdapt->Next;
            }

            // The refcount is the number of requests we will make
            gRequestRefCount = NumAdapters;

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

            if( NumAdapters == 0 )
            {
                // Nothing to do!
                rc = NDIS_STATUS_SUCCESS;
            }
            else
            {
                // Request will pend unless all adapters return immediately
                rc = NDIS_STATUS_PENDING;

                for( i = 0L; i < NumAdapters; i++ )
                {
                    // Allocate memory for the request
                    Status = NdisAllocateMemoryWithTag( &pRequest, sizeof(NDIS_REQUEST_BETTER), 'gdrB' );

                    if( Status != NDIS_STATUS_SUCCESS )
                    {
                        LONG            NewCount = InterlockedDecrement( &gRequestRefCount );

                        DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while relaying an OID\n"));

                        if( NewCount == 0 )
                        {
                            // This could only have happened with the last adapter
                            SAFEASSERT( i == NumAdapters - 1 );

                            // We're all done since everyone else has completed too
                            rc = NDIS_STATUS_SUCCESS;
                        }

                        // Let go of the adapter
                        BrdgReleaseAdapter( Adapters[i] );
                        continue;
                    }

                    // Set up the request as a mirror of ours
                    pRequest->Request.RequestType = NdisRequestSetInformation;
                    pRequest->Request.DATA.SET_INFORMATION.Oid = Oid ;
                    pRequest->Request.DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;
                    pRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;
                    NdisInitializeEvent( &pRequest->Event );
                    NdisResetEvent( &pRequest->Event );
                    pRequest->pFunc = BrdgMiniRelayedRequestComplete;
                    pRequest->FuncArg = NULL;

                    // Fire it off
                    NdisRequest( &Status, Adapters[i]->BindingHandle, &pRequest->Request );

                    // Let go of the adapter; NDIS should not permit it to be unbound while
                    // a request is in progress
                    BrdgReleaseAdapter( Adapters[i] );

                    if( Status != NDIS_STATUS_PENDING )
                    {
                        // The cleanup function won't get called
                        BrdgMiniRelayedRequestComplete( pRequest, NULL );
                    }
                }
            }

            //
            // Paranoia for future maintainance: can't refer to pointer parameters
            // at this point, as the relayed requests may have completed already, making
            // them stale.
            //
            InformationBuffer = NULL;
            BytesRead = NULL;
            BytesNeeded = NULL;

            return rc;
        }
        break;

    case OID_PNP_SET_POWER:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;
    }

    return NDIS_STATUS_NOT_SUPPORTED;
}

VOID
BrdgMiniRelayedRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       unused
    )
/*++

Routine Description:

    Called when a SetInformation request that we relayed completes.

Arguments:

    pRequest                    The NDIS_REQUEST_BETTER structure we allocated
                                in BrdgMiniSetInformation().

    unused                      Unused

Return Value:

    Status of the request

--*/
{
    LONG        NewCount = InterlockedDecrement( &gRequestRefCount );

    if( NewCount == 0 )
    {
        // NDIS Should not permit the miniport to shut down with a request
        // in progress
        SAFEASSERT( gMiniPortAdapterHandle != NULL );

        // The operation always succeeds
        NdisMSetInformationComplete( gMiniPortAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    // Free the request structure since we allocated it ourselves
    NdisFreeMemory( pRequest, sizeof(PNDIS_REQUEST_BETTER), 0 );
}




VOID
BrdgMiniLocalRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       pContext
    )
/*++

Routine Description:

    Called when bridge allocated request completes.

Arguments:

    pRequest    The NDIS_REQUEST_BETTER structure we allocated
                in BrdgSetMiniportsToBridgeMode.
    Context     pAdapt structure

Return Value:

    Status of the request

--*/
{
    PADAPT pAdapt = (PADAPT)pContext;

    // Let go of the adapter;
    BrdgReleaseAdapter( pAdapt);

    // Free the request structure since we allocated it ourselves
    NdisFreeMemory( pRequest, sizeof(PNDIS_REQUEST_BETTER), 0 );
}

VOID
BrdgSetMiniportsToBridgeMode(
    PADAPT pAdapt,
    BOOLEAN fSet
    )
/*++

Routine Description:

    Sends a 1394 specific OID to the miniport informing it that TCP/IP
    has been activated

Arguments:

    pAdapt -    If adapt is not NULL, send Request to this adapt.
                Otherwise send it to all of them.
    fSet -      if True, then set Bridge Mode ON, otherwise set it OFF

Return Value:

    Status of the request

--*/
{

    LOCK_STATE              LockState;
    PADAPT                  Adapters[MAX_ADAPTERS];
    LONG                    NumAdapters = 0L, i;
    NDIS_OID                Oid;

    if (pAdapt != NULL)
    {
        if (pAdapt->PhysicalMedium == NdisPhysicalMedium1394)
        {
            // We have a 1394 adapt, ref it and send the request to it
            if (BrdgAcquireAdapter (pAdapt))
            {
                Adapters[0] = pAdapt;
                NumAdapters = 1;
            }
        }
    }
    else
    {
        // walk through the list and Acquire all the 1394 adapts
        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

        // Make a list of the adapters to send the request to
        pAdapt = gAdapterList;

        while( pAdapt != NULL )
        {
            if( NumAdapters < MAX_ADAPTERS && pAdapt->PhysicalMedium == NdisPhysicalMedium1394)
            {
                Adapters[NumAdapters] = pAdapt;

                // We will be using this adapter outside the list lock
                BrdgAcquireAdapterInLock( pAdapt ); // cannot fail
                NumAdapters++;
            }
            pAdapt = pAdapt->Next;
        }

        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    }

    if (NumAdapters == 0)
    {
        return;
    }

    if (fSet == TRUE)
    {
        Oid = OID_1394_ENTER_BRIDGE_MODE ;
        DBGPRINT(MINI, ("Setting 1394 miniport bridge mode - ON !\n"));
    }
    else
    {
        Oid = OID_1394_EXIT_BRIDGE_MODE ;
        DBGPRINT(MINI, ("Setting 1394 miniport bridge mode - OFF !\n"));
    }

    for( i = 0L; i < NumAdapters; i++ )
    {
        NDIS_STATUS Status;
        PNDIS_REQUEST_BETTER pRequest;

        Status = NdisAllocateMemoryWithTag( &pRequest, sizeof(NDIS_REQUEST_BETTER), 'gdrB' );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while allocating a request structure \n"));

            // Let go of the adapter
            BrdgReleaseAdapter( Adapters[i] );
            continue;
        }

        // Set up the request
        pRequest->Request.RequestType = NdisRequestSetInformation;
        pRequest->Request.DATA.SET_INFORMATION.Oid = Oid;
        pRequest->Request.DATA.SET_INFORMATION.InformationBuffer = NULL;
        pRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = 0 ;
        NdisInitializeEvent( &pRequest->Event );
        NdisResetEvent( &pRequest->Event );
        pRequest->pFunc = BrdgMiniLocalRequestComplete;
        pRequest->FuncArg = Adapters[i];

        // Fire it off
        NdisRequest( &Status, Adapters[i]->BindingHandle, &pRequest->Request );

        if( Status != NDIS_STATUS_PENDING )
        {
            // The cleanup function won't get called
            BrdgMiniLocalRequestComplete( pRequest, Adapters[i] );
        }

    } // end of for loop

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgmini.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgmini.h

Abstract:

    Ethernet MAC level bridge.
    Miniport section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================


NTSTATUS
BrdgMiniDriverInit();

VOID
BrdgMiniInstantiateMiniport();

BOOLEAN
BrdgMiniShouldIndicatePacket(
    IN PUCHAR               pTargetAddr
    );

BOOLEAN
BrdgMiniIsUnicastToBridge (
    IN PUCHAR               Address
    );

VOID
BrdgMiniUpdateCharacteristics(
    IN BOOLEAN              bConnectivityChange
    );

NDIS_HANDLE
BrdgMiniAcquireMiniport();

NDIS_HANDLE
BrdgMiniAcquireMiniportForIndicate();

VOID
BrdgMiniReleaseMiniport();

VOID
BrdgMiniReleaseMiniportForIndicate();

BOOLEAN
BrdgMiniReadMACAddress(
    OUT PUCHAR              pAddr
    );

VOID
BrdgMiniInitFromAdapter(
    IN PADAPT               pAdapt
    );

BOOLEAN
BrdgMiniIsBridgeDeviceName(
    IN PNDIS_STRING         pDeviceName
    );

VOID
BrdgMiniAssociate();

VOID
BrdgMiniCleanup();

VOID
BrdgSetMiniportsToBridgeMode(
    PADAPT pAdapt,
    BOOLEAN fSet
    );

// ===========================================================================
//
// PUBLIC GLOBALS
//
// ===========================================================================

// The device name of our miniport (NULL if not initialized)
extern PWCHAR               gBridgeDeviceName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgpkt.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgpkt.h

Abstract:

    Ethernet MAC level bridge.
    Packet structure definitions

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef enum
{
    BrdgPacketImpossible = 0,       // We zero PACKET_INFO structures on free so make zero invalid
    BrdgPacketInbound,
    BrdgPacketOutbound,
    BrdgPacketCreatedInBridge
} PACKET_DIRECTION;

// Special pointer value to indicate local miniport
#define LOCAL_MINIPORT ((PADAPT)-1)

//
// This is the structure of the ProtocolReserved area of a packet queued for inbound processing
//
// This structure MUST be less than PROTOCOL_RESERVED_SIZE_IN_PACKET in size (currently 4*sizeof(PVOID))
// since we store this structure in the ProtocolReserved section of NDIS_PACKET.
//
typedef struct _PACKET_Q_INFO
{

    BSINGLE_LIST_ENTRY      List;               // Used to queue up the packets

    union
    {
        // If bFastTrackReceive == FALSE
        PADAPT                  pTargetAdapt;   // The target adapter if one was found in the
                                                // forwarding table. Its refcount is bumped when it
                                                // is looked up, and is decremented after processing
                                                // completes in the queue-draining thread

        // If bFastTrackReceive == TRUE
        PADAPT                  pOriginalAdapt; // The adapter on which this packet was originally
                                                // received.
    } u;

    struct _PACKET_INFO     *pInfo;             // NULL if this is a NIC's packet descriptor on loan
                                                // != NULL if we got the packet on the copy path and
                                                // had to wrap it with our own descriptor

    struct
    {
        BOOLEAN bIsUnicastToBridge : 1;         // This packet is unicast to the bridge and should be
                                                // indicated straight up when dequeued. The packet can
                                                // be a retained NIC packet or a wrapped packet.

        BOOLEAN bFastTrackReceive : 1;          // Only used when bIsUnicastToBridge == TRUE. Signals that
                                                // this packet should be fast-track indicated. When FALSE,
                                                // the packet is a base packet and can be indicated normally.

        BOOLEAN bShouldIndicate : 1;            // Whether this packet should be indicated up to the local
                                                // machine (used when bIsUnicastToBridge == FALSE)

        BOOLEAN bIsSTAPacket : 1;               // This packet was sent to the Spanning Tree Algorithm
                                                // reserved multicast address. It should be indicated
                                                // to user mode and NOT forwarded.

        BOOLEAN bRequiresCompatWork : 1;        // This packet will require compatibility-mode processing
                                                // when it gets dequeued. This IMPLIES bFastTrackReceive == FALSE,
                                                // since the fact that a packet requires compatibility-mode
                                                // processing should have forced us to copy the packet data
                                                // to our own data buffer. The compatibility-mode code
                                                // expects to receive a flat, EDITABLE packet.

    } Flags;

} PACKET_Q_INFO, *PPACKET_Q_INFO;

//
// This is the structure of the info block associated with every
// packet that we allocate.
//
typedef struct _PACKET_INFO
{
    //
    // List and pOwnerPacket are maintained by the buffering code. They should not be modified
    // during processing and transmission.
    //
    BSINGLE_LIST_ENTRY      List;               // Used to keep queues of packets

    PNDIS_PACKET            pOwnerPacket;       // Backpointer to the packet associated with this block

    //
    // All following fields are used by the forwarding code for packet processing.
    //
    struct
    {
        UINT                bIsBasePacket : 1;  // Whether this packet is a base packet
                                                // (Controls which variant of the union below to use)

        UINT                OriginalDirection:2;// Actually of type PACKET_DIRECTION but force to unsigned
                                                // otherwise Bad Things occur
                                                //
                                                // Whether this packet was originally received from a
                                                // lower-layer NIC, from a higher-layer protocol, or
                                                // created as a wrapper inside the bridge
    } Flags;

    union
    {
        //
        // This part of the union is valid if the bIsBasePacket field is NOT set
        //
        struct _PACKET_INFO     *pBasePacketInfo;   // If != NULL, this packet is using buffers refcounted by
                                                    // another packet, whose info block is indicated.

        struct
        {
            //
            // This part of the union is valid if the bIsBasePacket field IS set
            //

            PNDIS_PACKET            pOriginalPacket;    // If != NULL, pOriginalPacket == a packet from a miniport
                                                        // or protocol that needs to be returned when we're done

            PADAPT                  pOwnerAdapter;      // The adapter that owns pOriginalPacket. If != NULL, we
                                                        // got this packet from an underlying NIC and bumped up
                                                        // its refcount when we first received the packet. This
                                                        // ensures that a NIC is not unbound while we are still
                                                        // holding some of its packets. pOwnerAdapter's refcount
                                                        // is decremented after returning the original packet.

            LONG                    RefCount;           // Refcount for this packet's buffers (decremented by all
                                                        // dependent packets)

            NDIS_STATUS             CompositeStatus;    // Overall status of the packet. For packets sent to multiple
                                                        // adapters, this is initialized to NDIS_STATUS_FAILURE
                                                        // and any successful send sets it to NDIS_STATUS_SUCCESS.
                                                        // Thus, it is SUCCESS if at least one send succeeded.
        } BasePacketInfo;
    } u;

} PACKET_INFO, *PPACKET_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdghash.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdghash.h

Abstract:

    Ethernet MAC level bridge.
    Hash table implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    October  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

#define MAX_SUPPORTED_KEYSIZE           8               // Key can be up to 8 bytes

//
// Structure of a table entry
//
typedef struct _HASH_TABLE_ENTRY
{

    struct _HASH_TABLE_ENTRY           *Next;
    ULONG                               LastSeen;       // Result of NdisGetSystemUpTime()
    UCHAR                               key[MAX_SUPPORTED_KEYSIZE];

    // User's data follows

} HASH_TABLE_ENTRY, *PHASH_TABLE_ENTRY;


// The prototype of a hash function
typedef ULONG (*PHASH_FUNCTION)(PUCHAR pKey);

// The prototype of a matching function
typedef BOOLEAN (*PHASH_MATCH_FUNCTION)(PHASH_TABLE_ENTRY, PVOID);

// The prototype of a data-copy function
typedef VOID (*PHASH_COPY_FUNCTION)(PHASH_TABLE_ENTRY, PUCHAR);

// The prototype of a function used in calls to BrdgHashPrefixMultiMatch
typedef VOID (*PMULTIMATCH_FUNC)(PHASH_TABLE_ENTRY, PVOID);

//
// Structure of the table itself
//
typedef struct _HASH_TABLE
{
    NPAGED_LOOKASIDE_LIST       entryPool;

    //
    // The consistency of the buckets is protected by the tableLock.
    //
    // The LastSeen field in each entry is volatile and is updated
    // with interlocked instructions.
    //
    NDIS_RW_LOCK                tableLock;

    // These fields never change after creation
    PHASH_FUNCTION              pHashFunction;
    PHASH_TABLE_ENTRY          *pBuckets;
    ULONG                       numBuckets, entrySize;
    UINT                        keySize;
    BRIDGE_TIMER                timer;
    ULONG_PTR                   maxEntries;
    ULONG                       maxTimeoutAge;      // Maximum possible timeoutAge

    // These fields change but are protected by the tableLock.
    ULONG_PTR                   numEntries;
    ULONG                       nextTimerBucket;

    // This field is manipulated with InterlockExchange() instructions
    // to avoid having to take the table lock to change it.
    ULONG                       timeoutAge;

    // In debug builds, this tracks how many entries are in each bucket
    // so we can tell whether the table is well balanced
#if DBG
    PUINT                       bucketSizes;
#endif
} HASH_TABLE, *PHASH_TABLE;



// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

PHASH_TABLE
BrdgHashCreateTable(
    IN PHASH_FUNCTION           pHashFunction,
    IN ULONG                    numBuckets,
    IN ULONG                    entrySize,
    IN ULONG                    maxEntries,
    IN ULONG                    startTimeoutAge,
    IN ULONG                    maxTimeoutAge,
    IN UINT                     keySize
    );

VOID
BrdgHashFreeHashTable(
    IN PHASH_TABLE      pTable
    );

PHASH_TABLE_ENTRY
BrdgHashFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    IN LOCK_STATE              *pLockState
    );

PHASH_TABLE_ENTRY
BrdgHashRefreshOrInsert(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    OUT BOOLEAN                *pIsNewEntry,
    OUT PLOCK_STATE             pLockState
    );

VOID
BrdgHashRemoveMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    PVOID                       pData
    );

ULONG
BrdgHashCopyMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    IN PHASH_COPY_FUNCTION      pCopyFunction,
    IN ULONG                    copyUnitSize,
    IN PVOID                    pData,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    );

VOID
BrdgHashPrefixMultiMatch(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pPrefixKey,
    IN UINT                     prefixLen,
    IN PMULTIMATCH_FUNC         pFunc,
    IN PVOID                    pData
    );

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Changes the timeout value for a hash table
//
__forceinline
VOID
BrdgHashChangeTableTimeout(
    IN PHASH_TABLE              pTable,
    IN ULONG                    timeout
    )
{
    InterlockedExchange( (PLONG)&pTable->timeoutAge, (LONG)timeout );
}

//
// Refreshes a table entry held by the caller.
// ASSUMES the caller holds a read or write lock on the table
// enclosing this entry!
//
__forceinline
VOID
BrdgHashRefreshEntry(
    IN PHASH_TABLE_ENTRY        pEntry
    )
{
    ULONG                       CurrentTime;

    NdisGetSystemUpTime( &CurrentTime );
    InterlockedExchange( (PLONG)&pEntry->LastSeen, (LONG)CurrentTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgprot.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgprot.c

Abstract:

    Ethernet MAC level bridge.
    Protocol section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/
#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgbuf.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// NDIS handle for our identity as a protocol
NDIS_HANDLE             gProtHandle = NULL;

NDIS_MEDIUM             gMediumArray[1] =
                            {
                                NdisMedium802_3     // Ethernet only, can add other media later
                            };

// The adapter list and associated lock
PADAPT                  gAdapterList = {0};
NDIS_RW_LOCK            gAdapterListLock;

// Whether we have called the miniport sections BindsComplete() function yet
// 0 == no, 1 == yes
LONG                    gHaveInitedMiniport = 0L;

// A lock for all the adapters' link speed and media connect characteristics
NDIS_RW_LOCK            gAdapterCharacteristicsLock;

// Number of adapters. Doesn't change if a lock is held on gAdapterListLock
ULONG                   gNumAdapters = 0L;

// Name of the registry value that forces an adapter into compatibility mode
NDIS_STRING             gForceCompatValueName = NDIS_STRING_CONST("ForceCompatibilityMode");

#if DBG
// Boolean to force all adapters into compatibility mode
BOOLEAN                 gAllAdaptersCompat = FALSE;
const PWCHAR            gForceAllCompatPropertyName = L"ForceAllToCompatibilityMode";
#endif

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgProtOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    );

VOID
BrdgProtCloseAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

VOID
BrdgProtStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

VOID
BrdgProtStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
BrdgProtReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
BrdgProtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );

VOID
BrdgProtUnbindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    );

NDIS_STATUS
BrdgProtPnPEvent(
    IN NDIS_HANDLE              ProtocolBindingContext,
    IN PNET_PNP_EVENT           NetPnPEvent
    );

VOID
BrdgProtUnload(VOID);


UINT
BrdgProtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Signals the queue-draining threads that there has been a change in the
// adapter list
//
__forceinline
VOID
BrdgProtSignalAdapterListChange()
{
    INT         i;

    for( i = 0; i < KeNumberProcessors; i++ )
    {
        KeSetEvent( &gThreadsCheckAdapters[i], EVENT_INCREMENT, FALSE );
    }
}

//
// Writes an entry to the event log that indicates an error on a specific
// adapter.
//
// Can be used after we have successfully retrieved the adapter's friendly name.
//
__inline
VOID
BrdgProtLogAdapterErrorFriendly(
    IN NDIS_STATUS          ErrorCode,
    IN PADAPT               pAdapt,
    IN NDIS_STATUS          ErrorStatus
    )
{
    PWCHAR                  StringPtr = pAdapt->DeviceDesc.Buffer;
    NdisWriteEventLogEntry( gDriverObject, ErrorCode, 0, 1, &StringPtr, sizeof(NDIS_STATUS), &ErrorStatus );
}

//
// Writes an entry to the event log that indicates an error on a specific
// adapter.
//
// Reports the adapter's device name, so can be used before we have successfully retrieved
// the adapter's friendly name.
//
__inline
VOID
BrdgProtLogAdapterError(
    IN NDIS_STATUS          ErrorCode,
    IN PADAPT               pAdapt,
    IN NDIS_STATUS          ErrorStatus
    )
{
    PWCHAR                  StringPtr = pAdapt->DeviceName.Buffer;
    NdisWriteEventLogEntry( gDriverObject, ErrorCode, 0, 1, &StringPtr, sizeof(NDIS_STATUS), &ErrorStatus );
}

// Removes all references to an adapter from our various tables
__forceinline
VOID
BrdgProtScrubAdapter(
    IN PADAPT               pAdapt
    )
{
    BrdgTblScrubAdapter( pAdapt );
    BrdgCompScrubAdapter( pAdapt );
}

// Returns the number of adapters that are currently bridged.
ULONG
BrdgProtGetAdapterCount()
{
    return gNumAdapters;
}


// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgProtDriverInit()
/*++

Routine Description:

    Initialization routine for the protocol section.
    Must be called at PASSIVE level because we call NdisRegisterProtocol().

Arguments:

    None

Return Value:

    STATUS_SUCCESS to continue initialization or an error
    code to abort driver startup

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS   ProtChars;
    NDIS_STATUS                     NdisStatus;
    NDIS_STRING                     Name;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Initialize locks
    NdisInitializeReadWriteLock( &gAdapterListLock );
    NdisInitializeReadWriteLock( &gAdapterCharacteristicsLock );

    //
    // Register the protocol.
    //
    NdisZeroMemory(&ProtChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtChars.MajorNdisVersion = 5;
    ProtChars.MinorNdisVersion = 0;

    //
    // Make sure the protocol-name matches the service-name under which this protocol is installed.
    // This is needed to ensure that NDIS can correctly determine the binding and call us to bind
    // to miniports below.
    //
    NdisInitUnicodeString(&Name, PROTOCOL_NAME);
    ProtChars.Name = Name;
    ProtChars.OpenAdapterCompleteHandler = BrdgProtOpenAdapterComplete;
    ProtChars.CloseAdapterCompleteHandler = BrdgProtCloseAdapterComplete;
    ProtChars.RequestCompleteHandler = BrdgProtRequestComplete;
    ProtChars.ReceiveCompleteHandler = BrdgProtReceiveComplete;
    ProtChars.StatusHandler = BrdgProtStatus;
    ProtChars.StatusCompleteHandler = BrdgProtStatusComplete;
    ProtChars.BindAdapterHandler = BrdgProtBindAdapter;
    ProtChars.UnbindAdapterHandler = BrdgProtUnbindAdapter;
    ProtChars.PnPEventHandler = BrdgProtPnPEvent;
    ProtChars.UnloadHandler = BrdgProtUnload;
    ProtChars.CoReceivePacketHandler = BrdgProtCoReceive;

    //
    // These entry points are provided by the forwarding engine
    //
    ProtChars.ReceiveHandler = BrdgFwdReceive;
    ProtChars.TransferDataCompleteHandler = BrdgFwdTransferComplete;
    ProtChars.ReceivePacketHandler = BrdgFwdReceivePacket;
    ProtChars.SendCompleteHandler = BrdgFwdSendComplete;

    // Register ourselves
    NdisRegisterProtocol(&NdisStatus,
                         &gProtHandle,
                         &ProtChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        // This is a fatal error. Log it.
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(PROT, ("Failed to register the protocol driver with NDIS: %08x\n", NdisStatus));
        return STATUS_UNSUCCESSFUL;
    }

#if DBG
    {
        NTSTATUS        Status;
        ULONG           Value;

        // Check if we're supposed to force all adapters into compat mode
        Status = BrdgReadRegDWord( &gRegistryPath, gForceAllCompatPropertyName, &Value );

        if( (Status == STATUS_SUCCESS) && (Value != 0L) )
        {
            DBGPRINT(COMPAT, ("FORCING ALL ADAPTERS TO COMPATIBILITY MODE!\n"));
            gAllAdaptersCompat = TRUE;
        }
    }
#endif

    return STATUS_SUCCESS;
}

VOID
BrdgProtRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       NdisRequest,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion handler for the previously posted request.

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure

    NdisRequest             The posted request (this should actually
                            be a pointer to an NDIS_REQUEST_BETTER
                            structure)

    Status                  Completion status

Return Value:

    None

--*/
{
    PNDIS_REQUEST_BETTER    pRequest = (PNDIS_REQUEST_BETTER)NdisRequest;

    // Communicate final status to blocked caller
    pRequest->Status = Status;

    //
    // Call the completion function if there is one.
    // Having a completion function and blocking against the
    // event are mutually exclusive, not least because the
    // completion function may free the memory block
    // holding the event.
    //
    if( pRequest->pFunc != NULL )
    {
        (*pRequest->pFunc)(pRequest, pRequest->FuncArg);
    }
    else
    {
        NdisSetEvent( &pRequest->Event );
    }
}

NDIS_STATUS
BrdgProtDoRequest(
    NDIS_HANDLE             BindingHandle,
    BOOLEAN                 bSet,
    NDIS_OID                Oid,
    PVOID                   pBuffer,
    UINT                    BufferSize
    )
/*++

Routine Description:

    Calls NdisRequest to retrieve or set information from an underlying NIC,
    and blocks until the call completes.

    Must be called at PASSIVE level because we wait on an event.

Arguments:

    BindingHandle           Handle to the NIC
    bSet                    TRUE == set info, FALSE == query info
    Oid                     Request code
    pBuffer                 Output buffer
    BufferSize              Size of output buffer


Return Value:

    Status of the request

--*/
{
    NDIS_STATUS             Status;
    NDIS_REQUEST_BETTER     Request;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    Request.Request.RequestType = bSet ? NdisRequestSetInformation : NdisRequestQueryInformation;
    Request.Request.DATA.QUERY_INFORMATION.Oid = Oid ;
    Request.Request.DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
    Request.Request.DATA.QUERY_INFORMATION.InformationBufferLength = BufferSize;

    NdisInitializeEvent( &Request.Event );
    NdisResetEvent( &Request.Event );
    Request.pFunc = NULL;
    Request.FuncArg = NULL;

    NdisRequest( &Status, BindingHandle, &Request.Request);

    if ( Status == NDIS_STATUS_PENDING )
    {
        NdisWaitEvent( &Request.Event, 0 /*Wait forever*/ );
        Status = Request.Status;
    }

    return Status;
}

VOID
BrdgProtCleanup()
/*++

Routine Description:

    Called during driver unload to do an orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS     NdisStatus;

    // Deregister ourselves as a protocol. This will cause calls to BrdgProtUnbindAdapter
    // for all open adapters.
    if (gProtHandle != NULL)
    {
        NDIS_HANDLE     TmpHandle = gProtHandle;

        gProtHandle = NULL;
        NdisDeregisterProtocol(&NdisStatus, TmpHandle);
        SAFEASSERT( NdisStatus == NDIS_STATUS_SUCCESS );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgProtUnload(VOID)
{
    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    BrdgShutdown();
}

NDIS_STATUS
BrdgProtCompleteBindAdapter(
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Called by BrdgProtOpenAdapterComplete to complete the process of binding
    to an underlying NIC

    Must be called at < DISPATCH_LEVEL because we call BrdgMiniInstantiateMiniport().

Arguments:

    pAdapt                      The adapter to finish setting up

Return Value:

    Status of the operation. If the return code is != NDIS_STATUS_SUCCESS, the binding
    is aborted and this adapter is not used again. Any error must be logged since it
    causes us to fail to bind to an adapter.

--*/
{
    NDIS_STATUS                 Status;
    LOCK_STATE                  LockState;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    //
    // Query the adapter's friendly name.
    //
    Status = NdisQueryAdapterInstanceName(&pAdapt->DeviceDesc, pAdapt->BindingHandle);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // We failed.
        BrdgProtLogAdapterError( EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Failed to get an adapter's friendly name: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's media state (connected / disconnected)
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_MEDIA_CONNECT_STATUS,
                                &pAdapt->MediaState, sizeof(pAdapt->MediaState) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Some old crummy drivers don't support this OID
        pAdapt->MediaState = NdisMediaStateConnected;
    }

    //
    // Get the adapter's link speed
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_LINK_SPEED,
                                &pAdapt->LinkSpeed, sizeof(pAdapt->LinkSpeed) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Couldn't get an adapter's link speed: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's MAC address
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_802_3_PERMANENT_ADDRESS,
                                &pAdapt->MACAddr, sizeof(pAdapt->MACAddr) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Couldn't get an adapter's MAC address: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's physical medium
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_PHYSICAL_MEDIUM,
                                &pAdapt->PhysicalMedium, sizeof(pAdapt->PhysicalMedium) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Most drivers don't actually support OID_GEN_PHYSICAL_MEDIUM yet. Fall back on
        // NO_MEDIUM when the driver can't report anything.
        pAdapt->PhysicalMedium = BRIDGE_NO_MEDIUM;
    }


    //
    // Give the miniport section a look at this adapter so it can set its MAC address
    //
    BrdgMiniInitFromAdapter( pAdapt );

    //
    // If pAdapt->bCompatibilityMode is already TRUE, it means that we found a reg
    // key during the initial bind phase that forces this adapter to compatibility mode
    // or that we force all adapters into compatibility mode.
    //
    if( !pAdapt->bCompatibilityMode )
    {
        ULONG       Filter = NDIS_PACKET_TYPE_PROMISCUOUS;

        // Attempt to put the adapter into promiscuous receive mode. If it fails this OID,
        // we put the adapter into compatibility mode

        if( BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                               &Filter, sizeof(Filter) ) != NDIS_STATUS_SUCCESS )
        {
            // The adapter doesn't seem to be able to do promiscuous mode. Put it in
            // compatibility mode.
            DBGPRINT(PROT, ("Adapter %p failed to go promiscuous; putting it in COMPATIBILITY MODE\n", pAdapt));
            pAdapt->bCompatibilityMode = TRUE;
        }
        else
        {
            // Set the filter back to nothing for now
            Filter = 0L;
            BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER, &Filter, sizeof(Filter) );
        }
    }


    // If the STA isn't active, make this adapter live now.
    if( gDisableSTA )
    {
        pAdapt->State = Forwarding;

        // Put the adapter into its initial state
        BrdgProtDoAdapterStateChange( pAdapt );
    }
    // Else we initialize the adapter's STA functions below

    //
    // Link the adapter into the queue
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, TRUE /* Write access */, &LockState );

    pAdapt->Next = gAdapterList;
    gAdapterList = pAdapt;
    gNumAdapters++;

    // Must update this inside the write lock on the adapter list
    if( pAdapt->bCompatibilityMode )
    {
        gCompatAdaptersExist = TRUE;
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    if (g_fIsTcpIpLoaded == TRUE)
    {
        // Inform the 1394 miniport that tcpip has been loaded
        BrdgSetMiniportsToBridgeMode(pAdapt, TRUE);
    }

    if( ! gDisableSTA )
    {
        //
        // Let the STA section initialize this adapter. This has to be done after the adapter
        // has been linked into the global list.
        //
        BrdgSTAInitializeAdapter( pAdapt );
    }

    // Tell the draining threads to take notice of the new adapter
    BrdgProtSignalAdapterListChange();

    // Update the miniport's idea of our virtual media state and link speed
    BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

    // Tell user-mode code about the new adapter
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyAddAdapter );

    // If we haven't yet called the miniport's InstantiateMiniport() function, do it now, since we have
    // at least one adapter in the list
    if( InterlockedCompareExchange(&gHaveInitedMiniport, 1L, 0L) == 0L )
    {
        // Miniport wasn't previously initialized
        BrdgMiniInstantiateMiniport();
    }

    // We're all done, so let people use the adapter
    pAdapt->bResetting = FALSE;

    DBGPRINT(PROT, ("BOUND SUCCESSFULLY to adapter %ws\n", pAdapt->DeviceDesc.Buffer));

    return NDIS_STATUS_SUCCESS;
}

VOID
BrdgProtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
/*++

Routine Description:

    Called by NDIS to bind to a miniport below.

    Must be called at PASSIVE_LEVEL because we call NdisOpenAdapter().

Arguments:

    Status          - Return status of bind here.
    BindContext     - Can be passed to NdisCompleteBindAdapter if this call is pended.
    DeviceName      - Device name to bind to. This is passed to NdisOpenAdapter.
    SystemSpecific1 - Can be passed to NdisOpenProtocolConfiguration to read per-binding information
    SystemSpecific2 - Unused for NDIS 5.0.


Return Value:

    NDIS_STATUS_PENDING if this call is pended. In this case call NdisCompleteBindAdapter to complete.
    Anything else completes this call synchronously

--*/
{
    PADAPT                          pAdapt = NULL;
    NDIS_STATUS                     Sts;
    UINT                            MediumIndex;
    LONG                            AdaptSize;
    NDIS_HANDLE                     ConfigHandle;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Don't do any new binds if we're shutting down
    if( gShuttingDown )
    {
        DBGPRINT(PROT, ("REFUSING to bind to new adapter during shutdown!\n"));
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
    }

    // Make sure we're not being asked to bind to ourselves!
    if( BrdgMiniIsBridgeDeviceName(DeviceName) )
    {
        DBGPRINT(PROT, ("REFUSING to bind to SELF!\n"));
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
    }

    //
    // Allocate memory for the Adapter structure.
    //
    AdaptSize = sizeof(ADAPT) + DeviceName->MaximumLength;
    NdisAllocateMemoryWithTag(&pAdapt, AdaptSize, 'gdrB');

    if (pAdapt == NULL)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    //
    // Initialize the adapter structure
    //
    NdisZeroMemory(pAdapt, AdaptSize);
    pAdapt->AdaptSize = AdaptSize;
    pAdapt->DeviceName.Buffer = (WCHAR *)((PUCHAR)pAdapt + sizeof(ADAPT));
    pAdapt->DeviceName.MaximumLength = DeviceName->MaximumLength;
    pAdapt->DeviceName.Length = DeviceName->Length;
    NdisMoveMemory(pAdapt->DeviceName.Buffer, DeviceName->Buffer, DeviceName->Length);
    NdisInitializeEvent( &pAdapt->Event );
    NdisResetEvent( &pAdapt->Event );
    NdisAllocateSpinLock( &pAdapt->QueueLock );
    BrdgInitializeSingleList( &pAdapt->Queue );
    pAdapt->bServiceInProgress = FALSE;
    pAdapt->bSTAInited = FALSE;

    // Start out with this TRUE so no one can use the adapter until we're done
    // initializing it
    pAdapt->bResetting = TRUE;

    // Zero out statistics
    pAdapt->SentFrames.LowPart = pAdapt->SentFrames.HighPart = 0L;
    pAdapt->SentBytes.LowPart = pAdapt->SentBytes.HighPart = 0L;
    pAdapt->SentLocalFrames.LowPart = pAdapt->SentLocalFrames.HighPart = 0L;
    pAdapt->SentLocalBytes.LowPart = pAdapt->SentLocalBytes.HighPart = 0L;
    pAdapt->ReceivedFrames.LowPart = pAdapt->ReceivedFrames.HighPart = 0L;
    pAdapt->ReceivedBytes.LowPart = pAdapt->ReceivedBytes.HighPart = 0L;

    // The adapter starts off disabled
    pAdapt->State = Disabled;

    // Initialize quota information
    BrdgBufInitializeQuota( &pAdapt->Quota );

    BrdgInitializeWaitRef( &pAdapt->Refcount, FALSE );
    BrdgInitializeWaitRef( &pAdapt->QueueRefcount, FALSE );

    KeInitializeEvent( &pAdapt->QueueEvent, SynchronizationEvent, FALSE );

    pAdapt->bCompatibilityMode = FALSE;

#if DBG
    if( gAllAdaptersCompat )
    {
        pAdapt->bCompatibilityMode = TRUE;
    }
    else
    {
#endif
        // Check if a registry entry forces this adapter to compatibility mode
        NdisOpenProtocolConfiguration( Status, &ConfigHandle, SystemSpecific1);

        if( *Status == NDIS_STATUS_SUCCESS )
        {
            PNDIS_CONFIGURATION_PARAMETER   pncp;

            NdisReadConfiguration( Status, &pncp, ConfigHandle, &gForceCompatValueName, NdisParameterHexInteger );

            if( (*Status == NDIS_STATUS_SUCCESS) && (pncp->ParameterData.IntegerData != 0L ) )
            {
                DBGPRINT(PROT, ("Forcing adapter into COMPATIBILITY MODE as per registry entry\n"));
                pAdapt->bCompatibilityMode = TRUE;
            }

            NdisCloseConfiguration( ConfigHandle );
        }
        else
        {
            DBGPRINT(PROT, ("Failed to open protocol configuration for an adapter: %8x\n", *Status));
        }
#if DBG
    }
#endif

    //
    // Now open the adapter below
    //
    NdisOpenAdapter(Status,
                    &Sts,
                    &pAdapt->BindingHandle,
                    &MediumIndex,
                    gMediumArray,
                    sizeof(gMediumArray)/sizeof(NDIS_MEDIUM),
                    gProtHandle,
                    pAdapt,
                    DeviceName,
                    0,
                    NULL);

    if ( *Status == NDIS_STATUS_PENDING )
    {
        // The bind will complete later in BrdgProtOpenAdapterComplete
    }
    else
    {
        // Complete the bind right away
        BrdgProtOpenAdapterComplete( (NDIS_HANDLE)pAdapt, *Status, *Status );
    }
}

VOID
BrdgProtOpenAdapterComplete(
    IN  NDIS_HANDLE          ProtocolBindingContext,
    IN  NDIS_STATUS          Status,
    IN  NDIS_STATUS          OpenErrorStatus
    )
/*++

Routine Description:

    Completion routine for NdisOpenAdapter issued from within the BrdgProtBindAdapter. Simply
    unblock the caller.

    Must be called at PASSIVE_LEVEL because we wait on an event.

Arguments:

    ProtocolBindingContext  Pointer to the adapter
    Status                  Status of the NdisOpenAdapter call
    OpenErrorStatus         Secondary status(ignored by us).

Return Value:

    None

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Log this error since it means we can't use the adapter.
        BrdgProtLogAdapterError( EVENT_BRIDGE_ADAPTER_BIND_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("BIND FAILURE: Failed to open adapter: %08x, %08x\n", Status, OpenErrorStatus));
        NdisFreeMemory( pAdapt, pAdapt->AdaptSize, 0 );
    }
    else
    {
        // BrdgProtCompleteBindAdapter must log any fatal errors
        Status = BrdgProtCompleteBindAdapter( pAdapt );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(PROT, ("BIND FAILURE: Couldn't complete adapter initialization: %08x\n", Status));

            BrdgSetMiniportsToBridgeMode (pAdapt, FALSE);  // Turn bridge mode off on pAdapt

            NdisCloseAdapter( &Status, pAdapt->BindingHandle );

            if ( Status == NDIS_STATUS_PENDING )
            {
                NdisWaitEvent( &pAdapt->Event, 0/*Wait forever*/ );
            }

            NdisFreeMemory( pAdapt, pAdapt->AdaptSize, 0 );
        }
    }
}

VOID
BrdgProtUnbindAdapter(
    OUT PNDIS_STATUS        pStatus,
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         UnbindContext
    )
/*++

Routine Description:

    Called by NDIS when we are required to unbind to the adapter below.

    Must be called at PASSIVE_LEVEL because we wait on an event

Arguments:

    pStatus                  Placeholder for return status
    ProtocolBindingContext  Pointer to the adapter structure
    UnbindContext           Context for NdisUnbindComplete() if this pends

Return Value:

    None

--*/
{
    PADAPT                  *pTmp, pAnAdapt, pAdapt =(PADAPT)ProtocolBindingContext;
    LOCK_STATE              LockState;
    ULONG                   Filter;
    BOOLEAN                 bFound = FALSE, bCompatAdaptersExist;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(PROT, ("UNBINDING Adapter %p :\n", pAdapt));
    DBGPRINT(PROT, ("%ws\n", pAdapt->DeviceDesc.Buffer));

    // Set the Underlying miniports to Off
    BrdgSetMiniportsToBridgeMode(pAdapt,FALSE);

    // Shut off all packet reception as the first order of business
    Filter = 0L;
    BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                       &Filter, sizeof(Filter) );

    // Take this adapter out of the queue
    NdisAcquireReadWriteLock( &gAdapterListLock, TRUE /* Write access */, &LockState );

    for (pTmp = &gAdapterList; *pTmp != NULL; pTmp = &(*pTmp)->Next)
    {
        if (*pTmp == pAdapt)
        {
            *pTmp = pAdapt->Next;
            bFound = TRUE;
            break;
        }
    }

    gNumAdapters--;
    SAFEASSERT ( bFound );

    // Find out if there are any compat-mode adapters left
    bCompatAdaptersExist = FALSE;

    for( pAnAdapt = gAdapterList; pAnAdapt != NULL; pAnAdapt = pAnAdapt->Next)
    {
        if( pAnAdapt->bCompatibilityMode )
        {
            bCompatAdaptersExist = TRUE;
        }
    }

    // Must update this inside the write lock
    gCompatAdaptersExist = bCompatAdaptersExist;

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    //
    // Now no code will attempt to target this adapter for floods.
    //

    // Scrub this adapter from our tables so no one will attempt to target it.
    BrdgProtScrubAdapter( pAdapt );

    // Stop packet forwarding on this adapter
    if( gDisableSTA )
    {
        pAdapt->State = Disabled;
    }
    else
    {
        // Have the STA shut down its operations on this adapter
        BrdgSTAShutdownAdapter( pAdapt );
    }

    //
    // Prevent new packets from being processed on this adapter
    //
    BrdgBlockWaitRef( &pAdapt->Refcount );

    //
    // Wait for this adapter's queue to be drained by the worker threads.
    //
    BrdgShutdownWaitRefOnce( &pAdapt->QueueRefcount );

    //
    // Signal the change in adapter list to the queue-draining threads.
    // This will remove this adapter from the threads' list of queues they block against.
    //
    BrdgProtSignalAdapterListChange();

    //
    // Must wait for adapter refcount to go to zero before closing down the adapter.
    // This doesn't mean all requests have completed, just that none of our code is
    // holding this adapter's pointer anymore.
    //
    // Our receive functions bump up the refcount while they're processing an
    // inbound packet, so when the refcount drops to zero we should also have completed
    // any in-progress handling of received packets.
    //
    // The queue-draining threads also increment the refcount for adapters they are
    // using, so this wait is our guarantee that all threads have stopped using this
    // adapter as well.
    //
    BrdgShutdownWaitRefOnce( &pAdapt->Refcount );
    SAFEASSERT( pAdapt->Refcount.Refcount == 0L );

    //
    // Close this binding. This will pend till all NDIS requests in progress are
    // completed.
    //
    NdisResetEvent( &pAdapt->Event );
    NdisCloseAdapter( pStatus, pAdapt->BindingHandle );

    if ( *pStatus == NDIS_STATUS_PENDING )
    {
        NdisWaitEvent( &pAdapt->Event, 0 /*Wait forever*/ );
    }

    // Tell user-mode code the adapter left (this call should not attempt to read from
    // pAdapt)
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyRemoveAdapter );

    // Free adapter resources
    if (pAdapt->DeviceDesc.Buffer != NULL)
    {
        NdisFreeMemory(pAdapt->DeviceDesc.Buffer, pAdapt->DeviceDesc.MaximumLength, 0);
    }

    NdisFreeMemory(pAdapt, pAdapt->AdaptSize, 0);

    DBGPRINT(PROT, ("Unbind complete.\n"));

    // Have the miniport update in light of the missing adapter
    BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

    *pStatus = NDIS_STATUS_SUCCESS;
}

VOID
BrdgProtDoAdapterStateChange(
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Adjusts an adapter's packet filter and multicast list based on its current state.

    If the adapter is Forwarding or Learning, the adapter is put in promiscuous mode so
    all packets are received.

    If the adapter is Blocking or Listening, the adapter is set to receive only the STA
    multicast packets.

    Errors are logged since this is a vital operation

Arguments:

    pAdapt                  The adapter

Return Value:

    Status code of the operation

--*/

{
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    ULONG                   Filter;
    PORT_STATE              State = pAdapt->State;      // Freeze this value
    BOOLEAN                 bReceiveAllMode = (BOOLEAN)((State == Forwarding) || (State == Learning));

    if( ! bReceiveAllMode )
    {
        //
        // Even if we're not forwarding packets off this interface, we still need to listen
        // for Spanning Tree Algorithm traffic
        //
        Status = BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_802_3_MULTICAST_LIST,
                                    STA_MAC_ADDR, sizeof(STA_MAC_ADDR) );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_FILTER_FAILED, pAdapt, Status );
            DBGPRINT(PROT, ("Failed to set adapter %p's multicast list: %08x\n", pAdapt, Status));
            return;
        }
    }

    // Now set the packet filter appropriately
    if( pAdapt->bCompatibilityMode )
    {
        //
        // Compatibility adapters can't do promiscuous properly. Our compatibility
        // code relies only on them receiving traffic unicast to this machine, as
        // well as all broadcast and multicast traffic.
        //
        Filter = bReceiveAllMode ? NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_ALL_MULTICAST : NDIS_PACKET_TYPE_MULTICAST;
    }
    else
    {
        Filter = bReceiveAllMode ? NDIS_PACKET_TYPE_PROMISCUOUS : NDIS_PACKET_TYPE_MULTICAST;
    }

    Status =  BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                                 &Filter, sizeof(Filter) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_FILTER_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Failed to set adapter %p's packet filter: %08x\n", pAdapt, Status));
    }

    // Tell the miniport about the change so it can change the bridge's characteristics if it wants.
    BrdgMiniUpdateCharacteristics( FALSE /*Not a physical connectivity change*/ );
}

VOID
BrdgProtCloseAdapterComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion for the CloseAdapter call. Just unblocks waiting code

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    Status                  Completion status

Return Value:

    None.

--*/
{
    PADAPT  pAdapt =(PADAPT)ProtocolBindingContext;
    NdisSetEvent( &pAdapt->Event );
}

VOID
BrdgProtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of received buffers.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    //
    // Nothing to do here
    //
}


VOID
BrdgProtStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Handles status indications from underlying adapters

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PADAPT    pAdapt =(PADAPT)ProtocolBindingContext;

    switch( GeneralStatus )
    {
    case NDIS_STATUS_MEDIA_DISCONNECT:
    case NDIS_STATUS_MEDIA_CONNECT:
        {
            if( pAdapt != NULL )
            {
                LOCK_STATE      LockState;

                ULONG MediaState = (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) ?
                                    NdisMediaStateConnected :
                                    NdisMediaStateDisconnected;

                if( GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT )
                {
                    // Scrub the disconnected adapter from our tables. We will
                    // have to relearn its hosts
                    BrdgProtScrubAdapter( pAdapt );
                }

                if( ! gDisableSTA )
                {
                    // The STA needs to know when adapters connect and disconnect
                    if( MediaState == NdisMediaStateConnected )
                    {
                        BrdgSTAEnableAdapter( pAdapt );
                    }
                    else
                    {
                        BrdgSTADisableAdapter( pAdapt );
                    }
                }

                // A global lock is used for adapter characteristics, since they must be read
                // all at once by the miniport
                NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE /*Write access*/, &LockState );
                pAdapt->MediaState = MediaState;
                NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

                // See if this makes any difference to our overall state
                BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

                // Tell user-mode code that the adapter media state changed
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyMediaStateChange );
            }
            else
            {
                DBGPRINT(PROT, ("BrdgProtStatus called for link status with NULL adapter!\n"));
            }
        }
        break;

    case NDIS_STATUS_LINK_SPEED_CHANGE:
        {
            if( (pAdapt != NULL) &&
                (StatusBuffer != NULL) &&
                (StatusBufferSize >= sizeof(ULONG)) )
            {
                LOCK_STATE      LockState;

                // A global lock is used for adapter characteristics, since they must be read
                // all at once by the miniport
                NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE /*Write access*/, &LockState );
                pAdapt->LinkSpeed = *((ULONG*)StatusBuffer);
                NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

                if( ! gDisableSTA )
                {
                    // Tell the STA about the change so it can tweak the cost of this link
                    BrdgSTAUpdateAdapterCost( pAdapt, *((ULONG*)StatusBuffer) );
                }

                // See if this makes any difference to our overall state
                BrdgMiniUpdateCharacteristics( FALSE /*Not a connectivity change*/ );

                // Tell user-mode code that the adapter speed changed
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyLinkSpeedChange );
            }
            else
            {
                DBGPRINT(PROT, ("BrdgProtStatus called for link speed with bad params!\n"));
            }
        }
        break;

    case NDIS_STATUS_RESET_START:
        {
            DBGPRINT(PROT, ("Adapter %p RESET START\n", pAdapt));
            pAdapt->bResetting = TRUE;
        }
        break;

    case NDIS_STATUS_RESET_END:
        {
            DBGPRINT(PROT, ("Adapter %p RESET END\n", pAdapt));
            pAdapt->bResetting = FALSE;
        }
        break;

    default:
        {
            DBGPRINT(PROT, ("Unhandled status indication: %08x\n", GeneralStatus));
        }
        break;
    }
}


VOID
BrdgProtStatusComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext
    )
/*++

Routine Description:

    NDIS entry point called when a status indication completes.
    We do nothing in response to this.

Arguments:

    ProtocolBindingContext  The adapter involved

Return Value:

    None

--*/
{
    //
    // Nothing to do here
    //
}

VOID
BrdgProtInstantiateMiniport(
    IN PVOID        unused
    )
/*++

Routine Description:

    Deferrable function to call BrdgMiniInstantiateMiniport(), which must run
    at low IRQL

    Must run at < DISPATCH_LEVEL

Arguments:

    unused          Unused

Return Value:

    None

--*/
{
    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    BrdgMiniInstantiateMiniport();
}

NDIS_STATUS
BrdgProtPnPEvent(
    IN NDIS_HANDLE      ProtocolBindingContext,
    IN PNET_PNP_EVENT   NetPnPEvent
    )
/*++

Routine Description:

    NDIS entry point called to indicate a PnP event to us

Arguments:

    ProtocolBindingContext  The adapter involved
    NetPnPEvent             The event

Return Value:

    Our status code in response to the event (should be NDIS_STATUS_SUCCESS or
    NDIS_STATUS_UNSUPPORTED)

--*/
{
    PADAPT          pAdapt = (PADAPT)ProtocolBindingContext;

    switch( NetPnPEvent->NetEvent )
    {
    case NetEventBindsComplete:
    case NetEventSetPower:
    case NetEventQueryPower:
    case NetEventCancelRemoveDevice:
    case NetEventBindList:
    case NetEventQueryRemoveDevice:
    case NetEventPnPCapabilities:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case NetEventReconfigure:
        {
            if( pAdapt == NULL )
            {
                NDIS_HANDLE         MiniportHandle;

                //
                // A NetEventReconfigure event with a NULL binding context is either a
                // global indication of config changes or a signal from NDIS to restart
                // our miniport (for example, if it got disabled and then re-enabled).
                //
                // We're only interested in the case of a signal to restart our miniport.
                // We'll assume this can only happen after we have initialized it the
                // first time around.
                //
                // This is wierd, I know.
                //

                MiniportHandle = BrdgMiniAcquireMiniport();

                if( gHaveInitedMiniport && (MiniportHandle == NULL) )
                {
                    // Our miniport isn't initialized. Fire it up again.
                    // We can't do this at the high IRQL we're currently at, so defer the function.
                    DBGPRINT(PROT, ("Restarting miniport in response to NULL NetEventReconfigure signal\n"));
                    BrdgDeferFunction( BrdgProtInstantiateMiniport, NULL );
                }

                if( MiniportHandle != NULL )
                {
                    BrdgMiniReleaseMiniport();
                }
            }

            return NDIS_STATUS_SUCCESS;
        }
        break;
    }

    DBGPRINT(PROT, ("Unsupported PnP Code: %i\n", NetPnPEvent->NetEvent));
    return NDIS_STATUS_NOT_SUPPORTED;
}


UINT
BrdgProtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    NDIS entry point called to indicate packets that are being sent
    on the Co-Ndis path.

Arguments:


Return Value:
    Return 0 as this is a do-nothing function

--*/
{

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgprot.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgprot.h

Abstract:

    Ethernet MAC level bridge.
    Protocol section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgProtDriverInit();

VOID
BrdgProtRequestComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  NDIS_STATUS             Status
    );

VOID
BrdgProtDoAdapterStateChange(
    IN PADAPT                   pAdapt
    );

VOID
BrdgProtCleanup();

ULONG
BrdgProtGetAdapterCount();


// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Controls access to all the adapters' link speed, media state, etc
extern NDIS_RW_LOCK             gAdapterCharacteristicsLock;

// Number of bound adapters. Cannot change while a lock is held on gAdapterListLock
extern ULONG                    gNumAdapters;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgsta.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgsta.h

Abstract:

    Ethernet MAC level bridge
    Spanning-Tree Algorithm header file

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgSTADriverInit();

VOID
BrdgSTACleanup();

VOID
BrdgSTADeferredInit(
    IN PUCHAR           pBridgeMACAddress
    );

VOID
BrdgSTAEnableAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAInitializeAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTADisableAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAShutdownAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAUpdateAdapterCost(
    IN PADAPT           pAdapt,
    ULONG               LinkSpeed
    );

VOID
BrdgSTAReceivePacket(
    IN PADAPT           pAdapt,
    IN PNDIS_PACKET     pPacket
    );

VOID
BrdgSTAGetAdapterSTAInfo(
    IN PADAPT                   pAdapt,
    PBRIDGE_STA_ADAPTER_INFO    pInfo
    );

VOID
BrdgSTAGetSTAInfo(
    PBRIDGE_STA_GLOBAL_INFO     pInfo
    );

VOID
BrdgSTACancelTimersGPO();

VOID
BrdgSTARestartTimersGPO();

VOID
BrdgSTAResetSTAInfoGPO();

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// If TRUE, the STA is disabled for the lifetime of the bridge.
// This global does not change after initialization time.
extern BOOLEAN          gDisableSTA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgsta.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    brdgsta.c

Abstract:

    Ethernet MAC level bridge.
    Spanning Tree Algorithm section

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgsta.h"

#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// BPDU types
typedef enum
{
    ConfigBPDU,
    TopologyChangeBPDU
} BPDU_TYPE;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

// These values measured in STA units (1/256ths of a second)
#define DEFAULT_MAX_AGE                 (8 * 256)       // 8 seconds
#define DEFAULT_HELLO_TIME              (2 * 256)       // 2 seconds
#define DEFAULT_FORWARD_DELAY           (5 * 256)       // 5 seconds
#define MESSAGE_AGE_INCREMENT           1               // 1 STA time unit

// These values measured in milliseconds
#define HOLD_TIMER_PERIOD               (1 * 1000)      // 1 second in milliseconds

// Normal size, in bytes, of a full-size (non-TCN) STA packet
#define CONFIG_BPDU_PACKET_SIZE         35

// Size, in bytes, of a TCN STA packet
#define TCN_BPDU_PACKET_SIZE            4

// The name of the registry entry that causes the STA to be disabled
const PWCHAR                            gDisableSTAParameterName = L"DisableSTA";

// The size of an 802.3 header with LLC
#define _802_3_HEADER_SIZE              17

// Value to be added to port IDs; must leave the bottom byte clear to store
// actual port ID
#define PORT_PRIORITY                   0x8000

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

//
// This structure holds the information for a complete BPDU (although
// it is not laid out as the BPDU is actually transmitted on the wire)
//
typedef struct _CONFIG_BPDU
{
    BPDU_TYPE           Type;
    UCHAR               RootID[BRIDGE_ID_LEN];
    PATH_COST           RootCost;
    UCHAR               BridgeID[BRIDGE_ID_LEN];
    PORT_ID             PortID;
    STA_TIME            MessageAge;
    STA_TIME            MaxAge;
    STA_TIME            HelloTime;
    STA_TIME            ForwardDelay;
    BOOLEAN             bTopologyChangeAck;
    BOOLEAN             bTopologyChange;
} CONFIG_BPDU, *PCONFIG_BPDU;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Global spin lock protects all STA data accesses (for data stored in adapters
// as well as globals)
NDIS_SPIN_LOCK          gSTALock;

// The bridge we believe is the root bridge
UCHAR                   gDesignatedRootID[BRIDGE_ID_LEN];

// Our own unique ID
UCHAR                   gOurID[BRIDGE_ID_LEN];

// Whether our ID has been set yet
BOOLEAN                 gHaveID = FALSE;

// Our cost to reach the root
PATH_COST               gRootCost = 0;

// Our root port (adapter)
PADAPT                  gRootAdapter = NULL;

// Whether we have detected a topology change
BOOLEAN                 gTopologyChangeDetected = FALSE;

// Whether we tell other bridges that the topology has changed
BOOLEAN                 gTopologyChange = FALSE;

// Current bridge maximum message age
STA_TIME                gMaxAge = DEFAULT_MAX_AGE;

// Current bridge Hello time
STA_TIME                gHelloTime = DEFAULT_HELLO_TIME;

// Current bridge forward delay
STA_TIME                gForwardDelay = DEFAULT_FORWARD_DELAY;

// Every adapter must have a unique ID number, but there is no requirement that
// that number be unique over the lifetime of the bridge. This array is used as
// a bitfield that records which IDs are in use.
ULONG                   gUsedPortIDs[MAX_ADAPTERS / sizeof(ULONG) / 8];

//
// Timers
//
BRIDGE_TIMER            gTopologyChangeTimer;
BRIDGE_TIMER            gTopologyChangeNotificationTimer;
BRIDGE_TIMER            gHelloTimer;

// TRUE if the STA is disabled for the lifetime of the bridge
BOOLEAN                 gDisableSTA = FALSE;

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgSTARootSelection();

VOID
BrdgSTADesignatedPortSelection();

BOOLEAN
BrdgSTAPortStateSelection();

VOID
BrdgSTAGenerateConfigBPDUs();

VOID
BrdgSTABecomeDesignatedPort(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAProcessTCNBPDU(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAProcessConfigBPDU(
    IN PADAPT       pAdapt,
    IN PCONFIG_BPDU pbpdu
    );

BOOLEAN
BrdgSTATopologyChangeDetected();

VOID
BrdgSTACopyFromPacketToBuffer(
    OUT PUCHAR                      pPacketOut,
    IN ULONG                        BufferSize,
    OUT PULONG                      pWrittenCount,
    IN PNDIS_PACKET                 pPacketIn
    );

VOID
BrdgSTADeferredSetAdapterState(
    IN PVOID                Arg
    );

VOID
BrdgSTAHelloTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTAMessageAgeTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTAForwardDelayTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTATopologyChangeNotificationTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTATopologyChangeTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTAHoldTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTATransmitTCNPacket();

VOID
BrdgSTASetAdapterState(
    IN PADAPT               pAdapt,
    IN PORT_STATE           NewState
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Does a complete re-evaluation of STA info
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
VOID
BrdgSTAConfigUpdate()
{
    BrdgSTARootSelection();
    BrdgSTADesignatedPortSelection();
}

//
// Sets an NDIS timer using a time expressed in STA units
//
// No requirements on caller-held locks
//
__forceinline
VOID
BrdgSTASetTimerWithSTATime(
    IN PBRIDGE_TIMER    pTimer,
    IN STA_TIME         Time,
    IN BOOLEAN          bRecurring
    )
{
    BrdgSetTimer( pTimer, Time * 1000 / 256, bRecurring );
}

//
// Compares two bridge IDs.
//
//      -1      :       A < B
//      0       :       A == B
//      1       :       A > B
//
// No requirements on caller-held locks
//
__forceinline
INT
BrdgSTABridgeIDCmp(
    IN PUCHAR           pIDa,
    IN PUCHAR           pIDb
    )
{
    UINT        i;

    for( i = 0; i < BRIDGE_ID_LEN; i++ )
    {
        if( pIDa[i] > pIDb[i] )
        {
            return 1;
        }
        else if( pIDa[i] < pIDb[i] )
        {
            return -1;
        }
    }

    return 0;
}

//
// Returns whether or not we currently believe ourselves to be the root
// bridge.
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
BOOLEAN
BrdgSTAWeAreRoot()
{
    SAFEASSERT( gHaveID );
    return (BOOLEAN)(BrdgSTABridgeIDCmp( gOurID, gDesignatedRootID ) == 0);
}

//
// Copies a bridge ID from pIDSrc to pIDDest.
//
// No requirements on caller-held locks
//
__forceinline
VOID
BrdgSTACopyID(
    IN PUCHAR           pIDDest,
    IN PUCHAR           pIDSrc
    )
{
    UINT        i;

    for( i = 0; i < BRIDGE_ID_LEN; i++ )
    {
        pIDDest[i] = pIDSrc[i];
    }
}

//
// Calculates the STA path cost from an adapter's link speed.
// Follows IEEE 802.1D-1990 recommendation that the link cost be set
// to 1000 / (Speed in Mbits/s).
//
// No requirements on caller-held locks
//
__forceinline
PATH_COST
BrdgSTALinkCostFromLinkSpeed(
    IN ULONG            LinkSpeed
    )
{
    ULONG               retVal;

    // Link speed is reported in units of 100bps
    if( LinkSpeed == 0L )
    {
        // Avoid div by zero and return very high path cost
        DBGPRINT(STA, ("Zero link speed reported\n"));
        retVal = 0xFFFFFFFF;
    }
    else
    {
        retVal = (PATH_COST)(10000000L / LinkSpeed);
    }

    if( retVal == 0L )
    {
        // STA spec calls for path costs to always be at least 1
        return 1L;
    }
    else
    {
        return retVal;
    }
}

//
// Updates the global gTopologyChange flag. When this flag is set,
// we must use a forwarding table timeout value equal to the bridge's
// current forwarding delay. When the flag is not set, we use
// the table's default timeout value.
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
VOID
BrdgSTAUpdateTopologyChange(
    IN BOOLEAN          NewValue
    )
{
    if( gTopologyChange != NewValue )
    {
        gTopologyChange = NewValue;

        if( gTopologyChange )
        {
            // Convert the forward delay to ms
            BrdgTblSetTimeout( gForwardDelay * 1000 / 256 );
        }
        else
        {
            BrdgTblRevertTimeout();
        }
    }
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgSTAGetAdapterSTAInfo(
    IN PADAPT                   pAdapt,
    PBRIDGE_STA_ADAPTER_INFO    pInfo
    )
/*++

Routine Description:

    Copies STA information for a particular adapter into a structure

    Called to collect information for user-mode components

Arguments:

    pAdapt                      The adapter
    pInfo                       Structure to receive STA information

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    pInfo->ID = pAdapt->STAInfo.ID;
    pInfo->PathCost = pAdapt->STAInfo.PathCost;
    BrdgSTACopyID( pInfo->DesignatedRootID, pAdapt->STAInfo.DesignatedRootID );
    pInfo->DesignatedCost = pAdapt->STAInfo.DesignatedCost;
    BrdgSTACopyID( pInfo->DesignatedBridgeID, pAdapt->STAInfo.DesignatedBridgeID );
    pInfo->DesignatedPort = pAdapt->STAInfo.DesignatedPort;

    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAGetSTAInfo(
    PBRIDGE_STA_GLOBAL_INFO     pInfo
    )
/*++

Routine Description:

    Copies global STA information into a structure

    Called to collect information for user-mode components

Arguments:

    pInfo                       Structure to receive STA information

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    SAFEASSERT( gHaveID );

    BrdgSTACopyID( pInfo->OurID, gOurID );
    BrdgSTACopyID( pInfo->DesignatedRootID, gDesignatedRootID );
    pInfo->RootCost = gRootCost;
    pInfo->RootAdapter = (BRIDGE_ADAPTER_HANDLE)gRootAdapter;
    pInfo->bTopologyChangeDetected = gTopologyChangeDetected;
    pInfo->bTopologyChange = gTopologyChange;
    pInfo->MaxAge = gMaxAge;
    pInfo->HelloTime = gHelloTime;
    pInfo->ForwardDelay = gForwardDelay;

    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAUpdateAdapterCost(
    IN PADAPT           pAdapt,
    ULONG               LinkSpeed
    )
/*++

Routine Description:

    Updates an adapter's path cost to reflect an updated link speed

Arguments:

    pAdapt              The adapter
    LinkSpeed           The adapter's new link speed

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        pAdapt->STAInfo.PathCost = BrdgSTALinkCostFromLinkSpeed(LinkSpeed);

        // Do a global re-evaluation of STA info
        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();
    }
    else
    {
        DBGPRINT(STA, ("BrdgSTAUpdateAdapterCost() called with uninitialized adapter; ignoring!\n"));
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

NTSTATUS
BrdgSTADriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            NtStatus;
    UINT                i;
    ULONG               regValue;

    NdisAllocateSpinLock( &gSTALock );

    BrdgInitializeTimer( &gTopologyChangeTimer, BrdgSTATopologyChangeTimerExpiry, NULL );
    BrdgInitializeTimer( &gTopologyChangeNotificationTimer, BrdgSTATopologyChangeNotificationTimerExpiry, NULL );
    BrdgInitializeTimer( &gHelloTimer, BrdgSTAHelloTimerExpiry, NULL );

    // We haven't used any port IDs yet...
    for( i = 0; i < sizeof(gUsedPortIDs) / sizeof(ULONG); i++ )
    {
        gUsedPortIDs[i] = 0;
    }

    // Check if we're supposed to disable the STA
    NtStatus = BrdgReadRegDWord( &gRegistryPath, gDisableSTAParameterName, &regValue );

    if( (NtStatus == STATUS_SUCCESS) &&
        (regValue != 0L) )
    {
        gDisableSTA = TRUE;
        DBGPRINT(STA, ("DISABLING SPANNING TREE ALGORITHM\n"));
    }

    return STATUS_SUCCESS;
}

VOID
BrdgSTADeferredInit(
    IN PUCHAR           pBridgeMACAddress
    )
/*++

Routine Description:

    Second initialization pass; called when we determine the bridge's
    MAC address (which is needed for STA operations)

Arguments:

    pBridgeMACAddress   The bridge miniport's MAC address

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    UINT                i;

    // Our identifier consists of our MAC address preceeded with 0x8000
    gOurID[0] = 0x80;
    gOurID[1] = 0x00;

    for( i = BRIDGE_ID_LEN - ETH_LENGTH_OF_ADDRESS; i < BRIDGE_ID_LEN; i++ )
    {
        gOurID[i] = pBridgeMACAddress[i - (BRIDGE_ID_LEN - ETH_LENGTH_OF_ADDRESS)];
    }

    // Set the root bridge ID as our own to start out with
    BrdgSTACopyID( gDesignatedRootID, gOurID );
    gHaveID = TRUE;

    if (BrdgFwdBridgingNetworks())
    {
        // Don't use locks; rely on this function being non-reentrant and always run
        // before any other functions
        if( BrdgSTAPortStateSelection() )
        {
            BrdgSTATransmitTCNPacket();
        }

        BrdgSTAGenerateConfigBPDUs();
        BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );   
    }
}

VOID
BrdgSTACleanup()
/*++

Routine Description:

    Driver unload-time cleanup

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BrdgShutdownTimer( &gTopologyChangeTimer );
    BrdgShutdownTimer( &gTopologyChangeNotificationTimer );
    BrdgShutdownTimer( &gHelloTimer );
}

VOID
BrdgSTAEnableAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Enables STA operations on an adapter. Can be called multiple times
    (in conjunction with BrdgSTADisableAdapter()) for a given adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bTransmitTCN = FALSE;

    DBGPRINT(STA, ("ENABLING adapter %p\n", pAdapt));

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        BrdgSTABecomeDesignatedPort(pAdapt);
        BrdgSTASetAdapterState( pAdapt, Blocking );

        pAdapt->STAInfo.bTopologyChangeAck = FALSE;
        pAdapt->STAInfo.bConfigPending = FALSE;

        bTransmitTCN = BrdgSTAPortStateSelection();
    }
    else
    {
        DBGPRINT(STA, ("BrdgSTAEnableAdapter() called with uninitialized adapter; ignoring!\n"));
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN && BrdgFwdBridgingNetworks())
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAInitializeAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    One-time initialization for a new adatper

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.
    ASSUMES the adapter has already been added to the global list

--*/
{
    if( BrdgAcquireAdapter(pAdapt) )
    {
        UINT            i, j;

        // Adapters should always be disabled when being initialized, either because they are
        // brand new and this is how they start out, or as a way of checking that they were
        // correctly stopped when they were last disconnected.
        SAFEASSERT( pAdapt->State == Disabled );

        pAdapt->STAInfo.PathCost = BrdgSTALinkCostFromLinkSpeed(pAdapt->LinkSpeed);

        BrdgInitializeTimer( &pAdapt->STAInfo.MessageAgeTimer, BrdgSTAMessageAgeTimerExpiry, pAdapt );
        BrdgInitializeTimer( &pAdapt->STAInfo.ForwardDelayTimer, BrdgSTAForwardDelayTimerExpiry, pAdapt );
        BrdgInitializeTimer( &pAdapt->STAInfo.HoldTimer, BrdgSTAHoldTimerExpiry, pAdapt );
        pAdapt->STAInfo.LastConfigTime = 0L;

        // Find an unused port number in the bitfield
        NdisAcquireSpinLock( &gSTALock );
        for( i = 0; i < sizeof(gUsedPortIDs) / sizeof(ULONG); i++ )
        {
            for( j = 0; j < sizeof(ULONG) * 8; j++ )
            {
                if( (gUsedPortIDs[i] & (1 << j)) == 0 )
                {
                    pAdapt->STAInfo.ID = (PORT_ID)(PORT_PRIORITY | ((i * sizeof(ULONG) * 8) + j));
                    DBGPRINT(STA, ("Adapter %p gets ID %i\n", pAdapt, pAdapt->STAInfo.ID));
                    gUsedPortIDs[i] |= (1 << j);
                    goto doneID;
                }
            }
        }

        // Should be impossible to not have an available ID
        SAFEASSERT( FALSE );
        pAdapt->STAInfo.ID = PORT_PRIORITY | 0xFF;

doneID:
        // Set this before releasing the lock
        pAdapt->bSTAInited = TRUE;

        NdisReleaseSpinLock( &gSTALock );

        // Start the adapter off enabled / disabled based on its media state
        // The enable / disable functions take locks
        if( pAdapt->MediaState == NdisMediaStateConnected )
        {
            BrdgSTAEnableAdapter( pAdapt );
        }
        else
        {
            SAFEASSERT( pAdapt->MediaState == NdisMediaStateDisconnected );
            BrdgSTADisableAdapter( pAdapt );
        }
    }
    else
    {
        SAFEASSERT( FALSE );
    }
}

VOID
BrdgSTADisableAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Disable STA operation on an adapter. Can be called multiple times
    (in conjunction with BrdgSTAEnableAdapter()) on a given adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bWereRoot, bTransmitTCN = FALSE;

    DBGPRINT(STA, ("DISABLING adapter %p\n", pAdapt));

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        bWereRoot = BrdgSTAWeAreRoot();

        BrdgSTABecomeDesignatedPort(pAdapt);
        BrdgSTASetAdapterState( pAdapt, Disabled );

        pAdapt->STAInfo.bTopologyChangeAck = FALSE;
        pAdapt->STAInfo.bConfigPending = FALSE;

        BrdgCancelTimer( &pAdapt->STAInfo.MessageAgeTimer );
        pAdapt->STAInfo.LastConfigTime = 0L;
        BrdgCancelTimer( &pAdapt->STAInfo.ForwardDelayTimer );

        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();

        if( BrdgSTAWeAreRoot() && (! bWereRoot) )
        {
            // We're the root bridge now
            DBGPRINT(STA, ("Became root through disabling of adapter %p\n", pAdapt));

            gMaxAge = DEFAULT_MAX_AGE;
            gHelloTime = DEFAULT_HELLO_TIME;
            gForwardDelay = DEFAULT_FORWARD_DELAY;

            bTransmitTCN = BrdgSTATopologyChangeDetected();
            BrdgCancelTimer( &gTopologyChangeNotificationTimer );

            // Don't do packet sends with a spin lock held
            NdisReleaseSpinLock( &gSTALock );

            if (BrdgFwdBridgingNetworks())
            {
                BrdgSTAGenerateConfigBPDUs();
                BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );
            }
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
        DBGPRINT(STA, ("BrdgSTADisableAdapter() called with uninitialized adapter; ignoring!\n"));
    }

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAShutdownAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    One-time teardown of an adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.
    ASSUMES the adapter has been taken out of the global list

--*/
{
    UINT                i;
    PORT_ID             ActualID = pAdapt->STAInfo.ID & (~PORT_PRIORITY);

    // Shouldn't be possible to go through a formal shutdown without
    // having completed initialization.
    SAFEASSERT( pAdapt->bSTAInited );

    // Shutdown all this adapter's timers
    BrdgShutdownTimer( &pAdapt->STAInfo.HoldTimer );
    BrdgShutdownTimer( &pAdapt->STAInfo.ForwardDelayTimer );
    BrdgShutdownTimer( &pAdapt->STAInfo.MessageAgeTimer );

    // Disable the adapter
    BrdgSTADisableAdapter( pAdapt );

    // Note that this adapter's port ID is now free
    NdisAcquireSpinLock( &gSTALock );
    i = (UINT)(ActualID / (sizeof(ULONG) * 8));
    SAFEASSERT( i < sizeof(gUsedPortIDs) / sizeof(ULONG) );
    gUsedPortIDs[i] &= ~(1 << (ActualID % (sizeof(ULONG) * 8)));
    NdisReleaseSpinLock( &gSTALock );

    // We're all done with this adapter structure
    SAFEASSERT( gRootAdapter != pAdapt );
    BrdgReleaseAdapter( pAdapt );
}

VOID
BrdgSTAReceivePacket(
    IN PADAPT           pAdapt,
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    Function to handle the processing of a packet received on the reserved
    STA multicast channel

Arguments:

    pAdapt              The adapter the packet was received on
    pPacket             The received packet

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    UCHAR               STAPacket[CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    ULONG               written;
    SHORT               dataLen;

    // Copy the data from the packet into our data buffer
    BrdgSTACopyFromPacketToBuffer( STAPacket, sizeof(STAPacket), &written, pPacket );

    if( written < TCN_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(STA, ("Undersize STA packet received on %p\n", pAdapt));
        return;
    }

    // The LLC header must identify the STA protocol
    if( (STAPacket[14] != 0x42) || (STAPacket[15] != 0x42) )
    {
        THROTTLED_DBGPRINT(STA, ("Packet with bad protocol type received on %p\n", pAdapt));
        return;
    }

    // Bytes 13 and 14 encode the length of data.
    dataLen = STAPacket[12] << 8;
    dataLen |= STAPacket[13];

    // The first two bytes are the protocol identifier and must be zero.
    // The third byte is the version identifier and must be zero.

    if( (STAPacket[_802_3_HEADER_SIZE] != 0) ||
        (STAPacket[_802_3_HEADER_SIZE + 1] != 0) ||
        (STAPacket[_802_3_HEADER_SIZE + 2] != 0) )
    {
        THROTTLED_DBGPRINT(STA, ("Invalid STA packet received\n"));
        return;
    }

    if( STAPacket[_802_3_HEADER_SIZE + 3] == 0x80 )
    {
        // The length of the frame with LLC header must be 7 bytes for a TCN BPDU
        if( dataLen != 7 )
        {
            THROTTLED_DBGPRINT(STA, ("Bad header size for TCN BPDU on %p\n", pAdapt));
            return;
        }

        // This is a Topology Change BPDU.
        BrdgSTAProcessTCNBPDU( pAdapt );
    }
    else if( STAPacket[_802_3_HEADER_SIZE + 3] == 0x00 )
    {
        CONFIG_BPDU         bpdu;

        if( written < CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE )
        {
            THROTTLED_DBGPRINT(STA, ("Undersize config BPDU received on %p\n", pAdapt));
            return;
        }

        // The length of the frame with LLC header must be 38 bytes for a Config BPDU
        if( dataLen != 38 )
        {
            THROTTLED_DBGPRINT(STA, ("Bad header size for Config BPDU on %p\n", pAdapt));
            return;
        }

        bpdu.Type = ConfigBPDU;

        // The high bit of byte 5 encodes the topology change acknowledge flag
        bpdu.bTopologyChangeAck = (BOOLEAN)((STAPacket[_802_3_HEADER_SIZE + 4] & 0x80) != 0);

        // The low bit of byte 5 encodes the topology change flag
        bpdu.bTopologyChange = (BOOLEAN)((STAPacket[_802_3_HEADER_SIZE + 4] & 0x01) != 0);

        // Bytes 6 thru 13 encode the root bridge ID
        bpdu.RootID[0] = STAPacket[_802_3_HEADER_SIZE + 5];
        bpdu.RootID[1] = STAPacket[_802_3_HEADER_SIZE + 6];
        bpdu.RootID[2] = STAPacket[_802_3_HEADER_SIZE + 7];
        bpdu.RootID[3] = STAPacket[_802_3_HEADER_SIZE + 8];
        bpdu.RootID[4] = STAPacket[_802_3_HEADER_SIZE + 9];
        bpdu.RootID[5] = STAPacket[_802_3_HEADER_SIZE + 10];
        bpdu.RootID[6] = STAPacket[_802_3_HEADER_SIZE + 11];
        bpdu.RootID[7] = STAPacket[_802_3_HEADER_SIZE + 12];

        // Bytes 14 thru 17 encode the root path cost
        bpdu.RootCost = 0;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 13] << 24;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 14] << 16;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 15] << 8;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 16];

        // Bytes 18 thru 15 encode the designated bridge ID
        bpdu.BridgeID[0] = STAPacket[_802_3_HEADER_SIZE + 17];
        bpdu.BridgeID[1] = STAPacket[_802_3_HEADER_SIZE + 18];
        bpdu.BridgeID[2] = STAPacket[_802_3_HEADER_SIZE + 19];
        bpdu.BridgeID[3] = STAPacket[_802_3_HEADER_SIZE + 20];
        bpdu.BridgeID[4] = STAPacket[_802_3_HEADER_SIZE + 21];
        bpdu.BridgeID[5] = STAPacket[_802_3_HEADER_SIZE + 22];
        bpdu.BridgeID[6] = STAPacket[_802_3_HEADER_SIZE + 23];
        bpdu.BridgeID[7] = STAPacket[_802_3_HEADER_SIZE + 24];

        // Bytes 26 and 27 encode the port identifier
        bpdu.PortID = 0;
        bpdu.PortID |= STAPacket[_802_3_HEADER_SIZE + 25] << 8;
        bpdu.PortID |= STAPacket[_802_3_HEADER_SIZE + 26];

        // Bytes 28 and 29 encode the message age
        bpdu.MessageAge = 0;
        bpdu.MessageAge |= STAPacket[_802_3_HEADER_SIZE + 27] << 8;
        bpdu.MessageAge |= STAPacket[_802_3_HEADER_SIZE + 28];

        // Bytes 30 and 31 encode the Max Age
        bpdu.MaxAge = 0;
        bpdu.MaxAge |= STAPacket[_802_3_HEADER_SIZE + 29] << 8;
        bpdu.MaxAge |= STAPacket[_802_3_HEADER_SIZE + 30];

        if( bpdu.MaxAge == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero MaxAge on adapter %p\n", pAdapt));
            return;
        }

        // Bytes 32 and 33 encode the Hello Time
        bpdu.HelloTime = 0;
        bpdu.HelloTime |= STAPacket[_802_3_HEADER_SIZE + 31] << 8;
        bpdu.HelloTime |= STAPacket[_802_3_HEADER_SIZE + 32];

        if( bpdu.HelloTime == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero HelloTime on adapter %p\n", pAdapt));
            return;
        }

        // Bytes 34 and 35 encode the forwarding delay
        bpdu.ForwardDelay = 0;
        bpdu.ForwardDelay |= STAPacket[_802_3_HEADER_SIZE + 33] << 8;
        bpdu.ForwardDelay |= STAPacket[_802_3_HEADER_SIZE + 34];

        if( bpdu.ForwardDelay == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero ForwardDelay on adapter %p\n", pAdapt));
            return;
        }

        BrdgSTAProcessConfigBPDU( pAdapt, &bpdu );
    }
    else
    {
        THROTTLED_DBGPRINT(STA, ("Packet with unrecognized BPDU type received on %p\n", pAdapt));
        return;
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgSTASetAdapterState(
    IN PADAPT               pAdapt,
    IN PORT_STATE           NewState
    )
/*++

Routine Description:

    Updates an adapter's forwarding state correctly

    This function is designed to be callable at high IRQL, so it defers
    the actual call to BrdgProtDoAdapterStateChange, which must be called
    at low IRQL.

Arguments:

    pAdapt              The adapter the packet was received on
    pPacket             The received packet

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/

{
    LOCK_STATE              LockState;
    BOOLEAN                 bailOut = FALSE;
    
    // Set the adapter's new state.
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE/*Write access*/, &LockState );
    if( pAdapt->State == NewState )
    {
        bailOut = TRUE;
    }
    else
    {
        pAdapt->State = NewState;
    }
    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

    // Don't do additional work if the adapter is already in the requested state
    if( bailOut )
    {
        return;
    }

#if DBG
    switch( NewState )
    {
    case Blocking:
        DBGPRINT(STA, ("Adapter %p becomes BLOCKING\n", pAdapt));
        break;

    case Listening:
        DBGPRINT(STA, ("Adapter %p becomes LISTENING\n", pAdapt));
        break;

    case Learning:
        DBGPRINT(STA, ("Adapter %p becomes LEARNING\n", pAdapt));
        break;

    case Forwarding:
        DBGPRINT(STA, ("Adapter %p becomes FORWARDING\n", pAdapt));
        break;
    }
#endif

    //
    // We will be hanging onto the adapter pointer in order to defer the call
    // to BrdgSTADeferredSetAdapterState.
    //
    if( BrdgAcquireAdapter(pAdapt) )
    {
        NDIS_STATUS     Status;

        // We need to defer the call to BrdgProtDoAdapterStateChange since it must run
        // at PASSIVE_IRQL
        Status = BrdgDeferFunction( BrdgSTADeferredSetAdapterState, pAdapt );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(STA, ("Unable to defer call to BrdgSTADeferredSetAdapterState\n", pAdapt));
            BrdgReleaseAdapter( pAdapt );
        }
        // else adapter will be released in BrdgSTADeferredSetAdapterState
    }
    else
    {
        DBGPRINT(STA, ("Adapter %p already shutting down when attempted to set adapter state\n", pAdapt));
    }
}

VOID
BrdgSTADeferredSetAdapterState(
    IN PVOID                Arg
    )
/*++

Routine Description:

    Deferred function from BrdgSTASetAdapterState; does housekeeping associated with
    changing an adapter's forwarding state.

    Must be called at PASSIVE

Arguments:

    Arg                     The adapter that needs updating

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    PADAPT                  pAdapt = (PADAPT)Arg;

    SAFEASSERT( CURRENT_IRQL == PASSIVE_LEVEL );

    BrdgProtDoAdapterStateChange( pAdapt );

    // Tell user-mode about the change
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyAdapterStateChange );

    // Adapter was acquired in BrdgSTASetAdapterState()
    BrdgReleaseAdapter( pAdapt );
}

VOID
BrdgSTATransmitConfigBPDUPacket(
    IN PADAPT                       pAdapt,
    PCONFIG_BPDU                    pbpdu
    )
/*++

Routine Description:

    Transmits a config BPDU packet on a particular adapter

Arguments:

    pAdapt                          The adapter to transmit on
    pbpdu                           A structure describing the BPDU information

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    UCHAR                           STAPacket[CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    NDIS_STATUS                     Status;

    if (BrdgProtGetAdapterCount() < 2)
    {
        return;
    }

    if (!BrdgFwdBridgingNetworks())
    {
        DBGPRINT(STA, ("Not Transmitting STA Packet (we're not bridging)\r\n"));
        return;
    }

    //
    // First encode the Ethernet header.
    //
    // Destination MAC address of packet must be STA multicast address
    STAPacket[0] = STA_MAC_ADDR[0];
    STAPacket[1] = STA_MAC_ADDR[1];
    STAPacket[2] = STA_MAC_ADDR[2];
    STAPacket[3] = STA_MAC_ADDR[3];
    STAPacket[4] = STA_MAC_ADDR[4];
    STAPacket[5] = STA_MAC_ADDR[5];

    // The the source MAC address to the adapter's own MAC address
    STAPacket[6] = pAdapt->MACAddr[0];
    STAPacket[7] = pAdapt->MACAddr[1];
    STAPacket[8] = pAdapt->MACAddr[2];
    STAPacket[9] = pAdapt->MACAddr[3];
    STAPacket[10] = pAdapt->MACAddr[4];
    STAPacket[11] = pAdapt->MACAddr[5];

    // Next two bytes are the size of the frame (38 bytes)
    STAPacket[12] = 0x00;
    STAPacket[13] = 0x26;

    // Next two bytes are the LLC DSAP and SSAP fields, set to 0x42 for STA
    STAPacket[14] = 0x42;
    STAPacket[15] = 0x42;

    // Next byte is the LLC frame type, 3 for unnumbered
    STAPacket[16] = 0x03;

    //
    // Now we are encoding the payload.
    //
    // First 4 bytes are the protocol identifier, version and BPDU type, all zero
    STAPacket[_802_3_HEADER_SIZE] = STAPacket[_802_3_HEADER_SIZE + 1] =
        STAPacket[_802_3_HEADER_SIZE + 2] = STAPacket[_802_3_HEADER_SIZE + 3] = 0x00;

    // Byte 5 encodes the Topology Change Ack flag in the high bit and the
    // Topology Change flag in the low bit.
    STAPacket[_802_3_HEADER_SIZE + 4] = 0;

    if( pbpdu->bTopologyChangeAck )
    {
        STAPacket[_802_3_HEADER_SIZE + 4] |= 0x80;
    }

    if( pbpdu->bTopologyChange )
    {
        STAPacket[_802_3_HEADER_SIZE + 4] |= 0x01;
    }

    // Bytes 6-13 encode the root bridge ID
    STAPacket[_802_3_HEADER_SIZE + 5] = pbpdu->RootID[0];
    STAPacket[_802_3_HEADER_SIZE + 6] = pbpdu->RootID[1];
    STAPacket[_802_3_HEADER_SIZE + 7] = pbpdu->RootID[2];
    STAPacket[_802_3_HEADER_SIZE + 8] = pbpdu->RootID[3];
    STAPacket[_802_3_HEADER_SIZE + 9] = pbpdu->RootID[4];
    STAPacket[_802_3_HEADER_SIZE + 10] = pbpdu->RootID[5];
    STAPacket[_802_3_HEADER_SIZE + 11] = pbpdu->RootID[6];
    STAPacket[_802_3_HEADER_SIZE + 12] = pbpdu->RootID[7];

    // Bytes 14 - 17 encode the root path cost
    STAPacket[_802_3_HEADER_SIZE + 13] = (UCHAR)(pbpdu->RootCost >> 24);
    STAPacket[_802_3_HEADER_SIZE + 14] = (UCHAR)(pbpdu->RootCost >> 16);
    STAPacket[_802_3_HEADER_SIZE + 15] = (UCHAR)(pbpdu->RootCost >> 8);
    STAPacket[_802_3_HEADER_SIZE + 16] = (UCHAR)(pbpdu->RootCost);

    // Bytes 18-25 encode the designated bridge ID
    STAPacket[_802_3_HEADER_SIZE + 17] = pbpdu->BridgeID[0];
    STAPacket[_802_3_HEADER_SIZE + 18] = pbpdu->BridgeID[1];
    STAPacket[_802_3_HEADER_SIZE + 19] = pbpdu->BridgeID[2];
    STAPacket[_802_3_HEADER_SIZE + 20] = pbpdu->BridgeID[3];
    STAPacket[_802_3_HEADER_SIZE + 21] = pbpdu->BridgeID[4];
    STAPacket[_802_3_HEADER_SIZE + 22] = pbpdu->BridgeID[5];
    STAPacket[_802_3_HEADER_SIZE + 23] = pbpdu->BridgeID[6];
    STAPacket[_802_3_HEADER_SIZE + 24] = pbpdu->BridgeID[7];

    // Bytes 26 and 27 encode the port identifier
    STAPacket[_802_3_HEADER_SIZE + 25] = (UCHAR)(pbpdu->PortID >> 8);
    STAPacket[_802_3_HEADER_SIZE + 26] = (UCHAR)(pbpdu->PortID);

    // Bytes 28 and 29 encode the message age
    STAPacket[_802_3_HEADER_SIZE + 27] = (UCHAR)(pbpdu->MessageAge >> 8);
    STAPacket[_802_3_HEADER_SIZE + 28] = (UCHAR)(pbpdu->MessageAge);

    // Bytes 30 and 31 encode the max age
    STAPacket[_802_3_HEADER_SIZE + 29] = (UCHAR)(pbpdu->MaxAge >> 8);
    STAPacket[_802_3_HEADER_SIZE + 30] = (UCHAR)(pbpdu->MaxAge);

    // Bytes 32 and 33 encode the hello time
    STAPacket[_802_3_HEADER_SIZE + 31] = (UCHAR)(pbpdu->HelloTime >> 8);
    STAPacket[_802_3_HEADER_SIZE + 32] = (UCHAR)(pbpdu->HelloTime);

    // Bytes 34 and 35 encode the forward delay
    STAPacket[_802_3_HEADER_SIZE + 33] = (UCHAR)(pbpdu->ForwardDelay >> 8);
    STAPacket[_802_3_HEADER_SIZE + 34] = (UCHAR)(pbpdu->ForwardDelay);

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pAdapt, STAPacket, sizeof(STAPacket) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(STA, ("BPDU packet send failed: %08x\n", Status));
    }
}

VOID
BrdgSTATransmitTCNPacket()
/*++

Routine Description:

    Transmits a Topology Change Notification BPDU packet on the root adapter

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has NOT acquired gSTALock

--*/
{
    UCHAR                           STAPacket[TCN_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    NDIS_STATUS                     Status;
    PADAPT                          pRootAdapter;
    BOOLEAN                         bAcquired;

    if (BrdgProtGetAdapterCount() < 2)
    {
        return;
    }

    if (!BrdgFwdBridgingNetworks())
    {
        DBGPRINT(STA, ("Not Transmitting STA Packet (we're not bridging)\r\n"));
        return;
    }

    NdisAcquireSpinLock( &gSTALock );

    // Freeze this value for the rest of the function
    pRootAdapter = gRootAdapter;

    if( pRootAdapter == NULL )
    {
        NdisReleaseSpinLock( &gSTALock );
        return;
    }

    bAcquired = BrdgAcquireAdapter( pRootAdapter );
    NdisReleaseSpinLock( &gSTALock );

    if( ! bAcquired )
    {
        SAFEASSERT( FALSE );
        return;
    }

    SAFEASSERT( gHaveID );

    //
    // First encode the Ethernet header.
    //
    // Destination MAC address of packet must be STA multicast address
    STAPacket[0] = STA_MAC_ADDR[0];
    STAPacket[1] = STA_MAC_ADDR[1];
    STAPacket[2] = STA_MAC_ADDR[2];
    STAPacket[3] = STA_MAC_ADDR[3];
    STAPacket[4] = STA_MAC_ADDR[4];
    STAPacket[5] = STA_MAC_ADDR[5];

    // Set the packet's MAC address to the adapter's own MAC address
    STAPacket[6] = pRootAdapter->MACAddr[0];
    STAPacket[7] = pRootAdapter->MACAddr[1];
    STAPacket[8] = pRootAdapter->MACAddr[2];
    STAPacket[9] = pRootAdapter->MACAddr[3];
    STAPacket[10] = pRootAdapter->MACAddr[4];
    STAPacket[11] = pRootAdapter->MACAddr[5];

    // Next two bytes are the size of the frame (7 bytes)
    STAPacket[12] = 0x00;
    STAPacket[13] = 0x07;

    // Next two bytes are the LLC DSAP and SSAP fields, set to 0x42 for STA
    STAPacket[14] = 0x42;
    STAPacket[15] = 0x42;

    // Next byte is the LLC frame type, 3 for unnumbered
    STAPacket[16] = 0x03;

    //
    // Now we are encoding the payload.
    //
    // First 3 bytes are the protocol identifier and protocol version number, all zero
    STAPacket[_802_3_HEADER_SIZE] = STAPacket[_802_3_HEADER_SIZE + 1] =
        STAPacket[_802_3_HEADER_SIZE + 2] = 0x00;

    // Byte 4 is the BPDU type, which is 0x80 for TCN.
    STAPacket[_802_3_HEADER_SIZE + 3] = 0x80;

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pRootAdapter, STAPacket, sizeof(STAPacket) );

    // We are done with the root adapter
    BrdgReleaseAdapter( pRootAdapter );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(STA, ("BPDU packet send failed: %08x\n", Status));
    }
}

VOID
BrdgSTACopyFromPacketToBuffer(
    OUT PUCHAR                      pPacketOut,
    IN ULONG                        BufferSize,
    OUT PULONG                      pWrittenCount,
    IN PNDIS_PACKET                 pPacketIn
    )
/*++

Routine Description:

    Copies data out of a packet descriptor into a flat buffer

Arguments:

    pPacketOut                      Data buffer to copy info
    BufferSize                      Size of pPacketOut
    pWrittenCount                   Number of bytes actually written
    pPacketIn                       Packet to copy from

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    PNDIS_BUFFER                    pBuf;

    *pWrittenCount = 0L;
    pBuf = BrdgBufPacketHeadBuffer(pPacketIn);

    while( pBuf != NULL )
    {
        PVOID                       pData;
        UINT                        Len;

        NdisQueryBufferSafe( pBuf, &pData, &Len, NormalPagePriority );

        if( pData != NULL )
        {
            ULONG                   BytesToWrite;

            if( *pWrittenCount + Len > BufferSize )
            {
                BytesToWrite = BufferSize - *pWrittenCount;
            }
            else
            {
                BytesToWrite = Len;
            }

            NdisMoveMemory( pPacketOut, pData, BytesToWrite );
            pPacketOut += BytesToWrite;
            *pWrittenCount += BytesToWrite;

            if( BytesToWrite < Len )
            {
                // We're full, so we're done.
                return;
            }
        }
        else
        {
            // Shouldn't happen
            SAFEASSERT( FALSE );
        }

        NdisGetNextBuffer( pBuf, &pBuf );
    }
}

VOID
BrdgSTATransmitConfig(
    PADAPT      pAdapt
    )
/*++

Routine Description:

    Transmits a config BPDU on a particular adapter. Collects appropriate
    information and calls BrdgSTATransmitConfigBPDUPacket().

Arguments:

    pAdapt                      The adapter to transmit on

Return Value:

    None

Locking Constraints:

    ASSUMES the caller DOES NOT hold gSTALock

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    if( BrdgTimerIsRunning( &pAdapt->STAInfo.HoldTimer ) )
    {
        // We have sent a config packet recently. Wait until the hold timer
        // expires before sending another one so we don't flood other bridges.
        pAdapt->STAInfo.bConfigPending = TRUE;

        NdisReleaseSpinLock( &gSTALock );
    }
    else
    {
        CONFIG_BPDU     bpdu;

        // Fill out the BPDU information structure
        bpdu.Type = ConfigBPDU;
        SAFEASSERT( gHaveID );
        BrdgSTACopyID( bpdu.RootID, gDesignatedRootID );
        bpdu.RootCost = gRootCost;
        BrdgSTACopyID( bpdu.BridgeID, gOurID );
        bpdu.PortID = pAdapt->STAInfo.ID;

        if( BrdgSTAWeAreRoot() )
        {
            // We are the root, so the age of this config information is zero.
            bpdu.MessageAge = 0;
        }
        else
        {
            // The MessageAge field is to be set to the age of the last received
            // config BPDU on the root port.
            if( (gRootAdapter != NULL) && BrdgAcquireAdapter(gRootAdapter) )
            {
                ULONG       CurrentTime, deltaTime;

                NdisGetSystemUpTime( &CurrentTime );

                // The message age timer should be running on the root adapter if
                // we are not root.
                SAFEASSERT( BrdgTimerIsRunning(&gRootAdapter->STAInfo.MessageAgeTimer) );
                SAFEASSERT( gRootAdapter->STAInfo.LastConfigTime != 0L );

                // The last parameter is the max acceptable delta. We should have
                // received the last piece of config information from the root no more
                // than gMaxAge STA units ago, since if it was longer than that, we
                // should have become root. Allow an additional second for processing.
                deltaTime = BrdgDeltaSafe( gRootAdapter->STAInfo.LastConfigTime, CurrentTime,
                                           (ULONG)(((gMaxAge * 1000) / 256) + 1000) );

                // STA times are in 1/256ths of a second.
                bpdu.MessageAge = (STA_TIME)((deltaTime * 256) / 1000);

                // MESSAGE_AGE_INCREMENT allows for the transmission time, etc.
                bpdu.MessageAge += MESSAGE_AGE_INCREMENT;

                BrdgReleaseAdapter(gRootAdapter);
            }
            else
            {
                // Why isn't there a root port if we're not root?
                SAFEASSERT( FALSE );
                bpdu.MessageAge = 0;
            }

        }

        bpdu.MaxAge = gMaxAge;
        bpdu.HelloTime = gHelloTime;
        bpdu.ForwardDelay = gForwardDelay;

        // Are we supposed to acknowledge a topology change signal?
        bpdu.bTopologyChangeAck = pAdapt->STAInfo.bTopologyChangeAck;

        // We just sent out the topology change ack if there was one to send
        pAdapt->STAInfo.bTopologyChangeAck = FALSE;

        bpdu.bTopologyChange = gTopologyChange;

        // Start the hold timer to make sure another BPDU isn't sent prematurely
        pAdapt->STAInfo.bConfigPending = FALSE;

        // Don't send a packet with the spin lock held
        NdisReleaseSpinLock( &gSTALock );

        // Send off the config BPDU
        BrdgSTATransmitConfigBPDUPacket( pAdapt, &bpdu );

        BrdgSetTimer( &pAdapt->STAInfo.HoldTimer, HOLD_TIMER_PERIOD, FALSE /*Not periodic*/ );
    }
}

BOOLEAN
BrdgSTASupersedesPortInfo(
    IN PADAPT               pAdapt,
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Determines whether a given bpdu's information supersedes the information
    already associated with a particular adapter

Arguments:

    pAdapt                  The adapter
    pbpdu                   Received BPDU information to examine

Return Value:

    TRUE if the given information supersedes (i.e., is better) than the information
    previously held by the adapter. FALSE otherwise.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    INT                     cmp;

    /*  The information advertised on a given link supersedes the existing information for that
        link if the following conditions hold (applied in order; TRUE at any step causes immediate
        success)

        (1) The advertised root has a lower ID than the previous root
        (2) The advertised root is the same as the previous root and the new cost-to-root is
            lower than the previous value
        (3) The root IDs and costs are the same, and the ID of the advertising bridge is
            lower than the previous value
        (4) The root ID, cost-to-root and bridge IDs are the same and the advertising bridge
            is not us
        (5) The root ID, cost-to-root, bridge IDs are the same, the bridge is us, and the
            advertised port number is lower than the previous value (this happens if we have
            more than one port on the same physical link and we see the advertisement from
            our other port).
    */

    // Compare the advertised root ID to the adapter's previous designated root ID
    cmp = BrdgSTABridgeIDCmp( pbpdu->RootID, pAdapt->STAInfo.DesignatedRootID );

    if( cmp == -1 )                                                             // (1)
    {
        return TRUE;
    }
    else if( cmp == 0 )
    {
        if( pbpdu->RootCost < pAdapt->STAInfo.DesignatedCost )                  // (2)
        {
            return TRUE;
        }
        else if( pbpdu->RootCost == pAdapt->STAInfo.DesignatedCost )
        {
            // Compare the advertised bridge ID to the previous designated bridge ID
            cmp = BrdgSTABridgeIDCmp( pbpdu->BridgeID, pAdapt->STAInfo.DesignatedBridgeID );

            if( cmp == -1 )
            {
                return TRUE;                                                    // (3)
            }
            else if( cmp == 0 )
            {
                SAFEASSERT( gHaveID );

                // Compare the advertised bridge ID to our own ID
                cmp = BrdgSTABridgeIDCmp( pbpdu->BridgeID, gOurID );

                if( cmp != 0 )
                {
                    return TRUE;                                                // (4)
                }
                else if( cmp == 0 )
                {
                    return (BOOLEAN)(pbpdu->PortID <= pAdapt->STAInfo.DesignatedPort); // (5)
                }
            }
        }
    }

    return FALSE;
}

VOID
BrdgSTARecordConfigInfo(
    IN PADAPT               pAdapt,
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Associates the information from a received BPDU with a particular adapter

Arguments:

    pAdapt                  The adapter
    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    ULONG                   msgAgeInMs = (pbpdu->MessageAge / 256) * 1000;

    // Update the port's information with the new data
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedRootID, pbpdu->RootID );
    pAdapt->STAInfo.DesignatedCost = pbpdu->RootCost;
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedBridgeID, pbpdu->BridgeID );
    pAdapt->STAInfo.DesignatedPort = pbpdu->PortID;

    // Start the message age timer. It is specified to expire after
    // gMaxAge - MessageAge STA time units.
    if( pbpdu->MessageAge < gMaxAge )
    {
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.MessageAgeTimer,
                                    gMaxAge - pbpdu->MessageAge, FALSE /*Not periodic*/ );
    }
    else
    {
        // How odd. The message was already too old. Start the timer so that it
        // will expire immediately.

        THROTTLED_DBGPRINT(STA, ("Received over-age BPDU (%i / %i) on adapter %p", pbpdu->MessageAge,
                            gMaxAge, pAdapt));

        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.MessageAgeTimer, 0, FALSE /*Not periodic*/ );
    }

    NdisGetSystemUpTime( &pAdapt->STAInfo.LastConfigTime );

    // Roll back by the age of the info we got.
    SAFEASSERT( msgAgeInMs < pAdapt->STAInfo.LastConfigTime );
    pAdapt->STAInfo.LastConfigTime -= msgAgeInMs;
}

VOID
BrdgSTARecordTimeoutInfo(
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Records timeout information conveyed by a BPDU received from the root bridge

Arguments:

    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    gMaxAge = pbpdu->MaxAge;
    gHelloTime = pbpdu->HelloTime;
    gForwardDelay = pbpdu->ForwardDelay;
    BrdgSTAUpdateTopologyChange( pbpdu->bTopologyChange );
}

VOID
BrdgSTAGenerateConfigBPDUs()
/*++

Routine Description:

    Sends configuration BPDUs out every designated port

Arguments:

    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT hold gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              Adapters[MAX_ADAPTERS];
    INT                 cmpID;
    PADAPT              pAdapt;
    UINT                numAdapters = 0, i;

    NdisAcquireSpinLock( &gSTALock );
    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( (pAdapt->bSTAInited) && (pAdapt->State != Disabled) )
        {
            cmpID = BrdgSTABridgeIDCmp( pAdapt->STAInfo.DesignatedBridgeID, gOurID );

            if( (cmpID == 0) && (pAdapt->STAInfo.ID == pAdapt->STAInfo.DesignatedPort) )
            {
                // This adapter is a designated port. We will send a config BPDU out it.
                BrdgAcquireAdapterInLock( pAdapt );
                Adapters[numAdapters] = pAdapt;
                numAdapters++;
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    NdisReleaseSpinLock( &gSTALock );

    // Send a BPDU out every adapter that we chose
    for( i = 0; i < numAdapters; i++ )
    {
        BrdgSTATransmitConfig(Adapters[i]);
        BrdgReleaseAdapter(Adapters[i]);
    }
}

VOID
BrdgSTARootSelection()
/*++

Routine Description:

    Examines the information associated with every bridge port to determine
    the root bridge ID and root port

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              pAdapt, pRootAdapt = NULL;
    INT                 cmp;

    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( (pAdapt->bSTAInited) &&  (pAdapt->State != Disabled) )
        {
            /*
                We consider the information advertised on each link to determine which port should
                be the new root port. If no link advertises sufficiently attractive information, we declare
                ourselves to be the root. A port is acceptable as the root port if all the following
                conditions hold:

                (1) The port receiving the advertisement must not be a designated port
                (2) The link's advertised root must have a lower ID than us
                (3) The link's advertised root ID must be lower than the advertised root ID on any other link
                (4) If the advertised root ID is the same as another advertised root, the cost-to-root
                    must be lower
                (5) If the root ID and cost are the same, the designated bridge on the port must have a
                    lower ID than the designated bridge on other ports (this chooses arbitrarily
                    between two bridges that can reach the root with the same cost)
                (6) If the root ID, cost-to-root and designated bridge IDs are the same, the designated
                    port must be less than on other ports (this happens if two links have the same
                    designated bridge)
                (7) If the root ID, cost-to-root, designated bridge ID and designated port IDs are all
                    the same, the port number of the port itself must be lower (this only happens if
                    we have more than one port onto the same physical link; we pick the lower-numbered
                    one as the root port)
            */

            cmp = BrdgSTABridgeIDCmp( pAdapt->STAInfo.DesignatedBridgeID, gOurID );

            if( (cmp != 0) || (pAdapt->STAInfo.ID != pAdapt->STAInfo.DesignatedPort) )          // (1)
            {
                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, gOurID);

                if( cmp == -1 )                                                                 // (2)
                {
                    BOOLEAN         betterRoot = FALSE;

                    if( pRootAdapt == NULL )
                    {
                        // Hadn't seen a root better than ourselves before now; take this one.
                        betterRoot = TRUE;
                    }
                    else
                    {
                        // Compare the advertised root ID to our previous best
                        cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, pRootAdapt->STAInfo.DesignatedRootID);

                        if( cmp == -1 )                                                         // (3)
                        {
                            betterRoot = TRUE;
                        }
                        else if( cmp == 0 )
                        {
                            PATH_COST       thisCost = pAdapt->STAInfo.DesignatedCost + pAdapt->STAInfo.PathCost,
                                            prevBestCost = pRootAdapt->STAInfo.DesignatedCost + pRootAdapt->STAInfo.PathCost;

                            if( thisCost < prevBestCost )
                            {
                                betterRoot = TRUE;                                              // (4)
                            }
                            else if( thisCost == prevBestCost )
                            {
                                // Compare the IDs of the designated bridge
                                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, pRootAdapt->STAInfo.DesignatedBridgeID);

                                if( cmp == -1 )
                                {
                                    betterRoot = TRUE;                                          // (5)
                                }
                                else if( cmp == 0 )
                                {
                                    if( pAdapt->STAInfo.DesignatedPort < pRootAdapt->STAInfo.DesignatedPort )
                                    {
                                        betterRoot = TRUE;                                      // (6)
                                    }
                                    else if( pAdapt->STAInfo.DesignatedPort == pRootAdapt->STAInfo.DesignatedPort )
                                    {
                                        if( pAdapt->STAInfo.ID < pRootAdapt->STAInfo.ID )
                                        {
                                            betterRoot = TRUE;                                  // (7)
                                        }
                                        else
                                        {
                                            // Sanity-check that the two adapters' IDs are different!
                                            SAFEASSERT( pAdapt->STAInfo.ID != pRootAdapt->STAInfo.ID );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if( betterRoot )
                    {
                        // We have a better root port.
                        pRootAdapt = pAdapt;
                    }
                }
            }
        }
    }

    if( pRootAdapt == NULL )
    {
        gRootAdapter = NULL;
        BrdgSTACopyID( gDesignatedRootID, gOurID );
        gRootCost = 0;
    }
    else
    {
        gRootAdapter = pRootAdapt;
        BrdgSTACopyID( gDesignatedRootID, pRootAdapt->STAInfo.DesignatedRootID );
        gRootCost = pRootAdapt->STAInfo.DesignatedCost + pRootAdapt->STAInfo.PathCost;
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

VOID
BrdgSTABecomeDesignatedPort(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Sets the information associated with an adapter to make it a designated port

Arguments:

    pAdapt              The adapter to make designated

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    SAFEASSERT( gHaveID );
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedRootID, gDesignatedRootID );
    pAdapt->STAInfo.DesignatedCost = gRootCost;
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedBridgeID, gOurID );
    pAdapt->STAInfo.DesignatedPort = pAdapt->STAInfo.ID;
}

VOID
BrdgSTADesignatedPortSelection()
/*++

Routine Description:

    Examines the information associated with each port to determine
    which should become designated ports

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              pAdapt;
    INT                 cmp;

    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( pAdapt->bSTAInited )
        {
            BOOLEAN         becomeDesignated = FALSE;

            /*  We consider each port to determine whether it should become a designated port
                (if it previously was not one). A port becomes a designated port if the
                following conditions hold:

                (1) The port is the link's designated port by advertised info
                (2) The link's previous designated root is not the correct root
                (3) Our cost-to-root is lower than the current cost advertised on the link
                (4) We have a same cost-to-root but a lower ID than the current designated
                    bridge on the link
                (5) We have the same cost-to-root and ID as the designated bridge on the link
                    but a lower port number (this only happens if we have two or more ports
                    on the same physical link)
            */

            // See if the link's designated bridge is already us
            cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID);

            if( (cmp == 0) && (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
            {
                becomeDesignated = TRUE;                                    // (1)
            }
            else
            {
                // Compare the link's advertised root to the one we believe is root
                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, gDesignatedRootID);

                if( cmp != 0 )
                {
                    becomeDesignated = TRUE;                                    // (2)
                }
                else if( gRootCost < pAdapt->STAInfo.DesignatedCost )
                {
                    becomeDesignated = TRUE;                                    // (3)
                }
                else if( gRootCost == pAdapt->STAInfo.DesignatedCost )
                {
                    // Compare the link's designated bridge to our own ID
                    cmp = BrdgSTABridgeIDCmp(gOurID, pAdapt->STAInfo.DesignatedBridgeID);

                    if( cmp == -1 )
                    {
                        becomeDesignated = TRUE;                                // (4)
                    }
                    else if( cmp == 0 )
                    {
                        if( pAdapt->STAInfo.ID < pAdapt->STAInfo.DesignatedPort )
                        {
                            becomeDesignated = TRUE;                            // (5)
                        }
                        else
                        {
                            // If this SAFEASSERT fires, we should have succeeded on test (1)
                            SAFEASSERT( pAdapt->STAInfo.ID > pAdapt->STAInfo.DesignatedPort );
                        }
                    }
                }
            }

            if( becomeDesignated )
            {
                BrdgSTABecomeDesignatedPort( pAdapt );
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

BOOLEAN
BrdgSTATopologyChangeDetected()
/*++

Routine Description:

    Takes appropriate action when a topology change is detected. If we are
    the root, this consists of setting the TopologyChange flag in future
    BPDUs until the expiry of the gTopologyChangeTimer. If we are not the
    root, this consists of sending a TCN BPDU periodically until it is
    acknowledged

Arguments:

    None

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN         rc = FALSE;

    if( BrdgSTAWeAreRoot() )
    {
        BrdgSTAUpdateTopologyChange( TRUE );
        BrdgSTASetTimerWithSTATime( &gTopologyChangeTimer, DEFAULT_MAX_AGE + DEFAULT_FORWARD_DELAY, FALSE /*Not periodic*/ );
    }
    else
    {
        rc = TRUE;
        BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    }

    gTopologyChangeDetected = TRUE;

    return rc;
}

VOID
BrdgSTAMakeForwarding(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Starts the process of putting an adapter in the forwarding state.

    Adapters must pass through the Listening and Learning states before entering
    the Forwarding state.

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    None

--*/
{
    if( pAdapt->State == Blocking )
    {
        BrdgSTASetAdapterState( pAdapt, Listening );
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.ForwardDelayTimer, gForwardDelay, FALSE /*Not periodic*/ );
    }
}

BOOLEAN
BrdgSTAMakeBlocking(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Puts an adapter in the blocking state

Arguments:

    pAdapt              The adapter

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN             rc = FALSE;

    if( pAdapt->State != Blocking )
    {
        if( (pAdapt->State == Forwarding) ||
            (pAdapt->State == Learning) )
        {
            rc = BrdgSTATopologyChangeDetected();
        }

        BrdgSTASetAdapterState( pAdapt, Blocking );
        BrdgCancelTimer( &pAdapt->STAInfo.ForwardDelayTimer );
    }

    return rc;
}

BOOLEAN
BrdgSTAPortStateSelection()
/*++

Routine Description:

    Examines all ports and puts them in an appropriate state

Arguments:

    None

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN             rc = FALSE;
    LOCK_STATE          LockState;
    PADAPT              pAdapt;

    SAFEASSERT( gHaveID );

    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( pAdapt->bSTAInited )
        {
            if( pAdapt == gRootAdapter )
            {
                pAdapt->STAInfo.bConfigPending = FALSE;
                pAdapt->STAInfo.bTopologyChangeAck = FALSE;
                BrdgSTAMakeForwarding( pAdapt );
            }
            else if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
                     (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
            {
                // This port is a designated port.
                BrdgCancelTimer( &pAdapt->STAInfo.MessageAgeTimer );
                pAdapt->STAInfo.LastConfigTime = 0L;
                BrdgSTAMakeForwarding( pAdapt );
            }
            else
            {
                pAdapt->STAInfo.bConfigPending = FALSE;
                pAdapt->STAInfo.bTopologyChangeAck = FALSE;
                rc = BrdgSTAMakeBlocking( pAdapt );
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    return rc;
}

VOID
BrdgSTATopologyChangeAcknowledged()
/*++

Routine Description:

    Called when we receive an acknowledgement from the root bridge that
    our topology change notification has been noted.

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTATopologyChangeAcknowledged\n"));
    gTopologyChangeDetected = FALSE;
    BrdgCancelTimer( &gTopologyChangeNotificationTimer );
}

VOID
BrdgSTAAcknowledgeTopologyChange(
    IN PADAPT       pAdapt
    )
/*++

Routine Description:

    Called when we are the root bridge to send a config BPDU acknowledging
    another bridge's topology change notification

Arguments:

    pAdapt          The adapter on which the TCN was received

Return Value:

    None

Locking Constraints:

    ASSUMES the caller DOES NOT have gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTAAcknowledgeTopologyChange\n"));
    pAdapt->STAInfo.bTopologyChangeAck = TRUE;
    BrdgSTATransmitConfig( pAdapt );
}

VOID
BrdgSTAProcessConfigBPDU(
    IN PADAPT       pAdapt,
    IN PCONFIG_BPDU pbpdu
    )
/*++

Routine Description:

    Processes received BPDU information

Arguments:

    pAdapt          The adapter on which the BPDU was received
    pbpdu           The received information

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    BOOLEAN         bWasRoot;

    NdisAcquireSpinLock( &gSTALock );

    bWasRoot = BrdgSTAWeAreRoot();

    if( BrdgSTASupersedesPortInfo(pAdapt, pbpdu) )
    {
        BOOLEAN     bTransmitTCN = FALSE;

        // The new information is better than what we had before. Use it.
        BrdgSTARecordConfigInfo(pAdapt, pbpdu);
        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();

        if( bWasRoot && (! BrdgSTAWeAreRoot()) )
        {
            // We used to be the root bridge but now we're not!
            DBGPRINT(STA, ("Saw superseding information that made us NOT root on adapter %p\n", pAdapt));

            BrdgCancelTimer( &gHelloTimer );

            if( gTopologyChangeDetected )
            {
                BrdgCancelTimer( &gTopologyChangeTimer );
                bTransmitTCN = TRUE;
                BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
            }
        }

        if( pAdapt == gRootAdapter )
        {
            // This is the root port. Heed config information from the root and pass along
            // its information.
            BrdgSTARecordTimeoutInfo( pbpdu );

            if( pbpdu->bTopologyChangeAck )
            {
                BrdgSTATopologyChangeAcknowledged();
            }

            // Don't send packets from inside the spin lock
            NdisReleaseSpinLock( &gSTALock );

            BrdgSTAGenerateConfigBPDUs();
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }

        if( bTransmitTCN )
        {
            BrdgSTATransmitTCNPacket();
        }
    }
    else
    {
        // The received information does not supersede our previous info
        SAFEASSERT( gHaveID );

        if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
            (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
        {
            NdisReleaseSpinLock( &gSTALock );

            // This is the designated port for this link, and the information we just received
            // is inferior to the information we already have. Reply by sending out our own info.
            BrdgSTATransmitConfig(pAdapt);
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }
    }
}

VOID
BrdgSTAProcessTCNBPDU(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Processes a received TopologyChangeNotification BPDU

Arguments:

    pAdapt          The adapter on which the TCN was received

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTAProcessTCNBPDU()\n"));
    SAFEASSERT( gHaveID );

    NdisAcquireSpinLock( &gSTALock );

    if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
        (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
    {
        BOOLEAN             bTransmitTCN = FALSE;

        // This is a designated port.
        bTransmitTCN = BrdgSTATopologyChangeDetected();
        NdisReleaseSpinLock( &gSTALock );

        if( bTransmitTCN )
        {
            BrdgSTATransmitTCNPacket();
        }

        BrdgSTAAcknowledgeTopologyChange(pAdapt);
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }
}

VOID
BrdgSTAHelloTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Hello Timer expires. Sends another Config BPDU.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    BrdgSTAGenerateConfigBPDUs();
}

VOID
BrdgSTAMessageAgeTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Message Age Timer expires. Recalculates STA information
    given the fact that no bridge is being heard on the given port anymore.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt;
    BOOLEAN             bWasRoot, bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    pAdapt = (PADAPT)Context;
    pAdapt->STAInfo.LastConfigTime = 0L;
    bWasRoot = BrdgSTAWeAreRoot();

    BrdgSTABecomeDesignatedPort(pAdapt);
    BrdgSTAConfigUpdate();
    bTransmitTCN = BrdgSTAPortStateSelection();

    if( BrdgSTAWeAreRoot() && (! bWasRoot) )
    {
        DBGPRINT(STA, ("Became root through message age timer expiry of %p\n", pAdapt));

        // We just became root.
        gMaxAge = DEFAULT_MAX_AGE;
        gHelloTime = DEFAULT_HELLO_TIME;
        gForwardDelay = DEFAULT_FORWARD_DELAY;

        bTransmitTCN = BrdgSTATopologyChangeDetected();
        BrdgCancelTimer( &gTopologyChangeNotificationTimer );

        NdisReleaseSpinLock( &gSTALock );

        BrdgSTAGenerateConfigBPDUs();
        BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE /*Periodic*/ );
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAForwardDelayTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Forward Delay Timer expires. Continues stepping an
    adapter through the process of becoming Forwarding.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt = (PADAPT)Context;
    BOOLEAN             bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    SAFEASSERT( gHaveID );

    if( pAdapt->State == Listening )
    {
        // Move to learning state
        BrdgSTASetAdapterState( pAdapt, Learning );
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.ForwardDelayTimer, gForwardDelay, FALSE /*Not periodic*/ );
    }
    else if( pAdapt->State == Learning )
    {
        LOCK_STATE      LockState;
        PADAPT          anAdapt;

        // Move to forwarding state
        BrdgSTASetAdapterState( pAdapt, Forwarding );

        // If we are the designated port on any link, we need to signal a topology change
        // notification.
        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read-only*/, &LockState );

        for( anAdapt = gAdapterList; anAdapt != NULL; anAdapt = anAdapt->Next )
        {
            if( anAdapt->bSTAInited )
            {
                if( BrdgSTABridgeIDCmp(anAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0 )
                {
                    bTransmitTCN = BrdgSTATopologyChangeDetected();
                }
            }
        }

        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTATopologyChangeNotificationTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Topology Change Notification Timer expires.
    Transmits another TCN packet.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    if (BrdgFwdBridgingNetworks())
    {
        BrdgSTATransmitTCNPacket();
        BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    }
}

VOID
BrdgSTATopologyChangeTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Topology Change Timer expires. Stops setting the TopologyChange
    flag in outbound Config BPDUs.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    NdisAcquireSpinLock( &gSTALock );
    gTopologyChangeDetected = FALSE;
    BrdgSTAUpdateTopologyChange( FALSE );
    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAHoldTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Hold Timer expires. Sends a Config BPDU.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt = (PADAPT)Context;

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->STAInfo.bConfigPending )
    {
        NdisReleaseSpinLock( &gSTALock );
        BrdgSTATransmitConfig( pAdapt );
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }
}

VOID
BrdgSTACancelTimersGPO()
{
    LOCK_STATE LockState;
    PADAPT pAdapt = NULL;

    //
    // We need to cancel the general STA timers.
    //
    BrdgCancelTimer( &gTopologyChangeTimer );
    BrdgCancelTimer( &gTopologyChangeNotificationTimer );
    BrdgCancelTimer( &gHelloTimer );

    //
    // And the individual HoldTimers and MessageAgeTimers
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read-only*/, &LockState );
    
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // This will only cancel the timer if it is running.
        BrdgCancelTimer(&pAdapt->STAInfo.HoldTimer);
        BrdgCancelTimer(&pAdapt->STAInfo.MessageAgeTimer);
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

VOID
BrdgSTARestartTimersGPO()
{
    BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );
}

VOID
BrdgSTAResetSTAInfoGPO()
{
    BOOLEAN PortSelection = FALSE;
    
    NdisAcquireSpinLock(&gSTALock);

    PortSelection = BrdgSTAPortStateSelection();

    // Release the spinlock before we send packets over the wire.
    NdisReleaseSpinLock(&gSTALock);

    BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    
    if (PortSelection)
    { 
       BrdgSTATransmitTCNPacket();
    }

    if (!BrdgSTAWeAreRoot())
    {
        // Set the timer on the root adapter to expire immediately, this will force us to re-determine
        // our state.
        BrdgSTASetTimerWithSTATime( &gRootAdapter->STAInfo.MessageAgeTimer, 0, FALSE /*Not periodic*/ );
    }
    else
    {
        BrdgSTAGenerateConfigBPDUs();
    }
    BrdgSTARestartTimersGPO();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgstad.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgstad.h

Abstract:

    Ethernet MAC level bridge.
    STA type and structure declarations file

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

//
// A number of type and constant definitions are in bioctl.h, which must be
// included before this file.
//

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

// STA information associated with every port (adapter)
typedef struct _STA_ADAPT_INFO
{
    // Unique ID for this port
    PORT_ID             ID;

    // Cost of this link
    ULONG               PathCost;

    // The bridge reported as root on this link
    UCHAR               DesignatedRootID[BRIDGE_ID_LEN];

    // The reported cost to reach the root on this link
    PATH_COST           DesignatedCost;

    // The designated bridge on this link
    UCHAR               DesignatedBridgeID[BRIDGE_ID_LEN];

    // The designated port on this link
    PORT_ID             DesignatedPort;

    // Topology Change Acknowledge for this link
    BOOLEAN             bTopologyChangeAck;

    // Whether a BPDU transmit was attempted while not allowed
    // because of the maximum inter-BPDU time enforcement
    BOOLEAN             bConfigPending;

    // Timer to age out the last received config information on this link
    BRIDGE_TIMER        MessageAgeTimer;

    // Timestamp of when the last config we received was generated
    // (this is gMaxAge - (time left on MessageAgeTimer) ms ago)
    // When the message age timer is not running, this is set to 0L.
    ULONG               LastConfigTime;

    // Timer for transitioning between port states
    BRIDGE_TIMER        ForwardDelayTimer;

    // Timer for preventing BPDUs from being transmitted too frequently
    BRIDGE_TIMER        HoldTimer;

} STA_ADAPT_INFO, *PSTA_ADAPT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgslist.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bdgslist.h

Abstract:

    Ethernet MAC level bridge
    Singly-linked list implementation

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/


//
// A singly-linked list with a length counter
//
typedef struct _BSINGLE_LIST_ENTRY
{
    struct _BSINGLE_LIST_ENTRY      *Next;
} BSINGLE_LIST_ENTRY, *PBSINGLE_LIST_ENTRY;

typedef struct _BSINGLE_LIST_HEAD
{
    PBSINGLE_LIST_ENTRY             Head;
    PBSINGLE_LIST_ENTRY             Tail;
    ULONG                           Length;
} BSINGLE_LIST_HEAD, *PBSINGLE_LIST_HEAD;

//
// Singly-linked list functions
//
__forceinline VOID
BrdgInitializeSingleList(
    PBSINGLE_LIST_HEAD      Head
    )
{
    Head->Head = Head->Tail = NULL;
    Head->Length = 0L;
}

__forceinline ULONG
BrdgQuerySingleListLength(
    PBSINGLE_LIST_HEAD      Head
    )
{
    return Head->Length;
}

__forceinline VOID
BrdgInsertHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry
    )
{
    Entry->Next = Head->Head;
    Head->Head = Entry;

    if( Head->Tail == NULL )
    {
        Head->Tail = Entry;
    }

    Head->Length++;
}

__forceinline VOID
BrdgInterlockedInsertHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry,
    PNDIS_SPIN_LOCK         Lock
    )
{
    NdisAcquireSpinLock( Lock );
    BrdgInsertHeadSingleList( Head, Entry );
    NdisReleaseSpinLock( Lock );
}

__forceinline VOID
BrdgInsertTailSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry
    )
{
    Entry->Next = NULL;

    if( Head->Tail != NULL )
    {
        Head->Tail->Next = Entry;
    }

    if( Head->Head == NULL )
    {
        Head->Head = Entry;
    }

    Head->Tail = Entry;
    Head->Length++;
}

__forceinline VOID
BrdgInterlockedInsertTailSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry,
    PNDIS_SPIN_LOCK         Lock
    )
{
    NdisAcquireSpinLock( Lock );
    BrdgInsertTailSingleList( Head, Entry );
    NdisReleaseSpinLock( Lock );
}

__forceinline PBSINGLE_LIST_ENTRY
BrdgRemoveHeadSingleList(
    PBSINGLE_LIST_HEAD      Head
    )
{
    PBSINGLE_LIST_ENTRY     Entry = Head->Head;

    if( Entry != NULL )
    {
        Head->Head = Entry->Next;

        if( Head->Tail == Entry )
        {
            Head->Tail = NULL;
        }

        Head->Length--;
    }

    return Entry;
}

__forceinline PBSINGLE_LIST_ENTRY
BrdgInterlockedRemoveHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PNDIS_SPIN_LOCK         Lock
    )
{
    PBSINGLE_LIST_ENTRY      Entry;

    NdisAcquireSpinLock( Lock );
    Entry = BrdgRemoveHeadSingleList( Head );
    NdisReleaseSpinLock( Lock );

    return Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgtbl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtbl.h

Abstract:

    Ethernet MAC level bridge.
    MAC Table section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/
    
// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// The MAC forwarding table
extern PHASH_TABLE                      gMACForwardingTable;

// Default age at which entries are removed from table
#define DEFAULT_MAX_TBL_AGE             (300 * 1000)        // 5 minutes in milliseconds

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

//
// These need to be exposed here to make the inlines below work.
// Pretend they're not here.
//

VOID
BrdgTableRefreshInsertEntry(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pData
    );

BOOLEAN
BrdgTblEntriesMatch(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pAdapt
    );

VOID
BrdgTblCopyEntries(
    PHASH_TABLE_ENTRY           pEntry,
    PUCHAR                      pDest
    );

VOID
BrdgTblNoteAddress(
    IN PUCHAR                   pAddr,
    IN PADAPT                   pAdapt
    );

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Changes the forwarding table timeout value.
//
__forceinline
VOID
BrdgTblSetTimeout(
    IN ULONG                    Timeout
    )
{
    DBGPRINT(FWD, ("Adopting a shorter table timeout value of %ims\n", Timeout));
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashChangeTableTimeout( gMACForwardingTable, Timeout );
}

//
// Sets the table timeout value back to its default
//
__forceinline
VOID
BrdgTblRevertTimeout()
{
    DBGPRINT(FWD, ("Reverting to default timeout value of %ims\n", DEFAULT_MAX_TBL_AGE));
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashChangeTableTimeout( gMACForwardingTable, DEFAULT_MAX_TBL_AGE );
}

//
// Removes all entries that reference the given adapter
//
__forceinline
VOID
BrdgTblScrubAdapter(
    IN PADAPT           pAdapt
    )
{
    DBGPRINT(FWD, ("Scrubbing adapter %p from the MAC table...\n", pAdapt));
    BrdgHashRemoveMatching( gMACForwardingTable, BrdgTblEntriesMatch, pAdapt );
}

//
// Copies all the MAC addresses that appear in the forwarding table that
// are associated with the given adapter to the given data buffer.
//
// The return value is the room necessary to hold all the data. If the
// return value is <= BufferLength, the buffer was sufficiently large
// to hold the data and it was all copied.
//
__forceinline
ULONG
BrdgTblReadTable(
    IN PADAPT                   pAdapt,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    )
{
    return BrdgHashCopyMatching( gMACForwardingTable, BrdgTblEntriesMatch, BrdgTblCopyEntries,
                                 ETH_LENGTH_OF_ADDRESS, pAdapt, pBuffer, BufferLength );
}

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTblDriverInit();

PADAPT
BrdgTblFindTargetAdapter(
    IN PUCHAR                   pAddr
    );

VOID
BrdgTblCleanup();

VOID
BrdgTblScrubAllAdapters();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgtbl.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtbl.c

Abstract:

    Ethernet MAC level bridge.
    MAC Table section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgtbl.h"

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Default age at which entries are removed from table
#define DEFAULT_MAX_TBL_AGE     (300 * 1000)        // 5 minutes in milliseconds

//
// Default cap on forwarding table size
//
#define DEFAULT_MAX_TBL_MEMORY  (500 * 1024)        // 500K in bytes

//
// Registry values that hold our config values
//
const PWCHAR                    gMaxTableMemoryParameterName = L"MaxTableMemory";

// Structure of a table entry
typedef struct _MAC_FWDTABLE_ENTRY
{

    HASH_TABLE_ENTRY            hte;
    PADAPT                      pAdapt;

} MAC_FWDTABLE_ENTRY, *PMAC_FWDTABLE_ENTRY;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// The MAC forwarding table
PHASH_TABLE                     gMACForwardingTable;

// Number of hash buckets (needs to be N^2 for the hash function to work)
#define NUM_HASH_BUCKETS        256

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

// These would all be inlines except that we have to pass pointers to them

//
// Our hash function for Ethernet addresses. Uses the lower bits of byte #4.
//
// This hash function requires NUM_HASH_BUCKETS buckets; don't change this
// without updating the number of hash buckets available.
//
ULONG
BrdgTblHashAddress(
    IN PUCHAR               pAddr
    )
{
    return *((pAddr)+ETH_LENGTH_OF_ADDRESS-2) & (NUM_HASH_BUCKETS-1);
}

//
// Returns TRUE if the pAdapt field in two entries match
//
BOOLEAN
BrdgTblEntriesMatch(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pAdapt
    )
{
    return (BOOLEAN)(((PMAC_FWDTABLE_ENTRY)pEntry)->pAdapt == (PADAPT)pAdapt);
}

//
// Copies the MAC address from a table entry to a data buffer.
//
VOID
BrdgTblCopyEntries(
    PHASH_TABLE_ENTRY           pEntry,
    PUCHAR                      pDest
    )
{
    PMAC_FWDTABLE_ENTRY         pMACEntry = (PMAC_FWDTABLE_ENTRY)pEntry;

    // The MAC address is the key. Copy it to the target buffer.
    ETH_COPY_NETWORK_ADDRESS( pDest, pMACEntry->hte.key );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgTblDriverInit()
/*++

Routine Description:

    Load-time initialization function

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS aborts driver load.

--*/
{
    NTSTATUS            NtStatus;
    ULONG               MaxMemory, MaxEntries;

    NtStatus = BrdgReadRegDWord( &gRegistryPath, gMaxTableMemoryParameterName, &MaxMemory );

    if( NtStatus != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to read MaxTableMemory value: %08x\n", NtStatus));
        MaxMemory = DEFAULT_MAX_TBL_MEMORY;
        DBGPRINT(GENERAL, ( "Using DEFAULT maximum memory of %i\n", MaxMemory ));
    }

    MaxEntries = MaxMemory / sizeof(MAC_FWDTABLE_ENTRY);
    DBGPRINT(GENERAL, ( "Forwarding table cap set at %i entries (%iK of memory)\n", MaxEntries, MaxMemory / 1024 ));

    gMACForwardingTable = BrdgHashCreateTable( BrdgTblHashAddress, NUM_HASH_BUCKETS, sizeof(MAC_FWDTABLE_ENTRY),
                                               MaxEntries, DEFAULT_MAX_TBL_AGE, DEFAULT_MAX_TBL_AGE,
                                               ETH_LENGTH_OF_ADDRESS );

    if( gMACForwardingTable == NULL )
    {
        DBGPRINT(FWD, ("FAILED TO ALLOCATE MAC TABLE!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

//
// Creates a new table entry associating the given MAC address with the given
// adapter, or refreshes an existing entry.
//
VOID
BrdgTblNoteAddress(
    IN PUCHAR                   pAddr,
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Creates a new table entry associating the given MAC address with the given
    adapter, or refreshes an existing entry.

Arguments:

    pAddr                       The MAC address to look up
    pAdapt                      The adapter to associate it with

Return Value:

    None

--*/
{
    PMAC_FWDTABLE_ENTRY         pEntry;
    BOOLEAN                     bIsNewEntry;
    LOCK_STATE                  LockState;

    // Refuse to record non-unicast addresses
    if( ETH_IS_MULTICAST(pAddr) )
    {
        THROTTLED_DBGPRINT(FWD, ("## BRIDGE ## Not recording multicast address in BrdgTblNoteAddress\n"));
        return;
    }

    pEntry = (PMAC_FWDTABLE_ENTRY)BrdgHashRefreshOrInsert( gMACForwardingTable, pAddr, &bIsNewEntry, &LockState);

    if( pEntry != NULL )
    {
        // Regardless of whether or not this is a new table entry or an existing one,
        // just cram in the adapter pointer with an interlocked instruction.
        InterlockedExchangePointer( &pEntry->pAdapt, pAdapt );

        // Since the function came back != NULL, we must release the table lock.
        NdisReleaseReadWriteLock( &gMACForwardingTable->tableLock, &LockState );
    }
}


PADAPT
BrdgTblFindTargetAdapter(
    IN PUCHAR                   pAddr
    )
/*++

Routine Description:

    Locates the adapter corresponding to a particular MAC address.

    If an adapter is found, this function returns a PADAPT pointer after
    having INCREMENTED THE REFCOUNT for that adapter. This is to ensure that
    the adapter is not unbound until the caller is done using it. The caller
    should be sure to decrement the PADAPT's refcount when it is done using
    the pointer.

Arguments:

    pAddr                       The MAC address to look up

Return Value:

    A pointer to the ADAPT structure describing the adapter associated with
    the given MAC address, with its refcount INCREMENTED, or NULL if an
    entry associating the given MAC address to an adapter was not found.

--*/
{
    PMAC_FWDTABLE_ENTRY         pEntry;
    LOCK_STATE                  LockState;
    PADAPT                      pAdapt = NULL;

    pEntry = (PMAC_FWDTABLE_ENTRY)BrdgHashFindEntry( gMACForwardingTable, pAddr, &LockState );

    if( pEntry != NULL )
    {
        // Read this once since it can be changed even while we hold the RW lock
        pAdapt = pEntry->pAdapt;
        SAFEASSERT( pAdapt != NULL );

        //
        // Increment this adapter's refcount while inside the RW lock for the table.
        // This lets us close a race condition window for unbinding the adapter;
        // the caller will hang on to the returned PADAPT after we return, leading
        // to problems if the adapter is unbound before our caller is done using
        // the PADAPT structure.
        //
        BrdgAcquireAdapterInLock( pAdapt );

        // Release the table lock
        NdisReleaseReadWriteLock( &gMACForwardingTable->tableLock, &LockState );
    }

    return pAdapt;
}

//
// This function cleans all the adapters from the tables (this is in the case of a GPO changing
// our bridging settings)
//

VOID
BrdgTblScrubAllAdapters()
{
    PADAPT                      pAdapt = NULL;
    LOCK_STATE                  LockStateMACTable;
    LOCK_STATE                  LockStateAdapterList;

    //
    // We don't want the table to be modified while we're doing this, and we also don't want an adapter
    // to go away while we're enumerating the list of adapters.
    //
    NdisAcquireReadWriteLock(&gMACForwardingTable->tableLock, FALSE /*Read Only*/, &LockStateMACTable);
    NdisAcquireReadWriteLock(&gAdapterListLock, FALSE /*Read Only*/, &LockStateAdapterList);

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Scrub adapter from the table.
        BrdgTblScrubAdapter(pAdapt);
    }

    NdisReleaseReadWriteLock(&gAdapterListLock, &LockStateAdapterList);
    NdisReleaseReadWriteLock(&gMACForwardingTable->tableLock, &LockStateMACTable);
}

VOID
BrdgTblCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashFreeHashTable( gMACForwardingTable );
    gMACForwardingTable = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgtdi.c ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.c

Abstract:

    Ethernet MAC level bridge.
    Tdi registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <tdikrnl.h>
#include <ntstatus.h>
#include <wchar.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgtdi.h"

#include "brdgsta.h"
#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdggpo.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

BRDG_TDI_GLOBALS g_BrdgTdiGlobals;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

#define MAX_GUID_LEN        39
#define MAX_IP4_STRING_LEN  17

const WCHAR TcpipAdaptersKey[]    = {L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters"};

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTdiPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    );

VOID
BrdgTdiBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
    );

VOID
BrdgTdiAddAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );

VOID
BrdgTdiDelAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );

VOID
TSPrintTaAddress(PTA_ADDRESS  pTaAddress);

// ===========================================================================
//
// INLINE FUNCTIONS
//
// ===========================================================================

__forceinline
BOOLEAN
IsLower(WCHAR c)
{
    return (BOOLEAN)((c >= L'a') && (c <= 'z'));
}

__forceinline
BOOLEAN
IsDigit(WCHAR c)
{
    return (BOOLEAN)((c >= L'0') && (c <= '9'));
}

__forceinline
BOOLEAN
IsXDigit(WCHAR c)
{
    return (BOOLEAN)( ((c >= L'0') && (c <= '9')) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F')) );
}

// ===========================================================================
//
// BRIDGE TDI IMPLEMENTATION
//
// ===========================================================================

VOID
BrdgTdiInitializeClientInterface(
    IN PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo,
    IN PUNICODE_STRING            ClientName
    )
{
    DBGPRINT(TDI, ("BrdgTdiInitializeClientInterface\r\n"));
    ClientInterfaceInfo->MajorTdiVersion = TDI_CURRENT_MAJOR_VERSION;
    ClientInterfaceInfo->MinorTdiVersion = TDI_CURRENT_MINOR_VERSION;
    ClientInterfaceInfo->ClientName = ClientName;
    ClientInterfaceInfo->PnPPowerHandler = BrdgTdiPnpPowerHandler;
    ClientInterfaceInfo->BindingHandler = BrdgTdiBindingHandler;
    ClientInterfaceInfo->AddAddressHandlerV2 = BrdgTdiAddAddressHandler;
    ClientInterfaceInfo->DelAddressHandlerV2 = BrdgTdiDelAddressHandler;
}

NTSTATUS
BrdgTdiDriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            status;

    DBGPRINT(TDI, ("BrdgTdiDriverInit\r\n"));
    
    RtlInitUnicodeString(&g_BrdgTdiGlobals.ClientName, L"Bridge");

    RtlZeroMemory(&g_BrdgTdiGlobals.ciiBridge, sizeof(TDI_CLIENT_INTERFACE_INFO));

    BrdgTdiInitializeClientInterface(&g_BrdgTdiGlobals.ciiBridge, &g_BrdgTdiGlobals.ClientName);

    status = BrdgGpoDriverInit();
        
    if (!NT_SUCCESS(status))
    {
        BrdgTdiCleanup();
    }
    else
    {
        status = TdiRegisterPnPHandlers(&g_BrdgTdiGlobals.ciiBridge, 
                                        sizeof(TDI_CLIENT_INTERFACE_INFO), 
                                        &g_BrdgTdiGlobals.hBindingHandle);
    }

    return status;
}

VOID
BrdgTdiCleanup()
/*++

Routine Description:

    Driver shutdown cleanup

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS status;
    
    status = TdiDeregisterPnPHandlers(g_BrdgTdiGlobals.hBindingHandle);
    
    SAFEASSERT(NT_SUCCESS(status));

    BrdgGpoCleanup();
}

NTSTATUS
BrdgTdiPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    )
{
    DBGPRINT(TDI, ("BrdgTdiPnpPowerHandler\r\n"));
    return STATUS_SUCCESS;
}

VOID
BrdgTdiBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
    )
{
    DBGPRINT(TDI, ("BrdgTdiBindingHandler\r\n"));
}

VOID
BrdgTdiAddAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:
    
    Called if a new address is added.

Arguments:

    Address     -   New address that has been added.
    
    DeviceName  -   The device that this is changing for.

    Context     -   Not something we're interested in for now.

Return Value:

    None.

--*/

{
    DBGPRINT(TDI, ("BrdgTdiAddAddressHandler\r\n"));

    if ((Address->AddressType == TDI_ADDRESS_TYPE_IP))
    {
        if (NULL != DeviceName->Buffer)
        {
            //
            // Find the start of the GUID
            //
            PWCHAR DeviceId = wcsrchr(DeviceName->Buffer, L'{');
            if (NULL != DeviceId)
            {
                NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
                LPWSTR          AdapterPath;

                AdapterPath = ExAllocatePoolWithTag(PagedPool, 
                                                    (wcslen(TcpipAdaptersKey) + 1 + wcslen(DeviceId) + 1) * sizeof(WCHAR), 
                                                    'gdrB');
                if (AdapterPath)
                {
                    OBJECT_ATTRIBUTES   ObAttr;
                    UNICODE_STRING      Adapter;
                    HANDLE              hKey;
                    
                    wcscpy(AdapterPath, TcpipAdaptersKey);
                    wcscat(AdapterPath, L"\\");
                    wcscat(AdapterPath, DeviceId);

                    RtlInitUnicodeString(&Adapter, AdapterPath);

                    InitializeObjectAttributes( &ObAttr,
                                                &Adapter,
                                                OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
                                                NULL,
                                                NULL);

                    status = ZwOpenKey(&hKey,
                                       KEY_READ,
                                       &ObAttr);

                    if (NT_SUCCESS(status))
                    {
                        ZwClose(hKey);
                        //
                        // This is a valid adapter on this machine.  Otherwise it could be an NdisAdapter etc and
                        // we don't pay attention to these for group policies.
                        //
                        BrdgGpoNewAddressNotification(DeviceId);
                    }

                    ExFreePool(AdapterPath);
                }
            }
        }
#if DBG
        TSPrintTaAddress(Address);
#endif
    }
}

VOID
BrdgTdiDelAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    )
{
    DBGPRINT(TDI, ("BrdgTdiDelAddressHandler\r\n"));
    //
    // We don't delete the current list of networks that we have since we need them to make
    // an accurate assessment on whether to follow the GPO.  Instead, the AddAddressHandler
    // will simply update the existing network address for the ID's and if this results in 
    // a different network then we'll change the bridge mode.
    //
}

VOID
TSPrintTaAddress(PTA_ADDRESS  pTaAddress)
{
   BOOLEAN  fShowAddress = TRUE;

   DbgPrint("AddressType = TDI_ADDRESS_TYPE_");
   switch (pTaAddress->AddressType)
   {
      case TDI_ADDRESS_TYPE_UNSPEC:
         DbgPrint("UNSPEC\n");
         break;
      case TDI_ADDRESS_TYPE_UNIX:
         DbgPrint("UNIX\n");
         break;

      case TDI_ADDRESS_TYPE_IP:
         DbgPrint("IP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP   pTdiAddressIp = (PTDI_ADDRESS_IP)pTaAddress->Address;
            PUCHAR            pucTemp       = (PUCHAR)&pTdiAddressIp->in_addr;
            DbgPrint("sin_port = 0x%04x\n"
                        "in_addr  = %u.%u.%u.%u\n",
                         pTdiAddressIp->sin_port,
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3]);
         }
         break;

      case TDI_ADDRESS_TYPE_IMPLINK:
         DbgPrint("IMPLINK\n");
         break;
      case TDI_ADDRESS_TYPE_PUP:
         DbgPrint("PUP\n");
         break;
      case TDI_ADDRESS_TYPE_CHAOS:
         DbgPrint("CHAOS\n");
         break;

      case TDI_ADDRESS_TYPE_IPX:
         DbgPrint("IPX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IPX  pTdiAddressIpx = (PTDI_ADDRESS_IPX)pTaAddress->Address;
            DbgPrint("NetworkAddress = 0x%08x\n"
                        "NodeAddress    = %u.%u.%u.%u.%u.%u\n"
                        "Socket         = 0x%04x\n",
                         pTdiAddressIpx->NetworkAddress,
                         pTdiAddressIpx->NodeAddress[0],
                         pTdiAddressIpx->NodeAddress[1],
                         pTdiAddressIpx->NodeAddress[2],
                         pTdiAddressIpx->NodeAddress[3],
                         pTdiAddressIpx->NodeAddress[4],
                         pTdiAddressIpx->NodeAddress[5],
                         pTdiAddressIpx->Socket);
                  
         }
         break;

      case TDI_ADDRESS_TYPE_NBS:
         DbgPrint("NBS\n");
         break;
      case TDI_ADDRESS_TYPE_ECMA:
         DbgPrint("ECMA\n");
         break;
      case TDI_ADDRESS_TYPE_DATAKIT:
         DbgPrint("DATAKIT\n");
         break;
      case TDI_ADDRESS_TYPE_CCITT:
         DbgPrint("CCITT\n");
         break;
      case TDI_ADDRESS_TYPE_SNA:
         DbgPrint("SNA\n");
         break;
      case TDI_ADDRESS_TYPE_DECnet:
         DbgPrint("DECnet\n");
         break;
      case TDI_ADDRESS_TYPE_DLI:
         DbgPrint("DLI\n");
         break;
      case TDI_ADDRESS_TYPE_LAT:
         DbgPrint("LAT\n");
         break;
      case TDI_ADDRESS_TYPE_HYLINK:
         DbgPrint("HYLINK\n");
         break;

      case TDI_ADDRESS_TYPE_APPLETALK:
         DbgPrint("APPLETALK\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_APPLETALK  pTdiAddressAppleTalk = (PTDI_ADDRESS_APPLETALK)pTaAddress->Address;

            DbgPrint("Network = 0x%04x\n"
                        "Node    = 0x%02x\n"
                        "Socket  = 0x%02x\n",
                         pTdiAddressAppleTalk->Network,
                         pTdiAddressAppleTalk->Node,
                         pTdiAddressAppleTalk->Socket);
         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS:
         DbgPrint("NETBIOS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS pTdiAddressNetbios = (PTDI_ADDRESS_NETBIOS)pTaAddress->Address;
            UCHAR                pucName[17];

            //
            // make sure we have a zero-terminated name to print...
            //
            RtlCopyMemory(pucName, pTdiAddressNetbios->NetbiosName, 16);
            pucName[16] = 0;
            DbgPrint("NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_");
            switch (pTdiAddressNetbios->NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DbgPrint("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DbgPrint("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DbgPrint("QUICK_GROUP\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetbios->NetbiosNameType);
                  break;
            }
            DbgPrint("NetbiosName = %s\n", pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_8022:
         DbgPrint("8022\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_8022    pTdiAddress8022 = (PTDI_ADDRESS_8022)pTaAddress->Address;
            
            DbgPrint("Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
                         pTdiAddress8022->MACAddress[0],
                         pTdiAddress8022->MACAddress[1],
                         pTdiAddress8022->MACAddress[2],
                         pTdiAddress8022->MACAddress[3],
                         pTdiAddress8022->MACAddress[4],
                         pTdiAddress8022->MACAddress[5]);

         }
         break;

      case TDI_ADDRESS_TYPE_OSI_TSAP:
         DbgPrint("OSI_TSAP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_OSI_TSAP   pTdiAddressOsiTsap = (PTDI_ADDRESS_OSI_TSAP)pTaAddress->Address;
            ULONG                   ulSelectorLength;
            ULONG                   ulAddressLength;
            PUCHAR                  pucTemp = pTdiAddressOsiTsap->tp_addr;

            DbgPrint("TpAddrType = ISO_");
            switch (pTdiAddressOsiTsap->tp_addr_type)
            {
               case ISO_HIERARCHICAL:
                  DbgPrint("HIERARCHICAL\n");
                  ulSelectorLength = pTdiAddressOsiTsap->tp_tsel_len;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               case ISO_NON_HIERARCHICAL:
                  DbgPrint("NON_HIERARCHICAL\n");
                  ulSelectorLength = 0;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n",
                               pTdiAddressOsiTsap->tp_addr_type);
                  ulSelectorLength = 0;
                  ulAddressLength  = 0;
                  break;
            }
            if (ulSelectorLength)
            {
               ULONG    ulCount;

               DbgPrint("TransportSelector:  ");
               for (ulCount = 0; ulCount < ulSelectorLength; ulCount++)
               {
                  DbgPrint("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DbgPrint("\n");
            }
            if (ulAddressLength)
            {
               ULONG    ulCount;

               DbgPrint("TransportAddress:  ");
               for (ulCount = 0; ulCount < ulAddressLength; ulCount++)
               {
                  DbgPrint("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DbgPrint("\n");
            }
         }
         break;

      case TDI_ADDRESS_TYPE_NETONE:
         DbgPrint("NETONE\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETONE  pTdiAddressNetone = (PTDI_ADDRESS_NETONE)pTaAddress->Address;
            UCHAR                pucName[21];

            //
            // make sure have 0-terminated name
            //
            RtlCopyMemory(pucName,
                          pTdiAddressNetone->NetoneName,
                          20);
            pucName[20] = 0;
            DbgPrint("NetoneNameType = TDI_ADDRESS_NETONE_TYPE_");
            switch (pTdiAddressNetone->NetoneNameType)
            {
               case TDI_ADDRESS_NETONE_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETONE_TYPE_ROTORED:
                  DbgPrint("ROTORED\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetone->NetoneNameType);
                  break;
            }
            DbgPrint("NetoneName = %s\n",
                         pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_VNS:
         DbgPrint("VNS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_VNS  pTdiAddressVns = (PTDI_ADDRESS_VNS)pTaAddress->Address;

            DbgPrint("NetAddress:  %02x-%02x-%02x-%02x\n",
                         pTdiAddressVns->net_address[0],
                         pTdiAddressVns->net_address[1],
                         pTdiAddressVns->net_address[2],
                         pTdiAddressVns->net_address[3]);
            DbgPrint("SubnetAddr:  %02x-%02x\n"
                        "Port:        %02x-%02x\n"
                        "Hops:        %u\n",
                         pTdiAddressVns->subnet_addr[0],
                         pTdiAddressVns->subnet_addr[1],
                         pTdiAddressVns->port[0],
                         pTdiAddressVns->port[1],
                         pTdiAddressVns->hops);


         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS_EX:
         DbgPrint("NETBIOS_EX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS_EX pTdiAddressNetbiosEx = (PTDI_ADDRESS_NETBIOS_EX)pTaAddress->Address;
            UCHAR                   pucEndpointName[17];
            UCHAR                   pucNetbiosName[17];

            //
            // make sure we have zero-terminated names to print...
            //
            RtlCopyMemory(pucEndpointName,
                          pTdiAddressNetbiosEx->EndpointName,
                          16);
            pucEndpointName[16] = 0;
            RtlCopyMemory(pucNetbiosName, 
                          pTdiAddressNetbiosEx->NetbiosAddress.NetbiosName, 
                          16);
            pucNetbiosName[16] = 0;

            DbgPrint("EndpointName    = %s\n"
                        "NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_",
                         pucEndpointName);

            switch (pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DbgPrint("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DbgPrint("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DbgPrint("QUICK_GROUP\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType);
                  break;
            }
            DbgPrint("NetbiosName = %s\n", pucNetbiosName);
         }
         break;

      case TDI_ADDRESS_TYPE_IP6:
         DbgPrint("IPv6\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP6  pTdiAddressIp6 = (PTDI_ADDRESS_IP6)pTaAddress->Address;
            PUCHAR            pucTemp        = (PUCHAR)&pTdiAddressIp6->sin6_addr;

            DbgPrint("SinPort6 = 0x%04x\n"
                        "FlowInfo = 0x%08x\n"
                        "ScopeId  = 0x%08x\n",
                         pTdiAddressIp6->sin6_port,
                         pTdiAddressIp6->sin6_flowinfo,
                         pTdiAddressIp6->sin6_scope_id);

            DbgPrint("In6_addr = %x%02x:%x%02x:%x%02x:%x%02x:",
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3],
                         pucTemp[4], pucTemp[5],
                         pucTemp[6], pucTemp[7]);
            DbgPrint("%x%02x:%x%02x:%x%02x:%x%02x\n",
                         pucTemp[8],  pucTemp[9],
                         pucTemp[10], pucTemp[11],
                         pucTemp[12], pucTemp[13],
                         pucTemp[14], pucTemp[15]);
         }
         break;

      default:
         DbgPrint("UNKNOWN [0x%08x]\n", pTaAddress->AddressType);
         break;
   }

   if (fShowAddress)
   {
      PUCHAR    pucTemp = pTaAddress->Address;
      ULONG     ulCount;

      DbgPrint("AddressLength = %d\n"
                  "Address       = ",
                   pTaAddress->AddressLength);

      for (ulCount = 0; ulCount < pTaAddress->AddressLength; ulCount++)
      {
         DbgPrint("%02x ", *pucTemp);
         pucTemp++;
      }

      DbgPrint("\n");
   }
}

NTSTATUS
BrdgTdiIpv4StringToAddress(
    IN LPWSTR String,
    IN BOOLEAN Strict,
    OUT LPWSTR *Terminator,
    OUT in_addr *Addr)

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives a pointer to the structure to fill in with
        a suitable binary representation of the Internet address given. 

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    ULONG val, n;
    LONG base;
    WCHAR c;
    ULONG parts[4], *pp = parts;
    BOOLEAN sawDigit;

again:
    //
    // We must see at least one digit for address to be valid.
    //
    sawDigit = FALSE; 

    //
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*String == L'0') 
    {
        String++;
        if (IsDigit(*String)) 
        {
            base = 8;
        } else if (*String == L'x' || *String == L'X') 
        {
            base = 16;
            String++;
        } else 
        {
            //
            // It is still decimal but we saw the digit
            // and it was 0.
            //
            sawDigit = TRUE;
        }
    }
    if (Strict && (base != 10)) 
    {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    do
    {
        ULONG newVal;
        
        c = *String;
        
        if (IsDigit(c) && ((c - L'0') < base)) {
            newVal = (val * base) + (c - L'0');
        } else if ((base == 16) && IsXDigit(c)) {
            newVal = (val << 4) + (c + 10 - (IsLower(c) ? L'a' : L'A'));
        } else {
            break;
        }

        //
        // Protect from overflow
        //
        if (newVal < val) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        String++;
        sawDigit = TRUE;
        val = newVal;
    } while (c != L'\0');

    if (*String == L'.')
    {
        //
        // Internet format:
        //      a.b.c.d
        //      a.b.c   (with c treated as 16-bits)
        //      a.b     (with b treated as 24 bits)
        //
        if (pp >= parts + 3) 
        {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        *pp++ = val, String++;

        //
        // Check if we saw at least one digit.
        //
        if (!sawDigit) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }

        goto again;
    } while (c != L'\0');

    //
    // Check if we saw at least one digit.
    //
    if (!sawDigit) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    *pp++ = val;

    //
    // Concoct the address according to
    // the number of parts specified.
    //
    n = (ULONG)(pp - parts);
    if (Strict && (n != 4)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    switch ((int) n) {

    case 1:                         /* a -- 32 bits */
        val = parts[0];
        break;

    case 2:                         /* a.b -- 8.24 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:                         /* a.b.c -- 8.8.16 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
        break;

    case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xff) || (parts[3] > 0xff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    val = RtlUlongByteSwap(val);
    *Terminator = String;
    Addr->s_addr = val;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgtdi.h ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.h

Abstract:

    Ethernet MAC level bridge.
    Tdi registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/


// ===========================================================================
//
// TYPES
//
// ===========================================================================

typedef struct _BRDG_TDI_GLOBALS
{
    UNICODE_STRING              ClientName;
    TDI_CLIENT_INTERFACE_INFO   ciiBridge;
    HANDLE                      hBindingHandle;
} BRDG_TDI_GLOBALS, *PBRDG_TDI_GLOBALS;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTdiDriverInit();

VOID
BrdgTdiCleanup();

typedef struct _in_addr {
    union {
        struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { USHORT s_w1,s_w2; } S_un_w;
        ULONG S_addr;
    } S_un;
} in_addr;

NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength);



#define s_addr  S_un.S_addr

BOOLEAN IsLower(WCHAR c);
BOOLEAN IsDigit(WCHAR c);
BOOLEAN IsXDigit(WCHAR c);

NTSTATUS
BrdgTdiIpv4StringToAddress(
    IN LPWSTR String,
    IN BOOLEAN Strict,
    OUT LPWSTR *Terminator,
    OUT in_addr *Addr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgtimr.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtimr.h

Abstract:

    Ethernet MAC level bridge.
    Timer implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    November  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================
                            
// Bridge timer function definition
typedef VOID (*PBRIDGE_TIMER_FUNC)(PVOID);

typedef struct _BRIDGE_TIMER
{
    NDIS_TIMER              Timer;                  // The actual timer
    NDIS_EVENT              Event;                  // Only used during final shutdown, and even then,
                                                    // only if normal cancellation of the timer fails.

    // Lock protects bShuttingDown, bRunning, bCanceled, bRecurring and bInterval.
    NDIS_SPIN_LOCK          Lock;
    BOOLEAN                 bShuttingDown;          // TRUE if the timer is being shut down for good
    BOOLEAN                 bRunning;               // Whether the timer is currently running
    BOOLEAN                 bCanceled;              // Whether the timer is being canceled
    BOOLEAN                 bRecurring;             // Whether the timer is recurrant
    UINT                    Interval;               // Timer interval (for use if bRecurring == TRUE)

    // These fields do not change once the timer is initialized
    PBRIDGE_TIMER_FUNC      pFunc;                  // The timer function
    PVOID                   data;                   // Data to pass to pFunc
} BRIDGE_TIMER, *PBRIDGE_TIMER;


// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgInitializeTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN PBRIDGE_TIMER_FUNC   pFunc,
    IN PVOID                data
    );
VOID
BrdgSetTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN UINT                 interval,
    IN BOOLEAN              bRecurring
    );

VOID
BrdgShutdownTimer(
    IN PBRIDGE_TIMER        pTimer
    );
VOID
BrdgCancelTimer(
    IN PBRIDGE_TIMER        pTimer
    );


// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Returns whether a timer is currently running
//
__forceinline
BOOLEAN
BrdgTimerIsRunning(
    IN PBRIDGE_TIMER            pTimer
    )
{
    return pTimer->bRunning;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgwref.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgwait.c

Abstract:

    Ethernet MAC level bridge.
    WAIT_REFCOUNT implementation

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgInitializeWaitRef(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bResettable
    )
/*++

Routine Description:

    Initializes a wait-refcount

Arguments:

    pRefcount           The wait-refcount to initialize

Return Value:

    none

--*/
{
    NdisInitializeEvent(&pRefcount->Event);
    pRefcount->Refcount = 0L;
    pRefcount->state = WaitRefEnabled;
    pRefcount->bResettable = bResettable;
    NdisAllocateSpinLock( &pRefcount->lock );

    // The event starts life signaled since the refcount starts at zero
    NdisSetEvent(&pRefcount->Event);
}

BOOLEAN
BrdgIncrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Increments (acquires) a wait-refcount

Arguments:

    pRefcount           The wait-refcount to acquire

Return Value:

    TRUE if the wait-refcount was successfully acquired, FALSE otherwise (this can happen
    if the wait-refcount has been shut down)

--*/
{
    BOOLEAN     bSuccess;
    LONG        Scratch = 0L;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        SAFEASSERT( pRefcount->Refcount >= 0L );
        Scratch = ++pRefcount->Refcount;
        bSuccess = TRUE;
    }
    else
    {
        // The wait-refcount isn't enabled.
        SAFEASSERT( (pRefcount->state == WaitRefShutdown) ||
                    (pRefcount->state == WaitRefShuttingDown) );
        bSuccess = FALSE;
    }

    if( bSuccess && (Scratch == 1L) )
    {
        // We incremented from zero. Reset the event.
        NdisResetEvent( &pRefcount->Event );
    }

    NdisReleaseSpinLock( &pRefcount->lock );

    return bSuccess;
}

VOID
BrdgReincrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Re-increments a wait-refcount. This is guaranteed to succeed.

    It is only legal to use this if the caller has already acquired the
    wait-refcount (i.e., it is guaranteed that the refcount is > 0).

    CALLING THIS WITHOUT HAVING FIRST ACQUIRED THE WAIT-REFCOUNT WITH
    BrdgIncrementWaitRef IS A GREAT WAY TO SCREW UP YOUR CODE!

Arguments:

    pRefcount           The wait-refcount to re-acquire

Return Value:

    none

--*/
{
    LONG        Scratch;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );
    SAFEASSERT( (pRefcount->state == WaitRefEnabled) ||
                (pRefcount->state == WaitRefShuttingDown) );
    SAFEASSERT( pRefcount->Refcount >= 0L );
    Scratch = ++pRefcount->Refcount;
    NdisReleaseSpinLock( &pRefcount->lock );

    // Should be impossible for us to have incremented from zero to one
    SAFEASSERT( Scratch >= 2L );
}

VOID
BrdgDecrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Decrements (releases) a previously incremented (acquired) wait-refcount.

Arguments:

    pRefcount           The wait-refcount to decrement

Return Value:

    none

--*/
{
    LONG        Scratch;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );
    SAFEASSERT( (pRefcount->state == WaitRefEnabled) ||
                (pRefcount->state == WaitRefShuttingDown) );
    Scratch = --pRefcount->Refcount;
    SAFEASSERT( Scratch >= 0L );

    if( Scratch == 0L )
    {
        // Signal anyone waiting for the refount to go to zero
        NdisSetEvent( &pRefcount->Event );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}

VOID
BrdgBlockWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Puts the wait-refcount in the shutting-down state, making it impossible
    for the refcount to be incremented anymore.

    This can be used to block further acquires of the wait-refcount in
    advance of the shutdown process. Because shutting down the wait-refcount
    involves waiting for it to hit zero, this can be called at high IRQL to
    prevent further acquires of the wait-refcount in advance of a low-IRQL
    call to BrdgShutdownWaitRef().

Arguments:

    pRefcount           The wait-refcount to block

Return Value:

    none

--*/
{
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        pRefcount->state = WaitRefShuttingDown;
    }
    else
    {
        // Do nothing; the wait-refcount is already
        // shutting down or is already shut down.
        SAFEASSERT( (pRefcount->state == WaitRefShutdown) ||
                    (pRefcount->state == WaitRefShuttingDown) );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}

BOOLEAN
BrdgShutdownWaitRefInternal(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bRequireBlockedState
    )
/*++

Routine Description:

    Blocks new acquisitions of the wait-refcount and waits for the
    number of consumers to go to zero. If TRUE is returned, the caller
    can free any resources protected by the wait-refcount

Arguments:

    pRefcount               The wait-refcount to shut down

    bRequireBlockedState    TRUE means the shutdown attempt will fail if
                                the wait-refcount isn't in the shutting-down
                                state

Return Value:

    TRUE if the wait-refcount was shut down

    FALSE indicates that either the wait-refcount was reset or that
    another thread of execution had already shut down the wait-refcount.
    In both cases, the shared resources protected by the wait-refcount
    should NOT be freed.

--*/
{
    BOOLEAN         bSuccess;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        if( bRequireBlockedState )
        {
            // Caller was expecting the refcount to be shutting
            // down. It must have been reset. That had better
            // be OK!
            SAFEASSERT( pRefcount->bResettable );
            bSuccess = FALSE;
        }
        else
        {
            // Caller doesn't require that the refcount be
            // shutting down. Transition to the shutting-down
            // state.
            pRefcount->state = WaitRefShuttingDown;
            bSuccess = TRUE;
        }
    }
    else if( pRefcount->state == WaitRefShutdown )
    {
        // Someone else already shut down the waitref.
        // This always means failure.
        SAFEASSERT( pRefcount->Refcount == 0L );
        bSuccess = FALSE;
    }
    else
    {
        // The refcount is already shutting down.
        // This is always goodness.
        SAFEASSERT( pRefcount->state == WaitRefShuttingDown );
        bSuccess = TRUE;
    }

    NdisReleaseSpinLock( &pRefcount->lock );

    if( bSuccess )
    {
        // Wait for all consumers to be done
        NdisWaitEvent( &pRefcount->Event, 0/*Wait forever*/ );

        NdisAcquireSpinLock( &pRefcount->lock );

        if( pRefcount->state == WaitRefEnabled )
        {
            // Someone reactivated us while we were sleeping.
            SAFEASSERT( pRefcount->bResettable );
            bSuccess = FALSE;
        }
        else if( pRefcount->state == WaitRefShutdown )
        {
            // Someone else shut us down while we were sleeping.
            SAFEASSERT( pRefcount->Refcount == 0L );
            bSuccess = FALSE;
        }
        else
        {
            if( pRefcount->Refcount == 0L )
            {
                // We completed the shutdown.
                pRefcount->state = WaitRefShutdown;
                bSuccess = TRUE;
            }
            else
            {
                // The waitref must have been reactivated and
                // shut down again while we were asleep!
                SAFEASSERT( pRefcount->bResettable );
                bSuccess = FALSE;
            }
        }

        NdisReleaseSpinLock( &pRefcount->lock );
    }

    return bSuccess;
}

BOOLEAN
BrdgShutdownWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    return BrdgShutdownWaitRefInternal( pRefcount, FALSE );
}

BOOLEAN
BrdgShutdownBlockedWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    return BrdgShutdownWaitRefInternal( pRefcount, TRUE );
}

VOID
BrdgResetWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Re-enables a wait-refcount. Safe to call in any refcount
    state; if the refcount is shut down, this will re-enable it.
    If the refcount is in the middle of shutting down, this
    will flag it to be re-enabled if the code shutting down the
    waitref is using BrdgShutdownOrResetWaitRef().

Arguments:

    pRefcount           The wait-refcount

Return Value:

    none

--*/
{
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefShutdown )
    {
        // The wait-refcount is completely shut down. We
        // can reactivate it.
        SAFEASSERT( pRefcount->Refcount == 0L );
        pRefcount->state = WaitRefEnabled;
    }
    else if( pRefcount->state == WaitRefShuttingDown )
    {
        if( pRefcount->bResettable )
        {
            // Re-enable. The call to BrdgShutdownWaitRef()
            // or BrdgShutdownBlockedWaitRef() will return
            // FALSE.
            pRefcount->state = WaitRefEnabled;
        }
        else
        {
            // Not allowed to reset this refcount when
            // in the middle of shutting down
            SAFEASSERT( FALSE );
        }
    }
    else
    {
        // The wait-refcount is already enabled
        SAFEASSERT( pRefcount->state == WaitRefEnabled );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\brdgwref.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgwait.h

Abstract:

    Ethernet MAC level bridge
    WAIT_REFCOUNT implementation

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

//
// Structure for a refcount that can be waited against (when waiting for 0)
//

typedef enum
{
    WaitRefEnabled = 0,
    WaitRefShuttingDown,
    WaitRefShutdown
} WAIT_REFCOUNT_STATE;

typedef struct _WAIT_REFCOUNT
{
    LONG                    Refcount;               // The refcount
    NDIS_EVENT              Event;                  // Signaled when RefCount hits 0
    WAIT_REFCOUNT_STATE     state;                  // Current state
    BOOLEAN                 bResettable;            // TRUE if it's OK to reset this
                                                    // refcount when state == WaitRefShuttingDown
    NDIS_SPIN_LOCK          lock;                   // Protects fields above

} WAIT_REFCOUNT, *PWAIT_REFCOUNT;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgInitializeWaitRef(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bResettable
    );

BOOLEAN
BrdgIncrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgReincrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgDecrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgBlockWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

BOOLEAN
BrdgShutdownBlockedWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

BOOLEAN
BrdgShutdownWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

//
// Use when it should be impossible for two or more threads of
// execution to simultaneously shut down your waitref.
//
__inline
VOID
BrdgShutdownWaitRefOnce(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    BOOLEAN bSuccess = FALSE;
    
    bSuccess = BrdgShutdownWaitRef( pRefcount );
    SAFEASSERT( bSuccess );
}

VOID
BrdgResetWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnappprt.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P P P R T . C P P
//
//  Contents:   CHNetAppProtocol Implementation
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// ATL methods
//

HRESULT
CHNetAppProtocol::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrProtocol) SysFreeString(m_bstrProtocol);

    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetAppProtocol::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProtocol);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    //
    // Read and cache our builtin value
    //

    hr = GetBooleanValue(
            pwcoInstance,
            c_wszBuiltIn,
            &m_fBuiltIn
            );

    //
    // Store the path to the object
    //

    if (S_OK == hr)
    {
        hr = GetWmiPathFromObject(pwcoInstance, &m_bstrProtocol);
    }

    if (S_OK == hr)
    {
        m_piwsHomenet = piwsNamespace;
        m_piwsHomenet->AddRef();
    }

    return hr;
}

//
// IHNetApplicationProtocol methods
//

STDMETHODIMP
CHNetAppProtocol::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppszwName = NULL;

        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Read the name property from our instance
        //

        hr = pwcoProtocol->Get(
                c_wszName,
                NULL,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate memory for the return string
        //

        *ppszwName = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                       * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwName)
        {
            wcscpy(*ppszwName, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetName(
    OLECHAR *pszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (NULL == pszwName)
    {
        hr = E_INVALIDARG;
    }

    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Wrap the passed-in string in a BSTR and a variant
        //

        VariantInit(&vt);
        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(pszwName);
        if (NULL == V_BSTR(&vt))
        {
            hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr)
        {
            //
            // Set the property on the instance
            //

            hr = pwcoProtocol->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetOutgoingIPProtocol(
    UCHAR *pucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pucProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszOutgoingIPProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        *pucProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetOutgoingIPProtocol(
    UCHAR ucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == ucProtocol)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BSTR bstrWQL;
        USHORT usPort;
        
        //
        // Make sure this change doesn't result in a duplicate
        //

        bstrWQL = SysAllocString(c_wszWQL);

        if (NULL != bstrWQL)
        {
            hr = GetOutgoingPort(&usPort);

            if (S_OK == hr)
            {
                if (ApplicationProtocolExists(
                        m_piwsHomenet,
                        bstrWQL,
                        usPort,
                        ucProtocol
                        ))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
                }
            }
            
            SysFreeString(bstrWQL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        VariantInit(&vt);
        V_VT(&vt) = VT_UI1;
        V_UI1(&vt) = ucProtocol;

        hr = pwcoProtocol->Put(
                c_wszOutgoingIPProtocol,
                0,
                &vt,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );         
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetOutgoingPort(
    USHORT *pusPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszOutgoingPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetOutgoingPort(
    USHORT usPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BSTR bstrWQL;
        UCHAR ucProtocol;
        
        //
        // Make sure this change doesn't result in a duplicate
        //

        bstrWQL = SysAllocString(c_wszWQL);

        if (NULL != bstrWQL)
        {
            hr = GetOutgoingIPProtocol(&ucProtocol);

            if (S_OK == hr)
            {
                if (ApplicationProtocolExists(
                        m_piwsHomenet,
                        bstrWQL,
                        usPort,
                        ucProtocol
                        ))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
                }
            }
            
            SysFreeString(bstrWQL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }
    
    if (S_OK == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        VariantInit(&vt);
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = usPort;

        hr = pwcoProtocol->Put(
                c_wszOutgoingPort,
                0,
                &vt,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetResponseRanges(
    USHORT *puscResponses,
    HNET_RESPONSE_RANGE *prgResponseRange[]
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    USHORT usResponses;
    VARIANT vt;
    IUnknown **rgUnknown;
    IWbemClassObject *pObj;

    if (NULL != prgResponseRange)
    {
        *prgResponseRange = NULL;

        if (NULL != puscResponses)
        {
            *puscResponses = 0;
        }
        else
        {
            hr = E_POINTER;
        }
    }
    else
    {
        hr = E_POINTER;
    }
    
    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Get the number of response ranges
        //

        hr = pwcoProtocol->Get(
                c_wszResponseCount,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI uses V_I4 for it's uint16 type
            //
            _ASSERT(VT_I4 == V_VT(&vt));

            usResponses = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Allocate enough memory for the output array.
            //

            *prgResponseRange
                = reinterpret_cast<HNET_RESPONSE_RANGE*>(
                    CoTaskMemAlloc(usResponses * sizeof(HNET_RESPONSE_RANGE))
                    );

            if (NULL == *prgResponseRange)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Retrieve the response array
            //

            hr = pwcoProtocol->Get(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Process the array: for each element, QI for IWbemClassObject
        // and copy the range data into the return struct
        //

        _ASSERT((VT_ARRAY | VT_UNKNOWN) == V_VT(&vt));

        hr = SafeArrayAccessData(
                V_ARRAY(&vt),
                reinterpret_cast<void**>(&rgUnknown)
                );

        if (S_OK == hr)
        {
            for (USHORT i = 0; i < usResponses; i++)
            {
                hr = rgUnknown[i]->QueryInterface(
                        IID_PPV_ARG(IWbemClassObject, &pObj)
                        );

                _ASSERT(S_OK == hr);

                hr = CopyResponseInstanceToStruct(
                        pObj,
                        &(*prgResponseRange)[i]
                        );

                pObj->Release();

                if (FAILED(hr))
                {
                    break;
                }
            }

            SafeArrayUnaccessData(V_ARRAY(&vt));
        }

        VariantClear(&vt);
    }

    if (S_OK == hr)
    {
        *puscResponses = usResponses;
    }
    else if (prgResponseRange && *prgResponseRange)
    {
        CoTaskMemFree(*prgResponseRange);
        *prgResponseRange = NULL;
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetResponseRanges(
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponseRange[]
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == uscResponses || NULL == rgResponseRange)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        VariantInit(&vt);
        V_VT(&vt) = VT_ARRAY | VT_UNKNOWN;
        
        hr = ConvertResponseRangeArrayToInstanceSafearray(
                m_piwsHomenet,
                uscResponses,
                rgResponseRange,
                &V_ARRAY(&vt)
                );
                
        if (SUCCEEDED(hr))
        {
            //
            // Put the array and count properties
            //

            hr = pwcoProtocol->Put(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // WMI uses V_I4 for it's uint16 type
                //
                
                V_VT(&vt) = VT_I4;
                V_I4(&vt) = uscResponses;

                hr = pwcoProtocol->Put(
                        c_wszResponseCount,
                        0,
                        &vt,
                        NULL
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance back to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetBuiltIn(
    BOOLEAN *pfBuiltIn
    )

{
    HRESULT hr = S_OK;

    if (NULL != pfBuiltIn)
    {
        *pfBuiltIn = m_fBuiltIn;
    }
    else
    {
        hr = E_POINTER;
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetEnabled(
    BOOLEAN *pfEnabled
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;

    if (NULL == pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoProtocol,
                c_wszEnabled,
                pfEnabled
                );

        pwcoProtocol->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetEnabled(
    BOOLEAN fEnable
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;

    hr = GetProtocolObject(&pwcoProtocol);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoProtocol,
                c_wszEnabled,
                fEnable
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Notify service of update.
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
    }
    
    return hr;

}

STDMETHODIMP
CHNetAppProtocol::Delete()

{
    HRESULT hr = S_OK;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't delete builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProtocol,
                0,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            UpdateService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
        }
    }

    return hr;
}

HRESULT
CHNetAppProtocol::GetProtocolObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProtocol,
                ppwcoInstance
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1 -DMPR50=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=pch.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj

RCOPTIONS=-N
UMTYPE=windows
ATL_VER=30
USE_STATIC_ATL=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\bridge.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.c

Abstract:

    Ethernet MAC level bridge.

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#include <tdikrnl.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgbuf.h"
#include "brdgtbl.h"
#include "brdgfwd.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"
#include "brdgtdi.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Our driver object
PDRIVER_OBJECT          gDriverObject;

// Our registry path
UNICODE_STRING          gRegistryPath;

// Size of the allocated memory at gRegistryPath->Buffer
ULONG                   gRegistryPathBufferSize;

// Whether we're in the process of shutting down (non-zero means true)
LONG                    gShuttingDown = 0L;

// Whether we successfully initialized each subsystem
BOOLEAN                 gInitedSTA = FALSE;
BOOLEAN                 gInitedControl = FALSE;
BOOLEAN                 gInitedTbl = FALSE;
BOOLEAN                 gInitedBuf = FALSE;
BOOLEAN                 gInitedFwd = FALSE;
BOOLEAN                 gInitedProt = FALSE;
BOOLEAN                 gInitedMini = FALSE;
BOOLEAN                 gInitedComp = FALSE;
BOOLEAN                 gInitedTdiGpo = FALSE;

extern BOOLEAN          gBridging;
const PWCHAR            gDisableForwarding = L"DisableForwarding";


#if DBG
// Support for optional "soft asserts"
BOOLEAN                 gSoftAssert = FALSE;

// Fields used for printing current date and time in DBGPRINT
LARGE_INTEGER           gTime;
const LARGE_INTEGER     gCorrection = { 0xAC5ED800, 0x3A }; // 7 hours in 100-nanoseconds
TIME_FIELDS             gTimeFields;

// Used for throttling debug messages that risk overloading the debugger console
ULONG                   gLastThrottledPrint = 0L;

// Spew flags
ULONG                   gSpewFlags = 0L;

// Name of registry value that holds the spew flags settings
const PWCHAR            gDebugFlagRegValueName = L"DebugFlags";

// Used to bypass Tdi/Gpo code if it's breaking on startup.
BOOLEAN                 gGpoTesting = TRUE;
#endif

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Structure for deferring a function call
typedef struct _DEFER_REC
{
    NDIS_WORK_ITEM      nwi;
    VOID                (*pFunc)(PVOID);            // The function to defer
} DEFER_REC, *PDEFER_REC;


// ===========================================================================
//
// LOCAL PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT          pDeviceObject,
    IN  PIRP                    pIrp
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

NTSTATUS
BrdgAllocateBuffers(
    VOID
    );

VOID
BrdgDeferredShutdown(
    PVOID           pUnused
    );

VOID
BrdgDoShutdown(
    VOID
    );

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgDeferredFunction(
    IN PNDIS_WORK_ITEM          pNwi,
    IN PVOID                    arg
    )
/*++

Routine Description:

    NDIS worker function for deferring a function call

Arguments:

    pNwi                    Structure describing the function to call
    arg                     Argument to pass to the deferred function

Return Value:

    None

--*/
{
    PDEFER_REC                  pdr = (PDEFER_REC)pNwi;

    // Call the originally supplied function
    (*pdr->pFunc)(arg);

    // Release the memory used to store the work item
    NdisFreeMemory( pdr, sizeof(DEFER_REC), 0 );
}

NDIS_STATUS
BrdgDeferFunction(
    VOID            (*pFunc)(PVOID),
    PVOID           arg
    )
/*++

Routine Description:

    Defers the indicated function, calling it at low IRQL with the indicated argument.

Arguments:

    pFunc           The function to call later
    arg             The argument to pass it when it is called

Return Value:

    Status of the attempt to defer the function

--*/
{
    PDEFER_REC                  pdr;
    NDIS_STATUS                 Status;

    Status = NdisAllocateMemoryWithTag( &pdr, sizeof(DEFER_REC), 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Allocation failed in BrdgDeferFunction(): %08x\n", Status));
        return Status;
    }

    SAFEASSERT( pdr != NULL );

    pdr->pFunc = pFunc;

    NdisInitializeWorkItem( &pdr->nwi, BrdgDeferredFunction, arg );

    Status = NdisScheduleWorkItem( &pdr->nwi );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pdr, sizeof(DEFER_REC), 0 );
    }

    return Status;
}


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     pRegistryPath
    )
/*++

Routine Description:

    Main driver entry point. Called at driver load time

Arguments:

    DriverObject            Our driver
    RegistryPath            A reg key where we can keep parameters

Return Value:

    Status of our initialization. A status != STATUS_SUCCESS aborts the
    driver load and we don't get called again.

    Each component is responsible for logging any error that causes the
    driver load to fail.

--*/
{
    NTSTATUS                Status;
    NDIS_STATUS             NdisStatus;
    PUCHAR                  pRegistryPathCopy;

    DBGPRINT(GENERAL, ("DriverEntry\n"));

    // Remember our driver object pointer
    gDriverObject = DriverObject;

    do
    {
        ULONG               ulDisableForwarding = 0L;
        // Make a copy of our registry path
        pRegistryPathCopy = NULL;
        gRegistryPathBufferSize = pRegistryPath->Length + sizeof(WCHAR);
        NdisStatus = NdisAllocateMemoryWithTag( &pRegistryPathCopy, gRegistryPathBufferSize, 'gdrB' );

        if( (NdisStatus != NDIS_STATUS_SUCCESS) || (pRegistryPathCopy == NULL) )
        {
            DBGPRINT(GENERAL, ("Unable to allocate memory for saving the registry path: %08x\n", NdisStatus));
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0, 0, NULL, 0L, NULL );
            Status = NdisStatus;

            // Make the structure valid even though we failed the malloc
            RtlInitUnicodeString( &gRegistryPath, NULL );
            gRegistryPathBufferSize = 0L;
            break;
        }

        // Copy the registry name
        NdisMoveMemory( pRegistryPathCopy, pRegistryPath->Buffer, pRegistryPath->Length );

        // Make sure it's NULL-terminated
        *((PWCHAR)(pRegistryPathCopy + pRegistryPath->Length)) = UNICODE_NULL;

        // Make the UNICODE_STRING structure point to the string
        RtlInitUnicodeString( &gRegistryPath, (PWCHAR)pRegistryPathCopy );

        // Set our debug flags
#if DBG
        BrdgReadRegDWord(&gRegistryPath, gDebugFlagRegValueName, &gSpewFlags);
#endif

        // Initialize the STA part of the driver
        Status = BrdgSTADriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize STA functionality: %08x\n", Status));
            break;
        }

        gInitedSTA = TRUE;

        // Initialize the control part of the driver
        Status = BrdgCtlDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize user-mode control functionality: %08x\n", Status));
            break;
        }

        gInitedControl = TRUE;

        // Initialize the MAC table part of our driver
        Status = BrdgTblDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize MAC table functionality: %08x\n", Status));
            break;
        }

        gInitedTbl = TRUE;

        // Initialize the forwarding engine
        Status = BrdgFwdDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize forwarding engine functionality: %08x\n", Status));
            break;
        }

        gInitedFwd = TRUE;

        // Initialize the buffer management part of our driver
        Status = BrdgBufDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize miniport functionality: %08x\n", Status));
            break;
        }

        gInitedBuf = TRUE;

        // Initialize the miniport part of our driver
        Status = BrdgMiniDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize miniport functionality: %08x\n", Status));
            break;
        }

        gInitedMini = TRUE;

        // Initialize the protocol part of our driver
        Status = BrdgProtDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize protocol functionality: %08x\n", Status));
            break;
        }

        gInitedProt = TRUE;

        // Initialize the compatibility-mode code
        Status = BrdgCompDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize compatibility-mode functionality: %08x\n", Status));
            break;
        }

        gInitedComp = TRUE;

        Status = BrdgReadRegDWord(&gRegistryPath, gDisableForwarding, &ulDisableForwarding);

        if ((!NT_SUCCESS(Status) || !ulDisableForwarding))
        {

            //
            // Group policies are only in effect on Professional and up.
            //
            if (!BrdgIsRunningOnPersonal())
            {
    #if DBG
                if (gGpoTesting)
                {
    #endif
                    // Initialize the tdi code
                    Status = BrdgTdiDriverInit();
        
                    if( Status != STATUS_SUCCESS )
                    {
                        DBGPRINT(GENERAL, ("Unable to initialize tdi functionality: %08x\n", Status));
                        break;
                    }
                    gInitedTdiGpo = TRUE;
    #if DBG
                }
    #endif        
            }
            else
            {
                gBridging = TRUE;
                Status = STATUS_SUCCESS;
            }
        }

        // Associate the miniport to the protocol
        BrdgMiniAssociate();

    } while (FALSE);

    if (Status != STATUS_SUCCESS)
    {
        BrdgDoShutdown();
    }

    return(Status);
}

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Description:

    Receives control requests from the outside

Arguments:

    pDeviceObject           Our driver
    pIrp                    The IRP to handle

Return Value:

    Status of the operation

--*/
{
    PVOID                   Buffer;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   Size = 0;
    NTSTATUS                status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    Buffer = pIrp->AssociatedIrp.SystemBuffer;
    IrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL )
    {
        // Don't accept IRPs when we're shutting down
        if( gShuttingDown )
        {
            status = STATUS_UNSUCCESSFUL;
            pIrp->IoStatus.Information = 0;
        }
        else
        {
            status = BrdgCtlHandleIoDeviceControl( pIrp, IrpSp->FileObject, Buffer,
                                                   IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                                   IrpSp->Parameters.DeviceIoControl.IoControlCode, &Size );
        }
    }
    else
    {
        if( IrpSp->MajorFunction == IRP_MJ_CREATE )
        {
            BrdgCtlHandleCreate();
        }
        else if( IrpSp->MajorFunction == IRP_MJ_CLEANUP )
        {
            BrdgCtlHandleCleanup();
        }

        // Leave status == STATUS_SUCCESS and Size == 0
    }

    if( status != STATUS_PENDING )
    {
        pIrp->IoStatus.Information = Size;
        pIrp->IoStatus.Status = status;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
BrdgDeferredShutdown(
    PVOID           pUnused
    )
/*++

Routine Description:

    Orderly-shutdown routine if we need to defer that task from high IRQL

Arguments:

    pUnused         Ignored

Return Value:

    None

--*/
{
    BrdgDoShutdown();
}

VOID
BrdgDoShutdown(
    VOID
    )
/*++

Routine Description:

    Called to do an orderly shutdown at unload time

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(GENERAL, ("==> BrdgDoShutdown()!\n"));

    // Clean up each of the sections
    if ( gInitedTdiGpo )
    {
        gInitedTdiGpo = FALSE;
        BrdgTdiCleanup();
    }
    
    if( gInitedControl )
    {
        gInitedControl = FALSE;
        BrdgCtlCleanup();
    }

    if( gInitedProt )
    {
        gInitedProt = FALSE;
        BrdgProtCleanup();
    }

    // This needs to be cleaned up after the protocol section
    if( gInitedSTA )
    {
        gInitedSTA = FALSE;
        BrdgSTACleanup();
    }

    if( gInitedMini )
    {
        gInitedMini = FALSE;
        BrdgMiniCleanup();
    }
    
    if( gInitedTbl )
    {
        gInitedTbl = FALSE;
        BrdgTblCleanup();
    }
    
    if( gInitedBuf )
    {
        gInitedBuf = FALSE;
        BrdgBufCleanup();
    }

    if( gInitedFwd )
    {
        gInitedFwd = FALSE;
        BrdgFwdCleanup();
    }

    if( gInitedComp )
    {
        gInitedComp = FALSE;
        BrdgCompCleanup();
    }

    if( gRegistryPath.Buffer != NULL )
    {
        NdisFreeMemory( gRegistryPath.Buffer, gRegistryPathBufferSize, 0 );
        gRegistryPath.Buffer = NULL;
    }

    DBGPRINT(GENERAL, ("<== BrdgDoShutdown()\n"));
}

VOID
BrdgUnload(
    IN  PDRIVER_OBJECT      DriverObject
    )
/*++

Routine Description:

    Called to indicate that we are being unloaded and to cause an orderly
    shutdown

Arguments:

    DriverObject            Our driver

Return Value:

    None

--*/
{
    if( ! InterlockedExchange(&gShuttingDown, 1L) )
    {
        BrdgDoShutdown();
    }
    // else was already shutting down; do nothing
}

VOID BrdgShutdown(
    VOID
    )
{
    if( ! InterlockedExchange(&gShuttingDown, 1L) )
    {
        BrdgDoShutdown();
    }
    // else was already shutting down; do nothing
}

NTSTATUS
BrdgReadRegUnicode(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PWCHAR              *String,        // The string from the registry, freshly allocated
    OUT PULONG              StringSize      // Size of allocated memory at String
    )
/*++

Routine Description:

    Reads a Unicode string from a specific registry key and value. Allocates memory
    for the string and returns it.

Arguments:

    KeyName                 The key holding the string
    pValueName              The name of the value holding the string

    String                  A pointer to indicate a freshly allocated buffer containing
                            the requested string on return

    StringSize              Size of the returned buffer

Return Value:

    Status of the operation. String is not valid if return != STATUS_SUCCESS

--*/
{
    NDIS_STATUS                     NdisStatus;
    HANDLE                          KeyHandle;
    OBJECT_ATTRIBUTES               ObjAttrs;
    NTSTATUS                        Status;
    ULONG                           RequiredSize;
    KEY_VALUE_PARTIAL_INFORMATION   *pInfo;
    UNICODE_STRING                  ValueName;

    // Turn the string into a UNICODE_STRING
    RtlInitUnicodeString( &ValueName, pValueName );

    // Describe the key to open
    InitializeObjectAttributes( &ObjAttrs, KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Open it
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &ObjAttrs );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to open registry key \"%ws\": %08x\n", KeyName->Buffer, Status));
        return Status;
    }

    // Find out how much memory is necessary to hold the value information
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation, NULL,
                              0L, &RequiredSize );

    if( (Status != STATUS_BUFFER_OVERFLOW) &&
        (Status != STATUS_BUFFER_TOO_SMALL) )
    {
        DBGPRINT(GENERAL, ("Failed to query for the size of value \"%ws\": %08x\n", ValueName.Buffer, Status));
        ZwClose( KeyHandle );
        return Status;
    }

    // Allocate the indicated amount of memory
    NdisStatus = NdisAllocateMemoryWithTag( (PVOID*)&pInfo, RequiredSize, 'gdrB' );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("NdisAllocateMemoryWithTag failed: %08x\n", NdisStatus));
        ZwClose( KeyHandle );
        return STATUS_UNSUCCESSFUL;
    }

    // Actually read out the string
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation, pInfo,
                              RequiredSize, &RequiredSize );

    ZwClose( KeyHandle );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("ZwQueryValueKey failed: %08x\n", Status));
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return Status;
    }

    // This had better be a Unicode string with something in it
    if( pInfo->Type != REG_SZ && pInfo->Type != REG_MULTI_SZ)
    {
        SAFEASSERT(FALSE);
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return STATUS_UNSUCCESSFUL;
    }

    // Allocate memory for the string
    *StringSize = pInfo->DataLength + sizeof(WCHAR);
    NdisStatus = NdisAllocateMemoryWithTag( (PVOID*)String, *StringSize, 'gdrB' );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("NdisAllocateMemoryWithTag failed: %08x\n", NdisStatus));
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return STATUS_UNSUCCESSFUL;
    }

    SAFEASSERT( *String != NULL );

    // Copy the string to the freshly allocated memory
    NdisMoveMemory( *String, &pInfo->Data, pInfo->DataLength );

    // Put a two-byte NULL character at the end
    ((PUCHAR)*String)[pInfo->DataLength] = '0';
    ((PUCHAR)*String)[pInfo->DataLength + 1] = '0';

    // Let go of resources we used on the way
    NdisFreeMemory( pInfo, RequiredSize, 0 );

    return STATUS_SUCCESS;
}

NTSTATUS
BrdgReadRegDWord(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PULONG              Value
    )
/*++

Routine Description:

    Reads a DWORD value out of the registry

Arguments:

    KeyName                 The name of the key holding the value
    pValueName              The name of the value holding the value
    Value                   Receives the value

Return Value:

    Status of the operation. Value is junk if return value != STATUS_SUCCESS

--*/
{
    HANDLE                          KeyHandle;
    OBJECT_ATTRIBUTES               ObjAttrs;
    NTSTATUS                        Status;
    UCHAR                           InfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    ULONG                           RequiredSize;
    UNICODE_STRING                  ValueName;

    // Turn the PWCHAR into a UNICODE_STRING
    RtlInitUnicodeString( &ValueName, pValueName );

    // Describe the key to open
    InitializeObjectAttributes( &ObjAttrs, KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Open it
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &ObjAttrs );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to open registry key \"%ws\": %08x\n", KeyName->Buffer, Status));
        return Status;
    }

    // Actually read out the value
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation,
                              (PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer,
                              sizeof(InfoBuffer), &RequiredSize );

    ZwClose( KeyHandle );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("ZwQueryValueKey failed: %08x\n", Status));
        return Status;
    }

    // This had better be a DWORD value
    if( (((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->Type != REG_DWORD) ||
        (((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->DataLength != sizeof(ULONG)) )
    {
        DBGPRINT(GENERAL, ("Registry parameter %ws not of the requested type!\n"));
        return STATUS_UNSUCCESSFUL;
    }

    *Value = *((PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->Data);
    return STATUS_SUCCESS;
}

NTSTATUS
BrdgOpenDevice (
    IN LPWSTR           pDeviceNameStr,
    OUT PDEVICE_OBJECT  *ppDeviceObject,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject
    )
/*++

Routine Description:

    Opens specified device driver (control channel) and returns a file object
    and a driver object. The caller should call BrdgCloseDevice() to shut
    down the connection when it's done.

Arguments:

    DeviceNameStr       device to open.
    pFileHandle         Receives a file handle
    ppFileObject        Receives a pointer to the file object
    ppDeviceObject      Receives a pointer to the device object

Return Value:

    NTSTATUS -- Indicates whether the device was opened OK

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      DeviceName;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;

    // We make calls that can only be performed at PASSIVE_LEVEL.
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    RtlInitUnicodeString(&DeviceName, pDeviceNameStr);

    InitializeObjectAttributes(
        &objectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    status = IoCreateFile(
                 pFileHandle,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,                           // eaInfo
                 0,                              // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING        // Options
                    | IO_FORCE_ACCESS_CHECK
                 );

    if (NT_SUCCESS(status))
    {
        status = ObReferenceObjectByHandle (
                     *pFileHandle,
                     0L,
                     *IoFileObjectType,
                     KernelMode,
                     (PVOID *)ppFileObject,
                     NULL
                     );

        if (! NT_SUCCESS(status))
        {
            DBGPRINT(ALWAYS_PRINT, ("ObReferenceObjectByHandle FAILED while opening a device: %8x\n", status));
            ZwClose (*pFileHandle);
        }
        else
        {
            // Recover the driver object
            *ppDeviceObject = IoGetRelatedDeviceObject ( *ppFileObject );
            SAFEASSERT( *ppDeviceObject != NULL );

            // Reference the driver handle, too.
            ObReferenceObject( *ppDeviceObject );
        }
    }
    else
    {
        DBGPRINT(ALWAYS_PRINT, ("IoCreateFile FAILED while opening a device: %8x\n", status));
    }

    return status;
}

VOID
BrdgCloseDevice(
    IN HANDLE               FileHandle,
    IN PFILE_OBJECT         pFileObject,
    IN PDEVICE_OBJECT       pDeviceObject
    )
/*++

Routine Description:

    Closes a device

Arguments:

    FileHandle              The file handle
    pFileObject             The file object of the device
    pDeviceObject           The device object of the device

Return Value:

    None

--*/
{
    NTSTATUS                status;

    // We make calls that can only be performed at PASSIVE_LEVEL.
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    ObDereferenceObject( pFileObject );
    ObDereferenceObject( pDeviceObject );
    status = ZwClose( FileHandle );

    SAFEASSERT( NT_SUCCESS(status) );
}

VOID
BrdgTimerExpiry(
    IN PVOID        ignored1,
    IN PVOID        data,
    IN PVOID        ignored2,
    IN PVOID        ignored3
    )
/*++

Routine Description:

    Master device expiry function. Calls a timer-specific expiry
    function if one was specified for this timer.

Arguments:

    data            The timer pointer

Return Value:

    None

--*/
{
    PBRIDGE_TIMER   pTimer = (PBRIDGE_TIMER)data;

    NdisAcquireSpinLock( &pTimer->Lock );
    SAFEASSERT( pTimer->bRunning );

    if( pTimer->bCanceled )
    {
        // This is the rare codepath where a call to NdisCancelTimer() was unable to
        // dequeue our timer entry because we were about to be called.
        DBGPRINT(GENERAL, ("Timer expiry function called with cancelled timer!\n"));

        // Don't call the timer function; just bail out
        pTimer->bRunning = FALSE;
        NdisReleaseSpinLock( &pTimer->Lock );

        // Unblock BrdgShutdownTimer()
        NdisSetEvent( &pTimer->Event );
    }
    else
    {
        BOOLEAN         bRecurring;
        UINT            interval;

        // Read protected values inside the lock
        bRecurring = pTimer->bRecurring;
        interval = pTimer->Interval;

        // Update bRunning inside the spin lock
        pTimer->bRunning = bRecurring;
        NdisReleaseSpinLock( &pTimer->Lock );

        // Call the timer function
        (*pTimer->pFunc)(pTimer->data);

        if( bRecurring )
        {
            // Start it up again
            NdisSetTimer( &pTimer->Timer, interval );
        }
    }
}

VOID
BrdgInitializeTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN PBRIDGE_TIMER_FUNC   pFunc,
    IN PVOID                data
    )
/*++

Routine Description:

    Sets up a BRIDGE_TIMER.

Arguments:

    pTimer                  The timer
    pFunc                   Expiry function
    data                    Cookie to pass to pFunc

Return Value:

    None

--*/
{
    pTimer->bShuttingDown = FALSE;
    pTimer->bRunning = FALSE;
    pTimer->bCanceled = FALSE;
    pTimer->pFunc = pFunc;
    pTimer->data = data;

    NdisInitializeTimer( &pTimer->Timer, BrdgTimerExpiry, (PVOID)pTimer );
    NdisInitializeEvent( &pTimer->Event );
    NdisResetEvent( &pTimer->Event );
    NdisAllocateSpinLock( &pTimer->Lock );

    // Leave pTimer->bRecurring alone; it gets a value when the timer is started.
}

VOID
BrdgSetTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN UINT                 interval,
    IN BOOLEAN              bRecurring
    )
/*++

Routine Description:

    Starts a BRIDGE_TIMER ticking.

Arguments:

    pTimer                  The timer
    interval                Time before expiry in ms
    bRecurring              TRUE to restart the timer when it expires

Return Value:

    None

--*/
{
    NdisAcquireSpinLock( &pTimer->Lock );

    if( !pTimer->bShuttingDown )
    {
        pTimer->bRunning = TRUE;
        pTimer->bCanceled = FALSE;
        pTimer->Interval = interval;
        pTimer->bRecurring = bRecurring;
        NdisReleaseSpinLock( &pTimer->Lock );

        // Actually start the timer
        NdisSetTimer( &pTimer->Timer, interval );
    }
    else
    {
        NdisReleaseSpinLock( &pTimer->Lock );
        DBGPRINT(ALWAYS_PRINT, ("WARNING: Ignoring an attempt to restart a timer in final shutdown!\n"));
    }
}

VOID
BrdgShutdownTimer(
    IN PBRIDGE_TIMER        pTimer
    )
/*++

Routine Description:

    Safely shuts down a timer, waiting to make sure that the timer has been
    completely dequeued or its expiry function has started executing (there
    is no way to guarantee that the expiry function is completely done
    executing, however).

    Must be called at PASSIVE_LEVEL.

Arguments:

    pTimer                  The timer

Return Value:

    None

--*/
{
    // We wait on an event
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    NdisAcquireSpinLock( &pTimer->Lock );

    // Forbid future calls to BrdgSetTimer().
    pTimer->bShuttingDown = TRUE;

    if( pTimer->bRunning )
    {
        BOOLEAN             bCanceled;

        // Make sure the timer expiry function will bail out if it's too late to
        // dequeue the timer and it ends up getting called
        pTimer->bCanceled = TRUE;

        // This will unblock the timer expiry function, but even if it executes
        // between now and the call to NdisCancelTimer, it should still end up
        // signalling the event we will wait on below.
        NdisReleaseSpinLock( &pTimer->Lock );

        // Try to cancel the timer.
        NdisCancelTimer( &pTimer->Timer, &bCanceled );

        if( !bCanceled )
        {
            //
            // bCancelled can be FALSE if the timer wasn't running in the first place,
            // or if the OS couldn't dequeue the timer (but our expiry function will
            // still be called). Our use of our timer structure's spin lock should
            // guarantee that the timer expiry function will be executed after we
            // released the spin lock above, if we are on this code path. This means
            // that the event we wait on below will be signalled by the timer expiry
            // function.
            //
            DBGPRINT(GENERAL, ("Couldn't dequeue timer; blocking on completion\n"));

            // Wait for the completion function to finish its work
            NdisWaitEvent( &pTimer->Event, 0 /*Wait forever*/ );

            // The completion function should have cleared this
            SAFEASSERT( !pTimer->bRunning );
        }
        else
        {
            pTimer->bRunning = FALSE;
        }
    }
    else
    {
        // Tried to shutdown a timer that was not running. This is allowed (it does nothing).
        NdisReleaseSpinLock( &pTimer->Lock );
    }
}

VOID
BrdgCancelTimer(
    IN PBRIDGE_TIMER        pTimer
    )
/*++

Routine Description:

    Attempts to cancel a timer, but provides no guarantee that the timer is
    actually stopped on return. It is possible for the timer expiry function
    to fire after this function returns.

Arguments:

    pTimer                  The timer

Return Value:

    None.

--*/
{
    NdisAcquireSpinLock( &pTimer->Lock );
    
    if( pTimer->bRunning )
    {
        BOOLEAN             bCanceled;
        
        pTimer->bCanceled = TRUE;
        NdisCancelTimer( &pTimer->Timer, &bCanceled );
        
        if( bCanceled )
        {
            pTimer->bRunning = FALSE;
        }
        // else timer expiry function will set bRunning to FALSE when it completes.
    }
    // else tried to cancel a timer that was not running. This is allowed (it does nothing).
    
    NdisReleaseSpinLock( &pTimer->Lock );
}

BOOLEAN
BrdgIsRunningOnPersonal(
    VOID
    )
/*++

Routine Description:

    Determines if we're running on a Personal build.
    

Arguments:

    None.

Return Value:

    TRUE if we're on Personal, FALSE if we're not.

--*/
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;
    BOOLEAN IsPersonal = TRUE;
    
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;
    
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);
    
    if (RtlVerifyVersionInfo(&OsVer, VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask) == STATUS_REVISION_MISMATCH) {
        IsPersonal = FALSE;
    }
    
    return IsPersonal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\bridge\sys\bridge.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.h

Abstract:

    Ethernet MAC level bridge.

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#pragma warning( push, 3 )
// For Ethernet constants and macros
#include <xfilter.h>

// For ULONG_MAX
#include <limits.h>
#pragma warning( pop )

// Disable "conditional expression is constant" warning
#pragma warning( disable: 4127 )

// Disable "Unreferenced formal parameter" warning
#pragma warning( disable: 4100 )

// Disable "Bit field type other than int" warning
#pragma warning( disable: 4214 )

// Debugging defines
#include "brdgdbg.h"

// Singly-linked list implementation
#include "brdgslist.h"

// WAIT_REFCOUNT implementation
#include "brdgwref.h"

// Timer implementation
#include "brdgtimr.h"

// Hash table implementation
#include "brdghash.h"

// Cache implementation
#include "brdgcach.h"

// Our IOCTLs and control structures
#include "bioctl.h"

// Include the STA type declarations
#include "brdgstad.h"

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

#define DEVICE_NAME             L"\\Device\\Bridge"
#define SYMBOLIC_NAME           L"\\DosDevices\\Bridge"
#define PROTOCOL_NAME           L"BRIDGE"

//
// The IEEE-specified reserved Spanning Tree Algorithm group destination
// MAC address
//
// This exact address is specified as the "Bridge Group Address" and is used for
// transmitting STA packets. *Any* address with these first 5 bytes is reserved
// by the IEEE for future use (so there are 15 reserved but unused addresses).
//
// Frames addressed to ANY of the reserved addresses are never relayed by the bridge.
//
extern UCHAR                    STA_MAC_ADDR[ETH_LENGTH_OF_ADDRESS];

//
// Each queue draining thread blocks against one kernel event per adapter, plus
// the global kill event and the per-processor event to trigger a re-enumeration
// of adapters.
//
// This limits our maximum number of adapters, since the kernel can't block a
// thread against an unbounded number of objects.
//
#define MAX_ADAPTERS (MAXIMUM_WAIT_OBJECTS - 2)

// Registry key where we keep our global parameters
extern const PWCHAR             gRegConfigPath;

// Size of an Ethernet frame header
#define ETHERNET_HEADER_SIZE    ((2*ETH_LENGTH_OF_ADDRESS) + 2)

// Largest possible Ethernet packet (with header)
#define MAX_PACKET_SIZE         1514

// ===========================================================================
//
// TYPE DECLARATIONS
//
// ===========================================================================

struct _NDIS_REQUEST_BETTER;

// Completion function type for NDIS_REQUEST_BETTER
typedef VOID (*PCOMPLETION_FUNC)(struct _NDIS_REQUEST_BETTER*, PVOID);

//
// Structure for performing NDIS requests. Can block to wait for result or
// specify a custom completion routine.
//
typedef struct _NDIS_REQUEST_BETTER
{
    NDIS_REQUEST            Request;
    NDIS_STATUS             Status;                 // Final status of the request
    NDIS_EVENT              Event;                  // Event signaled when request completes
    PCOMPLETION_FUNC        pFunc;                  // Completion function
    PVOID                   FuncArg;                // Argument to completion function
} NDIS_REQUEST_BETTER, *PNDIS_REQUEST_BETTER;

typedef struct _ADAPTER_QUOTA
{
    //
    // Total number of packets this adapter is holding from each major pool.
    //
    // Note that the sum of all adapters' pool usage can be greater than the pool capacity,
    // because base packets are shared. The quota scheme allows this.
    //
    // [0] == Copy packets
    // [1] == Wrapper packets
    //
    ULONG                   UsedPackets[2];

} ADAPTER_QUOTA, *PADAPTER_QUOTA;

//
// Per adapter data structure
//
typedef struct _ADAPT ADAPT, *PADAPT;

typedef struct _ADAPT
{
    PADAPT                  Next;                   // Next adapter in queue

    LONG                    AdaptSize;              // Size of structure (storage for DeviceName is at tail)
    WAIT_REFCOUNT           Refcount;               // Refcount for the adapter

    // State must be updated inside a write lock on gAdapterCharacteristicsLock,
    // since an adapter's relaying status affects our miniport's virtual status.
    // Only the STA code writes to this field; all other code should treat it as
    // read-only.
    PORT_STATE              State;

    //
    // Various useful info about the adapter. None of these fields are ever changed after
    // adapter initialization.
    //
    NDIS_STRING             DeviceName;
    NDIS_STRING             DeviceDesc;

    UCHAR                   MACAddr[ETH_LENGTH_OF_ADDRESS];
    NDIS_MEDIUM             PhysicalMedium;         // Set to NO_MEDIUM if the NIC doesn't report something more specific

    NDIS_HANDLE             BindingHandle;
    BOOLEAN                 bCompatibilityMode;     // TRUE if the adapter is in compatibility mode

    // These two fields are used while opening / closing an adapter
    NDIS_EVENT              Event;
    NDIS_STATUS             Status;

    // This field is volatile
    BOOLEAN                 bResetting;

    // The queue and bServiceInProgress is protected by this spin lock
    NDIS_SPIN_LOCK          QueueLock;
    BSINGLE_LIST_HEAD       Queue;
    BOOLEAN                 bServiceInProgress;

    // This allows a caller to wait on the queue becoming empty. It is updated when an item is
    // queued or dequeued.
    WAIT_REFCOUNT           QueueRefcount;

    // Auto-clearing event to request servicing of the queue
    KEVENT                  QueueEvent;

    // These fields are locked by gAdapterCharacteristicsLock for all adapters together
    ULONG                   MediaState;             // NdisMediaStateConnected / NdisMediaStateDisconnected
    ULONG                   LinkSpeed;              // Units of 100bps (10MBps == 100,000)

    // This structure is locked by gQuotaLock for all adapters together
    ADAPTER_QUOTA           Quota;                  // Quota information for this adapter

    // Statistics
    LARGE_INTEGER           SentFrames;             // All frames sent (including relay)
    LARGE_INTEGER           SentBytes;              // All bytes sent (including relay)
    LARGE_INTEGER           SentLocalFrames;        // Frames sent from the local machine
    LARGE_INTEGER           SentLocalBytes;         // Bytes sent from the local machine
    LARGE_INTEGER           ReceivedFrames;         // All received frames (including relay)
    LARGE_INTEGER           ReceivedBytes;          // All received bytes (including relay)

    STA_ADAPT_INFO          STAInfo;                // STA data for this adapter

    // Set once from FALSE to TRUE when STA initialization on this adapter has completed.
    // This flag is set inside the gSTALock.
    BOOLEAN                 bSTAInited;

} ADAPT, *PADAPT;

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Calculates the difference between a previously recorded time and now
// allowing for timer rollover
//
__forceinline
ULONG
BrdgDeltaSafe(
    IN ULONG                    prevTime,
    IN ULONG                    nowTime,
    IN ULONG                    maxDelta
    )
{
    ULONG                       delta;

    if( nowTime >= prevTime )
    {
        // Timer did not roll over
        delta = nowTime - prevTime;
    }
    else
    {
        // Looks like timer rolled over
        delta = ULONG_MAX - prevTime + nowTime;
    }

    SAFEASSERT( delta < maxDelta );
    return delta;
}

//
// There is no defined InterlockedExchangeULong function in the kernel, just
// InterlockedExchange. Abstract out the cast.
//
__forceinline ULONG
InterlockedExchangeULong(
    IN PULONG           pULong,
    IN ULONG            NewValue
    )
{
    return (ULONG)InterlockedExchange( (PLONG)pULong, NewValue );
}

//
// Acquires an ADAPT structure checking whether the adapter is
// closing or not.
//
__forceinline BOOLEAN
BrdgAcquireAdapter(
    IN PADAPT           pAdapt
    )
{
    return BrdgIncrementWaitRef( &pAdapt->Refcount );
}

//
// Just increments a PADAPT's refcount; assumes that the refcount is already > 0
// Use when it is guaranteed that BrdgAcquireAdapter() has succeeded and
// the refcount is still > 0.
//
__forceinline VOID
BrdgReacquireAdapter(
    IN PADAPT           pAdapt
    )
{
    BrdgReincrementWaitRef( &pAdapt->Refcount );
}

//
// It is safe to acquire an adapter inside the gAdapterListLock or the gAddressLock
//
__forceinline VOID
BrdgAcquireAdapterInLock(
    IN PADAPT           pAdapt
    )
{
    BOOLEAN             bIncremented;

    SAFEASSERT( pAdapt->Refcount.state == WaitRefEnabled );
    bIncremented = BrdgIncrementWaitRef( &pAdapt->Refcount );
    SAFEASSERT( bIncremented );
}

//
// Releases a PADAPT structure (from either a BrdgAcquireAdapter() or BrdgReacquireAdapter()
// call)
//
__forceinline VOID
BrdgReleaseAdapter(
    IN PADAPT           pAdapt
    )
{
    BrdgDecrementWaitRef( &pAdapt->Refcount );
}

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgUnload(
    IN  PDRIVER_OBJECT      DriverObject
    );

NDIS_STATUS
BrdgDeferFunction(
    VOID                    (*pFunc)(PVOID),
    PVOID                   arg
    );

NTSTATUS
BrdgReadRegUnicode(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PWCHAR              *String,        // The string from the registry, freshly allocated
    OUT PULONG              StringSize      // Size of allocated memory at String
    );

NTSTATUS
BrdgReadRegDWord(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PULONG              Value
    );

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT      pDeviceObject,
    IN  PIRP                pIrp
    );

NTSTATUS
BrdgOpenDevice (
    IN LPWSTR           pDeviceNameStr,
    OUT PDEVICE_OBJECT  *ppDeviceObject,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject
    );

VOID
BrdgCloseDevice(
    IN HANDLE               FileHandle,
    IN PFILE_OBJECT         pFileObject,
    IN PDEVICE_OBJECT       pDeviceObject
    );

VOID
BrdgShutdown(VOID);

BOOLEAN
BrdgIsRunningOnPersonal(VOID);
                    

// ===========================================================================
//
// GLOBAL VARIABLE DECLARATIONS
//
// ===========================================================================

// NDIS handle for us as a protocol
extern NDIS_HANDLE              gProtHandle;

// The adapter list
extern PADAPT                   gAdapterList;

// RW lock protecting the adapter list
extern NDIS_RW_LOCK             gAdapterListLock;

// != 0 means we are shutting down
extern LONG                     gShuttingDown;

// Our driver object
extern PDRIVER_OBJECT           gDriverObject;

// Our registry key where we can keep config information
extern UNICODE_STRING           gRegistryPath;

// Set if the Bridge believes that tcp/ip has been loaded
extern BOOLEAN                  g_fIsTcpIpLoaded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnbridge.cpp ===
//depot/private/homenet/net/homenet/Config/CfgMgr/HNBridge.cpp#13 - edit change 5915 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R I D G E . C P P
//
//  Contents:   CHNBridge implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetBridge Methods
//

STDMETHODIMP
CHNBridge::EnumMembers(
    IEnumHNetBridgedConnections **ppEnum
    )

{
    HRESULT                                     hr;
    CComObject<CEnumHNetBridgedConnections>     *pEnum;
    INetCfgComponent                            *pBridgeProtocol = NULL;
    INetCfg                                     *pnetcfg;
    IHNetBridgedConnection                      **rgBridgedAdapters = NULL;
    ULONG                                       ulCountAdapters = 0L;

    if( NULL != ppEnum )
    {
        *ppEnum = NULL;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_SERVER,
                IID_PPV_ARG(INetCfg, &pnetcfg));

        if( S_OK == hr )
        {
            hr = pnetcfg->Initialize( NULL );

            if( S_OK == hr )
            {
                hr = pnetcfg->FindComponent( c_wszSBridgeSID, &pBridgeProtocol );

                if( S_OK == hr )
                {
                    INetCfgComponentBindings    *pnetcfgProtocolBindings;

                    // Get the ComponentBindings interface for the protocol component
                    hr = pBridgeProtocol->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgProtocolBindings)
                            );

                    if( S_OK == hr )
                    {
                        const GUID               guidDevClass = GUID_DEVCLASS_NET;
                        IEnumNetCfgComponent    *penumncfgcomp;
                        INetCfgComponent        *pnetcfgcomp;

                        //
                        // Get the list of NET (adapter) devices
                        //
                        hr = pnetcfg->EnumComponents( &guidDevClass, &penumncfgcomp );

                        if( S_OK == hr )
                        {
                            ULONG               ul;

                            //
                            // Examine each adapter to see if it's bound to the bridge protocol
                            //
                            while( (S_OK == hr) && (S_OK == penumncfgcomp->Next(1, &pnetcfgcomp, &ul)) )
                            {
                                _ASSERT( 1L == ul );
                                hr = pnetcfgProtocolBindings->IsBoundTo(pnetcfgcomp);

                                if( S_OK == hr )
                                {
                                    IHNetBridgedConnection      *pBridgedConnection;

                                    //
                                    // The bridge protocol is bound to this adapter. Turn the NetCfg component
                                    // interface into an IHNetBridgedConnection.
                                    //
                                    hr = GetIHNetConnectionForNetCfgComponent(
                                            m_piwsHomenet,
                                            pnetcfgcomp,
                                            TRUE,
                                            IID_PPV_ARG(IHNetBridgedConnection, &pBridgedConnection)
                                            );

                                    if( S_OK == hr )
                                    {
                                        IHNetBridgedConnection  **ppNewArray;

                                        //
                                        // Add the new IHNetBridgedConnection to our array
                                        //

                                        ppNewArray = reinterpret_cast<IHNetBridgedConnection**>(CoTaskMemRealloc( rgBridgedAdapters, (ulCountAdapters + 1) * sizeof(IHNetBridgedConnection*) ));

                                        if( NULL == ppNewArray )
                                        {
                                            hr = E_OUTOFMEMORY;
                                            // rgBridgedAdapters will be cleaned up below
                                        }
                                        else
                                        {
                                            // Use the newly grown array
                                            rgBridgedAdapters =  ppNewArray;
                                            rgBridgedAdapters[ulCountAdapters] = pBridgedConnection;
                                            ulCountAdapters++;
                                            pBridgedConnection->AddRef();
                                        }

                                        pBridgedConnection->Release();
                                    }
                                }
                                else if( S_FALSE == hr )
                                {
                                    // The bridge protocol is not bound to this adapter. Reset hr to success.
                                    hr = S_OK;
                                }

                                pnetcfgcomp->Release();
                            }

                            penumncfgcomp->Release();
                        }

                        pnetcfgProtocolBindings->Release();
                    }

                    pBridgeProtocol->Release();
                }

                pnetcfg->Uninitialize();
            }

            pnetcfg->Release();
        }

        //
        // Turn the array of bridge members into an enumeration
        //
        if( S_OK == hr )
        {
            hr = CComObject<CEnumHNetBridgedConnections>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(rgBridgedAdapters, ulCountAdapters);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridgedConnections, ppEnum)
                            );
                }

                pEnum->Release();
            }
        }

        //
        // The enumeration made a copy of the array and AddRef()ed the members.
        // Ditch it now.
        //
        if( rgBridgedAdapters )
        {
            ULONG           i;

            _ASSERT( ulCountAdapters );

            for( i = 0; i < ulCountAdapters; i++ )
            {
                _ASSERT( rgBridgedAdapters[i] );
                rgBridgedAdapters[i]->Release();
            }

            CoTaskMemFree( rgBridgedAdapters );
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNBridge::AddMember(
    IHNetConnection *pConn,
    IHNetBridgedConnection **ppBridgedConn,
    INetCfg *pnetcfgExisting
    )

{
    HRESULT             hr = S_OK;


    if (NULL == ppBridgedConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppBridgedConn = NULL;

        if (NULL == pConn)
        {
            hr = E_INVALIDARG;
        }
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    //
    // Make sure that it's permissible to add this connection
    // to a bridge
    //

    if (S_OK == hr)
    {
        HNET_CONN_PROPERTIES *pProps;

        hr = pConn->GetProperties(&pProps);

        if (S_OK == hr)
        {
            if (!pProps->fCanBeBridged)
            {
                hr = E_UNEXPECTED;
            }

            CoTaskMemFree(pProps);
        }
    }

    //
    // Bind the adapter to the bridge
    //

    if (S_OK == hr)
    {
        GUID            *pguidAdapter;

        hr = pConn->GetGuid (&pguidAdapter);

        if (S_OK == hr)
        {
            hr = BindNewAdapter (pguidAdapter, pnetcfgExisting);
            CoTaskMemFree(pguidAdapter);
        }
    }

    if (SUCCEEDED(hr))
    {
        if( NULL != pnetcfgExisting )
        {
            // Need to apply the changes for the next call to succeed
            hr = pnetcfgExisting->Apply();
        }

        if( SUCCEEDED(hr) )
        {
            // We should now be able to turn the provided connection into
            // an IHNetBridgedConnection
            hr = pConn->GetControlInterface( IID_PPV_ARG(IHNetBridgedConnection, ppBridgedConn) );

            // There is no good way to recover if this last operation failed
            _ASSERT( SUCCEEDED(hr) );

            //
            // Inform netman that something changed. Error doesn't matter.
            //
            UpdateNetman();
        }
    }

    return hr;
}

STDMETHODIMP
CHNBridge::Destroy(
    INetCfg *pnetcfgExisting
    )

{
    HRESULT                     hr = S_OK;
    IEnumHNetBridgedConnections *pEnum;
    IHNetBridgedConnection      *pConn;
    GUID                        *pGuid = NULL;

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    // Remember our connection GUID before we destroy it
    hr = GetGuid( &pGuid );

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumeration of our members
        //

        hr = EnumMembers(&pEnum);

        if (S_OK == hr)
        {
            ULONG ulCount;

            //
            // Remove each member from the bridge
            //

            do
            {
                hr = pEnum->Next(
                        1,
                        &pConn,
                        &ulCount
                        );

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    hr = pConn->RemoveFromBridge( pnetcfgExisting );
                    pConn->Release();
                }
            }
            while (SUCCEEDED(hr) && 1 == ulCount);

            pEnum->Release();
        }
    }
    else
    {
        _ASSERT( NULL == pGuid );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Remove the miniport
        //

        hr = RemoveMiniport( pnetcfgExisting );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Delete the WMI objects
        //

        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProperties,
                0,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = m_piwsHomenet->DeleteInstance(
                m_bstrConnection,
                0,
                NULL,
                NULL
                );
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //

        UpdateNetman();

        // Refresh the UI to remove this connection
        _ASSERT( NULL != pGuid );
        SignalDeletedConnection( pGuid );
    }

    if( NULL != pGuid )
    {
        CoTaskMemFree( pGuid );
    }

    return hr;
}

HRESULT
CHNBridge::RemoveMiniport(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;
    GUID                *pguid;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we failed to get a netcfg context
        if(  FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    hr = GetGuid( &pguid );

    if ( SUCCEEDED(hr) )
    {
        INetCfgComponent        *pnetcfgcomp;

        //
        // Locate ourselves by GUID
        //
        hr = FindAdapterByGUID(pnetcfg, pguid, &pnetcfgcomp);

        if ( SUCCEEDED(hr) )
        {
            const GUID          guidDevClass = GUID_DEVCLASS_NET;
            INetCfgClassSetup   *pncfgsetup = NULL;

            //
            // Recover the NetCfgClassSetup interface
            //
            hr = pnetcfg->QueryNetCfgClass(
                    &guidDevClass,
                    IID_PPV_ARG(INetCfgClassSetup, &pncfgsetup)
                    );

            if ( SUCCEEDED(hr) )
            {
                //
                // Blow away this instance of the bridge
                //
                hr = pncfgsetup->DeInstall(
                        pnetcfgcomp,
                        NULL,
                        NULL
                        );

                pncfgsetup->Release();
            }

            // Done with the bridge component
            pnetcfgcomp->Release();
        }

        CoTaskMemFree(pguid);
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}

HRESULT
CHNBridge::BindNewAdapter(
    IN GUID                 *pguid,
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;
    INetCfgComponent    *pnetcfgcomp;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we failed to get a netcfg context
        if(  FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    hr = FindAdapterByGUID(
            pnetcfg,
            pguid,
            &pnetcfgcomp
            );

    if ( SUCCEEDED(hr) )
    {
        hr = BindOnlyToBridge( pnetcfgcomp );
        pnetcfgcomp->Release();
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Redraw this connection
            SignalModifiedConnection( pguid );
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hncfgmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C F G M G R . C P P
//
//  Contents:   CHNetCfgMgr implementation
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Atl methods
//

HRESULT
CHNetCfgMgr::FinalConstruct()

{
    HRESULT hr = S_OK;
    IWbemLocator *pLocator = NULL;
    BSTR bstrNamespace = NULL;

    //
    // Allocate the commonly used BSTRs
    //

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        //
        // Allocate the BSTR for our namespace
        //

        bstrNamespace = SysAllocString(c_wszNamespace);
        if (NULL == bstrNamespace)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Create the IWbemLocator object. This interface allows us to
        // connect to the desired namespace.
        //

        hr = CoCreateInstance(
                CLSID_WbemLocator,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG(IWbemLocator, &pLocator)
                );
    }

    if (S_OK == hr)
    {
        //
        // Connect to our namespace
        //

        hr = pLocator->ConnectServer(
                bstrNamespace,
                NULL,   // user
                NULL,   // password
                NULL,   // locale
                0,      // security flags
                NULL,   // authority
                NULL,   // context
                &m_piwsHomenet
                );
    }

    //
    // Cleanup locals.
    //

    if (pLocator) pLocator->Release();
    if (bstrNamespace) SysFreeString(bstrNamespace);

    if (S_OK != hr)
    {
        //
        // Cleanup object members
        //

        SysFreeString(m_bstrWQL);
        m_bstrWQL = NULL;
        if (NULL != m_piwsHomenet)
        {
            m_piwsHomenet->Release();
            m_piwsHomenet = NULL;
        }
    }

    return hr;
}

HRESULT
CHNetCfgMgr::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_pNetConnUiUtil) m_pNetConnUiUtil->Release();
    if (m_pNetConnHNetUtil) m_pNetConnHNetUtil->Release();
    if (m_bstrWQL) SysFreeString(m_bstrWQL);

    return S_OK;
}


//
// IHNetCfgMgr methods
//

STDMETHODIMP
CHNetCfgMgr::GetIHNetConnectionForINetConnection(
    INetConnection *pNetConnection,
    IHNetConnection **ppHNetConnection
    )

{
    HRESULT hr = S_OK;
    NETCON_PROPERTIES* pProps;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;
    BOOLEAN fLanConnection;

    if (NULL == ppHNetConnection)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppHNetConnection = NULL;

        if (NULL == pNetConnection)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Get the properties for the connection
        //

        hr = pNetConnection->GetProperties(&pProps);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Attempt to find the connection and properties
        // instances in the store
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                &pProps->guidId,
                &pwcoConnection,
                &pwcoProperties
                );

        if (FAILED(hr))
        {


            //
            // We have no record of this connection. Determine
            // if it is a lan connection. (Will need to update
            // this for bridge)
            //

            fLanConnection = (NCM_LAN                  == pProps->MediaType ||
                              NCM_BRIDGE               == pProps->MediaType);

            //
            // Create the store instances
            //

            hr = CreateConnectionAndPropertyInstances(
                    &pProps->guidId,
                    fLanConnection,
                    pProps->pszwName,
                    &pwcoConnection,
                    &pwcoProperties
                    );

            //
            // If this is a ras connection, determine the
            // phonebook path
            //

            if (S_OK == hr && FALSE == fLanConnection)
            {
                LPWSTR wsz;
                VARIANT vt;

                hr = GetPhonebookPathFromRasNetcon(pNetConnection, &wsz);
                if (SUCCEEDED(hr))
                {
                    V_VT(&vt) = VT_BSTR;
                    V_BSTR(&vt) = SysAllocString(wsz);
                    CoTaskMemFree(wsz);

                    if (NULL != V_BSTR(&vt))
                    {
                        hr = pwcoConnection->Put(
                                c_wszPhonebookPath,
                                0,
                                &vt,
                                NULL
                                );

                        VariantClear(&vt);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Save modified connection instance
                    //

                    hr = m_piwsHomenet->PutInstance(
                            pwcoConnection,
                            WBEM_FLAG_CREATE_OR_UPDATE,
                            NULL,
                            NULL
                            );
                }
                else
                {
                    //
                    // Delete the newly created instances
                    //

                    DeleteWmiInstance(m_piwsHomenet, pwcoConnection);
                    DeleteWmiInstance(m_piwsHomenet, pwcoProperties);
                    pwcoConnection->Release();
                    pwcoProperties->Release();
                }
            }
        }

        NcFreeNetconProperties(pProps);
    }

    if (S_OK == hr)
    {
        CComObject<CHNetConn> *pHNConn;

        //
        // Create the wrapper object
        //

        hr = CComObject<CHNetConn>::CreateInstance(&pHNConn);

        if (SUCCEEDED(hr))
        {
            pHNConn->AddRef();

            hr = pHNConn->SetINetConnection(pNetConnection);

            if (S_OK == hr)
            {
                hr = pHNConn->InitializeFromInstances(
                        m_piwsHomenet,
                        pwcoConnection,
                        pwcoProperties
                        );
            }

            if (S_OK == hr)
            {
                hr = pHNConn->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppHNetConnection)
                        );
            }

            pHNConn->Release();
        }

        pwcoConnection->Release();
        pwcoProperties->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetIHNetConnectionForGuid(
    GUID *pGuid,
    BOOLEAN fLanConnection,
    BOOLEAN fCreateEntries,
    IHNetConnection **ppHNetConnection
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;

    if (NULL == ppHNetConnection)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppHNetConnection = NULL;

        if (NULL == pGuid)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Attempt to find the connection and properties
        // instances in the store
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                pGuid,
                &pwcoConnection,
                &pwcoProperties
                );

        if (FAILED(hr) && fCreateEntries)
        {
            INetConnection *pNetConn;

            //
            // We don't have a record of this guid. Get the INetConnection
            // that it corresponds to.
            //

            hr = FindINetConnectionByGuid(pGuid, &pNetConn);

            if (SUCCEEDED(hr))
            {
                hr = GetIHNetConnectionForINetConnection(
                        pNetConn,
                        ppHNetConnection
                        );

                pNetConn->Release();
                return hr;
            }
        }
    }


    if (S_OK == hr)
    {
        CComObject<CHNetConn> *pHNConn;

        //
        // Create the wrapper object
        //

        hr = CComObject<CHNetConn>::CreateInstance(&pHNConn);

        if (SUCCEEDED(hr))
        {
            pHNConn->AddRef();

            hr = pHNConn->InitializeFromInstances(
                    m_piwsHomenet,
                    pwcoConnection,
                    pwcoProperties
                    );

            if (S_OK == hr)
            {
                hr = pHNConn->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppHNetConnection)
                        );
            }

            pHNConn->Release();
        }

        pwcoConnection->Release();
        pwcoProperties->Release();
    }

    return hr;
}

//
// IHNetBridgeSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumBridges(
    IEnumHNetBridges **ppEnum
    )

{
    HRESULT                             hr;
    CComObject<CEnumHNetBridges>        *pEnum;
    IHNetBridge                         *phnbridge;

    if( NULL != ppEnum )
    {
        *ppEnum = NULL;

        hr = GetBridgeConnection( m_piwsHomenet, &phnbridge );

        if( S_OK == hr )
        {
            hr = CComObject<CEnumHNetBridges>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(&phnbridge, 1L);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridges, ppEnum)
                            );
                }

                pEnum->Release();
            }

            phnbridge->Release();
        }
        else
        {
            // Make an empty enumerator
            hr = CComObject<CEnumHNetBridges>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(NULL, 0L);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridges, ppEnum)
                            );
                }

                pEnum->Release();
            }
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreateBridge(
    IHNetBridge **ppHNetBridge,
    INetCfg *pnetcfgExisting
    )
{
    HRESULT hr = S_OK;
    GUID guid;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;

    if (NULL != ppHNetBridge)
    {
        *ppHNetBridge = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Install the bridge driver, and create the bridge miniport.
        //

        hr = InstallBridge( &guid, pnetcfgExisting );
    }

    if (S_OK == hr)
    {
        //
        // See if we already have property instances for this connection.
        // (They may have been created when the bridge connection object
        // was instantiated.)
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                &guid,
                &pwcoConnection,
                &pwcoProperties
                );

        if (S_OK != hr)
        {
            //
            // Create the store instances
            //

            hr = CreateConnectionAndPropertyInstances(
                    &guid,
                    TRUE,
                    c_wszBridge,
                    &pwcoConnection,
                    &pwcoProperties
                    );
        }
    }

    if (S_OK == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //

        UpdateNetman();
    }

    if (S_OK == hr)
    {
        CComObject<CHNBridge> *pBridge;

        //
        // Create wrapper object to return
        //

        hr = CComObject<CHNBridge>::CreateInstance(&pBridge);

        if (SUCCEEDED(hr))
        {
            pBridge->AddRef();

            hr = pBridge->InitializeFromInstances(
                    m_piwsHomenet,
                    pwcoConnection,
                    pwcoProperties
                    );

            if (S_OK == hr)
            {
                hr = pBridge->QueryInterface(
                        IID_PPV_ARG(IHNetBridge, ppHNetBridge)
                        );
            }

            pBridge->Release();
        }
    }

    if (NULL != pwcoConnection) pwcoConnection->Release();
    if (NULL != pwcoProperties) pwcoProperties->Release();

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DestroyAllBridges(
    ULONG *pcBridges,
    INetCfg *pnetcfgExisting
    )

{
    HRESULT hr = S_OK;
    IEnumHNetBridges *pehnbEnum;
    IHNetBridge *phnBridge;

    if (!pcBridges)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcBridges = 0;

        //
        // Get the enumeration of the bridges.
        //

        hr = EnumBridges(&pehnbEnum);
    }

    if (S_OK == hr)
    {
        //
        // Walk through the enumeration, destroying
        // each bridge
        //

        do
        {
            hr = pehnbEnum->Next(1, &phnBridge, NULL);
            if (S_OK == hr)
            {
                phnBridge->Destroy( pnetcfgExisting );
                phnBridge->Release();
                *pcBridges += 1;
            }
        }
        while (S_OK == hr);

        hr = S_OK;
        pehnbEnum->Release();
    }

    return hr;
}

//
// IHNetFirewallSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumFirewalledConnections(
    IEnumHNetFirewalledConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsFirewall is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsFirewalled != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetFirewalledConnections> *pEnum;

        hr = CComObject<CEnumHNetFirewalledConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetFirewalledConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings = NULL;

    if (!ppSettings)
    {
        hr = E_POINTER;
    }

    //
    // Allocate the necessary memory for the settings structure.
    //

    if (S_OK == hr)
    {
        *ppSettings = reinterpret_cast<HNET_FW_LOGGING_SETTINGS *>(
                        CoTaskMemAlloc(sizeof(HNET_FW_LOGGING_SETTINGS))
                        );

        if (NULL == *ppSettings)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetFWLoggingSettings,
                FALSE,
                &pwcoSettings
                );
    }

    if (S_OK == hr)
    {
        //
        // Copy the instance info into the settings block
        //

        hr = CopyLoggingInstanceToStruct(pwcoSettings, *ppSettings);

        pwcoSettings->Release();
    }

    if (FAILED(hr))
    {
        //
        // Clean up output structure
        //

        if (ppSettings && *ppSettings)
        {
            CoTaskMemFree(*ppSettings);
            *ppSettings = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings;

    if (NULL == pSettings)
    {
        hr = E_INVALIDARG;
    }

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve the HNet_FirewallLoggingSettings instance from
        // the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetFWLoggingSettings,
                TRUE,
                &pwcoSettings
                );
    }

    if (S_OK == hr)
    {
        //
        // Copy settings struct into object instance
        //

        hr = CopyStructToLoggingInstance(pSettings, pwcoSettings);

        if (S_OK == hr)
        {
            //
            // Write settings instance back to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoSettings,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoSettings->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Notify service of configuration change
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_FWLOGGER);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DisableAllFirewalling(
    ULONG *pcFirewalledConnections
    )

{
    HRESULT hr = S_OK;
    IEnumHNetFirewalledConnections *pehfcEnum;
    IHNetFirewalledConnection *phfcConnection;

    if (!pcFirewalledConnections)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcFirewalledConnections = 0;

        //
        // Get the enumeration of firewalled connections
        //

        hr = EnumFirewalledConnections(&pehfcEnum);
    }

    if (S_OK == hr)
    {
        //
        // Walk through the enumeration, turning off
        // firewalling for each connection
        //

        do
        {
            hr = pehfcEnum->Next(1, &phfcConnection, NULL);
            if (S_OK == hr)
            {
                phfcConnection->Unfirewall();
                phfcConnection->Release();
                *pcFirewalledConnections += 1;
            }
        }
        while (S_OK == hr);

        hr = S_OK;
        pehfcEnum->Release();
    }

    return hr;
}

//
// IHNetIcsSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumIcsPublicConnections(
    IEnumHNetIcsPublicConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsIcsPublic is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsIcsPublic != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetIcsPublicConnections> *pEnum;

        hr = CComObject<CEnumHNetIcsPublicConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetIcsPublicConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::EnumIcsPrivateConnections(
    IEnumHNetIcsPrivateConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsIcsPrivate is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsIcsPrivate != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetIcsPrivateConnections> *pEnum;

        hr = CComObject<CEnumHNetIcsPrivateConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetIcsPrivateConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DisableIcs(
    ULONG *pcIcsPublicConnections,
    ULONG *pcIcsPrivateConnections
    )

{
    HRESULT hr = S_OK;
    IEnumHNetIcsPrivateConnections *pehiPrivate;
    IEnumHNetIcsPublicConnections *pehiPublic;
    IHNetIcsPrivateConnection *phicPrivate;
    IHNetIcsPublicConnection *phicPublic;

    if (!pcIcsPublicConnections
        || !pcIcsPrivateConnections)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcIcsPublicConnections = 0;
        *pcIcsPrivateConnections = 0;

        //
        // Get enumeration of private connections
        //

        hr = EnumIcsPrivateConnections(&pehiPrivate);
    }

    if (S_OK == hr)
    {
        //
        // Loop through enumeration, unsharing the connection
        //

        do
        {
            hr = pehiPrivate->Next(1, &phicPrivate, NULL);
            if (S_OK == hr)
            {
                phicPrivate->RemoveFromIcs();
                phicPrivate->Release();
                *pcIcsPrivateConnections += 1;
            }
        } while (S_OK == hr);

        hr = S_OK;
        pehiPrivate->Release();
    }

    if (S_OK == hr)
    {
        //
        // Get enumeration of public connections
        //

        hr = EnumIcsPublicConnections(&pehiPublic);
    }

    if (S_OK == hr)
    {
        //
        // Loop through enumeration, unsharing the connection
        //

        do
        {
            hr = pehiPublic->Next(1, &phicPublic, NULL);
            if (S_OK == hr)
            {
                phicPublic->Unshare();
                phicPublic->Release();
                *pcIcsPublicConnections += 1;
            }
        } while (S_OK == hr);

        hr = S_OK;
        pehiPublic->Release();
    }

    if (S_OK == hr)
    {
        //
        // Currently, maximum of 1 public and private connection
        //

        _ASSERT(*pcIcsPrivateConnections <= 1);
        _ASSERT(*pcIcsPublicConnections <= 1);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetPossiblePrivateConnections(
    IHNetConnection *pConn,
    ULONG *pcPrivateConnections,
    IHNetConnection **pprgPrivateConnections[],
    LONG *pxCurrentPrivate
    )

/*++

Routine Description:

    Given an IHNetConnection, determines the what connections may
    serve as a private connection. Only connections that meet the
    following criteria may serve as a private connection:

    * it's a LAN connection
    * it's not part of a bridge
    * it's not firewalled
    * it's not the connection passed in
    * it's bound to TCP/IP

    Note that these are not the same rules that are used to set the
    fCanBeIcsPrivate member in HNET_CONN_PROPERTIES. In particular,
    these rules don't take into account whether or not a connection
    is currently marked as IcsPublic.

Arguments:

    pConn - the connection that would be the public connection

    pcPrivateConnections - receives the count of connections returned

    pprgPrivateConnections - receives that possible private connections.
        The caller is responsible for:
        1) Releasing all of the interface pointers w/in the array
        2) Calling CoTaskMemFree on the pointer to the array

    pxCurrentPrivate - receives the index into pprgPrivateConnections of
        the connection that is currently marked IcsPrivate. If no connection
        is so marked, receives -1.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    INetConnectionManager *pNetConnMgr;
    IEnumNetConnection *pEnum;
    INetConnection *rgNetConn[16];
    GUID *pGuid = NULL;
    HNET_CONN_PROPERTIES *pProps;
    IHNetConnection **rgConnections = NULL;
    ULONG cConn = 0;
    ULONG i;
    PIP_INTERFACE_INFO pIpIfTable = NULL;

    if (NULL != pprgPrivateConnections)
    {
        *pprgPrivateConnections = NULL;

        if (NULL == pConn)
        {
            hr = E_INVALIDARG;
        }
        else if (NULL == pcPrivateConnections
                 || NULL == pxCurrentPrivate)
        {
            hr = E_POINTER;
        }
        else
        {
            *pcPrivateConnections = 0;
            *pxCurrentPrivate = -1;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Obtain the IP interface table. We use this table to see if an
    // adapter is bound to TCP/IP.
    //

    if (S_OK == hr)
    {
        DWORD dwError;
        ULONG ulSize = 0;

        dwError = GetInterfaceInfo(NULL, &ulSize);

        if (ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            pIpIfTable =
                reinterpret_cast<PIP_INTERFACE_INFO>(
                    HeapAlloc(GetProcessHeap(), 0, ulSize)
                    );

            if (NULL != pIpIfTable)
            {
                dwError = GetInterfaceInfo(pIpIfTable, &ulSize);
                if (ERROR_SUCCESS != dwError)
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                    HeapFree(GetProcessHeap(), 0, pIpIfTable);
                    pIpIfTable = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    //
    // If the connection we we're given is a LAN connection, get its
    // guid so that we can exclude it from the possible private
    // connections.
    //

    if (S_OK == hr)
    {
        hr = pConn->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fLanConnection)
            {
                hr = pConn->GetGuid(&pGuid);
            }

            CoTaskMemFree(pProps);
        }
    }

    //
    // Create the net connections manager, and enumerate through the
    // connections. We don't enumerate through just what our store has,
    // as it might have stale entries (i.e., information for adapters
    // that have been removed from the system).
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG(INetConnectionManager, &pNetConnMgr)
                );
    }

    if (SUCCEEDED(hr))
    {
        SetProxyBlanket(pNetConnMgr);

        hr = pNetConnMgr->EnumConnections(NCME_DEFAULT, &pEnum);
        pNetConnMgr->Release();
    }

    if (SUCCEEDED(hr))
    {
        ULONG ulCount;

        SetProxyBlanket(pEnum);

        do
        {

            //
            // Grab a bunch of connections out of the enumeration
            //

            hr = pEnum->Next(ARRAYSIZE(rgNetConn), rgNetConn, &ulCount);

            if (SUCCEEDED(hr) && ulCount > 0)
            {
                //
                // Allocate memory for the output array
                //

                LPVOID pTemp = reinterpret_cast<LPVOID>(rgConnections);
                rgConnections = reinterpret_cast<IHNetConnection**>(
                    CoTaskMemRealloc(
                        pTemp,
                        (cConn + ulCount) * sizeof(IHNetConnection*))
                    );

                if (NULL != rgConnections)
                {
                    for (i = 0; i < ulCount; i++)
                    {
                        SetProxyBlanket(rgNetConn[i]);

                        hr = GetIHNetConnectionForINetConnection(
                                rgNetConn[i],
                                &rgConnections[cConn]
                                );

                        if (SUCCEEDED(hr))
                        {
                            hr = rgConnections[cConn]->GetProperties(&pProps);

                            if (SUCCEEDED(hr))
                            {
                                if (!pProps->fLanConnection
                                    || pProps->fPartOfBridge
                                    || pProps->fFirewalled)
                                {
                                    //
                                    // Connection can't be private
                                    //

                                    rgConnections[cConn]->Release();
                                    rgConnections[cConn] = NULL;
                                }
                                else
                                {
                                    GUID *pg;

                                    //
                                    // This connection can be private if:
                                    // 1) it's not the same as the public connection
                                    //    (if the public is LAN), and,
                                    // 2) it's bound to TCP/IP
                                    //

                                    hr = rgConnections[cConn]->GetGuid(&pg);

                                    if (SUCCEEDED(hr))
                                    {
                                        if ((NULL == pGuid
                                                || !IsEqualGUID(*pGuid, *pg))
                                            && ConnectionIsBoundToTcp(pIpIfTable, pg))
                                        {
                                            //
                                            // Connection can be private
                                            //

                                            if (pProps->fIcsPrivate)
                                            {
                                                _ASSERT(-1 == *pxCurrentPrivate);
                                                *pxCurrentPrivate = cConn;
                                            }

                                            cConn += 1;
                                        }
                                        else
                                        {
                                            rgConnections[cConn]->Release();
                                            rgConnections[cConn] = NULL;
                                        }

                                        CoTaskMemFree(pg);
                                    }
                                    else
                                    {
                                        rgConnections[cConn]->Release();
                                        rgConnections[cConn] = NULL;
                                    }
                                }

                                CoTaskMemFree(pProps);
                            }
                        }
                        else
                        {
                            //
                            // The connection couldn't be converted to an
                            // IHNetConnection -- this is expected for
                            // certain connection types (e.g., inbound)
                            //

                            hr = S_OK;
                            rgConnections[cConn] = NULL;
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    if (NULL != pTemp)
                    {
                        rgConnections = reinterpret_cast<IHNetConnection**>(pTemp);
                        for (i = 0; i < cConn; i++)
                        {
                            rgConnections[i]->Release();
                        }
                        CoTaskMemFree(pTemp);
                    }
                }

                //
                // Free the retrieved INetConnections
                //

                for (i = 0; i < ulCount; i++)
                {
                    rgNetConn[i]->Release();
                }
            }

        } while (SUCCEEDED(hr) && ulCount > 0);

        pEnum->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;

        if (cConn > 0)
        {
            *pcPrivateConnections = cConn;
            *pprgPrivateConnections = rgConnections;
        }
        else if (NULL != rgConnections)
        {
            CoTaskMemFree(reinterpret_cast<LPVOID>(rgConnections));
        }
    }
    else
    {
        //
        // Cleanup output array
        //

        if (NULL != rgConnections)
        {
            for (i = 0; i < cConn; i++)
            {
                if (NULL != rgConnections[i])
                {
                    rgConnections[i]->Release();
                }
            }

            CoTaskMemFree(reinterpret_cast<LPVOID>(rgConnections));
        }

        if (NULL != pxCurrentPrivate)
        {
            *pxCurrentPrivate = -1;
        }

        //
        // Even though a failure occurred, return success (with 0 possible
        // private connnections). Doing this allows our UI to continue to
        // show other homenet features, instead of throwing up an error
        // dialog and blocking everything.
        //

        hr = S_OK;
    }

    if (NULL != pGuid)
    {
        CoTaskMemFree(pGuid);
    }

    if (NULL != pIpIfTable)
    {
        HeapFree(GetProcessHeap(), 0, pIpIfTable);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetAutodialSettings(
    BOOLEAN *pfAutodialEnabled
    )

{
    HRESULT hr = S_OK;
    BOOL fEnabled;
    DWORD dwError;

    if (!pfAutodialEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Autodial information is stored in the registry and managed through
        // routines exported from rasapi32.dll. We're not changing any of the
        // autodial code, as to do so would require modifications to numerous
        // files and binaries, and thus would result in a very large test hit.
        //

        dwError = RasQuerySharedAutoDial(&fEnabled);
        if (ERROR_SUCCESS == dwError)
        {
            *pfAutodialEnabled = !!fEnabled;
        }
        else
        {
            //
            // Autodial defaults to true on failure.
            //

            *pfAutodialEnabled = TRUE;
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetAutodialSettings(
    BOOLEAN fEnableAutodial
    )

{
    DWORD dwError;

    //
    // Autodial information is stored in the registry and managed through
    // routines exported from rasapi32.dll. We're not changing any of the
    // autodial code, as to do so would require modifications to numerous
    // files and binaries, and thus would result in a very large test hit.
    //

    dwError = RasSetSharedAutoDial(!!fEnableAutodial);

    return HRESULT_FROM_WIN32(dwError);
}

STDMETHODIMP
CHNetCfgMgr::GetDhcpEnabled(
    BOOLEAN *pfDhcpEnabled
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance;

    if (NULL == pfDhcpEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Default to true on failure
        //

        *pfDhcpEnabled = TRUE;

        //
        // Get the HNet_IcsSettings instance from the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetIcsSettings,
                FALSE,
                &pwcoInstance
                );
    }

    if (S_OK == hr)
    {
        //
        // Retrieve the DHCP enabled property
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszDhcpEnabled,
                pfDhcpEnabled
                );

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::SetDhcpEnabled(
    BOOLEAN fEnableDhcp
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    //
    // Get the HNet_IcsSettings instance from the store
    //

    hr = RetrieveSingleInstance(
            m_piwsHomenet,
            c_wszHnetIcsSettings,
            TRUE,
            &pwcoInstance
            );

    if (S_OK == hr)
    {
        //
        // Write the property
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszDhcpEnabled,
                fEnableDhcp
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::GetDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    )

{
    HRESULT hr = S_OK;

    if (NULL == pdwScopeAddress || NULL == pdwScopeMask)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ReadDhcpScopeSettings(pdwScopeAddress, pdwScopeMask);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetDhcpScopeSettings(
    DWORD dwScopeAddress,
    DWORD dwScopeMask
    )

{
    //
    // This functionality isn't exposed in any way at the moment.
    //
    // People needing to override the default settings can do so
    // through the registry...
    //

    return E_NOTIMPL;
}


STDMETHODIMP
CHNetCfgMgr::GetDnsEnabled(
    BOOLEAN *pfDnsEnabled
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    if (NULL == pfDnsEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Default to true on failure
        //

        *pfDnsEnabled = TRUE;

        //
        // Get the HNet_IcsSettings instance from the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetIcsSettings,
                FALSE,
                &pwcoInstance
                );
    }

    if (S_OK == hr)
    {
        //
        // Retrieve the DHCP enabled property
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszDnsEnabled,
                pfDnsEnabled
                );

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::SetDnsEnabled(
    BOOLEAN fEnableDns
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    //
    // Get the HNet_IcsSettings instance from the store
    //

    hr = RetrieveSingleInstance(
            m_piwsHomenet,
            c_wszHnetIcsSettings,
            TRUE,
            &pwcoInstance
            );

    if (S_OK == hr)
    {
        //
        // Write the property
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszDnsEnabled,
                fEnableDns
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoInstance->Release();
    }

    return hr;
    **/

}
STDMETHODIMP
CHNetCfgMgr::EnumDhcpReservedAddresses(
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Query for all enabled bindings where the name is active.
    //

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                L"Enabled != FALSE AND NameActive != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Build wrapper object
        //

        CComObject<CEnumHNetPortMappingBindings> *pEnum;

        hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

        if (S_OK == hr)
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (S_OK == hr)
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}


//
// IHNetProtocolSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumApplicationProtocols(
    BOOLEAN fEnabledOnly,
    IEnumHNetApplicationProtocols **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ApplicationProtocol instances;
        // if fEnabledOnly is true, then only retrieve instances for
        // which the Enabled property is true
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetApplicationProtocol,
                fEnabledOnly ? L"Enabled != FALSE" : NULL
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetApplicationProtocols> *pEnum;

        hr = CComObject<CEnumHNetApplicationProtocols>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetApplicationProtocols, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreateApplicationProtocol(
    OLECHAR *pszwName,
    UCHAR ucOutgoingIPProtocol,
    USHORT usOutgoingPort,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    IHNetApplicationProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    VARIANT vt;
    SAFEARRAY *psa;
    IWbemClassObject *pwcoInstance;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProtocol = NULL;

        if (NULL == pszwName
                 || 0 == ucOutgoingIPProtocol
                 || 0 == usOutgoingPort
                 || 0 == uscResponses
                 || NULL == rgResponses)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Check to see if there already exists a protocol with the same
        // outgoing protocol and port
        //

        if (ApplicationProtocolExists(
                m_piwsHomenet,
                m_bstrWQL,
                usOutgoingPort,
                ucOutgoingIPProtocol
                ))
        {
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

    }

    if (S_OK == hr)
    {
        //
        // Convert the array of response range structure to a
        // SAFEARRAY of IUnknowns representing instances.
        //

        hr = ConvertResponseRangeArrayToInstanceSafearray(
                m_piwsHomenet,
                uscResponses,
                rgResponses,
                &psa
                );

    }

    if (S_OK == hr)
    {
        //
        // Spawn a new HNet_ApplicationProtocol
        //

        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetApplicationProtocol,
                &pwcoInstance
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the array property
            //


            V_VT(&vt) = VT_ARRAY | VT_UNKNOWN;
            V_ARRAY(&vt) = psa;

            hr = pwcoInstance->Put(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the name
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(pszwName);

                if (NULL != V_BSTR(&vt))
                {
                    hr = pwcoInstance->Put(
                            c_wszName,
                            0,
                            &vt,
                            NULL
                            );

                    VariantClear(&vt);
                }

            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the response count. WMI uses VT_I4
                // for its uint16 type
                //

                V_VT(&vt) = VT_I4;
                V_I4(&vt) = uscResponses;

                hr = pwcoInstance->Put(
                    c_wszResponseCount,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the outgoing port
                //

                V_VT(&vt) = VT_I4;
                V_I4(&vt) = usOutgoingPort;

                hr = pwcoInstance->Put(
                    c_wszOutgoingPort,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the outgoing IP protocol
                //

                V_VT(&vt) = VT_UI1;
                V_UI1(&vt) = ucOutgoingIPProtocol;

                hr = pwcoInstance->Put(
                    c_wszOutgoingIPProtocol,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set the builtin value to false
                //

                hr = SetBooleanValue(
                        pwcoInstance,
                        c_wszBuiltIn,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // New protocols are disabled by default
                //

                hr = SetBooleanValue(
                        pwcoInstance,
                        c_wszEnabled,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                IWbemCallResult *pResult;

                //
                // Write the instance to the store
                //

                pResult = NULL;
                hr = m_piwsHomenet->PutInstance(
                        pwcoInstance,
                        WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pResult
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    pwcoInstance->Release();
                    pwcoInstance = NULL;

                    hr = pResult->GetResultString(WBEM_INFINITE, &bstr);

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        hr = GetWmiObjectFromPath(
                                m_piwsHomenet,
                                bstr,
                                &pwcoInstance
                                );

                        SysFreeString(bstr);
                    }

                    pResult->Release();
                }
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Create the object to return
                //

                CComObject<CHNetAppProtocol> *pProt;

                hr = CComObject<CHNetAppProtocol>::CreateInstance(&pProt);

                if (S_OK == hr)
                {
                    pProt->AddRef();

                    hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                    if (S_OK == hr)
                    {
                        hr = pProt->QueryInterface(
                                IID_PPV_ARG(IHNetApplicationProtocol, ppProtocol)
                                );
                    }

                    pProt->Release();
                }
            }

            if (NULL != pwcoInstance)
            {
                pwcoInstance->Release();
            }
        }

        SafeArrayDestroy(psa);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::EnumPortMappingProtocols(
    IEnumHNetPortMappingProtocols **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrClass;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
    }

    if (S_OK == hr)
    {
        bstrClass = SysAllocString(c_wszHnetPortMappingProtocol);
        if (NULL == bstrClass)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Query the WMI store for HNet_PortMappingProtocol instances.
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->CreateInstanceEnum(
                bstrClass,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrClass);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetPortMappingProtocols> *pEnum;

        hr = CComObject<CEnumHNetPortMappingProtocols>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingProtocols, ppEnum)
                        );
            }

            pEnum->Release();

        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreatePortMappingProtocol(
    OLECHAR *pszwName,
    UCHAR ucIPProtocol,
    USHORT usPort,
    IHNetPortMappingProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProtocol = NULL;

        if (NULL == pszwName
                 || 0 == ucIPProtocol
                 || 0 == usPort)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Check to see if there already exists a protocol with
        // the same port/protocol combination
        //

        if (PortMappingProtocolExists(
                m_piwsHomenet,
                m_bstrWQL,
                usPort,
                ucIPProtocol
                ))
        {
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

    }

    if (S_OK == hr)
    {
        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetPortMappingProtocol,
                &pwcoInstance
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(pszwName);

        if (NULL != V_BSTR(&vt))
        {
            //
            // Write the name
            //

            hr = pwcoInstance->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the port
            //

            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoInstance->Put(
                c_wszPort,
                0,
                &vt,
                NULL
                );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the IP protocol
            //

            V_VT(&vt) = VT_UI1;
            V_UI1(&vt) = ucIPProtocol;

            hr = pwcoInstance->Put(
                c_wszIPProtocol,
                0,
                &vt,
                NULL
                );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set BuiltIn to false
            //

            hr = SetBooleanValue(
                    pwcoInstance,
                    c_wszBuiltIn,
                    FALSE
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            IWbemCallResult *pResult;

            //
            // Write the instance to the store
            //

            pResult = NULL;
            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pResult
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                pwcoInstance->Release();
                pwcoInstance = NULL;

                hr = pResult->GetResultString(WBEM_INFINITE, &bstr);

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = GetWmiObjectFromPath(
                            m_piwsHomenet,
                            bstr,
                            &pwcoInstance
                            );

                    SysFreeString(bstr);
                }

                pResult->Release();
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create the object to return
            //

            CComObject<CHNetPortMappingProtocol> *pProt;

            hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProt);

            if (S_OK == hr)
            {
                pProt->AddRef();

                hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                if (S_OK == hr)
                {
                    hr = pProt->QueryInterface(
                            IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                            );
                }

                pProt->Release();

            }
        }

        if (NULL != pwcoInstance)
        {
            pwcoInstance->Release();
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
         SendPortMappingListChangeNotification();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::FindPortMappingProtocol(
    GUID *pGuid,
    IHNetPortMappingProtocol **ppProtocol
    )

{
    BSTR bstr;
    HRESULT hr = S_OK;
    OLECHAR *pwszGuid;
    OLECHAR wszPath[MAX_PATH];
    IWbemClassObject *pwcoInstance;

    if (NULL != ppProtocol)
    {
        *ppProtocol = NULL;
        if (NULL == pGuid)
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Convert the GUID to string form
        //

        hr = StringFromCLSID(*pGuid, &pwszGuid);
    }

    if (S_OK == hr)
    {
        //
        // Construct the path to the desired protocol
        //

        int count =
            _snwprintf(
                wszPath,
                MAX_PATH,
                L"%s.%s=\"%s\"",
                c_wszHnetPortMappingProtocol,
                c_wszId,
                pwszGuid
                );

        _ASSERT(count > 0);
        CoTaskMemFree(pwszGuid);

        bstr = SysAllocString(wszPath);
        if (NULL != bstr)
        {
            hr = GetWmiObjectFromPath(m_piwsHomenet, bstr, &pwcoInstance);
            SysFreeString(bstr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        CComObject<CHNetPortMappingProtocol> *pProtocol;
        hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProtocol);

        if (SUCCEEDED(hr))
        {
            pProtocol->AddRef();

            hr = pProtocol->Initialize(m_piwsHomenet, pwcoInstance);
            if (SUCCEEDED(hr))
            {
                hr = pProtocol->QueryInterface(
                        IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                        );
            }

            pProtocol->Release();
        }

        pwcoInstance->Release();
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetCfgMgr::CopyLoggingInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_FW_LOGGING_SETTINGS *pfwSettings
    )

{
    HRESULT hr;
    VARIANT vt;
    BSTR bstrPath;

    _ASSERT(pwcoInstance);
    _ASSERT(pfwSettings);

    //
    // Zero-out settings structure
    //

    ZeroMemory(pfwSettings, sizeof(*pfwSettings));

    //
    // Get the Path property.
    //

    hr = pwcoInstance->Get(
            c_wszPath,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate space to hold the string
        //

        pfwSettings->pszwPath =
            (LPWSTR) CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                    * sizeof(OLECHAR));

        if (NULL != pfwSettings->pszwPath)
        {
            //
            // Copy string over
            //

            wcscpy(pfwSettings->pszwPath, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        //
        // Free the returned BSTR
        //

        VariantClear(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get max file size
        //

        hr = pwcoInstance->Get(
                c_wszMaxFileSize,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_I4 == V_VT(&vt));

            pfwSettings->ulMaxFileSize = V_I4(&vt);
            VariantClear(&vt);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get log dropped packets value
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszLogDroppedPackets,
                &pfwSettings->fLogDroppedPackets
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get log connections value
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszLogConnections,
                &pfwSettings->fLogConnections
                );

    }

    if (FAILED(hr) && NULL != pfwSettings->pszwPath)
    {
        CoTaskMemFree(pfwSettings->pszwPath);
    }

    return hr;
}

HRESULT
CHNetCfgMgr::CopyStructToLoggingInstance(
    HNET_FW_LOGGING_SETTINGS *pfwSettings,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(pwcoInstance);
    _ASSERT(pfwSettings);


    //
    // Wrap the path in a BSTR in a varaint
    //

    VariantInit(&vt);
    V_VT(&vt) = VT_BSTR;
    V_BSTR(&vt) = SysAllocString(pfwSettings->pszwPath);
    if (NULL == V_BSTR(&vt))
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        //
        // Set the Path property.
        //

        hr = pwcoInstance->Put(
                c_wszPath,
                0,
                &vt,
                NULL
                );

        //
        // Clearing the variant will free the BSTR we allocated
        // above.
        //

        VariantClear(&vt);
    }


    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set max file size
        //

        V_VT(&vt) = VT_I4;
        V_I4(&vt) = pfwSettings->ulMaxFileSize;

        hr = pwcoInstance->Put(
                c_wszMaxFileSize,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set log dropped packets value
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszLogDroppedPackets,
                pfwSettings->fLogDroppedPackets
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set log connections value
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszLogConnections,
                pfwSettings->fLogConnections
                );
    }

    return hr;
}

HRESULT
CHNetCfgMgr::InstallBridge(
    GUID                *pguid,
    INetCfg             *pnetcfgExisting
    )
{
    HRESULT                 hr = S_OK;
    INetCfg                 *pnetcfg = NULL;
    INetCfgLock             *pncfglock = NULL;
    INetCfgComponent        *pncfgcomp = NULL;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we can't acquire NetCfg.
        if( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    // ===================================================================
    // (cut here)
    //
    // Check if the bridge component already exists
    //
    // **
    // Remove this check when it becomes legal to have
    // multiple bridges
    // **
    //
    hr = pnetcfg->FindComponent(
            c_wszSBridgeMPID,
            &pncfgcomp
            );

    // S_OK indicates that the bridge component is present, which is BAD.
    // We take any other success code to indicate that the search succeeded,
    // but that the bridge component was not present (which is what we want).
    // We take failure codes to mean the search blew up.
    if ( S_OK == hr )
    {
        // Bridge was present
        pncfgcomp->Release();
        hr = E_UNEXPECTED;
    }
    // (cut here)
    // ===================================================================

    if ( SUCCEEDED(hr) )
    {
        const GUID          guidClass = GUID_DEVCLASS_NET;
        INetCfgClassSetup   *pncfgsetup = NULL;

        //
        // Recover the NetCfgClassSetup interface
        //
        hr = pnetcfg->QueryNetCfgClass(
                &guidClass,
                IID_PPV_ARG(INetCfgClassSetup, &pncfgsetup)
                );

        if ( SUCCEEDED(hr) )
        {
            //
            // Install the bridge miniport component
            //
            hr = pncfgsetup->Install(
                    c_wszSBridgeMPID,
                    NULL,
                    NSF_PRIMARYINSTALL,
                    0,
                    NULL,
                    NULL,
                    &pncfgcomp
                    );

            if ( SUCCEEDED(hr) )
            {
                hr = pncfgcomp->GetInstanceGuid(pguid);
                pncfgcomp->Release();
            }

            pncfgsetup->Release();
        }
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Signal that the bridge should be drawn
            SignalNewConnection( pguid );
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}

HRESULT
CHNetCfgMgr::CreateConnectionAndPropertyInstances(
    GUID *pGuid,
    BOOLEAN fLanConnection,
    LPCWSTR pszwName,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

{
    HRESULT hr;
    BSTR bstr = NULL;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties;
    IWbemCallResult *pResult;
    VARIANT vt;

    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != pszwName);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // Create the HNet_Connection instance
    //

    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszHnetConnection,
            &pwcoConnection
            );

    //
    // Fill out the HNet_Connection instance
    //

    if (WBEM_S_NO_ERROR == hr)
    {
        LPOLESTR wszGuid;

        //
        // Set GUID property
        //

        hr = StringFromCLSID(*pGuid, &wszGuid);

        if (S_OK == hr)
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(wszGuid);

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoConnection->Put(
                        c_wszGuid,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            CoTaskMemFree(wszGuid);
        }

        //
        // Set Name property
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(pszwName);

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoConnection->Put(
                        c_wszName,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set the IsLan property
            //

            hr = SetBooleanValue(
                    pwcoConnection,
                    c_wszIsLanConnection,
                    fLanConnection
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Commit the object and retrieve its path
            //

            pResult = NULL;
            hr = m_piwsHomenet->PutInstance(
                    pwcoConnection,
                    WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pResult
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                pwcoConnection->Release();
                pwcoConnection = NULL;

                hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                pResult->Release();

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = GetWmiObjectFromPath(
                            m_piwsHomenet,
                            bstr,
                            &pwcoConnection
                            );

                    if (FAILED(hr))
                    {
                        SysFreeString(bstr);
                        bstr = NULL;
                    }

                    //
                    // The bstr will be freed below on success
                    //
                }
            }
        }

        if (FAILED(hr) && NULL != pwcoConnection)
        {
            //
            // Something went wrong -- get rid
            // of the instance we created
            //

            pwcoConnection->Release();
            pwcoConnection = NULL;
        }
    }

    if (S_OK == hr)
    {
        //
        // Create the HNet_ConnectionProperties instance
        //

        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetProperties,
                &pwcoProperties
                );

        //
        // Fill out the HNet_ConnectionProperties instance
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set the path to our connection
            //

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = bstr;
            hr = pwcoProperties->Put(
                    c_wszConnection,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsFirewalled,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPublic,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPrivate,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Commit properties instance to the store
                //

                pResult = NULL;
                hr = m_piwsHomenet->PutInstance(
                        pwcoProperties,
                        WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pResult
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    pwcoProperties->Release();
                    pwcoProperties = NULL;

                    hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                    pResult->Release();

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        hr = GetWmiObjectFromPath(
                                m_piwsHomenet,
                                bstr,
                                &pwcoProperties
                                );

                        SysFreeString(bstr);
                    }
                }
            }

            if (FAILED(hr))
            {
                //
                // Something went wrong -- get rid of the instances
                // we created. We also need to delete the connection
                // instance from the store.
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoConnection);

                pwcoConnection->Release();
                pwcoConnection = NULL;

                if (NULL != pwcoProperties)
                {
                    pwcoProperties->Release();
                    pwcoProperties = NULL;
                }
            }
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Transferring reference, so skip release on pwco[x] and
        // addref on ppwco[x]
        //

        *ppwcoConnection = pwcoConnection;
        *ppwcoProperties = pwcoProperties;
    }

    return hr;
}

BOOLEAN
CHNetCfgMgr::ProhibitedByPolicy(
    DWORD dwPerm
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fProhibited = FALSE;

    if (NULL == m_pNetConnUiUtil)
    {
        Lock();

        if (NULL == m_pNetConnUiUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionUiUtilities,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG(INetConnectionUiUtilities, &m_pNetConnUiUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        fProhibited = !m_pNetConnUiUtil->UserHasPermission(dwPerm);
    }

    return fProhibited;
}

HRESULT
CHNetCfgMgr::UpdateNetman()

{
    HRESULT hr = S_OK;

    if (NULL == m_pNetConnHNetUtil)
    {
        Lock();

        if (NULL == m_pNetConnHNetUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionHNetUtil,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG(INetConnectionHNetUtil, &m_pNetConnHNetUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pNetConnHNetUtil->NotifyUpdate();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnbrgcon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R G C O N . C P P
//
//  Contents:   CHNBridgedConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Ojbect initialization
//

HRESULT
CHNBridgedConn::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection
    )

{
    return InitializeFromConnection(piwsNamespace, pwcoConnection);
}

//
// IHNetBridgedConnection methods
//

STDMETHODIMP
CHNBridgedConn::GetBridge(
    IHNetBridge **ppBridge
    )

{
    HRESULT                 hr;

    if (NULL != ppBridge)
    {
        *ppBridge = NULL;
        hr = GetBridgeConnection( m_piwsHomenet, ppBridge );
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNBridgedConn::RemoveFromBridge(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Unbind ourselves from the bridge
        //

        hr = UnbindFromBridge( pnetcfgExisting );
    }

    if (S_OK == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //
        UpdateNetman();
    }

    return hr;
}

HRESULT
CHNBridgedConn::CopyBridgeBindings(
    IN INetCfgComponent     *pnetcfgAdapter,
    IN INetCfgComponent     *pnetcfgBridge
    )
{
    HRESULT                     hr = S_OK;
    INetCfgComponentBindings    *pnetcfgAdapterBindings;

    //
    // Get the adapter's ComponentBindings interface
    //
    hr = pnetcfgAdapter->QueryInterface(
            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgAdapterBindings)
            );

    if (S_OK == hr)
    {
        IEnumNetCfgBindingPath  *penumPaths;

        //
        // Get the list of binding paths for the adapter
        //
        hr = pnetcfgAdapterBindings->EnumBindingPaths(
                EBP_ABOVE,
                &penumPaths
                );

        if (S_OK == hr)
        {
            ULONG               ulCount1, ulCount2;
            INetCfgBindingPath  *pnetcfgPath;

            while( (S_OK == penumPaths->Next(1, &pnetcfgPath, &ulCount1) ) )
            {
                INetCfgComponent        *pnetcfgOwner;

                //
                // Get the owner of this path
                //
                hr = pnetcfgPath->GetOwner( &pnetcfgOwner );

                if (S_OK == hr)
                {
                    INetCfgComponentBindings    *pnetcfgOwnerBindings;

                    //
                    // Need the ComponentBindings interface for the owner
                    //
                    hr = pnetcfgOwner->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgOwnerBindings)
                            );

                    if (S_OK == hr)
                    {
                        LPWSTR              lpwstrId;

                        //
                        // The rule is, the binding should be disabled if it
                        // represents the bridge protocol or something that
                        // is not bound to the bridge that the adapter is
                        // coming out of.
                        //
                        // If the binding is one that the bridge has, it is
                        // enabled.
                        //
                        // This makes the adapter's bindings mirror those of
                        // the bridge it just left.
                        //
                        hr = pnetcfgOwner->GetId( &lpwstrId );

                        if (S_OK == hr)
                        {
                            UINT            cmp = _wcsicmp(lpwstrId, c_wszSBridgeSID);

                            hr = pnetcfgOwnerBindings->IsBoundTo( pnetcfgBridge );

                            if ( (S_OK == hr) && (cmp != 0) )
                            {
                                // Activate this binding path
                                hr = pnetcfgOwnerBindings->BindTo(pnetcfgAdapter);
                            }
                            else
                            {
                                // Deactivate this path
                                hr = pnetcfgOwnerBindings->UnbindFrom(pnetcfgAdapter);
                            }

                            CoTaskMemFree(lpwstrId);
                        }

                        pnetcfgOwnerBindings->Release();
                    }

                    pnetcfgOwner->Release();
                }

                pnetcfgPath->Release();
            }

            penumPaths->Release();
        }

        pnetcfgAdapterBindings->Release();
    }

    return hr;
}

HRESULT
CHNBridgedConn::UnbindFromBridge(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    GUID                *pguidAdapter;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we can't acquire NetCfg.
        if( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    //
    // Get our own device GUID
    //
    hr = GetGuid (&pguidAdapter);

    if ( SUCCEEDED(hr) )
    {
        IHNetBridge     *pbridge;

        //
        // Get our bridge
        //
        hr = GetBridge (&pbridge);

        if ( SUCCEEDED(hr) )
        {
            IHNetConnection *phnetconBridge;

            //
            // Get the bridge's IHNetConnection interface
            //
            hr = pbridge->QueryInterface(
                    IID_PPV_ARG(IHNetConnection, &phnetconBridge)
                    );

            if ( SUCCEEDED(hr) )
            {
                GUID        *pguidBridge;

                // Get the bridge's device GUID
                hr = phnetconBridge->GetGuid (&pguidBridge);

                if ( SUCCEEDED(hr) )
                {
                    INetCfgComponent    *pnetcfgcompAdapter;

                    hr = FindAdapterByGUID(
                            pnetcfg,
                            pguidAdapter,
                            &pnetcfgcompAdapter
                            );

                    if ( SUCCEEDED(hr) )
                    {
                        INetCfgComponent    *pnetcfgcompBridge;

                        hr = FindAdapterByGUID(
                            pnetcfg,
                            pguidBridge,
                            &pnetcfgcompBridge
                            );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = CopyBridgeBindings(
                                    pnetcfgcompAdapter,
                                    pnetcfgcompBridge
                                    );

                            pnetcfgcompBridge->Release();
                        }

                        pnetcfgcompAdapter->Release();
                    }

                    CoTaskMemFree(pguidBridge);
                }

                phnetconBridge->Release();
            }

            pbridge->Release();
        }

        CoTaskMemFree(pguidAdapter);
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Refresh the UI for this connection
            RefreshNetConnectionsUI();
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnicsprv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P R V . C P P
//
//  Contents:   CHNIcsPrivateConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetIcsPrivateConnection methods
//

STDMETHODIMP
CHNIcsPrivateConn::RemoveFromIcs()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        //
        // Change our IsIcsPrivate property to false
        //
        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPrivate,
                FALSE
                );
                
        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Reconfig interface from backup settings
        //
        
        RestoreIpConfiguration();
    }



    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnetconn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N E T C O N N . C P P
//
//  Contents:   CHNetConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Prototype for iphlpapi routine. For some reason, this isn't defined
// in any header.
//

extern "C"
DWORD
APIENTRY
SetAdapterIpAddress(LPSTR AdapterName,
                    BOOL EnableDHCP,
                    ULONG IPAddress,
                    ULONG SubnetMask,
                    ULONG DefaultGateway
                    );

//
// CLSIDs for connection objects. We don't want to pull in all of the
// other guids that are defined in nmclsid.h, so we copy these
// into here
//

#define INITGUID
#include <guiddef.h>
DEFINE_GUID(CLSID_DialupConnection,
0xBA126AD7,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnection,
0xBA126ADB,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
#undef INITGUID

//
// ATL Methods
//

HRESULT
CHNetConn::FinalConstruct()

{
    HRESULT hr = S_OK;

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CHNetConn::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrConnection) SysFreeString(m_bstrConnection);
    if (m_bstrProperties) SysFreeString(m_bstrProperties);
    if (m_pNetConn) m_pNetConn->Release();
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    if (m_wszName) CoTaskMemFree(m_wszName);
    if (m_pGuid) CoTaskMemFree(m_pGuid);
    if (m_pNetConnUiUtil) m_pNetConnUiUtil->Release();
    if (m_pNetConnHNetUtil) m_pNetConnHNetUtil->Release();
    if (m_pNetConnRefresh) m_pNetConnRefresh->Release();

    return S_OK;
}

//
// Ojbect initialization
//

HRESULT
CHNetConn::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoProperties
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoConnection;
    VARIANT vt;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoProperties);

    //
    // Store pointer to our namespace.
    //

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    //
    // Get the path to the properties
    //

    hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the path to the HNet_Connection from our properties
        //

        hr = pwcoProperties->Get(
                c_wszConnection,
                0,
                &vt,
                NULL,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        m_bstrConnection = V_BSTR(&vt);

        //
        // BSTR ownership transfered to object
        //

        VariantInit(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the underying connection object
        //

        hr = GetConnectionObject(&pwcoConnection);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // See if this is a lan connection
        //

        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );

        pwcoConnection->Release();
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFromConnection(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoProperties;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);

    //
    // Store pointer to our namespace.
    //

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    //
    // Get the path to our connection
    //

    hr = GetWmiPathFromObject(pwcoConnection, &m_bstrConnection);

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the HNet_ConnectionProperties for our connection and
        // store its path
        //

        hr = GetPropInstanceFromConnInstance(
                piwsNamespace,
                pwcoConnection,
                &pwcoProperties
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);

            pwcoProperties->Release();
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // See if this is a lan connection
        //

        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFromInstances(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject *pwcoProperties
    )

{
    HRESULT hr;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);
    _ASSERT(NULL != pwcoProperties);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    hr = GetWmiPathFromObject(pwcoConnection, &m_bstrConnection);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFull(
    IWbemServices *piwsNamespace,
    BSTR bstrConnection,
    BSTR bstrProperties,
    BOOLEAN fLanConnection
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrConnection);
    _ASSERT(NULL != bstrProperties);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();
    m_fLanConnection = fLanConnection;

    m_bstrConnection = SysAllocString(bstrConnection);
    if (NULL != m_bstrConnection)
    {
        m_bstrProperties = SysAllocString(bstrProperties);
        if (NULL == m_bstrProperties)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CHNetConn::SetINetConnection(
    INetConnection *pConn
    )

{
    Lock();

    _ASSERT(NULL == m_pNetConn);
    _ASSERT(NULL != pConn);

    m_pNetConn = pConn;
    m_pNetConn->AddRef();

    Unlock();

    return S_OK;
}

//
// IHNetConnection methods
//

STDMETHODIMP
CHNetConn::GetINetConnection(
    INetConnection **ppNetConnection
    )

{
    HRESULT hr = S_OK;
    GUID *pGuid;

    if (NULL != ppNetConnection)
    {
        *ppNetConnection = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        Lock();

        if (NULL != m_pNetConn)
        {
            //
            // We've already cached away a pointer.
            //

            *ppNetConnection = m_pNetConn;
            (*ppNetConnection)->AddRef();
        }
        else
        {
            //
            // We don't have a cached pointer. Create the correct
            // connection object type and initialize appropriately.
            //

            hr = GetGuidInternal(&pGuid);

            if (S_OK == hr)
            {
                if (m_fLanConnection)
                {
                    INetLanConnection *pLanConnection;

                    hr = CoCreateInstance(
                            CLSID_LanConnection,
                            NULL,
                            CLSCTX_SERVER,
                            IID_PPV_ARG(INetLanConnection, &pLanConnection)
                            );

                    if (SUCCEEDED(hr))
                    {
                        LANCON_INFO lanInfo;

                        //
                        // We must set the proxy blanket on the object we just
                        // created.
                        //

                        SetProxyBlanket(pLanConnection);
                        
                        //
                        // We don't need to include the name to initialize
                        // a LAN connection -- the guid is sufficient.
                        //

                        lanInfo.szwConnName = NULL;
                        lanInfo.fShowIcon = TRUE;
                        lanInfo.guid = *pGuid;

                        hr = pLanConnection->SetInfo(
                                LCIF_COMP,
                                &lanInfo
                                );

                        if (SUCCEEDED(hr))
                        {
                            hr = pLanConnection->QueryInterface(
                                    IID_PPV_ARG(
                                        INetConnection,
                                        ppNetConnection
                                        )
                                    );

                            if (SUCCEEDED(hr))
                            {
                                SetProxyBlanket(*ppNetConnection);
                            }
                        }

                        pLanConnection->Release();
                                
                    }
                }
                else
                {
                    INetRasConnection *pRasConnection;

                    hr = CoCreateInstance(
                            CLSID_DialupConnection,
                            NULL,
                            CLSCTX_SERVER,
                            IID_PPV_ARG(INetRasConnection, &pRasConnection)
                            );

                    if (SUCCEEDED(hr))
                    {
                        OLECHAR *pszwName;
                        OLECHAR *pszwPath;

                        //
                        // We must set the proxy blanket on the object we just
                        // created.
                        //

                        SetProxyBlanket(pRasConnection);
                        
                        //
                        // We need to obtain the name and path of a RAS
                        // connection in order to initialize it.
                        //

                        hr = GetRasConnectionName(&pszwName);

                        if (S_OK == hr)
                        {
                            hr = GetRasPhonebookPath(&pszwPath);

                            if (S_OK == hr)
                            {
                                RASCON_INFO rasInfo;

                                rasInfo.pszwPbkFile = pszwPath;
                                rasInfo.pszwEntryName = pszwName;
                                rasInfo.guidId = *pGuid;

                                hr = pRasConnection->SetRasConnectionInfo(
                                        &rasInfo
                                        );

                                if (SUCCEEDED(hr))
                                {
                                    hr = pRasConnection->QueryInterface(
                                            IID_PPV_ARG(
                                                INetConnection,
                                                ppNetConnection
                                                )
                                            );

                                    if (SUCCEEDED(hr))
                                    {
                                        SetProxyBlanket(*ppNetConnection);
                                    }
                                }

                                CoTaskMemFree(pszwPath);
                            }
                            
                            CoTaskMemFree(pszwName);
                        }

                        pRasConnection->Release();
                    }
                }
                
                if (SUCCEEDED(hr))
                {
                    //
                    // Cache the connection
                    //

                    m_pNetConn = *ppNetConnection;
                    m_pNetConn->AddRef();
                    hr = S_OK;
                }
            }
        }

        Unlock();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetGuid(
    GUID **ppGuid
    )

{
    HRESULT hr = S_OK;

    if (NULL == ppGuid)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Allocate memory for the guid
        //

        *ppGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL == *ppGuid)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        GUID *pGuid;

        //
        // Get our guid
        //

        hr = GetGuidInternal(&pGuid);

        if (SUCCEEDED(hr))
        {
            CopyMemory(
                reinterpret_cast<PVOID>(*ppGuid),
                reinterpret_cast<PVOID>(pGuid),
                sizeof(GUID)
                );
        }
        else
        {
            CoTaskMemFree(*ppGuid);
            *ppGuid = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    INetConnection *pConn;
    NETCON_PROPERTIES *pProps;
    OLECHAR *pszwOldName = NULL;

    if (NULL != ppszwName)
    {
        *ppszwName = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        Lock();

        hr = GetINetConnection(&pConn);

        if (S_OK == hr)
        {
            hr = pConn->GetProperties(&pProps);

            if (SUCCEEDED(hr))
            {
                pszwOldName = m_wszName;
                m_wszName = pProps->pszwName;

                //
                // We can't call NcFreeNetconProperties, as that
                // would free the string pointer we just tucked away.
                //

                CoTaskMemFree(pProps->pszwDeviceName);
                CoTaskMemFree(pProps);
                hr = S_OK;
            }

            pConn->Release();
        }

        //
        // If the new name is not the same as the old name
        // store the new name
        //

        if (S_OK == hr
            && (NULL == pszwOldName
                || 0 != wcscmp(pszwOldName, m_wszName)))
        {
            IWbemClassObject *pwcoConnection;
            HRESULT hr2;
            VARIANT vt;

            hr2 = GetConnectionObject(&pwcoConnection);

            if (WBEM_S_NO_ERROR == hr2)
            {
                //
                // Write the retrieved name to the store. (While the stored
                // name is used only for debugging purposes, it's worth the
                // hit to keep it up to date.)
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(m_wszName);

                if (NULL != V_BSTR(&vt))
                {
                    hr2 = pwcoConnection->Put(
                            c_wszName,
                            0,
                            &vt,
                            NULL
                            );

                    VariantClear(&vt);

                    if (WBEM_S_NO_ERROR == hr2)
                    {
                        m_piwsHomenet->PutInstance(
                            pwcoConnection,
                            WBEM_FLAG_UPDATE_ONLY,
                            NULL,
                            NULL
                            );
                    }
                }

                pwcoConnection->Release();
            }
        }

        if (S_OK == hr)
        {
            ULONG ulSize = (wcslen(m_wszName) + 1) * sizeof(OLECHAR);

            *ppszwName = reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc(ulSize)
                            );

            if (NULL != *ppszwName)
            {
                CopyMemory(
                    reinterpret_cast<PVOID>(*ppszwName),
                    reinterpret_cast<PVOID>(m_wszName),
                    ulSize
                    );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        Unlock();
    }

    if (NULL != pszwOldName)
    {
        CoTaskMemFree(pszwOldName);
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetRasPhonebookPath(
    OLECHAR **ppszwPath
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoConnection;

    if (NULL != ppszwPath)
    {
        *ppszwPath = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (TRUE == m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionObject(&pwcoConnection);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoConnection->Get(
                c_wszPhonebookPath,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoConnection->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        *ppszwPath = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                        * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwPath)
        {
            wcscpy(*ppszwPath, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetProperties(
    HNET_CONN_PROPERTIES **ppProperties
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppProperties)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProperties = reinterpret_cast<HNET_CONN_PROPERTIES*>(
                            CoTaskMemAlloc(sizeof(HNET_CONN_PROPERTIES))
                            );

        if (NULL == *ppProperties)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = InternalGetProperties(pwcoProperties, *ppProperties);
            pwcoProperties->Release();
        }

        if (FAILED(hr))
        {
            CoTaskMemFree(*ppProperties);
            *ppProperties = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetControlInterface(
    REFIID iid,
    void **ppv
    )

{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES Props;

    if (NULL != ppv)
    {
        *ppv = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // See if a simple QI will produce the desired interface
        //

        hr = QueryInterface(iid, ppv);
        if (FAILED(hr))
        {
            //
            // Nope. Get our properties and see if it's appropriate to
            // provide the requested control interface.
            //

            IWbemClassObject *pwcoProperties;

            hr = GetConnectionPropertiesObject(&pwcoProperties);

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = InternalGetProperties(pwcoProperties, &Props);
                pwcoProperties->Release();
            }

            if (S_OK == hr)
            {
                if (IsEqualGUID(
                        __uuidof(IHNetFirewalledConnection),
                        iid
                        ))
                {
                    if (TRUE == Props.fFirewalled)
                    {
                        CComObject<CHNFWConn> *pfwConn;
                        hr = CComObject<CHNFWConn>::CreateInstance(&pfwConn);
                        if (SUCCEEDED(hr))
                        {
                            pfwConn->AddRef();

                            hr = pfwConn->InitializeFull(
                                            m_piwsHomenet,
                                            m_bstrConnection,
                                            m_bstrProperties,
                                            m_fLanConnection
                                            );

                            if (SUCCEEDED(hr))
                            {
                                hr = pfwConn->QueryInterface(iid, ppv);
                            }

                            pfwConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetIcsPublicConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fIcsPublic)
                    {
                        CComObject<CHNIcsPublicConn> *pIcsPubConn;
                        hr = CComObject<CHNIcsPublicConn>::CreateInstance(&pIcsPubConn);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPubConn->AddRef();

                            hr = pIcsPubConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pIcsPubConn->QueryInterface(iid, ppv);
                            }

                            pIcsPubConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetIcsPrivateConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fIcsPrivate)
                    {
                        CComObject<CHNIcsPrivateConn> *pIcsPrvConn;
                        hr = CComObject<CHNIcsPrivateConn>::CreateInstance(&pIcsPrvConn);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPrvConn->AddRef();

                            hr = pIcsPrvConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pIcsPrvConn->QueryInterface(iid, ppv);
                            }

                            pIcsPrvConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetBridge),
                            iid
                            ))
                {
                    if (TRUE == Props.fBridge)
                    {
                        CComObject<CHNBridge> *pBridge;
                        hr = CComObject<CHNBridge>::CreateInstance(&pBridge);
                        if (SUCCEEDED(hr))
                        {
                            pBridge->AddRef();

                            hr = pBridge->InitializeFull(
                                            m_piwsHomenet,
                                            m_bstrConnection,
                                            m_bstrProperties,
                                            m_fLanConnection
                                            );

                            if (SUCCEEDED(hr))
                            {
                                hr = pBridge->QueryInterface(iid, ppv);
                            }

                            pBridge->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetBridgedConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fPartOfBridge)
                    {
                        CComObject<CHNBridgedConn> *pBridgeConn;
                        hr = CComObject<CHNBridgedConn>::CreateInstance(&pBridgeConn);
                        if (SUCCEEDED(hr))
                        {
                            pBridgeConn->AddRef();

                            hr = pBridgeConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pBridgeConn->QueryInterface(iid, ppv);
                            }

                            pBridgeConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else
                {
                    //
                    // Unknown control interface
                    //

                    hr = E_NOINTERFACE;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::Firewall(
    IHNetFirewalledConnection **ppFirewalledConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppFirewalledConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppFirewalledConn = NULL;

        //
        // We fail immediately if firewalling is prohibited by policy,
        // or if the NAT routing protocol is installed.
        //

        if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
        {
            hr = HN_E_POLICY;
        }

        if (IsRoutingProtocolInstalled(MS_IP_NAT))
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (S_OK == hr)
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeFirewalled || TRUE == hnProps.fFirewalled)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                //
                // Set the firewalled property to true
                //

                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsFirewalled,
                        TRUE
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create the new object
            //

            CComObject<CHNFWConn> *pfwConn;
            hr = CComObject<CHNFWConn>::CreateInstance(&pfwConn);

            if (SUCCEEDED(hr))
            {
                pfwConn->AddRef();

                hr = pfwConn->InitializeFull(
                        m_piwsHomenet,
                        m_bstrConnection,
                        m_bstrProperties,
                        m_fLanConnection
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pfwConn->QueryInterface(
                            IID_PPV_ARG(IHNetFirewalledConnection, ppFirewalledConn)
                            );
                }

                pfwConn->Release();
            }
        }

        pwcoProperties->Release();
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppFirewalledConn)->Unfirewall();
            (*ppFirewalledConn)->Release();
            *ppFirewalledConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();

    }

    return hr;
}

STDMETHODIMP
CHNetConn::SharePublic(
    IHNetIcsPublicConnection **ppIcsPublicConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppIcsPublicConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIcsPublicConn = NULL;

        //
        // We fail immediately if sharing is prohibited by policy,
        // or if the NAT routing protocol is installed.
        //

        if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
        {
            hr = HN_E_POLICY;
        }

        if (IsRoutingProtocolInstalled(MS_IP_NAT))
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeIcsPublic || TRUE == hnProps.fIcsPublic)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                //
                // Set the ICS Public property to true
                //
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPublic,
                        TRUE
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create the new object
        //

        CComObject<CHNIcsPublicConn> *pIcsConn;
        hr = CComObject<CHNIcsPublicConn>::CreateInstance(&pIcsConn);

        if (SUCCEEDED(hr))
        {
            pIcsConn->AddRef();

            hr = pIcsConn->InitializeFull(
                    m_piwsHomenet,
                    m_bstrConnection,
                    m_bstrProperties,
                    m_fLanConnection
                    );

            if (SUCCEEDED(hr))
            {
                hr = pIcsConn->QueryInterface(
                        IID_PPV_ARG(IHNetIcsPublicConnection, ppIcsPublicConn)
                        );
            }

            pIcsConn->Release();
        }
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppIcsPublicConn)->Unshare();
            (*ppIcsPublicConn)->Release();
            *ppIcsPublicConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();

    }

    if (S_OK == hr && m_fLanConnection)
    {
        DWORD dwMode;
        DWORD dwLength = sizeof(dwMode);
        BOOL fResult;

        //
        // If this is a LAN connection, make sure that WinInet is
        // not set to dial always (#143885)
        //

        fResult =
            InternetQueryOption(
                NULL,
                INTERNET_OPTION_AUTODIAL_MODE,
                &dwMode,
                &dwLength
                );

        _ASSERT(TRUE == fResult);

        if (fResult && AUTODIAL_MODE_ALWAYS == dwMode)
        {
            //
            // Set the mode to contingent dialing.
            //

            dwMode = AUTODIAL_MODE_NO_NETWORK_PRESENT;
            fResult =
                InternetSetOption(
                    NULL,
                    INTERNET_OPTION_AUTODIAL_MODE,
                    &dwMode,
                    sizeof(dwMode)
                    );

            _ASSERT(TRUE == fResult);
        }
    }
    else if (S_OK == hr)
    {
        RASAUTODIALENTRYW adEntry;
        OLECHAR *pszwName;
        HRESULT hr2;

        //
        // Set this to be the RAS default connection. Errors
        // are not propagated to caller.
        //

        hr2 = GetName(&pszwName);

        if (S_OK == hr2)
        {
            ZeroMemory(&adEntry, sizeof(adEntry));
            adEntry.dwSize = sizeof(adEntry);
            wcsncpy(
                adEntry.szEntry,
                pszwName,
                sizeof(adEntry.szEntry)/sizeof(WCHAR)
                );

            RasSetAutodialAddress(
                NULL,
                0,
                &adEntry,
                sizeof(adEntry),
                1
                );

            CoTaskMemFree(pszwName);
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::SharePrivate(
    IHNetIcsPrivateConnection **ppIcsPrivateConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppIcsPrivateConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIcsPrivateConn = NULL;

        //
        // We fail immediately if sharing is prohibited by policy,
        // or if the NAT routing protocol is installed.
        //

        if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
        {
            hr = HN_E_POLICY;
        }

        if (IsRoutingProtocolInstalled(MS_IP_NAT))
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeIcsPrivate || TRUE == hnProps.fIcsPrivate)
            {
                hr = E_UNEXPECTED;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Backup current address information
            //

            hr = BackupIpConfiguration();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // if we are in ICS Upgrade, we don't need
            // to setup the private address because dhcp client won't be running in GUI Mode Setup
            // and the private tcpip addresses should be upgraded as is.
            //    
            HANDLE hIcsUpgradeEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName );
                 
            if ( NULL != hIcsUpgradeEvent )
            {
                CloseHandle( hIcsUpgradeEvent );
            }
            else
            {

                //
                // Setup addressing for private usage
                //

                hr = SetupConnectionAsPrivateLan();
            }
        }

        if (S_OK == hr)
        {
            //
            // Set the ICS Public property to true
            //

            hr = SetBooleanValue(
                    pwcoProperties,
                    c_wszIsIcsPrivate,
                    TRUE
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create the new object
        //

        CComObject<CHNIcsPrivateConn> *pIcsConn;
        hr = CComObject<CHNIcsPrivateConn>::CreateInstance(&pIcsConn);

        if (SUCCEEDED(hr))
        {
            pIcsConn->AddRef();

            hr = pIcsConn->InitializeFull(
                    m_piwsHomenet,
                    m_bstrConnection,
                    m_bstrProperties,
                    m_fLanConnection
                    );

            if (SUCCEEDED(hr))
            {
                hr = pIcsConn->QueryInterface(
                        IID_PPV_ARG(IHNetIcsPrivateConnection, ppIcsPrivateConn)
                        );
            }

            pIcsConn->Release();
        }
    }
    else
    {
        //
        // Restore backup address information
        //

        RestoreIpConfiguration();
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppIcsPrivateConn)->RemoveFromIcs();
            (*ppIcsPrivateConn)->Release();
            *ppIcsPrivateConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::EnumPortMappings(
    BOOLEAN fEnabledOnly,
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    LPWSTR wszWhere;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr && FALSE == fEnabledOnly)
    {
        //
        // Make sure that we have port mapping binding instances for
        // all of the port mapping protocols. If we're only enumerating
        // enabled protocols, then there's no need for us to create
        // anything.
        //

        hr = CreatePortMappingBindings();
    }

    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wszWhere,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr && fEnabledOnly)
        {
            LPWSTR wsz;

            //
            // Add "AND Enabled != FALSE"
            //

            hr = BuildAndString(
                    &wsz,
                    wszWhere,
                    L"Enabled != FALSE"
                    );

            delete [] wszWhere;

            if (S_OK == hr)
            {
                wszWhere = wsz;
            }
        }
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wszWhere
                );

        delete [] wszWhere;
    }

    if (S_OK == hr)
    {
        //
        // Execute the query and build the enum wrapper
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        CComObject<CEnumHNetPortMappingBindings> *pEnum;

        hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

        if (S_OK == hr)
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (S_OK == hr)
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}


STDMETHODIMP
CHNetConn::GetBindingForPortMappingProtocol(
    IHNetPortMappingProtocol *pProtocol,
    IHNetPortMappingBinding **ppBinding
    )

{
    HRESULT hr = S_OK;
    BSTR bstrConPath;
    BSTR bstrProtPath;
    IWbemClassObject *pwcoInstance;
    USHORT usPublicPort;

    if (NULL == pProtocol)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL == ppBinding)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppBinding = NULL;
    }

    if (S_OK == hr)
    {
        hr = pProtocol->GetPort(&usPublicPort);
    }

    if (S_OK == hr)
    {
        IHNetPrivate *pHNetPrivate;

        //
        // Use our private interface to get the path to the
        // protocol object
        //

        hr = pProtocol->QueryInterface(
                IID_PPV_ARG(IHNetPrivate, &pHNetPrivate)
                );

        if (S_OK == hr)
        {
            hr = pHNetPrivate->GetObjectPath(&bstrProtPath);
            pHNetPrivate->Release();
        }
    }

    //
    // Retrieve the binding instance for the protocol. If
    // it doesn't yet exist, this routine will create it.
    //

    if (S_OK == hr)
    {
        hr = GetPortMappingBindingInstance(
                m_piwsHomenet,
                m_bstrWQL,
                m_bstrConnection,
                bstrProtPath,
                usPublicPort,
                &pwcoInstance
                );

        SysFreeString(bstrProtPath);
    }


    if (S_OK == hr)
    {
        CComObject<CHNetPortMappingBinding> *pBinding;

        hr = CComObject<CHNetPortMappingBinding>::CreateInstance(&pBinding);

        if (S_OK == hr)
        {
            pBinding->AddRef();

            hr = pBinding->Initialize(m_piwsHomenet, pwcoInstance);

            if (S_OK == hr)
            {
                hr = pBinding->QueryInterface(
                        IID_PPV_ARG(IHNetPortMappingBinding, ppBinding)
                        );
            }

            pBinding->Release();
        }

        pwcoInstance->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetIcmpSettings(
    HNET_FW_ICMP_SETTINGS **ppSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings;

    if (NULL != ppSettings)
    {
        //
        // Allocate output structure
        //

        *ppSettings = reinterpret_cast<HNET_FW_ICMP_SETTINGS*>(
                        CoTaskMemAlloc(sizeof(HNET_FW_ICMP_SETTINGS))
                        );

        if (NULL == *ppSettings)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Retrieve the ICMP setting block for this connection
    //

    if (S_OK == hr)
    {
        hr = GetIcmpSettingsInstance(&pwcoSettings);
    }

    if (S_OK == hr)
    {
        //
        // Copy settings instance to struct
        //

        hr = CopyIcmpSettingsInstanceToStruct(
                pwcoSettings,
                *ppSettings
                );

        pwcoSettings->Release();
    }

    if (FAILED(hr) && NULL != *ppSettings)
    {
        CoTaskMemFree(*ppSettings);
        *ppSettings = NULL;
    }

    return hr;
}

STDMETHODIMP
CHNetConn::SetIcmpSettings(
    HNET_FW_ICMP_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fNewInstance = FALSE;
    VARIANT vt;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoSettings = NULL;
    BSTR bstr;

    if (NULL == pSettings)
    {
        hr = E_INVALIDARG;
    }

    //
    // Retrieve the ICMP setting block for this connection
    //

    if (S_OK == hr)
    {
        hr = GetIcmpSettingsInstance(&pwcoSettings);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Check to see if we need a new settings instace (i.e.,
        // the name of this instance is "Default"
        //

        hr = pwcoSettings->Get(
                c_wszName,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            if (0 == wcscmp(V_BSTR(&vt), c_wszDefault))
            {
                //
                // Need to create new settings block
                //

                fNewInstance = TRUE;
                pwcoSettings->Release();
                pwcoSettings = NULL;
            }

            VariantClear(&vt);
        }
        else
        {
            pwcoSettings->Release();
            pwcoSettings = NULL;
        }
    }

    if (WBEM_S_NO_ERROR == hr && TRUE == fNewInstance)
    {
        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetFwIcmpSettings,
                &pwcoSettings
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = CopyStructToIcmpSettingsInstance(pSettings, pwcoSettings);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        IWbemCallResult *pResult;

        //
        // Write the instance to the store
        //

        pResult = NULL;
        hr = m_piwsHomenet->PutInstance(
                pwcoSettings,
                WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pResult
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // We need to call GetResultString no matter what so that we
            // can get the proper error code if the put failed. However,
            // we only need to keep the path if this is a new instance,
            // as in that situation we need the path below to create the
            // new association object.
            //

            hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
            pResult->Release();

            if (FALSE == fNewInstance)
            {
                SysFreeString(bstr);
                bstr = NULL;
            }
        }
    }

    if (WBEM_S_NO_ERROR == hr && TRUE == fNewInstance)
    {
        BSTR bstrQuery;
        LPWSTR wsz;

        //
        // Delete the old association object, if any
        //

        hr = BuildEscapedQuotedEqualsString(
                &wsz,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr)
        {

            //
            // Query for the object associating the connection to
            // the ICMP settings block
            //

            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionIcmpSetting,
                    wsz
                    );

            delete [] wsz;

            if (S_OK == hr)
            {
                pwcoEnum = NULL;
                hr = m_piwsHomenet->ExecQuery(
                        m_bstrWQL,
                        bstrQuery,
                        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pwcoEnum
                        );

                SysFreeString(bstrQuery);
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            ULONG ulCount;
            IWbemClassObject *pwcoAssoc;

            pwcoAssoc = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoAssoc,
                &ulCount
                );

            //
            // Enum should be empty at this point
            //

            ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
            pwcoEnum->Release();

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Delete old association object
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoAssoc);
                pwcoAssoc->Release();
            }
        }

        //
        // Create new association
        //

        hr = CreateIcmpSettingsAssociation(bstr);
        SysFreeString(bstr);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Notify service of configuration change
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_CONNECTION);
    }

    if (NULL != pwcoSettings)
    {
        pwcoSettings->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::ShowAutoconfigBalloon(
    BOOLEAN *pfShowBalloon
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fShowBalloon = FALSE;
    BSTR bstrQuery;
    LPWSTR wszWhere;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != pfShowBalloon)
    {
        *pfShowBalloon = FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Autoconfig balloon is never shown for a RAS connection
    //

    if (!m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }

    //
    // Attempt to locate the HNet_ConnectionAutoconfig block
    // for this connection
    //

    if (S_OK == hr)
    {
        //
        // Build query string:
        //
        // SELECT * FROM HNet_ConnectionAutoconfig WHERE Connection = [this]
        //

        hr = BuildEscapedQuotedEqualsString(
                &wszWhere,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionAutoconfig,
                    wszWhere
                    );

            delete [] wszWhere;

        }
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;
        IWbemClassObject *pwcoInstance;

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
            WBEM_INFINITE,
            1,
            &pwcoInstance,
            &ulCount
            );

        //
        // Enum should be empty at this point
        //

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();

        if (WBEM_S_NO_ERROR == hr && 1 == ulCount)
        {
            //
            // Autoconfig block already exists
            //

            fShowBalloon = FALSE;
            pwcoInstance->Release();
        }
        else
        {
            //
            // Block doesn't exist -- create it now.
            //

            fShowBalloon = TRUE;

            hr = SpawnNewInstance(
                    m_piwsHomenet,
                    c_wszHnetConnectionAutoconfig,
                    &pwcoInstance
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                VARIANT vt;
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = m_bstrConnection;

                hr = pwcoInstance->Put(
                        c_wszConnection,
                        0,
                        &vt,
                        NULL
                        );

                //
                // We don't clear the variant as we did not
                // copy m_bstrConnection.
                //

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = m_piwsHomenet->PutInstance(
                            pwcoInstance,
                            WBEM_FLAG_CREATE_ONLY,
                            NULL,
                            NULL
                            );
                }

                pwcoInstance->Release();
            }
        }
    }

    //
    // If we think that we should show the balloon, make sure
    // that the connection isn't:
    // 1. ICS Public
    // 2. ICS Private
    // 3. Firewalled
    // 4. A bridge
    // 5. Part of a bridge
    //
    // If any of the above are true, we must have seen the connection
    // before, but just not in a way that would have caused us to
    // note it in it's autoconfig settings.
    //

    if (fShowBalloon)
    {
        IWbemClassObject *pwcoProperties;
        HNET_CONN_PROPERTIES hnProps;

        hr = GetConnectionPropertiesObject(&pwcoProperties);

        if (S_OK == hr)
        {
            hr = InternalGetProperties(pwcoProperties, &hnProps);
            pwcoProperties->Release();
        }

        if (S_OK == hr)
        {
            if (hnProps.fFirewalled
                || hnProps.fIcsPublic
                || hnProps.fIcsPrivate
                || hnProps.fBridge
                || hnProps.fPartOfBridge)
            {
                fShowBalloon = FALSE;
            }
        }
    }

    if (S_OK == hr)
    {
        *pfShowBalloon = fShowBalloon;
    }

    return hr;
}

STDMETHODIMP
CHNetConn::DeleteRasConnectionEntry()

{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IHNetFirewalledConnection *pHNetFwConnection;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoProperties;
    ULONG ulPublic;
    ULONG ulPrivate;
    BSTR bstr;

    if (m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }
    
    if (SUCCEEDED(hr))
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (SUCCEEDED(hr))
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (SUCCEEDED(hr))
        {
            if (hnProps.fIcsPublic)
            {
                CComObject<CHNetCfgMgrChild> *pCfgMgr;
                hr = CComObject<CHNetCfgMgrChild>::CreateInstance(&pCfgMgr); 
                
                if (SUCCEEDED(hr))
                {
                    pCfgMgr->AddRef();    
                    hr = pCfgMgr->Initialize(m_piwsHomenet);

                    if (SUCCEEDED(hr))
                    {
                        hr = pCfgMgr->DisableIcs(&ulPublic, &ulPrivate);
                    }

                    pCfgMgr->Release();
                }
            }

            //
            // If an error occured disabling sharing we'll still
            // try to disable firewalling.
            //

            if (hnProps.fFirewalled)
            {
                hr = GetControlInterface(
                        IID_PPV_ARG(
                            IHNetFirewalledConnection,
                            &pHNetFwConnection
                            )
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pHNetFwConnection->Unfirewall();
                    pHNetFwConnection->Release();
                }
            }
        }

        pwcoProperties->Release();

        //
        // Delete the entries relating to this connection. We'll try
        // to do this even if any of the above failed. We ignore any
        // errors that occur during the deletion prcoess (i.e., from
        // Delete[Wmi]Instance).
        //

        hr = GetIcmpSettingsInstance(&pwcoInstance);

        if (SUCCEEDED(hr))
        {
            //
            // We only want to delete this block if it's
            // not the default.
            //

            hr = GetWmiPathFromObject(pwcoInstance, &bstr);

            if (SUCCEEDED(hr))
            {
                if (0 != _wcsicmp(bstr, c_wszDefaultIcmpSettingsPath))
                {
                    m_piwsHomenet->DeleteInstance(
                        bstr,
                        0,
                        NULL,
                        NULL
                        );
                }

                SysFreeString(bstr);
            }

            pwcoInstance->Release();
        }

        //
        // Now find all object that refer to our conection object.
        //

        hr = BuildReferencesQueryBstr(
                &bstr,
                m_bstrConnection,
                NULL
                );

        if (SUCCEEDED(hr))
        {
            pwcoEnum = NULL;
            hr = m_piwsHomenet->ExecQuery(
                    m_bstrWQL,
                    bstr,
                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pwcoEnum
                    );

            SysFreeString(bstr);

            if (SUCCEEDED(hr))
            {
                ULONG ulCount;
                
                do
                {
                    pwcoInstance = NULL;
                    hr = pwcoEnum->Next(
                            WBEM_INFINITE,
                            1,
                            &pwcoInstance,
                            &ulCount
                            );

                    if (S_OK == hr && 1 == ulCount)
                    {
                        DeleteWmiInstance(
                            m_piwsHomenet,
                            pwcoInstance
                            );

                        pwcoInstance->Release();
                    }
                }
                while (S_OK == hr && 1 == ulCount);

                pwcoEnum->Release();
                hr = S_OK;
            }
            
        }

        //
        // Finally, delete the connection object. (The connection
        // properties object will have been deleted during the
        // references set.)
        //

        hr = m_piwsHomenet->DeleteInstance(
                m_bstrConnection,
                0,
                NULL,
                NULL
                );        
    }

    return hr;
}


//
// Protected methods
//

HRESULT
CHNetConn::GetIcmpSettingsInstance(
    IWbemClassObject **ppwcoSettings
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    IEnumWbemClassObject *pwcoEnum;
    ULONG ulCount;


    _ASSERT(NULL != ppwcoSettings);

    hr = BuildAssociatorsQueryBstr(
            &bstrQuery,
            m_bstrConnection,
            c_wszHnetConnectionIcmpSetting
            );

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the settings instance from the enum
        //

        *ppwcoSettings = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoSettings,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // Normalize return value
            //

            hr = S_OK;
        }
        else
        {
            //
            // Settings block not found -- use default settings
            //

            bstrQuery = SysAllocString(c_wszDefaultIcmpSettingsPath);

            if (NULL != bstrQuery)
            {
                hr = GetWmiObjectFromPath(
                        m_piwsHomenet,
                        bstrQuery,
                        ppwcoSettings
                        );

                SysFreeString(bstrQuery);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        //
        // Enum should be empty at this point
        //

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}

HRESULT
CHNetConn::CopyIcmpSettingsInstanceToStruct(
    IWbemClassObject *pwcoSettings,
    HNET_FW_ICMP_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL != pwcoSettings);
    _ASSERT(NULL != pSettings);

    hr = GetBooleanValue(
            pwcoSettings,
            c_wszAllowOutboundDestinationUnreachable,
            &pSettings->fAllowOutboundDestinationUnreachable
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundSourceQuench,
                &pSettings->fAllowOutboundSourceQuench
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowRedirect,
                &pSettings->fAllowRedirect
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundEchoRequest,
                &pSettings->fAllowInboundEchoRequest
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundRouterRequest,
                &pSettings->fAllowInboundRouterRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundTimeExceeded,
                &pSettings->fAllowOutboundTimeExceeded
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundParameterProblem,
                &pSettings->fAllowOutboundParameterProblem
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundTimestampRequest,
                &pSettings->fAllowInboundTimestampRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundMaskRequest,
                &pSettings->fAllowInboundMaskRequest
                );
    }

    return hr;
}

HRESULT
CHNetConn::CopyStructToIcmpSettingsInstance(
    HNET_FW_ICMP_SETTINGS *pSettings,
    IWbemClassObject *pwcoSettings
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL != pSettings);
    _ASSERT(NULL != pwcoSettings);

    hr = SetBooleanValue(
            pwcoSettings,
            c_wszAllowOutboundDestinationUnreachable,
            pSettings->fAllowOutboundDestinationUnreachable
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundSourceQuench,
                pSettings->fAllowOutboundSourceQuench
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowRedirect,
                pSettings->fAllowRedirect
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundEchoRequest,
                pSettings->fAllowInboundEchoRequest
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundRouterRequest,
                pSettings->fAllowInboundRouterRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundTimeExceeded,
                pSettings->fAllowOutboundTimeExceeded
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundParameterProblem,
                pSettings->fAllowOutboundParameterProblem
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundTimestampRequest,
                pSettings->fAllowInboundTimestampRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundMaskRequest,
                pSettings->fAllowInboundMaskRequest
                );
    }

    return hr;
}

HRESULT
CHNetConn::CreatePortMappingBindings()

{
    HRESULT hr = S_OK;
    BSTR bstr;
    IEnumWbemClassObject *pwcoEnumProtocols;
    IWbemClassObject *pwcoInstance;
    VARIANT vt;

    //
    // Get the enumeration of all protocol instances
    //

    bstr = SysAllocString(c_wszHnetPortMappingProtocol);

    if (NULL != bstr)
    {
        pwcoEnumProtocols = NULL;
        hr = m_piwsHomenet->CreateInstanceEnum(
                bstr,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnumProtocols
                );

        SysFreeString(bstr);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        //
        // Loop through the enumeration, checking to see if the desired binding
        // exists
        //

        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnumProtocols->Next(
                    WBEM_INFINITE,
                    1,
                    &pwcoInstance,
                    &ulCount
                    );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                hr = pwcoInstance->Get(
                        c_wszPort,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
                
                if (WBEM_S_NO_ERROR == hr)
                {
                    ASSERT(VT_I4 == V_VT(&vt));
                    
                    hr = GetWmiPathFromObject(pwcoInstance, &bstr);
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    IWbemClassObject *pwcoBinding;

                    hr = GetPortMappingBindingInstance(
                            m_piwsHomenet,
                            m_bstrWQL,
                            m_bstrConnection,
                            bstr,
                            static_cast<USHORT>(V_I4(&vt)),
                            &pwcoBinding
                            );

                    SysFreeString(bstr);

                    if (S_OK == hr)
                    {
                        pwcoBinding->Release();
                    }
                    else if (WBEM_E_NOT_FOUND == hr)
                    {
                        //
                        // This can occur if the protocol instance is
                        // deleted after we retrieved it from the enumeration
                        // but before we created the binding instance. It's
                        // OK to continue in this situation.
                        //
                        
                        hr = S_OK;
                    }
                }

                pwcoInstance->Release();
            }

        } while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnumProtocols->Release();
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

HRESULT
CHNetConn::InternalGetProperties(
    IWbemClassObject *pwcoProperties,
    HNET_CONN_PROPERTIES *pProperties
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL != pwcoProperties);
    _ASSERT(NULL != pProperties);

    pProperties->fLanConnection = m_fLanConnection;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsFirewalled,
                &pProperties->fFirewalled
                );
    }
    else
    {
        //
        // If the SharedAccess service is not running (or in the process
        // of starting up) we don't want to report this connection as
        // being firewalled. This is to prevent the confusion that could
        // result if the UI indicates the firewall is active, when in
        // reality it's not there providing protection.
        //

        pProperties->fFirewalled = FALSE;
    }


    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPublic,
                &pProperties->fIcsPublic
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPrivate,
                &pProperties->fIcsPrivate
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        if( m_fLanConnection )
        {
            //
            // Figure out NetCfg-based properties
            //
    
            INetCfg                 *pnetcfg;
    
            hr = CoCreateInstance(
                    CLSID_CNetCfg,
                    NULL,
                    CLSCTX_SERVER,
                    IID_PPV_ARG(INetCfg, &pnetcfg)
                    );
    
            if (S_OK == hr)
            {
                hr = pnetcfg->Initialize( NULL );
    
                if( S_OK == hr )
                {
                    GUID                    *pguid;
                    INetCfgComponent        *pncfgcomp;
    
                    hr = GetGuidInternal(&pguid);
    
                    if(S_OK == hr)
                    {
                        // Get the NetCfg component that corresponds to us
                        hr = FindAdapterByGUID( pnetcfg, pguid, &pncfgcomp );
    
                        if(S_OK == hr)
                        {
                            LPWSTR              pszwId;
    
                            pncfgcomp->GetId( &pszwId );
    
                            if(S_OK == hr)
                            {
                                pProperties->fBridge = (BOOLEAN)(_wcsicmp(pszwId, c_wszSBridgeMPID) == 0);
                                CoTaskMemFree(pszwId);
                                
                                if( pProperties->fBridge )
                                {
                                    // This adapter is the bridge. It can't possibly also be a bridge
                                    // member.
                                    pProperties->fPartOfBridge = FALSE;
                                }
                                else
                                {
                                    //
                                    // This adapter is not the bridge. Check if it's part of a bridge.
                                    //
                                    INetCfgComponent    *pnetcfgcompBridgeProtocol;
        
                                    // Find the bridge protocol component
                                    hr = pnetcfg->FindComponent( c_wszSBridgeSID, &pnetcfgcompBridgeProtocol );
        
                                    if(S_OK == hr)
                                    {
                                        INetCfgComponentBindings    *pnetcfgProtocolBindings;
        
                                        // Get the ComponentBindings interface for the protocol component
                                        hr = pnetcfgcompBridgeProtocol->QueryInterface(
                                                IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgProtocolBindings)
                                                );
        
                                        if(S_OK == hr)
                                        {
                                            hr = pnetcfgProtocolBindings->IsBoundTo(pncfgcomp);
        
                                            if(S_OK == hr)
                                            {
                                                // The bridge protocol is bound to this adapter
                                                pProperties->fPartOfBridge = TRUE;
                                            }
                                            else if(S_FALSE == hr)
                                            {
                                                // The bridge protocol is not bound to this adapter
                                                pProperties->fPartOfBridge = FALSE;
        
                                                // Reset to success
                                                hr = S_OK;
                                            }
                                            // else an error occured
        
                                            pnetcfgProtocolBindings->Release();
                                        }
        
                                        pnetcfgcompBridgeProtocol->Release();
                                    }
                                    else
                                    {
                                        // This adapter can't be bridged if there's no bridge protocol
                                        // in the system
                                        pProperties->fPartOfBridge = FALSE;
        
                                        // Reset to success
                                        hr = S_OK;
                                    }
                                }
                            }
    
                            pncfgcomp->Release();
                        }
                    }
    
                    pnetcfg->Uninitialize();
                }
    
                pnetcfg->Release();
            }
        } // if m_fLanConnection
        else
        {
            // We're not a LAN connection. We can never be a bridge or a bridge member.
            pProperties->fBridge = FALSE;
            pProperties->fPartOfBridge = FALSE;
        }
    }

    if(S_OK == hr)
    {
        //
        // Calculated properties
        //

        pProperties->fCanBeFirewalled =
            !pProperties->fPartOfBridge
            && !pProperties->fBridge
            && !pProperties->fIcsPrivate;

        pProperties->fCanBeIcsPublic =
            !pProperties->fBridge
            && !pProperties->fPartOfBridge
            && !pProperties->fIcsPrivate;

        pProperties->fCanBeIcsPrivate =
            m_fLanConnection
            && !pProperties->fIcsPublic
            && !pProperties->fFirewalled
            && !pProperties->fPartOfBridge;

        pProperties->fCanBeBridged =
            m_fLanConnection
            && !pProperties->fIcsPublic
            && !pProperties->fIcsPrivate
            && !pProperties->fFirewalled
            && !pProperties->fBridge;
    }

    return hr;
}

HRESULT
CHNetConn::SetupConnectionAsPrivateLan()

{
    HRESULT hr;
    GUID *pGuid;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    ULONG Error;
    DWORD dwAddress;
    DWORD dwMask;
    ULONG i;
    PMIB_IPADDRTABLE Table;


    ZeroMemory(&UnicodeString, sizeof(UnicodeString));
    ZeroMemory(&AnsiString, sizeof(AnsiString));

    hr = GetGuidInternal(&pGuid);

    if (SUCCEEDED(hr))
    {
        hr = RtlStringFromGUID(*pGuid, &UnicodeString);

        if (SUCCEEDED(hr))
        {
            hr = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Obtain the address and mask for the private network
        //

        hr = ReadDhcpScopeSettings(&dwAddress, &dwMask);
    }

    if (SUCCEEDED(hr))
    {

        //
        // Determine whether some LAN adapter other than the private LAN
        // is already using an address in the private network scope.
        // In the process, make sure that the private LAN has only one
        // IP address (otherwise, 'SetAdapterIpAddress' fails.)
        //

        Error =
            AllocateAndGetIpAddrTableFromStack(
                &Table,
                FALSE,
                GetProcessHeap(),
                0
                );

        if (ERROR_SUCCESS == Error)
        {
            ULONG Index = 0;
            ULONG Count;

            hr = MapGuidStringToAdapterIndex(UnicodeString.Buffer, &Index);

            if (SUCCEEDED(hr))
            {

                for (i = 0, Count = 0; i < Table->dwNumEntries; i++)
                {
                    if (Index == Table->table[i].dwIndex)
                    {
                        ++Count;
                    }
                    else if ((Table->table[i].dwAddr & dwMask)
                              == (dwAddress & dwMask))
                    {
                        //
                        // It appears that some other LAN adapter has an
                        // address in the proposed scope.
                        //
                        // This may happen when multiple netcards go into
                        // autonet mode or when the RAS server is handing
                        // out autonet addresses.
                        //
                        // Therefore, if we're using the autonet scope,
                        // allow this behavior; otherwise prohibit it.
                        //

                        if ((dwAddress & dwMask) != 0x0000fea9)
                        {
                            break;
                        }
                    }
                }

                if (i < Table->dwNumEntries)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_ADDRESS_EXISTS);
                }
                else if (Count > 1)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_MULTIPLE_ADDRESSES);
                }
            }

            HeapFree(GetProcessHeap(), 0, Table);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(Error);
        }
    }

    //
    // Set the predefined static IP address for the private LAN.
    //

    if (SUCCEEDED(hr))
    {
        Error =
            SetAdapterIpAddress(
                AnsiString.Buffer,
                FALSE,
                dwAddress,
                dwMask,
                0
                );

        if (ERROR_SUCCESS != Error)
        {
            if (Error == ERROR_TOO_MANY_NAMES)
            {
                Error = ERROR_SHARING_MULTIPLE_ADDRESSES;
            }
            else if (Error == ERROR_DUP_NAME)
            {
                Error = ERROR_SHARING_HOST_ADDRESS_CONFLICT;
            }
            else
            {
                //
                // Query the state of the connection.
                // If it is disconnected, convert the error code
                // to something more informative.
                //

                UNICODE_STRING DeviceString;
                NIC_STATISTICS NdisStatistics;
                LPWSTR pwsz;

                //
                // Build a buffer large enough for the device string
                //

                pwsz = new WCHAR[wcslen(c_wszDevice) + wcslen(UnicodeString.Buffer) + 1];
                if (NULL != pwsz)
                {
                    swprintf(pwsz, L"%s%s", c_wszDevice, UnicodeString.Buffer);
                    RtlInitUnicodeString(&DeviceString, pwsz);
                    NdisStatistics.Size = sizeof(NdisStatistics);
                    NdisQueryStatistics(&DeviceString, &NdisStatistics);
                    delete [] pwsz;

                    if (NdisStatistics.DeviceState != DEVICE_STATE_CONNECTED)
                    {
                        Error = ERROR_SHARING_NO_PRIVATE_LAN;
                    }
                    else if  (NdisStatistics.MediaState == MEDIA_STATE_UNKNOWN)
                    {
                        Error = ERROR_SHARING_HOST_ADDRESS_CONFLICT;
                    }
                    else if (NdisStatistics.MediaState == MEDIA_STATE_DISCONNECTED)
                    {
                        //
                        // The adapter is connected but is in a media disconnect
                        // state. When this happens the correct IP address will
                        // be there when the adapter is reconnected, so ignore
                        // the error.
                        //

                        Error = ERROR_SUCCESS;
                    }
                }
            }

            hr = HRESULT_FROM_WIN32(Error);
        }
    }

    //
    // As we zeroed out the string structure above, it's safe to call
    // the free routines, even if we never actually allocated anything.
    //

    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeAnsiString(&AnsiString);

    return hr;
}

HRESULT
CHNetConn::BackupIpConfiguration()

{
    HRESULT hr = S_OK;
    HANDLE Key;
    IWbemClassObject *pwcoInstance = NULL;
    VARIANT vt;
    PKEY_VALUE_PARTIAL_INFORMATION pInformation;

    //
    // Spawn a new HNet_BackupIpConfiguration instance
    //

    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszBackupIpConfiguration,
            &pwcoInstance
            );

    if (SUCCEEDED(hr))
    {
        //
        // Write connection property into instance
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = m_bstrConnection;

        hr = pwcoInstance->Put(
                c_wszConnection,
                0,
                &vt,
                NULL
                );

        VariantInit(&vt);
    }

    //
    // Open the registry key that stores the IP configuration
    // for this connection
    //

    if (SUCCEEDED(hr))
    {
        hr = OpenIpConfigurationRegKey(KEY_READ, &Key);
    }

    //
    // Read each part of the configuration, and write it to
    // the settings instance
    //

    if (SUCCEEDED(hr))
    {
        hr = QueryRegValueKey(Key, c_wszIPAddress, &pInformation);

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszIPAddress,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszSubnetMask, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszSubnetMask,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszDefaultGateway, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszDefaultGateway,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }


        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszEnableDHCP, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_DWORD == pInformation->Type);
            _ASSERT(sizeof(DWORD) == pInformation->DataLength);

            V_VT(&vt) = VT_I4;
            V_I4(&vt) = *(reinterpret_cast<DWORD*>(pInformation->Data));

            hr = pwcoInstance->Put(
                    c_wszEnableDHCP,
                    0,
                    &vt,
                    NULL
                    );

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        NtClose(Key);
    };

    //
    // Write the settings to the store
    //

    if (SUCCEEDED(hr))
    {
        hr = m_piwsHomenet->PutInstance(
                pwcoInstance,
                WBEM_FLAG_CREATE_OR_UPDATE,
                NULL,
                NULL
                );
    }

    if (NULL != pwcoInstance)
    {
        pwcoInstance->Release();
    }

    return hr;
}

HRESULT
CHNetConn::RestoreIpConfiguration()

{
    HRESULT hr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoSettings;
    BSTR bstr;
    LPWSTR wszAddress;
    VARIANT vt;
    LPWSTR wsz;
    UNICODE_STRING UnicodeString;
    HANDLE hKey = NULL;
    BOOLEAN fDhcpEnabled;
    ULONG ulLength;
    ULONG ulAddress;
    ULONG ulMask;

    //
    // Open the registry key
    //

    hr = OpenIpConfigurationRegKey(KEY_ALL_ACCESS, &hKey);

    //
    // Get the backup configuration block for this connection
    //
    
    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wsz,
                c_wszConnection,
                m_bstrConnection
                );
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszBackupIpConfiguration,
                wsz
                );

        delete [] wsz;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        ULONG ulCount;

        pwcoSettings = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoSettings, &ulCount);

        //
        // Even if we're not able to obtain backup settings we continue
        // to operate. By setting pwcoSettings to NULL we indidcate that
        // the default DHCP configuration should be used. (A failure for
        // ExecQuery indicates a much more serious problem, so we don't
        // try to continue if that occurs.)
        //

        if (FAILED(hr) || 1 != ulCount)
        {
            pwcoSettings = NULL;
        }

        hr = S_OK;

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();
    }

    //
    // Write backup values to registry -- start by getting the
    // old IP address
    //

    if (S_OK == hr)
    {
        if (NULL != pwcoSettings) 
        {
            hr = pwcoSettings->Get(
                    c_wszIPAddress,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                ULONG ulDhcpAddress;
                ULONG ulDhcpMask;

                _ASSERT(VT_BSTR == V_VT(&vt));

                //
                // Check to see if the stored backup address is the
                // same as our default DHCP scope -- if so, use
                // the default DHCP configuration.
                //

                hr = ReadDhcpScopeSettings(&ulDhcpAddress, &ulDhcpMask);

                if (S_OK == hr)
                {
                    ulAddress =
                        RtlUlongByteSwap(
                            IpPszToHostAddr(V_BSTR(&vt))
                            );

                    if (ulAddress == ulDhcpAddress
                        || static_cast<DWORD>(-1) == ulAddress)
                    {
                        //
                        // Use the default configuration.
                        //

                        DeleteWmiInstance(m_piwsHomenet, pwcoSettings);
                        pwcoSettings->Release();
                        pwcoSettings = NULL;
                        
                        VariantClear(&vt);
                        V_VT(&vt) = VT_BSTR;
                        V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
                        if (NULL == V_BSTR(&vt))
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            } 
        }
        else
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
            if (NULL == V_BSTR(&vt))
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wszAddress =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wszAddress)
            {
                RtlCopyMemory(wszAddress, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszIPAddress);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wszAddress),
                        ulLength
                        );
                        
                HeapFree(GetProcessHeap(), 0, wszAddress);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // DHCP settings
        //

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszEnableDHCP,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_I4;
                V_I4(&vt) = 1;
                hr = WBEM_S_NO_ERROR;
            }
        }

        //
        // Subnet mask
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_I4 == V_VT(&vt));

            RtlInitUnicodeString(&UnicodeString, c_wszEnableDHCP);

            hr = NtSetValueKey(
                    hKey,
                    &UnicodeString,
                    0,
                    REG_DWORD,
                    reinterpret_cast<PVOID>(&(V_I4(&vt))),
                    sizeof(V_I4(&vt))
                    );

            fDhcpEnabled = 1 == V_I4(&vt);
            VariantClear(&vt);
        }

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszSubnetMask,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
                if (NULL != V_BSTR(&vt))
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            LPWSTR wszMask;
            
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wszMask =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wszMask)
            {
                RtlCopyMemory(wszMask, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszSubnetMask);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wszMask),
                        ulLength
                        );

                if (!fDhcpEnabled)
                {
                    ulMask =
                        RtlUlongByteSwap(
                            IpPszToHostAddr(wszMask)
                            );
                }
                
                HeapFree(GetProcessHeap(), 0, wszMask);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // Default gateway
        //

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszDefaultGateway,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(L"");
                if (NULL != V_BSTR(&vt))
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wsz =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wsz)
            {
                RtlCopyMemory(wsz, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszDefaultGateway);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wsz),
                        ulLength
                        );

                HeapFree(GetProcessHeap(), 0, wsz);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // Delete the backup instance
        //

        if (NULL != pwcoSettings)
        {
            DeleteWmiInstance(m_piwsHomenet, pwcoSettings);
            pwcoSettings->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        GUID *pGuid;
        LPWSTR wszGuid;
        ULONG ulError;

        //
        // Notify the stack that the IP settings have changed
        //

        hr = GetGuidInternal(&pGuid);
        if (S_OK == hr)
        {
            hr = StringFromCLSID(*pGuid, &wszGuid);
        }

        if (S_OK == hr)
        {
            if (fDhcpEnabled)
            {
                ulError = DhcpNotifyConfigChange(
                            NULL,
                            wszGuid,
                            FALSE,
                            0,
                            0,
                            0,
                            DhcpEnable
                            );

                if (NO_ERROR != ulError)
                {
                    hr = HRESULT_FROM_WIN32(ulError);
                }
            }
            else
            {
                UNICODE_STRING BindList;
                UNICODE_STRING LowerComponent;
                IP_PNP_RECONFIG_REQUEST Request;
                UNICODE_STRING UpperComponent;
                        
                if ((ULONG)-1 != ulMask)
                {
                    //
                    // First delete the old (static) IP address
                    //

                    DhcpNotifyConfigChange(
                        NULL,
                        wszGuid,
                        TRUE,
                        0,
                        0,
                        0,
                        IgnoreFlag
                        );

                    //
                    // Now set the new address
                    //
                    
                    ulError =
                        DhcpNotifyConfigChange(
                            NULL,
                            wszGuid,
                            TRUE,
                            0,
                            ulAddress,
                            ulMask,
                            DhcpDisable
                            );

                    if (NO_ERROR != ulError)
                    {
                        hr = HRESULT_FROM_WIN32(ulError);
                    }
                }
                else
                {
                    hr = E_FAIL;
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Instruct the stack to pickup the
                    // new default gateway
                    //
                    
                    RtlInitUnicodeString(&BindList, L"");
                    RtlInitUnicodeString(&LowerComponent, L"");
                    RtlInitUnicodeString(&UpperComponent, L"Tcpip");
                    ZeroMemory(&Request, sizeof(Request));
                    Request.version = IP_PNP_RECONFIG_VERSION;
                    Request.gatewayListUpdate = TRUE;
                    Request.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE;
                    NdisHandlePnPEvent(
                        NDIS,
                        RECONFIGURE,
                        &LowerComponent,
                        &UpperComponent,
                        &BindList,
                        &Request,
                        sizeof(Request)
                        );
                }
            }

            CoTaskMemFree(wszGuid);
        }
    }

    if (NULL != hKey)
    {
        NtClose(hKey);
    }

    return hr;
}

HRESULT
CHNetConn::OpenIpConfigurationRegKey(
    ACCESS_MASK DesiredAccess,
    HANDLE *phKey
    )

{
    HRESULT hr;
    LPWSTR KeyName;
    ULONG KeyNameLength;
    GUID *pGuid;
    LPWSTR wszGuid;

    hr = GetGuidInternal(&pGuid);

    if (SUCCEEDED(hr))
    {
        hr = StringFromCLSID(*pGuid, &wszGuid);
    }

    if (SUCCEEDED(hr))
    {
        KeyNameLength =
            wcslen(c_wszTcpipParametersKey) + 1 +
            wcslen(c_wszInterfaces) + 1 +
            wcslen(wszGuid) + 2;

        KeyName = new OLECHAR[KeyNameLength];
        if (NULL != KeyName)
        {
            swprintf(
                KeyName,
                L"%ls\\%ls\\%ls",
                c_wszTcpipParametersKey,
                c_wszInterfaces,
                wszGuid
                );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(wszGuid);
    }

    if (SUCCEEDED(hr))
    {
        hr = OpenRegKey(phKey, DesiredAccess, KeyName);
        delete [] KeyName;
    }

    return hr;
}

HRESULT
CHNetConn::GetGuidInternal(
    GUID **ppGuid
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != ppGuid);

    Lock();

    if (NULL == m_pGuid)
    {
        //
        // Our guid hasn't been retrieved yet -- do it now.
        //

        m_pGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL == m_pGuid)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            IWbemClassObject *pwcoConnection;

            hr = GetConnectionObject(&pwcoConnection);

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Get our guid property
                //

                hr = pwcoConnection->Get(
                        c_wszGuid,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );

                pwcoConnection->Release();
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // Convert the string to a guid.
            //

            hr = CLSIDFromString(V_BSTR(&vt), m_pGuid);
            VariantClear(&vt);
        }

        if (FAILED(hr) && NULL != m_pGuid)
        {
            CoTaskMemFree(m_pGuid);
            m_pGuid = NULL;
        }
    }

    if (S_OK == hr)
    {
        *ppGuid = m_pGuid;
    }

    Unlock();

    return hr;
}

HRESULT
CHNetConn::GetConnectionObject(
    IWbemClassObject **ppwcoConnection
    )

{
    _ASSERT(NULL != ppwcoConnection);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrConnection,
                ppwcoConnection
                );
}

HRESULT
CHNetConn::GetConnectionPropertiesObject(
    IWbemClassObject **ppwcoProperties
    )

{
    _ASSERT(NULL != ppwcoProperties);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProperties,
                ppwcoProperties
                );
}

BOOLEAN
CHNetConn::ProhibitedByPolicy(
    DWORD dwPerm
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fProhibited = FALSE;

    if (NULL == m_pNetConnUiUtil)
    {
        Lock();

        if (NULL == m_pNetConnUiUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionUiUtilities,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG(INetConnectionUiUtilities, &m_pNetConnUiUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        fProhibited = !m_pNetConnUiUtil->UserHasPermission(dwPerm);
    }

    return fProhibited;
}

HRESULT
CHNetConn::UpdateNetman()

{
    HRESULT hr = S_OK;

    if (NULL == m_pNetConnHNetUtil)
    {
        Lock();

        if (NULL == m_pNetConnHNetUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionHNetUtil,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG(INetConnectionHNetUtil, &m_pNetConnHNetUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pNetConnHNetUtil->NotifyUpdate();
    }

    return hr;
}


HRESULT
CHNetConn::CreateIcmpSettingsAssociation(
    BSTR bstrIcmpSettingsPath
    )

{
    HRESULT hr;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;

    _ASSERT(NULL != bstrIcmpSettingsPath);

    //
    // Spawn a new instance of the association class
    //

    pwcoInstance = NULL;
    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszHnetConnectionIcmpSetting,
            &pwcoInstance
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set connection property
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = m_bstrConnection;
        hr = pwcoInstance->Put(
                c_wszConnection,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Point the association to the settings block
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = bstrIcmpSettingsPath;
        hr = pwcoInstance->Put(
                c_wszIcmpSettings,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Save the object to the store
        //

        hr = m_piwsHomenet->PutInstance(
                pwcoInstance,
                WBEM_FLAG_CREATE_OR_UPDATE,
                NULL,
                NULL
                );
    }

    return hr;
}

HRESULT
CHNetConn::GetRasConnectionName(
    OLECHAR **ppszwConnectionName
    )

{
    HRESULT hr;
    GUID *pGuid;
    OLECHAR *pszwPath;
    RASENUMENTRYDETAILS *rgEntryDetails;
    DWORD cBytes;
    DWORD cEntries;
    DWORD dwError;
    

    _ASSERT(NULL != ppszwConnectionName);
    _ASSERT(FALSE == m_fLanConnection);

    hr = GetGuidInternal(&pGuid);

    if (S_OK == hr)
    {
        hr = GetRasPhonebookPath(&pszwPath);
    }

    if (S_OK == hr)
    {
        //
        // Start with a buffer large enough to hold 5 entries.
        //

        cBytes = 5 * sizeof(RASENUMENTRYDETAILS);
        rgEntryDetails =
            reinterpret_cast<RASENUMENTRYDETAILS *>(
                CoTaskMemAlloc(cBytes)
                );

        if (NULL != rgEntryDetails)
        {
            //
            // Try to obtain the entry details
            //
            
            rgEntryDetails[0].dwSize = sizeof(RASENUMENTRYDETAILS);
            dwError =
                DwEnumEntryDetails(
                    pszwPath,
                    rgEntryDetails,
                    &cBytes,
                    &cEntries
                    );

            if (ERROR_BUFFER_TOO_SMALL == dwError)
            {
                //
                // Try again with a larger buffer
                //

                CoTaskMemFree(rgEntryDetails);
                rgEntryDetails =
                    reinterpret_cast<RASENUMENTRYDETAILS *>(
                        CoTaskMemAlloc(cBytes)
                        );

                if (NULL != rgEntryDetails)
                {
                    rgEntryDetails[0].dwSize = sizeof(RASENUMENTRYDETAILS);
                    dwError =
                        DwEnumEntryDetails(
                            pszwPath,
                            rgEntryDetails,
                            &cBytes,
                            &cEntries
                            );

                    if (ERROR_SUCCESS != dwError)
                    {
                        CoTaskMemFree(rgEntryDetails);
                        hr = HRESULT_FROM_WIN32(dwError);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else if (ERROR_SUCCESS != dwError)
            {
                CoTaskMemFree(rgEntryDetails);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(pszwPath);
    }

    if (S_OK == hr)
    {
        DWORD i;
        
        //
        // Locate the correct entry in the returned array
        //

        for (i = 0; i < cEntries; i++)
        {
            if (IsEqualGUID(rgEntryDetails[i].guidId, *pGuid))
            {
                //
                // We've located the correct entry. Allocate the
                // output buffer and copy over the name.
                //

                *ppszwConnectionName =
                    reinterpret_cast<OLECHAR *>(
                        CoTaskMemAlloc(
                            sizeof(OLECHAR)
                            * (wcslen(rgEntryDetails[i].szEntryName) + 1)
                            )
                        );

                if (NULL != *ppszwConnectionName)
                {
                    wcscpy(
                        *ppszwConnectionName,
                        rgEntryDetails[i].szEntryName
                        );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                break;
            }
        }

        if (i == cEntries)
        {
            //
            // Connection not found
            //

            hr = E_FAIL;
        }
        
        CoTaskMemFree(rgEntryDetails);
    }

    return hr;
}

HRESULT
CHNetConn::RefreshNetConnectionsUI(
    VOID
    )

{
    HRESULT hr = S_OK;
    INetConnection *pNetConnection;

    //
    // Make sure the UI refresh object exists
    //

    if (NULL == m_pNetConnRefresh)
    {
        Lock();

        if (NULL == m_pNetConnRefresh)
        {
            hr = CoCreateInstance(
                    CLSID_ConnectionManager,
                    NULL,
                    CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                    IID_PPV_ARG(INetConnectionRefresh, &m_pNetConnRefresh)
                    );

            if (SUCCEEDED(hr))
            {
                SetProxyBlanket(m_pNetConnRefresh);
            }
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = GetINetConnection(&pNetConnection);

        if (SUCCEEDED(hr))
        {
            hr = m_pNetConnRefresh->ConnectionModified(pNetConnection);
            pNetConnection->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnfwconn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N F W C O N N . C P P
//
//  Contents:   CHNFWConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetFirewalledConnection methods
//

STDMETHODIMP
CHNFWConn::Unfirewall()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Change our IsFirewalled property to false
        //
        

        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsFirewalled,
                FALSE
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state. Success is asserted on debug builds.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnicspub.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P U B . C P P
//
//  Contents:   CHNIcsPublicConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetIcsPublicConnection methods
//

STDMETHODIMP
CHNIcsPublicConn::Unshare()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Change our IsIcsPublic property to false
        //
        
        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPublic,
                FALSE
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state. Success is asserted on debug builds.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wbemidl.h>
#include <rasuip.h>
#include <raserror.h>
#include <netcon.h>
#include <netconp.h>
#include <wininet.h>
#include <routprot.h>
#include <rasapip.h>

#define _PNP_POWER_
#include <ndispnp.h>
#include <ntddip.h>
#include <ipinfo.h>
#include <iphlpapi.h>

extern "C" {
#include <iphlpstk.h>
#include <dhcpcapi.h>
}

#include <ipnathlp.h>
#include <netcfgx.h>
#include <netcfgn.h>
#include <devguid.h>
#include <saupdate.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncstrs.h"
#include "hncutil.h"
#include "hncres.h"
#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnprtbnd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingBinding implementation
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Atl methods
//

HRESULT
CHNetPortMappingBinding::FinalConstruct()

{
    HRESULT hr = S_OK;
    
    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CHNetPortMappingBinding::FinalRelease()

{
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrBinding) SysFreeString(m_bstrBinding);
    
    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetPortMappingBinding::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrBinding);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    hr = GetWmiPathFromObject(pwcoInstance, &m_bstrBinding);

    return hr;
}

//
// IHNetPortMappingBinding methods
//

STDMETHODIMP
CHNetPortMappingBinding::GetConnection(
    IHNetConnection **ppConnection
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoBinding;

    if (NULL == ppConnection)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppConnection = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Read our protocol reference
        //

        hr = pwcoBinding->Get(
                c_wszConnection,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Get the IWbemClassObject
        //

        hr = GetWmiObjectFromPath(
                m_piwsHomenet,
                V_BSTR(&vt),
                &pwcoInstance
                );

        VariantClear(&vt);
    }

    if (S_OK == hr)
    {
        //
        // Create the object for the instance
        //

        CComObject<CHNetConn> *pConnection;

        hr = CComObject<CHNetConn>::CreateInstance(&pConnection);

        if (SUCCEEDED(hr))
        {
            pConnection->AddRef();
            
            hr = pConnection->InitializeFromConnection(m_piwsHomenet, pwcoInstance);

            if (SUCCEEDED(hr))
            {
                hr = pConnection->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppConnection)
                        );
            }

            pConnection->Release();
        }

        pwcoInstance->Release();
    }

    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::GetProtocol(
    IHNetPortMappingProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoBinding;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {

        *ppProtocol = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Read our protocol reference
        //

        hr = pwcoBinding->Get(
                c_wszProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // Get the IWbemClassObject for the protocol.
            //

            hr = GetWmiObjectFromPath(
                    m_piwsHomenet,
                    V_BSTR(&vt),
                    &pwcoInstance
                    );

            VariantClear(&vt);
            
            if (S_OK == hr)
            {
                //
                // Create the object for the instance
                //

                CComObject<CHNetPortMappingProtocol> *pProt;

                hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProt);

                if (SUCCEEDED(hr))
                {
                    pProt->AddRef();
                    
                    hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                    if (SUCCEEDED(hr))
                    {
                        hr = pProt->QueryInterface(
                                IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                                );
                    }

                    pProt->Release();
                }

                pwcoInstance->Release();
            }
            else if (WBEM_E_NOT_FOUND == hr)
            {
                //
                // The protocol object we refer to doesn't exist --
                // the store is in an invalid state. Delete our
                // binding instance and return the error to the
                // caller.
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoBinding);
            }
        }

        pwcoBinding->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetEnabled(
    BOOLEAN *pfEnabled
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;

    if (NULL == pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoBinding,
                c_wszEnabled,
                pfEnabled
                );

        pwcoBinding->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::SetEnabled(
    BOOLEAN fEnable
    )
    
{
    BOOLEAN fOldEnabled;
    HRESULT hr;
    IWbemClassObject *pwcoBinding;

    hr = GetEnabled(&fOldEnabled);

    if (S_OK == hr && fOldEnabled != fEnable)
    {
        hr = GetBindingObject(&pwcoBinding);

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = SetBooleanValue(
                    pwcoBinding,
                    c_wszEnabled,
                    fEnable
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetCurrentMethod(
    BOOLEAN *pfUseName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;

    if (NULL == pfUseName)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoBinding,
                c_wszNameActive,
                pfUseName
                );

        pwcoBinding->Release();
    }

    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetComputerName(
    OLECHAR **ppszwName
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    BOOLEAN fNameActive;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszwName = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Check to see if the name is valid
        //

        hr = GetCurrentMethod(&fNameActive);

        if (S_OK == hr && FALSE == fNameActive)
        {
            hr = E_UNEXPECTED;
        }

        if (S_OK == hr)
        {
            *ppszwName = NULL;

            //
            // Read the name property from our instance
            //

            hr = pwcoBinding->Get(
                    c_wszTargetName,
                    NULL,
                    &vt,
                    NULL,
                    NULL
                    ); 
        }

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate memory for the return string
        //

        *ppszwName = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                       * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwName)
        {
            wcscpy(*ppszwName, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetComputerName(
    OLECHAR *pszwName
    )
    
{
    BOOLEAN fNameChanged = TRUE;
    BOOLEAN fNameWasActive;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pszwName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Check to see if we actually need to do any work. This
        // will be the case if:
        // 1) Our name wasn't active to start with, or
        // 2) The new name is different than the old.
        //
        
        hr = GetCurrentMethod(&fNameWasActive);

        if (S_OK == hr)
        {
            if (fNameWasActive)
            {
                OLECHAR *pszwOldName;

                hr = GetTargetComputerName(&pszwOldName);

                if (S_OK == hr)
                {
                    fNameChanged = 0 != _wcsicmp(pszwOldName, pszwName);
                    CoTaskMemFree(pszwOldName);
                }
            }
        }
    }

    if (S_OK == hr && fNameChanged)
    {
        hr = GetBindingObject(&pwcoBinding);

        if (S_OK == hr)
        {
            //
            // Wrap the passed-in string in a BSTR and a variant
            //

            VariantInit(&vt);
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(pszwName);
            if (NULL == V_BSTR(&vt))
            {
                hr = E_OUTOFMEMORY;
            }

            if (S_OK == hr)
            {
                //
                // Set the property on the instance
                //

                hr = pwcoBinding->Put(
                        c_wszTargetName,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set that our name is now active
                //

                hr = SetBooleanValue(
                        pwcoBinding,
                        c_wszNameActive,
                        TRUE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                ULONG ulAddress;
                
                //
                // Generate an address to use as our target. We must always
                // regenerate the address when our name changes, as there
                // might be another entry with our new name that already has
                // a reserved address
                //

                hr = GenerateTargetAddress(pszwName, &ulAddress);

                if (SUCCEEDED(hr))
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = ulAddress;

                    hr = pwcoBinding->Put(
                            c_wszTargetIPAddress,
                            0,
                            &vt,
                            NULL
                            );
                }
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetComputerAddress(
    ULONG *pulAddress
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pulAddress)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    //
    // We don't check to see what the current method is, as if the
    // name is valid, we would have generated an address to use
    // as the target
    //
    
    if (S_OK == hr)
    {   
        hr = pwcoBinding->Get(
                c_wszTargetIPAddress,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_I4 == V_VT(&vt));

        *pulAddress = static_cast<ULONG>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetComputerAddress(
    ULONG ulAddress
    )
    
{
    BOOLEAN fNameWasActive;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    ULONG ulOldAddress;
    VARIANT vt;

    if (0 == ulAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetTargetComputerAddress(&ulOldAddress);

        if (S_OK == hr)
        {
            hr = GetCurrentMethod(&fNameWasActive);
        }
    }

    //
    // If the new address is the same as the old address, and
    // we were previously using the address as the target (as
    // opposed to the name) we can skip the rest of the work.
    //

    if (S_OK == hr
        && (ulAddress != ulOldAddress || fNameWasActive))
    {
        hr = GetBindingObject(&pwcoBinding);
        
        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = ulAddress;

            hr = pwcoBinding->Put(
                    c_wszTargetIPAddress,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set that our name is no longer active
                //

                hr = SetBooleanValue(
                        pwcoBinding,
                        c_wszNameActive,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetPort(
    USHORT *pusPort
    )

{
    HRESULT hr;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {   
        hr = pwcoBinding->Get(
                c_wszTargetPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetPort(
    USHORT usPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    USHORT usOldPort;
    VARIANT vt;

    if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetTargetPort(&usOldPort);
    }

    if (S_OK == hr && usPort != usOldPort)
    {
        hr = GetBindingObject(&pwcoBinding);
        
        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoBinding->Put(
                    c_wszTargetPort,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetPortMappingBinding::GenerateTargetAddress(
    LPCWSTR pszwTargetName,
    ULONG *pulAddress
    )

{
    HRESULT hr;
    ULONG ulAddress = 0;
    BSTR bstrQuery;
    LPWSTR wszNameClause;
    LPWSTR wszWhereClause;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulCount;
    VARIANT vt;

    _ASSERT(NULL != pszwTargetName);
    _ASSERT(NULL != pulAddress);

    *pulAddress = 0;

    //
    // Check to see if there any other bindings w/ the same
    // name that have a valid address
    //
    // SELECT * FROM HNet_ConnectionPortMapping where
    //   TargetName = (our name) AND
    //   NameActive != FALSE AND
    //   TargetIPAddress != 0
    //

     hr = BuildQuotedEqualsString(
            &wszNameClause,
            c_wszTargetName,
            pszwTargetName
            );

    if (S_OK == hr)
    {
        hr = BuildAndString(
                &wszWhereClause,
                wszNameClause,
                L"NameActive != FALSE AND TargetIPAddress != 0"
                );

        delete [] wszNameClause;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wszWhereClause
                );

        delete [] wszWhereClause;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        pwcoInstance = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoInstance, &ulCount);

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // We got one. Return the address from this instance
            //

            hr = pwcoInstance->Get(
                    c_wszTargetIPAddress,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                _ASSERT(VT_I4 == V_VT(&vt));

                ulAddress = static_cast<ULONG>(V_I4(&vt));
            }

            pwcoInstance->Release();
        }
        else
        {
            hr = S_OK;
        }

        pwcoEnum->Release();
    }

    if (SUCCEEDED(hr) && 0 == ulAddress)
    {
        DWORD dwScopeAddress;
        DWORD dwScopeMask;
        ULONG ulScopeLength;
        ULONG ulIndex;
        WCHAR wszBuffer[128];
        
        //
        // No other binding using the same name was found. Generate
        // a new target address now
        //

        ReadDhcpScopeSettings(&dwScopeAddress, &dwScopeMask);
        ulScopeLength = NTOHL(~dwScopeMask);

        for (ulIndex = 1; ulIndex < ulScopeLength - 1; ulIndex++)
        {
            ulAddress = (dwScopeAddress & dwScopeMask) | NTOHL(ulIndex);
            if (ulAddress == dwScopeAddress) { continue; }

            //
            // Check to see if this address is already in use
            //

            _snwprintf(
                wszBuffer,
                ARRAYSIZE(wszBuffer),
                L"SELECT * FROM HNet_ConnectionPortMapping2 WHERE TargetIPAddress = %u",
                ulAddress
                );

            bstrQuery = SysAllocString(wszBuffer);

            if (NULL != bstrQuery)
            {
                pwcoEnum = NULL;
                hr = m_piwsHomenet->ExecQuery(
                        m_bstrWQL,
                        bstrQuery,
                        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                        NULL,
                        &pwcoEnum
                        );

                SysFreeString(bstrQuery);

                if (WBEM_S_NO_ERROR == hr)
                {
                    
                    pwcoInstance = NULL;
                    hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoInstance, &ulCount);

                    if (SUCCEEDED(hr))
                    {
                        if (0 == ulCount)
                        {
                            //
                            // This address isn't in use.
                            //

                            pwcoEnum->Release();
                            hr = S_OK;
                            break;
                        }
                        else
                        {
                            //
                            // Address already in use
                            //

                            pwcoInstance->Release();
                        }

                        pwcoEnum->Release();
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                break;
            }
        }
    }

    if (SUCCEEDED(hr) && 0 != ulAddress)
    {
        *pulAddress = ulAddress;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CHNetPortMappingBinding::GetBindingObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrBinding,
                ppwcoInstance
                );
}

HRESULT
CHNetPortMappingBinding::SendUpdateNotification()

{
    HRESULT hr = S_OK;
    IHNetConnection *pConnection;
    GUID *pConnectionGuid = NULL;
    IHNetPortMappingProtocol *pProtocol;
    GUID *pProtocolGuid = NULL;
    ISharedAccessUpdate *pUpdate;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetConnection(&pConnection);

        if (SUCCEEDED(hr))
        {
            hr = pConnection->GetGuid(&pConnectionGuid);
            pConnection->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = GetProtocol(&pProtocol);
        }

        if (SUCCEEDED(hr))
        {
            hr = pProtocol->GetGuid(&pProtocolGuid);
            pProtocol->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(
                    CLSID_SAUpdate,
                    NULL,
                    CLSCTX_SERVER,
                    IID_PPV_ARG(ISharedAccessUpdate, &pUpdate)
                    );

            if (SUCCEEDED(hr))
            {
                hr = pUpdate->ConnectionPortMappingChanged(
                        pConnectionGuid,
                        pProtocolGuid,
                        FALSE
                        );
                pUpdate->Release();
            }       
        }
    }

    if (NULL != pConnectionGuid)
    {
        CoTaskMemFree(pConnectionGuid);
    }

    if (NULL != pProtocolGuid)
    {
        CoTaskMemFree(pProtocolGuid);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\algsetup.h ===
// AlgSetup.h : Declaration of the CAlgSetup

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CAlgSetup
//
class ATL_NO_VTABLE CAlgSetup : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAlgSetup, &CLSID_AlgSetup>,
	public IDispatchImpl<IAlgSetup, &IID_IAlgSetup, &LIBID_NETCONLib>
{
public:
    DECLARE_REGISTRY(CAlgSetup, TEXT("Alg.AlgSetup.1"), TEXT("Alg.AlgSetup"), -1, THREADFLAGS_BOTH)

    DECLARE_NOT_AGGREGATABLE(CAlgSetup)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAlgSetup)
        COM_INTERFACE_ENTRY(IAlgSetup)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
    
//
// IAlgSetup
//
public:
	
	STDMETHODIMP Add(
        IN  BSTR    pszProgID, 
        IN  BSTR    pszPublisher, 
        IN  BSTR    pszProduct, 
        IN  BSTR    pszVersion, 
        IN  short   nProtocol,
        IN  BSTR    pszPorts
        );

    STDMETHODIMP Remove(
        IN  BSTR    pszProgID
        );



private:

    bool
    ArePortsAlreadyAssign(
        IN  LPCTSTR     pszPort,
        OUT BSTR*       pszOverlapping
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( alg_private )
EXTERN_PROXY_FILE( saupdate )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( alg_private ),
  REFERENCE_PROXY_FILE( saupdate ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\algsetup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Microsoft
//
// AlgSetup.cpp : Implementation of CAlgSetup
//
// JPDup    2001.01.01
//

//#include "pch.h"
#pragma hdrstop

#include "resource.h"   
#include "htmlhelp.h"
#include "sautil.h"

/////////////////////////////////////////////////////////////////////////////
// CConfirmation
//
class CConfirmation : public CDialogImpl<CConfirmation>
{
public:
    CConfirmation(
        LPCTSTR pszPublisher, 
        LPCTSTR pszProduct, 
        LPCTSTR pszPorts
    )
    {
        m_pszCompany = pszPublisher;
        m_pszProduct = pszProduct;
        m_pszPorts   = pszPorts;
        
    }
    
    ~CConfirmation()
    {
    }
    
    enum { IDD = IDD_CONFIRMATION };

    BEGIN_MSG_MAP(CConfirmation)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    END_MSG_MAP()
    
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SetDlgItemText(IDC_EDIT_COMPANY, m_pszCompany);
        SetDlgItemText(IDC_EDIT_PRODUCT, m_pszProduct);
        SetDlgItemText(IDC_EDIT_PORTS,   m_pszPorts);
        
        return 1;  // Let the system set the focus
    }
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }
    
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
                
        if ( CID_SA_ST_ICFLink == wParam )
        {
            UINT nCode = ((NMHDR* )lParam)->code;

            if ( NM_CLICK == nCode || NM_RETURN == nCode )
            {        

                // one help topic per SKU, 
                
                LPWSTR pszHelpTopic = NULL;
                
                OSVERSIONINFOEXW verInfo = {0};
                ULONGLONG ConditionMask = 0;
                
                verInfo.dwOSVersionInfoSize = sizeof(verInfo);
                verInfo.wProductType = VER_NT_WORKSTATION;
                verInfo.wSuiteMask = VER_SUITE_PERSONAL;
                
                VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);
                if ( 0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask) )
                {
                    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
                    if ( 0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE | VER_SUITENAME, ConditionMask) )
                    {
                        // personal
                        pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    }
                    else
                    {
                        // pro
                        pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    }
                }
                else
                {
                    // server
                    pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    
                }
                
                HtmlHelp(NULL, pszHelpTopic, HH_DISPLAY_TOPIC, 0);
                
                return 0;   
            }
        }

        return 1;
    }


    ULONG_PTR m_nSHFusion;   
    
    LPCTSTR  m_pszCompany;
    LPCTSTR  m_pszProduct;
    LPCTSTR  m_pszPorts;
};





/////////////////////////////////////////////////////////////////////////////
// CDlgInstallError
class CDlgInstallError : public CDialogImpl<CDlgInstallError>
{
public:
    CDlgInstallError(
        LONG nLastError
        )
    {
        m_nLastError = nLastError;
        //SHActivateContext(&m_nSHFusion);
    }

    ~CDlgInstallError()
    {
       //SHDeactivateContext(m_nSHFusion);        
    }

    enum { IDD = IDD_INSTALLERROR };

BEGIN_MSG_MAP(CDlgInstallError)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPVOID lpMsgBuf;

        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            m_nLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
            );

        SetDlgItemInt(IDC_EDIT_LASTERROR_CODE, m_nLastError, false);
        SetDlgItemText(IDC_EDIT_LASTERROR, (LPCTSTR)lpMsgBuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );

        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

//
// Properties
//
private:

    ULONG_PTR   m_nSHFusion;   
    LONG        m_nLastError;
   
};






//
//
//
STDMETHODIMP 
CAlgSetup::Add(
    BSTR    pszProgID, 
    BSTR    pszPublisher, 
    BSTR    pszProduct, 
    BSTR    pszVersion, 
    short   nProtocol,
    BSTR    pszPorts 
    )
{
    USES_CONVERSION;
    LONG lRet;

    //
    // Open the main ALG hive
    //
    CRegKey RegKeyISV;
    lRet = RegKeyISV.Create(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\ALG"));

    if ( ERROR_SUCCESS != lRet )
    {
        //
        // The OS is not setup correctly
        // ALG hive should have been present.
        //
        return HRESULT_FROM_WIN32(lRet);
    }


    lRet = RegKeyISV.Create(RegKeyISV, TEXT("ISV"));
    if ( ERROR_SUCCESS != lRet )
    {
        //
        // Weird we are able to create/open the parent hive but not the ISV hive
        // 
        return HRESULT_FROM_WIN32(lRet);
    }


    
    //
    // Will attempt to Open/Create the ALG hive key to see if the user has ADMINI rights
    // if not then we will reject the install no need to confirm the install since he can't write to the registry
    //
    CRegKey KeyThisAlgModule;
    lRet = KeyThisAlgModule.Create(RegKeyISV, OLE2T(pszProgID));

    if ( ERROR_SUCCESS != lRet )
    {

        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();
        return HRESULT_FROM_WIN32(lRet);
    }


    
    //
    //
    // Confirm that the ALG of the company/product is wanted by the user
    //
    //
    HANDLE hActivationContext;
    ULONG_PTR ulCookie;

    HRESULT hrLuna = ActivateLuna(&hActivationContext, &ulCookie);
    
    INITCOMMONCONTROLSEX CommonControlsEx;
    CommonControlsEx.dwSize = sizeof(CommonControlsEx);
    CommonControlsEx.dwICC = ICC_LINK_CLASS;

    if(InitCommonControlsEx(&CommonControlsEx))
    {
        
        CConfirmation DlgConfirm(
            OLE2T(pszPublisher), 
            OLE2T(pszProduct), 
            OLE2T(pszPorts)
            );
        
        if ( DlgConfirm.DoModal() != IDOK )
        {
            RegKeyISV.DeleteSubKey(OLE2T(pszProgID)); // Roll back created/test key
            return S_FALSE;
        }
    }
    
    if(SUCCEEDED(hrLuna))
    {
        DeactivateLuna(hActivationContext, ulCookie);
    }

    //
    // Write the news ALG plugin
    //
    KeyThisAlgModule.SetValue( OLE2T(pszPublisher),    TEXT("Publisher") );
    KeyThisAlgModule.SetValue( OLE2T(pszProduct),      TEXT("Product") );
    KeyThisAlgModule.SetValue( OLE2T(pszVersion),      TEXT("Version") );

    KeyThisAlgModule.SetValue( nProtocol,              TEXT("Protocol") );
    KeyThisAlgModule.SetValue( OLE2T(pszPorts),        TEXT("Ports") );


    // This will trigger the ALG.exe to refresh his load ALG modules
    RegKeyISV.SetValue(L"Enable", OLE2T(pszProgID) );     



    //
    // Add this ALG Module to the uninstall registry key in order to appear in the "Add/Remove Program"
    //
    CRegKey RegKeyUninstall;
    RegKeyUninstall.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
    RegKeyUninstall.Create(RegKeyUninstall, OLE2T(pszProgID));

    TCHAR szDisplayName[256];
    wsprintf(
        szDisplayName, 
        TEXT("Firewall Plugin Module from %s for %s version %s"), 
        OLE2T(pszPublisher), 
        OLE2T(pszProduct),
        OLE2T(pszVersion)
        );

    RegKeyUninstall.SetValue( szDisplayName, TEXT("DisplayName"));


    
    //
    // Setup the Add/Remove Program registry information in order to have the ALG be removed from the system
    //
    TCHAR szRunCommand[256];
    wsprintf(
        szRunCommand, 
        TEXT("RunDll32 %%SystemRoot%%\\system32\\hnetcfg.dll,AlgUninstall %s"), 
        OLE2T(pszProgID)
        );

    lRet = RegSetValueEx(
        RegKeyUninstall,            // handle to key
        TEXT("UninstallString"),    // value name
        0,                          // reserved
        REG_EXPAND_SZ,              // value type
        (const BYTE*)szRunCommand,               // value data
        (lstrlen(szRunCommand)+1)*sizeof(TCHAR)      // size of value data
        );

    //RegKeyUninstall.SetValue(szRunCommand, TEXT("UninstallString"));

    return S_OK;
}


//
//
//
STDMETHODIMP 
CAlgSetup::Remove(
    BSTR    pszProgID
    )
{
    USES_CONVERSION;


    TCHAR szRegPath[MAX_PATH];
    wsprintf(szRegPath,TEXT("SOFTWARE\\Microsoft\\ALG\\ISV"), OLE2T(pszProgID));


    CRegKey KeyAlgISV;


    //
    // Open the ISV hive
    //
    LONG lRet = KeyAlgISV.Open(HKEY_LOCAL_MACHINE, szRegPath);

    if ( ERROR_SUCCESS != lRet )
    {

        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();

        return HRESULT_FROM_WIN32(lRet);
    }


    //
    // Remove the ALG plugin key
    //
    lRet = KeyAlgISV.DeleteSubKey(OLE2T(pszProgID));

    if ( ERROR_SUCCESS != lRet && lRet != ERROR_FILE_NOT_FOUND )
    {
        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();

        return HRESULT_FROM_WIN32(lRet);
    }


    // This will trigger the ALG.exe to refresh his load ALG modules
    KeyAlgISV.DeleteValue(OLE2T(pszProgID) );     


    //
    // Remove from the Add/Remove Uninstall reg key
    //
    CRegKey RegKeyUninstall;
    RegKeyUninstall.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
    RegKeyUninstall.DeleteSubKey(OLE2T(pszProgID));


    return S_OK;
}



#define SIZE_PORTS  (ALG_SETUP_PORTS_LIST_BYTE_SIZE/sizeof(TCHAR))


//
//
//
bool
IsPortAlreadyAssign(
    IN  LPCTSTR     pszPort
    )
{

    CRegKey RegKeyISV;

    LRESULT lRet = RegKeyISV.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\ALG\\ISV"), KEY_READ);


    DWORD dwIndex=0;
    TCHAR szAlgModuleProgID[256];
    DWORD dwKeyNameSize;
    LONG  nRet;


    bool bPortAlreadyAssign=false;

    
    TCHAR* szPorts = new TCHAR[SIZE_PORTS];

    do
    {
        dwKeyNameSize = 256;

        nRet = RegEnumKeyEx(
            RegKeyISV.m_hKey,       // handle to key to enumerate
            dwIndex,                // subkey index
            szAlgModuleProgID,      // subkey name
            &dwKeyNameSize,         // size of subkey buffer
            NULL,                   // reserved
            NULL,                   // class string buffer
            NULL,                   // size of class string buffer
            NULL                    // last write time
            );

        dwIndex++; 

        if ( ERROR_NO_MORE_ITEMS == nRet )
            break;  // All items are enumerated we are done here


        if ( ERROR_SUCCESS == nRet )
        {
            CRegKey KeyALG;
            nRet = KeyALG.Open(RegKeyISV, szAlgModuleProgID, KEY_READ);

            if ( ERROR_SUCCESS == nRet )
            {
                //
                // str search to see if the port is in the ports list string
                // example is 21 is in   "39, 999, 21, 45"
                //
                
                ULONG nSizeOfPortsList = SIZE_PORTS;

                nRet = KeyALG.QueryValue(szPorts, TEXT("Ports"), &nSizeOfPortsList);

                if ( ERROR_SUCCESS == nRet )
                {
                    if ( wcsstr(szPorts, pszPort) != NULL )
                    {
                        bPortAlreadyAssign = true;
                    }
                 
                }
            }
        }
    } while ( ERROR_SUCCESS == nRet && bPortAlreadyAssign==false);

    delete szPorts;

    return bPortAlreadyAssign;
}








//
//
// This
//
void CALLBACK
AlgUninstall(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    CComObject<CAlgSetup>*   pAlgSetup;
    HRESULT hr = CComObject<CAlgSetup>::CreateInstance(&pAlgSetup);

    if ( SUCCEEDED(hr) )
    {
        TCHAR szConfirmRemove[512];
        TCHAR szTitle[512];


        LoadString(_Module.GetResourceInstance(), IDS_ADD_REMOVE,             szTitle, 512);
        LoadString(_Module.GetResourceInstance(), IDS_REMOVE_ALG_PLUGIN,      szConfirmRemove, 512);

        int nRet = MessageBox(
            GetFocus(), 
            szConfirmRemove, 
            szTitle, 
            MB_YESNO|MB_ICONQUESTION 
            );

        if ( IDYES == nRet )
        {
            CComBSTR    bstrAlgToRemove;
            bstrAlgToRemove = lpszCmdLine;

            pAlgSetup->Remove(bstrAlgToRemove);
        }
  
        delete pAlgSetup;  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\cfgmgr\hnprtmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . C P P 
//
//  Contents:   CHNetPortMappingProtocol implementation
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Atl methods
//

HRESULT
CHNetPortMappingProtocol::FinalConstruct()

{
    HRESULT hr = S_OK;

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CHNetPortMappingProtocol::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrProtocol) SysFreeString(m_bstrProtocol);
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    
    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetPortMappingProtocol::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProtocol);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    //
    // Read and cache our builtin value
    //

    hr = GetBooleanValue(
            pwcoInstance,
            c_wszBuiltIn,
            &m_fBuiltIn
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetWmiPathFromObject(pwcoInstance, &m_bstrProtocol);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        m_piwsHomenet = piwsNamespace;
        m_piwsHomenet->AddRef();
    }

    return hr;
}

//
// IHNetPortMappingProtocol methods
//


STDMETHODIMP
CHNetPortMappingProtocol::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszwName = NULL;
        
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Read the name property from our instance
        //

        hr = pwcoProtocol->Get(
                c_wszName,
                NULL,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        if (m_fBuiltIn)
        {
            UINT uiId;
            
            //
            // Attempt to convert the retrieved name to a resource
            // ID. (For localization purposes the names for builtin
            // protocols are stored as resources instead of directly
            // w/in the store.)
            //

            uiId = static_cast<UINT>(_wtoi(V_BSTR(&vt)));

            if (0 != uiId)
            {
                WCHAR wszBuffer[256];
                int iLength;

                iLength =
                    LoadString(
                        _Module.GetResourceInstance(),
                        uiId,
                        wszBuffer,
                        sizeof(wszBuffer) / sizeof(WCHAR)
                        );

                if (0 != iLength)
                {
                    //
                    // We were able to map the name to a resource. Allocate
                    // the output buffer and copy over the resource string.
                    //

                    *ppszwName =
                        reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc((iLength + 1) * sizeof(OLECHAR))
                            );

                    if (NULL != *ppszwName)
                    {
                        wcscpy(*ppszwName, wszBuffer);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr && NULL == *ppszwName)
        {
            //
            // This isn't a builtin protocol, or we weren't able to map
            // the stored "name" to a resource. Allocate the output
            // buffer and copy over the retrieved BSTR.
            //

            *ppszwName = reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                           * sizeof(OLECHAR))
                            );

            if (NULL != *ppszwName)
            {
                wcscpy(*ppszwName, V_BSTR(&vt));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingProtocol::SetName(
    OLECHAR *pszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (NULL == pszwName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Wrap the passed-in string in a BSTR and a variant
        //

        VariantInit(&vt);
        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(pszwName);
        if (NULL == V_BSTR(&vt))
        {
            hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr)
        {
            //
            // Set the property on the instance
            //

            hr = pwcoProtocol->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetIPProtocol(
    UCHAR *pucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pucProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszIPProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        *pucProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::SetIPProtocol(
    UCHAR ucProtocol
    )

{
    BOOLEAN fProtocolChanged = TRUE;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == ucProtocol)
    {
        hr = E_INVALIDARG;
    }

    if (S_OK == hr)
    {
        UCHAR ucOldProtocol;

        hr = GetIPProtocol(&ucOldProtocol);
        if (S_OK == hr && ucProtocol == ucOldProtocol)
        {
            fProtocolChanged = FALSE;
        }
    }


    if (S_OK == hr && fProtocolChanged)
    {
        USHORT usPort;
        
        //
        // Make sure that this won't result in a duplicate
        //

        hr = GetPort(&usPort);

        if (S_OK == hr)
        {
            if (PortMappingProtocolExists(
                    m_piwsHomenet,
                    m_bstrWQL,
                    usPort,
                    ucProtocol
                    ))
            {
                //
                // This change would result in a duplicate
                //

                hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }                    
        }

        if (S_OK == hr)
        {
            hr = GetProtocolObject(&pwcoProtocol);
        }

        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_UI1;
            V_UI1(&vt) = ucProtocol;

            hr = pwcoProtocol->Put(
                    c_wszIPProtocol,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoProtocol,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );         
            }

            pwcoProtocol->Release();
        }

        if (S_OK == hr)
        {
            //
            // Update SharedAccess of the change
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetPort(
    USHORT *pusPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::SetPort(
    USHORT usPort
    )

{
    BOOLEAN fPortChanged = TRUE;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }

    if (S_OK == hr)
    {
        USHORT usOldPort;
        
        //
        // Check if the new value is the same as the old
        //

        hr = GetPort(&usOldPort);
        if (S_OK == hr && usPort == usOldPort)
        {
            fPortChanged = FALSE;
        }
    }

    if (S_OK == hr && fPortChanged)
    {
        UCHAR ucIPProtocol;
        
        //
        // Make sure that this won't result in a duplicate
        //

        hr = GetIPProtocol(&ucIPProtocol);

        if (S_OK == hr)
        {
            if (PortMappingProtocolExists(
                    m_piwsHomenet,
                    m_bstrWQL,
                    usPort,
                    ucIPProtocol
                    ))
            {
                //
                // This change would result in a duplicate
                //

                hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }                    
        }

        if (S_OK == hr)
        {
            hr = GetProtocolObject(&pwcoProtocol);
        }
        
        if (S_OK == hr)
        {
            //
            // WMI uses V_I4 for it's uint16 type
            //
            
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoProtocol->Put(
                    c_wszPort,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoProtocol,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoProtocol->Release();
        }

        if (S_OK == hr)
        {
            //
            // Update SharedAccess of the change
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetBuiltIn(
    BOOLEAN *pfBuiltIn
    )

{
    HRESULT hr = S_OK;

    if (NULL != pfBuiltIn)
    {
        *pfBuiltIn = m_fBuiltIn;
    }
    else
    {
        hr = E_POINTER;
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingProtocol::Delete()

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    BSTR bstrQuery = NULL;
    ULONG ulCount;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't delete builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else
    {
        LPWSTR pwsz;
        
        //
        // Query for all HNet_ConnectionPortMapping instances
        // that refer to this protocol -- i.e.,
        //
        // SELECT * FROM HNet_ConnectionPortMapping2 WHERE PROTOCOL = m_bstrProtocol
        //
        // We can't use a references query here since once we delete the
        // protocol object that query won't return any results...
        //

        hr = BuildEscapedQuotedEqualsString(
                &pwsz,
                c_wszProtocol,
                m_bstrProtocol
                );

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionPortMapping,
                    pwsz
                    );

            delete [] pwsz;
        }
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        m_piwsHomenet->ExecQuery(
            m_bstrWQL,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &pwcoEnum
            );

        //
        // The query BSTR will be used again below
        //
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Loop through the enumeration, making sure that each entry
        // is disabled
        //

        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulCount
                );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                HRESULT hr2;
                CComObject<CHNetPortMappingBinding> *pBinding;
                
                //
                // Convert this to an actual CHNetPortMappingBinding so
                // that we can disable it and generate the change
                // notification for SharedAccess.
                //

                hr2 = CComObject<CHNetPortMappingBinding>::CreateInstance(&pBinding);
                if (SUCCEEDED(hr2))
                {
                    pBinding->AddRef();

                    hr2 = pBinding->Initialize(m_piwsHomenet, pwcoInstance);
                    if (SUCCEEDED(hr))
                    {
                        hr2 = pBinding->SetEnabled(FALSE);
                    }

                    pBinding->Release();
                }
                
                pwcoInstance->Release();
            }
        }
        while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnum->Release();
        hr = WBEM_S_NO_ERROR;
    }


    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Delete the protocol instance
        //
        
        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProtocol,
                0,
                NULL,
                NULL
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Now that the protocol instance is gone enumerate and
        // delete the bindings that refer to this instance. This
        // needs to happen after the protocol instance is gone to
        // prevent the instance from being recreated after we
        // delete it here.
        //

        pwcoEnum = NULL;
        m_piwsHomenet->ExecQuery(
            m_bstrWQL,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &pwcoEnum
            );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulCount
                );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                DeleteWmiInstance(m_piwsHomenet, pwcoInstance);
                pwcoInstance->Release();
            }
        }
        while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnum->Release();
        hr = WBEM_S_NO_ERROR;
    }

    if ( WBEM_S_NO_ERROR == hr )
    {
         SendPortMappingListChangeNotification();
    }

    //
    // bstrQuery is initialized to NULL at start, and SysFreeString
    // can deal w/ NULL input, so it's safe to call this even on
    // an error path.
    //

    SysFreeString(bstrQuery);

    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetGuid(
    GUID **ppGuid
    )

{
    HRESULT hr;
    IWbemClassObject *pwcoInstance;
    VARIANT vt;

    if (NULL != ppGuid)
    {
        *ppGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL != *ppGuid)
        {
            hr = GetProtocolObject(&pwcoInstance);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszId,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            ASSERT(VT_BSTR == V_VT(&vt));

            hr = CLSIDFromString(V_BSTR(&vt), *ppGuid);
            VariantClear(&vt);
        }

        pwcoInstance->Release();                
    }

    if (FAILED(hr) && NULL != ppGuid && NULL != *ppGuid)
    {
        CoTaskMemFree(*ppGuid);
        *ppGuid = NULL;
    }

    return hr;
    
}

//
// IHNetPrivate methods
//

STDMETHODIMP
CHNetPortMappingProtocol::GetObjectPath(
    BSTR *pbstrPath
    )

{
    HRESULT hr = S_OK;

    if (NULL != pbstrPath)
    {
        _ASSERT(m_bstrProtocol != NULL);

        *pbstrPath = SysAllocString(m_bstrProtocol);
        if (NULL == *pbstrPath)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetPortMappingProtocol::GetProtocolObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProtocol,
                ppwcoInstance
                );
}

HRESULT
CHNetPortMappingProtocol::SendUpdateNotification()

{
    HRESULT hr = S_OK;
    IEnumHNetPortMappingBindings *pEnum;
    GUID *pProtocolGuid = NULL;
    ISharedAccessUpdate *pUpdate;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetGuid(&pProtocolGuid);
        
        //
        // Get the enumeration of enabled port mapping
        // bindings for this protocol
        //

        if (SUCCEEDED(hr))
        {
            hr = GetEnabledBindingEnumeration(&pEnum);
        }

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(
                    CLSID_SAUpdate,
                    NULL,
                    CLSCTX_SERVER,
                    IID_PPV_ARG(ISharedAccessUpdate, &pUpdate)
                    );

            if (SUCCEEDED(hr))
            {
                IHNetPortMappingBinding *pBinding;
                IHNetConnection *pConnection;
                GUID *pConnectionGuid;
                ULONG ulCount;
                
                do
                {
                    hr = pEnum->Next(1, &pBinding, &ulCount);
                    if (SUCCEEDED(hr) && 1 == ulCount)
                    {
                        hr = pBinding->GetConnection(&pConnection);
                        pBinding->Release();

                        if (SUCCEEDED(hr))
                        {
                            hr = pConnection->GetGuid(&pConnectionGuid);
                            pConnection->Release();
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = pUpdate->ConnectionPortMappingChanged(
                                    pConnectionGuid,
                                    pProtocolGuid,
                                    TRUE
                                    );
                            CoTaskMemFree(pConnectionGuid);
                        }
                    }
                }
                while (SUCCEEDED(hr) && 1 == ulCount);

                pUpdate->Release();
            }

            pEnum->Release();
        }
    }

    if (NULL != pProtocolGuid)
    {
        CoTaskMemFree(pProtocolGuid);
    }

    return hr;
}

HRESULT
CHNetPortMappingProtocol::GetEnabledBindingEnumeration(
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    BSTR bstr;
    HRESULT hr = S_OK;
    OLECHAR *pwsz;
    OLECHAR *pwszWhere;
    
    _ASSERT(NULL != ppEnum);

    //
    // Generate the query string
    //

    hr = BuildEscapedQuotedEqualsString(
            &pwsz,
            c_wszProtocol,
            m_bstrProtocol
            );

    if (S_OK == hr)
    {
        hr = BuildAndString(
                &pwszWhere,
                pwsz,
                L"Enabled != FALSE"
                );
        
        delete [] pwsz;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                pwszWhere
                );

        delete [] pwszWhere;
    }

    //
    // Execute the query and build the enumerator
    //

    if (S_OK == hr)
    {
        IEnumWbemClassObject *pwcoEnum = NULL;

        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );
        
        SysFreeString(bstr);

        if (WBEM_S_NO_ERROR == hr)
        {
            CComObject<CEnumHNetPortMappingBindings> *pEnum;
            hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

            if (S_OK == hr)
            {
                pEnum->AddRef();
                hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

                if (S_OK == hr)
                {
                    hr = pEnum->QueryInterface(
                            IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                            );
                }

                pEnum->Release();
            }

            pwcoEnum->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for hnetcfg.dll
//
//  Notes:
//
//  Author:     jonburs   22 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif





// extern
extern void SetSAUIhInstance (HINSTANCE hInstance); // in saui.cpp

// Global
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPNAT, CUPnPNAT)
    OBJECT_ENTRY(CLSID_HNetCfgMgr, CHNetCfgMgr)
    OBJECT_ENTRY(CLSID_NetSharingManager, CNetSharingManager)
    OBJECT_ENTRY(CLSID_AlgSetup, CAlgSetup)
END_OBJECT_MAP()

HRESULT
CompileMof(
    );


//+---------------------------------------------------------------------------
// DLL Entry Point
//

EXTERN_C
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID pvReserved
    )
{
    if ( !PrxDllMain(hInstance, dwReason, pvReserved) )
    {
        return FALSE;
    }


    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ::DisableThreadLibraryCalls(hInstance);
        
        _Module.Init(ObjectMap, hInstance, &LIBID_NETCONLib);
        
        InitializeOemApi( hInstance );
        SetSAUIhInstance (hInstance);
        EnableOEMExceptionHandling();
        EnableNATExceptionHandling();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        ReleaseOemApi();
        DisableOEMExceptionHandling();
        DisableNATExceptionHandling();
    } else if (dwReason == DLL_THREAD_ATTACH) {
        EnableOEMExceptionHandling();
        EnableNATExceptionHandling();
    } else if (dwReason == DLL_THREAD_DETACH) {
        DisableOEMExceptionHandling();
        DisableNATExceptionHandling();
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(VOID)
{
    if ( PrxDllCanUnloadNow() != S_OK )
    {
        return S_FALSE;
    }
    
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
    
    return _Module.GetClassObject(rclsid, riid, ppv);
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer()
{
    HRESULT hr = PrxDllRegisterServer();
    
    if ( FAILED(hr) )
        return hr;
        
    hr = _Module.RegisterServer(TRUE);

    if (SUCCEEDED(hr))  // register second typelib
        hr = _Module.RegisterTypeLib (_T("\\2"));

    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer()
{
    PrxDllUnregisterServer();
    
    _Module.UnregisterServer(TRUE);
    _Module.UnRegisterTypeLib (_T("\\2"));
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\fwpages.h ===
#pragma once
#include <hnetcfg.h>


typedef struct tagCFirewallLoggingDialog
{
    IHNetFirewallSettings* pFirewallSettings;
    HNET_FW_LOGGING_SETTINGS* pSettings;

} CFirewallLoggingDialog;

typedef struct tagCICMPSettingsDialog
{
    IHNetConnection* pConnection;
    HNET_FW_ICMP_SETTINGS* pSettings;
} CICMPSettingsDialog;

HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager);
HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis);
INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam);

HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection);
HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis);
INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\fwpages.cpp ===
#include "pch.h"
#pragma hdrstop

#include "sautil.h"
#include "resource.h"

#include "fwpages.h"
#include <stddef.h>
#include <commdlg.h>

#define DEFAULT_FIREWALL_LOGFILE_SIZE 4096
#define DEFAULT_FIREWALL_LOGFILE_PATH TEXT("\\pfirewall.log")

extern LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem );

static DWORD g_adwFirewallLoggingHelp[] =
{
    CID_FL_CB_LogDroppedInbound, HID_FL_CB_LogDroppedInbound,
    CID_FL_CB_LogOutboundConnections, HID_FL_CB_LogOutboundConnections,
    CID_FL_EB_Filename, HID_FL_EB_Filename,
    CID_FL_PB_Browse, HID_FL_PB_Browse,
    CID_FL_EB_Filesize, HID_FL_EB_Filesize,
    CID_FL_PB_RestoreDefaults, HID_FL_PB_RestoreDefaults,
    0, 0
};

static DWORD g_adwICMPHelp[] =
{
    CID_IC_LV_Settings, HID_IC_LV_Settings,
    CID_IC_ST_Description, HID_IC_ST_Description,
    0, 0
};

typedef struct tagICMPEntry
{
    UINT uiStringID;
    UINT uiDescID;
    size_t Offset;
} ICMPEntry;

static ICMPEntry g_ICMPEntries[] =
{
    {SID_ICMP_IECHO, SID_ICMP_IECHO_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundEchoRequest)},  
    {SID_ICMP_ITIME, SID_ICMP_ITIME_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundTimestampRequest)},  
    {SID_ICMP_IMASK, SID_ICMP_IMASK_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundMaskRequest)},  
    {SID_ICMP_IROUT, SID_ICMP_IROUT_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundRouterRequest)},  
    {SID_ICMP_ODEST, SID_ICMP_ODEST_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundDestinationUnreachable)},  
    {SID_ICMP_OQNCH, SID_ICMP_OQNCH_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundSourceQuench)},  
    {SID_ICMP_OPRAM, SID_ICMP_OPRAM_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundParameterProblem)},  
    {SID_ICMP_OTIME, SID_ICMP_OTIME_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundTimeExceeded)},  
    {SID_ICMP_XRDRT, SID_ICMP_XRDRT_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowRedirect)},
    {0, 0},
};


HRESULT CFirewallLoggingDialog_GetDefaultLogfilePath(LPTSTR* ppszLogFilePath);
HRESULT CFirewallLoggingDialog_RestoreDefaults(HWND hwnd);
HRESULT CFirewallLoggingDialog_Apply(CFirewallLoggingDialog* pThis, HWND hWindow);
HRESULT CFirewallLoggingDialog_BrowseForLogfileName(HWND hWindow);

HRESULT CICMPSettingsDialog_Apply(CICMPSettingsDialog* pThis, HWND hWindow);
HRESULT CICMPSettingsDialog_ShowDescriptionText(HWND hwnd, INT nIndex);

INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'Firewall Logging' page.
    //
{
    HRESULT hr = S_OK;
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            PROPSHEETPAGE* pPropertySheetPage = (PROPSHEETPAGE*) lparam;
            CFirewallLoggingDialog* pFirewallLoggingDialog = (CFirewallLoggingDialog*) pPropertySheetPage->lParam;
            HNET_FW_LOGGING_SETTINGS* pSettings = pFirewallLoggingDialog->pSettings;

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pFirewallLoggingDialog);
            
            // Ignore if this fails, we're better off without it than killing the whole page
            CreateUpDownControl(WS_CHILD | WS_VISIBLE | WS_BORDER | UDS_SETBUDDYINT
                | UDS_ALIGNRIGHT | UDS_NOTHOUSANDS | UDS_ARROWKEYS, 0, 0, 0, 0, hwnd, -1, g_hinstDll, GetDlgItem(hwnd, CID_FL_EB_Filesize), UD_MAXVAL, 0, 0);

            if(NULL != pSettings)
            {
                SetDlgItemText(hwnd, CID_FL_EB_Filename, pSettings->pszwPath);
                SetDlgItemInt(hwnd, CID_FL_EB_Filesize, (UINT) (pSettings->ulMaxFileSize / 1024), FALSE); // REVIEW safe cast?
                CheckDlgButton(hwnd, CID_FL_CB_LogOutboundConnections, pSettings->fLogConnections ? BST_CHECKED : BST_UNCHECKED);
                CheckDlgButton(hwnd, CID_FL_CB_LogDroppedInbound, pSettings->fLogDroppedPackets ? BST_CHECKED : BST_UNCHECKED);
            }
            else
            {
                CFirewallLoggingDialog_RestoreDefaults(hwnd);                
            }


            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp(g_adwFirewallLoggingHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            
            case CID_FL_PB_Browse:
                CFirewallLoggingDialog_BrowseForLogfileName(hwnd);
                break;
            
            case CID_FL_PB_RestoreDefaults:
                CFirewallLoggingDialog_RestoreDefaults(hwnd);
                break;

            }
            break;
        }
        
        case WM_NOTIFY:
        {
            switch (((NMHDR*)lparam)->code)
            {
            case PSN_KILLACTIVE:
                {
                    BOOL bTranslated;
                    UINT uiLogFileSize = GetDlgItemInt(hwnd, CID_FL_EB_Filesize, &bTranslated, FALSE);
                    if(TRUE == bTranslated)
                    {
                        if(UD_MAXVAL < uiLogFileSize || 1 > uiLogFileSize)
                        {

                            MsgDlg(hwnd, SID_FwbInvalidSize, NULL);
                            hr = E_UNEXPECTED;
                        }

                    }
                    else
                    {
                        MsgDlg(hwnd, SID_FwbInvalidSize, NULL);
                        hr = E_FAIL;
                    }

                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }
            
            case PSN_APPLY:
                {
                    CFirewallLoggingDialog* pFirewallLoggingDialog;
                    pFirewallLoggingDialog = (CFirewallLoggingDialog*) GetWindowLongPtr(hwnd, DWLP_USER);
                    hr = CFirewallLoggingDialog_Apply(pFirewallLoggingDialog, hwnd);
                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}

HRESULT CFirewallLoggingDialog_RestoreDefaults(HWND hwnd)
{
    HRESULT hr;
    LPTSTR pszLogFilePath;
    hr = CFirewallLoggingDialog_GetDefaultLogfilePath(&pszLogFilePath);
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(hwnd, CID_FL_EB_Filename, pszLogFilePath);
        CoTaskMemFree(pszLogFilePath);
    }

    SetDlgItemInt(hwnd, CID_FL_EB_Filesize, DEFAULT_FIREWALL_LOGFILE_SIZE, FALSE);
    CheckDlgButton(hwnd, CID_FL_CB_LogOutboundConnections, BST_UNCHECKED);
    CheckDlgButton(hwnd, CID_FL_CB_LogDroppedInbound, BST_UNCHECKED);

    return hr;
}

HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager)
{
    HRESULT hr;
    
    hr = pHomenetConfigManager->QueryInterface (IID_IHNetFirewallSettings, 
                                    (void**)&pThis->pFirewallSettings);
    if(SUCCEEDED(hr))
    {
        hr = pThis->pFirewallSettings->GetFirewallLoggingSettings (&pThis->pSettings);
        if(HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND) == hr)
        {
            ASSERT(NULL == pThis->pSettings);
            hr = S_OK;
        }

        if(FAILED(hr))
        {
            pThis->pFirewallSettings->Release();
            pThis->pFirewallSettings = NULL;
        }
    }

    return hr;
}

HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis)
{
    pThis->pFirewallSettings->Release();
    if(NULL != pThis->pSettings)
    {
        if(NULL != pThis->pSettings->pszwPath)
        {
            CoTaskMemFree(pThis->pSettings->pszwPath);
        }                        

    }
    return S_OK;
}


HRESULT CFirewallLoggingDialog_GetDefaultLogfilePath(LPTSTR* ppszLogfilePath)
{
    HRESULT hr = S_OK;
    LPTSTR pszAppendPath = DEFAULT_FIREWALL_LOGFILE_PATH;
    LPTSTR pszLogfilePath;
    UINT uiPathLength, uiLength;

    ASSERT(NULL != ppszLogfilePath);

    uiPathLength = GetWindowsDirectory(NULL, 0);
    if(0 != uiPathLength)
    {
        uiPathLength += lstrlen(pszAppendPath) + 1;
        pszLogfilePath = (LPTSTR) CoTaskMemAlloc((ULONG) (uiPathLength * sizeof(TCHAR)));
        if(NULL != pszLogfilePath)
        {
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            uiLength = GetWindowsDirectory(pszLogfilePath, uiPathLength);
            if(0 != uiLength)
            {
                // REVIEW if the size of the windir somehow changes then we have problems, but this can't happen right?
                //
                lstrcpyn(
                    pszLogfilePath + uiLength,
                    TEXT('\\') == pszLogfilePath[uiLength - 1] ?
                        pszAppendPath + 1 : pszAppendPath,
                    uiPathLength - uiLength);
                *ppszLogfilePath = pszLogfilePath;
            }
            else
            {
                hr = E_FAIL;
            }

            if(FAILED(hr))
            {
                CoTaskMemFree(pszLogfilePath);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CFirewallLoggingDialog_Apply(CFirewallLoggingDialog* pThis, HWND hWindow)
{
    HRESULT hr = S_OK;
    HNET_FW_LOGGING_SETTINGS NewSettings;
    BOOL bTranslated;
    UINT uiLogFileSize;
    UINT uiSizeNeeded;

    NewSettings.fLogDroppedPackets = BST_CHECKED == IsDlgButtonChecked(hWindow, CID_FL_CB_LogDroppedInbound);
    NewSettings.fLogConnections = BST_CHECKED == IsDlgButtonChecked(hWindow, CID_FL_CB_LogOutboundConnections);
    NewSettings.pszwPath = NULL;

    if(SUCCEEDED(hr))
    {
        uiSizeNeeded = Edit_GetTextLength(GetDlgItem(hWindow, CID_FL_EB_Filename)) + 1;
        if(0 != uiSizeNeeded)
        {
            NewSettings.pszwPath = (LPWSTR) CoTaskMemAlloc((ULONG) (uiSizeNeeded * sizeof(TCHAR)));
            if(NULL != NewSettings.pszwPath)
            {
                uiSizeNeeded = GetDlgItemText(hWindow, CID_FL_EB_Filename, NewSettings.pszwPath, uiSizeNeeded);
                if(0 == uiSizeNeeded)
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED; // invalid param, empty filename
        }
        
    }
    
    if(SUCCEEDED(hr))
    {
        uiLogFileSize = GetDlgItemInt(hWindow, CID_FL_EB_Filesize, &bTranslated, FALSE);
        if(TRUE == bTranslated)
        {
            NewSettings.ulMaxFileSize = 1024 * (ULONG) uiLogFileSize;
        }
        else
        {
            hr = E_UNEXPECTED; // invalid param
        }
    }
    
    if(SUCCEEDED(hr))
    {
        BOOL bDirty = TRUE;

        if(NULL != pThis->pSettings) // we may not have gotten one on GetFirewallLoggingSettings
        {
            bDirty = FALSE;
            bDirty |= NewSettings.fLogDroppedPackets != pThis->pSettings->fLogDroppedPackets;
            bDirty |= NewSettings.fLogConnections != pThis->pSettings->fLogConnections;
            bDirty |= NewSettings.ulMaxFileSize != pThis->pSettings->ulMaxFileSize;
            bDirty |= 0 != lstrcmp(NewSettings.pszwPath, pThis->pSettings->pszwPath);
        }

        if(TRUE == bDirty)
        {
            hr = pThis->pFirewallSettings->SetFirewallLoggingSettings (&NewSettings);
        }
    }

    if(NULL != NewSettings.pszwPath)
    {
        CoTaskMemFree(NewSettings.pszwPath);
    }

    return hr;
}

HRESULT CFirewallLoggingDialog_BrowseForLogfileName(HWND hWindow)
{
    HRESULT hr = S_OK;

    OPENFILENAME ofn;
    TCHAR* pszFilterDesc;
    TCHAR* pszFilter;
    TCHAR* pszDefExt;
    TCHAR* pszTitle;
    TCHAR szBuf[ MAX_PATH + 1 ] = L"";
    TCHAR szDir[ MAX_PATH + 1] = L"";

    // Fill in FileOpen dialog parameter buffer.
    //
    
    // if any of these fail just let them be null
    pszFilterDesc = PszFromId( g_hinstDll, SID_FwbFilterDesc );
    pszTitle = PszFromId( g_hinstDll, SID_FwbTitle );
    pszDefExt = PszFromId( g_hinstDll, SID_FwbDefExt );

    // if this fails we will have a null path, so the open dialog should open at the root
    if(0 != GetDlgItemText(hWindow, CID_FL_EB_Filename, szDir, sizeof(szDir) / sizeof(TCHAR)))
    {
        // lose the file name
        LPWSTR pszLastSlash = wcsrchr(szDir, L'\\');
        if(NULL != pszLastSlash)
        {
            *pszLastSlash = L'\0';
        }
    }
    
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetParent( hWindow );
    ofn.hInstance = g_hinstDll;
    ofn.lpstrFilter = pszFilterDesc;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuf;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = pszTitle;
    ofn.lpstrDefExt = pszDefExt;
    ofn.Flags = 0;

    if (GetOpenFileName (&ofn))
    {
        SetWindowText( GetDlgItem(hWindow, CID_FL_EB_Filename), ofn.lpstrFile );
    }

    Free0(pszTitle);
    Free0(pszDefExt);
    Free0(pszFilterDesc);

    return S_OK;
}

INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'ICMP' page.
    //
{
    HRESULT hr;
    // Give the extended list-control a chance to look at all messages first.
    //
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, SasLvxCallback))
    {
        return TRUE;
    }
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            UINT i = 0;
            UINT uiEntry = 0;
            LVITEM lvi;
            HWND hListView;

            PROPSHEETPAGE* pPropertySheetPage = (PROPSHEETPAGE*) lparam;
            CICMPSettingsDialog* pICMPSettingsDialog = (CICMPSettingsDialog*) pPropertySheetPage->lParam;
            HNET_FW_ICMP_SETTINGS* pSettings = pICMPSettingsDialog->pSettings;
            ASSERT(NULL != pSettings);

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pICMPSettingsDialog);
            
            hListView = GetDlgItem(hwnd, CID_IC_LV_Settings);
            ASSERT(NULL != hListView);

            ListView_InstallChecks(hListView, g_hinstDll);
            ListView_InsertSingleAutoWidthColumn(hListView);
            
            while(0 != g_ICMPEntries[uiEntry].uiStringID)
            {
                LPTSTR pszText = PszFromId(g_hinstDll, g_ICMPEntries[uiEntry].uiStringID);
                if(NULL != pszText)
                {
                
                    ZeroMemory(&lvi, sizeof(lvi));
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    lvi.iItem = i + 1; // add to end
                    lvi.lParam = (LPARAM) g_ICMPEntries[uiEntry].Offset;
                    lvi.pszText = pszText;
                    lvi.cchTextMax = lstrlen(pszText) + 1;
                    
                    i = ListView_InsertItem(hListView, &lvi);
                    if (i != -1)
                    {
                        ListView_SetCheck(hListView, i, (BOOLEAN)*((BYTE*)pSettings + g_ICMPEntries[uiEntry].Offset)); // REVIEW 64bit safe?
                    }
                    Free(pszText);
                }
                uiEntry++;
            }
            ListView_SetItemState(hListView, 0, LVIS_SELECTED, LVIS_SELECTED);
            CICMPSettingsDialog_ShowDescriptionText(hwnd, 0);

            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp(g_adwICMPHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR*)lparam)->code)
            {
                case PSN_APPLY:
                {
                    CICMPSettingsDialog* pICMPSettingsDialog;
                    pICMPSettingsDialog = (CICMPSettingsDialog*) GetWindowLongPtr(hwnd, DWLP_USER);
                    hr = CICMPSettingsDialog_Apply(pICMPSettingsDialog, hwnd);
                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    INT nSelectedItem;
                    LPNMLISTVIEW ListViewInfo = (LPNMLISTVIEW) lparam;
                    if(-1 != ListViewInfo->iItem && LVIS_SELECTED & ListViewInfo->uNewState)
                    {
                        CICMPSettingsDialog_ShowDescriptionText(hwnd, ListViewInfo->iItem);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection)
{
    HRESULT hr;
    
    pThis->pConnection = pHomenetConnection;
    pHomenetConnection->AddRef();
    
    hr = pHomenetConnection->GetIcmpSettings (&pThis->pSettings);
    if(FAILED(hr))
    {
        pHomenetConnection->Release();
    }
    return hr;

}

HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis)
{
    ASSERT(pThis->pConnection);
    pThis->pConnection->Release();
    
    ASSERT(pThis->pSettings);
    CoTaskMemFree(pThis->pSettings);
    return S_OK;
}

HRESULT CICMPSettingsDialog_Apply(CICMPSettingsDialog* pThis, HWND hWindow)
{
    HRESULT hr = S_OK;
    HNET_FW_ICMP_SETTINGS NewSettings;
    BOOL bDirty = FALSE;
    HWND hListView;
    LVITEM lvi;
    int nItemCount;

    hListView = GetDlgItem(hWindow, CID_IC_LV_Settings);
    ASSERT(NULL != hListView);

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;

    nItemCount = ListView_GetItemCount(hListView);
    while(0 < nItemCount--)
    {
        BOOLEAN bChecked = (BOOLEAN) ListView_GetCheck(hListView, nItemCount); // REVIEW can this error?
        lvi.iItem = nItemCount;

        if(TRUE == ListView_GetItem(hListView, &lvi))
        {
            (BOOLEAN)*((BYTE*)&NewSettings + lvi.lParam) = bChecked;
            if(bChecked != (BOOLEAN)*((BYTE*)(pThis->pSettings) + lvi.lParam)) // REVIEW 64bit safe?
            {
                bDirty = TRUE;
            }
        }
    }
    
    if(bDirty)
    {
        hr = pThis->pConnection->SetIcmpSettings (&NewSettings);
    }


    return hr;
}

HRESULT CICMPSettingsDialog_ShowDescriptionText(HWND hwnd, INT nIndex)
{
    
    LPWSTR pszDescription = PszFromId(g_hinstDll, g_ICMPEntries[nIndex].uiDescID);
    if(NULL != pszDescription)
    {
        SetDlgItemText(hwnd, CID_IC_ST_Description, pszDescription);
        Free(pszDescription);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hnapien.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I E N . C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop


/*++

  CNetSharingManager::EnumEveryConnections

Routine Description:

	Return an IEnumNetEveryConnection interface used to enumerate all of
	the contained INetConnections configured as a public adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumEveryConnection(
    INetSharingEveryConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingEveryConnection * pENEC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
    	*ppColl = NULL;
		hr      = E_ACCESSDENIED;
	}
	else
	{
    	*ppColl = NULL;
        
		INetConnectionManager* pManager = NULL;
        
		hr = CoCreateInstance( CLSID_ConnectionManager,
        					   NULL,
                               CLSCTX_ALL,
                               IID_PPV_ARG(INetConnectionManager, &pManager) );
                               
        if ( SUCCEEDED(hr) )
        {
		    IEnumNetConnection* pNetEnum = NULL;
			
	        SetProxyBlanket(pManager);

	        hr = pManager->EnumConnections(NCME_DEFAULT, &pNetEnum);
            
            if ( SUCCEEDED(hr) )
            {
		        CComObject<CSharingManagerEnumEveryConnection>* pEnum;

		        hr = CComObject<CSharingManagerEnumEveryConnection>::CreateInstance(&pEnum);

		        if ( SUCCEEDED(hr) )
	            {
		            pEnum->AddRef();

		            hr = pEnum->Initialize( pNetEnum, ICSSC_DEFAULT );

		            if ( SUCCEEDED(hr) )
	    	        {
		                hr = pEnum->QueryInterface(
		                        IID_PPV_ARG(IEnumNetSharingEveryConnection, &pENEC)
		                        );
					}

		            ReleaseObj(pEnum);
	            }
            
            	ReleaseObj(pNetEnum);
            }
         
         	ReleaseObj(pManager);   
    	}
    }
    
    // create collection:
    if (pENEC) {
        if (hr == S_OK) {
            CComObject<CNetSharingEveryConnectionCollection>* pNECC = NULL;
            hr = CComObject<CNetSharingEveryConnectionCollection>::CreateInstance (&pNECC);
            if (pNECC) {
                pNECC->AddRef();
                pNECC->Initialize (pENEC);
                hr = pNECC->QueryInterface (__uuidof(INetSharingEveryConnectionCollection), (void**)ppColl);
                pNECC->Release();
            }
        }
        pENEC->Release();
    }

    return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingManager::EnumPublicConnections

Routine Description:

	Return an IEnumNetPublicConnection interface used to enumerate all of
	the contained INetConnections configured as a public adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumPublicConnections(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumNetPublicConnection**   ppEnum
    INetSharingPublicConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPublicConnection * pENPC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else
	{
		IEnumHNetIcsPublicConnections* pHNetEnum;

		hr = m_pIcsSettings->EnumIcsPublicConnections( &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
	        CComObject<CSharingManagerEnumPublicConnection>* pEnum;

	        hr = CComObject<CSharingManagerEnumPublicConnection>::CreateInstance(&pEnum);

	        if ( SUCCEEDED(hr) )
	        {
	            pEnum->AddRef();

	            hr = pEnum->Initialize( pHNetEnum, Flags );

	            if ( SUCCEEDED(hr) )
    	        {
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPublicConnection, &pENPC)
	                        );
				}

	            ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
        }
	}
    
    // create collection:
    if (pENPC) {
        if (hr == S_OK) {
            CComObject<CNetSharingPublicConnectionCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPublicConnectionCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pENPC);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPublicConnectionCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pENPC->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}


/*++

  CNetSharingManager::EnumPrivateConnections

Routine Description:

	Return an IEnumNetPrivateConnection interface used to enumerate all of
	the contained INetConnections configured as a private adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumPrivateConnections(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumNetPrivateConnection**  ppEnum)
    INetSharingPrivateConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPrivateConnection * pENPC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else
	{
		IEnumHNetIcsPrivateConnections* pHNetEnum;

		hr = m_pIcsSettings->EnumIcsPrivateConnections( &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
	        CComObject<CSharingManagerEnumPrivateConnection>* pEnum;

	        hr = CComObject<CSharingManagerEnumPrivateConnection>::CreateInstance(&pEnum);

	        if ( SUCCEEDED(hr) )
	        {
	            pEnum->AddRef();

	            hr = pEnum->Initialize( pHNetEnum, Flags );

	            if ( SUCCEEDED(hr) )
    	        {
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPrivateConnection, &pENPC)
	                        );
				}

	            ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
        }
	}

    // create collection:
    if (pENPC) {
        if (hr == S_OK) {
            CComObject<CNetSharingPrivateConnectionCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPrivateConnectionCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pENPC);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPrivateConnectionCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pENPC->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::get_EnumPortMappings(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumSharingPortMapping**     ppEnum)
    INetSharingPortMappingCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPortMapping * pESPM = NULL;
    // idea:  use existing code below to fill out pESPM,
    // then convert to collection
	HRESULT hr = S_OK;

	IHNetProtocolSettings *pProtocolSettings;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else if ( NULL == m_pHNetConnection )
	{
		hr = E_UNEXPECTED;
	}
	else
	{
	    IEnumHNetPortMappingBindings *pHNetEnum;

		hr = m_pHNetConnection->EnumPortMappings( Flags & ICSSC_ENABLED, &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
			CComObject<CSharingManagerEnumPortMapping>* pEnum;

			hr = CComObject<CSharingManagerEnumPortMapping>::CreateInstance(&pEnum);

			if ( SUCCEEDED(hr) )
			{
				pEnum->AddRef();

				hr = pEnum->Initialize( pHNetEnum, Flags );

				if ( SUCCEEDED(hr) )
				{
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPortMapping, &pESPM)
	                        );
				}

				ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
		}
	}

    // create collection:
    if (pESPM) {
        if (hr == S_OK) {
            CComObject<CNetSharingPortMappingCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPortMappingCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pESPM);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPortMappingCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pESPM->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hnapiprp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I P R P . C P P
//
//  Contents:   OEM API
//
//  Notes:      Props (IDispatch wrappers)
//
//  Author:     bhanlon 17 Jan 2001
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
// CNetSharingPortMappingProps
STDMETHODIMP CNetSharingPortMappingProps::get_Name           (BSTR  * pbstrName)
{   // can't validate m_IPM
    HNET_OEM_API_ENTER

    _ASSERT (pbstrName);
    if (!pbstrName)
        return E_POINTER;

    *pbstrName = SysAllocString (m_IPM.pszwName);
    if (!*pbstrName)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_IPProtocol     (UCHAR * pucIPProt)
{
    HNET_OEM_API_ENTER

    _ASSERT (pucIPProt);
    if (!pucIPProt)
        return E_POINTER;

    *pucIPProt = m_IPM.ucIPProtocol;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_ExternalPort   (long * pusPort)
{
    HNET_OEM_API_ENTER

    _ASSERT (pusPort);
    if (!pusPort)
        return E_POINTER;

    *pusPort = m_IPM.usExternalPort;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_InternalPort   (long * pusPort)
{
    HNET_OEM_API_ENTER

    _ASSERT (pusPort);
    if (!pusPort)
        return E_POINTER;

    *pusPort = m_IPM.usInternalPort;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_Options        (long * pdwOptions)
{
    HNET_OEM_API_ENTER

    _ASSERT (pdwOptions);
    if (!pdwOptions)
        return E_POINTER;

    *pdwOptions = m_IPM.dwOptions;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_TargetName     (BSTR  * pbstrTargetName)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbstrTargetName);
    if (!pbstrTargetName)
        return E_POINTER;

    *pbstrTargetName = SysAllocString (m_IPM.pszwTargetName);
    if (!*pbstrTargetName)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_TargetIPAddress(BSTR  * pbstrTargetIPAddress)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbstrTargetIPAddress);
    if (!pbstrTargetIPAddress)
        return E_POINTER;

    *pbstrTargetIPAddress = SysAllocString (m_IPM.pszwTargetIPAddress);
    if (!*pbstrTargetIPAddress)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_Enabled (VARIANT_BOOL * pbool)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbool);
    if (!pbool)
        return E_POINTER;

    *pbool = m_IPM.bEnabled;
    return S_OK;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hnapimgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I M G R. C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <sddl.h>
#include <wchar.h>


HINSTANCE  g_hOemInstance       = NULL;
BOOLEAN    g_fOemNotifyUser     = TRUE;
BOOLEAN    g_fSavedNotifyState  = FALSE;


BOOLEAN IsSecureContext()
/*++

	IsSecureContext

Routine Description:

    This routine checks if the current user belongs to an Administrator Group.

Arguments:

	none

Return Value:

	TRUE  = Current process does belong to an Administrator group
	FALSE = Current process does Not belong to an Administrator group

--*/
{
	PSID						psidAdministrators;

	BOOL                        bIsAdministrator = FALSE;
	SID_IDENTIFIER_AUTHORITY	siaNtAuthority   = SECURITY_NT_AUTHORITY;

	BOOL bResult = AllocateAndInitializeSid( &siaNtAuthority, 2,
						SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
						0, 0, 0, 0, 0, 0, &psidAdministrators );

	_ASSERT( bResult );

	if ( bResult ) 
	{
		bResult = CheckTokenMembership( NULL, psidAdministrators, &bIsAdministrator );
		_ASSERT( bResult );

		FreeSid( psidAdministrators );
	}

	return (BOOLEAN)bIsAdministrator;
}

/*++

	CenterWindow

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

BOOLEAN
CenterDialog( 
	HWND	hwndDlg		// handle to dialog box
	)
{
	RECT rcDlg, rcDesktop;
	HWND hwndDesktop;

    hwndDesktop = GetDesktopWindow();

    if ( GetWindowRect( hwndDlg, &rcDlg ) && GetWindowRect( hwndDesktop, &rcDesktop ) )
	{
		RECT rcCenter;

		// Create a rectangle in the middle of the screen

		rcDesktop.right  -= rcDesktop.left;
		rcDlg.right      -= rcDlg.left;

		rcDesktop.bottom -= rcDesktop.top;
		rcDlg.bottom     -= rcDlg.top;

		if ( rcDesktop.right > rcDlg.right )
		{
		    rcCenter.left  = rcDesktop.left + ((rcDesktop.right - rcDlg.right) / 2);
		    rcCenter.right = rcCenter.left + rcDlg.right;
		}
		else
		{
			rcCenter.left  = rcDesktop.left;
			rcCenter.right = rcDesktop.right;
		}

		if ( rcDesktop.bottom > rcDlg.bottom )
		{
		    rcCenter.top    = rcDesktop.top  + ((rcDesktop.bottom - rcDlg.bottom) / 2);
		    rcCenter.bottom = rcCenter.top  + rcDlg.bottom;
		}
		else
		{
		    rcCenter.top    = rcDesktop.top;
		    rcCenter.bottom = rcDesktop.bottom;
		}

	    return (BOOLEAN)SetWindowPos( hwndDlg, NULL, 
					    			  rcCenter.left, rcCenter.top, 0, 0,
						              SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER );
	}

	return FALSE;
}


INT_PTR CALLBACK OemNotifyDialogProc(
	HWND    hwndDlg,  // handle to dialog box
	UINT    uMsg,     // message
	WPARAM  wParam,   // first message parameter
	LPARAM  lParam    // second message parameter
)
/*++

	OemNotifyDialogProc

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{

    switch ( uMsg ) 
    { 
	case WM_INITDIALOG:
		if ( CenterDialog( hwndDlg ) )
		{
			LPTSTR lpszFmt = new TCHAR[ NOTIFYFORMATBUFFERSIZE ];

			if ( NULL != lpszFmt )
			{
				if ( LoadString( g_hOemInstance, 
								 IDS_SECURITYNOTIFICATIONTEXT,
								 lpszFmt,
								 NOTIFYFORMATBUFFERSIZE ) > 0 )
				{
                    TCHAR lpszCmdLine[MAX_PATH*2+1] = {0};
                    GetModuleFileName (NULL, lpszCmdLine, MAX_PATH*2);

					LPTSTR lpszMsg = new TCHAR[ lstrlen(lpszCmdLine)*2 + 
					                            lstrlen(lpszFmt) + 2 ];

					if ( NULL != lpszMsg )
					{
						wsprintf( lpszMsg, lpszFmt, lpszCmdLine, lpszCmdLine );

						SetDlgItemText( hwndDlg, IDC_TXT_NOTIFICATION, lpszMsg );

						delete lpszMsg;
					}
				}

				delete lpszFmt;
			}
						
		}
		break;

	case WM_COMMAND: 
        switch ( LOWORD(wParam) ) 
        { 
        case IDOK: 
            // Fall through. 

        case IDCANCEL: 

			if ( IsDlgButtonChecked( hwndDlg, IDC_CHK_DISABLESHARESECURITYWARN )
					== BST_CHECKED )
			{
				g_fOemNotifyUser = FALSE;
			}

            EndDialog( hwndDlg, wParam ); 
            return TRUE; 
        } 
		break;
    }

	return FALSE;
}


BOOLEAN IsNotifyApproved()
/*++

	IsNotifyApproved

Routine Description:

	IsSecureContext, g_fOemNotifyUser, g_fSavedNotifyState,	DialogBox determine the 
	value returned.  IsSecureContext MUST be TRUE to return TRUE.  g_fSavedNotifyState
	holds the value returned by DialogBox on the previous call.

Arguments:

	none

Return Value:

	TRUE
	FALSE

--*/
{
	BOOLEAN bApproved = FALSE;

	if ( IsSecureContext() )
	{
		if ( g_fOemNotifyUser )
		{
		    g_fSavedNotifyState = ( DialogBox( g_hOemInstance, 
    								    	   MAKEINTRESOURCE(IDD_SecurityNotification), 
    					        	 		   NULL, 
    					        	 		   OemNotifyDialogProc ) == IDOK ) ?

						TRUE : FALSE;
                        
			g_fOemNotifyUser = FALSE;
		}

		bApproved = g_fSavedNotifyState;
	}

	return bApproved;
}


HRESULT InitializeOemApi( 
	HINSTANCE hInstance 
	)
/*++

	InitializedOemApi 

Routine Description:


Arguments:

	none

Return Value:

	HRESULT

--*/
{
	g_hOemInstance       = hInstance;
	g_fOemNotifyUser     = TRUE;
	g_fSavedNotifyState  = FALSE;
	
	return S_OK;
}


HRESULT ReleaseOemApi()
/*++

	ReleaseOemApi

Routine Description:


Arguments:

	none

Return Value:

	HRESULT

--*/
{
	g_hOemInstance = NULL;

	return S_OK;
}


static HRESULT
_ObtainCfgMgrObj(
	IHNetCfgMgr** ppHNetCfgMgr)
/*++

  _ObtainCfgMgrObj

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
	HRESULT hr = S_OK;

	if ( NULL == ppHNetCfgMgr )
	{
		hr = E_POINTER;
	}
	else 
	{
		hr = CoCreateInstance(
				CLSID_HNetCfgMgr,
				NULL,
				CLSCTX_INPROC_SERVER,
	            IID_PPV_ARG(IHNetCfgMgr, ppHNetCfgMgr)
				);

        _ASSERT(NULL != *ppHNetCfgMgr);
	}

    return hr;
}


/*++

	_ObtainIcsSettingsObj

Routine Description:


Arguments:

	ppIcs -

Return Value:

	HRESULT

--*/
HRESULT 
_ObtainIcsSettingsObj( IHNetIcsSettings** ppIcsSettings )
{
	HRESULT        hr;
	IHNetCfgMgr*   pCfgMgr;

	hr = _ObtainCfgMgrObj( &pCfgMgr );
	
    if ( SUCCEEDED(hr) )
	{
		// Obtain interface pointer to the ICS Settings and enumerator for
		// public connections

		hr = pCfgMgr->QueryInterface( 
				IID_PPV_ARG(IHNetIcsSettings, ppIcsSettings) );

		ReleaseObj( pCfgMgr );
	}

	return hr;
}


HRESULT
CNetSharingConfiguration::Initialize(
	INetConnection *pNetConnection 

	)
/*++

  CNetSharingConfiguration::Initialize

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
	HRESULT        hr;
	IHNetCfgMgr*   pCfgMgr;

	hr = _ObtainCfgMgrObj( &pCfgMgr );

	if ( SUCCEEDED(hr) )
	{
		IHNetConnection* pHNetConnection;	

		hr = pCfgMgr->GetIHNetConnectionForINetConnection( pNetConnection, &pHNetConnection );

		if ( SUCCEEDED(hr) )
		{
			IHNetProtocolSettings* pSettings;

			hr = pCfgMgr->QueryInterface( 
					IID_PPV_ARG(IHNetProtocolSettings, &pSettings) );
			_ASSERT( SUCCEEDED(hr) );

			if ( SUCCEEDED(hr) )
			{
				EnterCriticalSection(&m_csSharingConfiguration);

				ReleaseObj(m_pHNetConnection);
				m_pHNetConnection = pHNetConnection;
				m_pHNetConnection->AddRef();

				ReleaseObj(m_pSettings);
				m_pSettings = pSettings;
				m_pSettings->AddRef();

				LeaveCriticalSection(&m_csSharingConfiguration);

				ReleaseObj(pSettings);
			}

			ReleaseObj(pHNetConnection);
		}

		ReleaseObj(pCfgMgr);
	}
	
	return hr;
}


/*++

  CNetSharingManager::GetSharingInstalled

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

STDMETHODIMP
CNetSharingManager::get_SharingInstalled( 
	VARIANT_BOOL *pbInstalled )
{
    HNET_OEM_API_ENTER

	HRESULT hr = S_OK;

	if ( NULL == pbInstalled )
	{
		hr = E_POINTER;
	}
	else
	{
        BOOLEAN bInstalled = FALSE;

	    SC_HANDLE ScmHandle;
	    SC_HANDLE ServiceHandle;

	    // Connect to the service control manager

	    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	    if ( ScmHandle )
		{
	        // Open the shared access service

	        ServiceHandle = OpenService( ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS );

	        if ( ServiceHandle )
			{
				bInstalled = TRUE;

				CloseServiceHandle(ServiceHandle);
			}

		    CloseServiceHandle(ScmHandle);
		}

		*pbInstalled = bInstalled ? VARIANT_TRUE : VARIANT_FALSE;

	}

	return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingManager::GetINetSharingConfigurationForINetConnection

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_INetSharingConfigurationForINetConnection(
    INetConnection*            pNetConnection,
    INetSharingConfiguration** ppNetSharingConfiguration
    )
{
    HNET_OEM_API_ENTER

	HRESULT hr;

	if ( NULL == ppNetSharingConfiguration )
	{
		hr = E_POINTER;
	}
	else if ( NULL == pNetConnection )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		CComObject<CNetSharingConfiguration>* pNetConfig;

		hr = CComObject<CNetSharingConfiguration>::CreateInstance(&pNetConfig);

		if ( SUCCEEDED(hr) )
		{
			pNetConfig->AddRef();

			hr = pNetConfig->Initialize(pNetConnection);

			if ( SUCCEEDED(hr) )
			{
				hr = pNetConfig->QueryInterface( 
						IID_PPV_ARG( INetSharingConfiguration, ppNetSharingConfiguration ) );
			}

			ReleaseObj(pNetConfig);
		}
	}

	return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hncapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C A P I . C P P
//
//  Contents:   Routines exported from HNetCfg.dll
//
//  Notes:
//
//  Author:     jonburs 20 June 2000
//
//  History:    billi   09 July 2000 - added HNet[Get|Set]ShareAndBridgeSettings
//                                     and supporting static functions
//              billi   14 Sep  2000 - added timeout work around for bridge creation
//                                     and SharePrivate.  This work to be removed
//                                     by Whistler Beta 2 due to DHCP fix.
//              billi   27 Dec  2000 - added HNW logging strings
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <lmcons.h>
#include <lmapibuf.h>
#include <ndispnp.h>
#include <raserror.h>
#include <winsock2.h>
#include <iphlpapi.h>     // ip helper 
#include <netconp.h>

extern "C" {              // make it work in C++
#include <dhcpcsdk.h>     // dhcp client options api
#include "powrprof.h"
}


const DWORD MAX_DISABLE_EVENT_TIMEOUT = 0xFFFF;

#define SECONDS_TO_WAIT_FOR_BRIDGE 20
#define SECONDS_TO_WAIT_FOR_DHCP   20
#define INITIAL_BUFFER_SIZE        256

extern HINSTANCE g_hOemInstance;

typedef struct _HNET_DELETE_RAS_PARAMS
{
    GUID Guid;
    HMODULE hModule;
} HNET_DELETE_RAS_PARAMS, *PHNET_DELETE_RAS_PARAMS;



VOID
HNetFreeFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    )

/*++

Routine Description:

    Frees the memory used by a an HNET_FW_LOGGING_SETTINGS structure. This
    routine should only be used for structures obtained from
    IHNetFirewallSettings::GetFirewallLoggingSettings.


Arguments:

    pSettings - pointer to the structure to free. This pointer should not be
                NULL.

Return Value:

    None.

--*/

{
    if (NULL != pSettings)
    {
        if (NULL != pSettings->pszwPath)
        {
            CoTaskMemFree(pSettings->pszwPath);
        }

        CoTaskMemFree(pSettings);
    }
    else
    {
        _ASSERT(FALSE);
    }
}


DWORD
WINAPI
HNetDeleteRasConnectionWorker(
    VOID *pVoid
    )

/*++

Routine Description:

    Work item to perform the actual cleanup of a deleted
    RAS connection.

Arguments:

    pVoid - HNET_DELETE_RAS_PARAMS

Return Value:

    DWORD
    
--*/

{
    BOOL fComInitialized = FALSE;
    HRESULT hr;
    IHNetCfgMgr *pHNetCfgMgr;
    IHNetConnection *pHNetConnection;
    PHNET_DELETE_RAS_PARAMS pParams;

    _ASSERT(NULL != pVoid);
    pParams = reinterpret_cast<PHNET_DELETE_RAS_PARAMS>(pVoid);

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    //
    // Create the config manager
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_SERVER,
                IID_PPV_ARG(IHNetCfgMgr, &pHNetCfgMgr)
                );
    }

    //
    // Try to obtain the IHNetConnection for the guid
    //

    if (SUCCEEDED(hr))
    {
        hr = pHNetCfgMgr->GetIHNetConnectionForGuid(
                &pParams->Guid,
                FALSE,
                FALSE,
                &pHNetConnection
                );

        if (SUCCEEDED(hr))
        {
            //
            // Ask the connection to delete itself
            //

            hr = pHNetConnection->DeleteRasConnectionEntry();
            pHNetConnection->Release();
        }

        pHNetCfgMgr->Release();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == fComInitialized)
    {
        CoUninitialize();
    }

    //
    // Free the params and exit thread.
    //

    HMODULE hModule = pParams->hModule;
    HeapFree(GetProcessHeap(), 0, pParams);
    FreeLibraryAndExitThread(hModule, ERROR_SUCCESS);

    return ERROR_SUCCESS;
} // HNetDeleteRasConnectionWorker


VOID
WINAPI
HNetDeleteRasConnection(
    GUID *pGuid
    )

/*++

Routine Description:

    Called by rasapi32 when a RAS connection is being deleted. The
    actual work is performed on a separate thread.

Arguments:

    pGuid - the GUID of the connection to delete

Return Value:

    None.
    
--*/

{
    HANDLE hThread;
    PHNET_DELETE_RAS_PARAMS pParams = NULL;

    do
    {
        if (NULL == pGuid)
        {
            break;
        }

        //
        // Setup the work item paramters
        //

        pParams =
            reinterpret_cast<PHNET_DELETE_RAS_PARAMS>(
                HeapAlloc(GetProcessHeap(), 0, sizeof(*pParams))
                );

        if (NULL == pParams)
        {
            break;
        }

        //
        // We need to add a reference to hnetcfg to guarantee that the
        // dll won't be unloaded before the worker finishes execution.
        //

        pParams->hModule = LoadLibraryW(L"hnetcfg");

        if (NULL == pParams->hModule)
        {
            break;
        }

        CopyMemory(&pParams->Guid, pGuid, sizeof(*pGuid));

        //
        // Create the worker thread. (We can't use QueueUserWorkItem
        // due to a possible race condition w/r/t unloading the
        // library and returning from the work item).
        //

        hThread =
            CreateThread(
                NULL,
                0,
                HNetDeleteRasConnectionWorker,
                pParams,
                0,
                NULL
                );

        if (NULL == hThread)
        {
            break;
        }

        CloseHandle(hThread);

        return;
        
    } while (FALSE);


    //
    // Failure path cleanup
    //

    if (NULL != pParams)
    {
        if (NULL != pParams->hModule)
        {
            FreeLibrary(pParams->hModule);
        }

        HeapFree(GetProcessHeap(), 0, pParams);
    }
    
} // HNetDeleteRasConnection



#if DBG

WCHAR tcDbgPrtBuf[ BUF_SIZE + 1 ] = _T("");

void inline rawdebugprintf( wchar_t *buf )
{
    _sntprintf( tcDbgPrtBuf, BUF_SIZE, buf );

    tcDbgPrtBuf[BUF_SIZE] = _T('\0');

    OutputDebugString(tcDbgPrtBuf);

    return;
}


void inline debugprintf( wchar_t *preamble, wchar_t *buf )
{
    OutputDebugString( _T("HNET: ") );

    OutputDebugString( preamble );

    OutputDebugString( buf );

    OutputDebugString( _T("\r\n") );

    return;
}

void inline debugretprintf( wchar_t *msg, HRESULT hResult )
{
    _sntprintf( tcDbgPrtBuf, BUF_SIZE, _T("HNET: %s = %x\r\n"), msg, hResult );

    tcDbgPrtBuf[BUF_SIZE] = _T('\0');

    OutputDebugString( tcDbgPrtBuf );

    return;
}

#define TRACE_ENTER(x)      debugprintf( _T("==> "), _T(x) );

#define TRACE_LEAVE(x,y)    debugretprintf( _T("<== ")_T(x), y );

#else

#define rawdebugprintf(x)
#define debugprintf(x,y)
#define debugretprintf(x,y)
#define TRACE_ENTER(x)
#define TRACE_LEAVE(x,y)

#endif



HRESULT
UpdateHnwLog(
    IN LPHNWCALLBACK lpHnwCallback,
    IN LPARAM        lpContext,
    IN UINT          uID,
    IN LPCWSTR       lpczwValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr = S_OK;

    if ( NULL == lpHnwCallback )
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        LPWSTR lpFormat = new WCHAR[ NOTIFYFORMATBUFFERSIZE ];
        
        if ( NULL != lpFormat )
        {
            if ( LoadString( g_hOemInstance,            // handle to resource module
                             uID,                       // resource identifier
                             lpFormat,                  // resource buffer
                             NOTIFYFORMATBUFFERSIZE-1 ) // size of buffer
                             == 0 )
            {
                hr = HrFromLastWin32Error();
            }
            else
            {
                if ( NULL != lpczwValue )
                {
                    LPWSTR lpBuffer = new WCHAR[ HNWCALLBACKBUFFERSIZE ];
                    
                       if ( NULL != lpBuffer )
                    {
                        _snwprintf( lpBuffer, HNWCALLBACKBUFFERSIZE-1, lpFormat, lpczwValue );
        
                        (*lpHnwCallback)( lpBuffer, lpContext );
                        
                        delete [] lpBuffer;
                    }
                    else
                       {
                        (*lpHnwCallback)( lpFormat, lpContext );
                        
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    (*lpHnwCallback)( lpFormat, lpContext );
                }
            }

            delete [] lpFormat;
         }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  DWORD         dwValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    WCHAR pzwValue[ 32 ];
    
    _snwprintf( pzwValue, 32, L"%lx", dwValue );
    
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, pzwValue );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  int           iValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    WCHAR pzwValue[ 32 ];
    
    _snwprintf( pzwValue, 32, L"%x", iValue );
    
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, pzwValue );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, NULL );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  LPCSTR        lpczValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr     = E_FAIL;
    int     iChars = 0;
    
    iChars = MultiByteToWideChar( CP_THREAD_ACP, 0, lpczValue, -1, NULL, 0 );
    
    if ( 0 != iChars )
    {
        LPWSTR lpWideStr = new WCHAR[ iChars + 1 ];
        
        if ( NULL != lpWideStr )
        {
            if ( !MultiByteToWideChar( CP_THREAD_ACP, 0, lpczValue, -1, lpWideStr, iChars ) )
            {
                hr = UpdateHnwLog( lpHnwCallback, lpContext, uID, lpWideStr );
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }
    
    return hr;
}



HRESULT
CheckNetCfgWriteLock( 
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT   hr;
    INetCfg  *pnetcfg = NULL;

    TRACE_ENTER("CheckNetCfgWriteLock");

    hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_SERVER, IID_PPV_ARG(INetCfg, &pnetcfg ) );

    if ( SUCCEEDED(hr) )
    {
        INetCfgLock *pncfglock = NULL;

        // Get the lock interface
        
        hr = pnetcfg->QueryInterface( IID_PPV_ARG(INetCfgLock, &pncfglock) );

        if ( SUCCEEDED(hr) )
        {
            // Get the NetCfg lock
            
            hr = pncfglock->AcquireWriteLock( 5, L"HNetCfg", NULL );
            
            if ( SUCCEEDED(hr) )
            {
                pncfglock->ReleaseWriteLock();
            }
            else
            {
            }
            
            pncfglock->Release();
        }
        else
        {
        }
        
        pnetcfg->Release();
    }
    else
    {
    }

    TRACE_LEAVE("CheckNetCfgWriteLock", hr);
    
    return hr;
}



HRESULT
ArpForConflictingDhcpAddress(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr      = S_OK;
    WSADATA wsaData;
    int     iWsaErr;

    TRACE_ENTER("ArpForConflictingDhcpAddress");

    iWsaErr = WSAStartup( 0x202, &wsaData );

    if ( 0 != iWsaErr )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_INTERNET, iWsaErr );

        UpdateHnwLog( lpHnwCallback, lpContext, IDS_WSAERRORDURINGDETECTION, iWsaErr );
    }
    else
    {
        // Obtain required ICS server address

        ULONG TargetAddress, TargetMask;
        
        hr = ReadDhcpScopeSettings( &TargetAddress, &TargetMask );

        if ( SUCCEEDED(hr) )
        {
            // Retrieve the best interface for the target IP address,
            // and also perform a UDP-connect to determine the 'closest'
            // local IP address to the target IP address.
            
            ULONG InterfaceIndex;

            if ( GetBestInterface( TargetAddress, &InterfaceIndex ) != NO_ERROR )
            {
                int         Length;
                SOCKADDR_IN SockAddrIn;
                SOCKET      Socket;

                SockAddrIn.sin_family      = AF_INET;
                SockAddrIn.sin_port        = 0;
                SockAddrIn.sin_addr.s_addr = TargetAddress;

                Socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
                
                if ( INVALID_SOCKET != Socket )
                {
                    iWsaErr = connect( Socket, (PSOCKADDR)&SockAddrIn, sizeof(SockAddrIn) );
                    
                    if ( NO_ERROR == iWsaErr )
                    {
                        iWsaErr = getsockname( Socket, ( PSOCKADDR)&SockAddrIn, &Length );
                    }
                }
                else
                {
                    iWsaErr = SOCKET_ERROR;
                }
            
                if ( NO_ERROR != iWsaErr )
                {
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_INTERNET, iWsaErr );

                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_WSAERRORDURINGDETECTION, iWsaErr );
                }
                else
                {
                    // Make sure the target IP address isn't already cached,
                    // by removing it from the ARP cache if present using the interface index
                    // determined above.
                    
                    MIB_IPNETROW IpNetRow;
                    DWORD        dwError;
                    CHAR         HardwareAddress[6];
                    ULONG        HardwareAddressLength;
                    ULONG        SourceAddress;

                    SourceAddress = SockAddrIn.sin_addr.s_addr;
                    
                    ZeroMemory( &IpNetRow, sizeof(IpNetRow) );
                    IpNetRow.dwIndex       = InterfaceIndex;
                    IpNetRow.dwPhysAddrLen = 6;
                    IpNetRow.dwAddr        = TargetAddress;
                    IpNetRow.dwType        = MIB_IPNET_TYPE_INVALID;

                    DeleteIpNetEntry( &IpNetRow );

                    dwError = SendARP( TargetAddress,               // destination IP address
                                       SourceAddress,               // IP address of sender
                                       (PULONG)HardwareAddress,     // returned physical address
                                       &HardwareAddressLength       // length of returned physical addr.
                            );

                    if ( NO_ERROR == dwError )
                    {
                        TargetAddress = inet_addr( HardwareAddress );
                        
                        if ( TargetAddress != SourceAddress )
                        {
                            hr = E_ICSADDRESSCONFLICT;
    
                            UpdateHnwLog( lpHnwCallback, 
                                          lpContext, 
                                          IDS_ICSADDRESSCONFLICTDETECTED, 
                                          HardwareAddress );
                        }
                        else
                        {
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_INTERNET, dwError );
                        
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_SENDARPERRORDURINGDETECTION, dwError );
                    }
                }                
            }
        }
    }

    TRACE_LEAVE("ArpForConflictingDhcpAddress", hr);

    return hr;
}



HRESULT
ObtainIcsErrorConditions(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("ObtainIcsErrorConditions");
    
    hr = ArpForConflictingDhcpAddress( lpHnwCallback, lpContext );
    
    if ( SUCCEEDED(hr) )
    {
        hr = CheckNetCfgWriteLock( lpHnwCallback, lpContext );
        
        if ( SUCCEEDED(hr) )
        {
            // Create Homenet Configuration Manager COM Instance

            IHNetCfgMgr* pCfgMgr;

            hr = CoCreateInstance( CLSID_HNetCfgMgr, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_PPV_ARG(IHNetCfgMgr, &pCfgMgr) );
                                   
            if ( SUCCEEDED(hr) )
            {
                pCfgMgr->Release();
            }
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCONFIGURATIONUNAVAIL );
            }
        }
    }
    
    TRACE_LEAVE("ObtainIcsErrorConditions", hr);

    return hr;
}


HRESULT
HRGetConnectionAdapterName( 
    INetConnection *pNetConnection,
    LPWSTR         *ppzwAdapterName 
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("HRGetConnectionAdapterName");

    if ( NULL == pNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( NULL == ppzwAdapterName )
    {
        hr = E_POINTER;
    }
    else
    {
        NETCON_PROPERTIES* pProps;

        *ppzwAdapterName = NULL;

        hr = pNetConnection->GetProperties(&pProps);

        if ( SUCCEEDED( hr ) )
        {
            *ppzwAdapterName = new WCHAR[ wcslen( pProps->pszwDeviceName ) + 1 ];
            
            if ( NULL != *ppzwAdapterName )
            {
                wcscpy( *ppzwAdapterName, pProps->pszwDeviceName );

                debugprintf( _T("\t"), *ppzwAdapterName );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            NcFreeNetconProperties( pProps );
        }
    }

    TRACE_LEAVE("HRGetConnectionAdapterName", hr);

    return hr;
}



HRESULT
GetIcsPublicConnection( 
    IN  CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    OUT INetConnection     **ppNetPublicConnection,
    OUT BOOLEAN             *pbSharePublicConnection OPTIONAL,
    OUT BOOLEAN             *pbFirewallPublicConnection OPTIONAL
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("GetIcsPublicConnection");

    CComPtr<IHNetIcsSettings> spIHNetIcsSettings;

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPublicConnection );

    if ( NULL == ppNetPublicConnection )
    {
        hr = E_POINTER;
    }
    else if ( spIHNetCfgMgr == NULL )
    {
        hr = E_INVALIDARG;

        *ppNetPublicConnection = NULL;
    }
    else
    {
        // initialize arguments

        *ppNetPublicConnection = NULL;

        if ( NULL != pbSharePublicConnection )
            *pbSharePublicConnection    = FALSE;

        if ( NULL != pbFirewallPublicConnection )
            *pbFirewallPublicConnection = FALSE;

        // Obtain interface pointer
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetIcsSettings, &spIHNetIcsSettings ) );

        if ( SUCCEEDED(hr) )
        {
            hr = S_OK;
        }
    }

    if ( S_OK == hr )
    {
        CComPtr<IEnumHNetIcsPublicConnections> spehiPublic;

        if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &spehiPublic ) ) == S_OK )
        {
            CComPtr<IHNetIcsPublicConnection> spIHNetIcsPublic;

            // obtain only the first IHNetIcsPublicConnetion

            if ( ( hr = spehiPublic->Next( 1, &spIHNetIcsPublic, NULL ) ) == S_OK )
            {
                // obtain pointer to IID_IHNetConnection interface of object
                
                CComPtr<IHNetConnection> spIHNetPublic;

                hr = spIHNetIcsPublic->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPublic ) );
                
                _ASSERT( SUCCEEDED(hr) );
                
                if ( SUCCEEDED(hr) )
                {
                    // The reference count will be decremented by the caller
                    // if necessary.  Notice we are using the caller's pointer
                    // variable.
                
                    hr = spIHNetPublic->GetINetConnection( ppNetPublicConnection );

                    if ( SUCCEEDED(hr) )
                    {
                        HNET_CONN_PROPERTIES *phncProperties;

                        hr = spIHNetPublic->GetProperties( &phncProperties );

                        if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )
                        {
                            if ( NULL != pbSharePublicConnection )
                                *pbSharePublicConnection = phncProperties->fIcsPublic;
                                
                            if ( NULL != pbFirewallPublicConnection )
                                *pbFirewallPublicConnection = phncProperties->fFirewalled;

                            CoTaskMemFree( phncProperties );
                    
                        }   //if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )

                        if ( FAILED(hr) )
                        {
                            (*ppNetPublicConnection)->Release();

                            *ppNetPublicConnection = NULL;
                        }
                    
                    }   // if ( SUCCEEDED(hr) )
                
                }   // if ( SUCCEEDED(hr) )
            
            }   // if ( ( hr = pehiPublic->Next( 1, &sphicPublic, NULL ) ) == S_OK )

        }   // if ( ( hr = pIHNetCfgMgr->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )
    }

    TRACE_LEAVE("GetIcsPublicConnection", hr);

    return hr;
}



HRESULT
GetIcsPrivateConnections( 
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT INetConnection      ***ppNetPrivateConnection
    )

/*++

Routine Description:

    Obtain the private connections enumerator and loop
    through enumeration twice.  Set the required array
    length during the first enumeration.  If the parameter
    array is big enough initialize it during the second
    enumeration.

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;
    ULONG   ulArrayLength, ulListLength, uIndex;
    BOOLEAN bBufferAllocated;

    CComPtr<IHNetIcsSettings>                 spIHNetIcsSettings;
    IHNetIcsPrivateConnection                *pIHNetIcsPrivate;
    IHNetIcsPrivateConnection               **ppIHNetIPList;
    CComPtr<IEnumHNetIcsPrivateConnections>   spehiPrivate;

    TRACE_ENTER("GetIcsPrivateConnections");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPrivateConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == ppNetPrivateConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // initialize local vars

        ulArrayLength    = 0L;
        ulListLength     = 0L;
        bBufferAllocated = FALSE;

        // Obtain interface pointer
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetIcsSettings, &spIHNetIcsSettings ) );

        if ( SUCCEEDED(hr) )
        {
            hr = S_OK;
        }

    }   // else

    if ( S_OK == hr )   
    {
        if ( ( hr = spIHNetIcsSettings->EnumIcsPrivateConnections( &spehiPrivate ) ) == S_OK )
        {
            while ( spehiPrivate->Next( 1, &pIHNetIcsPrivate, NULL ) == S_OK )
            {
                ulArrayLength++;
                pIHNetIcsPrivate->Release();
            }

            // releasing the enumeration interface now so we can re-initialize it later

            spehiPrivate = NULL;
            
        }   // if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )

    }   // if ( S_OK == hr )

    if ( S_OK == hr )   
    {
        if ( ( hr = spIHNetIcsSettings->EnumIcsPrivateConnections( &spehiPrivate ) ) == S_OK )
        {
            hr = spehiPrivate->Next( ulArrayLength, &pIHNetIcsPrivate, &ulListLength );

            if ( S_OK == hr )
            {
                // Allocate array of INetConnection pointers.  There will
                // be on extra pointer element for the NULL pointer at the
                // end of the array.  We allocate this buffer with 
                // NetApiBufferAllocate so the buffer must be released using
                // NetApiBufferFree.

                NET_API_STATUS nErr;
                LPVOID         lpvBuffer;
            
                ++ulArrayLength;

                nErr = NetApiBufferAllocate( ulArrayLength * sizeof(INetConnection *), 
                                         (LPVOID *)ppNetPrivateConnection );

                if ( NERR_Success == nErr )
                {
                    bBufferAllocated = TRUE;

                    for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
                    {
                        (*ppNetPrivateConnection)[uIndex] = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;

                    // must release IHNetIcsPrivateConnection instances

                    ppIHNetIPList = &pIHNetIcsPrivate;

                    for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
                    {
                        ppIHNetIPList[uIndex]->Release();
                    }
                }

            }   // if ( S_OK == hr )

            // done with enumeration interface pointer so we explicitly release it

            spehiPrivate = NULL;
            
        }   // if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )

    }   // if ( S_OK == hr )


    if ( S_OK == hr )
    {
        ppIHNetIPList = &pIHNetIcsPrivate;

        for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
        {
            if ( uIndex < ulArrayLength - 1 )
            {
                CComPtr<IHNetConnection> spIHNetPrivate;

                hr = ppIHNetIPList[uIndex]->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPrivate ) );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    // We allow the caller to invoke Release for (*ppNetPrivateConnection)[uIndex]

                    hr = spIHNetPrivate->GetINetConnection( &((*ppNetPrivateConnection)[uIndex]) );
                    _ASSERT( SUCCEEDED(hr) );
                }
                
            }   // if ( uIndex < uiArrayLength - 1 )

            ppIHNetIPList[uIndex]->Release();

        }   // for ( uIndex = 0L; ...

    }   // if ( S_OK == hr )

    if ( !SUCCEEDED(hr) )
    {
        // If we fail after allocating the buffer then we need release
        // references and buffer

        if ( bBufferAllocated )
        {
            for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
            {
                if ( NULL != (*ppNetPrivateConnection)[uIndex] )
                {
                    (*ppNetPrivateConnection)[uIndex]->Release();
                }
            }

            NetApiBufferFree( *ppNetPrivateConnection );
        }
    }
        
    TRACE_LEAVE("GetIcsPrivateConnections", hr);

    return hr;
}



HRESULT
GetBridge(
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT IHNetBridge          **ppBridge 
    )

/*++

Routine Description:

    Obtain the bridge enumerator and loop through enumeration.

Arguments:


Return Value:

--*/

{
    HRESULT hr = E_INVALIDARG;

    TRACE_ENTER("GetBridge");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppBridge );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == ppBridge )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetBridgeSettings, &spIHNetBridgeSettings ) );

        if ( SUCCEEDED(hr) )
        {
            CComPtr<IEnumHNetBridges> spBridgeEnum;

            hr = spIHNetBridgeSettings->EnumBridges( &spBridgeEnum );

            if ( SUCCEEDED(hr) )
            {
                hr = spBridgeEnum->Next( 1, ppBridge, NULL );
                
                if ( S_FALSE == hr )
                {
                    hr = E_FAIL;
                }

                // We allow the caller to invoke Release for *ppBridge
            }

        }   // if ( SUCCEEDED(hr) )

    }   // else

    TRACE_LEAVE("GetBridge", hr);

    return hr;
}



HRESULT
GetBridgedConnections(
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT INetConnection      ***ppNetPrivateConnection
    )

/*++

Routine Description:

    Obtain the bridge connections enumerator and loop
    through enumeration twice.  Set the required array
    length during the first enumeration.  If the parameter
    array is big enough initialize it during the second
    enumeration.

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;
    ULONG   ulArrayLength, ulListLength, uIndex;

    CComPtr<IHNetBridge>                  spBridge;
    CComPtr<IEnumHNetBridgedConnections>  spEnum;
    IHNetBridgedConnection               *pIHNetBridged;
    IHNetBridgedConnection              **ppIHNetBridgeList;

    TRACE_ENTER("GetBridgedConnections");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPrivateConnection );

    if ( NULL == ppNetPrivateConnection )
    {
        hr = E_POINTER;
    }
    else if ( spIHNetCfgMgr == NULL )
    {
        hr = E_INVALIDARG;

        *ppNetPrivateConnection = NULL;
    }
    else
    {
        // initialize arguments

        *ppNetPrivateConnection = NULL;
        ulArrayLength           = 0L;
        ulListLength            = 0L;

        // Obtain bridge interface pointer
        
        hr = GetBridge( spIHNetCfgMgr, &spBridge );

    }   // else

    if ( S_OK == hr )
    {
        if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )
        {
            while ( spEnum->Next( 1, &pIHNetBridged, NULL ) == S_OK )
            {
                ulArrayLength++;
                pIHNetBridged->Release();
            }

            // releasing the enumeration interface instance so we can re-initialize it later

            spEnum = NULL;
        
        }   // if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )

    }   // if ( S_OK == hr )


    if ( S_OK == hr )   
    {
        if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )
        {
            hr = spEnum->Next( ulArrayLength, &pIHNetBridged, &ulListLength );

            if ( S_OK == hr )
            {
                // Allocate array of INetConnection pointers.  There will
                // be on extra pointer element for the NULL pointer at the
                // end of the array.  We allocate this buffer with 
                // NetApiBufferAllocate so the buffer must be released using
                // NetApiBufferFree.

                NET_API_STATUS nErr;
            
                ++ulArrayLength;
            
                nErr = NetApiBufferAllocate( ulArrayLength*sizeof(INetConnection *), 
                                             (LPVOID *)ppNetPrivateConnection );

                if ( NERR_Success == nErr )
                {
                    for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
                    {
                        (*ppNetPrivateConnection)[uIndex] = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;

                    // must release IHNetIcsPrivateConnection instances
                    
                    ppIHNetBridgeList = &pIHNetBridged;
                    
                    for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
                    {
                        ppIHNetBridgeList[uIndex]->Release();
                    }
                
                }   // else

            }   // if ( S_OK == hr )

            // releasing enumeration interface instance

            spEnum = NULL;

        }   // if ( ( hr = pBridge->EnumMembers( &spEnum ) ) == S_OK )

    }   // if ( S_OK == hr )    

    if ( S_OK == hr )
    {
        ppIHNetBridgeList = &pIHNetBridged;

        for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
        {
            if ( uIndex < ulArrayLength - 1 )
            {
                CComPtr<IHNetConnection> spIHNetPrivate;

                hr = ppIHNetBridgeList[uIndex]->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPrivate ) );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    // We allow the caller to invoke Release for (*ppNetPrivateConnection)[uIndex]

                    hr = spIHNetPrivate->GetINetConnection( &((*ppNetPrivateConnection)[uIndex]) );
                    _ASSERT( SUCCEEDED(hr) );
                }
                
            }   // if ( uIndex < uiArrayLength - 1 )

            ppIHNetBridgeList[uIndex]->Release();

        }   // for ( uIndex = 0L; ...

    }   // if ( S_OK == hr )
            
    TRACE_LEAVE("GetBridgedConnections", hr);

    return hr;
}



HRESULT
SetIcsPublicConnection(
    IN CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN INetConnection      *pNetPublicConnection,
    IN BOOLEAN              bSharePublicConnection,
    IN BOOLEAN              bFirewallPublicConnection,
    IN  LPHNWCALLBACK       lpHnwCallback,
    IN  LPARAM              lpContext
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("SetIcsPublicConnection");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != pNetPublicConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == pNetPublicConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        INetConnectionRefresh* pNetConnectionRefresh;

        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        if( SUCCEEDED(hr) )
        {
            _ASSERT( pNetConnectionRefresh );

            pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

            OLECHAR *strAdapter = L"Adapter";
            OLECHAR *strName    = strAdapter;

            CComPtr<IHNetConnection> spHNetConnection;

            hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPublicConnection, 
                                                &spHNetConnection );
            if ( S_OK == hr )
            {
                if ( HRGetConnectionAdapterName( pNetPublicConnection, &strName ) != S_OK )
                {
                    strName = strAdapter;
                }

                if ( bSharePublicConnection )
                {
                    CComPtr<IHNetIcsPublicConnection> spIcsPublicConn;

                    hr = spHNetConnection->SharePublic( &spIcsPublicConn );

                    if ( SUCCEEDED(hr) )
                    {
                        // Instantiating the IHNetIcsPublicConnection pointer with
                        // SharePublic results in updating our WMI store with 
                        // the new sharing properties for this connection.  This
                        // is our only goal at this time.

                        //
                        // set the power scheme!
                        //

                        if (!SetActivePwrScheme(3, NULL, NULL)) {
                            debugprintf( _T("Unable to set power scheme to always on\n"), strName);
                        }

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPUBLICCONNECTIONCREATED, strName );

                        spIcsPublicConn.Release();

                        debugprintf( _T("\t"), strName );
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPUBLICCONNECTIONFAILED, strName );
                    }
                    
                }   //  if ( bSharePublicConnection )

                if ( SUCCEEDED(hr) && bFirewallPublicConnection )
                {
                    CComPtr<IHNetFirewalledConnection> spFirewalledConn;

                    hr = spHNetConnection->Firewall( &spFirewalledConn );

                    if ( SUCCEEDED(hr) )
                    {
                        // Instantiating the IHNetFirewalledConnection pointer with
                        // SharePublic results in updating our WMI store with 
                        // the new firewall properties for this connection.  This
                        // is our only goal at this time.

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_FIREWALLCONNECTION, strName );

                        spFirewalledConn.Release();
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_FIREWALLCONNECTIONFAILED, strName );
                    }
                    
                }   //  if ( SUCCEEDED(hr) && bFirewallPublicConnection )

            }   // if ( S_OK == hr )
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCFGFORADAPTERUNAVAIL, strName );
            }

            if ( strName != strAdapter )
            {
                delete strName;
            }

            pNetConnectionRefresh->DisableEvents( FALSE, 0L );
            pNetConnectionRefresh->Release();

        }    //    if( SUCCEEDED(hr) )

    }   // else

    TRACE_LEAVE("SetIcsPublicConnection", hr);

    return hr;
}



HRESULT WaitForConnectionToInitialize( 
    IN CComPtr<IHNetConnection> spIHNC,
    IN ULONG                    ulSeconds,
    IN BOOLEAN                  bIsBridge
    )
{
    HRESULT         hr;
    GUID           *pGuid;
    UNICODE_STRING  UnicodeString;

    TRACE_ENTER("WaitForConnectionToInitialize");

    ZeroMemory( &UnicodeString, sizeof(UnicodeString) );

    hr = spIHNC->GetGuid( &pGuid );
    
    if ( SUCCEEDED(hr) )
    {
        NTSTATUS Status = RtlStringFromGUID( *pGuid, &UnicodeString );
        
        hr = ( STATUS_SUCCESS == Status ) ? S_OK : E_FAIL;
        
        CoTaskMemFree( pGuid );
    }

    pGuid = NULL;

#ifdef WAIT_FOR_MEDIA_STATUS_CONNECTED

    if ( SUCCEEDED(hr) && bIsBridge )
    {
        // Query the state of the connection.  Try to wait for the 
        // bridge to build the spanning tree and report media state connected.

        LPWSTR  pwsz;

        // Build a buffer large enough for the device string

        pwsz = new WCHAR[ sizeof(c_wszDevice)/sizeof(WCHAR) + UnicodeString.Length/sizeof(WCHAR) + 1 ];

        if ( NULL != pwsz )
        {
            UNICODE_STRING  DeviceString;
            NIC_STATISTICS  NdisStatistics;
            ULONG           ulTimeout;

            swprintf( pwsz, L"%s%s", c_wszDevice, UnicodeString.Buffer );

            ulTimeout = SECONDS_TO_WAIT_FOR_BRIDGE;
            RtlInitUnicodeString( &DeviceString, pwsz );

            do
            {
                ZeroMemory( &NdisStatistics, sizeof(NdisStatistics) );
                NdisStatistics.Size = sizeof(NdisStatistics);
                NdisQueryStatistics( &DeviceString, &NdisStatistics );
        
                if ( NdisStatistics.MediaState == MEDIA_STATE_UNKNOWN )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_HOST_ADDRESS_CONFLICT);
                } 
                else if ( NdisStatistics.DeviceState != DEVICE_STATE_CONNECTED ||
                          NdisStatistics.MediaState != MEDIA_STATE_CONNECTED )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN);
                }
                else
                {
                    // AHA! Bridge initialized!

                    hr = S_OK;
                    break;
                }

                debugretprintf( pwsz, hr );

                Sleep( 1000 );
            }
            while ( ulTimeout-- );

            delete [] pwsz;
    
        }   //  if ( NULL != pwsz )

    }   //  if ( SUCCEEDED(hr) && bIsBridge )

#endif

    
    if ( SUCCEEDED(hr) )
    {
        DWORD  dwResult;
        DWORD  dwVersion;                           // version of the DHCP Client Options API reported

        hr       = HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN);
        dwResult = DhcpCApiInitialize( &dwVersion );

        if ( ERROR_SUCCESS == dwResult )
        {
            DHCPCAPI_PARAMS       requests[1]  = { {0, OPTION_SUBNET_MASK, FALSE, NULL, 0} };   // subnet mask
            DHCPCAPI_PARAMS_ARRAY sendarray    = { 0, NULL };           // we aren't sending anything
            DHCPCAPI_PARAMS_ARRAY requestarray = { 1, requests };       // we are requesting 2 items

            while ( --ulSeconds )
            {
                DWORD   dwSize = INITIAL_BUFFER_SIZE;                       // size of buffer for options
                LPBYTE  buffer = NULL;                                      // buffer for options  
                IN_ADDR addr;                                               // address in return code

                do
                {
                    if ( NULL != buffer )
                    {
                        LocalFree( buffer );
                    }

                    buffer = (LPBYTE) LocalAlloc( LPTR, dwSize );               // allocate the buffer

                    if ( NULL == buffer )
                    {
                        break;
                    }

                    // make the request on the adapter

                    dwResult = DhcpRequestParams( DHCPCAPI_REQUEST_SYNCHRONOUS, 
                                                  NULL, 
                                                  UnicodeString.Buffer,
                                                  NULL, 
                                                  sendarray, 
                                                  requestarray, 
                                                  buffer, 
                                                  &dwSize, 
                                                  NULL );
                }
                while ( ERROR_MORE_DATA == dwResult );

                if ( NULL != buffer )
                {
                    LocalFree( buffer );
                }

                if ( ERROR_SUCCESS == dwResult )
                {
                    hr = S_OK;
                    break;
                }

                // wait for dhcp to pick up connection

                debugretprintf( UnicodeString.Buffer, hr );

                Sleep( 1000 );

            }   //  while ( --ulSeconds )

            DhcpCApiCleanup();

        }   //  if ( 0 == dwResult )

    }   //  if ( SUCCEEDED(hr) )
    
   	RtlFreeUnicodeString( &UnicodeString );

    TRACE_LEAVE("WaitForConnectionToInitialize", hr);

    return hr;
}



HRESULT
SetIcsPrivateConnections(
    IN  CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN  INetConnection      *pNetPrivateConnection[],
    IN  BOOLEAN              bSharePublicConnection,
    IN  LPHNWCALLBACK        lpHnwCallback,
    IN  LPARAM               lpContext,
    OUT INetConnection     **pNetPrivateInterface
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("SetIcsPrivateConnections");

    CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;
    INetConnectionRefresh*       pNetConnectionRefresh = NULL;

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != pNetPrivateConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == pNetPrivateConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetBridgeSettings, &spIHNetBridgeSettings ) );
    }
    
    if ( SUCCEEDED(hr) )
    {
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        
        if( SUCCEEDED(hr) )
        {
            _ASSERT( pNetConnectionRefresh );
            pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );
        }
        else
        {
            pNetConnectionRefresh = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        CComPtr<IHNetConnection> spIHNC;
        INetConnection         **ppNC;
        ULONG                    uIndex;
        BOOLEAN                  bIsBridge;
        INetCfg                 *pnetcfg = NULL;
        INetCfgLock             *pncfglock = NULL;

        ppNC      = pNetPrivateConnection;
        bIsBridge = FALSE;

        for ( uIndex=0L; NULL != *ppNC; ppNC++ )
        {
            _ASSERT( !IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) );

            if ( IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) )
            {
                hr = E_POINTER;
                break;
            }
            else
            {
#if DBG
                LPWSTR  lpzwAdapterName;
                HRESULT hrGetName;
                
                hrGetName = HRGetConnectionAdapterName( *ppNC, &lpzwAdapterName );

                if ( SUCCEEDED( hrGetName ) )
                {
                    debugprintf( _T("\t"), lpzwAdapterName );

                    delete lpzwAdapterName;
                }
#endif
                // We only count this as a valid connection for valid pointers

                uIndex++;
            }

        }   //  if ( SUCCEEDED(hr) )


        if ( SUCCEEDED(hr) )
        {
            HRESULT hrWrite;
        
            hrWrite = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );
        
            if ( 1 < uIndex )
            {
                CComPtr<IHNetBridge> spHNetBridge;

                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetBridgeSettings->CreateBridge( &spHNetBridge, pnetcfg );

                if ( S_OK == hr )
                {
                    ULONG uCount;
                    
                    ppNC = pNetPrivateConnection;
                    
                    for ( uCount=0L; (NULL != *ppNC) && (uCount < uIndex); uCount++, ppNC++ )
                    {
                        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                        hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( *ppNC, &spIHNC );

                        if ( SUCCEEDED(hr) )
                        {
                            CComPtr<IHNetBridgedConnection> spBridgedConn;

                            hr = spHNetBridge->AddMember( spIHNC, &spBridgedConn, pnetcfg );

                            if ( S_OK == hr )
                            {
                                // Instantiating the IHNetBridgeConnection pointer with
                                // SharePublic results in updating our WMI store with 
                                // the new bridge properties for this connection.  This
                                // is our only goal at this time.

                                spBridgedConn.Release();
                            }
                            else
                            {
                                debugretprintf( _T("AddMember FAILED with "), hr );
                            }

                            // We no longer need this IHNetConnection reference
                            // so we NULL the smart pointer to release it.
                            
                            spIHNC = NULL;
                        }

                    }   // for ( uCount=0L; ...

                    hr = spHNetBridge->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNC ) );
                    _ASSERT( SUCCEEDED(hr) );

                    if ( SUCCEEDED(hr) )
                    {
                        bIsBridge = TRUE;

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWBRIDGECREATED );
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWBRIDGEFAILED );
                    }
                
                }   // if ( SUCCEEDED(hr) )
            
            }   // if ( 1 < uIndex )

            else if ( 1 == uIndex )
            {
                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPrivateConnection[0], &spIHNC );
                _ASSERT( SUCCEEDED(hr) );
            }
            else
            {
                // We don't have ANY private connections so we null out
                // this pointer to make sure we don't try to use it.

                spIHNC = NULL;
            }

            if ( SUCCEEDED(hrWrite) )
            {
                UninitializeNetCfgForWrite( pnetcfg, pncfglock );
            }
            
        }   //  if ( SUCCEEDED(hr) )
        else
        {
            // Some previous error condition occurred and we need to 
            // null out this pointer to make sure we don't try to use it.

            spIHNC = NULL;
        }


        if ( bSharePublicConnection && SUCCEEDED(hr) && ( spIHNC != NULL ) )
        {
            OLECHAR *strAdapter = _T("Adapter");
            OLECHAR *strName    = strAdapter;

            CComPtr<IHNetIcsPrivateConnection> spIcsPrivateConn;

            // Get name of private connection candidate

            if ( spIHNC != NULL )
            {
                if ( S_OK != spIHNC->GetName( &strName )  )
                {
                    strName = strAdapter;
                }
            }

            // Wait for connection to finish initialization and share it
                
            if ( SUCCEEDED(hr) )
            {
                // if we are in ICS Upgrade, don't wait for dhcp
                // service because it won't be running during GUI Mode Setup.
                
                HANDLE hIcsUpgradeEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName );
                
                if ( NULL != hIcsUpgradeEvent )
                {
                    CloseHandle( hIcsUpgradeEvent );
                }
                else
                {
                    // We are running normally with dhcp so we must wait
                    // for dhcp to pick up the new bridge interface
                
                    pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                    hr = WaitForConnectionToInitialize( spIHNC, SECONDS_TO_WAIT_FOR_DHCP, bIsBridge );
                    
                    if ( HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN) == hr )
                    {
                    	// If WaitForConnectionToInitialize can't get statistics then try
                        // SharePrivate anyway.
                    
                    	hr = S_OK;
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                    hr = spIHNC->SharePrivate( &spIcsPrivateConn );
                }
            }

            if ( SUCCEEDED(hr) )
            {
                // We are only configuring the connection

                // Instantiating the IHNetIcsPrivateConnection pointer with
                // SharePublic results in updating our WMI store with 
                // the new private connection properties for this connection.  
                
                // Obtain Interface pointer to private connection if requested

                if ( NULL != pNetPrivateInterface )
                {
                    spIHNC->GetINetConnection( pNetPrivateInterface );
                }

                UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPRIVATECONNECTIONCREATED, strName );

                spIcsPrivateConn.Release();

                debugprintf( _T("SharePrivate: "), strName );
            }
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPRIVATECONNECTIONFAILED, strName );

                debugretprintf( _T("SharePrivate FAILED with "), hr );
            }

            if ( strName != strAdapter )
            {
                CoTaskMemFree( strName );
            }

        }   // if ( SUCCEEDED(hr) && ( spIHNC != NULL ) )

        // We no longer need this IHNetConnection reference so we NULL the smart
        // pointer to release it.  If the smart pointer is all ready NULL then
        // no release or AV will occur.  We do this here because the smart pointer 
        // may be valid even though we did not enter the preceeding block.

        spIHNC = NULL;

    }   // if ( SUCCEEDED(hr) )


    if ( pNetConnectionRefresh )
    {
        pNetConnectionRefresh->DisableEvents( FALSE, 0L );
        pNetConnectionRefresh->Release();
    }

    TRACE_LEAVE("SetIcsPrivateConnections", hr);

    return hr;
}



HRESULT
DisableEverything(
    IN CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN  INetConnection     *pNetPublicConnection,
    IN  INetConnection     *pNetPrivateConnection[],
    IN  LPHNWCALLBACK       lpHnwCallback,
    IN  LPARAM              lpContext
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT                hr;
    INetConnectionRefresh* pNetConnectionRefresh;

    TRACE_ENTER("DisableEverything");

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
    
    if( SUCCEEDED(hr) )
    {
        ULONG ulConnections;

        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

        if ( pNetPublicConnection )
        {
            IHNetConnection* pHNetPublicConnection;

            hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPublicConnection, 
            &pHNetPublicConnection );
            if ( S_OK == hr )
            {
                IHNetFirewalledConnection* pPublicConnectionFirewall;

                hr = pHNetPublicConnection->GetControlInterface( IID_IHNetFirewalledConnection,
                                                                 (void**)&pPublicConnectionFirewall );
                if ( SUCCEEDED(hr) )
                {
                    hr = pPublicConnectionFirewall->Unfirewall();
                    pPublicConnectionFirewall->Release();
                    pPublicConnectionFirewall = NULL;

                    if ( FAILED(hr) ) 
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEFIREWALLFAIL, hr );
                    }
                }

                pHNetPublicConnection->Release();
                pHNetPublicConnection = NULL;
            }
        }

        if ( pNetPrivateConnection && pNetPrivateConnection[0] )
        {
            INetConnection** ppNC = pNetPrivateConnection;
            
            while ( *ppNC )
            {
                IHNetConnection* pHNetPrivateConnection;

                _ASSERT( !IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) );

                if ( IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) )
                {
                    hr = E_POINTER;
                    break;
                }

                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( *ppNC, 
                                                                         &pHNetPrivateConnection );
                if ( S_OK == hr )
                {
                    IHNetFirewalledConnection* pPrivateConnectionFirewall;
                
                    hr = pHNetPrivateConnection->GetControlInterface( IID_IHNetFirewalledConnection,
                                                                     (void**)&pPrivateConnectionFirewall );
                    if ( SUCCEEDED(hr) )
                    {
                        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                        hr = pPrivateConnectionFirewall->Unfirewall();
                        pPrivateConnectionFirewall->Release();
                        pPrivateConnectionFirewall = NULL;

                        if ( FAILED(hr) ) 
                        {
                            UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEFIREWALLFAIL, hr );
                        }
                    }
                
                    pHNetPrivateConnection->Release();
                    pHNetPrivateConnection = NULL;
                    
                }    //    if ( S_OK == hr )
            
                ppNC++;
                
            }    // while ( ppNC )
            
        }    //    if ( pNetPrivateConnection && pNetPrivateConnection[0] )

        {
            CComQIPtr<IHNetBridgeSettings> spIHNetBridge = spIHNetCfgMgr;

            if ( spIHNetBridge != NULL )
            {
                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetBridge->DestroyAllBridges( &ulConnections );

                if ( FAILED(hr) ) 
                {
                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_DESTROYBRIDGEFAIL, hr );
                }
            }
        }

        {
            CComQIPtr<IHNetIcsSettings> spIHNetIcs = spIHNetCfgMgr;

            if ( spIHNetIcs != NULL )
            {
                ULONG ulPrivateConnections;

                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetIcs->DisableIcs( &ulConnections, &ulPrivateConnections );

                if ( FAILED(hr) ) 
                {
                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEICS, hr );
                }
            }
        }

        pNetConnectionRefresh->DisableEvents( FALSE, 0L );
        pNetConnectionRefresh->Release();
    }

    TRACE_LEAVE("DisableEverything", hr);

    return hr;
}



extern
HRESULT APIENTRY
HNetSetShareAndBridgeSettings(
    IN  INetConnection          *pNetPublicConnection,
    IN  INetConnection          *pNetPrivateConnection[],
    IN  BOOLEAN                  bSharePublicConnection,
    IN  BOOLEAN                  bFirewallPublicConnection,
    IN  LPHNWCALLBACK            lpHnwCallback,
    IN  LPARAM                   lpContext,
    OUT INetConnection         **pNetPrivateInterface
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    TRACE_ENTER("HNetSetShareAndBridgeSettings");

    HRESULT hr;

    // Initialize returned interface pointer if necessary

    if ( NULL != pNetPrivateInterface )
    {
        *pNetPrivateInterface = NULL;
    }

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.

    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    hr = spIHNetCfgMgr.CoCreateInstance( CLSID_HNetCfgMgr );

    if ( SUCCEEDED(hr) )
    {
        DisableEverything( spIHNetCfgMgr, 
                           pNetPublicConnection, 
                           pNetPrivateConnection, 
                           lpHnwCallback, 
                           lpContext );

        if ( NULL != pNetPublicConnection )
        {
            hr = SetIcsPublicConnection( spIHNetCfgMgr, 
                                         pNetPublicConnection, 
                                         bSharePublicConnection, 
                                         bFirewallPublicConnection,
                                         lpHnwCallback,
                                         lpContext );
        }

        if ( ( NULL != pNetPrivateConnection ) && ( NULL != pNetPrivateConnection[0] ) && SUCCEEDED(hr) )
        {
            hr = SetIcsPrivateConnections( spIHNetCfgMgr, 
                                           pNetPrivateConnection, 
                                           bSharePublicConnection,
                                           lpHnwCallback,
                                           lpContext,
                                           pNetPrivateInterface );
        }

        if ( FAILED(hr) )
        {
            DisableEverything( spIHNetCfgMgr, 
                               pNetPublicConnection, 
                               pNetPrivateConnection, 
                               lpHnwCallback, 
                               lpContext );
        }
    }
    else
    {
        UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCONFIGURATIONUNAVAIL );
    }

    TRACE_LEAVE("HNetSetShareAndBridgeSettings", hr);

    return hr;
}



extern
HRESULT APIENTRY
HNetGetShareAndBridgeSettings(
    OUT INetConnection  **ppNetPublicConnection,
    OUT INetConnection ***ppNetPrivateConnection,
    OUT BOOLEAN          *pbSharePublicConnection,
    OUT BOOLEAN          *pbFirewallPublicConnection
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("HNetGetShareAndBridgeSettings");

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.

    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    *ppNetPublicConnection      = NULL;
    *ppNetPrivateConnection     = NULL;
    *pbSharePublicConnection    = FALSE;
    *pbFirewallPublicConnection = FALSE;

    hr = spIHNetCfgMgr.CoCreateInstance( CLSID_HNetCfgMgr );

    if ( SUCCEEDED(hr) )
    {
        if ( NULL != ppNetPublicConnection )
        {
            hr = GetIcsPublicConnection( spIHNetCfgMgr,
                                         ppNetPublicConnection,
                                         pbSharePublicConnection,
                                         pbFirewallPublicConnection );
        }

        if ( NULL != ppNetPrivateConnection )
        {
            hr = GetIcsPrivateConnections( spIHNetCfgMgr, ppNetPrivateConnection );

            if ( S_OK == hr )
            {
                CComPtr<IHNetConnection>   spIHNetConnection;
                INetConnection           **ppINetCon;

                // Check first private connection to see if it is the bridge
                
                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( (*ppNetPrivateConnection)[0], 
                                                                         &spIHNetConnection );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    HNET_CONN_PROPERTIES *phncProperties;

                    hr = spIHNetConnection->GetProperties( &phncProperties );

                    if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )
                    {
                        if ( phncProperties->fBridge )
                        {
                            // If Bridge, then release the private connection instances
                            // and get the list of bridged connections

                            for ( ppINetCon = *ppNetPrivateConnection; NULL != *ppINetCon; ppINetCon++ )
                            {
                                (*ppINetCon)->Release();
                                *ppINetCon = NULL;
                            }

                            NetApiBufferFree( *ppNetPrivateConnection );

                            *ppNetPrivateConnection = NULL;

                            hr = GetBridgedConnections( spIHNetCfgMgr, ppNetPrivateConnection );

                        }   // if ( phncProperties->fBridge )

                        CoTaskMemFree( phncProperties );

                    }   // if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )

                }   // if ( SUCCEEDED(hr)

                // What if we fail along this path?  Then we need to release
                // any private connection interface pointer held.

                if ( FAILED(hr) && ( NULL != ppNetPrivateConnection ) )
                {
                    for ( ppINetCon = *ppNetPrivateConnection; NULL != *ppINetCon; ppINetCon++ )
                    {
                        (*ppINetCon)->Release();
                    }

                    NetApiBufferFree( *ppNetPrivateConnection );

                    *ppNetPrivateConnection = NULL;
                }

            }   // if ( S_OK == hr )
        
        }   // if ( NULL != ppNetPrivateConnection )

        // If we fail along the way then we need to release the public interface
        // and NULL the pointer so that it won't be used.

        if ( FAILED(hr) && ( NULL != ppNetPublicConnection ) )
        {
            (*ppNetPublicConnection)->Release();

            *ppNetPublicConnection = NULL;
        }

    }   // if ( SUCCEEDED(hr) )
    
    TRACE_LEAVE("HNetGetShareAndBridgeSettings", hr);

    return hr;
}


HRESULT DisablePersonalFirewallOnAll()
/*++

Routine Description:

    Disable firewall on all connections

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr = S_OK;
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;
    
    TRACE_ENTER("DisablePersonalFirewallOnAll");
    
    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_PPV_ARG(IHNetCfgMgr, &spIHNetCfgMgr));

    if (SUCCEEDED(hr))
    {
        CComQIPtr<IHNetFirewallSettings> spIHNetFirewall = spIHNetCfgMgr;
        
        if ( NULL != spIHNetFirewall.p )
        {
            ULONG   ulConnections = 0;
            hr = spIHNetFirewall->DisableAllFirewalling( &ulConnections );
        }
        else
        {
            hr = E_FAIL;
        }
    }
    

    TRACE_LEAVE("DisablePersonalFirewallOnAll", hr);
    
    return hr;
        
}

HRESULT EnablePersonalFirewallOnAll()
/*++

Routine Description:
    Enable firewall on all connections that can be firewalled


Arguments:


Return Value:

    hResult

--*/

{
    HRESULT         hr      = S_OK;
    HRESULT         hrTemp  = S_OK;
    ULONG           ulCount = 0;

    CComPtr<IEnumNetConnection> spEnum; 
    
    // Get the net connection manager
    CComPtr<INetConnectionManager> spConnMan;
    CComPtr<INetConnection> spConn;

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    TRACE_ENTER("EnablePersonalFirewallOnAll");

    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_PPV_ARG(IHNetCfgMgr, &spIHNetCfgMgr));
    
    if (FAILED(hr))
    {
        goto End;
    }
    
    //disable any previous firewall settings otherwise enabling
    //firewall on the same connection twice will return errors
    //We will continue do the enable firewall if this step fails    
    DisablePersonalFirewallOnAll();

    hr = CoCreateInstance(CLSID_ConnectionManager, 
                        NULL,
                        CLSCTX_ALL,
                        IID_PPV_ARG(INetConnectionManager, &spConnMan));

    if (FAILED(hr))
    {
        goto End;
    }

    
    // Get the enumeration of connections
    SetProxyBlanket(spConnMan);
    
    hr = spConnMan->EnumConnections(NCME_DEFAULT, &spEnum);
    if (FAILED(hr))
    {
        goto End;
    }

    SetProxyBlanket(spEnum);
    
    
    hr = spEnum->Reset();
    if (FAILED(hr))
    {
        goto End;
    } 
    
    do
    {
        NETCON_PROPERTIES* pProps = NULL;
        
        //release any previous ref count we hold
        spConn = NULL;

        hr = spEnum->Next(1, &spConn, &ulCount);
        if (FAILED(hr) || 1 != ulCount)
        {
            break;
        }

        SetProxyBlanket(spConn);
        
        hr = spConn->GetProperties(&pProps);
        if (FAILED(hr) || NULL == pProps)
        {
            continue;
        }

        //ICF is available only for certain types of connections
        if (NCM_PHONE == pProps->MediaType ||
            NCM_ISDN == pProps->MediaType  ||
            NCM_PPPOE == pProps->MediaType ||
            NCM_LAN == pProps->MediaType ||
            NCM_TUNNEL == pProps->MediaType )
        {
            CComPtr<IHNetConnection> spHNetConnection;
            //release the ref count if we are holding one
            spHNetConnection = NULL;
            hrTemp = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
                spConn, 
                &spHNetConnection );
            
            if (SUCCEEDED(hr))
            {
                hr = hrTemp;
            }
    
            if (SUCCEEDED(hrTemp))
            {
                //check whether the connect can be firewalled
                HNET_CONN_PROPERTIES *phncProperties = NULL;
                
                hrTemp = spHNetConnection->GetProperties( &phncProperties );
                if (SUCCEEDED(hrTemp) && NULL != phncProperties)
                {
                    if (phncProperties->fCanBeFirewalled)
                    {
                        CComPtr<IHNetFirewalledConnection> spFirewalledConn;
                        
                        //turn on the firewall
                        hrTemp = spHNetConnection->Firewall( &spFirewalledConn );
                    }
                    CoTaskMemFree(phncProperties);
                }

                if (SUCCEEDED(hr))
                {
                    hr = hrTemp;
                }
            }
        }   
        NcFreeNetconProperties(pProps);
        
    } while (SUCCEEDED(hr) && 1 == ulCount);

End:
    TRACE_LEAVE("EnablePersonalFirewallOnAll", hr);
    
    //normalize hr because we used IEnum
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }
    return hr;
}

extern "C"
BOOL 
WINAPI
WinBomConfigureHomeNet(
                LPCTSTR lpszUnattend, 
                LPCTSTR lpszSection
                )
/*++

Routine Description:
        Reads home networking settings from the specified unattend file and saves 
        those in current system that is already setup and running.



Arguments:
        lpszUnattend [IN] Points to a string buffer which contains the full path 
                          to the unattend file (winbom.ini in this case) with all 
                          the home network settings.
        
        lpszSection  [IN] Points to a string buffer which contains the name of 
                          the section which contains all the home network settings 
                          in the unattend file specified above.


Return Value:
        Returns TRUE if the settings were successfully read and saved to the system.  
        Otherwise returns FALSE to indicate something failed.

--*/

{
    if (NULL == lpszSection || NULL == lpszUnattend)
        return FALSE;

    BOOL fRet = TRUE;
    WCHAR szBuf[256] = {0};
    DWORD dwRet = 0;
    dwRet = GetPrivateProfileString(lpszSection,
                        c_szEnableFirewall,
                        _T(""),
                        szBuf,
                        sizeof(szBuf)/sizeof(szBuf[0]),
                        lpszUnattend);

    if (dwRet) 
    {
        if (0 == lstrcmpi(szBuf, c_szYes))
        {
            fRet = SUCCEEDED(EnablePersonalFirewallOnAll());
        }
        else if (0 == lstrcmpi(szBuf, c_szNo))
        {
            fRet = SUCCEEDED(DisablePersonalFirewallOnAll());
        }
    }
    else
    {
        //if there is no EnableFirewall there, we should treat this
        //as a success
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hnapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I . C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <winsock2.h>

void __cdecl hnet_oem_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp )
{
   throw HNet_Oem_SEH_Exception( uSECode );
}
void EnableOEMExceptionHandling()
{
   _set_se_translator (hnet_oem_trans_func);
}
void DisableOEMExceptionHandling()
{
   _set_se_translator(NULL);
}

HRESULT
InternalGetSharingEnabled( 
    IHNetConnection*       pHNetConnection,
    BOOLEAN*               pbEnabled,
    SHARINGCONNECTIONTYPE* pType
    )
/*++

  InternalGetSharingEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if ( NULL == pHNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( ( NULL == pbEnabled ) || ( NULL == pType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        hr = pHNetConnection->GetProperties( &pProps );

        if ( SUCCEEDED(hr) )
        {
            if ( pProps->fIcsPublic )
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PUBLIC;
            }
            else if ( pProps->fIcsPrivate )
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PRIVATE;
            }

            CoTaskMemFree( pProps );
        }
    }

    return hr;
}


HRESULT
InternalIsShareTypeEnabled( 
    SHARINGCONNECTIONTYPE Type,
    BOOLEAN*              pbEnabled
    )
/*++

  InternalGetShareTypeEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT hr;

    if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else 
    {
        IHNetIcsSettings* pIcsSettings;

        *pbEnabled = FALSE;

        hr = _ObtainIcsSettingsObj( &pIcsSettings );
        
        if ( SUCCEEDED(hr) )
        {
            switch( Type )
            {
            case  ICSSHARINGTYPE_PUBLIC:
                {
                    IEnumHNetIcsPublicConnections* pHNetEnumPub;

                       hr = pIcsSettings->EnumIcsPublicConnections( &pHNetEnumPub );

                    if ( SUCCEEDED(hr) )
                    {
                        IHNetIcsPublicConnection *pIHNetIcsPublic;

                        if ( pHNetEnumPub->Next( 1, &pIHNetIcsPublic, NULL ) == S_OK )
                        {
                            *pbEnabled = TRUE;

                            ReleaseObj( pIHNetIcsPublic );
                        }

                        ReleaseObj( pHNetEnumPub );
                    }
                }
                break;
    
            case ICSSHARINGTYPE_PRIVATE:
                {
                    IEnumHNetIcsPrivateConnections* pHNetEnumPrv;

                    hr = pIcsSettings->EnumIcsPrivateConnections( &pHNetEnumPrv );

                    if ( SUCCEEDED(hr) )
                    {
                        IHNetIcsPrivateConnection *pIHNetIcsPrivate;
                    
                        if ( pHNetEnumPrv->Next( 1, &pIHNetIcsPrivate, NULL ) == S_OK )
                        {
                            *pbEnabled = TRUE;

                            ReleaseObj( pIHNetIcsPrivate );
                        }

                        ReleaseObj( pHNetEnumPrv );
                    }
                }
                break;
            
            default:
                 hr = E_UNEXPECTED;
                break;

            }    //    switch( Type )
            
            ReleaseObj( pIcsSettings );

        }    //    if ( SUCCEEDED(hr) )

    }    //    if ( NULL == pbEnabled )

    return hr;
}


STDMETHODIMP
CNetSharingConfiguration::GetSharingEnabled(
    BOOLEAN*               pbEnabled,
    SHARINGCONNECTIONTYPE* pType )
/*++

  CNetSharingConfiguration::GetSharingEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr = S_OK;

    if ( ( NULL == pbEnabled ) || ( NULL == pType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        BOOLEAN bBridged = FALSE;

        hr = InternalGetSharingEnabled( m_pHNetConnection, pbEnabled, pType );
    }

    return hr;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingConfiguration::get_SharingEnabled (VARIANT_BOOL* pbEnabled)
{
    HNET_OEM_API_ENTER

    SHARINGCONNECTIONTYPE Type;
    BOOLEAN bEnabled = FALSE;
    HRESULT hr = GetSharingEnabled (&bEnabled, &Type);
    if (SUCCEEDED(hr))
        *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    return hr;

    HNET_OEM_API_LEAVE
}
STDMETHODIMP CNetSharingConfiguration::get_SharingConnectionType(SHARINGCONNECTIONTYPE* pType)
{
    HNET_OEM_API_ENTER

    BOOLEAN bEnabled;
    return GetSharingEnabled (&bEnabled, pType);

    HNET_OEM_API_LEAVE
}

STDMETHODIMP
CNetSharingConfiguration::DisableSharing()
/*++

  CNetSharingConfiguration::DisableSharing

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        SHARINGCONNECTIONTYPE Type;
        
        hr = InternalGetSharingEnabled( m_pHNetConnection, &bEnabled, &Type );
        
        if ( SUCCEEDED(hr) && bEnabled ) 
        {
            switch( Type )
            {
            case ICSSHARINGTYPE_PUBLIC:
                {
                    IHNetIcsPublicConnection* pPublicConnection;

                    hr = m_pHNetConnection->GetControlInterface( 
                                __uuidof(IHNetIcsPublicConnection), 
                                reinterpret_cast<void**>(&pPublicConnection) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pPublicConnection->Unshare();

                        ReleaseObj(pPublicConnection);
                    }
                }
                break;

            case ICSSHARINGTYPE_PRIVATE:
                {
                    IHNetIcsPrivateConnection* pPrivateConnection;

                    hr = m_pHNetConnection->GetControlInterface( 
                                __uuidof(IHNetIcsPrivateConnection), 
                                reinterpret_cast<void**>(&pPrivateConnection) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pPrivateConnection->RemoveFromIcs();

                        ReleaseObj(pPrivateConnection);
                    }
                }
                break;

            default:
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::EnableSharing(
    SHARINGCONNECTIONTYPE  Type 
    )
/*++

  CNetSharingConfiguration::EnableSharing

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        SHARINGCONNECTIONTYPE existingType;

        hr = InternalGetSharingEnabled( m_pHNetConnection, &bEnabled, &existingType );

        // If all ready sharing the connection at the specified type then
        // return hresult.
        
        if ( SUCCEEDED(hr) && ( !bEnabled || (existingType != Type) ) )
        {
            BOOLEAN bTypeEnabled = FALSE;

            hr = InternalIsShareTypeEnabled( Type, &bTypeEnabled );

            // If we have another adapter all ready shared at the specified type
            // then return error

            if ( SUCCEEDED(hr) && bTypeEnabled )
            {
                hr = E_ANOTHERADAPTERSHARED;
            }
            else
            {
                if ( bEnabled )
                {
                    DisableSharing();
                }

                switch( Type )
                {
                case ICSSHARINGTYPE_PUBLIC:
                    {
                        IHNetIcsPublicConnection* pPublicConnection;

                        hr = m_pHNetConnection->SharePublic( &pPublicConnection );

                        if ( SUCCEEDED(hr) )
                        {
                            ReleaseObj( pPublicConnection );
                        }
                    }
                    break;

                case ICSSHARINGTYPE_PRIVATE:
                    {
                        IHNetIcsPrivateConnection* pPrivateConnection;

                        hr = m_pHNetConnection->SharePrivate( &pPrivateConnection );

                        if ( SUCCEEDED(hr) )
                        {
                            ReleaseObj(pPrivateConnection);
                        }
                    }
                    break;

                default:
                    hr = E_UNEXPECTED;

                }    //    switch( Type )

            }    //    if ( SUCCEEDED(hr) && !bEnabled )

        }    //    if ( SUCCEEDED(hr) && ( !bEnabled || (existingType != Type) )

    }    //    if ( !IsNotifyApproved() )

    return hr;

    HNET_OEM_API_LEAVE
}


HRESULT
InternalGetFirewallEnabled( 
    IHNetConnection*       pHNetConnection,
    BOOLEAN*               pbEnabled
    )
/*++

  InternalGetFirewallEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if ( NULL == pHNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;

        hr = pHNetConnection->GetProperties( &pProps );

        if ( SUCCEEDED(hr) )
        {
            if ( pProps->fFirewalled )
            {
                *pbEnabled = TRUE;
            }

            CoTaskMemFree( pProps );
        }
    }

    return hr;
}


STDMETHODIMP
CNetSharingConfiguration::get_InternetFirewallEnabled(
    VARIANT_BOOL *pbEnabled )
/*++

  CNetSharingConfiguration::GetInternetFirewallEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr = S_OK;

    if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;
        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::DisableInternetFirewall()
/*++

  CNetSharingConfiguration::DisableInternetFirewall

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        
        if ( SUCCEEDED(hr) && bEnabled ) 
        {
            IHNetFirewalledConnection* pFirewallConnection;

            hr = m_pHNetConnection->GetControlInterface( 
                        __uuidof(IHNetFirewalledConnection), 
                        reinterpret_cast<void**>(&pFirewallConnection) );

            if ( SUCCEEDED(hr) )
            {
                hr = pFirewallConnection->Unfirewall();

                ReleaseObj(pFirewallConnection);
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::EnableInternetFirewall()
/*++

  CNetSharingConfiguration::EnableInternetFirewall

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        
        if ( SUCCEEDED(hr) && !bEnabled ) 
        {
            IHNetFirewalledConnection* pFirewalledConnection;

            m_pHNetConnection->Firewall( &pFirewalledConnection );

            if ( SUCCEEDED(hr) )
            {
                ReleaseObj( pFirewalledConnection );
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP
CNetSharingConfiguration::AddPortMapping(
    OLECHAR*                 pszwName,
    UCHAR                    ucIPProtocol,
    USHORT                   usExternalPort,
    USHORT                   usInternalPort,
    DWORD                     dwOptions,
    OLECHAR*                 pszwTargetNameOrIPAddress,
    ICS_TARGETTYPE           eTargetType,
    INetSharingPortMapping** ppMapping )
/*++

  CNetSharingConfiguration::AddPortMapping

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    OLECHAR* pszwTargetName      = NULL;
    OLECHAR* pszwTargetIPAddress = NULL;
    if      (eTargetType == ICSTT_NAME)         pszwTargetName      = pszwTargetNameOrIPAddress;
    else if (eTargetType == ICSTT_IPADDRESS)    pszwTargetIPAddress = pszwTargetNameOrIPAddress;
    else
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if ( NULL == ppMapping )
    {
        hr = E_POINTER;
    }
    else if ( ( NULL == pszwName ) ||
              ( 0 == ucIPProtocol ) ||
              ( 0 == usInternalPort) || // should I allow this, implying internal == external?
              ( 0 == usExternalPort ) )
    {
        hr = E_INVALIDARG;
    }
    else if ( ( NULL == pszwTargetName ) &&
              ( NULL == pszwTargetIPAddress ) )
    {
        hr = E_INVALIDARG;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else if ( NULL == m_pSettings )
    {
        hr = E_UNEXPECTED;
    }

    if ( SUCCEEDED(hr) )
    {
        *ppMapping = NULL;

        CComObject<CNetSharingPortMapping>* pNewMap;

        hr = CComObject<CNetSharingPortMapping>::CreateInstance( &pNewMap );

        if ( SUCCEEDED(hr) )
        {
            pNewMap->AddRef();

            IHNetPortMappingProtocol* pNewProtocol = NULL;

            // first, find existing IHNetPortMappingProtocol interface
            CComPtr<IEnumHNetPortMappingProtocols> spEnumProtocols = NULL;
            m_pSettings->EnumPortMappingProtocols (&spEnumProtocols);
            if (spEnumProtocols) {
                CComPtr<IHNetPortMappingProtocol> spHNetPortMappingProtocol = NULL;
                while (S_OK == spEnumProtocols->Next (1, &spHNetPortMappingProtocol, NULL)) {
                    UCHAR ucProtocol = 0;
                    spHNetPortMappingProtocol->GetIPProtocol (&ucProtocol);
                    USHORT usPort = 0;
                    spHNetPortMappingProtocol->GetPort (&usPort);

                    if ((ucProtocol    == ucIPProtocol) &&
                        (ntohs(usPort) == usExternalPort)) {
#if DBG
                        OLECHAR * szwName = NULL;
                        spHNetPortMappingProtocol->GetName (&szwName);
                        if (szwName) {
                            _ASSERT (!wcscmp (szwName, pszwName));
                            CoTaskMemFree (szwName);
                        }
#endif
                        pNewProtocol = spHNetPortMappingProtocol.Detach();
                        break;
                    }
                    spHNetPortMappingProtocol = NULL;
                }
            }

            if (pNewProtocol == NULL) {
                hr = m_pSettings->CreatePortMappingProtocol(
                            pszwName,
                            ucIPProtocol,
                            htons (usExternalPort),
                            &pNewProtocol );
            }

            if ( SUCCEEDED(hr) )
            {
                IHNetPortMappingBinding *pNewBinding;

                hr = m_pHNetConnection->GetBindingForPortMappingProtocol( 
                            pNewProtocol, 
                            &pNewBinding );

                if ( SUCCEEDED(hr) )
                {
                    if ( NULL == pszwTargetName )
                    {
                        ULONG ulAddress = IpPszToHostAddr( pszwTargetIPAddress );
                        ulAddress = htonl (ulAddress);
                        hr = pNewBinding->SetTargetComputerAddress( ulAddress );
                    }
                    else
                    {
                        hr = pNewBinding->SetTargetComputerName( pszwTargetName );
                    }

                    if ( SUCCEEDED(hr ) )
                    {
                        hr = pNewBinding->SetTargetPort (htons (usInternalPort));
                    }

                    if ( SUCCEEDED(hr ) )
                    {
                        pNewMap->Initialize( pNewBinding );

                        *ppMapping = pNewMap;

                        (*ppMapping)->AddRef();
                    }

                    ReleaseObj( pNewBinding );
                }

                ReleaseObj( pNewProtocol );
            }

            ReleaseObj(pNewMap);
        }
    }
    
    return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingConfiguration::RemovePortMapping

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
STDMETHODIMP
CNetSharingConfiguration::RemovePortMapping( 
    INetSharingPortMapping*  pMapping 
    )
{
    HNET_OEM_API_ENTER

    HRESULT hr;

    if ( NULL == pMapping )
    {
        hr = E_INVALIDARG;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = pMapping->Delete();
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingPortMapping::get_Properties (INetSharingPortMappingProps ** ppNSPMP)
//    ICS_PORTMAPPING** ppProps)
/*++

  CNetSharingPortMapping::get_Properties

Routine Description:


Arguments:

    ppProps

Return Value:

    none

--*/
{
    // idea: use existing code to fill out ICS_PORTMAPPING,
    // then convert to INetSharingPortMappingProps

    HNET_OEM_API_ENTER

    ICS_PORTMAPPING * pProps = NULL;
    ICS_PORTMAPPING** ppProps = &pProps;

    HRESULT hr;

#define Props (*ppProps)

    if ( NULL == ppNSPMP )
    {
        hr = E_POINTER;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        Props = reinterpret_cast<ICS_PORTMAPPING*>(CoTaskMemAlloc(sizeof(ICS_PORTMAPPING)));

        if ( NULL == Props )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            HRESULT hrName, hrAddr;
            ULONG   ulAddress = 0L;

            ZeroMemory( Props, sizeof(ICS_APPLICATION_DEFINITION) );
            
            hrName = _IProtocol()->GetTargetComputerName( &(Props->pszwTargetName) );

            hrAddr = _IProtocol()->GetTargetComputerAddress( &ulAddress );
    
            if ( SUCCEEDED(hrAddr) )
            {
                hrAddr = HostAddrToIpPsz( ulAddress, &(Props->pszwTargetIPAddress) );
            }

            if ( SUCCEEDED(hrName) || SUCCEEDED(hrAddr) )
            {
                IHNetPortMappingProtocol *pProtocol = NULL;

                hr = _IProtocol()->GetProtocol( &pProtocol );

                if ( SUCCEEDED(hr) )
                {
                    hr = pProtocol->GetName( &(Props->pszwName) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pProtocol->GetIPProtocol( &(Props->ucIPProtocol) );
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pProtocol->GetPort( &(Props->usExternalPort) );
                    }

                    ReleaseObj(pProtocol);
                }
            } else  // actually, either error will do.
                hr = hrName; // ? hrName : hrAddr;

            if (SUCCEEDED(hr)) {

                // distinguish between TargetComputerName and TargetIPAddress
                if (Props->pszwTargetIPAddress && Props->pszwTargetName) {
                    BOOLEAN fUseName;
                    HRESULT hr1 = _IProtocol()->GetCurrentMethod (&fUseName);
                    if (fUseName) {
                        CoTaskMemFree( Props->pszwTargetIPAddress );
                        Props->pszwTargetIPAddress = NULL;
                    } else {
                        CoTaskMemFree( Props->pszwTargetName );
                        Props->pszwTargetName = NULL;
                    }
                }

                // lastly, get enabled bit
                BOOLEAN b = FALSE;
                hr = _IProtocol()->GetEnabled (&b);
                Props->bEnabled = b == TRUE ? VARIANT_TRUE : VARIANT_FALSE;
            }

            if (SUCCEEDED(hr))
            {
                hr = _IProtocol()->GetTargetPort ( &(Props->usInternalPort) );
            }

            if ( FAILED(hr) )
            {
                if ( Props->pszwName )
                    CoTaskMemFree( Props->pszwName );

                if ( Props->pszwTargetIPAddress )
                    CoTaskMemFree( Props->pszwTargetIPAddress );

                if ( Props->pszwTargetName )
                    CoTaskMemFree( Props->pszwTargetName );

                CoTaskMemFree( Props );

                Props = NULL;
            }
        }
    }

    if (Props) {
        // convert to INetSharingPortMappingProps **ppNSPMP
        CComObject<CNetSharingPortMappingProps>* pNSPMP = NULL;
        hr = CComObject<CNetSharingPortMappingProps>::CreateInstance (&pNSPMP);
        if (pNSPMP) {
            pNSPMP->AddRef();
            // adjust byte order
            Props->usExternalPort = ntohs (Props->usExternalPort);
            Props->usInternalPort = ntohs (Props->usInternalPort);
            hr = pNSPMP->SetRawData (Props);
            if (hr == S_OK)
                hr = pNSPMP->QueryInterface (__uuidof(INetSharingPortMappingProps), (void**)ppNSPMP);
            pNSPMP->Release();
        }
        if (Props->pszwName)
            CoTaskMemFree (Props->pszwName);
        if (Props->pszwTargetIPAddress)
            CoTaskMemFree (Props->pszwTargetIPAddress);
        if (Props->pszwTargetName)
            CoTaskMemFree (Props->pszwTargetName);
        CoTaskMemFree (Props);
    }

#undef Props                

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingPortMapping::Delete()
/*++

  CNetSharingPortMapping::Delete

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr;

    Disable();  // if we can't delete it, at least disable it.
    // TODO: should I do this only if the Delete call below returns E_ACCESSDENIED?

    if ( _IProtocol() )
    {
        IHNetPortMappingProtocol* pPortMappingProtocol;

        hr = _IProtocol()->GetProtocol( &pPortMappingProtocol );

        if SUCCEEDED(hr)
        {
            pPortMappingProtocol->Delete();

            EnterCriticalSection( _CriticalSection() );

            _IProtocol( NULL );        

            LeaveCriticalSection( _CriticalSection() );

            ReleaseObj( pPortMappingProtocol );
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <commctrl.h>    // added to "Fusionized"
#include <windowsx.h>
#include <raserror.h>
#include <rasuip.h>
#include <wbemidl.h>
#include <netcon.h>
#include <netconp.h>
#include <devguid.h>
#include <iphlpapi.h>
#include <ipnathlp.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <saupdate.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncres.h"
#include "hncstrs.h"
#include "hncutil.h"

#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
#include "hnapi.h"

#include <NATUPnP.h>
#include "UPnPNAT.h"
#include "AlgSetup.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\resourc2.h ===
// stuff shared between hnetcfg and icsdclt

// used by lvx stuff
#define IID_Checked           50
#define IID_Unchecked         51
#define IID_DisabledUnchecked 60
#define IID_DisabledChecked   61
#define IID_Connection_ICF_ICS 62

#define PID_SS_SharedAccessServices     559
#define DID_SS_Service                  557
#define PID_SS_PleaseWait               558

#define CID_SS_LV_Services              1560
#define CID_SS_PB_Add                   1561
#define CID_SS_PB_Delete                1562
#define CID_SS_PB_Edit                  1563
#define CID_SS_EB_InternalPort          1551
#define CID_SS_EB_ExternalPort          1553
#define CID_SS_EB_Service               1552
#define CID_SS_PB_Tcp                   1554
#define CID_SS_PB_Udp                   1555
#define CID_SS_EB_Address               1556

#define SID_PopupTitle                  361
#define SID_TypeEntryName               532
#define SID_TypePortNumber              534
#define SID_DuplicatePortNumber         539
#define SID_NoDeleteSelection           541
#define SID_NoModifySelection           543
#define SID_SS_TypeAddress              544
#define SID_OP_GenericPortMappingError  501
#define SID_OP_OurGatewayError          503
#define SID_OP_TheirGatewayError        504
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hncutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C U T I L . C P P
//
//  Contents:   Home Networking Configuration Utility Routines
//
//  Notes:
//
//  Author:     jonburs 27 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// MPRAPI.DLL import prototypes
//

typedef DWORD
(APIENTRY* PMPRCONFIGBUFFERFREE)(
    LPVOID
    );

typedef DWORD
(APIENTRY* PMPRCONFIGSERVERCONNECT)(
    LPWSTR,
    PHANDLE
    );

typedef VOID
(APIENTRY* PMPRCONFIGSERVERDISCONNECT)(
    HANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETHANDLE)(
    HANDLE,
    DWORD,
    PHANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETINFO)(
    HANDLE,
    HANDLE,
    LPBYTE*,
    LPDWORD,
    LPBYTE*,
    LPDWORD,
    LPWSTR*
    );

typedef DWORD
(APIENTRY* PMPRINFOBLOCKFIND)(
    LPVOID,
    DWORD,
    LPDWORD,
    LPDWORD,
    LPBYTE*
    );

//
// The size of the stack buffer to use for building queries. If the
// query exceeeds this length, the working buffer will be allocated from
// the heap
//

const ULONG c_cchQueryBuffer = 256;


HRESULT
HrFromLastWin32Error ()
//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }
    return hr;
}


BOOLEAN
ApplicationProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usOutgoingPort,
    UCHAR ucOutgoingIPProtocol
    )

/*++

Routine Description:

    Checks if an application protocol already exists that has the
    specified outgoing protocol and port.


Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing "WQL"

    ucOutgoingProtocol - the protocol number to check for

    usOutgoingPort - the port to check for

Return Value:

    BOOLEAN -- TRUE if the application protocol exists; FALSE otherwise

--*/

{
    BSTR bstr;
    BOOLEAN fDuplicate = FALSE;
    HRESULT hr = S_OK;
    int iBytes;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulObjs;
    OLECHAR wszWhereClause[c_cchQueryBuffer + 1];

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(0 == wcscmp(bstrWQL, L"WQL"));

    //
    // Build the query string
    //

    iBytes = _snwprintf(
                wszWhereClause,
                c_cchQueryBuffer,
                c_wszApplicationProtocolQueryFormat,
                usOutgoingPort,
                ucOutgoingIPProtocol
                );

    if (iBytes >= 0)
    {
        //
        // String fit into buffer; make sure it's null terminated
        //

        wszWhereClause[c_cchQueryBuffer] = L'\0';
    }
    else
    {
        //
        // For some reason the string didn't fit into the buffer...
        //

        hr = E_UNEXPECTED;
        _ASSERT(FALSE);
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetApplicationProtocol,
                wszWhereClause
                );
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve an item from the enum. If we're successful,
        // this is a duplicate protocol.
        //

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulObjs
                );

        if (SUCCEEDED(hr) && 1 == ulObjs)
        {
            //
            // It's a duplicate
            //

            fDuplicate = TRUE;
            pwcoInstance->Release();
        }

        pwcoEnum->Release();
    }

    return fDuplicate;
} // ApplicationProtocolExists



HRESULT
BuildAndString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft AND pwszRight


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the AND clause

    pwszRight - right side of the AND clause

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + AND + space + length(right) + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s AND %s",
            pwszLeft,
            pwszRight
            );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



HRESULT
BuildAssociatorsQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszAssocClass
    )

/*++

Routine Description:

    Builds a WQL references query and places it into a BSTR. The returned
    query is

    ASSOCIATORS OF {wszProperties} WHERE AssocClass = pwszAssocClass


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszObjectPath - path of the object to find the references of

    pwszAssocClass - the associator class

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszAssociatorsOf) == c_cchAssociatorsOf);
    _ASSERT(wcslen(c_wszWhereAssocClass) == c_cchWhereAssocClass);

    //
    // All necessary spaces are embedded in the string constants
    //

    ULONG cchLength = c_cchAssociatorsOf + c_cchWhereAssocClass;

    _ASSERT(pwszObjectPath);
    _ASSERT(pwszAssocClass);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszObjectPath);
    cchLength += wcslen(pwszAssocClass);

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        swprintf(
            pwszQuery,
            L"%s%s%s%s",
            c_wszAssociatorsOf,
            pwszObjectPath,
            c_wszWhereAssocClass,
            pwszAssocClass
            );

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


HRESULT
BuildEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = pwszRight


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + = + space + length(right) + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 4;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = %s",
            pwszLeft,
            pwszRight
            );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
BuildEscapedQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = "pwszRight"

    after escaping pwszRight -- replace \ w/ \\ and " with \"


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause. This will be escaped, and then
                wrapped in quotes

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;
    LPWSTR wszEscaped;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // Escape string
    //

    wszEscaped = EscapeString(pwszRight);
    if (NULL == wszEscaped)
    {
        return E_OUTOFMEMORY;
    }

    //
    // length(left) + space + = + space + " + length(right) + " + null
    //

    cch = wcslen(pwszLeft) + wcslen(wszEscaped) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = \"%s\"",
            pwszLeft,
            wszEscaped
            );

        delete [] wszEscaped;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
BuildQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = "pwszRight"


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause. This will be wrapped in
                quotes

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;
    LPWSTR wsz;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + = + space + " + length(right) + " + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = \"%s\"",
            pwszLeft,
            pwszRight
            );

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



HRESULT
BuildReferencesQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszTargetClass
    )

/*++

Routine Description:

    Builds a WQL references query and places it into a BSTR. The returned
    query is

    REFERENCES OF {pwszObjectPath} WHERE ResultClass = pwszTargetClass

    if pwszTargetClass is not NULL, and

    REFERENCES OF {pwszObjectPath}

    otherwise


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszObjectPath - path of the object to find the references of

    pwszTargetClass - the class of references desired. May be NULL.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszReferencesOf) == c_cchReferencesOf);
    _ASSERT(wcslen(c_wszWhereResultClass) == c_cchWhereResultClass);

    //
    // All necessary spaces are embedded in the string constants
    //

    ULONG cchLength = c_cchReferencesOf + c_cchWhereResultClass;

    _ASSERT(pwszObjectPath);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszObjectPath);
    if (NULL != pwszTargetClass)
    {
        cchLength += wcslen(pwszTargetClass);
    }

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        if (NULL != pwszTargetClass)
        {
            swprintf(
                pwszQuery,
                L"%s%s%s%s",
                c_wszReferencesOf,
                pwszObjectPath,
                c_wszWhereResultClass,
                pwszTargetClass
                );
        }
        else
        {
            swprintf(
                pwszQuery,
                L"%s%s}",
                c_wszReferencesOf,
                pwszObjectPath
                );
        }

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


HRESULT
BuildSelectQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszProperties,
    LPCWSTR pwszFromClause,
    LPCWSTR pwszWhereClause
    )

/*++

Routine Description:

    Builds a WQL select query and places it into a BSTR. The returned
    query is

    SELECT wszProperties FROM wszFromClause [WHERE wszWhereClause]


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszProperties - the properties the query should return

    pwszFromClause - the class the returned objects should be from

    pwszWhereClause - the constraints that the returned object must meet. If
        NULL, the query will not have a where clause.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszSelect) == c_cchSelect);
    _ASSERT(wcslen(c_wszFrom) == c_cchFrom);
    _ASSERT(wcslen(c_wszWhere) == c_cchWhere);

    //
    // SELECT + 2 spaces (around properties) + FROM + space
    //

    ULONG cchLength = c_cchSelect + 2 + c_cchFrom + 1;

    _ASSERT(pwszProperties);
    _ASSERT(pwszFromClause);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszProperties);
    cchLength += wcslen(pwszFromClause);
    if (pwszWhereClause)
    {
        //
        // space + WHERE + space
        //
        cchLength += 2 + c_cchWhere;
        cchLength += wcslen(pwszWhereClause);
    }

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        if (pwszWhereClause)
        {
            swprintf(
                pwszQuery,
                L"%s %s %s %s %s %s",
                c_wszSelect,
                pwszProperties,
                c_wszFrom,
                pwszFromClause,
                c_wszWhere,
                pwszWhereClause
                );
        }
        else
        {
            swprintf(
                pwszQuery,
                L"%s %s %s %s",
                c_wszSelect,
                pwszProperties,
                c_wszFrom,
                pwszFromClause
                );
        }

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


BOOLEAN
ConnectionIsBoundToTcp(
    PIP_INTERFACE_INFO pIpInfoTable,
    GUID *pConnectionGuid
    )

/*++

Routine Description:

    Determines if a LAN connection is bound to TCP/IP. For the purposes of
    this routine, "bound to TCP/IP" is defines as there exists an IP
    adapter index for the connection.

Arguments:

    pIpInfoTable - the IP interface table, obtained from a call to
                   GetInterfaceInfo

    pConnectionGuid - a pointer to the guid for the connection

Return Value:

    BOOLEAN - TRUE if the connection is bound to TCP/IP; FALSE otherwise.
              FALSE will be returned if an error occurs

--*/

{
    BOOLEAN fIsBound = FALSE;
    LPOLESTR pszGuid;
    HRESULT hr;
    ULONG cchGuid;
    ULONG cchName;
    PWCHAR pwchName;
    LONG l;

    _ASSERT(NULL != pIpInfoTable);
    _ASSERT(NULL != pConnectionGuid);

    //
    // Convert the guid to a string
    //

    hr = StringFromCLSID(*pConnectionGuid, &pszGuid);

    if (SUCCEEDED(hr))
    {
        cchGuid = wcslen(pszGuid);

        //
        // Walk the table, searching for the corresponding adapter
        //

        for (l = 0; l < pIpInfoTable->NumAdapters; l++)
        {
            cchName = wcslen(pIpInfoTable->Adapter[l].Name);

            if (cchName < cchGuid) { continue; }
            pwchName = pIpInfoTable->Adapter[l].Name + (cchName - cchGuid);
            if (0 == _wcsicmp(pszGuid, pwchName))
            {
                fIsBound = TRUE;
                break;
            }
        }

        CoTaskMemFree(pszGuid);
    }


    return fIsBound;
} // ConnectionIsBoundToTcp


HRESULT
ConvertResponseRangeArrayToInstanceSafearray(
    IWbemServices *piwsNamespace,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    SAFEARRAY **ppsa
    )

/*++

Routine Description:

    Converts an array of HNET_RESPONSE_RANGE structures into a
    safearray of IUnknows that represent WMI instances of
    those response ranges.

Arguments:

    piwsNamespace - the namespace to use

    uscResponses - the count of responses

    rgResponses - the response range structures

    ppsa - receives a pointer to the safearrays

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    SAFEARRAY *psa;
    BSTR bstrPath;
    SAFEARRAYBOUND rgsabound[1];
    IWbemClassObject *pwcoClass = NULL;
    IWbemClassObject *pwcoInstance;
    IUnknown *pUnk;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(0 != uscResponses);
    _ASSERT(NULL != rgResponses);
    _ASSERT(NULL != ppsa);

    bstrPath = SysAllocString(c_wszHnetResponseRange);
    if (NULL == bstrPath)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {

        //
        // Get the class for HNet_ResponseRange
        //

        pwcoClass = NULL;
        hr = piwsNamespace->GetObject(
                bstrPath,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pwcoClass,
                NULL
                );

        SysFreeString(bstrPath);
    }


    if (S_OK == hr)
    {
        //
        // Create the array to hold the response range instances
        //

        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = uscResponses;

        psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
        if (NULL == psa)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Process the passed in response ranges
        //

        for (USHORT i = 0; i < uscResponses; i++)
        {
            //
            // First, create an HNet_ResponseRange instance
            // for the entry
            //

            pwcoInstance = NULL;
            hr = pwcoClass->SpawnInstance(0, &pwcoInstance);

            if (WBEM_S_NO_ERROR != hr)
            {
                break;
            }

            //
            // Populate that instance
            //

            hr = CopyStructToResponseInstance(
                    &rgResponses[i],
                    pwcoInstance
                    );

            if (FAILED(hr))
            {
                pwcoInstance->Release();
                break;
            }

            //
            // Get the IUnknown for the instance and put it
            // in the array
            //

            hr = pwcoInstance->QueryInterface(
                    IID_PPV_ARG(IUnknown, &pUnk)
                    );

            _ASSERT(S_OK == hr);

            LONG lIndex = i;
            hr = SafeArrayPutElement(
                    psa,
                    &lIndex,
                    pUnk
                    );

            pUnk->Release();
            pwcoInstance->Release();

            if (FAILED(hr))
            {
                SafeArrayDestroy(psa);
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppsa = psa;
        hr = S_OK;
    }

    if (pwcoClass) pwcoClass->Release();

    return hr;
}


HRESULT
CopyResponseInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_RESPONSE_RANGE *pResponse
    )

/*++

Routine Description:

    Converts an instance of an HNet_ResponseRange into the
    corresponding HNET_RESPONSE_RANGE

Arguments:

    pwcoInstance - the HNet_ResponseRange instance

    pResponse - the HNET_RESPONSE_RANGE to fill

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pResponse);

    hr = pwcoInstance->Get(
            c_wszIPProtocol,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        pResponse->ucIPProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszStartPort,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI returns uint16 properties as VT_I4
            //

            _ASSERT(VT_I4 == V_VT(&vt));

            pResponse->usStartPort = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszEndPort,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI returns uint16 properties as VT_I4
            //

            _ASSERT(VT_I4 == V_VT(&vt));

            pResponse->usEndPort = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }
    }

    return hr;
}


HRESULT
CopyStructToResponseInstance(
    HNET_RESPONSE_RANGE *pResponse,
    IWbemClassObject *pwcoInstance
    )

/*++

Routine Description:

    Converts an instance of an HNet_ResponseRange into the
    corresponding HNET_RESPONSE_RANGE

Arguments:

    pResponse - the HNET_RESPONSE_RANGE to fill

    pwcoInstance - the HNet_ResponseRange instance to create


Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pResponse);
    _ASSERT(NULL != pwcoInstance);

    VariantInit(&vt);
    V_VT(&vt) = VT_UI1;
    V_UI1(&vt) = pResponse->ucIPProtocol;

    hr = pwcoInstance->Put(
            c_wszIPProtocol,
            0,
            &vt,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = pResponse->usStartPort;

        hr = pwcoInstance->Put(
            c_wszStartPort,
            0,
            &vt,
            NULL
            );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        V_I4(&vt) = pResponse->usEndPort;

        hr = pwcoInstance->Put(
            c_wszEndPort,
            0,
            &vt,
            NULL
            );
    }

    return hr;

}


HRESULT
DeleteWmiInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

/*++

Routine Description:

    Deletes an object instance from the WMI repository.

Arguments:

    piwsNamespace - the namespace the object is in

    pwcoInstance - the class object interface for the instance

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR bstr;

    _ASSERT(piwsNamespace);
    _ASSERT(pwcoInstance);

    hr = GetWmiPathFromObject(pwcoInstance, &bstr);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = piwsNamespace->DeleteInstance(
                bstr,
                0,
                NULL,
                NULL
                );

        SysFreeString(bstr);
    }

    return hr;
}


LPWSTR
EscapeString(
    LPCWSTR pwsz
    )

{
    ULONG ulCount = 0;
    LPWSTR wsz;
    LPWSTR wszReturn;

    wsz = const_cast<LPWSTR>(pwsz);

    while (NULL != *wsz)
    {
        if (L'\\' == *wsz || L'\"' == *wsz)
        {
            //
            // Need an extra character
            //

            ulCount += 1;
        }

        wsz += 1;
        ulCount += 1;
    }

    //
    // Allocate new string buffer
    //

    wszReturn = new OLECHAR[ulCount + 1];
    if (NULL == wszReturn)
    {
        return wszReturn;
    }

    //
    // Copy string over
    //

    wsz = wszReturn;

    while (NULL != *pwsz)
    {
        if (L'\\' == *pwsz || L'\"' == *pwsz)
        {
            *wsz++ = L'\\';
        }

        *wsz++ = *pwsz++;
    }

    //
    // Make sure everything is properly null terminated
    //

    *wsz = L'';

    return wszReturn;
}


HRESULT
InitializeNetCfgForWrite(
    OUT INetCfg             **ppnetcfg,
    OUT INetCfgLock         **ppncfglock
    )

/*++

Routine Description:

    Initializes NetCfg for writing. If this function succeeds, the
    caller must call UninitializeNetCfgForWrite() with the two
    returned interface pointers when done.

Arguments:

    ppnetcfg                Receives an initialized INetCfg interface.

    ppnetcfglock            Receives an acquires INetCfgLock interface.

Return Value:

    Status of the operation

--*/

{
    HRESULT         hr = S_OK;

    *ppnetcfg = NULL;
    *ppncfglock = NULL;

    // Open our own NetCfg context
    hr = CoCreateInstance(
            CLSID_CNetCfg,
            NULL,
            CLSCTX_SERVER,
            IID_PPV_ARG(INetCfg, ppnetcfg)
            );

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the lock interface
        //
        hr = (*ppnetcfg)->QueryInterface(
                IID_PPV_ARG(INetCfgLock, ppncfglock)
                );

        if ( SUCCEEDED(hr) )
        {
            //
            // Get the NetCfg lock
            //
            hr = (*ppncfglock)->AcquireWriteLock(
                    5,
                    L"HNetCfg",
                    NULL
                    );

            //
            // S_FALSE is actually failure; it means NetCfg timed out
            // trying to acquire the write lock
            //
            if( S_FALSE == hr )
            {
                // Turn into an error that will make sense up the call chain
                hr = NETCFG_E_NO_WRITE_LOCK;
            }

            if ( SUCCEEDED(hr) )
            {
                //
                // Must initialize NetCfg inside the lock
                //
                hr = (*ppnetcfg)->Initialize( NULL );

                if( FAILED(hr) )
                {
                    (*ppncfglock)->ReleaseWriteLock();
                }
            }

            if( FAILED(hr) )
            {
                (*ppncfglock)->Release();
                *ppncfglock = NULL;
            }
        }

        if( FAILED(hr) )
        {
            (*ppnetcfg)->Release();
            *ppnetcfg = NULL;
        }
    }

    return hr;
}



void
UninitializeNetCfgForWrite(
    IN INetCfg              *pnetcfg,
    IN INetCfgLock          *pncfglock
    )

/*++

Routine Description:

    Uninitializes a NetCfg context created with InitializeNetCfgForWrite()

Arguments:

    pnetcfg                 An INetCfg instance created by InitializeNetCfgForWrite()

    pncfglock               An INetCfgLock instance created by InitializeNetCfgForWrite()

Return Value:

    Status of the operation

--*/

{
    _ASSERT( (NULL != pnetcfg) && (NULL != pncfglock) );

    pnetcfg->Uninitialize();
    pncfglock->ReleaseWriteLock();
    pncfglock->Release();
    pnetcfg->Release();
}


HRESULT
FindAdapterByGUID(
    IN INetCfg              *pnetcfg,
    IN GUID                 *pguid,
    OUT INetCfgComponent    **ppncfgcomp
    )

/*++

Routine Description:

    Retrieves an INetCfgComponent interface, if any, that corresponds
    to the given device GUID. The GUID must correspond to a networking
    component of class NET (i.e., a miniport).

    E_FAIL is returned if the given GUID is not located.

Arguments:

    pnetcfg                 An instance of INetCfg which has already had
                            its Initialize() method called

    pguid                   The GUID to search for

    ppncfgcomp              Receives the resulting INetCfgComponent interface
                            pointer.

Return Value:

    Status of the operation

--*/

{
    HRESULT                 hr = S_OK;
    GUID                    guidDevClass = GUID_DEVCLASS_NET;
    IEnumNetCfgComponent    *penumncfgcomp;
    INetCfgComponent        *pnetcfgcomp;
    ULONG                   ulCount;
    BOOLEAN                 fFound = FALSE;

    //
    // Get the list of NET (adapter) devices
    //
    hr = pnetcfg->EnumComponents( &guidDevClass, &penumncfgcomp );

    if (S_OK == hr)
    {
        //
        // Search for the designated adapter by GUID
        //
        while ( (FALSE == fFound) &&
                (S_OK == penumncfgcomp->Next(1, &pnetcfgcomp, &ulCount) ) )
        {
            GUID            guidThis;

            hr = pnetcfgcomp->GetInstanceGuid( &guidThis );

            if ( (S_OK == hr) && (InlineIsEqualGUID(guidThis,*pguid)) )
            {
                fFound = TRUE;
            }
            else
            {
                pnetcfgcomp->Release();
            }
        }
        penumncfgcomp->Release();
    }

    if (fFound)
    {
        *ppncfgcomp = pnetcfgcomp;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT
FindINetConnectionByGuid(
    GUID *pGuid,
    INetConnection **ppNetCon
    )

/*++

Routine Description:

    Retrieves the INetConnection that corresponds to the given GUID.

Arguments:

    pGuid - the guid of the connection

    ppNetCon - receives the interface

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    INetConnectionManager *pManager;
    IEnumNetConnection *pEnum;
    INetConnection *pConn;

    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != ppNetCon);

    //
    // Get the net connections manager
    //

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_ALL,
            IID_PPV_ARG(INetConnectionManager, &pManager)
            );

    if (S_OK == hr)
    {
        //
        // Get the enumeration of connections
        //

        SetProxyBlanket(pManager);

        hr = pManager->EnumConnections(NCME_DEFAULT, &pEnum);

        pManager->Release();
    }

    if (S_OK == hr)
    {
        //
        // Search for the connection with the correct guid
        //

        ULONG ulCount;
        BOOLEAN fFound = FALSE;

        SetProxyBlanket(pEnum);

        do
        {
            NETCON_PROPERTIES *pProps;

            hr = pEnum->Next(1, &pConn, &ulCount);
            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                SetProxyBlanket(pConn);

                hr = pConn->GetProperties(&pProps);
                if (S_OK == hr)
                {
                    if (IsEqualGUID(pProps->guidId, *pGuid))
                    {
                        fFound = TRUE;
                        *ppNetCon = pConn;
                        (*ppNetCon)->AddRef();
                    }

                    NcFreeNetconProperties(pProps);
                }

                pConn->Release();
            }
        }
        while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

        //
        // Normalize hr
        //

        hr = (fFound ? S_OK : E_FAIL);

        pEnum->Release();
    }

    return hr;
}

HRESULT
GetBridgeConnection(
    IN IWbemServices       *piwsHomenet,
    OUT IHNetBridge       **pphnetBridge
    )
{
    INetCfg                 *pnetcfg;
    HRESULT                 hr;

    if( NULL != pphnetBridge )
    {
        *pphnetBridge = NULL;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_SERVER,
                IID_PPV_ARG(INetCfg, &pnetcfg));

        if( S_OK == hr )
        {
            hr = pnetcfg->Initialize( NULL );

            if( S_OK == hr )
            {
                INetCfgComponent    *pnetcfgcompBridge;

                hr = pnetcfg->FindComponent( c_wszSBridgeMPID, &pnetcfgcompBridge );

                if( S_OK == hr )
                {
                    hr = GetIHNetConnectionForNetCfgComponent(
                            piwsHomenet,
                            pnetcfgcompBridge,
                            TRUE,
                            IID_PPV_ARG(IHNetBridge, pphnetBridge)
                            );

                    pnetcfgcompBridge->Release();
                }

                pnetcfg->Uninitialize();
            }

            pnetcfg->Release();
        }
    }
    else
    {
        hr = E_POINTER;
    }

    // S_FALSE tends to get mishandled; return E_FAIL to signal the absence of a bridge.
    if( S_FALSE == hr )
    {
        return E_FAIL;
    }

    return hr;
}

HRESULT
GetIHNetConnectionForNetCfgComponent(
    IN IWbemServices        *piwsHomenet,
    IN INetCfgComponent     *pnetcfgcomp,
    IN BOOLEAN               fLanConnection,
    IN REFIID                iid,
    OUT PVOID               *ppv
    )
{
    HRESULT                         hr;

    if( NULL != ppv )
    {
        CComObject<CHNetCfgMgrChild>    *pHNCfgMgrChild;

        *ppv = NULL;
        hr = CComObject<CHNetCfgMgrChild>::CreateInstance(&pHNCfgMgrChild);

        if (SUCCEEDED(hr))
        {
            pHNCfgMgrChild->AddRef();
            hr = pHNCfgMgrChild->Initialize(piwsHomenet);

            if (SUCCEEDED(hr))
            {
                GUID                guid;

                hr = pnetcfgcomp->GetInstanceGuid( &guid );

                if( S_OK == hr )
                {
                    IHNetConnection     *phnetcon;

                    hr = pHNCfgMgrChild->GetIHNetConnectionForGuid( &guid, fLanConnection, TRUE, &phnetcon );

                    if( S_OK == hr )
                    {
                        hr = phnetcon->GetControlInterface( iid, ppv );
                        phnetcon->Release();
                    }
                }
            }

            pHNCfgMgrChild->Release();
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
BindOnlyToBridge(
    IN INetCfgComponent     *pnetcfgcomp
    )

/*++

Routine Description:

    Alters the bindings for the given INetCfgComponent so it is bound only
    to the bridge protocol
    
    c_pwszBridgeBindExceptions is a list of exceptions; if a binding path
    involves a component listed in c_pwszBridgeBindExceptions, the path
    will not be altered.

Arguments:

    pnetcfgcomp     The component whose bindings we wish to alter

Return Value:

    standard HRESULT

--*/


{
    HRESULT                     hr = S_OK;
    INetCfgComponentBindings    *pnetcfgBindings;

    //
    // Retrieve the ComponentBindings interface
    //
    hr = pnetcfgcomp->QueryInterface(
            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgBindings)
            );

    if (S_OK == hr)
    {
        IEnumNetCfgBindingPath  *penumPaths;

        //
        // Get the list of binding paths for this component
        //
        hr = pnetcfgBindings->EnumBindingPaths(
                EBP_ABOVE,
                &penumPaths
                );

        if (S_OK == hr)
        {
            ULONG               ulCount1, ulCount2;
            INetCfgBindingPath  *pnetcfgPath;

            while( (S_OK == penumPaths->Next(1, &pnetcfgPath, &ulCount1) ) )
            {
                INetCfgComponent        *pnetcfgOwner;

                //
                // Get the owner of this path
                //
                hr = pnetcfgPath->GetOwner( &pnetcfgOwner );

                if (S_OK == hr)
                {
                    INetCfgComponentBindings    *pnetcfgOwnerBindings;

                    hr = pnetcfgOwner->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgOwnerBindings)
                            );

                    if (S_OK == hr)
                    {
                        LPWSTR              lpwstrId;

                        hr = pnetcfgOwner->GetId( &lpwstrId );

                        if (S_OK == hr)
                        {
                            BOOLEAN         bIsBridge;

                            bIsBridge = ( _wcsicmp(lpwstrId, c_wszSBridgeSID) == 0 );

                            if( bIsBridge )
                            {
                                // This is the bridge component. Activate this binding path
                                hr = pnetcfgOwnerBindings->BindTo(pnetcfgcomp);
                            }
                            else
                            {
                                // Check if this is one of the bind exceptions
                                BOOLEAN     bIsException = FALSE;
                                const WCHAR **ppwszException = c_pwszBridgeBindExceptions;

                                while( NULL != *ppwszException )
                                {
                                    bIsException = ( _wcsicmp(lpwstrId, *ppwszException) == 0 );

                                    if( bIsException )
                                    {
                                        break;
                                    }
                                    
                                    ppwszException++;
                                }

                                if( !bIsException )
                                {
                                    hr = pnetcfgOwnerBindings->UnbindFrom(pnetcfgcomp);
                                }
                                // else this is an exception; leave the bind path as-is.
                            }

                            CoTaskMemFree(lpwstrId);
                        }

                        pnetcfgOwnerBindings->Release();
                    }

                    pnetcfgOwner->Release();
                }

                pnetcfgPath->Release();
            }

            penumPaths->Release();
        }

        pnetcfgBindings->Release();
    }

    return hr;
}


HRESULT
GetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN *pfBoolean
    )

/*++

Routine Description:

    Retrieves a boolean property from a Wbem object.

Arguments:

    pwcoInstance - the object to get the property from

    pwszProperty - the property to retrieve

    pfBoolean - received the property value

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pwszProperty);
    _ASSERT(NULL != pfBoolean);

    hr = pwcoInstance->Get(
            pwszProperty,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BOOL == V_VT(&vt) || VT_NULL == V_VT(&vt));

        if (VT_BOOL == V_VT(&vt))
        {
            *pfBoolean = VARIANT_TRUE == V_BOOL(&vt);
        }
        else
        {
            //
            // No value for this member was ever written to the store.
            // Return FALSE, and set that value in the store. We don't
            // pass along the error, if one occurs
            //

            *pfBoolean = FALSE;
            SetBooleanValue(
                pwcoInstance,
                pwszProperty,
                FALSE
                );
        }

        VariantClear(&vt);
    }

    return hr;
}


HRESULT
GetConnectionInstanceByGuid(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection
    )

/*++

Routine Description:

    Retrieves the HNet_Connection instance for a INetConnection guid

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    pGuid - the guid of the INetConnection (i.e., guidId in its properties)

    ppwcoConnection - receives the HNet_Connection instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    LPWSTR wsz;
    BSTR bstrQuery;
    LPOLESTR wszGuid;
    IEnumWbemClassObject *pwcoEnum;

    //
    // Convert the guid to a string
    //

    hr = StringFromCLSID(*pGuid, &wszGuid);

    if (S_OK == hr)
    {
        //
        // Find the connection w/ name equal to that string
        //

        hr = BuildQuotedEqualsString(
                &wsz,
                c_wszGuid,
                wszGuid
                );

        CoTaskMemFree(wszGuid);

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnection,
                    wsz
                    );

            delete [] wsz;
        }

        if (S_OK == hr)
        {
            pwcoEnum = NULL;
            hr = piwsNamespace->ExecQuery(
                    bstrWQL,
                    bstrQuery,
                    WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                    NULL,
                    &pwcoEnum
                    );

            SysFreeString(bstrQuery);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        //
        // Get the instance out of the enum
        //

        *ppwcoConnection = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoConnection,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 != ulCount)
        {
            hr = E_FAIL;
        }

        ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}


HRESULT
GetConnAndPropInstancesByGuid(
    IWbemServices *piwsNamespace,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_Connection and HNet_ConnectionProperties instances
    for a INetConnection guid

Arguments:

    piwsNamespace - WMI namespace

    pGuid - the guid of the INetConnection (i.e., guidId in its properties)

    ppwcoConnection - receives the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR bstrWQL = NULL;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);


    bstrWQL = SysAllocString(c_wszWQL);
    if (NULL != bstrWQL)
    {
        hr = GetConnectionInstanceByGuid(
                piwsNamespace,
                bstrWQL,
                pGuid,
                ppwcoConnection
                );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = GetPropInstanceFromConnInstance(
                piwsNamespace,
                *ppwcoConnection,
                ppwcoProperties
                );

        if (FAILED(hr))
        {
            (*ppwcoConnection)->Release();
            *ppwcoConnection = NULL;
        }
    }

    if (NULL != bstrWQL)
    {
        SysFreeString(bstrWQL);
    }

    return hr;
}


HRESULT
GetConnAndPropInstancesForHNC(
    IWbemServices *piwsNamespace,
    IHNetConnection *pConn,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_Connection and HNet_ConnectionProperties instances
    for an IHNetConnection.

Arguments:

    piwsNamespace - WMI namespace

    pConn - the IHNetConnection

    ppwcoConnection - receives the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    GUID *pGuid;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pConn);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // Find the items by GUID
    //

    hr = pConn->GetGuid(&pGuid);

    if (S_OK == hr)
    {
        hr = GetConnAndPropInstancesByGuid(
                piwsNamespace,
                pGuid,
                ppwcoConnection,
                ppwcoProperties
                );

        CoTaskMemFree(pGuid);
    }

    return hr;
}


HRESULT
GetPhonebookPathFromRasNetcon(
    INetConnection *pConn,
    LPWSTR *ppwstr
    )

/*++

Routine Description:

    Retrieves the phonebook path for an INetConnection that represents
    a RAS connection

Arguments:

    INetConnection - the RAS connection

    ppwstr - receives the phonebook path. The caller must call CoTaskMemFree for
             this pointer on success. On failure, the pointer receives NULL.


Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    INetRasConnection *pRasConn;
    RASCON_INFO RasConInfo;

    _ASSERT(NULL != pConn);
    _ASSERT(NULL != ppwstr);

    *ppwstr = NULL;

    //
    // QI for the INetRasConnection
    //

    hr = pConn->QueryInterface(
            IID_PPV_ARG(INetRasConnection, &pRasConn)
            );

    if (SUCCEEDED(hr))
    {
        //
        // Get the connection information
        //

        hr = pRasConn->GetRasConnectionInfo(&RasConInfo);

        if (SUCCEEDED(hr))
        {
            *ppwstr = RasConInfo.pszwPbkFile;

            //
            // Free the name pointer. The caller is responsible for
            // freeing the path pointer
            //

            CoTaskMemFree(RasConInfo.pszwEntryName);
        }

        pRasConn->Release();
    }

    return hr;
}


HRESULT
GetPortMappingBindingInstance(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    BSTR bstrConnectionPath,
    BSTR bstrProtocolPath,
    USHORT usPublicPort,
    IWbemClassObject **ppInstance
    )

/*++

Routine Description:

    Given the path to an HNet_Connection instance and and
    HNet_PortMappingProtocol instance, checks to see if a
    corresponding HNet_ConnectionPortMapping exists. If it
    doesn't, the instance is created. The HNet_ConnectionPortMapping
    instance -- existing or newly created -- is returned and must
    be released by the caller.

Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing the string "WQL"

    bstrConnectionPath - path to the HNet_Connection instance

    bstrProtocolPath - path to the HNet_PortMappingProtocol instance

    usPublicPort - the port of the port mapping protocol

    ppInstance - receives the HNet_ConnectionPortMapping instance

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    BSTR bstrQuery;
    BSTR bstr;
    LPWSTR wsz;
    LPWSTR wszConClause;
    LPWSTR wszProtClause;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(NULL != bstrConnectionPath);
    _ASSERT(NULL != bstrProtocolPath);
    _ASSERT(NULL != ppInstance);

    //
    // Connection = "bstrConnectionPath" AND Protocol = "bstrProtocolPath"
    //

    hr = BuildEscapedQuotedEqualsString(
            &wszConClause,
            c_wszConnection,
            bstrConnectionPath
            );

    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wszProtClause,
                c_wszProtocol,
                bstrProtocolPath
                );

        if (S_OK == hr)
        {
            hr = BuildAndString(
                    &wsz,
                    wszConClause,
                    wszProtClause
                    );

            delete [] wszProtClause;
        }

        delete [] wszConClause;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wsz
                );

        delete [] wsz;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        *ppInstance = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, ppInstance, &ulCount);

        if (FAILED(hr) || 1 != ulCount)
        {
            //
            // Instance does not exist -- create now. However, first make
            // sure that the protocol instance bstrProtocolPath refers to
            // actually exists.
            //

            hr = GetWmiObjectFromPath(
                    piwsNamespace,
                    bstrProtocolPath,
                    ppInstance
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // The protocol object exists -- release it and
                // continue with creating the new binding object.
                //

                (*ppInstance)->Release();
                *ppInstance = NULL;

                hr = SpawnNewInstance(
                        piwsNamespace,
                        c_wszHnetConnectionPortMapping,
                        ppInstance
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                VARIANT vt;

                //
                // Fill out new instance information
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = bstrConnectionPath;

                hr = (*ppInstance)->Put(
                        c_wszConnection,
                        0,
                        &vt,
                        NULL
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_BSTR(&vt) = bstrProtocolPath;

                    hr = (*ppInstance)->Put(
                            c_wszProtocol,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = SetBooleanValue(
                            *ppInstance,
                            c_wszEnabled,
                            FALSE
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = SetBooleanValue(
                            *ppInstance,
                            c_wszNameActive,
                            FALSE
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = 0;

                    hr = (*ppInstance)->Put(
                            c_wszTargetIPAddress,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_BSTR;
                    V_BSTR(&vt) = SysAllocString(L" ");

                    if (NULL != V_BSTR(&vt))
                    {
                        hr = (*ppInstance)->Put(
                                c_wszTargetName,
                                0,
                                &vt,
                                NULL
                                );

                        VariantClear(&vt);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = usPublicPort;

                    hr = (*ppInstance)->Put(
                            c_wszTargetPort,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    IWbemCallResult *pResult;

                    //
                    // Write new instance to the store
                    //

                    pResult = NULL;
                    hr = piwsNamespace->PutInstance(
                            *ppInstance,
                            WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL,
                            &pResult
                            );

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        //
                        // Release the object, get the path from the result,
                        // and re-retrieve the object from the path
                        //

                        (*ppInstance)->Release();
                        *ppInstance = NULL;

                        hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                        if (WBEM_S_NO_ERROR == hr)
                        {
                            hr = GetWmiObjectFromPath(
                                    piwsNamespace,
                                    bstr,
                                    ppInstance
                                    );

                            SysFreeString(bstr);
                        }

                        pResult->Release();
                    }
                }
            }
        }
        else
        {
            //
            // Normalize enum hresult
            //

            hr = S_OK;
        }

        ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}




HRESULT
GetPropInstanceFromConnInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_ConnectionProperties instance associated with
    an HNet_Connection.

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    pwcoConnection - the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszPath = NULL;
    BSTR bstrPath;
    VARIANT vt;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszConnectionPropertiesPathFormat) == c_cchConnectionPropertiesPathFormat);


    //
    // Get the guid for the connection
    //

    hr = pwcoConnection->Get(
            c_wszGuid,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Determine how much space we need for the path and decide
        // if we need to allocate a heap buffer.
        //

        ULONG cchLength =
            c_cchConnectionPropertiesPathFormat + SysStringLen(V_BSTR(&vt)) + 1;

        if (cchLength <= c_cchQueryBuffer)
        {
            //
            // The buffer is large enough. (Note that since the buffer on the
            // stack is one greater than the constant, the terminator is accounted
            // for.) Point our working pointer to the stack buffer.
            //

            pwszPath = wszBuffer;
        }
        else
        {
            //
            // Allocate a sufficient buffer from the heap. The +1 is for the
            // terminating nul
            //

            pwszPath = new OLECHAR[cchLength + 1];

            if (NULL == pwszPath)
            {
                hr = E_OUTOFMEMORY;
                pwszPath = wszBuffer;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Build the path string
            //

            int iBytes =
                _snwprintf(
                    pwszPath,
                    cchLength,
                    c_wszConnectionPropertiesPathFormat,
                    V_BSTR(&vt)
                    );

            _ASSERT(iBytes >= 0);

            //
            // Convert that to a BSTR
            //

            bstrPath = SysAllocString(pwszPath);
            if (NULL != bstrPath)
            {
                hr = GetWmiObjectFromPath(
                        piwsNamespace,
                        bstrPath,
                        ppwcoProperties
                        );
                
                SysFreeString(bstrPath);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        VariantClear(&vt);
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszPath)
    {
        delete [] pwszPath;
    }

    return hr;
}


HRESULT
GetWmiObjectFromPath(
    IWbemServices *piwsNamespace,
    BSTR bstrPath,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Retrieves the IWbemClassObject corresponding to an object path.

Arguments:

    piwsNamespace - the WMI namespace the object lives in

    bstrPath - the path to the object

    ppwcoInstance - receives the object instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrPath);
    _ASSERT(NULL != ppwcoInstance);

    *ppwcoInstance = NULL;
    hr = piwsNamespace->GetObject(
            bstrPath,
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            ppwcoInstance,
            NULL
            );

    return hr;
}


HRESULT
GetWmiPathFromObject(
    IWbemClassObject *pwcoInstance,
    BSTR *pbstrPath
    )

/*++

Routine Description:

    Retrieves the object path corresponding to an IWbemClassObject instance.

Arguments:

    pwcoInstance - the object instance to retrieve the path of

    pbstrPath - receives the path to the object

Return Value:

    standard HRESULT

--*/
{
    HRESULT hr;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pbstrPath);

    hr = pwcoInstance->Get(
            c_wsz__Path,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        *pbstrPath = V_BSTR(&vt);

        //
        // BSTR ownership transferred to caller
        //
    }

    return hr;
}


HRESULT
HostAddrToIpPsz(
        DWORD   dwAddress,
    LPWSTR* ppszwNewStr
    )

        // Converts IP Address from host by order to string

{
        HRESULT hr = S_OK;
        LPWSTR  pszwStr;

        *ppszwNewStr = NULL;

        pszwStr = reinterpret_cast<LPWSTR>(CoTaskMemAlloc(sizeof(WCHAR) * 16));

        if ( NULL == pszwStr )
        {
                hr = E_OUTOFMEMORY;
        }
        else
        {
                swprintf( pszwStr,
                                  TEXT("%u.%u.%u.%u"),
                                  (dwAddress&0xff),
                                  ((dwAddress>>8)&0x0ff),
                                  ((dwAddress>>16)&0x0ff),
                                  ((dwAddress>>24)&0x0ff) );

                *ppszwNewStr = pszwStr;
        }

        return hr;
}


DWORD
IpPszToHostAddr(
    LPCWSTR cp
    )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}


BOOLEAN
IsRoutingProtocolInstalled(
    ULONG ulProtocolId
    )

/*++

Routine Description:

    This routine is invoked to determine whether the routing protocol
    with the given protocol-ID is installed for Routing and Remote Access.
    This is determined by examining the configuration for the service.

Arguments:

    ulProtocolId - identifies the protocol to be found

Return Value:

    TRUE if the protocol is installed, FALSE otherwise.

--*/

{
    PUCHAR Buffer;
    ULONG BufferLength;
    HINSTANCE Hinstance;
    PMPRCONFIGBUFFERFREE MprConfigBufferFree;
    PMPRCONFIGSERVERCONNECT MprConfigServerConnect;
    PMPRCONFIGSERVERDISCONNECT MprConfigServerDisconnect;
    PMPRCONFIGTRANSPORTGETHANDLE MprConfigTransportGetHandle;
    PMPRCONFIGTRANSPORTGETINFO MprConfigTransportGetInfo;
    PMPRINFOBLOCKFIND MprInfoBlockFind;
    HANDLE ServerHandle;
    HANDLE TransportHandle;

    //
    // Load the MPRAPI.DLL module and retrieve the entrypoints
    // to be used for examining the RRAS configuration.
    //

    if (!(Hinstance = LoadLibraryW(c_wszMprapiDll)) ||
        !(MprConfigBufferFree =
            (PMPRCONFIGBUFFERFREE)
                GetProcAddress(Hinstance, c_szMprConfigBufferFree)) ||
        !(MprConfigServerConnect =
            (PMPRCONFIGSERVERCONNECT)
                GetProcAddress(Hinstance, c_szMprConfigServerConnect)) ||
        !(MprConfigServerDisconnect =
            (PMPRCONFIGSERVERDISCONNECT)
                GetProcAddress(Hinstance, c_szMprConfigServerDisconnect)) ||
        !(MprConfigTransportGetHandle =
            (PMPRCONFIGTRANSPORTGETHANDLE)
                GetProcAddress(Hinstance, c_szMprConfigTransportGetHandle)) ||
        !(MprConfigTransportGetInfo =
            (PMPRCONFIGTRANSPORTGETINFO)
                GetProcAddress(Hinstance, c_szMprConfigTransportGetInfo)) ||
        !(MprInfoBlockFind =
            (PMPRINFOBLOCKFIND)
                GetProcAddress(Hinstance, c_szMprInfoBlockFind))) {
        if (Hinstance) { FreeLibrary(Hinstance); }
        return FALSE;
    }

    //
    // Connect to the RRAS configuration, and retrieve the configuration
    // for the IP transport-layer routing protocols. This should include
    // the configuration for the routing-protocol in 'ProtocolId',
    // if installed.
    //

    ServerHandle = NULL;
    if (MprConfigServerConnect(NULL, &ServerHandle) != NO_ERROR ||
        MprConfigTransportGetHandle(ServerHandle, PID_IP, &TransportHandle)
            != NO_ERROR ||
        MprConfigTransportGetInfo(
            ServerHandle,
            TransportHandle,
            &Buffer,
            &BufferLength,
            NULL,
            NULL,
            NULL
            ) != NO_ERROR) {
        if (ServerHandle) { MprConfigServerDisconnect(ServerHandle); }
        FreeLibrary(Hinstance);
        return FALSE;
    }

    MprConfigServerDisconnect(ServerHandle);

    //
    // Look for the requested protocol's configuration,
    // and return TRUE if it is found; otherwise, return FALSE.
    //

    if (MprInfoBlockFind(Buffer, ulProtocolId, NULL, NULL, NULL) == NO_ERROR) {
        MprConfigBufferFree(Buffer);
        FreeLibrary(Hinstance);
        return TRUE;
    }
    MprConfigBufferFree(Buffer);
    FreeLibrary(Hinstance);
    return FALSE;
} // IsRoutingProtocolInstalled


BOOLEAN
IsServiceRunning(
    LPCWSTR pwszServiceName
    )

/*++

Routine Description:

    Determines if a service is in a running state.

Arguments:

    pwszServiceName - the service to check

Return Value:

    TRUE if the service is in the running or start_pending state,
    FALSE otherwise

--*/

{
    BOOLEAN fServiceRunning = FALSE;
    SC_HANDLE hScm;
    SC_HANDLE hService;
    SERVICE_STATUS Status;

    hScm = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, GENERIC_READ);
    if (NULL != hScm)
    {
        hService = OpenService(hScm, pwszServiceName, GENERIC_READ);
        if (NULL != hService)
        {
            if (QueryServiceStatus(hService, &Status))
            {
                fServiceRunning =
                    (SERVICE_RUNNING == Status.dwCurrentState
                     || SERVICE_START_PENDING == Status.dwCurrentState);
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hScm);
    }

    return fServiceRunning;
} // IsServiceRunning


HRESULT
MapGuidStringToAdapterIndex(
    LPCWSTR pwszGuid,
    ULONG *pulIndex
    )

/*++

Routine Description:

    This routine is called to match the GUID in the given string to
    an adapter in the list returned by calling GetInterfaceInfo.

Arguments:

    pwszGuid - identifies the GUID of the adapter to be found. The GUID string
               must be in the format returned by RtlGuidToUnicodeString

    pulIndex - receives the index of the adapter

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG ulError;
    ULONG i;
    ULONG GuidLength;
    PIP_INTERFACE_INFO Info;
    PWCHAR Name;
    ULONG NameLength;
    ULONG Size;

    _ASSERT(NULL != pwszGuid);
    _ASSERT(NULL != pulIndex);

    Size = 0;
    GuidLength = wcslen(pwszGuid);

    ulError = GetInterfaceInfo(NULL, &Size);
    if (ERROR_INSUFFICIENT_BUFFER == ulError)
    {
        Info = new IP_INTERFACE_INFO[Size];
        if (NULL != Info)
        {
            ulError = GetInterfaceInfo(Info, &Size);
            if (NO_ERROR == ulError)
            {
                for (i = 0; i < (ULONG)Info->NumAdapters; i++)
                {
                    NameLength = wcslen(Info->Adapter[i].Name);
                    if (NameLength < GuidLength) { continue; }

                    Name = Info->Adapter[i].Name + (NameLength - GuidLength);
                    if (_wcsicmp(pwszGuid, Name) == 0)
                    {
                        *pulIndex = Info->Adapter[i].Index;
                        break;
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ulError);
            }

            delete [] Info;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ulError);
    }

    return hr;
}


HRESULT
OpenRegKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    )

/*++

Routine Description:

    This routine is invoked to open a given registry key.

Arguments:

    Key - receives the opened key

    DesiredAccess - specifies the requested access

    Name - specifies the key to be opened

Return Value:

    HRESULT - NT status code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, Name);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    return NtOpenKey(Key, DesiredAccess, &ObjectAttributes);
} // OpenRegKey


BOOLEAN
PortMappingProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usPort,
    UCHAR ucIPProtocol
    )

/*++

Routine Description:

    Checks if an port mapping protocol already exists that has the
    specified protocol and port.


Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing "WQL"

    ucProtocol - the protocol number to check for

    usPort - the port to check for

Return Value:

    BOOLEAN -- TRUE if the port mapping protocol exists; FALSE otherwise

--*/

{
    BSTR bstr;
    BOOLEAN fDuplicate = FALSE;
    HRESULT hr = S_OK;
    int iBytes;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulObjs;
    OLECHAR wszWhereClause[c_cchQueryBuffer + 1];

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(0 == wcscmp(bstrWQL, L"WQL"));

    //
    // Build the query string
    //

    iBytes = _snwprintf(
                wszWhereClause,
                c_cchQueryBuffer,
                c_wszPortMappingProtocolQueryFormat,
                usPort,
                ucIPProtocol
                );

    if (iBytes >= 0)
    {
        //
        // String fit into buffer; make sure it's null terminated
        //

        wszWhereClause[c_cchQueryBuffer] = L'\0';
    }
    else
    {
        //
        // For some reason the string didn't fit into the buffer...
        //

        hr = E_UNEXPECTED;
        _ASSERT(FALSE);
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetPortMappingProtocol,
                wszWhereClause
                );
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve an item from the enum. If we're successful,
        // this is a duplicate protocol.
        //

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulObjs
                );

        if (SUCCEEDED(hr) && 1 == ulObjs)
        {
            //
            // It's a duplicate
            //

            fDuplicate = TRUE;
            pwcoInstance->Release();
        }

        pwcoEnum->Release();
    }

    return fDuplicate;
} // PortMappingProtocolExists


HRESULT
QueryRegValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    )

/*++

Routine Description:

    This routine is called to obtain the value of a registry key.

Arguments:

    Key - the key to be queried

    ValueName - the value to be queried

    Information - receives a pointer to the information read. On success,
                  the caller must HeapFree this pointer

Return Value:

    HRESULT - NT status code.

--*/

{
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    ULONG InformationLength;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString, ValueName);

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    InformationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    //
    // Read the value's size
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        *Information = NULL;
        return status;
    }

    //
    // Allocate space for the value's size
    //

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION) HeapAlloc(
                                                        GetProcessHeap(),
                                                        0,
                                                        InformationLength+2
                                                        );
    if (!*Information) { return STATUS_NO_MEMORY; }

    //
    // Read the value's data
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );
    if (!NT_SUCCESS(status))
    {
        HeapFree(GetProcessHeap(), 0, *Information);
        *Information = NULL;
    }

    return status;

} // QueryRegValueKey

HRESULT
ReadDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    )

{
    _ASSERT(NULL != pdwScopeAddress);
    _ASSERT(NULL != pdwScopeMask);

    //
    // This routine never fails. Set default address/mask
    // (192.168.0.1/255.255.255.255, in network order)
    //

    *pdwScopeAddress = 0x0100a8c0;
    *pdwScopeMask = 0x00ffffff;

    //
    // $$TODO: Check to see if these values are overiddent
    // through a registry entry
    //

    return S_OK;
}


HRESULT
RetrieveSingleInstance(
    IWbemServices *piwsNamespace,
    const OLECHAR *pwszClass,
    BOOLEAN fCreate,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Retrieves a single instance of a class from the WMI store. If there
    are more than one instance, every instance after the first is deleted,
    and an assertion is raised. If there are no instances, one is optionally
    created.

Arguments:

    piwsNamespace - WMI namespace

    pwszClass - the class to retrieve the instance of

    fCreate - create an instance if one does not already exist

    ppwcoInstance - receive the instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum = NULL;
    BSTR bstrClass = NULL;
    ULONG ulCount = 0;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwszClass);
    _ASSERT(NULL != ppwcoInstance);

    //
    // Allocate the BSTR for the class name
    //

    bstrClass = SysAllocString(pwszClass);
    if (NULL == bstrClass)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Query the WMI store for instances of the class
    //

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->CreateInstanceEnum(
            bstrClass,
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pwcoEnum
            );

        SysFreeString(bstrClass);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Attempt to retrieve an actual instance from the enumeration.
        // Even if there are zero instances, WMI considers returning a
        // zero-element enumerator success.
        //

        *ppwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoInstance,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // Normalize return value
            //

            hr = S_OK;

            //
            // Validate that enumeration is now empty
            //

            ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);

        }
        else
        {
            if (WBEM_S_FALSE == hr)
            {
                //
                // No items in enumeration.
                //

                if (fCreate)
                {
                    //
                    // Create a new object instance
                    //

                    hr = SpawnNewInstance(
                            piwsNamespace,
                            pwszClass,
                            ppwcoInstance
                            );
                }
                else
                {
                    //
                    // Change this to an error code. This
                    // is deliberately not a WBEM error code.
                    //

                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND);
                }
            }
        }

        pwcoEnum->Release();
    }

    return hr;
}


HRESULT
SetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN fBoolean
    )

/*++

Routine Description:

    Retrieves a boolean property from a Wbem object.

Arguments:

    pwcoInstance - the object to get the property from

    pwszProperty - the property to retrieve

    pfBoolean - received the property value

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pwszProperty);

    VariantInit(&vt);
    V_VT(&vt) = VT_BOOL;
    V_BOOL(&vt) = (fBoolean ? VARIANT_TRUE : VARIANT_FALSE);

    hr = pwcoInstance->Put(
            pwszProperty,
            0,
            &vt,
            NULL
            );

    return hr;
}


VOID
SetProxyBlanket(
    IUnknown *pUnk
    )

/*++

Routine Description:

    Sets the standard COM security settings on the proxy for an
    object.

Arguments:

    pUnk - the object to set the proxy blanket on

Return Value:

    None. Even if the CoSetProxyBlanket calls fail, pUnk remains
    in a usable state. Failure is expected in certain contexts, such
    as when, for example, we're being called w/in the netman process --
    in this case, we have direct pointers to the netman objects, instead
    of going through a proxy.

--*/

{
    HRESULT hr;

    _ASSERT(pUnk);

    hr = CoSetProxyBlanket(
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE
            );

    if (SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket(
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE
                    );

            pUnkSet->Release();
        }
    }
}


HRESULT
SpawnNewInstance(
    IWbemServices *piwsNamespace,
    LPCWSTR wszClass,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Creates a new instance of a class

Arguments:

    piwsNamespace - the namespace the class is in

    wszClass - the class to create the instance of

    ppwcoInstance -- receives the created instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    BSTR bstr;
    IWbemClassObject *pwcoClass;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != wszClass);
    _ASSERT(NULL != ppwcoInstance);

    *ppwcoInstance = NULL;

    bstr = SysAllocString(wszClass);
    if (NULL != bstr)
    {
        pwcoClass = NULL;
        hr = piwsNamespace->GetObject(
                bstr,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pwcoClass,
                NULL
                );

        SysFreeString(bstr);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoClass->SpawnInstance(0, ppwcoInstance);
        pwcoClass->Release();
    }

    return hr;
}


DWORD
StartOrUpdateService(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to start the SharedAccess service. It will
    also mark the service as auto-start. If the service is already running,
    it will send a IPNATHLP_CONTROL_UPDATE_CONNECTION notification

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;
    ULONG Timeout;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return GetLastError(); }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as auto-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_AUTO_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        // if we are in ICS Upgrade, don't start the SharedAccess service because the
        // service may have problem in starting up during GUI Mode Setup.
        HANDLE hIcsUpgradeEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName);
        if (NULL != hIcsUpgradeEvent)
        {
            CloseHandle(hIcsUpgradeEvent);
            Error = NO_ERROR;
            break;
        }

        //
        // Attempt to start the service
        //

        if (!StartService(ServiceHandle, 0, NULL)) {
            Error = GetLastError();
            if (Error == ERROR_SERVICE_ALREADY_RUNNING)
            {
                //
                // Send control notification
                //

                Error = NO_ERROR;

                if (!ControlService(
                        ServiceHandle,
                        IPNATHLP_CONTROL_UPDATE_CONNECTION,
                        &ServiceStatus
                        ))
                {
                    Error = GetLastError();
                }
            }
            break;
        }

        //
        // Wait for the service to start
        //

        Timeout = 30;
        Error = ERROR_CAN_NOT_COMPLETE;

        do {

            //
            // Query the service's state
            //

            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                Error = GetLastError(); break;
            }

            //
            // See if the service has started
            //

            if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                Error = NO_ERROR; break;
            } else if (ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
                       ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                break;
            }

            //
            // Wait a little longer
            //

            Sleep(1000);

        } while(Timeout--);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

    return Error;
}


VOID
StopService(
    VOID
    )

/*++

Routine Description:

    Stops the SharedAccess service, and marks it as demand start.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return; }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as demand-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_DEMAND_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        //
        // Attempt to stop the service
        //

        ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

}


HRESULT
UpdateOrStopService(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    DWORD dwControlCode
    )

/*++

Routine Description:

    Checks to see if there are any firewalled or ICS connections. If so,
    an update request is sent to the SharedAccess service; if not, the
    service is stopped

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    dwControlCode - the kind of update to send

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);

    //
    // See if we have any connections that are marked as
    // * ICS public
    // * ICS private
    // * firewalled
    //
    // (We don't care about bridged connections, as the SharedAccess service
    // doesn't have anything to do with the bridge.)
    //

    bstrQuery = SysAllocString(c_wszServiceCheckQuery);
    if (NULL != bstrQuery)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;
        IWbemClassObject *pwcoObj;

        //
        // Check to see if the query returned anything
        //

        pwcoObj = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoObj, &ulCount);

        if (SUCCEEDED(hr))
        {
            if (1 == ulCount)
            {
                //
                // Object retrieved -- need to update service
                //

                pwcoObj->Release();
                UpdateService(dwControlCode);
            }
            else
            {
                //
                // No object retrieved -- stop service
                //

                StopService();
            }
        }

        pwcoEnum->Release();
    }

    return hr;
}


VOID
UpdateService(
    DWORD dwControlCode
    )

/*++

Routine Description:

    Sends a control code to the SharedAccess service

Arguments:

    dwControlCode - the code to send

Return Value:

    none.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return; }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Send the control notification
        //

        ControlService(ServiceHandle, dwControlCode, &ServiceStatus);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

}


VOID
ValidateFinishedWCOEnum(
    IWbemServices *piwsNamespace,
    IEnumWbemClassObject *pwcoEnum
    )

/*++

Routine Description:

    Checks to see that a WCO enumerator is finished (i.e., all objects
    have been retrieved). If the enumerator is not finished, any object
    instances that are retrieved will be deleted, and an assertion will
    be raised on checked builds.

Arguments:

    piwsNamespace - the namespace the enumeration is from

    pwcoEnum - the enumeration to validate

Return Value:

    None.

--*/

{

    HRESULT hr;
    IWbemClassObject *pwcoInstance = NULL;
    ULONG ulCount = 0;

    _ASSERT(piwsNamespace);
    _ASSERT(pwcoEnum);

    do
    {
        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
            WBEM_INFINITE,
            1,
            &pwcoInstance,
            &ulCount
            );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // We got an unexpected instance.
            //

            _ASSERT(FALSE);

            //
            // Delete the instance. Don't care about return value.
            //

            DeleteWmiInstance(
                piwsNamespace,
                pwcoInstance
                );

            pwcoInstance->Release();
        }
    }
    while (SUCCEEDED(hr) && 1 == ulCount);
}


HRESULT
SendPortMappingListChangeNotification()

{
    HRESULT hr = S_OK;
    ISharedAccessUpdate* pUpdate = NULL;

    if ( IsServiceRunning(c_wszSharedAccess) )
    {
        hr = CoCreateInstance(
                CLSID_SAUpdate,
                NULL,
                CLSCTX_SERVER,
                IID_PPV_ARG( ISharedAccessUpdate, &pUpdate )
                );

        if ( SUCCEEDED(hr) )
        {
            hr = pUpdate->PortMappingListChanged();

            pUpdate->Release();
        }
    }

    return hr;
}

HRESULT
SignalModifiedConnection(
    GUID                *pGUID
    )
/*++

Routine Description:

    Signals a modification to a network connection (refreshes the UI)

Arguments:

    pGUID               The GUID of the modified connection

Return Value:

    Result of the operation

--*/
{
    HRESULT             hr;
    INetConnection      *pConn;

    hr = FindINetConnectionByGuid( pGUID, &pConn );

    if( SUCCEEDED(hr) )
    {
        INetConnectionRefresh   *pNetConRefresh;

        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
                );

        if( SUCCEEDED(hr) )
        {
            SetProxyBlanket(pNetConRefresh);
            hr = pNetConRefresh->ConnectionModified(pConn);
            pNetConRefresh->Release();
        }

        pConn->Release();
    }

    return hr;
}

HRESULT
SignalNewConnection(
    GUID                *pGUID
    )
/*++

Routine Description:

    Signals that a new network connection has been created (refreshes the UI)

Arguments:

    pGUID               The GUID of the new connection

Return Value:

    Result of the operation

--*/
{
    HRESULT             hr;
    INetConnection      *pConn;

    hr = FindINetConnectionByGuid( pGUID, &pConn );

    if( SUCCEEDED(hr) )
    {
        INetConnectionRefresh   *pNetConRefresh;

        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
                );

        if( SUCCEEDED(hr) )
        {
            SetProxyBlanket(pNetConRefresh);
            hr = pNetConRefresh->ConnectionAdded(pConn);
            pNetConRefresh->Release();
        }

        pConn->Release();
    }

    return hr;
}

HRESULT
SignalDeletedConnection(
    GUID            *pGUID
    )
/*++

Routine Description:

    Signals that a network connection has been deleted (refreshes the UI)

Arguments:

    pGUID               The GUID of the deleted connection

Return Value:

    Result of the operation

--*/
{
    HRESULT                 hr;
    INetConnectionRefresh   *pNetConRefresh;

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
            );

    if( SUCCEEDED(hr) )
    {
        hr = pNetConRefresh->ConnectionDeleted(pGUID);
        pNetConRefresh->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <initguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\sadlg.cpp ===
// Copyright (c) 1998, Microsoft Corporation, all rights reserved
//
// sadlg.c
// Remote Access Common Dialog APIs
// Shared Access Settings property sheet
//
// 10/20/1998 Abolade Gbadegesin
//

//#include "pch.h"
#pragma hdrstop

#include "sautil.h"

#include <winsock2.h>
#include "sainfo.h"
#include "ipnat.h"
#include "fwpages.h"

// extern(s)
// replaced global atom with "HNETCFG_SADLG"

// Loopback address (127.0.0.1) in network and host byte order
//
#define LOOPBACK_ADDR               0x0100007f
#define LOOPBACK_ADDR_HOST_ORDER    0x7f000001

// 'Shared Access Settings' common block
//
typedef struct
_SADLG
{
    HWND hwndOwner;
    HWND hwndDlg;
    HWND hwndSrv;

    HWND hwndServers;

    IHNetCfgMgr *pHNetCfgMgr;
    IHNetConnection *pHNetConn;
    LIST_ENTRY PortMappings;
    BOOL fModified;
    TCHAR *ComputerName;

    IUPnPService * pUPS;    // iff downlevel
}
SADLG;

// Info block for port mapping entries
//
typedef struct
_SAPM
{
    LIST_ENTRY Link;
    IHNetPortMappingProtocol *pProtocol;
    IHNetPortMappingBinding *pBinding;
    BOOL fProtocolModified;
    BOOL fBindingModified;
    BOOL fNewEntry;
    BOOL fDeleted;

    TCHAR *Title;
    BOOL Enabled;
    BOOL BuiltIn;

    UCHAR Protocol;
    USHORT ExternalPort;
    USHORT InternalPort;

    TCHAR *InternalName;

    IStaticPortMapping * pSPM;
}
SAPM;

#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

#define SAPAGE_Servers 0
#define SAPAGE_Applications 1
#define SAPAGE_FirewallLogging 2
#define SAPAGE_ICMPSettings 3
#define SAPAGE_PageCount 4

inline SADLG * SasContext(HWND hwnd)
{
    return (SADLG*)GetProp(GetParent(hwnd), _T("HNETCFG_SADLG"));
}
#define SasErrorDlg(h,o,e,a) \
    ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_SharedAccessSettings,SID_FMT_ErrorMsg)

const TCHAR c_szEmpty[] = TEXT("");

static DWORD g_adwSrvHelp[] =
{
    CID_SS_LV_Services,         HID_SS_LV_Services,
    CID_SS_PB_Add,              HID_SS_PB_Add,
    CID_SS_PB_Edit,             HID_SS_PB_Edit,
    CID_SS_PB_Delete,           HID_SS_PB_Delete,
    0, 0
};

static DWORD g_adwSspHelp[] =
{
    CID_SS_EB_Service,          HID_SS_EB_Service,
    CID_SS_EB_ExternalPort,     -1,
    CID_SS_EB_InternalPort,     HID_SS_EB_Port,
    CID_SS_PB_Tcp,              HID_SS_PB_Tcp,
    CID_SS_PB_Udp,              HID_SS_PB_Udp,
    CID_SS_EB_Address,          HID_SS_EB_Address,
    0, 0
};

// FORWARD DECLARATIONS
//
HRESULT
DeleteRemotePortMappingEntry(
    SADLG *pDlg,
    SAPM * pPortMapping
    );

VOID
FreePortMappingEntry(
    SAPM *pPortMapping );

VOID
FreeSharingAndFirewallSettings(
    SADLG* pDlg );

HRESULT
LoadPortMappingEntry(
    IHNetPortMappingBinding *pBinding,
    SADLG* pDlg,
    SAPM **ppPortMapping );

HRESULT
LoadRemotePortMappingEntry (
    IDispatch * pDisp,
/*  SADLG* pDlg, */
    SAPM **ppPortMapping );

HRESULT
LoadSharingAndFirewallSettings(
    SADLG* pDlg );

VOID
SasApply(
    SADLG* pDlg );

LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem );

INT_PTR CALLBACK
SasSrvDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam );

HRESULT
SavePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping );

BOOL
SharedAccessPortMappingDlg(
    IN HWND hwndOwner,
    IN OUT SAPM** PortMapping );

INT_PTR CALLBACK
SspDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
SrvAddOrEditEntry(
    SADLG* pDlg,
    LONG iItem,
    SAPM* PortMapping );

BOOL
SrvCommand(
    IN SADLG* pDlg,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
SrvConflictDetected(
    SADLG* pDlg,
    SAPM* PortMapping );

BOOL
SrvInit(
    HWND hwndPage,
    SADLG* pDlg );

#define WM_PRIVATE_CANCEL 0x8000

VOID
SrvUpdateButtons(
    SADLG* pDlg,
    BOOL fAddDelete,
    LONG iSetCheckItem );



void DisplayError (HWND hwnd, int idError, int idTitle)
{
    TCHAR* pszError = PszFromId (g_hinstDll, idError);
    if (pszError) {
        TCHAR* pszTitle = PszFromId (g_hinstDll, idTitle);
        if (pszTitle) {
            MessageBox (hwnd,
                        pszError, pszTitle,
                        MB_OK | MB_ICONERROR | MB_APPLMODAL);
            Free (pszTitle);
        }
        Free (pszError);
    }
}

BOOL APIENTRY
HNetSharedAccessSettingsDlg(
    BOOL fSharedAccessMode,
    HWND hwndOwner )

    // Displays the shared access settings property-sheet.
    // On input, 'hwndOwner' indicates the window of the caller,
    // with respect to which we offset the displayed property-sheet.
    //
{
    HRESULT hr;
    IHNetCfgMgr *pHNetCfgMgr;
    BOOL fComInitialized = FALSE;
    BOOL fModified = FALSE;

    TRACE("HNetSharedAccessSettingsDlg");

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (SUCCEEDED(hr))
    {
        fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    //
    // Create the HNetCfgMgr
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_ALL,
                IID_IHNetCfgMgr,
                (VOID**) &pHNetCfgMgr
                );

        if (SUCCEEDED(hr))
        {
            fModified = HNetSharingAndFirewallSettingsDlg(
                            hwndOwner,
                            pHNetCfgMgr,
                            FALSE,
                            NULL
                            );

            pHNetCfgMgr->Release();
        }
    }

    if (TRUE == fComInitialized)
    {
        CoUninitialize();
    }

    return fModified;
}

int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    // A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    //
    // Returns 0 always.
    //
{
    TRACE2( "UnHelpCallbackFunc(m=%d,l=%08x)",unMsg, lparam );

    if (unMsg == PSCB_PRECREATE)
    {
        extern BOOL g_fNoWinHelp;

        // Turn off context help button if WinHelp won't work.  See
        // common\uiutil\ui.c.
        //
        if (g_fNoWinHelp)
        {
            DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
            pDlg->style &= ~(DS_CONTEXTHELP);
        }
    }

    return 0;
}

HRESULT APIENTRY HNetGetSharingServicesPage (IUPnPService * pUPS, PROPSHEETPAGE * psp)
{
//  _asm int 3

    if (!pUPS)  return E_INVALIDARG;
    if (!psp)   return E_INVALIDARG;

    // psp->dwSize muust be filled out by caller!
    if (psp->dwSize == 0)
        return E_INVALIDARG;

    SADLG* pDlg = (SADLG*)Malloc(sizeof(*pDlg));
    if (!pDlg)
        return E_OUTOFMEMORY;

    ZeroMemory(pDlg, sizeof(*pDlg));
    pDlg->hwndOwner = (HWND)psp->lParam;    // double-secret place to hang the owning window
    pDlg->pUPS = pUPS;
    pUPS->AddRef();
    InitializeListHead(&pDlg->PortMappings);

    HRESULT hr = LoadSharingAndFirewallSettings(pDlg);
    if (SUCCEEDED(hr)) {
        // use the size we're given
        DWORD dwSize = psp->dwSize;
        ZeroMemory (psp, dwSize);           // double-secret place gets wiped here
        psp->dwSize      = dwSize;

        psp->hInstance   = g_hinstDll;
        psp->pszTemplate = MAKEINTRESOURCE(PID_SS_SharedAccessServices);
        psp->pfnDlgProc  = SasSrvDlgProc;
        psp->lParam      = (LPARAM)pDlg;
    } else {
        FreeSharingAndFirewallSettings(pDlg);
        Free(pDlg);
    }
    return hr;
}

HRESULT APIENTRY HNetFreeSharingServicesPage (PROPSHEETPAGE * psp)
{   // this must be called if and only if the psp has not been displayed

    // NOTE: these tests are not definitive!!!
    if (IsBadReadPtr ((void*)psp->lParam, sizeof(SADLG)))
        return E_UNEXPECTED;

    SADLG * pDlg = (SADLG *)psp->lParam;
    if (pDlg->pUPS == NULL)
        return E_UNEXPECTED;

    // TODO:  should I walk the heap?

    FreeSharingAndFirewallSettings(pDlg);
    Free(pDlg);

    return S_OK;
}

BOOL
APIENTRY
HNetSharingAndFirewallSettingsDlg(
    IN HWND             hwndOwner,
    IN IHNetCfgMgr      *pHNetCfgMgr,
    IN BOOL             fShowFwOnlySettings,
    IN OPTIONAL IHNetConnection  *pHNetConn )

    // Displays the shared access settings property-sheet.
    // On input, 'hwndOwner' indicates the window of the caller,
    // with respect to which we offset the displayed property-sheet.
    //
{
//  _asm int 3

    DWORD dwErr;
    BOOL fModified = FALSE;
    SADLG* pDlg;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[SAPAGE_PageCount];
    TCHAR* pszCaption;
    CFirewallLoggingDialog FirewallLoggingDialog = {0};
    CICMPSettingsDialog ICMPSettingsDialog = {0};
    HRESULT hr;
    HRESULT hFirewallLoggingResult = E_FAIL;
    HRESULT hICMPSettingsResult = E_FAIL;

    TRACE("HNetSharingAndFirewallSettingsDlg");

    // Allocate and initialize the property-sheet's context block,
    // and read into it the current shared access settings.
    //
    pDlg = (SADLG*)Malloc(sizeof(*pDlg));
    if (!pDlg) { return FALSE; }

    ZeroMemory(pDlg, sizeof(*pDlg));
    pDlg->hwndOwner = hwndOwner;
    pDlg->pHNetCfgMgr = pHNetCfgMgr;
    pDlg->pHNetConn = pHNetConn;
    InitializeListHead(&pDlg->PortMappings);

    hr = LoadSharingAndFirewallSettings(pDlg);
    if (SUCCEEDED(hr))
    {
        // Construct the property sheet.
        // We use a single DlgProc for both our pages, and distinguish the pages
        // by setting the applications page's 'lParam' to contain the shared
        // context-block.
        // (See the 'WM_INITDIALOG' handling in 'SasDlgProc'.)
        //
        int nPages = 0;
        ZeroMemory(psp, sizeof(psp));
        ZeroMemory(&psh, sizeof(psh));

        if(NULL != pHNetConn && fShowFwOnlySettings)
        {
            hFirewallLoggingResult = CFirewallLoggingDialog_Init(&FirewallLoggingDialog, pHNetCfgMgr);
            hICMPSettingsResult = CICMPSettingsDialog_Init(&ICMPSettingsDialog, pHNetConn);
        }

        if(NULL != pHNetConn)
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_SS_SharedAccessServices);
            psp[nPages].pfnDlgProc = SasSrvDlgProc;
            psp[nPages].lParam = (LPARAM)pDlg;
            nPages++;
        }

        if(SUCCEEDED(hFirewallLoggingResult))
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_FW_FirewallLogging);
            psp[nPages].pfnDlgProc = CFirewallLoggingDialog_StaticDlgProc;
            psp[nPages].lParam = (LPARAM)&FirewallLoggingDialog;
            nPages++;
        }

        if(SUCCEEDED(hICMPSettingsResult))
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_FW_ICMP);
            psp[nPages].pfnDlgProc = CICMPSettingsDialog_StaticDlgProc;
            psp[nPages].lParam = (LPARAM)&ICMPSettingsDialog;
            nPages++;
        }

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
        psh.hInstance = g_hinstDll;
        psh.nPages = nPages;
        psh.hwndParent = hwndOwner;
        psh.ppsp = (LPCPROPSHEETPAGE)psp;
        pszCaption = pHNetConn
            ? PszFromId(g_hinstDll, SID_SharedAccessSettings)
            : PszFromId(g_hinstDll, SID_NetworkApplicationSettings);
        psh.pszCaption = (pszCaption ? pszCaption : c_szEmpty);
        psh.pfnCallback = UnHelpCallbackFunc;

        if (PropertySheet(&psh) == -1)
        {
            dwErr = GetLastError();
            TRACE1("SharedAccessSettingsDlg: PropertySheet=%d", dwErr);
            SasErrorDlg(hwndOwner, SID_OP_LoadDlg, dwErr, NULL);
        }
        fModified = pDlg->fModified;
        Free0(pszCaption); // REVIEW is this right

        if(SUCCEEDED(hICMPSettingsResult))
        {
            CICMPSettingsDialog_FinalRelease(&ICMPSettingsDialog);
        }

        if(SUCCEEDED(hFirewallLoggingResult))
        {
            CFirewallLoggingDialog_FinalRelease(&FirewallLoggingDialog);
        }

        FreeSharingAndFirewallSettings(pDlg);
    }
    Free(pDlg);
    return fModified;
}

VOID
FreePortMappingEntry(
    SAPM *pPortMapping )

{
    ASSERT(NULL != pPortMapping);

    if (NULL != pPortMapping->pProtocol)
    {
        pPortMapping->pProtocol->Release();
    }

    if (NULL != pPortMapping->pBinding)
    {
        pPortMapping->pBinding->Release();
    }

    if (pPortMapping->pSPM)
        pPortMapping->pSPM->Release();

    Free0(pPortMapping->Title);
    Free0(pPortMapping->InternalName);

    Free(pPortMapping);
}

VOID
FreeSharingAndFirewallSettings(
    SADLG* pDlg )

    // Frees all sharing and firewall settings
    //

{
    PLIST_ENTRY pLink;
    SAPM *pPortMapping;

    ASSERT(pDlg);

    //
    // Free port-mapping entries
    //

    while (!IsListEmpty(&pDlg->PortMappings))
    {
        pLink = RemoveHeadList(&pDlg->PortMappings);
        pPortMapping = CONTAINING_RECORD(pLink, SAPM, Link);
        ASSERT(pPortMapping);

        FreePortMappingEntry(pPortMapping);
    }

    //
    // Free computer name
    //

    Free0(pDlg->ComputerName);

    if (pDlg->pUPS) {
        pDlg->pUPS->Release();
        pDlg->pUPS = NULL;
    }
}

#define NAT_API_ENTER
#define NAT_API_LEAVE
#include "natutils.h"
#include "sprtmapc.h"
HRESULT GetCollectionFromService (IUPnPService * pUPS, IStaticPortMappingCollection ** ppSPMC)
{
    CComObject<CStaticPortMappingCollection> * pC = NULL;
    HRESULT hr = CComObject<CStaticPortMappingCollection>::CreateInstance (&pC);
    if (pC) {
        pC->AddRef();
        // init
        hr = pC->Initialize (pUPS);
        if (SUCCEEDED(hr))
            hr = pC->QueryInterface (__uuidof(IStaticPortMappingCollection), (void**)ppSPMC);
        pC->Release();
    }
    return hr;
}

HRESULT GetStaticPortMappingCollection (
    SADLG* pDlg,
    IStaticPortMappingCollection ** ppSPMC)
{
    _ASSERT (pDlg);
    _ASSERT (pDlg->pUPS);
    _ASSERT (ppSPMC);

    *ppSPMC = NULL;

    return GetCollectionFromService (pDlg->pUPS, ppSPMC);
}

HRESULT
LoadRemotePortMappingEntry (IDispatch * pDisp, /* SADLG* pDlg, */ SAPM **ppPortMapping )
{   // NOTE: may need pDlg to get computer name if loopback

    *ppPortMapping = NULL;

    SAPM *pMapping  = (SAPM*)Malloc(sizeof(*pMapping));
    if (!pMapping)
        return E_OUTOFMEMORY;

    ZeroMemory(pMapping, sizeof(*pMapping));
    InitializeListHead(&pMapping->Link);

    HRESULT hr = pDisp->QueryInterface (__uuidof(IStaticPortMapping),
                                        (void**)&pMapping->pSPM);
    if (SUCCEEDED(hr)) {
        // get title (description)
        CComBSTR cbDescription;
        hr = pMapping->pSPM->get_Description (&cbDescription);
        if (SUCCEEDED(hr)) {
            // immediately figure out if it's "built-in"
            #define BUILTIN_KEY L" [MICROSOFT]"
            OLECHAR * tmp = wcsstr (cbDescription.m_str, BUILTIN_KEY);
            if (tmp && (tmp[wcslen(BUILTIN_KEY)] == 0)) {
                // if the key exists and is at the end, then it's a built-in mapping
                pMapping->BuiltIn = TRUE;
                *tmp = 0;
            }

            pMapping->Title = StrDupTFromW (cbDescription);
            if (NULL == pMapping->Title)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr)) {
            // get protocol
            CComBSTR cbProtocol;
            hr = pMapping->pSPM->get_Protocol (&cbProtocol);
            if (SUCCEEDED(hr)) {
                if (!_wcsicmp (L"tcp", cbProtocol))
                    pMapping->Protocol = NAT_PROTOCOL_TCP;
                else
                if (!_wcsicmp (L"udp", cbProtocol))
                    pMapping->Protocol = NAT_PROTOCOL_UDP;
                else {
                    _ASSERT (0 && "bad protocol!?");
                    hr = E_UNEXPECTED;
                }

                if (SUCCEEDED(hr)) {
                    // get external port
                    long lExternalPort = 0;
                    hr = pMapping->pSPM->get_ExternalPort (&lExternalPort);
                    if (SUCCEEDED(hr)) {
                        _ASSERT (lExternalPort > 0);
                        _ASSERT (lExternalPort < 65536);
                        pMapping->ExternalPort = ntohs ((USHORT)lExternalPort);

                        // get internal port
                        long lInternalPort = 0;
                        hr = pMapping->pSPM->get_InternalPort (&lInternalPort);
                        if (SUCCEEDED(hr)) {
                            _ASSERT (lInternalPort > 0);
                            _ASSERT (lInternalPort < 65536);
                            pMapping->InternalPort = ntohs ((USHORT)lInternalPort);

                            // get Enabled
                            VARIANT_BOOL vb;
                            hr = pMapping->pSPM->get_Enabled (&vb);
                            if (SUCCEEDED(hr)) {
                                pMapping->Enabled = vb == VARIANT_TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr)) {
        // lastly, get private IP or host name (hard one)
        // TODO:  check for loopback, etc., like in LoadPortMappingEntry code below
        CComBSTR cbInternalClient;
        hr = pMapping->pSPM->get_InternalClient (&cbInternalClient);
        if (SUCCEEDED(hr)) {
            if (!(cbInternalClient == L"0.0.0.0")) {
                pMapping->InternalName = StrDupTFromW (cbInternalClient);
                if (!pMapping->InternalName)
                    hr = E_OUTOFMEMORY;
            }
        }
    }

    if (SUCCEEDED(hr))
        *ppPortMapping = pMapping;
    else
        FreePortMappingEntry (pMapping);

    return hr;
}

HRESULT
LoadPortMappingEntry(
    IHNetPortMappingBinding *pBinding,
    SADLG* pDlg,
    SAPM **ppPortMapping )

{
    HRESULT hr = S_OK;
    IHNetPortMappingProtocol *pProtocol = NULL;
    SAPM *pMapping;
    BOOLEAN fTemp;
    OLECHAR *pwsz;

    ASSERT(NULL != pBinding);
    ASSERT(NULL != ppPortMapping);

    pMapping = (SAPM*) Malloc(sizeof(*pMapping));

    if (NULL != pMapping)
    {
        ZeroMemory(pMapping, sizeof(*pMapping));
        InitializeListHead(&pMapping->Link);

        hr = pBinding->GetProtocol (&pProtocol);

        if (SUCCEEDED(hr))
        {
            hr = pProtocol->GetName (&pwsz);

            if (SUCCEEDED(hr))
            {
                pMapping->Title = StrDupTFromW(pwsz);
                if (NULL == pMapping->Title)
                {
                    hr = E_OUTOFMEMORY;
                }
                CoTaskMemFree(pwsz);
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocol->GetBuiltIn (&fTemp);
            }

            if (SUCCEEDED(hr))
            {
                pMapping->BuiltIn = !!fTemp;

                hr = pProtocol->GetIPProtocol (&pMapping->Protocol);
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocol->GetPort (&pMapping->ExternalPort);
            }

            pMapping->pProtocol = pProtocol;
            pMapping->pProtocol->AddRef();
            pProtocol->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pBinding->GetTargetPort (&pMapping->InternalPort);
    }

    if (SUCCEEDED(hr))
    {
        hr = pBinding->GetEnabled (&fTemp);
    }

    if (SUCCEEDED(hr))
    {
        pMapping->Enabled = !!fTemp;

        hr = pBinding->GetCurrentMethod (&fTemp);
    }

    if (SUCCEEDED(hr))
    {
        if (fTemp)
        {
            hr = pBinding->GetTargetComputerName (&pwsz);

            if (SUCCEEDED(hr))
            {
                pMapping->InternalName = StrDupTFromW(pwsz);
                if (NULL == pMapping->InternalName)
                {
                    hr = E_OUTOFMEMORY;
                }
                CoTaskMemFree(pwsz);
            }
        }
        else
        {
            ULONG ulAddress;

            hr = pBinding->GetTargetComputerAddress (&ulAddress);

            if (SUCCEEDED(hr))
            {
                if (LOOPBACK_ADDR == ulAddress)
                {
                    //
                    // The mapping is directed at this machine, so
                    // replace the loopback address with our
                    // machine name
                    //

                    pMapping->InternalName = _StrDup(pDlg->ComputerName);
                    if (NULL == pMapping->InternalName)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else if (0 != ulAddress)
                {
                    pMapping->InternalName =
                        (LPTSTR) Malloc(16 * sizeof(TCHAR));

                    if (NULL != pMapping->InternalName)
                    {
                        IpHostAddrToPsz(
                            NTOHL(ulAddress),
                            pMapping->InternalName
                            );
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        pMapping->pBinding = pBinding;
        pMapping->pBinding->AddRef();
        *ppPortMapping = pMapping;
    }
    else if (NULL != pMapping)
    {
        FreePortMappingEntry(pMapping);
    }

    return hr;
}

class CWaitDialog
{
public:
    struct SWaitDialog
    {
        HWND hwndOwner;
    private:
        CComAutoCriticalSection m_acs;
        HWND m_hwndDlg;
    public:
        SWaitDialog (HWND hwnd)
        {
            hwndOwner = hwnd;
            m_hwndDlg = NULL;
        }
        void SetWindow (HWND hwnd)
        {
            m_acs.Lock();
            if (m_hwndDlg == NULL)
                m_hwndDlg = hwnd;
            m_acs.Unlock();
        }
        HWND GetWindow () { return m_hwndDlg; }
    };
private:
    SWaitDialog * m_pwd;
public:
    CWaitDialog (HWND hwndOwner)
    {
        m_pwd = new SWaitDialog (hwndOwner);
        if (m_pwd) {
            // create thread
            DWORD ThreadId = NULL;
            CloseHandle (CreateThread (NULL, 0,
                                       CWaitDialog::ThreadProc,
                                       (void*)m_pwd,
                                       0, &ThreadId));
        }
    }
   ~CWaitDialog ()
    {
        if (m_pwd) {
            HWND hwnd = m_pwd->GetWindow();
            m_pwd->SetWindow ((HWND)INVALID_HANDLE_VALUE);
            if (hwnd != NULL)
                EndDialog (hwnd, 1);
        }
    }
    static DWORD WINAPI ThreadProc (VOID *pVoid)
    {
        SWaitDialog * pWD = (SWaitDialog *)pVoid;
        EnableWindow (pWD->hwndOwner, FALSE);
        DialogBoxParam (g_hinstDll,
                        MAKEINTRESOURCE(PID_SS_PleaseWait),
                        pWD->hwndOwner,
                        CWaitDialog::DlgProc,
                        (LPARAM)pWD);
        EnableWindow (pWD->hwndOwner, TRUE);
        delete pWD;
        return 1;
    }
    static INT_PTR CALLBACK DlgProc (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
    {
        switch (uMsg) {
        case WM_INITDIALOG:
        {
            // hang onto my data
            SWaitDialog * pWD = (SWaitDialog *)lparam;
            SetWindowLongPtr (hwnd, DWLP_USER, (LONG_PTR)pWD);

            // center window on owner
            CenterWindow (hwnd, pWD->hwndOwner);

            // fill out dlg's hwnd
            pWD->SetWindow (hwnd);
            if (pWD->GetWindow() == INVALID_HANDLE_VALUE)   // already destructed!
                PostMessage (hwnd, 0x8000, 0, 0L);
            return TRUE;
        }
        case WM_PAINT:
        {
            SWaitDialog * pWD = (SWaitDialog *)GetWindowLongPtr (hwnd, DWLP_USER);
            if (pWD->GetWindow() == INVALID_HANDLE_VALUE)   // already destructed!
                PostMessage (hwnd, 0x8000, 0, 0L);
            break;
        }
        case 0x8000:
            EndDialog (hwnd, 1);
            return TRUE;
        }
        return FALSE;
    }
};

HRESULT
LoadSharingAndFirewallSettings(
    SADLG* pDlg )

{
    CWaitDialog wd(pDlg->hwndOwner);    // may be NULL

    HRESULT hr = S_OK;
    IHNetProtocolSettings *pProtSettings;
    ULONG ulCount;
    DWORD dwError;

    ASSERT(pDlg);

    //
    // Load the name of the computer
    //

#ifndef DOWNLEVEL_CLIENT    // downlevel client doesn't have this call
    ulCount = 0;
    if (!GetComputerNameEx(ComputerNameDnsHostname, NULL, &ulCount))
    {
        dwError = GetLastError();

        if (ERROR_MORE_DATA == dwError)
        {
            pDlg->ComputerName = (TCHAR*) Malloc(ulCount * sizeof(TCHAR));
            if (NULL != pDlg->ComputerName)
            {
                if (!GetComputerNameEx(
                        ComputerNameDnsHostname,
                        pDlg->ComputerName,
                        &ulCount
                        ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    else
    {
        //
        // Since we didn't pass in a buffer, this should never happen.
        //

        ASSERT(FALSE);
        hr = E_UNEXPECTED;
    }
    if (FAILED(hr))
        return hr;
#else
    // downlevel client version
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize       = MAX_COMPUTERNAME_LENGTH+1;
    if (!GetComputerName (szComputerName, &dwSize))
        hr = HRESULT_FROM_WIN32(GetLastError());
    else {
        pDlg->ComputerName = _StrDup (szComputerName);
        if (!pDlg->ComputerName)
            hr = E_OUTOFMEMORY;
    }
#endif

    // do downlevel and remote case here
    if (pDlg->pUPS) {
        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetCollectionFromService (pDlg->pUPS, &spSPMC);
        if (spSPMC) {
            CComPtr<IEnumVARIANT> spEV = NULL;

            CComPtr<IUnknown> spunk = NULL;
            hr = spSPMC->get__NewEnum (&spunk);
            if (spunk)
                hr = spunk->QueryInterface (
                            __uuidof(IEnumVARIANT),
                            (void**)&spEV);
            if (spEV) {
                CComVariant cv;
                while (S_OK == spEV->Next (1, &cv, NULL)) {
                    if (V_VT (&cv) == VT_DISPATCH) {
                        SAPM *pSAPortMap = NULL;
                        hr = LoadRemotePortMappingEntry (V_DISPATCH (&cv), /* pDlg, */ &pSAPortMap);
                        if (SUCCEEDED(hr))
                            InsertTailList(&pDlg->PortMappings, &pSAPortMap->Link);
                    }
                    cv.Clear();
                }
            }
        }
    }

    // do stuff below iff not remote
    if (NULL != pDlg->pHNetConn)
    {
        IEnumHNetPortMappingBindings *pEnumBindings = NULL;

        //
        // Load port-mapping settings
        //

        hr = pDlg->pHNetConn->EnumPortMappings (FALSE, &pEnumBindings);

        if (SUCCEEDED(hr))
        {
            IHNetPortMappingBinding *pBinding;

            do
            {
                hr = pEnumBindings->Next (1, &pBinding, &ulCount);

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    SAPM *pSAPortMap;

                    hr = LoadPortMappingEntry(pBinding, pDlg, &pSAPortMap);

                    if (SUCCEEDED(hr))
                    {
                        InsertTailList(&pDlg->PortMappings, &pSAPortMap->Link);
                    }
                    else
                    {
                        //
                        // Even though an error occured for this entry we'll
                        // keep on going -- this allows the UI to show up.
                        //
                        
                        hr = S_OK;
                    }

                    pBinding->Release();
                }

            } while (SUCCEEDED(hr) && 1 == ulCount);

            pEnumBindings->Release();
        }
    }
    return hr;
}

extern BOOL IsICSHost (); // in upnpnat.cpp
VOID
SasApply(
    SADLG* pDlg )

    // Called to save all changes made in the property sheet.
    //
{
    if (!pDlg->fModified)
    {
        return;
    }

    if (pDlg->hwndServers)
    {
        SAPM* pPortMapping;
#if DBG
        LONG i = -1;
        while ((i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_ALL))
                >= 0)
        {
            pPortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
            ASSERT(pPortMapping->Enabled == ListView_GetCheck(pDlg->hwndServers, i));
        }
#endif

        //
        // Commit modified port-mapping entries. Since entries marked
        // for deletion were placed at the front of the port-mapping
        // list there's no chance of having a new or modified entry
        // conflicting with a deleted entry.
        //

        HRESULT hr = S_OK;

        PLIST_ENTRY Link;
        for (Link = pDlg->PortMappings.Flink;
             Link != &pDlg->PortMappings; Link = Link->Flink)
        {
            pPortMapping = CONTAINING_RECORD(Link, SAPM, Link);

            if (pPortMapping->fDeleted)
            {
                Link = Link->Blink;
                RemoveEntryList(&pPortMapping->Link);

                if(NULL != pPortMapping->pProtocol)
                {
                    pPortMapping->pProtocol->Delete();
                }
                else if (pPortMapping->pSPM)
                {
                    HRESULT hr = DeleteRemotePortMappingEntry (pDlg, pPortMapping);
                    if (FAILED(hr)) {
                        // TODO: should I pop up some UI?
                    }
                }

                FreePortMappingEntry(pPortMapping);
            }
            else if (pPortMapping->fProtocolModified
                     || pPortMapping->fBindingModified
                     || pPortMapping->fNewEntry)
            {
                HRESULT hr2 = SavePortMappingEntry(pDlg, pPortMapping);
                if (SUCCEEDED(hr2))
                {
                    pPortMapping->fProtocolModified = FALSE;
                    pPortMapping->fBindingModified = FALSE;
                    pPortMapping->fNewEntry = FALSE;
                } else {
                    if (SUCCEEDED(hr))
                        hr = hr2;   // grab first error
                }
            }
        }
        if (FAILED(hr)) {
            if (pDlg->pUPS && !IsICSHost ())
                DisplayError (pDlg->hwndDlg,
                              SID_OP_TheirGatewayError,
                              SID_PopupTitle);
            else
                DisplayError (pDlg->hwndDlg,
                              SID_OP_GenericPortMappingError,
                              SID_PopupTitle);
        }
    }
}

INT_PTR CALLBACK
SasSrvDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'Services' pages.
    //
{
    // Give the extended list-control a chance to look at all messages first.
    //
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, SasLvxCallback))
    {
        return TRUE;
    }
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            SADLG* pDlg = (SADLG*)((PROPSHEETPAGE*)lparam)->lParam;
            return SrvInit(hwnd, pDlg);
        }
        case WM_PRIVATE_CANCEL:
        {
            SADLG* pDlg = SasContext(hwnd);
            PostMessage (pDlg->hwndDlg, PSM_PRESSBUTTON, PSBTN_CANCEL, 0L);
            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            SADLG* pDlg = SasContext(hwnd);
            ContextHelp(g_adwSrvHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            SADLG* pDlg = SasContext(hwnd);
                return SrvCommand(
                    pDlg, HIWORD(wparam), LOWORD(wparam), (HWND)lparam);
        }

        case WM_NOTIFY:
        {
            SADLG* pDlg = SasContext(hwnd);
            switch (((NMHDR*)lparam)->code)
            {
                case PSN_APPLY:
                {
                    SasApply(pDlg);
                    return TRUE;
                }

                case NM_DBLCLK:
                {
                    SendMessage(
                        GetDlgItem(hwnd, CID_SS_PB_Edit), BM_CLICK, 0, 0);
                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    pDlg->fModified = TRUE;
                    SrvUpdateButtons(
                        pDlg, FALSE, ((NM_LISTVIEW*)lparam)->iItem);
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    if ((((NM_LISTVIEW*)lparam)->uNewState & LVIS_SELECTED)
                        != (((NM_LISTVIEW*)lparam)->uOldState & LVIS_SELECTED))
                    {
                        SrvUpdateButtons(
                            pDlg, FALSE, ((NM_LISTVIEW*)lparam)->iItem);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
SasInit(
    HWND hwndPage,
    SADLG* pDlg )

    // Called to initialize the settings property sheet.
    // Sets the window-property in which the shared context-block is stored,
    // and records the dialog's window-handle.
    //
{
    HWND hwndDlg = GetParent(hwndPage);
    if (!SetProp(hwndDlg, _T("HNETCFG_SADLG"), pDlg))
    {
        return FALSE;
    }
    pDlg->hwndDlg = hwndDlg;
    return TRUE;
}

LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem )

    // Callback for extended list-controls on the 'Applications' and 'Services'
    // pages.
    //
{
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { LVXDIA_Static } };
    return &info;
}

HRESULT DeleteRemotePortMappingEntry (SADLG *pDlg, SAPM * pPortMapping)
{
    _ASSERT (pPortMapping);
    _ASSERT (!pPortMapping->pProtocol);
    _ASSERT (!pPortMapping->pBinding);
    _ASSERT (pPortMapping->pSPM);

    // don't use value in pPortMapping struct:  they could have been edited.
    long lExternalPort = 0;
    HRESULT hr = pPortMapping->pSPM->get_ExternalPort (&lExternalPort);
    if (SUCCEEDED(hr)) {
        CComBSTR cbProtocol;
        hr = pPortMapping->pSPM->get_Protocol (&cbProtocol);
        if (SUCCEEDED(hr)) {

            // get IStaticPortMappings interface (collection has Remove method)
            CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
            hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
            if (spSPMC)
                hr = spSPMC->Remove (lExternalPort, cbProtocol);
        }
    }
    return hr;
}

HRESULT
SaveRemotePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping )
{
    _ASSERT (pPortMapping);
    _ASSERT (!pPortMapping->pProtocol);
    _ASSERT (!pPortMapping->pBinding);
    _ASSERT (pDlg->pUPS);  // either remote or downlevel

    USES_CONVERSION;

    HRESULT hr = S_OK;

    // common params
    long lExternalPort = htons (pPortMapping->ExternalPort);
    long lInternalPort = htons (pPortMapping->InternalPort);
    CComBSTR cbClientIPorDNS = T2OLE(pPortMapping->InternalName);
    CComBSTR cbDescription   = T2OLE(pPortMapping->Title);
    CComBSTR cbProtocol;
    if (pPortMapping->Protocol == NAT_PROTOCOL_TCP)
        cbProtocol =  L"TCP";
    else
        cbProtocol =  L"UDP";

    if (NULL == pPortMapping->pSPM) {
        // brand-new entry:
        // delete dup if any
        // add new entry

        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
        if (spSPMC) {
            spSPMC->Remove (lExternalPort, cbProtocol); // just in case
            hr = spSPMC->Add (lExternalPort,
                              cbProtocol,
                              lInternalPort,
                              cbClientIPorDNS,
                              pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE,
                              cbDescription,
                              &pPortMapping->pSPM);
        }
        return hr;
    }

    // edited case:  check what changed.

    // if ports or protocol changed,...
    long lOldExternalPort = 0;
    pPortMapping->pSPM->get_ExternalPort (&lOldExternalPort);
    CComBSTR cbOldProtocol;
    pPortMapping->pSPM->get_Protocol (&cbOldProtocol);
    if ((lOldExternalPort != lExternalPort) ||
        (!(cbOldProtocol == cbProtocol))) {
        // ... delete old entry and create new entry

        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
        if (spSPMC)
            hr = spSPMC->Remove (lOldExternalPort, cbOldProtocol);

        if (SUCCEEDED(hr)) {
            pPortMapping->pSPM->Release();
            pPortMapping->pSPM = NULL;

            hr = spSPMC->Add (lExternalPort,
                              cbProtocol,
                              lInternalPort,
                              cbClientIPorDNS,
                              pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE,
                              cbDescription,
                              &pPortMapping->pSPM);
        }
        return hr;
    }
    // else, just edit in place.
    // Note that the client address must be filled out before trying to enable

    // did the client IP address change?
    CComBSTR cbOldClientIP;
    pPortMapping->pSPM->get_InternalClient (&cbOldClientIP);
    if (!(cbClientIPorDNS == cbOldClientIP)) {
        hr = pPortMapping->pSPM->EditInternalClient (cbClientIPorDNS);
        if (FAILED(hr))
            return hr;
    }

    // did the internal port change?
    long lOldInternalPort = 0;
    pPortMapping->pSPM->get_InternalPort (&lOldInternalPort);
    if (lOldInternalPort != lInternalPort) {
        hr = pPortMapping->pSPM->EditInternalPort (lInternalPort);
        if (FAILED(hr))
            return hr;
    }

    // did the enabled flag change?
    VARIANT_BOOL vbEnabled = FALSE;
    pPortMapping->pSPM->get_Enabled (&vbEnabled);
    if (vbEnabled != (pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE)) {
        hr = pPortMapping->pSPM->Enable (pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE);
    }
    return hr;
}

HRESULT
SavePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping )

{
    if (pDlg->pUPS)  // remote case
        return SaveRemotePortMappingEntry (pDlg, pPortMapping);

    HRESULT hr = S_OK;
    OLECHAR *wszTitle;

    ASSERT(NULL != pDlg);
    ASSERT(NULL != pPortMapping);

    wszTitle = StrDupWFromT(pPortMapping->Title);
    if (NULL == wszTitle)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (pPortMapping->fNewEntry)
    {
        IHNetProtocolSettings *pSettings;

        ASSERT(NULL == pPortMapping->pProtocol);
        ASSERT(NULL == pPortMapping->pBinding);

        hr = pDlg->pHNetCfgMgr->QueryInterface (IID_IHNetProtocolSettings,
                                                (void**)&pSettings);

        if (SUCCEEDED(hr))
        {
            hr = pSettings->CreatePortMappingProtocol(
                    wszTitle,
                    pPortMapping->Protocol,
                    pPortMapping->ExternalPort,
                    &pPortMapping->pProtocol
                    );

            pSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = pDlg->pHNetConn->GetBindingForPortMappingProtocol(
                    pPortMapping->pProtocol,
                    &pPortMapping->pBinding
                    );

            if (SUCCEEDED(hr))
            {
                //
                // At this point, the protocol is set. However, we
                // still need to save the binding information
                //

                pPortMapping->fProtocolModified = FALSE;
                pPortMapping->fBindingModified = TRUE;
            }
        }
    }

    if (SUCCEEDED(hr) && pPortMapping->fProtocolModified)
    {
        hr = pPortMapping->pProtocol->SetName (wszTitle);

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pProtocol->SetIPProtocol (
                                                    pPortMapping->Protocol);
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pProtocol->SetPort (pPortMapping->ExternalPort);
        }
    }

    if (SUCCEEDED(hr)
        && pPortMapping->fBindingModified
        && NULL != pPortMapping->InternalName)
    {
        ULONG ulAddress = INADDR_NONE;

        if (lstrlen(pPortMapping->InternalName) >= 7)
        {
            //
            // 1.2.3.4 -- minimum of 7 characters
            //

            ulAddress = IpPszToHostAddr(pPortMapping->InternalName);
        }

        if (INADDR_NONE == ulAddress)
        {
            //
            // Check to see if the target name is either
            // 1) this computer's name, or
            // 2) "localhost"
            //
            // If so, use the loopback address instead of the name.
            //

            if (0 == _tcsicmp(pPortMapping->InternalName, pDlg->ComputerName)
                || 0 == _tcsicmp(pPortMapping->InternalName, _T("localhost")))
            {
                ulAddress = LOOPBACK_ADDR_HOST_ORDER;
            }
        }

        //
        // We can't just check for INADDR_NONE here, since that
        // is 0xFFFFFFFF, which is 255.255.255.255. To catch this
        // we need to compare the name against that explicit string
        // address.
        //

        if (INADDR_NONE == ulAddress
            && 0 != _tcsicmp(pPortMapping->InternalName, _T("255.255.255.255")))
        {
            OLECHAR *wsz;

            wsz = StrDupWFromT(pPortMapping->InternalName);
            if (NULL != wsz)
            {
                hr = pPortMapping->pBinding->SetTargetComputerName (wsz);

                Free(wsz);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = pPortMapping->pBinding->SetTargetComputerAddress
                        (HTONL(ulAddress));
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pBinding->SetEnabled (!!pPortMapping->Enabled);
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pBinding->SetTargetPort (pPortMapping->InternalPort);
        }
    }

    Free0(wszTitle);

    return hr;
}

VOID
SrvAddOrEditEntry(
    SADLG* pDlg,
    LONG iItem,
    SAPM* PortMapping )

    // Called to display the 'Add' or 'Edit' dialog for a service.
    //
{
    LV_ITEM lvi;

    // Display the dialog, and return if the user cancels.
    // Otherwise, remove the old item (if any) and insert the added or edited
    // item.
    //

    if (!SharedAccessPortMappingDlg(pDlg->hwndDlg, &PortMapping))
    {
        return;
    }

    if (iItem != -1)
    {
        ListView_DeleteItem(pDlg->hwndServers, iItem);
    }

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.lParam = (LPARAM)PortMapping;
    lvi.pszText = PortMapping->Title;
    lvi.cchTextMax = lstrlen(PortMapping->Title) + 1;
    lvi.iItem = 0;

    iItem = ListView_InsertItem(pDlg->hwndServers, &lvi);
    if (iItem == -1)
    {
        RemoveEntryList(&PortMapping->Link);
        if (NULL != PortMapping->pProtocol)
        {
            PortMapping->pProtocol->Delete();
        }
        else if (NULL != PortMapping->pSPM)
        {
            DeleteRemotePortMappingEntry (pDlg, PortMapping);
        }
        FreePortMappingEntry(PortMapping);
        return;
    }

    // Update the item's 'enabled' state. Setting the check on the item
    // triggers an update of the button state as well as conflict detection.
    // (See 'SrvUpdateButtons' and the LVXN_SETCHECK handling in 'SasDlgProc').
    //
    ListView_SetCheck(pDlg->hwndServers, iItem, PortMapping->Enabled);
    ListView_SetItemState(
        pDlg->hwndServers, iItem, LVIS_SELECTED, LVIS_SELECTED);
    pDlg->fModified = TRUE;
}

BOOL
SrvCommand(
    IN SADLG* pDlg,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called to process a 'WM_COMMAND' message from one of the page's buttons.
    //
{
    switch (wId)
    {
        case CID_SS_PB_Add:
        {
            SrvAddOrEditEntry(pDlg, -1, NULL);
            return TRUE;
        }

        case CID_SS_PB_Edit:
        {
            LONG i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
            SAPM* PortMapping;
            if (i == -1)
            {
                MsgDlg(pDlg->hwndDlg, SID_NoModifySelection, NULL);
                SetFocus(pDlg->hwndServers);
                return FALSE;
            }
            PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
            if (PortMapping)
            {
                SrvAddOrEditEntry(pDlg, i, PortMapping);
            }
            SetFocus(pDlg->hwndServers);
            return TRUE;
        }

        case CID_SS_PB_Delete:
        {
            LONG i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
            SAPM* PortMapping;
            if (i == -1)
            {
                MsgDlg(pDlg->hwndDlg, SID_NoDeleteSelection, NULL);
                SetFocus(pDlg->hwndServers);
                return FALSE;
            }

            // Delete each selected item. Items with marked 'built-in'
            // cannot be deleted, and are ignored.
            //
            do {
                PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);

                if(NULL == PortMapping)
                {
                    break;
                }

                if (PortMapping->BuiltIn)
                {
                    ++i;
                }
                else
                {
                    ListView_DeleteItem(pDlg->hwndServers, i);
                    --i;

                    //
                    // If this is a new entry we can immediately remove
                    // it from the list and free it; otherwise, we move
                    // it to the front of the list and mark it for
                    // deletion.
                    //

                    RemoveEntryList(&PortMapping->Link);
                    if (PortMapping->fNewEntry)
                    {
                        _ASSERT(NULL == PortMapping->pProtocol);
                        _ASSERT(NULL == PortMapping->pSPM);

                        FreePortMappingEntry(PortMapping);
                    }
                    else
                    {
                        InsertHeadList(&pDlg->PortMappings, &PortMapping->Link);
                        PortMapping->fDeleted = TRUE;
                    }
                }
                i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_SELECTED);
            } while (i != -1);

            // Update the dialog and synchronize the button-states with the
            // current selection, if any.
            //
            pDlg->fModified = TRUE;
            SetFocus(pDlg->hwndServers);
            SrvUpdateButtons(pDlg, TRUE, -1);
            return TRUE;
        }
    }
    return TRUE;
}

BOOL
SrvConflictDetected(
    SADLG* pDlg,
    SAPM* PortMapping )

    // Called to determine whether the given item conflicts with any other
    // item and, if so, to display a message.
    //
{
    SAPM* Duplicate;
    PLIST_ENTRY Link;
    for (Link = pDlg->PortMappings.Flink;
         Link != &pDlg->PortMappings; Link = Link->Flink)
    {
        Duplicate = CONTAINING_RECORD(Link, SAPM, Link);
        if (PortMapping != Duplicate &&
            !Duplicate->fDeleted &&
            PortMapping->Protocol == Duplicate->Protocol &&
            PortMapping->ExternalPort == Duplicate->ExternalPort)
        {
            MsgDlg(pDlg->hwndDlg, SID_DuplicatePortNumber, NULL);
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SrvInit(
    HWND hwndPage,
    SADLG* pDlg )

    // Called to initialize the services page. Fills the list-control with
    // configured services.
    //
{
    BOOL fModified;
    LONG i;
    LV_ITEM lvi;
    PLIST_ENTRY Link;
    SAPM* PortMapping;

    // Initialize the containing property-sheet, then store this page's
    // data in the shared control-block at 'pDlg'.
    //
    if (!SasInit(hwndPage, pDlg))
    {
        return FALSE;
    }

    // Store this page's data in the shared control-block at 'pDlg'.
    //
    pDlg->hwndSrv = hwndPage;
    pDlg->hwndServers = GetDlgItem(hwndPage, CID_SS_LV_Services);

    // Initialize the list-control with checkbox-handling,
    // insert a single column, and fill the list-control with the configured
    // items.
    //
    ListView_InstallChecks(pDlg->hwndServers, g_hinstDll);
    ListView_InsertSingleAutoWidthColumn(pDlg->hwndServers);

    fModified = pDlg->fModified;
    for (Link = pDlg->PortMappings.Flink;
         Link != &pDlg->PortMappings; Link = Link->Flink)
    {
        PortMapping = CONTAINING_RECORD(Link, SAPM, Link);

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.lParam = (LPARAM)PortMapping;
        lvi.pszText = PortMapping->Title;
        lvi.cchTextMax = lstrlen(PortMapping->Title) + 1;

        i = ListView_InsertItem(pDlg->hwndServers, &lvi);

        if (i != -1)
        {
            ListView_SetCheck(pDlg->hwndServers, i, PortMapping->Enabled);
        }
    }
    pDlg->fModified = fModified;

    // Finally, update the appearance of the buttons for the current selection.
    //
    ListView_SetItemState(pDlg->hwndServers, 0, LVIS_SELECTED, LVIS_SELECTED);
    SrvUpdateButtons(pDlg, TRUE, -1);

    // if we got no portmappings, check to see if the button allowing
    // other network users to control the gateway is unchecked (on the host)
    if (IsListEmpty (pDlg->PortMappings.Flink) &&
        pDlg->pUPS && IsICSHost ()) {

        // display error
        DisplayError (pDlg->hwndDlg, SID_OP_OurGatewayError, SID_PopupTitle);
        // cancel
        PostMessage (hwndPage, WM_PRIVATE_CANCEL, 0, 0L);
    }

    return TRUE;
}

VOID
SrvUpdateButtons(
    SADLG* pDlg,
    BOOL fAddDelete,
    LONG iSetCheckItem )

    // Called to set an initial selection if necessary, update the appearance
    // of the 'Edit' and 'Delete' buttons, and perform conflict-detection
    // if an entry's checkbox was set.
    //
{
    LONG i;
    SAPM* PortMapping;

    // If an entry was added or removed, ensure that there is a selection.
    // If there are no entries at all, disable the 'Edit' button.
    //
    if (fAddDelete)
    {
        if (ListView_GetItemCount(pDlg->hwndServers))
        {
            ListView_SetItemState(
                pDlg->hwndServers, 0, LVIS_SELECTED, LVIS_SELECTED);
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Edit), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Edit), FALSE);
        }
    }

    // Disable the 'Delete' button, and enable it only if at least one of the
    // selected items is not a built-in item.
    //
    EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Delete), FALSE);
    i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
    while (i != -1)
    {
        PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
        if (    (NULL != PortMapping)
            &&  (!PortMapping->BuiltIn))
        {
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Delete), TRUE);
            break;
        }

        i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_SELECTED);
    }

    // If the check-state of an item was changed and the item is now checked,
    // perform conflict-detection. If a conflict is detected, clear the item's
    // check state.
    //
    if (iSetCheckItem != -1)
    {
        PortMapping =
            (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, iSetCheckItem);

        if(NULL == PortMapping)
        {
            return;
        }

        if (ListView_GetCheck(pDlg->hwndServers, iSetCheckItem))
        {
            if (SrvConflictDetected(pDlg, PortMapping))
            {
                ListView_SetCheck(pDlg->hwndServers, iSetCheckItem, FALSE);
                SrvAddOrEditEntry(pDlg, iSetCheckItem, PortMapping);
            }
            else
            {
                PortMapping->Enabled = TRUE;
                PortMapping->fBindingModified = TRUE;

                // If the item is marked 'built-in' and it is being enabled
                // for the first time, pop up the edit-dialog so the user can
                // specify an internal IP address or name for the server.
                //
                if (PortMapping->BuiltIn &&
                    (!PortMapping->InternalName
                     || !lstrlen(PortMapping->InternalName)))
                {

                    //
                    // We fill in the local computer name as the default
                    // target. It's OK if this allocation fails; the UI
                    // will show an empty field, so the user will be
                    // required to enter a target.
                    //

                    PortMapping->InternalName = _StrDup(pDlg->ComputerName);
                    SrvAddOrEditEntry(pDlg, iSetCheckItem, PortMapping);

                    if (!PortMapping->InternalName
                        || !lstrlen(PortMapping->InternalName))
                    {
                        ListView_SetCheck(
                            pDlg->hwndServers, iSetCheckItem, FALSE);

                        PortMapping->Enabled = FALSE;
                        PortMapping->fBindingModified = FALSE;
                    }
                }
            }
        }
        else
        {
            PortMapping->Enabled = FALSE;
            PortMapping->fBindingModified = TRUE;
        }
    }
}


BOOL
SharedAccessPortMappingDlg(
    IN HWND hwndOwner,
    IN OUT SAPM** PortMapping )

    // Called to display the dialog for adding or editing a service-entry.
    // 'Server' points to NULL if adding, or the target entry if editing.
    //
{
    LRESULT nResult =
        DialogBoxParam(g_hinstDll, MAKEINTRESOURCE(DID_SS_Service),
            hwndOwner, SspDlgProc, (LPARAM)PortMapping);
    return nResult == -1 ? FALSE : (BOOL)nResult;
}

INT_PTR CALLBACK
SspDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // Called to handle messages for the add/edit service dialog.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            SADLG* pDlg;
            SAPM* PortMapping;

            // Retrieve the context-block for the settings dialog from which
            // this dialog was launched.
            //
            if (!(pDlg = SasContext(hwnd)))
            {
                EndDialog(hwnd, FALSE);
                return TRUE;
            }

            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_ExternalPort), 5);
            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_InternalPort), 5);

            // Create new service if adding a service, or retrieve the service
            // to be edited.
            //
            if (!(PortMapping = *(SAPM**)lparam))
            {
                PortMapping = (SAPM*)Malloc(sizeof(*PortMapping));
                if (!PortMapping)
                {
                    EndDialog(hwnd, FALSE);
                    return TRUE;
                }
                *(SAPM**)lparam = PortMapping;
                ZeroMemory(PortMapping, sizeof(*PortMapping));
                PortMapping->Enabled = TRUE;
                PortMapping->fNewEntry = TRUE;
                InitializeListHead(&PortMapping->Link);
                CheckDlgButton(hwnd, CID_SS_PB_Tcp, TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, CID_SS_EB_Service), FALSE);
                SetDlgItemText(hwnd, CID_SS_EB_Service, PortMapping->Title);
                SetDlgItemInt(hwnd, CID_SS_EB_ExternalPort, ntohs(PortMapping->ExternalPort), FALSE);
                SetDlgItemInt(hwnd, CID_SS_EB_InternalPort, ntohs(PortMapping->InternalPort), FALSE);
                CheckDlgButton(
                    hwnd, CID_SS_PB_Tcp, PortMapping->Protocol == NAT_PROTOCOL_TCP);
                CheckDlgButton(
                    hwnd, CID_SS_PB_Udp, PortMapping->Protocol != NAT_PROTOCOL_TCP);
                SetDlgItemText(hwnd, CID_SS_EB_Address, PortMapping->InternalName);

                // If the entry to be modified is marked 'built-in', disable
                // all input fields except the server-name, which the user must
                // now enter.
                //

                if (PortMapping->BuiltIn)
                {
                    EnableWindow(GetDlgItem(hwnd, CID_SS_EB_ExternalPort), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_EB_InternalPort), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_PB_Tcp), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_PB_Udp), FALSE);
                }
            }

            SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)PortMapping);
            CenterWindow(hwnd, GetParent(hwnd));
            AddContextHelpButton(hwnd);
            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwSspHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wparam) != BN_CLICKED) { return FALSE; }

            // If the user is dismissing the dialog, clean up and return.
            //
            SAPM* PortMapping;
            SADLG* pDlg;
            if (IDCANCEL == LOWORD(wparam))
            {
                PortMapping = (SAPM*)GetWindowLongPtr(hwnd, DWLP_USER);
                if (IsListEmpty(&PortMapping->Link))
                {
                    FreePortMappingEntry(PortMapping);
                }
                EndDialog (hwnd, FALSE);
                return TRUE;
            }
            else if (LOWORD(wparam) != IDOK)
            {
                return FALSE;
            }
            else if (!(pDlg = SasContext(hwnd)))
            {
                return FALSE;
            }

            // Retrieve the service to be added or modified.
            //
            PortMapping = (SAPM*)GetWindowLongPtr(hwnd, DWLP_USER);

            // Retrieve the values specified by the user,
            // and attempt to save them in the new or modified entry.
            //
            UCHAR Protocol = IsDlgButtonChecked(hwnd, CID_SS_PB_Tcp)
                ? NAT_PROTOCOL_TCP : NAT_PROTOCOL_UDP;

            BOOL Success;
            ULONG ExternalPort = GetDlgItemInt(hwnd, CID_SS_EB_ExternalPort, &Success, FALSE);
            if (!Success || ExternalPort < 1 || ExternalPort > 65535)
            {
                MsgDlg(hwnd, SID_TypePortNumber, NULL);
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_ExternalPort));
                return FALSE;
            }
            ExternalPort = htons((USHORT)ExternalPort);

            //
            // Check to see if this is a duplicate. To do this we need
            // to save the old port and protocol values, put the new
            // values into the protocol entry, perform the check, and
            // then restore the old values.
            //

            USHORT OldExternalPort    = PortMapping->ExternalPort;
            PortMapping->ExternalPort = (USHORT)ExternalPort;
            UCHAR OldProtocol     = PortMapping->Protocol;
            PortMapping->Protocol = Protocol;

            if (SrvConflictDetected(pDlg, PortMapping))
            {
                PortMapping->ExternalPort = OldExternalPort;
                PortMapping->Protocol = OldProtocol;
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_ExternalPort));
                return FALSE;
            }
            PortMapping->ExternalPort = OldExternalPort;
            PortMapping->Protocol = OldProtocol;

            // per BillI, there's no need to test internal ports for conflicts
            ULONG InternalPort = GetDlgItemInt(hwnd, CID_SS_EB_InternalPort, &Success, FALSE);
            if (InternalPort == 0)
                InternalPort = ExternalPort;
            else {
                if (InternalPort < 1 || InternalPort > 65535)
                {
                    MsgDlg(hwnd, SID_TypePortNumber, NULL);
                    SetFocus(GetDlgItem(hwnd, CID_SS_EB_InternalPort));
                    return FALSE;
                }
                InternalPort = htons((USHORT)InternalPort);
            }

            TCHAR* InternalName = GetText(GetDlgItem(hwnd, CID_SS_EB_Address));
            if (!InternalName || !lstrlen(InternalName))
            {
                MsgDlg(hwnd, SID_SS_TypeAddress, NULL);
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_Address));
                return FALSE;
            }

            if (IsListEmpty(&PortMapping->Link))
            {
                PortMapping->Title = GetText(GetDlgItem(hwnd, CID_SS_EB_Service));
                if (!PortMapping->Title || !lstrlen(PortMapping->Title))
                {
                    MsgDlg(hwnd, SID_TypeEntryName, NULL);
                    SetFocus(GetDlgItem(hwnd, CID_SS_EB_Service));
                    Free0(InternalName);
                    return FALSE;
                }
            }

            if (PortMapping->Protocol     != Protocol ||
                PortMapping->ExternalPort != (USHORT)ExternalPort ||
                PortMapping->InternalPort != (USHORT)InternalPort)
            {
                PortMapping->fProtocolModified = TRUE;
            }

            PortMapping->fBindingModified = TRUE;
            PortMapping->Protocol         = Protocol;
            PortMapping->ExternalPort     = (USHORT)ExternalPort;
            PortMapping->InternalPort     = (USHORT)InternalPort;
            if (PortMapping->InternalName)
            {
                Free(PortMapping->InternalName);
            }
            PortMapping->InternalName = InternalName;
            if (IsListEmpty(&PortMapping->Link))
            {
                InsertTailList(&pDlg->PortMappings, &PortMapping->Link);
            }
            EndDialog (hwnd, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\saui.cpp ===
#include "pch.h"
#pragma hdrstop

#include <shellapi.h>
#include <rasdlg.h>
#include "sautil.h"
#include "resource.h"
#include "beacon.h"
#include "htmlhelp.h"
#include "lm.h"
#include <shlobj.h>

// global(s)
HINSTANCE g_hinstDll;
LPCTSTR g_contextId = NULL;


// external(s)
extern "C" {
    extern BOOL WINAPI LinkWindow_RegisterClass();
}

// static(s)
static DWORD g_adwSaHelp[] =
{
    CID_SA_PB_Shared,       HID_SA_PB_Shared,
    CID_SA_GB_Shared,       -1,
    CID_SA_PB_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_PB_Settings,     HID_SA_PB_Settings,
    CID_SA_GB_PrivateLan,   -1,
//  CID_SA_ST_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_SA_LB_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_FW_PB_Firewalled,   HID_FW_PB_Firewalled,   
    CID_SA_ST_ICFLink,      HID_SA_ST_ICFLink,      
    CID_SA_EB_PrivateLan,   HID_SA_EB_PrivateLan,   
    CID_SA_PB_Beacon,       HID_SA_PB_Beacon,       
    CID_SA_ST_ICSLink,      HID_SA_ST_ICSLink,
    CID_SA_ST_HNWLink,      HID_SA_ST_HNWLink,
    0, 0
};
static TCHAR g_pszFirewallRegKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetworking\\PersonalFirewall");
static TCHAR g_pszDisableFirewallWarningValue[] = TEXT("ShowDisableFirewallWarning");

// replacement for (private) PBENTRY
typedef struct _BILLSPBENTRY
{
    TCHAR pszPhonebookPath[MAX_PATH];
    TCHAR pszEntryName[RAS_MaxEntryName];
    DWORD dwType;
    GUID  guidId;   // somewhere for pGuid to point
    GUID* pGuid;
    DWORD dwfExcludedProtocols;
} BILLSPBENTRY;

// Phonebook Entry common block.
//
typedef struct _EINFO
{
    // RAS API arguments.
    //
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
//  RASENTRYDLG* pApiArgs;
    HWND hwndOwner; // bhanlon: so that EuHomenetCommit error dialogs work.

    // Set true by property sheet or wizard when changes should be committed
    // before returning from the API.  Does not apply in ShellOwned-mode where
    // the API returns before the property sheet is dismissed.
    //
//    BOOL fCommit;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if fRouter is TRUE and pszRouter refers to a remote machine.
    //
//  BOOL fRemote;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only
    // if fRouter is true.
    //
//  BOOL fNt4Router;

    //Set if pszRouter is an Windows 2000 machine, Valid only if
    // fRouter is true
//  BOOL fW2kRouter;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
//  TCHAR* pszRouter;

    // Set by the add entry or add interface wizards if user chooses to end
    // the wizard and go edit the properties directly.  When this flag is set
    // the wizard should *not* call EuFree before returning.
    //
//  BOOL fChainPropertySheet;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile' as 'file' will only be used in cases where the open
    // phonebook is not passed thru the reserved word hack.
    //
//    PBFILE* pFile;
//    PBFILE file;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
//    PBUSER* pUser;
//    PBUSER user;

    // Set if "no user before logon" mode.
    //
//  BOOL fNoUser;

    // Set by the add-entry wizard if the selected port is an X.25 PAD.
    //
//  BOOL fPadSelected;

    // Set if there are multiple devices configured, i.e. if the UI is running
    // in the multiple device mode.  This is implicitly false in VPN and
    // Direct modes.
    //
//  BOOL fMultipleDevices;

    // Link storing the List of PBPHONEs and alternate options for shared
    // phone number mode.  This allows user to change the port/device to
    // another link without losing the phone number he typed.
    //
//    DTLNODE* pSharedNode;

    // The node being edited (still in the list), and the original entry name
    // for use in comparison later.  These are valid in "edit" case only.
    //
//    DTLNODE* pOldNode;
//    TCHAR szOldEntryName[ RAS_MaxEntryName + 1 ];

    // The work entry node containing and a shortcut pointer to the entry
    // inside.
    //
//    DTLNODE* pNode;
//  PBENTRY* pEntry;
    BILLSPBENTRY* pEntry;

    // The master list of configured ports used by EuChangeEntryType to
    // construct an appropriate sub-list of PBLINKs in the work entry node.
    //
//    DTLLIST* pListPorts;

    // The "current" device.  This value is NULL for multilink entries.  It
    // is the device that the entry will use if no change is made.  We compare
    // the current device to the device selected from the general tab to know
    // when it is appropriate to update the phonebook's "preferred" device.
    //
//  TCHAR* pszCurDevice;
//  TCHAR* pszCurPort;

    // Set true if there are no ports of the current entry type configured,
    // not including any bogus "uninstalled" ports added to the link list so
    // the rest of the code can assume there is at least one link.
    //
//  BOOL fNoPortsConfigured;

    // Dial-out user info for router; used by AiWizard.  Used to set interface
    // credentials via MprAdminInterfaceSetCredentials.
    //
//  TCHAR* pszRouterUserName;
//  TCHAR* pszRouterDomain;
//  TCHAR* pszRouterPassword;

    // Dial-in user info for router (optional); used by AiWizard.  Used to
    // create dial-in user account via NetUserAdd; the user name for the
    // account is the interface (phonebook entry) name.
    //
//  BOOL fAddUser;
//  TCHAR* pszRouterDialInPassword;

    // Home networking settings for the entry.
    //
    BOOL fComInitialized;
    IHNetConnection *pHNetConn;
    IHNetCfgMgr *pHNetCfgMgr;
    BOOL fShowHNetPages;
    HRESULT hShowHNetPagesResult;

    // ICS settings for the entry
    //
    IHNetIcsSettings *pIcsSettings;
    BOOL fOtherShared;
    BOOL fShared;
    BOOL fNewShared;
    BOOL fDemandDial;
    BOOL fNewDemandDial;
    BOOL fNewBeaconControl;
    BOOL fResetPrivateAdapter;
    IHNetConnection *pPrivateLanConnection;
    IHNetConnection **rgPrivateConns;
    IHNetIcsPublicConnection *pOldSharedConnection;
    DWORD dwLanCount;
    LONG lxCurrentPrivate;

    // Firewall settings for the entry
    //
    BOOL fFirewalled;
    BOOL fNewFirewalled;

    // AboladeG - security level of the current user.
    // Set true if the user is an administrator/power user.
    // This is required by several pages, both in the wizard
    // and in the property sheet.
    //
    BOOL fIsUserAdminOrPowerUser;

    // Set if strong encryption is supported by NDISWAN, as determined in
    // EuInit.
    //
    BOOL fStrongEncryption;

    // Set whent the VPN "first connect" controls should be read-only, e.g. in
    // the dialer's Properties button is pressed in the middle of a double
    // dial.
    //
//  BOOL fDisableFirstConnect;

    //Used in the IPSec Policy in the Security tab for a VPN connection
    //
//  BOOL fPSKCached;
//  TCHAR szPSK[PWLEN + 1];


    // Flags to track whether to save the default Internet connection
    //
//  BOOL fDefInternetPersonal;
//  BOOL fDefInternetGlobal;

    // Default credentials
    //
//  TCHAR* pszDefUserName;
//  TCHAR* pszDefPassword;
}
EINFO;

// Phonebook Entry property sheet context block.  All property pages refer to
// the single context block is associated with the sheet.
//
typedef struct
_PEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Property sheet dialog and property page handles.  'hwndFirstPage' is
    // the handle of the first property page initialized.  This is the page
    // that allocates and frees the context block.
    //
    // Note the "Network" page is missing.  This "NCPA" page, developed
    // separately by ShaunCo, does not use this shared area for page specfic
    // controls, instead returning users selections via the "penettab.h"
    // interface.
    //
    HWND hwndDlg;
//  HWND hwndFirstPage;
//  HWND hwndGe;
//  HWND hwndOe;
//  HWND hwndLo;
    HWND hwndSa;
//  HWND hwndFw;

    // General page.
    //
//  HWND hwndLvDevices;
//  HWND hwndLbDevices;
//  HWND hwndPbUp;
//  HWND hwndPbDown;
//  HWND hwndCbSharedPhoneNumbers;
//  HWND hwndPbConfigureDevice;
//  HWND hwndGbPhoneNumber;
//  HWND hwndStAreaCodes;
//  HWND hwndClbAreaCodes;
//  HWND hwndStCountryCodes;
//  HWND hwndLbCountryCodes;
//  HWND hwndStPhoneNumber;
//  HWND hwndEbPhoneNumber;
//  HWND hwndCbUseDialingRules;
//  HWND hwndPbDialingRules;
//  HWND hwndPbAlternates;
//  HWND hwndCbShowIcon;

//  HWND hwndEbHostName;
//  HWND hwndCbDialAnotherFirst;
//  HWND hwndLbDialAnotherFirst;

//  HWND hwndEbBroadbandService;

    // Options page.
    //
//  HWND hwndCbDisplayProgress;
//  HWND hwndCbPreviewUserPw;
//  HWND hwndCbPreviewDomain;
//  HWND hwndCbPreviewNumber;
//  HWND hwndEbRedialAttempts;
//  HWND hwndLbRedialTimes;
//  HWND hwndLbIdleTimes;
//  HWND hwndCbRedialOnDrop;
//  HWND hwndGbMultipleDevices;
//  HWND hwndLbMultipleDevices;
//  HWND hwndPbConfigureDialing;
//  HWND hwndPbX25;
//  HWND hwndPbTunnel;
//  HWND hwndRbPersistent;  // only for fRouter
//  HWND hwndRbDemandDial;  // only for fRouter

    // Security page.
    //
//  HWND hwndGbSecurityOptions;
//  HWND hwndRbTypicalSecurity;
//  HWND hwndStAuths;
//  HWND hwndLbAuths;
//  HWND hwndCbUseWindowsPw;
//  HWND hwndCbEncryption;
//  HWND hwndRbAdvancedSecurity;
//  HWND hwndStAdvancedText;
//  HWND hwndPbAdvanced;
//  HWND hwndPbIPSec;       //Only for VPN
//  HWND hwndGbScripting;
//  HWND hwndCbRunScript;
//  HWND hwndCbTerminal;
//  HWND hwndLbScripts;
//  HWND hwndPbEdit;
//  HWND hwndPbBrowse;

    // Networking page.
    //
//  HWND hwndLbServerType;
//  HWND hwndPbSettings;
//  HWND hwndLvComponents;
//  HWND hwndPbAdd;
//  HWND hwndPbRemove;
//  HWND hwndPbProperties;
//  HWND hwndDescription;

    // Shared Access page.
    //
    HWND hwndSaPbShared;
    HWND hwndSaGbShared;
    HWND hwndSaGbPrivateLan;
    HWND hwndSaEbPrivateLan;
    HWND hwndSaLbPrivateLan;
    HWND hwndSaSfPrivateLan;
    HWND hwndSaPbDemandDial;
    HWND hwndSaPbFirewalled;

    // Indicates that the informational popup noting that SLIP does not
    // support any authentication settings should appear the next time the
    // Security page is activated.
    //
//  BOOL fShowSlipPopup;

    // The "restore" states of the typical security mode listbox and
    // checkboxes.  Initialized in LoInit and set whenever the controls are
    // disabled.
    //
//  DWORD iLbAuths;
//  BOOL fUseWindowsPw;
//  BOOL fEncryption;

    // MoveUp/MoveDown icons, for enabled/disabled cases.
    //
//  HANDLE hiconUpArr;
//  HANDLE hiconDnArr;
//  HANDLE hiconUpArrDis;
//  HANDLE hiconDnArrDis;

    // The currently displayed link node, i.e. either the node of the selected
    // device or the shared node.  This is a shortcut for GeAlternates, that
    // keeps all the lookup code in GeUpdatePhoneNumberFields.
    //
//    DTLNODE* pCurLinkNode;

    // The currently selected device.  Used to store phone number information
    // for the just unselected device when a new device is selected.
    //
//  INT iDeviceSelected;

    // Complex phone number helper context block, and a flag indicating if the
    // block has been initialized.
    //
//    CUINFO cuinfo;
//  BOOL fCuInfoInitialized;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
//    SUINFO suinfo;
//  BOOL fSuInfoInitialized;

    // Flags whether the user authorized a reboot after installing or removing
    // and networking component.
    //
//  BOOL fRebootAlreadyRequested;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
//    DTLLIST* pListAreaCodes;

    // Stash/restore values for Options page checkboxes.
    //
//  BOOL fPreviewUserPw;
//  BOOL fPreviewDomain;

    // Set when user changes to "Typical smartcard" security.  This causes the
    // registry based association of EAP per-user information to be discarded,
    // sort of like flushing cached credentials.
    //
//  BOOL fDiscardEapUserData;

    // Set true on the first click of the Typical or Advanced radio button on
    // the security page, false before.  The first click is the one
    // artificially generated in LoInit.  The Advanced click handler uses the
    // information to avoid incorrectly adopting the Typical defaults in the
    // case of Advanced settings.
    //
//  BOOL fAuthRbInitialized;

    // Used by the networking page
    //
//  INetCfg*                        pNetCfg;
//  BOOL                            fInitCom;
//  BOOL                            fReadOnly;  // Netcfg was initialized in
                                                // read-only mode
//  BOOL                            fNonAdmin;  // Run in non-admin mode (406630)
//  BOOL                            fNetCfgLock;// NetCfg needs to be unlocked
                                                // when uninited.
//    SP_CLASSIMAGELIST_DATA          cild;
//  INetConnectionUiUtilities *     pNetConUtilities;
//  IUnknown*                       punkUiInfoCallback;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
//  BOOL fComInitialized;

    // Keep track of whether we have shown this warning, or if it was disabled by the user
    //
    BOOL fShowDisableFirewallWarning;
    
    // r/w memory for indirect propsheet dialog
    LPDLGTEMPLATE lpdt;
}
PEINFO;

// local protos
INT_PTR CALLBACK SaDlgProc (IN HWND hwnd, IN UINT unMsg, IN WPARAM wparam, IN LPARAM lparam);
BOOL SaCommand (IN PEINFO* pInfo, IN WORD wNotification, IN WORD wId, IN HWND hwndCtrl);
BOOL SaInit (IN HWND hwndPage);

// more local protos
PEINFO* PeContext(IN HWND hwndPage);
BOOL SaIsAdapterDHCPEnabled(IN IHNetConnection* pConnection);
INT_PTR CALLBACK SaDisableFirewallWarningDlgProc(IN HWND hwnd, IN UINT unMsg, IN WPARAM wparam, IN LPARAM lparam);
HRESULT PeInit (GUID * pGuid, PEINFO ** ppEI);
DWORD EuInit (IN RASENTRY * pRE, IN TCHAR* pszPhonebook, IN TCHAR* pszEntry, IN RASENTRYDLG* pArgs, IN BOOL fRouter, OUT EINFO** ppInfo, OUT DWORD* pdwOp);
BOOL FIsUserAdminOrPowerUser (void);
void PeTerm (PEINFO * pEI);
VOID EuFree (IN EINFO* pInfo);
BOOL PeApply (IN HWND hwndPage);
BOOL EuCommit(IN EINFO* pInfo);
DWORD EuHomenetCommitSettings(IN EINFO* pInfo);

LRESULT CALLBACK CenterDlgOnOwnerCallWndProc (int code, WPARAM wparam, LPARAM lparam);
TCHAR* PszFromId(IN HINSTANCE hInstance,IN DWORD dwStringId);

HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu);

VOID VerifyConnTypeAndCreds(IN PEINFO* pInfo);
DWORD FindEntryCredentials(IN  TCHAR* pszPath, IN  TCHAR* pszEntryName, OUT BOOL* pfUser, OUT BOOL* pfGlobal);

//----------------------------------------------------------------------------
// Shared Access property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared Access page of the Entry property
    // sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "SaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            // hang pPEINFO off prop
            PROPSHEETPAGEW * pPSP = (PROPSHEETPAGEW *)lparam;
            SetProp (hwnd, g_contextId, (HANDLE)pPSP->lParam);
            return SaInit( hwnd );
        }

        case WM_NCDESTROY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            if (pInfo)
                PeTerm (pInfo);
            RemoveProp (hwnd, g_contextId);
            GlobalDeleteAtom ((ATOM)g_contextId);
            g_contextId = NULL;
            break;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwSaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return SaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    PeApply (hwnd);
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    PEINFO* pInfo;

                    TRACE("SwKILLACTIVE");
                    pInfo = PeContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    if ( Button_GetCheck( pInfo->hwndSaPbShared )
                        && (!pInfo->pArgs->fShared || (pInfo->pArgs->fResetPrivateAdapter && 0 != pInfo->pArgs->dwLanCount)))
                    {
                        IHNetConnection* pPrivateConn = NULL;

                        if(1 < pInfo->pArgs->dwLanCount) // if the combobox is showing make sure they selected a valid adapter
                        {
                            INT item = ComboBox_GetCurSel( pInfo->hwndSaLbPrivateLan );
                            if (item != CB_ERR)
                            {
                                pPrivateConn = (IHNetConnection*)ComboBox_GetItemData( pInfo->hwndSaLbPrivateLan, item );
                            }
                        }
                        else
                        {
                            pPrivateConn = pInfo->pArgs->rgPrivateConns[0];

                        }

                        if(NULL == pPrivateConn)
                        {
                            MSGARGS msgargs;
                            ASSERT(1 < pInfo->pArgs->dwLanCount);

                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_OK | MB_ICONWARNING;
                            MsgDlg( pInfo->hwndDlg, SID_SA_SelectAdapterError, &msgargs );
                            SetWindowLong( hwnd, DWLP_MSGRESULT, PSNRET_INVALID );
                            return TRUE;
                        }

                        if(!pInfo->pArgs->fOtherShared && FALSE == SaIsAdapterDHCPEnabled(pPrivateConn))
                        {
                            // if shared access is being turned on for the first time,
                            // explain its implications.
                            //

                            MSGARGS msgargs;
                            UINT    unId;
                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_YESNO | MB_ICONINFORMATION;
                            unId = MsgDlg( pInfo->hwndDlg, SID_EnableSharedAccess, &msgargs );
                            if (unId == IDNO)
                                SetWindowLong( hwnd, DWLP_MSGRESULT, TRUE );
                            else
                                SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                        }
                    }

                    if ( TRUE == pInfo->pArgs->fFirewalled && TRUE == pInfo->fShowDisableFirewallWarning && FALSE == Button_GetCheck( pInfo->hwndSaPbFirewalled ) )
                    {
                        INT_PTR nDialogResult;
                        pInfo->fShowDisableFirewallWarning = FALSE;
                        nDialogResult = DialogBox(g_hinstDll, MAKEINTRESOURCE(DID_SA_DisableFirewallWarning), hwnd, SaDisableFirewallWarningDlgProc);
                        if(-1 != nDialogResult && IDYES != nDialogResult)
                        {
                            Button_SetCheck ( pInfo->hwndSaPbFirewalled, TRUE );
                            SaCommand( pInfo, BN_CLICKED, CID_FW_PB_Firewalled, pInfo->hwndSaPbFirewalled );

                        }
                    }
                    return TRUE;
                }

                case NM_CLICK:
                case NM_RETURN:
                {
                    HWND hPropertySheetWindow = GetParent(hwnd);
                    if(NULL != hPropertySheetWindow)
                    {
                        if(CID_SA_ST_HNWLink == wparam)
                        {
                            ShellExecute(NULL,TEXT("open"),TEXT("rundll32"), TEXT("hnetwiz.dll,HomeNetWizardRunDll"),NULL,SW_SHOW);
                            PostMessage(hPropertySheetWindow, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), (LPARAM) GetDlgItem(hPropertySheetWindow, IDCANCEL));
                        }
                        else if(CID_SA_ST_ICFLink == wparam || CID_SA_ST_ICSLink == wparam)
                        {
                            LPTSTR pszHelpTopic = CID_SA_ST_ICFLink == wparam ? TEXT("netcfg.chm::/hnw_understanding_firewall.htm") : TEXT("netcfg.chm::/Share_conn_overvw.htm");
                            HtmlHelp(NULL, pszHelpTopic, HH_DISPLAY_TOPIC, 0);
                            
                        }
                    }
                    break;
                }
                    
                    
            }
            break;
        }
    }
    
    return FALSE;
}

BOOL
SaCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "SaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_FW_PB_Firewalled:
        {
            BOOL fFirewalled = Button_GetCheck( pInfo->hwndSaPbFirewalled );
            EnableWindow(
                GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), fFirewalled || Button_GetCheck( pInfo->hwndSaPbShared ));
            return TRUE;
        }

        case CID_SA_PB_Shared:
        {
            BOOL fShared = Button_GetCheck( pInfo->hwndSaPbShared );
            EnableWindow( pInfo->hwndSaPbDemandDial, fShared );
            EnableWindow( GetDlgItem(pInfo->hwndSa, CID_SA_PB_Beacon), fShared );
            EnableWindow(
                GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), fShared || Button_GetCheck( pInfo->hwndSaPbFirewalled ));
            if (fShared && !pInfo->pArgs->fShared)
            {
                MSGARGS msgargs;
                IEnumHNetIcsPublicConnections *pEnum;
                IHNetIcsPublicConnection *pOldIcsConn;
                IHNetConnection *pOldConn;
                LPWSTR pszwOldName = NULL;
                HRESULT hr;
                hr = pInfo->pArgs->pIcsSettings->EnumIcsPublicConnections (&pEnum);
                if (SUCCEEDED(hr))
                {
                    ULONG ulCount;
                    
                    VerifyConnTypeAndCreds(pInfo);

                    hr = pEnum->Next(
                            1,
                            &pOldIcsConn,
                            &ulCount
                            );

                    if (SUCCEEDED(hr) && 1 == ulCount)
                    {
                        hr = pOldIcsConn->QueryInterface(
                                IID_IHNetConnection,
                                (void**)&pOldConn
                                );

                        if (SUCCEEDED(hr))
                        {
                            // Transer pOldIcsConn reference
                            //
                            pInfo->pArgs->fOtherShared = TRUE;
                            pInfo->pArgs->pOldSharedConnection = pOldIcsConn;

                            hr = pOldConn->GetName (&pszwOldName);
                            pOldConn->Release();
                        }
                        else
                        {
                            pOldIcsConn->Release();
                        }
                    }

                    pEnum->Release();
                }

                if (SUCCEEDED(hr) && NULL != pszwOldName)
                {
                    ZeroMemory( &msgargs, sizeof(msgargs) );
                    msgargs.apszArgs[ 0 ] = pszwOldName;
                    msgargs.apszArgs[ 1 ] = pInfo->pArgs->pEntry->pszEntryName;
                    msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                    MsgDlg( pInfo->hwndDlg, SID_ChangeSharedConnection, &msgargs );
                    CoTaskMemFree( pszwOldName );
                }
            }
            return TRUE;
        }

        case CID_SA_PB_Settings:
        {
            HNetSharingAndFirewallSettingsDlg(
                pInfo->hwndDlg,
                pInfo->pArgs->pHNetCfgMgr,
                Button_GetCheck( pInfo->hwndSaPbFirewalled ),
                pInfo->pArgs->pHNetConn
                );
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
SaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO* pInfo;
    INetConnectionUiUtilities* pncuu = NULL;
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    TRACE( "SaInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }
    _ASSERT (pInfo->hwndDlg == NULL);
    pInfo->pArgs->hwndOwner = pInfo->hwndDlg = GetParent (hwndPage);
    _ASSERT (pInfo->hwndDlg);

    // Initialize page-specific context information.
    //
    pInfo->hwndSa = hwndPage;
    pInfo->hwndSaPbShared = GetDlgItem( hwndPage, CID_SA_PB_Shared );
    ASSERT( pInfo->hwndSaPbShared );
    pInfo->hwndSaGbShared = GetDlgItem( hwndPage, CID_SA_GB_Shared );
    ASSERT( pInfo->hwndSaGbShared );
    pInfo->hwndSaGbPrivateLan = GetDlgItem( hwndPage, CID_SA_GB_PrivateLan );
    ASSERT( pInfo->hwndSaGbPrivateLan );
    pInfo->hwndSaEbPrivateLan = GetDlgItem( hwndPage, CID_SA_EB_PrivateLan );
    ASSERT( pInfo->hwndSaEbPrivateLan );
    pInfo->hwndSaLbPrivateLan = GetDlgItem( hwndPage, CID_SA_LB_PrivateLan );
    ASSERT( pInfo->hwndSaLbPrivateLan );
    pInfo->hwndSaSfPrivateLan = GetDlgItem( hwndPage, CID_SA_SF_PrivateLan );
    ASSERT( pInfo->hwndSaSfPrivateLan );
    pInfo->hwndSaPbDemandDial = GetDlgItem( hwndPage, CID_SA_PB_DemandDial );
    ASSERT( pInfo->hwndSaPbDemandDial );
    pInfo->hwndSaPbFirewalled = GetDlgItem( hwndPage, CID_FW_PB_Firewalled );
    ASSERT( pInfo->hwndSaPbFirewalled );

    // Initialize checks.
    //

    // Check if ZAW is denying access to the Shared Access UI
    //
    if (FAILED(HrCreateNetConnectionUtilities(&pncuu)))
    {
        ASSERT(NULL == pncuu);
    }

    if(NULL == pncuu || TRUE == pncuu->UserHasPermission (NCPERM_PersonalFirewallConfig))
    {
        HKEY hFirewallKey;
        Button_SetCheck( pInfo->hwndSaPbFirewalled, pInfo->pArgs->fFirewalled );
        SaCommand( pInfo, BN_CLICKED, CID_FW_PB_Firewalled, pInfo->hwndSaPbFirewalled );

        pInfo->fShowDisableFirewallWarning = TRUE;
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, KEY_QUERY_VALUE, &hFirewallKey))
        {
            DWORD dwValue;
            DWORD dwType;
            DWORD dwSize = sizeof(dwValue);
            if(ERROR_SUCCESS == RegQueryValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, NULL, &dwType, (BYTE*)&dwValue, &dwSize))
            {
                if(REG_DWORD == dwType && TRUE == dwValue)
                {
                    pInfo->fShowDisableFirewallWarning = FALSE;
                }
            }
            RegCloseKey(hFirewallKey);
        }

    }
    else
    {
        EnableWindow(pInfo->hwndSaPbFirewalled, FALSE);
    }


    // Initialize the page's appearance.
    // If there are multiple private LAN connections, below the 'shared access'
    // checkbox we display either
    // (a) a drop-list of LAN connections if the connection is not shared, or
    // (b) a disabled edit-control with the current private LAN.
    // This involves moving everything in the 'on-demand dialing' groupbox
    // downward on the page at run-time.
    // To achieve this, we use a hidden static control to tell us the position
    // to which the groupbox should be moved.
    //

    BOOL fPolicyAllowsSharing = TRUE;
    if(NULL != pncuu && FALSE == pncuu->UserHasPermission (NCPERM_ShowSharedAccessUi))
    {
        fPolicyAllowsSharing = FALSE;
    }

    if (pInfo->pArgs->dwLanCount == 0)
    {
        ShowWindow(pInfo->hwndSaGbShared, SW_HIDE);
        ShowWindow(pInfo->hwndSaPbShared, SW_HIDE);
        ShowWindow(pInfo->hwndSaPbDemandDial, SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_PB_Shared), SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_ICSLink), SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_PB_Beacon), SW_HIDE);
    }
    else if(FALSE == fPolicyAllowsSharing)
    {
        // if policy disables ICS just gray the checkbox
        EnableWindow(pInfo->hwndSaPbShared, FALSE);
        EnableWindow(pInfo->hwndSaPbDemandDial, FALSE);
        EnableWindow(GetDlgItem(hwndPage, CID_SA_PB_Beacon), FALSE);
    }
    else if (pInfo->pArgs->dwLanCount > 1)
    {
        INT cy;
        HDWP hdwp;
        DWORD i;
        INT item;
        RECT rc, rcFrame;
        IHNetConnection **rgPrivateConns;
        LPWSTR pszwName;
        HRESULT hr;

        // get the reference-frame and group-box coordinates
        //
        GetWindowRect( pInfo->hwndSaSfPrivateLan, &rcFrame );
        GetWindowRect( pInfo->hwndSaPbDemandDial, &rc );
        cy = rcFrame.top - rc.top;

        // move each control down by the amount in 'cy'
        //
        hdwp = BeginDeferWindowPos(3);

        if(NULL != hdwp)
        {


            GetWindowRect( pInfo->hwndSaPbDemandDial, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, pInfo->hwndSaPbDemandDial, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

            HWND hBeaconCheck = GetDlgItem(hwndPage, CID_SA_PB_Beacon);
            GetWindowRect( hBeaconCheck, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, hBeaconCheck, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
            
            HWND hICSLink = GetDlgItem(hwndPage, CID_SA_ST_ICSLink);
            GetWindowRect( hICSLink, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, hICSLink, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

            EndDeferWindowPos(hdwp);
        }

        // hide the smaller shared-access group box, show the larger version,
        // and display either the drop-list or the edit-control.
        //
        rgPrivateConns = (IHNetConnection **)pInfo->pArgs->rgPrivateConns;
        ShowWindow( pInfo->hwndSaGbShared, SW_HIDE );
        ShowWindow( pInfo->hwndSaGbPrivateLan, SW_SHOW );
        ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_HomeConnection), SW_SHOW);
        EnableWindow(GetDlgItem(hwndPage, CID_SA_ST_HomeConnection), TRUE);

        if (pInfo->pArgs->fShared && !pInfo->pArgs->fResetPrivateAdapter)
        {
            ShowWindow( pInfo->hwndSaEbPrivateLan, SW_SHOW );

            // Fill in name of current private connection
            //

            hr = rgPrivateConns[pInfo->pArgs->lxCurrentPrivate]->GetName (&pszwName);
            if (SUCCEEDED(hr))
            {
                SetWindowText(
                    pInfo->hwndSaEbPrivateLan, pszwName );

                CoTaskMemFree( pszwName );
            }
        }
        else
        {
            ShowWindow( pInfo->hwndSaLbPrivateLan, SW_SHOW );

            // Add the bogus entry to the combobox

            pszwName = PszFromId( g_hinstDll, SID_SA_SelectAdapter );
            ASSERT(pszwName);

            item = ComboBox_AddString( pInfo->hwndSaLbPrivateLan, pszwName );
            if (item != CB_ERR && item != CB_ERRSPACE)
            {
                ComboBox_SetItemData( pInfo->hwndSaLbPrivateLan, item, NULL ); // ensure item data is null for validation purposes
            }

            // fill the combobox with LAN names
            //
            for (i = 0; i < pInfo->pArgs->dwLanCount; i++)
            {
                hr = rgPrivateConns[i]->GetName (&pszwName);
                if (SUCCEEDED(hr))
                {
                    item =
                        ComboBox_AddString(
                            pInfo->hwndSaLbPrivateLan, pszwName );

                    if (item != CB_ERR)
                    {
                        ComboBox_SetItemData(
                            pInfo->hwndSaLbPrivateLan, item, rgPrivateConns[i] );
                    }

                    CoTaskMemFree( pszwName );
                }
            }

            ComboBox_SetCurSel( pInfo->hwndSaLbPrivateLan, 0 );
        }
    }

    if(NULL != pncuu)
    {
        pncuu->Release();
    }

    // Initialize checks.
    //

    BOOL fBeaconControl = TRUE;
    
    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS == dwError) // if this fails we assume it is on, set the box, and commit on apply
    {
        DWORD dwType;
        DWORD dwData = 0;
        DWORD dwSize = sizeof(dwData);
        dwError = RegQueryValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, &dwType, reinterpret_cast<LPBYTE>(&dwData), &dwSize);
        if(ERROR_SUCCESS == dwError && REG_DWORD == dwType && 0 == dwData)
        {
            fBeaconControl = FALSE;
        }
        RegCloseKey(hKey);
    }

    Button_SetCheck( pInfo->hwndSaPbShared, pInfo->pArgs->fShared );
    Button_SetCheck( pInfo->hwndSaPbDemandDial, pInfo->pArgs->fDemandDial );
    Button_SetCheck(GetDlgItem(hwndPage, CID_SA_PB_Beacon), fBeaconControl);

    EnableWindow( pInfo->hwndSaPbDemandDial, pInfo->pArgs->fShared && fPolicyAllowsSharing);
    EnableWindow( GetDlgItem(hwndPage, CID_SA_PB_Beacon), pInfo->pArgs->fShared && fPolicyAllowsSharing );
    EnableWindow( GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), pInfo->pArgs->fShared || pInfo->pArgs->fFirewalled );


    //if the machine is personal or workstation show the HNW link
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    if(0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask))
    {
        
        // but only if not on a domain
        LPWSTR pszNameBuffer;
        NETSETUP_JOIN_STATUS BufferType;
        
        if(NERR_Success == NetGetJoinInformation(NULL, &pszNameBuffer, &BufferType))
        {
            NetApiBufferFree(pszNameBuffer);
            if(NetSetupDomainName != BufferType)
            {
                ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_HNWLink), SW_SHOW);
            }
        }
    }

    return TRUE;
}

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch(unMsg)
    {
        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            case IDYES:
            case IDNO:
                if(BST_CHECKED == IsDlgButtonChecked(hwnd, CID_SA_PB_DisableFirewallWarning))
                {
                    HKEY hFirewallKey;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hFirewallKey, NULL))
                    {
                        DWORD dwValue = TRUE;
                        RegSetValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, 0, REG_DWORD, (CONST BYTE*)&dwValue, sizeof(dwValue));
                        RegCloseKey(hFirewallKey);
                    }
                }

                // fallthru
            case IDCANCEL:
                EndDialog(hwnd, LOWORD(wparam));
                break;

            }
            break;
        }
    }

    return FALSE;
}

BOOL SaIsAdapterDHCPEnabled(IHNetConnection* pConnection)
{
    HRESULT hr;
    BOOL fDHCP = FALSE;
    GUID* pAdapterGuid;
    hr = pConnection->GetGuid (&pAdapterGuid);
    if(SUCCEEDED(hr))
    {
        LPOLESTR pAdapterName;
        hr = StringFromCLSID(*pAdapterGuid, &pAdapterName);
        if(SUCCEEDED(hr))
        {
            SIZE_T Length = wcslen(pAdapterName);
            LPSTR pszAnsiAdapterName = (LPSTR)Malloc(Length + 1);
            if(NULL != pszAnsiAdapterName)
            {
                if(0 != WideCharToMultiByte(CP_ACP, 0, pAdapterName, (int)(Length + 1), pszAnsiAdapterName, (int)(Length + 1), NULL, NULL))
                {
                    HMODULE hIpHelper;
                    hIpHelper = LoadLibrary(L"iphlpapi");
                    if(NULL != hIpHelper)
                    {
                        DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO, PULONG);

                        pGetAdaptersInfo = (DWORD (WINAPI*)(PIP_ADAPTER_INFO, PULONG)) GetProcAddress(hIpHelper, "GetAdaptersInfo");
                        if(NULL != pGetAdaptersInfo)
                        {
                            ULONG ulSize = 0;
                            if(ERROR_BUFFER_OVERFLOW == pGetAdaptersInfo(NULL, &ulSize))
                            {
                                PIP_ADAPTER_INFO pInfo = (PIP_ADAPTER_INFO)Malloc(ulSize);
                                if(NULL != pInfo)
                                {
                                    if(ERROR_SUCCESS == pGetAdaptersInfo(pInfo, &ulSize))
                                    {
                                        PIP_ADAPTER_INFO pAdapterInfo = pInfo;
                                        do
                                        {
                                            if(0 == lstrcmpA(pszAnsiAdapterName, pAdapterInfo->AdapterName))
                                            {
                                                fDHCP = !!pAdapterInfo->DhcpEnabled;
                                                break;
                                            }

                                        } while(NULL != (pAdapterInfo = pAdapterInfo->Next));
                                    }
                                    Free(pInfo);
                                }
                            }
                        }
                        FreeLibrary(hIpHelper);
                    }
                }
                Free(pszAnsiAdapterName);
            }
            CoTaskMemFree(pAdapterName);
        }
        CoTaskMemFree(pAdapterGuid);
    }

    return fDHCP;
}

PEINFO* PeContext (IN HWND hwndPage)
{
    // Retrieve the property sheet context from a property page handle.
    //
//  return (PEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
// now hanging our stuff off our window (since it's not shared)
    return (PEINFO* )GetProp( hwndPage, g_contextId );
}

void PeTerm (PEINFO * pEI)
{
    _ASSERT (pEI);
    _ASSERT (pEI->pArgs);
    _ASSERT (pEI->pArgs->pEntry);

    Free (pEI->pArgs->pEntry); // BILLSPBENTRY
    EuFree (pEI->pArgs);
    if (pEI->lpdt)
        Free (pEI->lpdt);
    Free (pEI);
}

VOID
EuFree(
    IN EINFO* pInfo )

    // Releases 'pInfo' and associated resources.
    //
{
    TCHAR* psz;
//    INTERNALARGS* piargs;

//    piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;

    // Don't clean up the phonebook and user preferences if they arrived via
    // the secret hack.
    //
//    if (!piargs)
//    {
//        if (pInfo->pFile)
//        {
//            ClosePhonebookFile( pInfo->pFile );
//        }

//        if (pInfo->pUser)
//        {
//            DestroyUserPreferences( pInfo->pUser );
//        }
//    }

//    if (pInfo->pListPorts)
//    {
//        DtlDestroyList( pInfo->pListPorts, DestroyPortNode );
//    }
//    Free(pInfo->pszCurDevice);
//    Free(pInfo->pszCurPort);

//    if (pInfo->pNode)
//    {
//        DestroyEntryNode( pInfo->pNode );
//    }

    // Free router-information
    //
//    Free( pInfo->pszRouter );
//    Free( pInfo->pszRouterUserName );
//    Free( pInfo->pszRouterDomain );

//    if (pInfo->pSharedNode)
//    {
//        DestroyLinkNode( pInfo->pSharedNode );
//    }

//    psz = pInfo->pszRouterPassword;
//    if (psz)
//    {
//        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
//        Free( psz );
//    }

//    psz = pInfo->pszRouterDialInPassword;
//    if (psz)
//    {
//        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
//        Free( psz );
//    }

    // Free credentials stuff
//    Free(pInfo->pszDefUserName);
//    Free(pInfo->pszDefPassword);

    // Free home networking information
    //
    if (pInfo->rgPrivateConns)
    {
        UINT i;

        for (i = 0; i < pInfo->dwLanCount; i++)
        {
            if (pInfo->rgPrivateConns[i])
            {
                pInfo->rgPrivateConns[i]->Release();
            }
        }

        CoTaskMemFree(pInfo->rgPrivateConns);
    }

    if (pInfo->pHNetConn)
    {
        pInfo->pHNetConn->Release();
    }

    if (pInfo->pIcsSettings)
    {
        pInfo->pIcsSettings->Release();
    }

    if (pInfo->pOldSharedConnection)
    {
        pInfo->pOldSharedConnection->Release();
    }

    if (pInfo->pHNetCfgMgr)
    {
        pInfo->pHNetCfgMgr->Release();
    }

    if (pInfo->fComInitialized)
    {
        CoUninitialize();
    }

    Free( pInfo );
}

// helper
HRESULT GetRasEntry (TCHAR * pszPhonebook, TCHAR * pszEntry, RASENTRY ** ppRE)
{
    *ppRE = NULL;

    DWORD dwSize = 0;
    DWORD dwErr  = RasGetEntryProperties (pszPhonebook, pszEntry, NULL, &dwSize, NULL, NULL);
    if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return HRESULT_FROM_WIN32(dwErr);
    _ASSERT (dwSize != 0);

    RASENTRY * pRE = (RASENTRY*)Malloc (dwSize);
    if (!pRE)
        return E_OUTOFMEMORY;

    ZeroMemory (pRE, dwSize);
    pRE->dwSize = sizeof(RASENTRY);
    
    dwErr = RasGetEntryProperties (pszPhonebook, pszEntry, pRE, &dwSize, NULL, NULL);
    if (dwErr) {
        Free (pRE);
        return HRESULT_FROM_WIN32(dwErr);
    }
    *ppRE = pRE;
    return S_OK;
}

// wrapper....
HRESULT PeInit (GUID * pGuid, PEINFO ** ppEI)
{
    _ASSERT (pGuid);
    _ASSERT (ppEI);

    *ppEI = (PEINFO *)Malloc (sizeof(PEINFO));
    if (!*ppEI)
        return E_OUTOFMEMORY;
    ZeroMemory (*ppEI, sizeof(PEINFO));

    CComPtr<IHNetConnection> spHNetConn = NULL;
    CComPtr<IHNetCfgMgr> spHNetCfgMgr = NULL;
    HRESULT hr = CoCreateInstance (CLSID_HNetCfgMgr,
                                   NULL,
                                   CLSCTX_ALL,
                                   __uuidof(IHNetCfgMgr),   // &IID_IHNetCfgMgr,
                                   (void**)&spHNetCfgMgr);
    if (SUCCEEDED(hr)) {
        // Convert the entry to an IHNetConnection
        hr = spHNetCfgMgr->GetIHNetConnectionForGuid (
                            pGuid, FALSE, TRUE, &spHNetConn);
    }
    if (SUCCEEDED(hr)) {
        // the code below assumes UNICODE....
        TCHAR * pszPhonebook = NULL;
        TCHAR * pszEntry = NULL;
        HRESULT hr = spHNetConn->GetName (&pszEntry);
        if (hr == S_OK)
            hr = spHNetConn->GetRasPhonebookPath (&pszPhonebook);
    
        if (hr == S_OK) {
            // get RASENTRY dwType and guidId fields for code below
            RASENTRY * pRE = NULL;
            hr = GetRasEntry (pszPhonebook, pszEntry, &pRE);
            if (pRE) {
                DWORD dwOp = 0;
                DWORD dwError = EuInit (pRE,
                                        pszPhonebook,
                                        pszEntry,
                                        NULL,       // IN RASENTRYDLG* pArgs,
                                        FALSE,      // IN BOOL fRouter,
                                        &(*ppEI)->pArgs,
                                        &dwOp);
                if (dwError != 0) {
                    _ASSERT (dwOp != 0);
                    _ASSERT (!*ppEI);
                    if (HRESULT_SEVERITY(dwError))
                        hr = dwError;
                    else
                        hr = HRESULT_FROM_WIN32 (dwError);
                } else {
                    _ASSERT (dwOp == 0);
                    _ASSERT (*ppEI);
                }
                Free (pRE);
            }
        }
        if (pszPhonebook)   CoTaskMemFree (pszPhonebook);
        if (pszEntry)       CoTaskMemFree (pszEntry);
    }
    return hr;
}

DWORD
EuInit(
    IN RASENTRY * pRE,
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp )

    // Allocates '*ppInfo' data for use by the property sheet or wizard.
    // 'PszPhonebook', 'pszEntry', and 'pArgs', are the arguments passed by
    // user to the API.  'FRouter' is set if running in "router mode", clear
    // for the normal "dial-out" mode.  '*pdwOp' is set to the operation code
    // associated with any error.
    //
    // Returns 0 if successful, or an error code.  If non-null '*ppInfo' is
    // returned caller must eventually call EuFree to release the returned
    // block.
    //
{
    DWORD dwErr;
    EINFO* pInfo;
//  INTERNALARGS* piargs;

    *ppInfo = NULL;
    *pdwOp = 0;

    pInfo = (EINFO*)Malloc( sizeof(EINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pInfo, sizeof(*pInfo ) );

    /*
        bhanlon: I'm filling out what used to be a PBENTRY with a
        BILLSPBENTRY struct.  This needs to be freed....
    */
    pInfo->pEntry = (BILLSPBENTRY *)Malloc (sizeof(BILLSPBENTRY));
    if (!pInfo->pEntry) {
        Free (pInfo);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    _tcsncpy (pInfo->pEntry->pszEntryName, pszEntry, RAS_MaxEntryName);
    _tcsncpy (pInfo->pEntry->pszPhonebookPath, pszPhonebook, MAX_PATH);
    pInfo->pEntry->pGuid = &pInfo->pEntry->guidId;
    pInfo->pEntry->dwfExcludedProtocols = 0;
    pInfo->pEntry->dwType = pRE->dwType;
    pInfo->pEntry->guidId = pRE->guidId;

    *ppInfo = pInfo;
    pInfo->pszPhonebook = pszPhonebook;
    pInfo->pszEntry = pszEntry;
//  pInfo->pApiArgs = pArgs;
    pInfo->fRouter = fRouter;

//  piargs = (INTERNALARGS *)pArgs->reserved;

//  if (pInfo->fRouter)
//  {
//      LPTSTR pszRouter;
//      DWORD dwVersion;

//      ASSERT(piargs);

//      pszRouter = RemoteGetServerName(piargs->hConnection);

        // pmay: 348623
        //
        // Note that RemoteGetServerName is guarenteed to return
        // NULL for local box, non-NULL for remote
        //
//      pInfo->fRemote = !!pszRouter;

//      if(NULL == pszRouter)
//      {
//          pszRouter = TEXT("");
//      }

//      pInfo->pszRouter = StrDupTFromW(pszRouter);

        // Find out if we're focused on an nt4 router
        // pInfo->fNt4Router = FALSE;
        // IsNt40Machine( pszRouter, &(pInfo->fNt4Router) );

//      dwVersion = ((RAS_RPC *)(piargs->hConnection))->dwVersion;

//      pInfo->fNt4Router = !!(VERSION_40 == dwVersion );
        //Find out if the remote server is a win2k machine
        //
//      pInfo->fW2kRouter = !!(VERSION_50 == dwVersion );
//  }

    // Load the user preferences, or figure out that caller has already loaded
    // them.
    //
//  if (piargs && !piargs->fInvalid)
//  {
//      // We've received user preferences and the "no user" status via the
//      // secret hack.
//      //
//      pInfo->pUser = piargs->pUser;
//      pInfo->fNoUser = piargs->fNoUser;
//      pInfo->pFile = piargs->pFile;
//      pInfo->fDisableFirstConnect = piargs->fDisableFirstConnect;
//  }
//  else
//  {
//      DWORD dwReadPbkFlags = 0;

//      // Read user preferences from registry.
//      //
//      dwErr = g_pGetUserPreferences(
//          (piargs) ? piargs->hConnection : NULL,
//          &pInfo->user,
//          (pInfo->fRouter) ? UPM_Router : UPM_Normal );
//      if (dwErr != 0)
//      {
//          *pdwOp = SID_OP_LoadPrefs;
//          return dwErr;
//      }

//      pInfo->pUser = &pInfo->user;

//      if(pInfo->fRouter)
//      {
//          pInfo->file.hConnection = piargs->hConnection;
//          dwReadPbkFlags |= RPBF_Router;
//      }

//      if(pInfo->fNoUser)
//      {
//          dwReadPbkFlags |= RPBF_NoUser;
//      }

        // Load and parse the phonebook file.
        //
//        dwErr = ReadPhonebookFile(
//            pInfo->pszPhonebook, &pInfo->user, NULL,
//            dwReadPbkFlags,
//            &pInfo->file );
//        if (dwErr != 0)
//        {
//            *pdwOp = SID_OP_LoadPhonebook;
//            return dwErr;
//        }

//        pInfo->pFile = &pInfo->file;
//  }

    // Determine if strong encryption is supported.  Export laws prevent it in
    // some versions of the system.
    //
    {
//      ULONG ulCaps;
//      RAS_NDISWAN_DRIVER_INFO info;
//
//      ZeroMemory( &info, sizeof(info) );
//      ASSERT( g_pRasGetNdiswanDriverCaps );
//      dwErr = g_pRasGetNdiswanDriverCaps(
//          (piargs) ? piargs->hConnection : NULL, &info );
//      if (dwErr == 0)
//      {
//          pInfo->fStrongEncryption =
//              !!(info.DriverCaps & RAS_NDISWAN_128BIT_ENABLED);
//      }
//      else
        {
            pInfo->fStrongEncryption = FALSE;
        }
    }

    // Load the list of ports.
    //
//  dwErr = LoadPortsList2(
//      (piargs) ? piargs->hConnection : NULL,
//      &pInfo->pListPorts,
//      pInfo->fRouter );
//  if (dwErr != 0)
//  {
//      TRACE1( "LoadPortsList=%d", dwErr );
//      *pdwOp = SID_OP_RetrievingData;
//      return dwErr;
//  }

    // Set up work entry node.
    //
//  if (pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
//  {
//      DTLNODE* pNodeL;
//      DTLNODE* pNodeP;
//      PBLINK* pLink;
//      PBPORT* pPort;
//       // New entry mode, so 'pNode' set to default settings.
//      //
//      pInfo->pNode = CreateEntryNode( TRUE );
//      if (!pInfo->pNode)
//      {
//          TRACE( "CreateEntryNode failed" );
//          *pdwOp = SID_OP_RetrievingData;
//          return dwErr;
//      }

//      // Store entry within work node stored in context for convenience
//      // elsewhere.
//      //
//      pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
//      ASSERT( pInfo->pEntry );

//      if (pInfo->fRouter)
//      {
            // Set router specific defaults.
            //
//          pInfo->pEntry->dwIpNameSource = ASRC_None;
//          pInfo->pEntry->dwRedialAttempts = 0;

            // Since this is a new entry, setup a proposed entry name.
            // This covers the case when the wizard is not used to
            // create the entry and the property sheet has no way to enter
            // the name.
//          ASSERT( !pInfo->pEntry->pszEntryName );
//          GetDefaultEntryName( pInfo->pFile,
//                               RASET_Phone,
//                               pInfo->fRouter,
//                               &pInfo->pEntry->pszEntryName );

            // Disable MS client and File and Print services by default
            //
//          EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_msclient"),
//              FALSE);
//          EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_server"),
//              FALSE);
//      }

        // Use caller's default name, if any.
        //
//      if (pInfo->pszEntry)
//      {
//          pInfo->pEntry->pszEntryName = StrDup( pInfo->pszEntry );
//      }

        // Set the default entry type to "phone", i.e. modems, ISDN, X.26 etc.
        // This may be changed to "VPN" or  "direct"  by the new entry  wizard
        // after the initial wizard page.
        //
//      EuChangeEntryType( pInfo, RASET_Phone );
//  }
//  else
//  {
//      DTLNODE* pNode;

        // Edit or clone entry mode, so 'pNode' set to entry's current
        // settings.
        //
//      pInfo->pOldNode = EntryNodeFromName(
//          pInfo->pFile->pdtllistEntries, pInfo->pszEntry );

//      if (    !pInfo->pOldNode
//          &&  !pInfo->fRouter)
//      {

//          if(NULL == pInfo->pszPhonebook)
//          {
                //
                // Close the phonebook file we opened above.
                // we will try to find the entry name in the
                // per user phonebook file.
                //
//              ClosePhonebookFile(&pInfo->file);

//              pInfo->pFile = NULL;

                //
                // Attempt to find the file in users profile
                //
//              dwErr = GetPbkAndEntryName(
//                                  NULL,
//                                  pInfo->pszEntry,
//                                  0,
//                                  &pInfo->file,
//                                  &pInfo->pOldNode);

//              if(ERROR_SUCCESS != dwErr)
//              {
//                  *pdwOp = SID_OP_RetrievingData;
//                  return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
//              }

//              pInfo->pFile = &pInfo->file;
//          }
//          else
//          {
//              *pdwOp = SID_OP_RetrievingData;
//              return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
//          }
//      }

//      if(NULL != pInfo->pOldNode)
//      {
//          PBENTRY *pEntry = (PBENTRY *) DtlGetData(pInfo->pOldNode);

            // Before cloning or editing make sure that for dial up
            // connections, share File And Print is disabled.
            //
//          if(     ((RASET_Phone == pEntry->dwType)
//              ||  (RASET_Broadband == pEntry->dwType))
//              &&  (!pEntry->fShareMsFilePrint))
//          {
//              EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
//                  FALSE);
//          }
//      }

//      if(NULL != pInfo->pOldNode)
//      {
//          if (pInfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
//          {
//              pInfo->pNode = CloneEntryNode( pInfo->pOldNode );
//          }
//          else
//          {
//              pInfo->pNode = DuplicateEntryNode( pInfo->pOldNode );
//          }
//      }

//      if (!pInfo->pNode)
//      {
//          TRACE( "DuplicateEntryNode failed" );
//          *pdwOp = SID_OP_RetrievingData;
//          return ERROR_NOT_ENOUGH_MEMORY;
//      }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
//      pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );

        // Save original entry name for comparison later.
        //
//      lstrcpyn(
//          pInfo->szOldEntryName,
//          pInfo->pEntry->pszEntryName,
//          RAS_MaxEntryName + 1);

        // For router, want unconfigured ports to show up as "unavailable" so
        // they stand out to user who has been directed to change them.
        //
//      if (pInfo->fRouter)
//      {
//          DTLNODE* pNodeL;
//          PBLINK* pLink;

//          pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//          pLink = (PBLINK* )DtlGetData( pNodeL );

//          if (!pLink->pbport.fConfigured)
//          {
//              Free( pLink->pbport.pszDevice );
//              pLink->pbport.pszDevice = NULL;
//          }
//      }

        // pmay: 277801
        //
        // Remember the "current" device if this entry was last saved
        // as single link.
        //
//      if (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1)
//      {
//          DTLNODE* pNodeL;
//          PBLINK* pLink;

//          pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//          pLink = (PBLINK* )DtlGetData( pNodeL );

//          if (pLink->pbport.pszDevice && pLink->pbport.pszPort)
//          {
//              pInfo->pszCurDevice =
//                  StrDup(pLink->pbport.pszDevice);
//              pInfo->pszCurPort =
//                  StrDup(pLink->pbport.pszPort);
//          }
//      }

        // Append all non-configured ports of the entries type to the list of
        // links.  This is for the convenience of the UI.  The non-configured
        // ports are removed after editing prior to saving.
        //
//      AppendDisabledPorts( pInfo, pInfo->pEntry->dwType );
//  }

    // Set up the phone number storage for shared phone number mode.
    // Initialize it to a copy of the information from the first link which at
    // startup will always be enabled.  Note the Dial case with non-0
    // dwSubEntry is an exception, but in that case the pSharedNode anyway.
    //
//  {
//      DTLNODE* pNode;

//      pInfo->pSharedNode = CreateLinkNode();
//      if (!pInfo->pSharedNode)
//      {
//          *pdwOp = SID_OP_RetrievingData;
//          return ERROR_NOT_ENOUGH_MEMORY;
//      }

//      ASSERT( pInfo->pSharedNode );
//      pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      ASSERT( pNode );
//      CopyLinkPhoneNumberInfo( pInfo->pSharedNode, pNode );
//  }

    // Load the current shared-access (and firewall) settings
    //
    if (!pInfo->fRouter)
    {
        HRESULT hr;
        HNET_CONN_PROPERTIES *pProps;

        // Make sure COM is initialized on this thread.
        //
        hr = CoInitializeEx(
                NULL,
                COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
                );

        if (SUCCEEDED(hr))
        {
            pInfo->fComInitialized = TRUE;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // Create the home networking configuration manager
            //
            hr = CoCreateInstance(
                    CLSID_HNetCfgMgr,
                    NULL,
                    CLSCTX_ALL,
                    __uuidof(IHNetCfgMgr),
                    (void**)&pInfo->pHNetCfgMgr);

        }

        if (SUCCEEDED(hr))
        {
            // Get the IHNetIcsSettings interface
            //

            hr = pInfo->pHNetCfgMgr->QueryInterface(
                    __uuidof(IHNetIcsSettings), (void**)&pInfo->pIcsSettings);
        }

        if (SUCCEEDED(hr))
        {
            // Convert the entry to an IHNetConnection
            //

            hr = pInfo->pHNetCfgMgr->GetIHNetConnectionForGuid(
                    pInfo->pEntry->pGuid, FALSE, TRUE,
                    &pInfo->pHNetConn);
        }

        if (SUCCEEDED(hr))
        {
            // Determine whether this entry is already shared;
            // skip the check for new entries.
            //
            if (pInfo->pEntry->pszEntryName)
            {
                hr = pInfo->pHNetConn->GetProperties (&pProps);
                if (SUCCEEDED(hr))
                {
                    pInfo->fShared = pProps->fIcsPublic;
                    pInfo->fFirewalled = pProps->fFirewalled;
                    CoTaskMemFree(pProps);
                }
            }
            else
            {
                pInfo->fShared = FALSE;
                pInfo->fFirewalled = FALSE;
            }

            pInfo->fNewShared = pInfo->fShared;
            pInfo->fNewFirewalled = pInfo->fFirewalled;
        }

        if (SUCCEEDED(hr))
        {
            // Obtain an array of possible ICS private connections
            //
            hr = pInfo->pIcsSettings->GetPossiblePrivateConnections(
                    pInfo->pHNetConn,
                    &pInfo->dwLanCount,
                    &pInfo->rgPrivateConns,
                    &pInfo->lxCurrentPrivate
                    );

            RasQuerySharedAutoDial(&pInfo->fDemandDial);
            pInfo->fNewDemandDial = pInfo->fDemandDial;
            pInfo->fResetPrivateAdapter =
            pInfo->fShared && -1 == pInfo->lxCurrentPrivate;
        }

        pInfo->hShowHNetPagesResult = hr;

        if(SUCCEEDED(hr))
        {
            pInfo->fShowHNetPages = TRUE;
        }
    }

//  if (pInfo->fRouter)
//  {
//      pInfo->pEntry->dwfExcludedProtocols |= NP_Nbf;
//  }

    // AboladeG - capture the security level of the current user.
    //
    pInfo->fIsUserAdminOrPowerUser = FIsUserAdminOrPowerUser();

    return 0;
}

BOOL
FIsUserAdminOrPowerUser()
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID                        psid;
    BOOL                        fIsMember = FALSE;
    BOOL                        fRet = FALSE;
    SID                         sidLocalSystem = { 1, 1,
                                    SECURITY_NT_AUTHORITY,
                                    SECURITY_LOCAL_SYSTEM_RID };


    // Check to see if running under local system first
    //
    if (!CheckTokenMembership( NULL, &sidLocalSystem, &fIsMember ))
    {
        TRACE( "CheckTokenMemberShip for local system failed.");
        fIsMember = FALSE;
    }

    fRet = fIsMember;

    if (!fIsMember)
    {
        // Allocate a SID for the Administrators group and check to see
        // if the user is a member.
        //
        if (AllocateAndInitializeSid( &SidAuth, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &psid ))
        {
            if (!CheckTokenMembership( NULL, psid, &fIsMember ))
            {
                TRACE( "CheckTokenMemberShip for admins failed.");
                fIsMember = FALSE;
            }

            FreeSid( psid );

// Changes to the Windows 2000 permission model mean that regular Users
// on workstations are in the power user group.  So we no longer want to
// check for power user.
#if 0
            if (!fIsMember)
            {
                // They're not a member of the Administrators group so allocate a
                // SID for the Power Users group and check to see
                // if the user is a member.
                //
                if (AllocateAndInitializeSid( &SidAuth, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_POWER_USERS,
                             0, 0, 0, 0, 0, 0,
                             &psid ))
                {
                    if (!CheckTokenMembership( NULL, psid, &fIsMember ))
                    {
                        TRACE( "CheckTokenMemberShip for power users failed.");
                        fIsMember = FALSE;
                    }

                    FreeSid( psid );
                }
            }
#endif
        }

        fRet = fIsMember;
    }

    return fRet;
}

BOOL PeApply (IN HWND hwndPage)
{
    // Saves the contents of the property sheet.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.
    //
    // Returns true is page can be dismissed, false otherwise.
    //
    DWORD dwErr;
    PEINFO* pInfo;
    BILLSPBENTRY* pEntry;

    TRACE( "PeApply" );

    pInfo = PeContext( hwndPage );
    ASSERT( pInfo );
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT( pEntry );

    // Save General page fields.
    //
//  ASSERT( pInfo->hwndGe );
//  {
//      DTLNODE* pNode;

        // Retrieve the lone common control.
        //
//      pEntry->fShowMonitorIconInTaskBar =
//          Button_GetCheck( pInfo->hwndCbShowIcon );

//      if (pEntry->dwType == RASET_Phone)
//      {
//          DWORD dwCount;

//          dwCount = GeSaveLvDeviceChecks( pInfo );

            // Don't allow the user to deselect all of the
            // devices
//          if ( (pInfo->pArgs->fMultipleDevices) && (dwCount == 0) )
//          {
//              MsgDlg( hwndPage, SID_SelectDevice, NULL );
//              PropSheet_SetCurSel ( pInfo->hwndDlg, pInfo->hwndGe, 0 );
//              SetFocus ( pInfo->hwndLvDevices );
//              return FALSE;
//          }

            // Save the "shared phone number" setting.  As usual, single
            // device mode implies shared mode, allowing things to fall
            // through correctly.
            //
//          if (pInfo->pArgs->fMultipleDevices)
//          {
//              pEntry->fSharedPhoneNumbers =
//                  Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
//          }
//          else
//          {
//              pEntry->fSharedPhoneNumbers = TRUE;
//          }

            // Set the phone number set for the first phone number of the
            // current link (shared or selected) to the contents of the phone
            // number controls.
            //
//          GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

            // Swap lists, saving updates to caller's global list of area
            // codes.  Caller's original list will be destroyed by PeTerm.
            //
//          if (pInfo->pListAreaCodes)
//          {
//              DtlSwapLists(
//                  pInfo->pArgs->pUser->pdtllistAreaCodes,
//                  pInfo->pListAreaCodes );
//              pInfo->pArgs->pUser->fDirty = TRUE;
//          }
//      }
//      else if (pEntry->dwType == RASET_Vpn)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;
//          PBPHONE* pPhone;

            // Save host name, i.e. the VPN phone number.
            //
//          pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//          ASSERT( pNode );
//          pLink = (PBLINK* )DtlGetData( pNode );
//          pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

//          if(NULL == pNode)
//          {
//              return FALSE;
//          }

//          pPhone = (PBPHONE* )DtlGetData( pNode );
//          Free0( pPhone->pszPhoneNumber );
//          pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
//          FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

            // Any prequisite entry selection change has been saved already.
            // Just need to toss it if disabled.
            //
//          if (!Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
//          {
//              Free0( pEntry->pszPrerequisiteEntry );
//              pEntry->pszPrerequisiteEntry = NULL;
//              Free0( pEntry->pszPrerequisitePbk );
//              pEntry->pszPrerequisitePbk = NULL;
//          }
//      }
//      else if (pEntry->dwType == RASET_Broadband)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;
//          PBPHONE* pPhone;

            // Save service name, i.e. the broadband phone number.
            //
//          pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//          ASSERT( pNode );
//          pLink = (PBLINK* )DtlGetData( pNode );
//          pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

//          if(NULL == pNode)
//          {
//              return FALSE;
//          }

//          pPhone = (PBPHONE* )DtlGetData( pNode );
//          Free0( pPhone->pszPhoneNumber );
//          pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
//          FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );
//      }
//      else if (pEntry->dwType == RASET_Direct)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;

            // The currently enabled device is the one
            // that should be used for the connection.  Only
            // one device will be enabled (DnUpdateSelectedDevice).
//          for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//               pNode;
//               pNode = DtlGetNextNode( pNode ))
//          {
//              pLink = (PBLINK* )DtlGetData( pNode );
//              ASSERT(pLink);

//              if ( pLink->fEnabled )
//                  break;
//          }

            // If we found a link successfully, deal with it
            // now.
//          if ( pLink && pLink->fEnabled ) {
//              if (pLink->pbport.pbdevicetype == PBDT_ComPort)
//                  MdmInstallNullModem (pLink->pbport.pszPort);
//          }
//      }
//  }

    // Save Options page fields.
    //
//  if (pInfo->hwndOe)
//  {
//      UINT unValue;
//      BOOL f;
//      INT iSel;

//      pEntry->fShowDialingProgress =
//          Button_GetCheck( pInfo->hwndCbDisplayProgress );

        // Note: The'fPreviewUserPw', 'fPreviewDomain' fields are updated as
        //       they are changed.

//      pEntry->fPreviewPhoneNumber =
//          Button_GetCheck( pInfo->hwndCbPreviewNumber );

//      unValue = GetDlgItemInt(
//          pInfo->hwndOe, CID_OE_EB_RedialAttempts, &f, FALSE );
//      if (f && unValue <= 999999999)
//      {
//          pEntry->dwRedialAttempts = unValue;
//      }

//      iSel = ComboBox_GetCurSel( pInfo->hwndLbRedialTimes );
//      pEntry->dwRedialSeconds =
//          (DWORD )ComboBox_GetItemData( pInfo->hwndLbRedialTimes, iSel );

//      iSel = ComboBox_GetCurSel( pInfo->hwndLbIdleTimes );
//      pEntry->lIdleDisconnectSeconds =
//          (LONG )ComboBox_GetItemData( pInfo->hwndLbIdleTimes, iSel );

//      if (pInfo->pArgs->fRouter)
//      {
//          pEntry->fRedialOnLinkFailure =
//              Button_GetCheck( pInfo->hwndRbPersistent );
//      }
//      else
//      {
//          pEntry->fRedialOnLinkFailure =
//              Button_GetCheck( pInfo->hwndCbRedialOnDrop );
//      }

        // Note: dwDialMode is saved as changed.
        // Note: X.25 settings are saved at OK on that dialog.
//  }

    // Save Security page fields.
    //
//  if (pInfo->hwndLo)
//  {
//      if (Button_GetCheck( pInfo->hwndRbTypicalSecurity ))
//      {
//          LoSaveTypicalAuthSettings( pInfo );

//          if (pEntry->dwTypicalAuth == TA_CardOrCert)
//          {
                /*
                // Toss any existing advanced EAP configuration remnants when
                // typical smartcard, per bug 262702 and VBaliga email.
                //
                Free0( pEntry->pCustomAuthData );
                pEntry->pCustomAuthData = NULL;
                pEntry->cbCustomAuthData = 0;

                */
//              (void) DwSetCustomAuthData(
//                          pEntry,
//                          0,
//                          NULL);

//              TRACE( "RasSetEapUserData" );
//              ASSERT( g_pRasGetEntryDialParams );
//              g_pRasSetEapUserData(
//                  INVALID_HANDLE_VALUE,
//                  pInfo->pArgs->pFile->pszPath,
//                  pEntry->pszEntryName,
//                  NULL,
//                  0 );
//              TRACE( "RasSetEapUserData done" );
//          }
//      }

//      if (pEntry->dwType == RASET_Phone)
//      {
//          Free0( pEntry->pszScriptAfter );
//          SuGetInfo( &pInfo->suinfo,
//              &pEntry->fScriptAfter,
//              &pEntry->fScriptAfterTerminal,
//              &pEntry->pszScriptAfter );
//      }
//  }

    // Save Network page fields.
    // We won't have anything to do if we never initialized pNetCfg.
    //
//  if (pInfo->pNetCfg)
//  {
//      HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
//      NeSaveBindingChanges(pInfo);

//      hr = INetCfg_Apply (pInfo->pNetCfg);
//      if (((NETCFG_S_REBOOT == hr) || (pInfo->fRebootAlreadyRequested)) &&
//            pInfo->pNetConUtilities)
//      {
//          DWORD dwFlags = QUFR_REBOOT;
//          if (!pInfo->fRebootAlreadyRequested)
//              dwFlags |= QUFR_PROMPT;

            //$TODO NULL caption?
//          INetConnectionUiUtilities_QueryUserForReboot (
//                  pInfo->pNetConUtilities, pInfo->hwndDlg, NULL, dwFlags);
//      }
//  }

    // Save Shared Access page fields
    //
    if (pInfo->hwndSa)
    {
        // record the (new) sharing and demand-dial settings
        //
        pInfo->pArgs->fNewShared =
            Button_GetCheck( pInfo->hwndSaPbShared );
        pInfo->pArgs->fNewDemandDial =
            Button_GetCheck( pInfo->hwndSaPbDemandDial );
        pInfo->pArgs->fNewBeaconControl = 
            Button_GetCheck( GetDlgItem(pInfo->hwndSa, CID_SA_PB_Beacon) );

        // we only look at the private-lan drop list
        // if the user just turned on sharing, since that's the only time
        // we display the drop-list to begin with. we also need to look if
        // we need to reset the private adapter
        //
        if ((pInfo->pArgs->fNewShared && !pInfo->pArgs->fShared)
            || pInfo->pArgs->fResetPrivateAdapter)
        {
            if (pInfo->pArgs->dwLanCount > 1)
            {
                INT item = ComboBox_GetCurSel( pInfo->hwndSaLbPrivateLan );
                if (item != CB_ERR)
                {
                    pInfo->pArgs->pPrivateLanConnection =
                        (IHNetConnection*)ComboBox_GetItemData(
                                    pInfo->hwndSaLbPrivateLan, item );
                }
            }
            else if (pInfo->pArgs->dwLanCount)
            {
                ASSERT(pInfo->pArgs->rgPrivateConns);

                pInfo->pArgs->pPrivateLanConnection =
                    pInfo->pArgs->rgPrivateConns[0];
            }
        }

    // Save Firewall fields
    //
        pInfo->pArgs->fNewFirewalled =
            Button_GetCheck( pInfo->hwndSaPbFirewalled );
    }

#if 0 //!!!
    if ((fLocalPad || iPadSelection != 0)
        && (!pEntry->pszX25Address || IsAllWhite( pEntry->pszX25Address )))
    {
        // Address field is blank with X.25 dial-up or local PAD chosen.
        //
        MsgDlg( pInfo->hwndDlg, SID_NoX25Address, NULL );
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_XsPage );
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }
#endif

    // Make sure proprietary ISDN options are disabled if more than one link
    // is enabled.  The proprietary ISDN option is only meaningful when
    // calling a down-level server that needs Digiboard channel aggragation
    // instead of PPP multi-link.
    //
//  {
//      DTLNODE* pNode;
//      DWORD cIsdnLinks;

//      cIsdnLinks = 0;
//      for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//           pNode;
//           pNode = DtlGetNextNode( pNode ))
//      {
//          PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//          ASSERT(pLink);

//          if (pLink->fEnabled && pLink->pbport.pbdevicetype == PBDT_Isdn)
//          {
//              ++cIsdnLinks;
//          }
//      }

//      if (cIsdnLinks > 1)
//      {
//          for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//               pNode;
//               pNode = DtlGetNextNode( pNode ))
//          {
//              PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//              ASSERT(pLink);

//              if (pLink->fEnabled && pLink->fProprietaryIsdn)
//              {
//                  pLink->fProprietaryIsdn = FALSE;
//              }
//          }
//      }
//  }

    // Inform user that edits to the connected entry won't take affect until
    // the entry is hung up and re-dialed, per PierreS's insistence.
    //
//  if (HrasconnFromEntry( pInfo->pArgs->pFile->pszPath, pEntry->pszEntryName ))
//  {
//      MsgDlg( pInfo->hwndDlg, SID_EditConnected, NULL );
//  }

    // It's a valid new/changed entry.  Commit the changes to the phonebook
    // and preferences.  This occurs immediately in "ShellOwned" mode where
    // the RasEntryDlg API has already returned, but is otherwise deferred
    // until the API is ready to return.
    //
//  if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
//  {
        EuCommit( pInfo->pArgs );
//  }
//  else
//  {
//      pInfo->pArgs->fCommit = TRUE;
//  }
    return TRUE;
}

BOOL EuCommit(IN EINFO* pInfo )
{
    // Commits the new or changed entry node to the phonebook file and list.
    // Also adds the area code to the per-user list, if indicated.  'PInfo' is
    // the common entry information block.
    //
    // Returns true if successful, false otherwise.
    //
    DWORD dwErr;
//  BOOL fEditMode;
//  BOOL fChangedNameInEditMode;

    // If shared phone number, copy the phone number information from the
    // shared link to each enabled link.
    //
//  if (pInfo->pEntry->fSharedPhoneNumbers)
//  {
//      DTLNODE* pNode;

//      ASSERT( pInfo->pEntry->dwType == RASET_Phone );

//      for (pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//           pNode;
//           pNode = DtlGetNextNode( pNode ))
//      {
//          PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//          ASSERT(pLink);

//          if (pLink->fEnabled)
//          {
//              CopyLinkPhoneNumberInfo( pNode, pInfo->pSharedNode );
//          }
//      }
//  }

    // Delete all disabled link nodes.
    //
//  if (pInfo->fMultipleDevices)
//  {
//      DTLNODE* pNode;

//      pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      while (pNode)
//      {
//          PBLINK*  pLink = (PBLINK* )DtlGetData( pNode );
//          DTLNODE* pNextNode = DtlGetNextNode( pNode );

//          if (!pLink->fEnabled)
//          {
//              DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNode );
//              DestroyLinkNode( pNode );
//          }

//          pNode = pNextNode;
//      }
//  }

    // pmay: 277801
    //
    // Update the preferred device if the one selected is different
    // from the device this page was initialized with.
    //
//  if ((pInfo->fMultipleDevices) &&
//      (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1))
//  {
//      DTLNODE* pNodeL;
//      PBLINK* pLink;
//      BOOL bUpdatePref = FALSE;

//      pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      pLink = (PBLINK*) DtlGetData( pNodeL );

//      TRACE( "Mult devs, only one selected -- check preferred dev." );

//      if ((pInfo->pszCurDevice == NULL) || (pInfo->pszCurPort == NULL))
//      {
//          TRACE( "No preferred device.  Resetting preferred to current." );
//          bUpdatePref = TRUE;
//      }
//      else if (
//          (lstrcmpi(pInfo->pszCurDevice, pLink->pbport.pszDevice)) ||
//          (lstrcmpi(pInfo->pszCurPort, pLink->pbport.pszPort)))
//      {
//          TRACE( "New device selected as preferred device" );
//          bUpdatePref = TRUE;
//      }
//      if (bUpdatePref)
//      {
//          Free0(pInfo->pEntry->pszPreferredDevice);
//          Free0(pInfo->pEntry->pszPreferredPort);

//          pInfo->pEntry->pszPreferredDevice =
//              StrDup(pLink->pbport.pszDevice);
//          pInfo->pEntry->pszPreferredPort =
//              StrDup(pLink->pbport.pszPort);
//      }
//  }

    // Save preferences if they've changed.
    //
//  if (pInfo->pUser->fDirty)
//  {
//      INTERNALARGS *pIArgs = (INTERNALARGS *)pInfo->pApiArgs->reserved;

//      if (g_pSetUserPreferences(
//              (pIArgs) ? pIArgs->hConnection : NULL,
//              pInfo->pUser,
//              (pInfo->fRouter) ? UPM_Router : UPM_Normal ) != 0)
//      {
//          return FALSE;
//      }
//  }

    // Save the changed phonebook entry.
    //
//  pInfo->pEntry->fDirty = TRUE;

    // The final name of the entry is output to caller via API structure.
    //
//  lstrcpyn(
//      pInfo->pApiArgs->szEntry,
//      pInfo->pEntry->pszEntryName,
//      RAS_MaxEntryName + 1);

    // Delete the old node if in edit mode, then add the new node.
    //
//  EuGetEditFlags( pInfo, &fEditMode, &fChangedNameInEditMode );

//  if (fEditMode)
//  {
//      DtlDeleteNode( pInfo->pFile->pdtllistEntries, pInfo->pOldNode );
//  }

//  DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pInfo->pNode );
//  pInfo->pNode = NULL;

    // Write the change to the phone book file.
    //
//  dwErr = WritePhonebookFile( pInfo->pFile,
//              (fChangedNameInEditMode) ? pInfo->szOldEntryName : NULL );

//  if (dwErr != 0)
//  {
//      ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_WritePhonebook, dwErr,
//          NULL );
//      // shaunco - fix RAID 171651 by assigning dwErr to callers structure.
//      pInfo->pApiArgs->dwError = dwErr;
//      return FALSE;
//  }

    // Notify through rasman that the entry has changed
    //
//  if(pInfo->pApiArgs->dwFlags & (RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry))
//  {
//      dwErr = DwSendRasNotification(
//                      ENTRY_ADDED,
//                      pInfo->pEntry,
//                      pInfo->pFile->pszPath);
//  }
//  else
//  {
//      dwErr = DwSendRasNotification(
//                      ENTRY_MODIFIED,
//                      pInfo->pEntry,
//                      pInfo->pFile->pszPath);

//  }

    // Ignore the error returned from DwSendRasNotification - we don't want
    // to fail the operation in this case. The worst case scenario is that
    // the connections folder won't refresh automatically.
    //
//  dwErr = ERROR_SUCCESS;

    // If EuCommit is being called as a result of completing the "new demand
    // dial interface" wizard, then we need to create the new demand dial
    // interface now.
    //
//  if ( EuRouterInterfaceIsNew( pInfo ) )
//  {
        //Create Router MPR interface and save user credentials
        //like UserName, Domain and Password
        //IPSec credentials are save in EuCredentialsCommitRouterIPSec
        //

//      dwErr = EuRouterInterfaceCreate( pInfo );

        // If we weren't successful at commiting the interface's
        // credentials, then delete the new phonebook entry.
        //
//      if ( dwErr != NO_ERROR )
//      {
//          WritePhonebookFile( pInfo->pFile, pInfo->pApiArgs->szEntry );
//          pInfo->pApiArgs->dwError = dwErr;
//          return FALSE;
//      }

//  }

    // Now save any per-connection credentials
    //
//  dwErr = EuCredentialsCommit( pInfo );

   // If we weren't successful at commiting the interface's
  // credentials, then delete the new phonebook entry.
   //
// if ( dwErr != NO_ERROR )
//  {
//      ErrorDlg( pInfo->pApiArgs->hwndOwner,
//                SID_OP_CredCommit,
//                dwErr,
//                NULL );

//      pInfo->pApiArgs->dwError = dwErr;

//     return FALSE;
//  }

    // Save the default Internet connection settings as appropriate.  Igonre
    // the error returned as failure to set the connection as default need
    // not prevent the connection/interface creation.
    //
//  dwErr = EuInternetSettingsCommitDefault( pInfo );
//  dwErr = NO_ERROR;

    // If the user edited/created a router-phonebook entry, store the bitmask
    // of selected network-protocols in 'reserved2'.
    //
//  if (pInfo->fRouter)
//  {
//      pInfo->pApiArgs->reserved2 =
//          ((NP_Ip | NP_Ipx) & ~pInfo->pEntry->dwfExcludedProtocols);
//  }

    // Commit the user's changes to home networking settings.
    // Ignore the return value.
    //
    dwErr = EuHomenetCommitSettings(pInfo);
    dwErr = NO_ERROR;

//  pInfo->pApiArgs->dwError = 0;
    return TRUE;
}

DWORD EuHomenetCommitSettings(IN EINFO* pInfo)
{
    HRESULT hr = S_OK;
    ULONG ulcPublic;
    ULONG ulcPrivate;
    BOOL fPrivateConfigured = FALSE;
    HNET_CONN_PROPERTIES *pProps;
    DWORD dwErr = NO_ERROR;


    if (pInfo->fRouter)
    {
        return NO_ERROR;
    }

    if (!!pInfo->fShared != !!pInfo->fNewShared)
    {
        if (pInfo->fShared)
        {
            hr = pInfo->pIcsSettings->DisableIcs (&ulcPublic, &ulcPrivate);
        }
        else
        {
            // Check to see if the private connection is
            // already properly configured
            //

            hr = pInfo->pPrivateLanConnection->GetProperties (&pProps);
            if (SUCCEEDED(hr))
            {
                fPrivateConfigured = !!pProps->fIcsPrivate;
                CoTaskMemFree(pProps);
            }

            if (pInfo->fOtherShared)
            {
                if (fPrivateConfigured)
                {
                    // Using the same private connection, so
                    // only modify the old public
                    //

                    ASSERT(NULL != pInfo->pOldSharedConnection);
                    hr = pInfo->pOldSharedConnection->Unshare();
                }
                else
                {
                    hr = pInfo->pIcsSettings->DisableIcs (&ulcPublic, &ulcPrivate);
                }
            }

            if (SUCCEEDED(hr))
            {
                IHNetIcsPublicConnection *pIcsPublic;
                IHNetIcsPrivateConnection *pIcsPrivate;

                hr = pInfo->pHNetConn->SharePublic (&pIcsPublic);
                if (SUCCEEDED(hr))
                {
                    if (!fPrivateConfigured)
                    {
                        hr = pInfo->pPrivateLanConnection->SharePrivate (&pIcsPrivate);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPrivate->Release();
                        }
                        else
                        {
                            pIcsPublic->Unshare();
                        }
                    }
                    pIcsPublic->Release();
                }
            }

            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT))
            {
                MsgDlg(pInfo->hwndOwner, SID_SharingConflict, NULL);
            }
            else if (FAILED(hr))
            {
                if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
                {
                    dwErr = HRESULT_CODE(hr);
                }
                else
                {
                    dwErr = (DWORD) hr;
                }

                ErrorDlg(
                    pInfo->hwndOwner,
                    pInfo->fShared
                    ? SID_OP_UnshareConnection : SID_OP_ShareConnection,
                    dwErr, NULL );
            }
        }
    }
    else if (pInfo->fResetPrivateAdapter && pInfo->dwLanCount)
    {

        IHNetIcsPrivateConnection *pIcsPrivateConnection;
        hr = pInfo->pPrivateLanConnection->SharePrivate(&pIcsPrivateConnection);
        if (SUCCEEDED(hr))
        {
            pIcsPrivateConnection->Release();
        }
        else
        {
            ULONG ulPublicCount, ulPrivateCount;
            HRESULT hr2 = pInfo->pIcsSettings->DisableIcs(&ulPublicCount, &ulPrivateCount);
            if (SUCCEEDED(hr2))
            {
                pInfo->fShared = FALSE;
            }

            ErrorDlg(pInfo->hwndOwner, SID_OP_ShareConnection, hr, NULL );
        }
    }

    if (!!pInfo->fDemandDial != !!pInfo->fNewDemandDial)
    {
        dwErr = RasSetSharedAutoDial(pInfo->fNewDemandDial);
        if (dwErr)
        {
            ErrorDlg(
                pInfo->hwndOwner,
                pInfo->fDemandDial
                ? SID_OP_DisableDemandDial : SID_OP_EnableDemandDial,
                dwErr, NULL );
        }
    }

    HKEY hKey;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, NULL, 0, KEY_SET_VALUE, NULL, &hKey, NULL))
    {
        DWORD dwData = pInfo->fNewBeaconControl;
        RegSetValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, REG_DWORD, reinterpret_cast<LPBYTE>(&dwData), sizeof(dwData));
        RegCloseKey(hKey);
    }

    // Commit changes to firewall settings
    //
    if (!!pInfo->fFirewalled != !!pInfo->fNewFirewalled)
    {
        IHNetFirewalledConnection *pFwConn;

        if (pInfo->fNewFirewalled)
        {
            hr = pInfo->pHNetConn->Firewall (&pFwConn);
            if (SUCCEEDED(hr))
            {
                pFwConn->Release();
            }
        }
        else
        {
            hr = pInfo->pHNetConn->GetControlInterface (
                                IID_IHNetFirewalledConnection,
                                (void**)&pFwConn);
            if (SUCCEEDED(hr))
            {
                hr = pFwConn->Unfirewall();
                pFwConn->Release();
            }
        }

        if (FAILED(hr))
        {
            if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
            {
                dwErr = HRESULT_CODE(hr);
            }
            else
            {
                dwErr = (DWORD) hr;
            }

            ErrorDlg(
                pInfo->hwndOwner,
                pInfo->fFirewalled
                ? SID_OP_UnshareConnection : SID_OP_ShareConnection,
                dwErr, NULL );
        }
    }


    return dwErr;
}

HRESULT APIENTRY
HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu)
{
    HRESULT hr;

    hr = CoCreateInstance (CLSID_NetConnectionUiUtilities, NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_INetConnectionUiUtilities, (void**)ppncuu);
    return hr;
}

// --------------------------------------------------------------------------
// exported function here
// --------------------------------------------------------------------------

static LPDLGTEMPLATE CopyDialogTemplate (HINSTANCE hinst, LPCWSTR wszResource)
{
    LPDLGTEMPLATE lpdtCopy = NULL;

    HRSRC hrsrc = FindResourceW (hinst, wszResource, (LPCWSTR)RT_DIALOG);
    if (hrsrc) {
        HGLOBAL hg = LoadResource (hinst, hrsrc);
        if (hg) {
            LPDLGTEMPLATE lpdt = (LPDLGTEMPLATE) LockResource (hg);
            if (lpdt) {
                DWORD dwSize = SizeofResource (hinst, hrsrc);
                if (dwSize) {
                    lpdtCopy = (LPDLGTEMPLATE)Malloc (dwSize);
                    if (lpdtCopy) {
                        CopyMemory (lpdtCopy, lpdt, dwSize);
                    }
                }
            }
        }
    }
    return lpdtCopy;
}

void SetSAUIhInstance (HINSTANCE hInstance)
{
    _ASSERT (g_hinstDll == NULL);
    _ASSERT (hInstance  != NULL);
    g_hinstDll = hInstance;
}

extern "C" HRESULT HNetGetFirewallSettingsPage (PROPSHEETPAGEW * pPSP, GUID * pGuid)
{
    // zeroth thing:  the PROPSHEETPAGEW struct is different sizes depending
    // on what version of _WIN32_IE and _WIN32_WINNT are set to.  So, check
    // the dwSize field
    if (IsBadWritePtr (pPSP, sizeof(DWORD)))
        return E_POINTER;
    if (IsBadWritePtr (pPSP, pPSP->dwSize))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_SIZE);
    if (pPSP->dwSize < RTL_SIZEOF_THROUGH_FIELD (PROPSHEETPAGEW, lParam))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_SIZE);

    // first thing: check rights
    if (FALSE == FIsUserAdminOrPowerUser ())
        return HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
    {
        // Check if ZAW is denying access to the Shared Access UI
        BOOL fShowAdvancedUi = TRUE;
        INetConnectionUiUtilities* pncuu = NULL;
        HrCreateNetConnectionUtilities(&pncuu);
        if (pncuu)
        {
            if ((FALSE == pncuu->UserHasPermission (NCPERM_ShowSharedAccessUi)) &&
                (FALSE == pncuu->UserHasPermission (NCPERM_PersonalFirewallConfig)))
               fShowAdvancedUi = FALSE;
            pncuu->Release();
        }
        if (FALSE == fShowAdvancedUi)
            return HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
    }

    // setup global(s)
    g_contextId = (LPCTSTR)GlobalAddAtom (TEXT("SAUI"));
    if (!g_contextId)
        return GetLastError();

    PEINFO * pPEINFO = NULL;
    DWORD dwError = PeInit (pGuid, &pPEINFO);
    if (dwError == S_OK) {
        // we need this to init the link
        LinkWindow_RegisterClass(); // no need to ever unregister:  see ...\shell\shell32\linkwnd.cpp

        // fill out PSP:
        DWORD dwSize;
        ZeroMemory (pPSP, dwSize = pPSP->dwSize);
        pPSP->dwSize          = dwSize;
        pPSP->dwFlags         = 0;
        LPDLGTEMPLATE lpdt    = CopyDialogTemplate (g_hinstDll, MAKEINTRESOURCE (PID_SA_Advanced));
        if (lpdt) {
            // avoid idd collisions
            pPSP->dwFlags    |= PSP_DLGINDIRECT;
            pPSP->pResource   = lpdt;
            pPEINFO->lpdt     = lpdt;   // hang it here so I can free it
        } else  // if all else fails... (this should never happen).
            pPSP->pszTemplate = MAKEINTRESOURCE (PID_SA_Advanced);
        pPSP->hInstance       = g_hinstDll;
        pPSP->pfnDlgProc      = SaDlgProc;
        pPSP->lParam          = (LPARAM)pPEINFO;
    }
    return dwError;
}

//
//  Figure out if this is a single user connection.  If it is, then we need
//  to give them an error that explains that they should be using an all user
//  connection instead.
//  If this is an All-User connection, warn them if they don't have global credentials
//
VOID VerifyConnTypeAndCreds(IN PEINFO* pInfo)
{
    if (NULL == pInfo)
    {
        return;
    }

    BOOL fAllUser = FALSE;
    TCHAR szAppData[MAX_PATH+1]={0};

    HINSTANCE hinstDll = LoadLibrary (TEXT("shfolder.dll"));;
    
    if (hinstDll)
    {
        typedef HRESULT (*pfnGetFolderPathFunction) (HWND, int, HANDLE, DWORD, LPTSTR);
#ifdef UNICODE
        pfnGetFolderPathFunction pfnGetFolderPath = (pfnGetFolderPathFunction)GetProcAddress (hinstDll, "SHGetFolderPathW");
#else
        pfnGetFolderPathFunction pfnGetFolderPath = (pfnGetFolderPathFunction)GetProcAddress (hinstDll, "SHGetFolderPathA");
#endif

        if (pfnGetFolderPath && pInfo->pArgs->pEntry->pszEntryName)
        {
            HRESULT hr = pfnGetFolderPath(pInfo->hwndDlg , CSIDL_COMMON_APPDATA, NULL, 0, szAppData);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                //
                //  Okay, now we have the path to the common application data directory.
                //  Let's compare that against the phonebook path that we have and see
                //  if this is an all user connection or not.
                //
                const TCHAR* const c_pszRelativePbkPath = TEXT("\\Microsoft\\Network\\Connections\\Pbk");
                DWORD dwSize = (lstrlen(szAppData) + lstrlen(c_pszRelativePbkPath) + 1) * sizeof(TCHAR);
                LPTSTR pszAllUserPhoneBookDir =  (LPTSTR)Malloc(dwSize);
                
                if (pszAllUserPhoneBookDir)
                {
                    wsprintf(pszAllUserPhoneBookDir, TEXT("%s%s"), szAppData, c_pszRelativePbkPath);
                            
                    //
                    // Compare
                    //
                    if (pInfo->pArgs->pEntry->pszPhonebookPath)
                    {
                        LPTSTR pszAllUser = _tcsstr(pInfo->pArgs->pEntry->pszPhonebookPath, pszAllUserPhoneBookDir);

                        if (pszAllUser)
                        {
                            fAllUser = TRUE;
                        }
                        else
                        {
                            //
                            //  If the phonebook path wasn't based on the common app data dir, check to see
                            //  if it was based on the old ras phonebook location %windir%\system32\ras.
                            //
                            HRESULT hr2 = pfnGetFolderPath(pInfo->hwndDlg , CSIDL_SYSTEM, NULL, 0, szAppData);
                            if (SUCCEEDED(hr2) && (S_FALSE != hr2))
                            {
                                const TCHAR* const c_pszRas = TEXT("\\Ras");
                                DWORD dwSize2 = (lstrlen(szAppData) + lstrlen(c_pszRas) + 1) * sizeof(TCHAR);
                                LPTSTR pszOldRasPhoneBook = (LPTSTR)Malloc(dwSize2);

                                if (pszOldRasPhoneBook)
                                {
                                    wsprintf(pszOldRasPhoneBook, TEXT("%s%s"), szAppData, c_pszRas);

                                    LPTSTR pszAllUser = _tcsstr(pInfo->pArgs->pEntry->pszPhonebookPath, pszOldRasPhoneBook);
                                    
                                    if (pszAllUser)
                                    {
                                        fAllUser = TRUE;
                                    }                        
                                }
                                Free0(pszOldRasPhoneBook);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Phone book string is null - using default RAS phonebook which is for all users
                        //
                        fAllUser = TRUE;
                    }

                    // 
                    // Finally check if we have the proper credentials for an all user profile. If not then
                    // prompt user to create and save global credentials (option A).
                    // or display a message that an all-user profile is needed (option B)
                    //
                    if (fAllUser)
                    {
                        //
                        // Check if we have global passwords
                        //
                        BOOL fUserCreds = FALSE;
                        BOOL fGlobalCreds = FALSE;

                        FindEntryCredentials(pInfo->pArgs->pEntry->pszPhonebookPath, 
                                             pInfo->pArgs->pEntry->pszEntryName, 
                                             &fUserCreds, 
                                             &fGlobalCreds);

                        if (FALSE == fGlobalCreds)
                        {
                            //
                            // need to display warning message (A) - should have global creds
                            //
                            MSGARGS msgargs;
                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                            MsgDlg( pInfo->hwndDlg, IDS_ALL_USER_CONN_MUST_HAVE_GLOBAL_CREDS, &msgargs );
                        }
                    }
                    else
                    {
                        //
                        // need to display warning message (B) - should create an all-user connection
                        //
                        MSGARGS msgargs;
                        ZeroMemory( &msgargs, sizeof(msgargs) );
                        msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                        MsgDlg( pInfo->hwndDlg, IDS_PER_USER_CONN_NEED_TO_CREATE_ALL_USER_CONN, &msgargs );
                    }
                }
                Free0(pszAllUserPhoneBookDir);
            }
        }

        FreeLibrary(hinstDll);
    }
}

//
// All of this function is taken from RAS - rasdlg - dial.c 
// with some parts removed since we didn't need them here.
//
DWORD 
FindEntryCredentials(
    IN  TCHAR* pszPath,
    IN  TCHAR* pszEntryName,
    OUT BOOL* pfUser,               // set true if per user creds found
    OUT BOOL* pfGlobal              // set true if global creds found
    )

// Loads the credentials for the given entry into memory.  This routine 
// determines whether per-user or per-connection credentials exist or 
// both. 
// 
// The logic is a little complicated because RasGetCredentials had to 
// support legacy usage of the API.
//
// Here's how it works.  If only one set of credentials is stored for a 
// connection, then RasGetCredentials will return that set regardless of 
// whether the RASCM_DefalutCreds flag is set.  If two sets of credentials
// are saved, then RasGetCredentials will return the per-user credentials
// if the RASCM_DefaultCreds bit is set, and the per-connection credentials
// otherwise.
//
// Here is the algorithm for loading the credentials
//
// 1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//    1a. If nothing is returned, no credentials are saved
//    1b. If the RASCM_DefaultCreds bit is set on return, then only
//        global credentials are saved.
//
// 2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//    2a. If the RASCM_DefaultCreds bit is set on return, then 
//        both global and per-connection credentials are saved.
//    2b. Otherwise, only per-user credentials are saved.
//
{
    DWORD dwErr;
    RASCREDENTIALS rc1, rc2;
    BOOL fUseLogonDomain;

    TRACE( "saui.cpp - FindEntryCredentials" );

    // Initialize
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    ZeroMemory( &rc1, sizeof(rc1) );
    ZeroMemory( &rc2, sizeof(rc2) );
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    if (NULL == pszPath || NULL == pszEntryName)
    {
        return (DWORD)-1; 
    }

    do 
    {
        // Look up per-user cached username, password, and domain.
        // See comment '1.' in the function header
        //
        rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
        TRACE( "RasGetCredentials per-user" );
        dwErr = RasGetCredentials(pszPath, pszEntryName, &rc1 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc1.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 1a. in the function header comments
        //
        if (rc1.dwMask == 0)
        {
            dwErr = NO_ERROR;
            break;
        }

        // See 1b. in the function header comments
        //
        else if (rc1.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;
            dwErr = NO_ERROR;
            break;
        }

        // Look up global per-user cached username, password, domain.
        // See comment 2. in the function header
        //
        rc2.dwMask =  
            RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;

        TRACE( "RasGetCredentials global" );
        
        dwErr = RasGetCredentials(pszPath, pszEntryName, &rc2 );
        
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc2.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 2a. in the function header comments
        //
        if (rc2.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }
        }

        // See 2b. in the function header comments
        //
        else
        {
            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }
        }

    }while (FALSE);

    // Cleanup
    //
    ZeroMemory( rc1.szPassword, sizeof(rc1.szPassword) );
    ZeroMemory( rc2.szPassword, sizeof(rc2.szPassword) );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\hncstrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C S T R S . C P P
//
//  Contents:   Constant string definitions
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

const OLECHAR c_wszNamespace[] = L"\\\\.\\Root\\Microsoft\\HomeNet";
const OLECHAR c_wszWQL[] = L"WQL";
const OLECHAR c_wszStar[] = L"*";
const OLECHAR c_wszHnetConnection[] = L"HNet_Connection";
const OLECHAR c_wszHnetProperties[] = L"HNet_ConnectionProperties";
const OLECHAR c_wszHnetApplicationProtocol[] = L"HNet_ApplicationProtocol";
const OLECHAR c_wszHnetPortMappingProtocol[] = L"HNet_PortMappingProtocol";
const OLECHAR c_wszHnetConnectionPortMapping[] = L"HNet_ConnectionPortMapping2";
const OLECHAR c_wszHnetFWLoggingSettings[] = L"HNet_FirewallLoggingSettings";
const OLECHAR c_wszHnetIcsSettings[] = L"HNet_IcsSettings";
const OLECHAR c_wszHnetResponseRange[] = L"HNet_ResponseRange";
const OLECHAR c_wszPath[] = L"Path";
const OLECHAR c_wszMaxFileSize[] = L"MaxFileSize";
const OLECHAR c_wszLogDroppedPackets[] = L"LogDroppedPackets";
const OLECHAR c_wszLogConnections[] = L"LogConnections";
const OLECHAR c_wszDhcpEnabled[] = L"DhcpEnabled";
const OLECHAR c_wszDnsEnabled[] = L"DnsEnabled";

const OLECHAR c_wszName[] = L"Name";
const OLECHAR c_wszDeviceName[] = L"DeviceName";
const OLECHAR c_wszEnabled[] = L"Enabled";
const OLECHAR c_wszBuiltIn[] = L"BuiltIn";
const OLECHAR c_wszOutgoingIPProtocol[] = L"OutgoingIPProtocol";
const OLECHAR c_wszOutgoingPort[] = L"OutgoingPort";
const OLECHAR c_wszResponseCount[] = L"ResponseCount";
const OLECHAR c_wszResponseArray[] = L"ResponseArray";
const OLECHAR c_wszIPProtocol[] = L"IPProtocol";
const OLECHAR c_wszStartPort[] = L"StartPort";
const OLECHAR c_wszEndPort[] = L"EndPort";
const OLECHAR c_wszPort[] = L"Port";
const OLECHAR c_wszId[] = L"Id";

const OLECHAR c_wszConnection[] = L"Connection";
const OLECHAR c_wszProtocol[] = L"Protocol";
const OLECHAR c_wszTargetName[] = L"TargetName";
const OLECHAR c_wszTargetIPAddress[] = L"TargetIPAddress";
const OLECHAR c_wszTargetPort[] = L"TargetPort";
const OLECHAR c_wszNameActive[] = L"NameActive";

const OLECHAR c_wszIsLanConnection[] = L"IsLanConnection";
const OLECHAR c_wszIsFirewalled[] = L"IsFirewalled";
const OLECHAR c_wszIsIcsPublic[] = L"IsIcsPublic";
const OLECHAR c_wszIsIcsPrivate[] = L"IsIcsPrivate";
const OLECHAR c_wszIsBridgeMember[] = L"IsBridgeMember";
const OLECHAR c_wszIsBridge[] = L"IsBridge";
const OLECHAR c_wszPhonebookPath[] = L"PhonebookPath";
const OLECHAR c_wszGuid[] = L"Guid";

const OLECHAR c_wszHnetFwIcmpSettings[] = L"HNet_FwIcmpSettings";
const OLECHAR c_wszAllowOutboundDestinationUnreachable[] = L"AllowOutboundDestinationUnreachable";
const OLECHAR c_wszAllowOutboundSourceQuench[] = L"AllowOutboundSourceQuench";
const OLECHAR c_wszAllowRedirect[] = L"AllowRedirect";
const OLECHAR c_wszAllowInboundEchoRequest[] = L"AllowInboundEchoRequest";
const OLECHAR c_wszAllowInboundRouterRequest[] = L"AllowInboundRouterRequest";
const OLECHAR c_wszAllowOutboundTimeExceeded[] = L"AllowOutboundTimeExceeded";
const OLECHAR c_wszAllowOutboundParameterProblem[] = L"AllowOutboundParameterProblem";
const OLECHAR c_wszAllowInboundTimestampRequest[] = L"AllowInboundTimestampRequest";
const OLECHAR c_wszAllowInboundMaskRequest[] = L"AllowInboundMaskRequest";
const OLECHAR c_wszDefault[] = L"Default";
const OLECHAR c_wszDefaultIcmpSettingsPath[] = L"HNet_FwIcmpSettings.Name=\"Default\"";

const OLECHAR c_wszHnetConnectionIcmpSetting[] = L"HNet_ConnectionIcmpSetting";
const OLECHAR c_wszIcmpSettings[] = L"IcmpSettings";

const OLECHAR c_wszHnetBridgeMember[] = L"HNet_BridgeMember";
const OLECHAR c_wszBridge[] = L"Bridge";
const OLECHAR c_wszMember[] = L"Member";

const OLECHAR c_wszSelect[] = L"SELECT";
const OLECHAR c_wszFrom[] = L"FROM";
const OLECHAR c_wszWhere[] = L"WHERE";
const OLECHAR c_wsz__Path[] = L"__Relpath";
const OLECHAR c_wszReferencesOf[] = L"REFERENCES OF {";
const OLECHAR c_wszWhereResultClass[] = L"} WHERE ResultClass = ";
const OLECHAR c_wszAssociatorsOf[] = L"ASSOCIATORS OF {";
const OLECHAR c_wszWhereAssocClass[] = L"} WHERE AssocClass = ";

const OLECHAR c_wszPortMappingProtocolQueryFormat[] = L"Port = %u AND IPProtocol = %u";
const OLECHAR c_wszApplicationProtocolQueryFormat[] = L"OutgoingPort = %u AND OutgoingIPProtocol = %u";
const OLECHAR c_wszConnectionPropertiesPathFormat[] = L"HNet_ConnectionProperties.Connection=\"HNet_Connection.Guid=\\\"%s\\\"\"";

const OLECHAR c_wszBackupIpConfiguration[] = L"HNet_BackupIpConfiguration";
const OLECHAR c_wszEnableDHCP[] = L"EnableDHCP";
const OLECHAR c_wszInterfaces[] = L"Interfaces";
const OLECHAR c_wszIPAddress[] = L"IPAddress";
const OLECHAR c_wszSubnetMask[] = L"SubnetMask";
const OLECHAR c_wszDefaultGateway[] = L"DefaultGateway";
const OLECHAR c_wszTcpipParametersKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip"
    L"\\Parameters";
const OLECHAR c_wszZeroIpAddress[] = L"0.0.0.0";

const OLECHAR c_wszSharedAccess[] = L"SharedAccess";
const OLECHAR c_wszDevice[] = L"\\Device\\";
const OLECHAR c_wszServiceCheckQuery[] =
    L"SELECT * FROM HNet_ConnectionProperties WHERE IsFirewalled != FALSE"
    L" or IsIcsPublic != FALSE or IsIcsPrivate != FALSE";

const OLECHAR c_wszHnetConnectionAutoconfig[] = L"HNet_ConnectionAutoconfig";

// ICS Upgrade named event (has to be the same name in net\config\shell\netsetup\icsupgrd.h)
const OLECHAR c_wszIcsUpgradeEventName[] = L"IcsUpgradeEventName_";

//
// Commonly used string lengths. Generating these at compile time
// saves us a large number of wcslen calls. On debug builds, these
// values are compared with the output of wcslen, and an assertion is
// raised if the values do not match.
//

#define STRING_LENGTH(pwz) \
    (sizeof((pwz)) / sizeof((pwz)[0]) - 1)

const ULONG c_cchSelect = STRING_LENGTH(c_wszSelect);
const ULONG c_cchFrom = STRING_LENGTH(c_wszFrom);
const ULONG c_cchWhere = STRING_LENGTH(c_wszWhere);
const ULONG c_cchReferencesOf = STRING_LENGTH(c_wszReferencesOf);
const ULONG c_cchWhereResultClass = STRING_LENGTH(c_wszWhereResultClass);
const ULONG c_cchAssociatorsOf = STRING_LENGTH(c_wszAssociatorsOf);
const ULONG c_cchWhereAssocClass = STRING_LENGTH(c_wszWhereAssocClass);
const ULONG c_cchConnection = STRING_LENGTH(c_wszConnection);
const ULONG c_cchConnectionPropertiesPathFormat = STRING_LENGTH(c_wszConnectionPropertiesPathFormat);

//
// Bindings-related strings
//

const WCHAR c_wszSBridgeMPID[]              = L"ms_bridgemp";
const WCHAR c_wszSBridgeSID[]               = L"ms_bridge";
const WCHAR *c_pwszBridgeBindExceptions[]   = {
                                                L"ms_ndisuio", // Need NDISUIO for wireless adapters; want the wireless UI
                                                               // even when the adapter is bridged.
                                                NULL
                                              };

//
// String constants used for IsRoutingProtocolInstalled.
//

const CHAR c_szMprConfigBufferFree[] = "MprConfigBufferFree";
const CHAR c_szMprConfigServerConnect[] = "MprConfigServerConnect";
const CHAR c_szMprConfigServerDisconnect[] = "MprConfigServerDisconnect";
const CHAR c_szMprConfigTransportGetHandle[] = "MprConfigTransportGetHandle";
const CHAR c_szMprConfigTransportGetInfo[] = "MprConfigTransportGetInfo";
const CHAR c_szMprInfoBlockFind[] = "MprInfoBlockFind";
const WCHAR c_wszMprapiDll[] = L"MPRAPI.DLL";

//
// Strings that are used in WinBom homenet install
//
const TCHAR c_szEnableFirewall[] = _T("EnableFirewall");
const TCHAR c_szYes[] = _T("Yes");
const TCHAR c_szNo[] = _T("No");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hnetcfg.rc
//

#include "resourc2.h"

// used by saui.cpp
#define IID_Direct                      561
#define IID_Phone                       562
#define IID_Vpn                         565

#define SID_EnableSharedAccess          511
#define SID_ChangeSharedConnection      509

// rasdlg advanced page
#define PID_SA_Advanced                 543
#define CID_SA_ST_HomeConnection        101
#define CID_SA_PB_Beacon                102
#define IID_PersonalFirewall            573
#define CID_FW_PB_Firewalled            15026
#define CID_SA_GB_PrivateLan            1518
#define CID_SA_GB_Shared                1517
#define IID_Dun1                        136
#define CID_SA_PB_Shared                15022
#define CID_SA_LB_PrivateLan            1516
#define CID_SA_EB_PrivateLan            1521
#define CID_SA_PB_DemandDial            15023
#define CID_SA_SF_PrivateLan            1519
#define CID_SA_ST_HNWLink               1659
#define CID_SA_ST_ICFLink               1660
#define CID_SA_ST_ICSLink               1661
#define CID_SA_PB_Settings              1564

#define SID_SA_SelectAdapter            1663
#define SID_SA_SelectAdapterError       1664
#define DID_SA_DisableFirewallWarning   1660
#define CID_SA_PB_DisableFirewallWarning 1662

#define SID_HelpFile                    264
#define HID_SA_PB_Shared                1150
#define HID_SA_PB_DemandDial            1151
#define HID_SA_PB_Settings              1152
#define HID_SA_LB_PrivateLan            1153
#define HID_FW_PB_Firewalled            1154
#define HID_SA_ST_ICFLink               1155
#define HID_SA_EB_PrivateLan            1156
#define HID_SA_PB_Beacon                1157
#define HID_SA_ST_ICSLink               1158
#define HID_SA_ST_HNWLink               1159

#define SID_SharingConflict             194
#define SID_OP_UnshareConnection        319
#define SID_OP_ShareConnection          330
#define SID_OP_DisableDemandDial        502
#define SID_OP_EnableDemandDial         500
#define SID_FMT_ErrorMsg                250

#define IDS_ALL_USER_CONN_MUST_HAVE_GLOBAL_CREDS        17001
#define IDS_PER_USER_CONN_NEED_TO_CREATE_ALL_USER_CONN  17002
// used by sadlg.cpp, etc.
#define PID_FW_FirewallLogging          571
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_EB_Filename              1674
#define CID_FL_PB_Browse                1639
#define CID_FL_EB_Filesize              1640
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_PB_RestoreDefaults       1643
#define SID_SharedAccessSettings        545
#define SID_NetworkApplicationSettings  546
#define PID_FW_ICMP                     572
#define CID_IC_LV_Settings              1644
#define CID_IC_ST_Description           1645
#define SID_OP_LoadDlg                  318

#define SID_TypeResponseList            540
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_ITIME                  1647
#define SID_ICMP_IMASK                  1648
#define SID_ICMP_IROUT                  1649
#define SID_ICMP_ODEST                  1650
#define SID_ICMP_OQNCH                  1651
#define SID_ICMP_OPRAM                  1652
#define SID_ICMP_OTIME                  1653
#define SID_ICMP_XRDRT                  1654
#define SID_ICMP_IECHO_DESC             1665
#define SID_ICMP_ITIME_DESC             1666
#define SID_ICMP_IMASK_DESC             1667
#define SID_ICMP_IROUT_DESC             1668
#define SID_ICMP_ODEST_DESC             1669
#define SID_ICMP_OQNCH_DESC             1670
#define SID_ICMP_OPRAM_DESC             1671
#define SID_ICMP_OTIME_DESC             1672
#define SID_ICMP_XRDRT_DESC             1673
#define SID_FwbInvalidSize              1675
#define SID_FwbFilterDesc               1657
#define SID_FwbTitle                    1658
#define SID_FwbDefExt                   1655

// Shared access settings property sheet, Services page.
//
#define HID_SS_LV_Services              4250
#define HID_SS_PB_Add                   4251
#define HID_SS_PB_Edit                  4252
#define HID_SS_PB_Delete                4253

// Shared access settings property sheet, New Service dialog.
//
#define HID_SS_EB_ExternalPort          4349
#define HID_SS_EB_Service               4350
#define HID_SS_EB_Port                  4351
#define HID_SS_PB_Tcp                   4352
#define HID_SS_PB_Udp                   4353
#define HID_SS_EB_Address               4354

// Firewall Logging settings property sheet
//
#define HID_FL_CB_LogDroppedInbound     4355
#define HID_FL_CB_LogOutboundConnections 4356
#define HID_FL_EB_Filename              4357
#define HID_FL_PB_Browse                4358
#define HID_FL_EB_Filesize              4359
#define HID_FL_PB_RestoreDefaults       4360

// ICMP Settings property sheet
//
#define HID_IC_LV_Settings              4361
#define HID_IC_ST_Description           4362

// ALG Setup confirmation dialog and Error Dialog
//
#define IDD_CONFIRMATION                5000
#define IDC_EDIT_COMPANY                5001
#define IDC_EDIT_PRODUCT                5002
#define IDC_EDIT_PORTS                  5003
#define IDC_EDIT_PORTS2                 5004

#define IDD_INSTALLERROR                5010
#define IDC_EDIT_LASTERROR              5011
#define IDC_EDIT_LASTERROR_CODE         5012

// Display names for default port mappings
//
#define SID_PMP_FTP                     1700
#define SID_PMP_TELNET                  1701
#define SID_PMP_SMTP                    1702
#define SID_PMP_POP3                    1703
#define SID_PMP_IMAP3                   1704
#define SID_PMP_IMAP4                   1705
#define SID_PMP_HTTP                    1706
#define SID_PMP_HTTPS                   1707
#define SID_PMP_RDP                     1708

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        571
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1639
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Home Networking Configuration Manager"
#define VER_INTERNALNAME_STR            "HNETCFG.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\idl\sauclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File: SAUClsId.c
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

// {d851f103-8c90-4321-aff0-58ba5bd421c2}

DEFINE_GUID(CLSID_SAUpdate, 0xd851f103,0x8c90,0x4321,0xaf,0xf0,0x58,0xba,0x5b,0xd4,0x21,0xc2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\sautil.h ===
#ifndef _SAUTIL_H
#define _SAUTIL_H


#include "resource.h"

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)

extern HINSTANCE g_hinstDll;  // in saui.cpp

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

VOID ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam);

VOID AddContextHelpButton (IN HWND hwnd);

/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define MSGARGS struct tagMSGARGS
MSGARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwMsg' string, or
    ** NULLs if none.
    */
    TCHAR* apszArgs[ 9 ];

    /* Currently, as for MessageBox, where defaults if 0 are MB_OK and
    ** MB_ICONINFORMATION.
    */
    DWORD dwFlags;

    /* If non-NULL, specifies a string overriding the loading of the 'dwMsg'
    ** parameter string.
    */
    TCHAR* pszString;

    /* If 'fStringOutput' is true, the MsgDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle );

VOID UnclipWindow (IN HWND hwnd);
VOID CenterWindow (IN HWND hwnd, IN HWND hwndRef);
LRESULT CALLBACK CenterDlgOnOwnerCallWndProc (int code, WPARAM wparam, LPARAM lparam);
TCHAR* PszFromId (IN HINSTANCE hInstance, IN DWORD dwStringId);
TCHAR* GetText (IN HWND hwnd);
BOOL GetErrorText (DWORD dwError, TCHAR** ppszError);

#define ERRORARGS struct tagERRORARGS
ERRORARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwOperation' string,
    ** or NULLs if none.
    */
    TCHAR* apszOpArgs[ 9 ];

    /* Insertion strings for auxillary arguments %4 to %6 in the 'dwFormat'
    ** string, or NULLs if none.  (The standard arguments are %1=the
    ** 'dwOperation' string, %2=the decimal error number, and %3=the
    ** 'dwError'string.)
    */
    TCHAR* apszAuxFmtArgs[ 3 ];

    /* If 'fStringOutput' is true, the ErrorDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat );
int MsgDlgUtil(IN HWND hwndOwner, IN DWORD dwMsg, IN OUT MSGARGS* pargs, IN HINSTANCE hInstance, IN DWORD dwTitle);
#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)



// LVX stuff (cut-n-paste'd from ...\net\rras\ras\ui\common\uiutil\lvx.c, etc.

/* Text indents within a column in pixels.  If you mess with the dx, you're
** asking for misalignment problems with the header labels.  BTW, the first
** column doesn't line up with it's header if there are no icons.  Regular
** list view has this problem, too.  If you try to fix this you'll wind up
** duplicating the AUTOSIZE_USEHEADER option of ListView_SetColumnWidth.
** Should be able to change the dy without causing problems.
*/
#define LVX_dxColText 4
#define LVX_dyColText 1

/* Guaranteed vertical space between icons.  Should be able to mess with this
** without causing problems.
*/
#define LVX_dyIconSpacing 1

#define SI_Unchecked 1
#define SI_Checked   2
#define SI_DisabledUnchecked 3
#define SI_DisabledChecked 4

#define LVXN_SETCHECK (LVN_LAST + 1)
#define LVXN_DBLCLK (LVN_LAST + 2)

/* The extended list view control calls the owner back to find out the layout
** and desired characteristics of the enhanced list view.
*/
#define LVX_MaxCols      10
#define LVX_MaxColTchars 512

/* 'dwFlags' option bits.
*/
#define LVXDI_DxFill     1  // Auto-fill wasted space on right (recommended)
#define LVXDI_Blend50Sel 2  // Dither small icon if selected (not recommended)
#define LVXDI_Blend50Dis 4  // Dither small icon if disabled (recommended)

/* 'adwFlags' option bits.
*/
#define LVXDIA_3dFace 1  // Column is not editable but other columns are
#define LVXDIA_Static 2  // Emulates static text control w/icon if disabled

/* Returned by owner at draw item time.
*/
#define LVXDRAWINFO struct tagLVXDRAWINFO
LVXDRAWINFO
{
    /* The number of columns.  The list view extensions require that your
    ** columns are numbered sequentially from left to right where 0 is the
    ** item column and 1 is the first sub-item column.  Required always.
    */
    INT cCols;

    /* Pixels to indent this item, or -1 to indent a "small icon" width.  Set
    ** 0 to disable.
    */
    INT dxIndent;

    /* LVXDI_* options applying to all columns.
    */
    DWORD dwFlags;

    /* LVXDIA_* options applying to individual columns.
    */
    DWORD adwFlags[ LVX_MaxCols ];
};
typedef LVXDRAWINFO* (*PLVXCALLBACK)( IN HWND, IN DWORD dwItem );


BOOL ListView_IsCheckDisabled (IN HWND hwndLv, IN INT  iItem);
VOID ListView_SetCheck (IN HWND hwndLv, IN INT iItem, IN BOOL fCheck);
VOID* ListView_GetParamPtr(IN HWND hwndLv, IN INT iItem);
BOOL ListView_GetCheck(IN HWND hwndLv, IN INT iItem);
LRESULT APIENTRY LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );
BOOL ListView_InstallChecks(IN HWND hwndLv, IN HINSTANCE hinst);
VOID ListView_InsertSingleAutoWidthColumn (HWND hwndLv);
TCHAR* Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL);
BOOL LvxDrawItem(IN DRAWITEMSTRUCT* pdis, IN PLVXCALLBACK pLvxCallback);
BOOL LvxMeasureItem(IN HWND hwnd, IN OUT MEASUREITEMSTRUCT* pmis);
BOOL ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback );

TCHAR* _StrDup(LPCTSTR psz);
TCHAR* StrDupTFromW (LPCWSTR psz);
WCHAR* StrDupWFromT (LPCTSTR psz);
void  IpHostAddrToPsz(IN DWORD dwAddr, OUT LPTSTR pszBuffer);
DWORD IpPszToHostAddr(IN LPCTSTR cp);

VOID* Free0 (VOID* p);

HRESULT ActivateLuna(HANDLE* phActivationContext, ULONG_PTR* pulCookie);
HRESULT DeactivateLuna(HANDLE hActivationContext, ULONG_PTR ulCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\dll\sautil.cpp ===
//#include "pch.h"
#pragma hdrstop

#include "sautil.h"

BOOL g_fNoWinHelp = FALSE;

VOID ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam)
    // Calls WinHelp to popup context sensitive help.  'PadwMap' is an array
    // of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
    // WM_HELP or WM_CONTEXTMENU indicating the message received requesting
    // help.  'Wparam' and 'lparam' are the parameters of the message received
    // requesting help.
    //
{
    HWND hwnd;
    UINT unType;
    TCHAR* pszHelpFile;

    ASSERT( unMsg==WM_HELP || unMsg==WM_CONTEXTMENU );

    // Don't try to do help if it won't work.  See common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;
        if (g_fNoWinHelp)
        {
            return;
        }
    }

    if (unMsg == WM_HELP)
    {
        LPHELPINFO p = (LPHELPINFO )lparam;;

        TRACE3( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return;
        }

        hwnd = (HWND)p->hItemHandle;
        ASSERT( hwnd );
        unType = HELP_WM_HELP;
    }
    else
    {
        // Standard Win95 method that produces a one-item "What's This?" menu
        // that user must click to get help.
        //
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );

        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    };

//    if (fRouter)
//    {
//        pszHelpFile = g_pszRouterHelpFile;
//    }
//    else
//    {
//      pszHelpFile = g_pszHelpFile;
//    }
    pszHelpFile = PszFromId (g_hinstDll, SID_HelpFile );

    TRACE1( "WinHelp(%s)", pszHelpFile );
    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR ) padwMap );

    Free0 (pszHelpFile);
}

VOID
AddContextHelpButton(
    IN HWND hwnd )

    /* Turns on title bar context help button in 'hwnd'.
    **
    ** Dlgedit.exe doesn't currently support adding this style at dialog
    ** resource edit time.  When that's fixed set DS_CONTEXTHELP in the dialog
    ** definition and remove this routine.
    */
{
    LONG lStyle;

    if (g_fNoWinHelp)
        return;

    lStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if (lStyle)
        SetWindowLong( hwnd, GWL_EXSTYLE, lStyle | WS_EX_CONTEXTHELP );
}

/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/

/*----------------------------------------------------------------------------
** Message popup
**----------------------------------------------------------------------------
*/

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle )

    /* Pops up a message dialog centered on 'hwndOwner'.  'DwMsg' is the
    ** string resource ID of the message text.  'Pargs' is a extended
    ** formatting arguments or NULL if none.  'hInstance' is the
    ** application/module handle where string resources are located.
    ** 'DwTitle' is the string ID of the dialog title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("MsgDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the message string.
    */
    pszResult = pszNotFound;

    if (pargs && pargs->pszString)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pargs->pszString, 0, 0, (LPTSTR )&pszResult, 1,
            (va_list* )pargs->apszArgs );
    }
    else
    {
        pszUnformatted = PszFromId( hInstance, dwMsg );

        if (pszUnformatted)
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING +
                    FORMAT_MESSAGE_ALLOCATE_BUFFER +
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszUnformatted, 0, 0, (LPTSTR )&pszResult, 1,
                (va_list* )((pargs) ? pargs->apszArgs : NULL) );

            Free( pszUnformatted );
        }
    }

    if (!pargs || !pargs->fStringOutput)
    {
        TCHAR* pszTitle;
        DWORD  dwFlags;
        HHOOK  hhook;

        if (pargs && pargs->dwFlags != 0)
            dwFlags = pargs->dwFlags;
        else
            dwFlags = MB_ICONINFORMATION + MB_OK + MB_SETFOREGROUND;

        pszTitle = PszFromId( hInstance, dwTitle );

        if (hwndOwner)
        {
            /* Install hook that will get the message box centered on the
            ** owner window.
            */
            hhook = SetWindowsHookEx( WH_CALLWNDPROC,
                CenterDlgOnOwnerCallWndProc,
                hInstance, GetCurrentThreadId() );
        }
        else
            hhook = NULL;

        if (pszResult)
        {
            nResult = MessageBox( hwndOwner, pszResult, pszTitle, dwFlags );
        }

        if (hhook)
            UnhookWindowsHookEx( hhook );

        Free0( pszTitle );
        if (pszResult != pszNotFound)
            LocalFree( pszResult );
    }
    else
    {
        /* Caller wants the string without doing the popup.
        */
        pargs->pszOutput = (pszResult != pszNotFound) ? pszResult : NULL;
        nResult = IDOK;
    }

    return nResult;
}


VOID
UnclipWindow(
    IN HWND hwnd )

    /* Moves window 'hwnd' so any clipped parts are again visible on the
    ** screen.  The window is moved only as far as necessary to achieve this.
    */
{
    RECT rect;
    INT  dxScreen = GetSystemMetrics( SM_CXSCREEN );
    INT  dyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    if (rect.right > dxScreen)
        rect.left = dxScreen - (rect.right - rect.left);

    if (rect.left < 0)
        rect.left = 0;

    if (rect.bottom > dyScreen)
        rect.top = dyScreen - (rect.bottom - rect.top);

    if (rect.top < 0)
        rect.top = 0;

    SetWindowPos(
        hwnd, NULL,
        rect.left, rect.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );
}
VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef )

    /* Center window 'hwnd' on window 'hwndRef' or if 'hwndRef' is NULL on
    ** screen.  The window position is adjusted so that no parts are clipped
    ** by the edge of the screen, if necessary.  If 'hwndRef' has been moved
    ** off-screen with SetOffDesktop, the original position is used.
    */
{
    RECT rectCur;
    LONG dxCur;
    LONG dyCur;
    RECT rectRef;
    LONG dxRef;
    LONG dyRef;

    GetWindowRect( hwnd, &rectCur );
    dxCur = rectCur.right - rectCur.left;
    dyCur = rectCur.bottom - rectCur.top;

    if (hwndRef)
    {
//        if (!SetOffDesktop( hwndRef, SOD_GetOrgRect, &rectRef ))
            GetWindowRect( hwndRef, &rectRef );
    }
    else
    {
        rectRef.top = rectRef.left = 0;
        rectRef.right = GetSystemMetrics( SM_CXSCREEN );
        rectRef.bottom = GetSystemMetrics( SM_CYSCREEN );
    }

    dxRef = rectRef.right - rectRef.left;
    dyRef = rectRef.bottom - rectRef.top;

    rectCur.left = rectRef.left + ((dxRef - dxCur) / 2);
    rectCur.top = rectRef.top + ((dyRef - dyCur) / 2);

    SetWindowPos(
        hwnd, NULL,
        rectCur.left, rectCur.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );

    UnclipWindow( hwnd );
}

LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that looks for the next dialog
    ** started and centers it on it's owner window.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to center
        ** the dialog on it's owner's window.
        */
        if (p->message == WM_INITDIALOG)
            CenterWindow( p->hwnd, GetParent( p->hwnd ) );
    }

    return 0;
}

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId )

    /* String resource message loader routine.
    **
    ** Returns the address of a heap block containing the string corresponding
    ** to string resource 'dwStringId' or NULL if error.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    HRSRC  hrsrc;
    TCHAR* pszBuf;
    int    cchBuf = 256;
    int    cchGot;

    for (;;)
    {
        pszBuf = (TCHAR*)Malloc( cchBuf * sizeof(TCHAR) );
        if (!pszBuf)
            break;

        /* LoadString wants to deal with character-counts rather than
        ** byte-counts...weird.  Oh, and if you're thinking I could
        ** FindResource then SizeofResource to figure out the string size, be
        ** advised it doesn't work.  From perusing the LoadString source, it
        ** appears the RT_STRING resource type requests a segment of 16
        ** strings not an individual string.
        */
        cchGot = LoadString( hInstance, (UINT )dwStringId, pszBuf, cchBuf );

        if (cchGot < cchBuf - 1)
        {
            TCHAR *pszTemp = pszBuf;

            /* Good, got the whole string.  Reduce heap block to actual size
            ** needed.
            */
            pszBuf = (TCHAR*)Realloc( pszBuf, (cchGot + 1) * sizeof(TCHAR));

            if(NULL == pszBuf)
            {
                Free(pszTemp);
            }

            break;
        }

        /* Uh oh, LoadStringW filled the buffer entirely which could mean the
        ** string was truncated.  Try again with a larger buffer to be sure it
        ** wasn't.
        */
        Free( pszBuf );
        cchBuf += 256;
        TRACE1("Grow string buf to %d",cchBuf);
    }

    return pszBuf;
}

TCHAR*
GetText(
    IN HWND hwnd )

    /* Returns heap block containing the text contents of the window 'hwnd' or
    ** NULL.  It is caller's responsibility to Free the returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = GetWindowTextLength( hwnd );
    psz = (TCHAR*)Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        GetWindowText( hwnd, psz, cch + 1 );
    }

    return psz;
}

BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError )

    /* Fill caller's '*ppszError' with the address of a LocalAlloc'ed heap
    ** block containing the error text associated with error 'dwError'.  It is
    ** caller's responsibility to LocalFree the returned string.
    **
    ** Returns true if successful, false otherwise.
    */
{
#define MAXRASERRORLEN 256

    TCHAR  szBuf[ MAXRASERRORLEN + 1 ];
    DWORD  dwFlags;
    HANDLE hmodule;
    DWORD  cch;

    /* Don't panic if the RAS API address is not loaded.  Caller may be trying
    ** and get an error up during LoadRas.
    */
//  if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
//      && g_pRasGetErrorString
//      && g_pRasGetErrorString(
    if (RasGetErrorString ((UINT)dwError, (LPTSTR)szBuf, MAXRASERRORLEN) == 0)
    {
        /* It's a RAS error.
        */
        *ppszError = (TCHAR*)LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) * sizeof(TCHAR) );
        if (!*ppszError)
            return FALSE;

        lstrcpy( *ppszError, szBuf );
        return TRUE;
    }

    /* The rest adapted from BLT's LoadSystem routine.
    */
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS;

    if (dwError >= MIN_LANMAN_MESSAGE_ID && dwError <= MAX_LANMAN_MESSAGE_ID)
    {
        /* It's a net error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_HMODULE;
        hmodule = GetModuleHandle( TEXT("NETMSG.DLL") );
    }
    else
    {
        /* It must be a system error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_SYSTEM;
        hmodule = NULL;
    }

    cch = FormatMessage(
        dwFlags, hmodule, dwError, 0, (LPTSTR )ppszError, 1, NULL );
    return (cch > 0);
}

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat )

    /* Pops up a modal error dialog centered on 'hwndOwner'.  'DwOperation' is
    ** the string resource ID of the string describing the operation underway
    ** when the error occurred.  'DwError' is the code of the system or RAS
    ** error that occurred.  'Pargs' is a extended formatting arguments or
    ** NULL if none.  'hInstance' is the application/module handle where
    ** string resources are located.  'DwTitle' is the string ID of the dialog
    ** title.  'DwFormat' is the string ID of the error format title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszOp;
    TCHAR  szErrorNum[ 50 ];
    TCHAR* pszError;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("ErrorDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the error number string.
    */
    if (dwError > 0x7FFFFFFF)
        wsprintf( szErrorNum, TEXT("0x%X"), dwError );
    else
        wsprintf( szErrorNum, TEXT("%u"), dwError );

    /* Build the error text string.
    */
    if (!GetErrorText( dwError, &pszError ))
        pszError = pszNotFound;

    /* Build the operation string.
    */
    pszUnformatted = PszFromId( hInstance, dwOperation );
    pszOp = pszNotFound;

    if (pszUnformatted)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszUnformatted, 0, 0, (LPTSTR )&pszOp, 1,
            (va_list* )((pargs) ? pargs->apszOpArgs : NULL) );

        Free( pszUnformatted );
    }

    /* Call MsgDlgUtil with the standard arguments plus any auxillary format
    ** arguments.
    */
    pszUnformatted = PszFromId( hInstance, dwFormat );
    pszResult = pszNotFound;

    if (pszUnformatted)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK + MB_SETFOREGROUND;
        msgargs.pszString = pszUnformatted;
        msgargs.apszArgs[ 0 ] = pszOp;
        msgargs.apszArgs[ 1 ] = szErrorNum;
        msgargs.apszArgs[ 2 ] = pszError;

        if (pargs)
        {
            msgargs.fStringOutput = pargs->fStringOutput;

            CopyMemory( &msgargs.apszArgs[ 3 ], pargs->apszAuxFmtArgs,
                3 * sizeof(TCHAR) );
        }

        nResult =
            MsgDlgUtil(
                hwndOwner, 0, &msgargs, hInstance, dwTitle );

        Free( pszUnformatted );

        if (pargs && pargs->fStringOutput)
            pargs->pszOutput = msgargs.pszOutput;
    }

    if (pszOp != pszNotFound)
        LocalFree( pszOp );
    if (pszError != pszNotFound)
        LocalFree( pszError );

    return nResult;
}
int MsgDlgUtil(IN HWND hwndOwner, IN DWORD dwMsg, IN OUT MSGARGS* pargs, IN HINSTANCE hInstance, IN DWORD dwTitle);
#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)



// LVX stuff (cut-n-paste'd from ...\net\rras\ras\ui\common\uiutil\lvx.c, etc.


static LPCTSTR g_lvxcbContextId = NULL;

BOOL
ListView_IsCheckDisabled (
        IN HWND hwndLv,
        IN INT  iItem)

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is disabled, false otherwise.
    */
{
    UINT unState;
    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );

    if ((unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )) ||
        (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledUnchecked )))
        return TRUE;

    return FALSE;
}

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NM_LISTVIEW nmlv;

    if (ListView_IsCheckDisabled(hwndLv, iItem))
        return;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmlv.hdr.code = LVXN_SETCHECK;
    nmlv.hdr.hwndFrom = hwndLv;
    nmlv.iItem = iItem;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmlv, SendMessage
        );
}

VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns the lParam address of the 'iItem' item in 'hwndLv' or NULL if
    ** none or error.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;

    if (!ListView_GetItem( hwndLv, &item ))
        return NULL;

    return (VOID* )item.lParam;
}

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.  This function works on disabled
    ** check boxes as well as enabled ones.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!((unState == INDEXTOSTATEIMAGEMASK( SI_Checked )) ||
              (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )));
}

LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* List view subclass window procedure to trap toggle-check events.
    */
{
    WNDPROC pOldProc;
    INT     iItem;
    BOOL    fSet;
    BOOL    fClear;
    BOOL    fToggle;

    iItem = -1;
    fSet = fClear = fToggle = FALSE;

    if (unMsg == WM_LBUTTONDOWN)
    {
        LV_HITTESTINFO info;

        /* Left mouse button pressed over checkbox icon toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  Now figure out if it's over the
            ** checkbox.  Note this currently doesn't account for use of the
            ** "indent" feature on an owner-drawn item.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON ))
                iItem = -1;
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_LBUTTONDBLCLK)
    {
        LV_HITTESTINFO info;

        /* Left mouse button double clicked over any area toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  If the click does not occur
             * over a checkbox, inform the parent of the double click.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON )) {
                NM_LISTVIEW nmlv;
                nmlv.hdr.code = LVXN_DBLCLK;
                nmlv.hdr.hwndFrom = hwnd;
                nmlv.iItem = iItem;

                FORWARD_WM_NOTIFY(
                    GetParent(hwnd), GetDlgCtrlID(hwnd), &nmlv, SendMessage);

                iItem = -1;
            }

            /*
             * Otherwise, toggle the state.
            */
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_CHAR)
    {
        /* Space bar pressed with item selected toggles check.
        ** Plus or Equals keys set check.
        ** Minus key clears check.
        */
        switch (wparam)
        {
            case TEXT(' '):
                fToggle = TRUE;
                break;

            case TEXT('+'):
            case TEXT('='):
                fSet = TRUE;
                break;

            case TEXT('-'):
                fClear = TRUE;
                break;
        }

        if (fToggle || fSet || fClear)
            iItem = ListView_GetNextItem( hwnd, -1, LVNI_SELECTED );
    }
    else if (unMsg == WM_KEYDOWN)
    {
        /* Left arrow becomes up arrow and right arrow becomes down arrow so
        ** the list of checkboxes behaves just like a static group of
        ** checkboxes.
        */
        if (wparam == VK_LEFT)
            wparam = VK_UP;
        else if (wparam == VK_RIGHT)
            wparam = VK_DOWN;
    }

    if (iItem >= 0)
    {

        /* If we are handling the spacebar, plus, minus, or equals,
        ** the change we make applies to all the selected items;
        ** hence the do {} while(WM_CHAR).
        */

        do {

            if (fToggle)
            {
                UINT unOldState;
                BOOL fCheck;

                fCheck = ListView_GetCheck( hwnd, iItem );
                ListView_SetCheck( hwnd, iItem, !fCheck );
            }
            else if (fSet)
            {
                if (!ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, TRUE );
            }
            else if (fClear)
            {
                if (ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, FALSE );
            }

            iItem = ListView_GetNextItem(hwnd, iItem, LVNI_SELECTED);

        } while(iItem >= 0 && unMsg == WM_CHAR);

        if (fSet || fClear) {

            /* Don't pass to listview to avoid beep.
            */
            return 0;
        }
    }

    pOldProc = (WNDPROC )GetProp( hwnd, g_lvxcbContextId );
    if (pOldProc)
        return CallWindowProc( pOldProc, hwnd, unMsg, wparam, lparam );

    return 0;
}

BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Initialize "list of checkbox" handling for listview 'hwndLv'.  'Hinst'
    ** is the module instance containing the two checkbox icons.  See LVX.RC.
    **
    ** Returns true if successful, false otherwise.  Caller must eventually
    ** call 'ListView_UninstallChecks', typically in WM_DESTROY processing.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;
    WNDPROC    pOldProc;

    // pmay: 397395
    //
    // Prevent endless loops resulting from accidentally calling this
    // api twice.
    //
    pOldProc = (WNDPROC)GetWindowLongPtr(hwndLv, GWLP_WNDPROC);
    if (pOldProc == LvxcbProc)
    {
        return TRUE;
    }

    /* Build checkbox image lists.
    */
    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK | ILC_MIRROR, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Unchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Checked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledUnchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledChecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_STATE );

    /* Register atom for use in the Windows XxxProp calls which are used to
    ** associate the old WNDPROC with the listview window handle.
    */
    if (!g_lvxcbContextId)
        g_lvxcbContextId = (LPCTSTR )GlobalAddAtom( _T("RASLVXCB") );
    if (!g_lvxcbContextId)
        return FALSE;

    /* Subclass the current window procedure.
    */
    pOldProc = (WNDPROC)SetWindowLongPtr(
                                hwndLv, GWLP_WNDPROC, (ULONG_PTR)LvxcbProc );

    return SetProp( hwndLv, g_lvxcbContextId, (HANDLE )pOldProc );
}

VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv )

    // Insert a single auto-sized column into listview 'hwndLv', e.g. for a
    // list of checkboxes with no visible column header.
    //
{
    LV_COLUMN col;

    ZeroMemory( &col, sizeof(col) );
    col.mask = LVCF_FMT;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndLv, 0, &col );
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE );
}

TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL )

    /* Returns a heap string containing the 'psz' shortened to fit in the
    ** given width, if necessary, by truncating and adding "...". 'Hdc' is the
    ** device context with the appropiate font selected.  'DxColumn' is the
    ** width of the column.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    const TCHAR szDots[] = TEXT("...");

    SIZE   size;
    TCHAR* pszResult;
    TCHAR* pszResultLast;
    TCHAR* pszResult2nd;
    DWORD  cch;

    cch = lstrlen( psz );
    pszResult = (TCHAR*)Malloc( (cch * sizeof(TCHAR)) + sizeof(szDots) );
    if (!pszResult)
        return NULL;
    lstrcpy( pszResult, psz );

    dxColumn -= dxColText;
    if (dxColumn <= 0)
    {
        /* None of the column text will be visible so bag the calculations and
        ** just return the original string.
        */
        return pszResult;
    }

    if (!GetTextExtentPoint32( hdc, pszResult, cch, &size ))
    {
        Free( pszResult );
        return NULL;
    }

    pszResult2nd = CharNext( pszResult );
    pszResultLast = pszResult + cch;

    while (size.cx > dxColumn && pszResultLast > pszResult2nd)
    {
        /* Doesn't fit.  Lop off a character, add the ellipsis, and try again.
        ** The minimum result is "..." for empty original or "x..." for
        ** non-empty original.
        */
        pszResultLast = CharPrev( pszResult2nd, pszResultLast );
        lstrcpy( pszResultLast, szDots );

        if (!GetTextExtentPoint( hdc, pszResult, lstrlen( pszResult ), &size ))
        {
            Free( pszResult );
            return NULL;
        }
    }

    return pszResult;
}

BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback )

    /* Respond to WM_DRAWITEM by drawing the list view item.  'Pdis' is the
    ** information sent by the system.  'PLvxCallback' is caller's callback to
    ** get information about drawing the control.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    LV_ITEM      item;
    INT          i;
    INT          dxState;
    INT          dyState;
    INT          dxSmall;
    INT          dySmall;
    INT          dxIndent;
    UINT         uiStyleState;
    UINT         uiStyleSmall;
    HIMAGELIST   himlState;
    HIMAGELIST   himlSmall;
    LVXDRAWINFO* pDrawInfo;
    RECT         rc;
    RECT         rcClient;
    BOOL         fEnabled;
    BOOL         fSelected;
    HDC          hdc;
    HFONT        hfont;


    TRACE3("LvxDrawItem,i=%d,a=$%X,s=$%X",
        pdis->itemID,pdis->itemAction,pdis->itemState);

    /* Make sure this is something we want to handle.
    */
    if (pdis->CtlType != ODT_LISTVIEW)
        return FALSE;

    if (pdis->itemAction != ODA_DRAWENTIRE
        && pdis->itemAction != ODA_SELECT
        && pdis->itemAction != ODA_FOCUS)
    {
        return TRUE;
    }

    /* Get item information from the list view.
    */
    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_IMAGE + LVIF_STATE;
    item.iItem = pdis->itemID;
    item.stateMask = LVIS_STATEIMAGEMASK;
    if (!ListView_GetItem( pdis->hwndItem, &item ))
    {
        TRACE("LvxDrawItem GetItem failed");
        return TRUE;
    }

    /* Stash some useful stuff for reference later.
    */
    fEnabled = IsWindowEnabled( pdis->hwndItem )
               && !(pdis->itemState & ODS_DISABLED);
    fSelected = (pdis->itemState & ODS_SELECTED);
    GetClientRect( pdis->hwndItem, &rcClient );

    /* Callback owner to get drawing information.
    */
    ASSERT(pLvxCallback);
    pDrawInfo = pLvxCallback( pdis->hwndItem, pdis->itemID );
    ASSERT(pDrawInfo);

    /* Get image list icon sizes now, though we draw them last because their
    ** background is set up during first column text output.
    */
    dxState = dyState = 0;
    himlState = ListView_GetImageList( pdis->hwndItem, LVSIL_STATE );
    if (himlState)
        ImageList_GetIconSize( himlState, &dxState, &dyState );

    dxSmall = dySmall = 0;
    himlSmall = ListView_GetImageList( pdis->hwndItem, LVSIL_SMALL );
    if (himlSmall)
        ImageList_GetIconSize( himlSmall, &dxSmall, &dySmall );

    uiStyleState = uiStyleSmall = ILD_TRANSPARENT;

    /* Figure out the number of pixels to indent the item, if any.
    */
    if (pDrawInfo->dxIndent >= 0)
        dxIndent = pDrawInfo->dxIndent;
    else
    {
        if (dxSmall > 0)
            dxIndent = dxSmall;
        else
            dxIndent = GetSystemMetrics( SM_CXSMICON );
    }

    /* Get a device context for the window and set it up with the font the
    ** control says it's using.  (Can't use the one that comes in the
    ** DRAWITEMSTRUCT because sometimes it has the wrong rectangle, see bug
    ** 13106)
    */
    hdc = GetDC( pdis->hwndItem );

    if(NULL == hdc)
    {
        return FALSE;
    }

    hfont = (HFONT )SendMessage( pdis->hwndItem, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    /* Set things up as if we'd just got done processing a column that ends
    ** after the icons, then loop thru each column from left to right.
    */
    rc.right = pdis->rcItem.left + dxIndent + dxState + dxSmall;
    rc.top = pdis->rcItem.top;
    rc.bottom = pdis->rcItem.bottom;

    for (i = 0; i < pDrawInfo->cCols; ++i)
    {
        TCHAR  szText[ LVX_MaxColTchars + 1 ];
        TCHAR* pszText;
        INT    dxCol;

        /* Get the column width, adding any index and icon width to the first
        ** column.
        */
        dxCol = ListView_GetColumnWidth( pdis->hwndItem, i );
        if (i == 0)
            dxCol -= dxIndent + dxState + dxSmall;

        szText[ 0 ] = TEXT('\0');
        ListView_GetItemText( pdis->hwndItem, pdis->itemID, i, szText,
            LVX_MaxColTchars + 1 );

        /* Update rectangle to enclose just this one item's column 'i'.
        */
        rc.left = rc.right;
        rc.right = rc.left + dxCol;

        if ((pDrawInfo->dwFlags & LVXDI_DxFill)
            && i == pDrawInfo->cCols - 1)
        {
            INT dxWnd = pdis->rcItem.left + rcClient.right;

            if (rc.right < dxWnd)
            {
                /* When the last column does not fill out a full controls
                ** width of space, extend it to the right so it does.  Note
                ** this does not mean the user can't scroll off to the right
                ** if they want.
                ** (Abolade-Gbadegesin 03-27-96)
                ** Don't subtrace rc.left when there is only one column;
                ** this accounts for the space needed for icons.
                */
                rc.right = pdis->rcItem.right = dxWnd;
                if (i == 0) {
                    ListView_SetColumnWidth(pdis->hwndItem, i, rc.right);
                }
                else {
                    ListView_SetColumnWidth(
                        pdis->hwndItem, i, rc.right - rc.left );
                }
            }
        }

        /* Lop the text and append "..." if it won't fit in the column.
        */
        pszText = Ellipsisize( hdc, szText, rc.right - rc.left, LVX_dxColText );
        if (!pszText)
            continue;

        /* Figure out the appropriate text and background colors for the
        ** current item state.
        */
        if (fEnabled)
        {
            if (fSelected)
            {
                SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
                if (pDrawInfo->dwFlags & LVXDI_Blend50Sel)
                    uiStyleSmall |= ILD_BLEND50;
            }
            else
            {
                if (pDrawInfo->adwFlags[ i ] & LVXDIA_3dFace)
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
                }
                else
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW ) );
                }
            }
        }
        else
        {
            if (pDrawInfo->adwFlags[ i ] & LVXDIA_Static)
            {
                SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }
            else
            {
                SetTextColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }

            if (pDrawInfo->dwFlags & LVXDI_Blend50Dis)
                uiStyleSmall |= ILD_BLEND50;
        }

        /* Draw the column text.  In the first column the background of any
        ** indent and icons is erased to the text background color.
        */
        {
            RECT rcBg = rc;

            if (i == 0)
                rcBg.left -= dxIndent + dxState + dxSmall;

            ExtTextOut( hdc, rc.left + LVX_dxColText,
                rc.top + LVX_dyColText, ETO_CLIPPED + ETO_OPAQUE,
                &rcBg, pszText, lstrlen( pszText ), NULL );
        }

        Free( pszText );
    }

    /* Finally, draw the icons, if caller specified any.
    */
    if (himlState)
    {
        ImageList_Draw( himlState, (item.state >> 12) - 1, hdc,
            pdis->rcItem.left + dxIndent, pdis->rcItem.top, uiStyleState );
    }

    if (himlSmall)
    {
        ImageList_Draw( himlSmall, item.iImage, hdc,
            pdis->rcItem.left + dxIndent + dxState,
            pdis->rcItem.top, uiStyleSmall );
    }

    /* Draw the dotted focus rectangle around the whole item, if indicated.
    */
//comment for bug 52688 whistler
//   if ((pdis->itemState & ODS_FOCUS) && GetFocus() == pdis->hwndItem)
//        DrawFocusRect( hdc, &pdis->rcItem );
//

    ReleaseDC( pdis->hwndItem, hdc );

    return TRUE;
}

BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis )

    /* Respond to WM_MEASUREITEM message, i.e. fill in the height of an item
    ** in the ListView.  'Hwnd' is the owner window.  'Pmis' is the structure
    ** provided from Windows.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    HDC        hdc;
    HWND       hwndLv;
    HFONT      hfont;
    TEXTMETRIC tm;
    UINT       dySmIcon;
    RECT       rc;

    TRACE("LvxMeasureItem");

    if (pmis->CtlType != ODT_LISTVIEW)
        return FALSE;

    hwndLv = GetDlgItem( hwnd, pmis->CtlID );
    ASSERT(hwndLv);

    /* Get a device context for the list view control and set up the font the
    ** control says it's using.  MSDN claims the final font may not be
    ** available at this point, but it sure seems to be.
    */
    hdc = GetDC( hwndLv );
    hfont = (HFONT )SendMessage( hwndLv, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    if (GetTextMetrics( hdc, &tm ))
        pmis->itemHeight = tm.tmHeight + 1;
    else
        pmis->itemHeight = 0;

    /* Make sure it's tall enough for a standard small icon.
    */
    dySmIcon = (UINT )GetSystemMetrics( SM_CYSMICON );
    if (pmis->itemHeight < dySmIcon + LVX_dyIconSpacing)
        pmis->itemHeight = dySmIcon + LVX_dyIconSpacing;

    /* Set the width since the docs say to, though I don't think it's used by
    ** list view.
    */
    GetClientRect( hwndLv, &rc );
    pmis->itemWidth = rc.right - rc.left - 1;

    ReleaseDC( hwndLv, hdc );
    return TRUE;
}

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback )

    /* Handler that, when installed, turns a regular report-view-only list
    ** view (but with style LVS_OWNERDRAWFIXED) into an enhanced list view
    ** with full width selection bar and other custom column display options.
    ** It should appear in list view owner's dialog proc as follows:
    **
    **     BOOL
    **     MyDlgProc(
    **         IN HWND   hwnd,
    **         IN UINT   unMsg,
    **         IN WPARAM wparam,
    **         IN LPARAM lparam )
    **     {
    **         if (ListView_OwnerHandler(
    **                 hwnd, unMsg, wParam, lParam, MyLvxCallback ))
    **             return TRUE;
    **
    **         <the rest of your stuff here>
    **     }
    **
    ** 'PLvxCallback' is caller's callback routine that provides information
    ** about drawing columns and other options.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    /* This routine executes on EVERY message thru the dialog so keep it
    ** efficient, please.
    */
    switch (unMsg)
    {
        case WM_DRAWITEM:
            return LvxDrawItem( (DRAWITEMSTRUCT* )lparam, pLvxCallback );

        case WM_MEASUREITEM:
            return LvxMeasureItem( hwnd, (MEASUREITEMSTRUCT* )lparam );
    }

    return FALSE;
}

// StrDup* functions
TCHAR* _StrDup(LPCTSTR psz )    // my local version...

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  It is caller's responsibility to
    ** 'Free' the returned string.
    */
{
    TCHAR* pszNew = NULL;

    if (psz)
    {
        pszNew = (TCHAR*)Malloc( (lstrlen( psz ) + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDup Malloc failed");
            return NULL;
        }

        lstrcpy( pszNew, psz );
    }

    return pszNew;
}

TCHAR*
StrDupTFromW(
    LPCWSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return _StrDup ( psz );

#else // !UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb + 1 );
        if (!pszNew)
        {
            TRACE("StrDupTFromW Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupTFromW conversion failed");
            return NULL;
        }
    }

    return pszNew;

#endif
}

WCHAR*
StrDupWFromT(
    LPCTSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return _StrDup ( psz );

#else // !UNICODE

    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = (WCHAR*)Malloc( (cb + 1) * sizeof(WCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromT Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupWFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;
#endif
}

void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer )

    // Converts an IP address in host byte order to its
    // string representation.
    // pszBuffer should be allocated by the caller and be
    // at least 16 characters long.
    //
{
    BYTE* pb = (BYTE*)&dwAddr;
    static const TCHAR c_szIpAddr [] = TEXT("%d.%d.%d.%d");
    wsprintf (pszBuffer, c_szIpAddr, pb[3], pb[2], pb[1], pb[0]);
}
#ifdef DOWNLEVEL_CLIENT
DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}
#endif
VOID*
Free0(
    VOID* p )

    /* Like Free, but deals with NULL 'p'.
    */
{
    if (!p)
        return NULL;

    return Free( p );
}

HRESULT ActivateLuna(HANDLE* phActivationContext, ULONG_PTR* pulCookie)
{
    HRESULT hr = E_FAIL;
    
    
    TCHAR szPath[MAX_PATH];
    if(0 != GetModuleFileName(_Module.GetResourceInstance(), szPath, sizeof(szPath) / sizeof(TCHAR)))
    {
        ACTCTX ActivationContext;
        ZeroMemory(&ActivationContext, sizeof(ActivationContext));
        ActivationContext.cbSize = sizeof(ActivationContext);
        ActivationContext.lpSource = szPath;
        ActivationContext.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        ActivationContext.lpResourceName = MAKEINTRESOURCE(123);
        
        ULONG_PTR ulCookie;
        HANDLE hActivationContext = CreateActCtx(&ActivationContext);
        if(NULL != hActivationContext)
        {
            if(TRUE == ActivateActCtx(hActivationContext, &ulCookie))
            {
                *phActivationContext = hActivationContext;
                *pulCookie = ulCookie;
                hr = S_OK;
            }
            else
            {
                ReleaseActCtx(hActivationContext);
            }
        }
    }
    return hr;
}

HRESULT DeactivateLuna(HANDLE hActivationContext, ULONG_PTR ulCookie)
{
    DeactivateActCtx(0, ulCookie);
    ReleaseActCtx(hActivationContext);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\dportmap.h ===
// DPortMap.h : Declaration of the CDynamicPortMapping

#ifndef __DYNAMICPORTMAPPING_H_
#define __DYNAMICPORTMAPPING_H_

#include <upnp.h>


/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMapping
class ATL_NO_VTABLE CDynamicPortMapping : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CDynamicPortMapping, &CLSID_DynamicPortMapping>,
	public IDispatchImpl<IDynamicPortMapping, &IID_IDynamicPortMapping, &LIBID_NATUPNPLib>
{
private:
   enum eEnumData {
      eNoData = -1,
      eSomeData,
      eAllData
   };
   eEnumData  m_eComplete;

   CComBSTR m_cbRemoteHost;   // "" == wildcard (for static)
   long     m_lExternalPort;
   CComBSTR m_cbProtocol;     // "TCP" or "UDP"
   long     m_lInternalPort;  // internal == external for static
   CComBSTR m_cbInternalClient;
   VARIANT_BOOL m_vbEnabled;
   CComBSTR m_cbDescription;
   // Lease is live

   CComPtr<IUPnPService> m_spUPS;

public:
	CDynamicPortMapping()
	{
      m_eComplete = eNoData;

      m_lInternalPort =
      m_lExternalPort = 0;
      m_vbEnabled     = VARIANT_FALSE;
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DYNAMICPORTMAPPING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDynamicPortMapping)
	COM_INTERFACE_ENTRY(IDynamicPortMapping)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDynamicPortMapping
public:
   STDMETHOD(get_ExternalIPAddress)(/*[out, retval]*/ BSTR *pVal); // live one!
   STDMETHOD(get_RemoteHost)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_ExternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_Protocol)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_InternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_InternalClient)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_Enabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
   STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_LeaseDuration)(/*[out, retval]*/ long *pVal);  // live one!
   STDMETHOD(RenewLease)(/*[in]*/ long lLeaseDurationDesired, /*[out, retval]*/ long * pLeaseDurationReturned);
   STDMETHOD(EditInternalClient)(/*[in]*/ BSTR bstrInternalClient);
   STDMETHOD(Enable)(/*[in]*/ VARIANT_BOOL vb);
   STDMETHOD(EditDescription)(/*[in]*/ BSTR bstrDescription);
   STDMETHOD(EditInternalPort)(/*[in]*/ long lInternalPort);

// CDynamicPortMapping
public:
   static HRESULT CreateInstance (IUPnPService * pUPS, long lIndex, IDynamicPortMapping ** ppDPM);
   HRESULT Initialize (IUPnPService * pUPS, long lIndex);

   static HRESULT CreateInstance (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM);
   HRESULT Initialize (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol);

private:
   HRESULT GetAllData (long * pLease = NULL);
};

#endif //__DYNAMICPORTMAPPING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnappprt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P P P R T . H
//
//  Contents:   CHNetAppProtocol declarations
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetAppProtocol :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetApplicationProtocol
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance
    //

    BSTR m_bstrProtocol;

    //
    // True if this is a built-in protocol. We cache
    // this value as it will be used quite often, and
    // will never change for the instance.
    //

    BOOLEAN m_fBuiltIn;

    //
    // Obtains the protocol object from the stored path
    //

    HRESULT
    GetProtocolObject(
        IWbemClassObject **ppwcoInstance
        );

public:

    BEGIN_COM_MAP(CHNetAppProtocol)
        COM_INTERFACE_ENTRY(IHNetApplicationProtocol)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetAppProtocol()
    {
        m_piwsHomenet = NULL;
        m_bstrProtocol = NULL;
        m_fBuiltIn = FALSE;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetApplicationProtocol methods
    //

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetOutgoingIPProtocol(
        UCHAR *pucProtocol
        );

    STDMETHODIMP
    SetOutgoingIPProtocol(
        UCHAR ucProtocol
        );

    STDMETHODIMP
    GetOutgoingPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetOutgoingPort(
        USHORT usPort
        );

    STDMETHODIMP
    GetResponseRanges(
        USHORT *puscResponses,
        HNET_RESPONSE_RANGE *prgResponseRange[]
        );

    STDMETHODIMP
    SetResponseRanges(
        USHORT uscResponses,
        HNET_RESPONSE_RANGE rgResponseRange[]
        );

    STDMETHODIMP
    GetBuiltIn(
        BOOLEAN *pfBuiltIn
        );

    STDMETHODIMP
    GetEnabled(
        BOOLEAN *pfEnabled
        );

    STDMETHODIMP
    SetEnabled(
        BOOLEAN fEnable
        );

    STDMETHODIMP
    Delete();
};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetApplicationProtocols,
            IHNetApplicationProtocol,
            CHNetAppProtocol
            >
        CEnumHNetApplicationProtocols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnbrgcon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R G C O N . H
//
//  Contents:   CHNBridgedConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNBridgedConn :
    public CHNetConn,
    public IHNetBridgedConnection
{
private:
    HRESULT
    CHNBridgedConn::UnbindFromBridge(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

    HRESULT
    CopyBridgeBindings(
        IN INetCfgComponent     *pnetcfgAdapter,
        IN INetCfgComponent     *pnetcfgBridge
        );

public:

    BEGIN_COM_MAP(CHNBridgedConn)
        COM_INTERFACE_ENTRY(IHNetBridgedConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    //
    // Ojbect initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection
        );

    //
    // IHNetBridgedConnection methods
    //

    STDMETHODIMP
    GetBridge(
        IHNetBridge **ppBridge
        );

    STDMETHODIMP
    RemoveFromBridge(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );
};

typedef CHNCArrayEnum<IEnumHNetBridgedConnections, IHNetBridgedConnection> CEnumHNetBridgedConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnbridge.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R I D G E . H
//
//  Contents:   CHNBridge declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNBridge :
    public CHNetConn,
    public IHNetBridge
{
private:

    HRESULT
    BindNewAdapter(
        IN GUID                 *pguid,
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

    HRESULT
    RemoveMiniport(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

public:

    BEGIN_COM_MAP(CHNBridge)
        COM_INTERFACE_ENTRY(IHNetBridge)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    //
    // IHNetBridge Methods
    //

    STDMETHODIMP
    EnumMembers(
        IEnumHNetBridgedConnections **ppEnum
        );

    STDMETHODIMP
    AddMember(
        IHNetConnection *pConn,
        IHNetBridgedConnection **ppBridgedConn,
        INetCfg *pnetcfgExisting
        );

    STDMETHODIMP
    Destroy(
        INetCfg *pnetcfgExisting
        );
};

typedef CHNCArrayEnum<IEnumHNetBridges, IHNetBridge>    CEnumHNetBridges;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001
//
//  File:       H N A P I . H
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#define HNET_OEM_API_ENTER try {
#define HNET_OEM_API_LEAVE } catch (...) { return DISP_E_EXCEPTION; }

#include <eh.h>
class HNet_Oem_SEH_Exception 
{
private:
    unsigned int m_uSECode;
public:
   HNet_Oem_SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
   HNet_Oem_SEH_Exception() {}
  ~HNet_Oem_SEH_Exception() {}
   unsigned int getSeHNumber() { return m_uSECode; }
};
void __cdecl hnet_oem_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableOEMExceptionHandling();
void DisableOEMExceptionHandling();

#ifndef IID_PPV_ARG
   #define IID_PPV_ARG(Type, Expr) \
       __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
#endif


#ifndef ReleaseObj

#define ReleaseObj(obj)  (( obj ) ? (obj)->Release() : 0)

#endif


BOOLEAN IsSecureContext();

BOOLEAN IsNotifyApproved();

HRESULT InitializeOemApi( HINSTANCE hInstance );

HRESULT ReleaseOemApi();

HRESULT _ObtainIcsSettingsObj( IHNetIcsSettings** ppIcsSettings );

// structs
typedef struct tagICSPortMapping
{
   OLECHAR *pszwName;

   UCHAR    ucIPProtocol;
   USHORT   usExternalPort;
   USHORT   usInternalPort;
   DWORD    dwOptions;

   OLECHAR *pszwTargetName;
   OLECHAR *pszwTargetIPAddress;

   VARIANT_BOOL bEnabled;
}
ICS_PORTMAPPING, *LPICS_PORTMAPPING;

typedef struct tagICS_RESPONSE_RANGE
{
   UCHAR  ucIPProtocol;
   USHORT usStartPort;
   USHORT usEndPort;
}
ICS_RESPONSE_RANGE, *LPICS_RESPONSE_RANGE;

typedef struct tagICS_APPLICATION_DEFINITION
{
   VARIANT_BOOL bEnabled;
   OLECHAR *pszwName;
   UCHAR    ucIPProtocol;
   USHORT   usOutgoingPort;
   DWORD    dwOptions;
   USHORT   uscResponses;

   ICS_RESPONSE_RANGE lpResponse[1];
}
ICS_APPLICATION_DEFINITION, *LPICS_APPLICATION_DEFINITION;

class ATL_NO_VTABLE CNetConnectionProps :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetConnectionProps, &IID_INetConnectionProps, &LIBID_NETCONLib>
{
private:
   INetConnection* m_pNetConnection;   

public:

   BEGIN_COM_MAP(CNetConnectionProps)
      COM_INTERFACE_ENTRY(INetConnectionProps)
      COM_INTERFACE_ENTRY(IDispatch)
   END_COM_MAP()

   CNetConnectionProps()
   {
      m_pNetConnection = NULL;
   }
  ~CNetConnectionProps()
   {
      ReleaseObj (m_pNetConnection);
   }

   HRESULT Initialize (INetConnection * pNC)
   {
      _ASSERT (pNC);
      if (!pNC)
         return E_POINTER;
      ReleaseObj (m_pNetConnection);

      m_pNetConnection = pNC;
      m_pNetConnection->AddRef();
      return S_OK;
   }

// INetConnectionProps
   STDMETHODIMP get_Guid (BSTR * pbstrGuid)
   {
      HNET_OEM_API_ENTER

      if (!pbstrGuid)
         return E_POINTER;
      *pbstrGuid = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         LPOLESTR lpo = NULL;
         hr = StringFromCLSID (pNCP->guidId, &lpo);
         if (lpo) {
            *pbstrGuid = SysAllocString (lpo);
            if (!*pbstrGuid)
               hr = E_OUTOFMEMORY;
            CoTaskMemFree (lpo);
         }
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_Name (BSTR * pbstrName)
   {
      HNET_OEM_API_ENTER

      if (!pbstrName)
         return E_POINTER;
      *pbstrName = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pbstrName = SysAllocString (pNCP->pszwName);
         if (!*pbstrName)
            hr = E_OUTOFMEMORY;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_DeviceName(BSTR * pbstrDeviceName)
   {
      HNET_OEM_API_ENTER

      if (!pbstrDeviceName)
         return E_POINTER;
      *pbstrDeviceName = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pbstrDeviceName = SysAllocString (pNCP->pszwDeviceName);
         if (!*pbstrDeviceName)
            hr = E_OUTOFMEMORY;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_Status    (NETCON_STATUS * pStatus)
   {
      HNET_OEM_API_ENTER

      if (!pStatus)
         return E_POINTER;
//    *pStatus = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pStatus = pNCP->Status;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_MediaType (NETCON_MEDIATYPE * pMediaType)
   {
      HNET_OEM_API_ENTER

      if (!pMediaType)
         return E_POINTER;
      *pMediaType = NCM_NONE;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pMediaType = pNCP->MediaType;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }

   STDMETHODIMP get_Characteristics (DWORD * pdwFlags)
   {
      HNET_OEM_API_ENTER

      if (!pdwFlags)
         return E_POINTER;
      *pdwFlags = NCCF_NONE;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pdwFlags = pNCP->dwCharacter;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
};

class ATL_NO_VTABLE CNetSharingConfiguration : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetSharingConfiguration, &IID_INetSharingConfiguration, &LIBID_NETCONLib>
{

private:

   IHNetConnection*        m_pHNetConnection;   
   IHNetProtocolSettings*   m_pSettings;

   CRITICAL_SECTION      m_csSharingConfiguration;

   // private method called from 2 wrappers below (get_SharingEnabled, get_SharingEnabledType)
   STDMETHODIMP GetSharingEnabled (BOOLEAN* pbEnabled, SHARINGCONNECTIONTYPE* pType);
   // this was necessary because oleautomation allows only one retval type

public:

    BEGIN_COM_MAP(CNetSharingConfiguration)
        COM_INTERFACE_ENTRY(INetSharingConfiguration)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

   CNetSharingConfiguration()
   {
      m_pHNetConnection = NULL;
      m_pSettings       = NULL;

       InitializeCriticalSection(&m_csSharingConfiguration);
   }

   ~CNetSharingConfiguration()
   {
       DeleteCriticalSection(&m_csSharingConfiguration);
   }

   HRESULT
   Initialize(
      INetConnection *pNetConnection );
   
   HRESULT
   FinalRelease()
   {
      ReleaseObj(m_pHNetConnection);
      ReleaseObj(m_pSettings);

      return S_OK;
   }

   STDMETHODIMP get_SharingEnabled    (VARIANT_BOOL* pbEnabled);
   STDMETHODIMP get_SharingConnectionType(SHARINGCONNECTIONTYPE* pType);

   STDMETHODIMP
   DisableSharing();

   STDMETHODIMP
   EnableSharing(
      SHARINGCONNECTIONTYPE  Type );

   STDMETHODIMP
   get_InternetFirewallEnabled(
      VARIANT_BOOL *pbEnabled );

   STDMETHODIMP
   DisableInternetFirewall();

   STDMETHODIMP
   EnableInternetFirewall();

    // Return an IEnumSharingPortMapping interface used to enumerate all of
    // the contained INetSharingPortMapping objects.
    //
   STDMETHODIMP
    get_EnumPortMappings(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPortMappingCollection** ppColl);

   STDMETHODIMP
   AddPortMapping(
      OLECHAR*                 pszwName,
      UCHAR                    ucIPProtocol,
      USHORT                   usExternalPort,
      USHORT                   usInternalPort,
        DWORD                      dwOptions,
      OLECHAR*                 pszwTargetNameOrIPAddress,
      ICS_TARGETTYPE           eTargetType,
      INetSharingPortMapping** ppMapping );

   STDMETHODIMP
   RemovePortMapping( 
      INetSharingPortMapping*  pMapping );

};


class ATL_NO_VTABLE CNetSharingManager : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CNetSharingManager, &CLSID_NetSharingManager>,
    public IDispatchImpl<INetSharingManager, &IID_INetSharingManager, &LIBID_NETCONLib>
{

private:
  
   IHNetIcsSettings*  m_pIcsSettings;

public:

    BEGIN_COM_MAP(CNetSharingManager)
        COM_INTERFACE_ENTRY(INetSharingManager)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_SHAREMGR)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

   CNetSharingManager()
   {
      m_pIcsSettings = NULL;
   }
   
   HRESULT FinalConstruct()
   {
      return _ObtainIcsSettingsObj( &m_pIcsSettings );
   }

   HRESULT FinalRelease()
   {
      ReleaseObj( m_pIcsSettings );

      return S_OK;
   }


   STDMETHODIMP
   get_SharingInstalled( 
      VARIANT_BOOL *pbInstalled );

    // Return an IEnumNetEveryConnection interface used to enumerate all of
    // the contained INetConnections
    //
    STDMETHODIMP
    get_EnumEveryConnection(
        INetSharingEveryConnectionCollection** ppColl);

    // Return an IEnumNetPublicConnection interface used to enumerate all of
    // the contained INetConnections configured as a public adapter
    //
    STDMETHODIMP
    get_EnumPublicConnections(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPublicConnectionCollection** ppColl);

    // Return an IEnumNetPrivateConnection interface used to enumerate all of
    // the contained INetConnections configured as a private adapter
    //
    STDMETHODIMP
    get_EnumPrivateConnections(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPrivateConnectionCollection** ppColl);

   STDMETHODIMP
   get_INetSharingConfigurationForINetConnection(
        INetConnection*            pNetConnection,
        INetSharingConfiguration** ppNetSharingConfiguration
        );


   STDMETHODIMP
   get_NetConnectionProps(
      INetConnection      * pNetConnection,
      INetConnectionProps **ppProps)
   {
      HNET_OEM_API_ENTER

      if (!ppProps)
         return E_POINTER;
      else
         *ppProps = NULL;
      if (!pNetConnection)
         return E_INVALIDARG;

      CComObject<CNetConnectionProps>* pNCP = NULL;
      HRESULT hr = CComObject<CNetConnectionProps>::CreateInstance(&pNCP);
      if (pNCP) {
         pNCP->AddRef();
         hr = pNCP->Initialize (pNetConnection);
         if (hr == S_OK)
            hr = pNCP->QueryInterface (
                     __uuidof(INetConnectionProps), (void**)ppProps);
         pNCP->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
};


template<
   class IMapping,
   class IProtocol
   >
class TNetMapping :
    public CComObjectRootEx<CComMultiThreadModel>,
   public IMapping
{

private:

   IProtocol*        m_pIProtocol;
   CRITICAL_SECTION  m_csDefinition;

protected:

   IProtocol* _IProtocol() { return m_pIProtocol; }

   IProtocol* _IProtocol( IProtocol* _pIProtocol )
   {
      if ( m_pIProtocol ) ReleaseObj(m_pIProtocol);

      m_pIProtocol = _pIProtocol;

      if ( m_pIProtocol ) m_pIProtocol->AddRef();
      
      return m_pIProtocol;
   }

   CRITICAL_SECTION* _CriticalSection()
   {
      return &m_csDefinition;
   }

public:

   typedef TNetMapping<IMapping, IProtocol> _ThisClass;

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(IMapping)
    END_COM_MAP()

public:

   TNetMapping()
   {
      m_pIProtocol = NULL;

      InitializeCriticalSection(&m_csDefinition);
   }

   ~TNetMapping()
   {
      DeleteCriticalSection(&m_csDefinition);
   }

   HRESULT
   FinalRelease()
   {
      ReleaseObj( m_pIProtocol );

      return S_OK;
   }
   
   HRESULT
   Initialize(
      IProtocol*  pItem)
   {
      EnterCriticalSection(&m_csDefinition);

      _IProtocol( pItem );

      LeaveCriticalSection(&m_csDefinition);

      return S_OK;
   }

   STDMETHOD(Disable)(void)
   {
      HRESULT   hr;

      if ( !IsNotifyApproved() )
      {
         hr = E_ACCESSDENIED;
      }
      else if ( NULL == m_pIProtocol )
      {
         hr = E_UNEXPECTED;
      }
      else
      {
         hr = m_pIProtocol->SetEnabled( FALSE );
      }

      return hr;
   }

   STDMETHOD(Enable)(void)
   {
      HRESULT   hr;

      if ( !IsNotifyApproved() )
      {
         hr = E_ACCESSDENIED;
      }
      else if ( NULL == m_pIProtocol )
      {
         hr = E_UNEXPECTED;
      }
      else
      {
         hr = m_pIProtocol->SetEnabled( TRUE );
      }

      return hr;
   }
};

class ATL_NO_VTABLE CNetSharingPortMapping :
   public IDispatchImpl<TNetMapping<INetSharingPortMapping, IHNetPortMappingBinding>, &IID_INetSharingPortMapping, &LIBID_NETCONLib>
{

public:

   typedef TNetMapping<INetSharingPortMapping, IHNetPortMappingBinding> _ThisOtherClass;

    BEGIN_COM_MAP(CNetSharingPortMapping)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisOtherClass)
    END_COM_MAP()

   STDMETHODIMP get_Properties (/*[out, retval]*/ INetSharingPortMappingProps ** ppNSPMP);

   STDMETHODIMP
   Delete();
};


template<
   class EnumInterface,
   class ItemInterface,
   class EnumWrapped,
   class ItemWrapped
   >
class TNetApiEnum :
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface,
    public IEnumVARIANT
{

protected:

    typedef TNetApiEnum<EnumInterface, ItemInterface, EnumWrapped, ItemWrapped> _ThisClass;

   friend class TNetApiEnum<EnumInterface, ItemInterface, EnumWrapped, ItemWrapped>;

   SHARINGCONNECTION_ENUM_FLAGS  m_fEnumFlags;
   EnumWrapped*                  m_pEnum;

   CRITICAL_SECTION            m_csEnum;

public:

    TNetApiEnum ()
    {
      m_fEnumFlags = ICSSC_DEFAULT;
      m_pEnum      = NULL;

       InitializeCriticalSection(&m_csEnum);
    }

   ~TNetApiEnum ()
   {
      DeleteCriticalSection(&m_csEnum);
   }

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

   HRESULT Initialize( EnumWrapped* pEnum, SHARINGCONNECTION_ENUM_FLAGS Flags )
   {
      EnterCriticalSection(&m_csEnum);

      ReleaseObj( m_pEnum );

      m_fEnumFlags = Flags;
      m_pEnum      = pEnum;

      m_pEnum->AddRef();

      LeaveCriticalSection(&m_csEnum);

      return S_OK;
   }

   HRESULT FinalRelease ()
   {
      ReleaseObj( m_pEnum );

      return S_OK;      
   }

   virtual HRESULT GetItemInterfaceFromItemWrapped( ItemWrapped* pItem, ItemInterface** ppIface )
   {
      HRESULT hr;

      if ( NULL == ppIface )
      {   
         hr = E_POINTER;
      }
      else if ( NULL == pItem )
      {
         hr = E_INVALIDARG;
      }
      else
      {
         *ppIface = NULL;

         hr = E_NOTIMPL;
      }

      return hr;
   }

private:
    STDMETHOD (Next) (
        ULONG              celt,
        ItemInterface**    rgelt,
        ULONG*             pceltFetched)
   {
      HRESULT hr = S_OK;
      ULONG   ulFetched = 0;

      ItemInterface  **ppNet = rgelt;
      ItemWrapped    **ItemArray;

      // Validate parameters.

      if ( !rgelt || ((1 < celt) && !pceltFetched) )
      {
         hr = E_POINTER;
      }
      else if ( 0 == celt )
      {
         hr = E_INVALIDARG;
      }

      if ( SUCCEEDED(hr) )
      {
         ZeroMemory(rgelt, sizeof(ItemInterface*) * celt);

         if ( pceltFetched ) *pceltFetched = 0;

         ulFetched = 0;
      
         if ( NULL == m_pEnum )
         {
            hr = S_FALSE;
         }
         else
         {
            ItemArray = new ItemWrapped * [ sizeof(ItemWrapped) * celt ];

            if ( ItemArray )
            {
               ZeroMemory( ItemArray, sizeof(ItemWrapped) * celt );
            }
            else
            {
               hr = E_OUTOFMEMORY;
            }
         }
      }

      if ( SUCCEEDED(hr) && m_pEnum )
      {
         ItemWrapped **ppItem;
         ULONG         ulBatchFetched, i;

         hr = m_pEnum->Next( celt, ItemArray, &ulBatchFetched );

         ppItem = ItemArray;
         ppNet  = rgelt;

         for( i=0, ulFetched=0; ( ( i < ulBatchFetched ) && ( S_OK == hr ) ); i++, ppItem++ )
         {
            hr = GetItemInterfaceFromItemWrapped( *ppItem, ppNet );

            if ( SUCCEEDED(hr) )
            {
               ppNet++;

               ulFetched++;
            }

            ReleaseObj( *ppItem );
         }

         delete [] ItemArray;
      }

      if ( ulFetched > 0 )
      {
         hr = ( ulFetched == celt ) ? S_OK : S_FALSE;

         if ( pceltFetched ) *pceltFetched = ulFetched;
      }

      return hr;
   }
public:
   STDMETHOD (Next) (ULONG celt, VARIANT * rgVar, ULONG * pceltFetched)
   {  // this Next calls the private Next to wrap up ItemInterfaces in VARIANTs
      HNET_OEM_API_ENTER

      if (!rgVar || ((1 < celt) && !pceltFetched))
         return E_POINTER;
      else if (0 == celt)
         return E_INVALIDARG;

      HRESULT hr = S_OK;

      // alloc array of ItemInterface* and call private Next
      ItemInterface ** rgelt = (ItemInterface**)malloc (celt*sizeof(ItemInterface*));
      if (!rgelt)
         hr = E_OUTOFMEMORY;
      else {
         hr = Next (celt, rgelt, pceltFetched);
         if (hr == S_OK) { // if error or S_FALSE, don't copy data
            ULONG ulElements;
            if (pceltFetched)
               ulElements = *pceltFetched;
            else
               ulElements = 1;

            for (ULONG ul=0; ul<ulElements; ul++) {
               if (S_OK == (hr = rgelt[ul]->QueryInterface (__uuidof(IDispatch), (void**)&V_DISPATCH (&rgVar[ul]))))
                  V_VT (&rgVar[ul]) = VT_DISPATCH;
               else 
               if (S_OK == (hr = rgelt[ul]->QueryInterface (__uuidof(IUnknown),  (void**)&V_UNKNOWN  (&rgVar[ul]))))
                  V_VT (&rgVar[ul]) = VT_UNKNOWN;
               else
                  break;
            }
            for (ULONG ul=0; ul<ulElements; ul++)
               rgelt[ul]->Release();
         }
         free (rgelt);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }

    STDMETHOD (Skip) (
        ULONG   celt)
   {
      return ( (m_pEnum) ? m_pEnum->Skip(celt) : S_OK );
   }


    STDMETHOD (Reset) ()
   {
      return ( (m_pEnum) ? m_pEnum->Reset() : S_OK );
   }

public:
    STDMETHOD (Clone) (
        EnumInterface**  ppEnum)
   {
      HNET_OEM_API_ENTER
      
      HRESULT hr = S_OK;

      CComObject<_ThisClass>* pNewEnum;
      EnumWrapped*            pClonedEnum;

      if ( NULL == ppEnum )
      {
          hr = E_POINTER;
      }
      else 
      {
          // Attempt to clone the embedded enumeration.

          pClonedEnum = NULL;
          hr = m_pEnum->Clone(&pClonedEnum);
      }


      if ( SUCCEEDED(hr) )
      {
          // Create an initialized a new instance of ourselves

          hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);

          if ( SUCCEEDED(hr) )
          {
              pNewEnum->AddRef();
              
              hr = pNewEnum->Initialize( pClonedEnum, m_fEnumFlags );

              if ( SUCCEEDED(hr) )
              {
                  hr = pNewEnum->QueryInterface( IID_PPV_ARG(EnumInterface, ppEnum) );
              }

              pNewEnum->Release();
          }

          // Release the cloned enum. New enum object will have
          // AddReffed it...

          pClonedEnum->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
public:
   STDMETHOD (Clone) (IEnumVARIANT ** ppEnum)
   {
      HNET_OEM_API_ENTER

      EnumInterface* pEnum = NULL;
      HRESULT hr = Clone (&pEnum);
      if (pEnum) {
         hr = pEnum->QueryInterface (__uuidof(IEnumVARIANT), (void**)ppEnum);
         pEnum->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   
};

template<> 
HRESULT TNetApiEnum <IEnumNetSharingEveryConnection,
                 INetConnection,
                 IEnumNetConnection,
                 INetConnection>
::GetItemInterfaceFromItemWrapped( 
   INetConnection*  pItem, 
   INetConnection** ppIface 
   )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      hr = pItem->QueryInterface( IID_PPV_ARG( INetConnection, ppIface ) );
   }

   return hr;
}

class ATL_NO_VTABLE CSharingManagerEnumEveryConnection :
   public TNetApiEnum <IEnumNetSharingEveryConnection,
                   INetConnection,
                   IEnumNetConnection,
                   INetConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumEveryConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingEveryConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<> 
HRESULT TNetApiEnum <IEnumNetSharingPublicConnection,
                 INetConnection,
                 IEnumHNetIcsPublicConnections,
                 IHNetIcsPublicConnection>
::GetItemInterfaceFromItemWrapped( 
   IHNetIcsPublicConnection* pItem, 
   INetConnection**          ppIface 
   )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      IHNetConnection* pHNet;

      *ppIface = NULL;

      hr = pItem->QueryInterface( IID_PPV_ARG( IHNetConnection, &pHNet ) );

      if ( SUCCEEDED(hr) )
      {
         hr = pHNet->GetINetConnection( ppIface );
      
         ReleaseObj( pHNet );
      }
   }

   return hr;
}

class ATL_NO_VTABLE CSharingManagerEnumPublicConnection :
   public TNetApiEnum <IEnumNetSharingPublicConnection,
                   INetConnection,
                   IEnumHNetIcsPublicConnections,
                   IHNetIcsPublicConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPublicConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingPublicConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<>
HRESULT TNetApiEnum <IEnumNetSharingPrivateConnection,
                INetConnection,
                IEnumHNetIcsPrivateConnections,
                IHNetIcsPrivateConnection>
::GetItemInterfaceFromItemWrapped( 
         IHNetIcsPrivateConnection* pItem, 
         INetConnection**           ppIface )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      IHNetConnection* pHNet;

      *ppIface = NULL;

      hr = pItem->QueryInterface( IID_PPV_ARG( IHNetConnection, &pHNet ) );

      if ( SUCCEEDED(hr) )
      {
         hr = pHNet->GetINetConnection( ppIface );
      
         ReleaseObj( pHNet );
      }
   }

   return hr;
}


class ATL_NO_VTABLE CSharingManagerEnumPrivateConnection :
   public TNetApiEnum <IEnumNetSharingPrivateConnection,
                   INetConnection,
                   IEnumHNetIcsPrivateConnections,
                   IHNetIcsPrivateConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPrivateConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingPrivateConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<>
HRESULT TNetApiEnum<IEnumNetSharingPortMapping,
               INetSharingPortMapping,
               IEnumHNetPortMappingBindings,
               IHNetPortMappingBinding>
::GetItemInterfaceFromItemWrapped( 
         IHNetPortMappingBinding*  pItem, 
         INetSharingPortMapping**  ppIface )
{
   HRESULT hr;

   hr = ( NULL == ppIface ) ? E_POINTER : S_OK;

   if ( SUCCEEDED(hr) )
   {
      *ppIface = NULL;

      if ( NULL == pItem )
      {
         hr = E_INVALIDARG;
      }
   }

   if ( SUCCEEDED(hr) )
   {
      CComObject<CNetSharingPortMapping>* pMap;

        hr = CComObject<CNetSharingPortMapping>::CreateInstance(&pMap);
      
      if ( SUCCEEDED(hr) )
      {
         pMap->AddRef();

         hr = pMap->Initialize( pItem );

         if ( SUCCEEDED(hr) )
         {
            hr = pMap->QueryInterface( IID_PPV_ARG( INetSharingPortMapping, ppIface ) );
         }

         ReleaseObj(pMap);
      }
   }

   return hr;
}


class ATL_NO_VTABLE CSharingManagerEnumPortMapping :
   public TNetApiEnum<IEnumNetSharingPortMapping,
                  INetSharingPortMapping,
                  IEnumHNetPortMappingBindings,
                  IHNetPortMappingBinding>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPortMapping)
        COM_INTERFACE_ENTRY(IEnumNetSharingPortMapping)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

// collections
template <class IEnumBase, class IEnumerator>
class TNetCollection :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IEnumBase
{
private:
   IEnumerator * m_pE;

public:

   typedef TNetCollection<IEnumBase, IEnumerator> _ThisClass;

   BEGIN_COM_MAP(_ThisClass)
      COM_INTERFACE_ENTRY(IEnumBase)
   END_COM_MAP()

public:

   TNetCollection()
   {
      m_pE = NULL;
   }
  ~TNetCollection()
   {
      ReleaseObj(m_pE);
   }

   HRESULT Initialize (IEnumerator * pE)
   {
      _ASSERT ( pE != NULL);
      _ASSERT(m_pE == NULL);
      m_pE = pE;
      m_pE->AddRef();
      return S_OK;
   }

   STDMETHOD(get__NewEnum)(IUnknown** ppVal)
   {
      HNET_OEM_API_ENTER

       if (!ppVal)
           return E_POINTER;
       if (!m_pE)
           return E_UNEXPECTED;
       return m_pE->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

      HNET_OEM_API_LEAVE
   }

   STDMETHOD(get_Count)(long *pVal)
   {
      HNET_OEM_API_ENTER

      if (!pVal)
          return E_POINTER;
      if (!m_pE)
          return E_UNEXPECTED;
   
      CComPtr<IEnumerator> spE;
      HRESULT hr = m_pE->Clone (&spE);
      if (spE) {
          long lCount = 0;
          spE->Reset();
          while (1) {
              CComVariant cvar;
              HRESULT hr2 = spE->Next (1, &cvar, NULL);
              if (hr2 == S_OK)
                  lCount++;
              else
                  break;
          }
          *pVal = lCount;
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   
};

class ATL_NO_VTABLE CNetSharingEveryConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingEveryConnectionCollection, IEnumNetSharingEveryConnection>, &IID_INetSharingEveryConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingEveryConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPublicConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingPublicConnectionCollection, IEnumNetSharingPublicConnection>, &IID_INetSharingPublicConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPublicConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPrivateConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingPrivateConnectionCollection,IEnumNetSharingPrivateConnection>, &IID_INetSharingPrivateConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPrivateConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPortMappingCollection :
    public IDispatchImpl<TNetCollection<INetSharingPortMappingCollection, IEnumNetSharingPortMapping>, &IID_INetSharingPortMappingCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPortMappingCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};


// props
class ATL_NO_VTABLE CNetSharingPortMappingProps :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetSharingPortMappingProps, &IID_INetSharingPortMappingProps, &LIBID_NETCONLib>
{
private:
   ICS_PORTMAPPING m_IPM;  // not alloc'd

public:
    BEGIN_COM_MAP(CNetSharingPortMappingProps)
        COM_INTERFACE_ENTRY(INetSharingPortMappingProps)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

public:
   CNetSharingPortMappingProps()
   {
      ZeroMemory (&m_IPM, sizeof(ICS_PORTMAPPING));
   }
  ~CNetSharingPortMappingProps()
   {
      FreeData (&m_IPM);
   }


public:  // CNetSharingPortMappingProps
   ICS_PORTMAPPING * GetVolatileRawData (void)
   {
      return &m_IPM;
   }
   HRESULT SetRawData (ICS_PORTMAPPING * pIPM)
   {
      _ASSERT (pIPM);
      if (!pIPM)
         return E_POINTER;

      ICS_PORTMAPPING IPM = {0};
      HRESULT hr = DupData (pIPM, &IPM);
      if (hr == S_OK) {
         FreeData (&m_IPM);
         m_IPM = IPM;  // struct copy
      }
      return S_OK;
   }
   static OLECHAR * DupString (OLECHAR * in)
   {
      OLECHAR * po = NULL;
      if (in) {
         po = (OLECHAR*)malloc ((wcslen (in) + 1)*sizeof(OLECHAR));
         if (po)
            wcscpy(po, in);
      } else {
         // one of pszwTargetName or pszwTargetIPAddress may be blank! so...
         po = (OLECHAR*)malloc (1*sizeof(OLECHAR));
         if (po)
            *po = 0; // ...alloc an emptry string
      }
      return po;
   }
   static HRESULT DupData (ICS_PORTMAPPING * in, ICS_PORTMAPPING * out)
   {
      if (!in) return E_POINTER;

      out->ucIPProtocol   = in->ucIPProtocol;
      out->usExternalPort = in->usExternalPort;
      out->usInternalPort = in->usInternalPort;
      out->dwOptions      = in->dwOptions;
      out->bEnabled       = in->bEnabled;

      out->pszwName            = DupString (in->pszwName);
      out->pszwTargetName      = DupString (in->pszwTargetName);
      out->pszwTargetIPAddress = DupString (in->pszwTargetIPAddress);
      if (!out->pszwName || !out->pszwTargetName || !out->pszwTargetIPAddress) {
         FreeData (out);
         return E_OUTOFMEMORY;
      }
      return S_OK;
   }
   static void FreeData (ICS_PORTMAPPING * pIPM)
   {
      if (pIPM) {
         if (pIPM->pszwName)            free (pIPM->pszwName);
         if (pIPM->pszwTargetName)      free (pIPM->pszwTargetName);
         if (pIPM->pszwTargetIPAddress) free (pIPM->pszwTargetIPAddress);
      }
   }

public:  // INetSharingPortMappingProps

   STDMETHODIMP get_Name           (/*[out, retval]*/ BSTR  * pbstrName);
   STDMETHODIMP get_IPProtocol     (/*[out, retval]*/ UCHAR * pucIPProt);
   STDMETHODIMP get_ExternalPort   (/*[out, retval]*/ long    * pusPort);
   STDMETHODIMP get_InternalPort   (/*[out, retval]*/ long    * pusPort);
   STDMETHODIMP get_Options        (/*[out, retval]*/ long   * pdwOptions);
   STDMETHODIMP get_TargetName     (/*[out, retval]*/ BSTR  * pbstrTargetName);
   STDMETHODIMP get_TargetIPAddress(/*[out, retval]*/ BSTR  * pbstrTargetIPAddress);
   STDMETHODIMP get_Enabled        (/*[out, retval]*/ VARIANT_BOOL * pbool);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\dprtmapc.h ===
// DPrtMapC.h : Declaration of the CDynamicPortMappingCollection

#ifndef __DYNAMICPORTMAPPINGCOLLECTION_H_
#define __DYNAMICPORTMAPPINGCOLLECTION_H_

#include "dportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMappingCollection
class ATL_NO_VTABLE CDynamicPortMappingCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CDynamicPortMappingCollection, &CLSID_DynamicPortMappingCollection>,
	public IDispatchImpl<IDynamicPortMappingCollection, &IID_IDynamicPortMappingCollection, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPService> m_spUPS;

public:
	CDynamicPortMappingCollection()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DYNAMICPORTMAPPINGCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDynamicPortMappingCollection)
	COM_INTERFACE_ENTRY(IDynamicPortMappingCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDynamicPortMappingCollection
public:
   STDMETHOD(Add)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[in]*/ long lInternalPort, /*[in]*/ BSTR bstrInternalClient, /*[in]*/ VARIANT_BOOL bEnabled, /*[in]*/ BSTR bstrDescription, /*[in]*/ long lLeaseDuration, /*[retval][out]*/ IDynamicPortMapping **ppDPM);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown* *pVal);
   STDMETHOD(get_Item)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[out, retval]*/ IDynamicPortMapping ** ppDPM);

// CDynamicPortMappingCollection
public:
   HRESULT Initialize (IUPnPService * pUPS);
};

// quickie enumerator
class CEnumDynamicPortMappingCollection : public IEnumVARIANT
{
private:
   CComPtr<IUPnPService> m_spUPS;
   long m_index, m_refs;

   CEnumDynamicPortMappingCollection ()
   {
      m_refs = 0;
      m_index = 0;
   }
   HRESULT Init (IUPnPService * pUPS, long lIndex)
   {
      m_index = lIndex;
      m_spUPS = pUPS;
      return S_OK;
   }

public:
   static IEnumVARIANT * CreateInstance (IUPnPService * pUPS, long lIndex = 0)
   {
      CEnumDynamicPortMappingCollection * pCEV = new CEnumDynamicPortMappingCollection ();
      if (!pCEV)
         return NULL;
      HRESULT hr = pCEV->Init (pUPS, lIndex);
      if (FAILED(hr)) {
         delete pCEV;
         return NULL;
      }

      IEnumVARIANT * pIEV = NULL;
      pCEV->AddRef();
      pCEV->QueryInterface (IID_IEnumVARIANT, (void**)&pIEV);
      pCEV->Release();
      return pIEV;
   }

// IUnknown
   virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void ** ppvObject)
   {
      NAT_API_ENTER

      if (ppvObject)
         *ppvObject = NULL;
      else
         return E_POINTER;

      HRESULT hr = S_OK;
      if ((riid == IID_IUnknown) ||
         (riid == IID_IEnumVARIANT) ){
         AddRef();
         *ppvObject = (void *)this;
      } else
         hr = E_NOINTERFACE;
      return hr;

      NAT_API_LEAVE
   }
   virtual ULONG STDMETHODCALLTYPE AddRef ()
   {
      return InterlockedIncrement ((PLONG)&m_refs);
   }
   virtual ULONG STDMETHODCALLTYPE Release ()
   {
      ULONG l = InterlockedDecrement ((PLONG)&m_refs);
      if (l == 0)
         delete this;
      return l;
   }

// IEnumVARIANT
   virtual HRESULT STDMETHODCALLTYPE Next (/*[in]*/ ULONG celt, /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar, /*[out]*/ ULONG * pCeltFetched)
   {
      NAT_API_ENTER

      // clear stuff being passed in (just in case)
      if (pCeltFetched)   *pCeltFetched = 0;
      for (ULONG i=0; i<celt; i++)
         VariantInit (&rgVar[i]);

      HRESULT hr = S_OK;

      // get the next celt elements
      for (i=0; i<celt; i++) {

         // ask service for more....
         CComPtr<IDynamicPortMapping> spDPM = NULL;
         hr = CDynamicPortMapping::CreateInstance (m_spUPS, (long)m_index+i, &spDPM);
         if (!spDPM)
            break;

         // can't fail
         V_VT (&rgVar[i]) = VT_DISPATCH;
         spDPM->QueryInterface (__uuidof(IDispatch), 
                               (void**)&V_DISPATCH (&rgVar[i]));
      }
      if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
         hr = S_OK;  // no more; will return S_FALSE below

      if (FAILED(hr)) {
         // on error clear variant array....
         for (ULONG j=0; j<i; j++)
            VariantClear (&rgVar[j]);
         return hr;
      }

      // now update index
      m_index += i;

      // fill out how many we're returning
      if (pCeltFetched)
         *pCeltFetched = i;
      return i < celt ? S_FALSE : S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Skip (/*[in]*/ ULONG celt)
   {
      NAT_API_ENTER

      if (celt + m_index > GetTotal())
         return S_FALSE;
      m_index += celt;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Reset ()
   {
      NAT_API_ENTER

      m_index = 0;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Clone (/*[out]*/ IEnumVARIANT ** ppEnum)
   {
      NAT_API_ENTER

      if (!(*ppEnum = CreateInstance (m_spUPS, m_index)))
         return E_OUTOFMEMORY;
      return S_OK;

      NAT_API_LEAVE
   }

private:
   ULONG GetTotal()
   {
      ULONG ul = 0;
      GetNumberOfEntries (m_spUPS, &ul);
      return ul;
   }
};

#endif //__DYNAMICPORTMAPPINGCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C B A S E . H
//
//  Contents:   Base include file for HNetCfg service. Defines globals.
//
//  Notes:
//
//  Author:     jonburs     23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include "hncatl.h"

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

//
// Return value to use for policy violations
//

#define HN_E_POLICY E_ACCESSDENIED

// Return value to use for sharing configuration conflict

#define HNETERRORSTART          0x200
#define E_ANOTHERADAPTERSHARED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+1)
#define E_ICSADDRESSCONFLICT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+2)

// Buffer sizes to use for notifications

#ifndef NOTIFYFORMATBUFFERSIZE
#define NOTIFYFORMATBUFFERSIZE	1024
#endif

#ifndef HNWCALLBACKBUFFERSIZE
#define HNWCALLBACKBUFFERSIZE  1024
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       H N C A T L . H
//
//  Contents:   Common code for use with ATL.
//
//  Notes:      
//
//  Author:     jonburs     23 May 2000 (from shaunco   22 Sep 1997)
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _HNCATL_H_
#define _HNCATL_H_

//
// This file should be included *after* your standard ATL include sequence.
//
//      #include <atlbase.h>
//      extern CComModule _Module;
//      #include <atlcom.h>
//      #include "hncatl.h"      <------
//
// We cannot directly include that sequence here because _Module may be
// derived from CComModule as opposed to an instance of it.
//

//
// We have our own version of AtlModuleRegisterServer coded here
// because the former brings in oleaut32.dll so it can register
// type libraries.  We don't care to have a type library registered
// so we can avoid the whole the mess associated with oleaut32.dll.
//

inline
HRESULT
NcAtlModuleRegisterServer(
    _ATL_MODULE* pM
    )
{
    /*AssertH (pM);
    AssertH(pM->m_hInst);
    AssertH(pM->m_pObjMap);*/

    HRESULT hr = S_OK;

    for (_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
         pEntry->pclsid;
         pEntry++)
    {
        if (pEntry->pfnGetObjectDescription() != NULL)
        {
            continue;
        }

        hr = pEntry->pfnUpdateRegistry(TRUE);
        if (FAILED(hr))
        {
            break;
        }
    }

    // TraceError ("NcAtlModuleRegisterServer", hr);
    return hr;
}

#endif // _HNCATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncaenum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C A E N U M . H
//
//  Contents:   Array enumerator
//
//  Notes:
//
//  Author:     maiken 13 Dec 2000
//
//----------------------------------------------------------------------------

//
// This simple template acts as an enumerator for an array of COM pointers.
//


template<
    class EnumInterface,
    class ItemInterface
    >
class CHNCArrayEnum :
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface
{
private:
    typedef CHNCArrayEnum<EnumInterface, ItemInterface> _ThisClass;

    //
    // The array of pointers we're holding
    //
    ItemInterface           **m_rgItems;

    //
    // Our position counter
    //
    ULONG                   m_pos;

    //
    // Number of pointers in m_rgItems
    //
    ULONG                   m_numItems;

protected:

    VOID
    SetPos(
        ULONG               pos
        )
    {
        _ASSERT( pos < m_numItems );
        m_pos = pos;
    };

public:

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Object Creation
    //

    CHNCArrayEnum()
    {
        m_rgItems = NULL;
        m_pos = 0L;
        m_numItems = 0L;
    };

    HRESULT
    Initialize(
        ItemInterface       **pItems,
        ULONG               countItems
        )
    {
        HRESULT             hr = S_OK;

        // pItems can be NULL to indicate an enumeration of nothing
        if( NULL != pItems )
        {
            _ASSERT( countItems > 0L );
            m_rgItems = new ItemInterface*[countItems];

            if( NULL == m_rgItems )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                ULONG       i;

                for( i = 0L; i < countItems; i++ )
                {
                    m_rgItems[i] = pItems[i];
                    m_rgItems[i]->AddRef();
                }

                m_numItems = countItems;
            }
        }

        return hr;
    };

    //
    // Object Destruction
    //

    HRESULT
    FinalRelease()
    {
        if( m_rgItems != NULL )
        {
            ULONG           i;

            for( i = 0L; i < m_numItems; i++ )
            {
                m_rgItems[i]->Release();
            }

            delete [] m_rgItems;
        }

        return S_OK;
    };

    //
    // EnumInterface methods
    //

    STDMETHODIMP
    Next(
        ULONG               cElt,
        ItemInterface       **rgElt,
        ULONG               *pcEltFetched
        )

    {
        HRESULT             hr = S_OK;
        ULONG               ulCopied = 0L;

        if (NULL == rgElt)
        {
            hr = E_POINTER;
        }
        else if (0 == cElt)
        {
            hr = E_INVALIDARG;
        }
        else if (1 != cElt && NULL == pcEltFetched)
        {
            hr = E_POINTER;
        }

        if( S_OK == hr )
        {
            ulCopied = 0L;

            // Copy until we run out of items to copy;
            while( (m_pos < m_numItems) && (ulCopied < cElt) )
            {
                rgElt[ulCopied] = m_rgItems[m_pos];
                rgElt[ulCopied]->AddRef();
                m_pos++;
                ulCopied++;
            }

            if( ulCopied == cElt )
            {
                // Copied all the requested items
                hr = S_OK;
            }
            else
            {
                // Copied a subset of the requested items (or none)
                hr = S_FALSE;
            }

            if( pcEltFetched != NULL )
            {
                *pcEltFetched = ulCopied;
            }
        }

        return hr;
    };

    STDMETHODIMP
    Clone(
        EnumInterface **ppEnum
        )

    {
        HRESULT                     hr = S_OK;

        if (NULL == ppEnum)
        {
            hr = E_POINTER;
        }
        else
        {
            CComObject<_ThisClass>      *pNewEnum;

            //
            // Create an initialized, new instance of ourselves
            //

            hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);

            if (SUCCEEDED(hr))
            {
                pNewEnum->AddRef();

                hr = pNewEnum->Initialize(m_rgItems, m_numItems);

                if (SUCCEEDED(hr))
                {
                    pNewEnum->SetPos( m_pos );

                    hr = pNewEnum->QueryInterface(
                            IID_PPV_ARG(EnumInterface, ppEnum)
                            );

                    //
                    // This QI should never fail, unless we were given
                    // bogus template arguments.
                    //

                    _ASSERT(SUCCEEDED(hr));
                }

                pNewEnum->Release();
            }
        }

        return hr;
    };

    //
    // Skip and Reset simply delegate to the contained enumeration.
    //

    STDMETHODIMP
    Reset()

    {
        m_pos = 0L;;
        return S_OK;
    };

    STDMETHODIMP
    Skip(
        ULONG cElt
        )

    {
        HRESULT         hr;

        if( m_pos + cElt < m_numItems )
        {
            m_pos += cElt;
            hr = S_OK;
        }
        else
        {
            m_pos = m_numItems - 1;
            hr = S_FALSE;
        }

        return hr;
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncdbg.h ===
//depot/private/homenet/net/homenet/Config/inc/HNCDbg.h#2 - edit change 5763 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C D B G . H
//
//  Contents:   Home Networking Configuration debug routines
//
//  Notes:
//
//  Author:     jonburs 13 June 2000
//
//----------------------------------------------------------------------------

#pragma once

//
// The standard CRT assertions do bad things such as displaying message boxes.
// These macros will just print stuff out to the debugger. If you do want the
// standard CRT assertions, just define _DEBUG before including this header
//

#ifdef DBG   // checked build
#ifndef _DEBUG // DEBUG_CRT is not enabled.

#undef _ASSERT
#undef _ASSERTE
#define BUF_SIZE 512

#define _ASSERT(expr)                   \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("HNetCfg: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)

#define _ASSERTE(expr)                  \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("HNetCfg: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N M R E S . H
//
//  Contents:   Master resource header for HNetCfg
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
#define IDS_SECURITYNOTIFICATIONTEXT		22000
#define IDS_SECURITYNOTIFICATIONTITLE		22001

#define IDS_SHARINGCONFIGURATIONUNAVAIL     22002
#define IDS_DISABLEFIREWALLFAIL             22003
#define IDS_DESTROYBRIDGEFAIL               22004
#define IDS_DISABLEICS                      22005
#define IDS_NEWBRIDGECREATED                22006
#define IDS_NEWBRIDGEFAILED                 22007
#define IDS_NEWPRIVATECONNECTIONCREATED     22008                  
#define IDS_NEWPRIVATECONNECTIONFAILED      22009
#define IDS_SHARINGCFGFORADAPTERUNAVAIL     22010
#define IDS_NEWPUBLICCONNECTIONCREATED      22011
#define IDS_NEWPUBLICCONNECTIONFAILED       22012
#define IDS_FIREWALLCONNECTION				22013
#define IDS_FIREWALLCONNECTIONFAILED		22014
#define IDS_WSAERRORDURINGDETECTION			22015
#define IDS_SENDARPERRORDURINGDETECTION     22016
#define IDS_ICSADDRESSCONFLICTDETECTED      22017
#define IDS_ADD_REMOVE                      22018
#define IDS_REMOVE_ALG_PLUGIN               22019

//+---------------------------------------------------------------------------
// Dialog ID's
//

#define IDD_SecurityNotification			22500


//+---------------------------------------------------------------------------
// Control ID's
//

#define IDC_TXT_NOTIFICATION				22600
#define IDC_BTN_MOREINFO					22601
#define IDC_CHK_DISABLESHARESECURITYWARN	22602

//+---------------------------------------------------------------------------
// Registry resources
//	 

#define IDR_HNETCFG     100
#define IDR_HNETMOF     101
#define IDR_SHAREMGR    102
#define IDR_UPNPNAT     103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncfgmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C F G M G R . H
//
//  Contents:   CHNetCfgMgr declarations
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetCfgMgr :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHNetCfgMgr, &CLSID_HNetCfgMgr>,
    public IHNetCfgMgr,
    public IHNetBridgeSettings,
    public IHNetFirewallSettings,
    public IHNetIcsSettings,
    public IHNetProtocolSettings

{
protected:

    //
    // Connection to \\.\Root\Microsoft\HomeNet WMI namespace. Obtained
    // through IWbemLocator::ConnectServer
    //

    IWbemServices *m_piwsHomenet;

    //
    // Policy check object
    //

    INetConnectionUiUtilities *m_pNetConnUiUtil;

    //
    // Netman update object
    //

    INetConnectionHNetUtil *m_pNetConnHNetUtil;

    //
    // Commonly used BSTRs.
    //

    BSTR m_bstrWQL;

    //
    // Copies an HNet_FirewallLoggingSettings instance to an
    // HNET_FW_LOGGING_SETTINGS struct
    //

    HRESULT
    CopyLoggingInstanceToStruct(
        IWbemClassObject *pwcoInstance,
        HNET_FW_LOGGING_SETTINGS *pfwSettings
        );

    //
    // Copies an HNET_FW_LOGGING_SETTINGS struct to
    // an HNet_FirewallLoggingSettings instance
    //

    HRESULT
    CopyStructToLoggingInstance(
        HNET_FW_LOGGING_SETTINGS *pfwSettings,
        IWbemClassObject *pwcoInstance
        );

    //
    // Installs the bridge protocol and miniport
    //

    HRESULT
    InstallBridge(
        GUID *pguid,
        INetCfg *pnetcfgExisting
        );

    //
    // Creates the appropriate instances for a connection that there is
    // no record of in the store. The returned instances must be commited
    // (through IWbemServices::PutInstance)
    //

    HRESULT
    CreateConnectionAndPropertyInstances(
        GUID *pGuid,
        BOOLEAN fLanConnection,
        LPCWSTR pszwName,
        IWbemClassObject **ppwcoConnection,
        IWbemClassObject **ppwcoProperties
        );

    //
    // Helper routine to perform policy checks. Returns
    // TRUE if this action is prohibited.
    //

    BOOLEAN
    ProhibitedByPolicy(
        DWORD dwPerm
        );

    //
    // Helper routine to update netman that some homenet
    // property changed
    //

    HRESULT
    UpdateNetman();

public:

    BEGIN_COM_MAP(CHNetCfgMgr)
        COM_INTERFACE_ENTRY(IHNetCfgMgr)
        COM_INTERFACE_ENTRY(IHNetBridgeSettings)
        COM_INTERFACE_ENTRY(IHNetFirewallSettings)
        COM_INTERFACE_ENTRY(IHNetIcsSettings)
        COM_INTERFACE_ENTRY(IHNetProtocolSettings)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_HNETCFG)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //

    CHNetCfgMgr()
    {
        m_piwsHomenet = NULL;
        m_bstrWQL = NULL;
        m_pNetConnUiUtil = NULL;
        m_pNetConnHNetUtil = NULL;
    };

    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // IHNetCfgMgr methods
    //

    STDMETHODIMP
    GetIHNetConnectionForINetConnection(
        INetConnection *pNetConnection,
        IHNetConnection **ppHNetConnection
        );

    STDMETHODIMP
    GetIHNetConnectionForGuid(
        GUID *pGuid,
        BOOLEAN fLanConnection,
        BOOLEAN fCreateEntries,
        IHNetConnection **ppHNetConnection
        );

    //
    // IHNetBridgeSettings methods
    //

    STDMETHODIMP
    EnumBridges(
        IEnumHNetBridges **ppEnum
        );

    STDMETHODIMP
    CreateBridge(
        IHNetBridge **ppHNetBridge,
        INetCfg *pnetcfgExisting
        );

    STDMETHODIMP
    DestroyAllBridges(
        ULONG *pcBridges,
        INetCfg *pnetcfgExisting
        );

    //
    // IHNetFirewallSettings methods
    //

    STDMETHODIMP
    EnumFirewalledConnections(
        IEnumHNetFirewalledConnections **ppEnum
        );

    STDMETHODIMP
    GetFirewallLoggingSettings(
        HNET_FW_LOGGING_SETTINGS **ppSettings
        );

    STDMETHODIMP
    SetFirewallLoggingSettings(
        HNET_FW_LOGGING_SETTINGS *pSettings
        );

    STDMETHODIMP
    DisableAllFirewalling(
        ULONG *pcFirewalledConnections
        );

    //
    // IHNetIcsSettings methods
    //

    STDMETHODIMP
    EnumIcsPublicConnections(
        IEnumHNetIcsPublicConnections **ppEnum
        );

    STDMETHODIMP
    EnumIcsPrivateConnections(
        IEnumHNetIcsPrivateConnections **ppEnum
        );

    STDMETHODIMP
    DisableIcs(
        ULONG *pcIcsPublicConnections,
        ULONG *pcIcsPrivateConnections
        );

    STDMETHODIMP
    GetPossiblePrivateConnections(
        IHNetConnection *pConn,
        ULONG *pcPrivateConnections,
        IHNetConnection **pprgPrivateConnections[],
        LONG *pxCurrentPrivate
        );

    STDMETHODIMP
    GetAutodialSettings(
        BOOLEAN *pfAutodialEnabled
        );

    STDMETHODIMP
    SetAutodialSettings(
        BOOLEAN fEnableAutodial
        );

    STDMETHODIMP
    GetDhcpEnabled(
        BOOLEAN *pfDhcpEnabled
        );

    STDMETHODIMP
    SetDhcpEnabled(
        BOOLEAN fEnableDhcp
        );

    STDMETHODIMP
    GetDhcpScopeSettings(
        DWORD *pdwScopeAddress,
        DWORD *pdwScopeMask
        );

    STDMETHODIMP
    SetDhcpScopeSettings(
        DWORD dwScopeAddress,
        DWORD dwScopeMask
        );

    STDMETHODIMP
    EnumDhcpReservedAddresses(
        IEnumHNetPortMappingBindings **ppEnum
        );

    STDMETHODIMP
    GetDnsEnabled(
        BOOLEAN *pfDnsEnabled
        );

    STDMETHODIMP
    SetDnsEnabled(
        BOOLEAN fEnableDns
        );

    //
    // IHNetProtocolSettings methods
    //

    STDMETHODIMP
    EnumApplicationProtocols(
        BOOLEAN fEnabledOnly,
        IEnumHNetApplicationProtocols **ppEnum
        );

    STDMETHODIMP
    CreateApplicationProtocol(
        OLECHAR *pszwName,
        UCHAR ucOutgoingIPProtocol,
        USHORT usOutgoingPort,
        USHORT uscResponses,
        HNET_RESPONSE_RANGE rgResponses[],
        IHNetApplicationProtocol **ppProtocol
        );

    STDMETHODIMP
    EnumPortMappingProtocols(
        IEnumHNetPortMappingProtocols **ppEnum
        );

    STDMETHODIMP
    CreatePortMappingProtocol(
        OLECHAR *pszwName,
        UCHAR ucIPProtocol,
        USHORT usPort,
        IHNetPortMappingProtocol **ppProtocol
        );

    STDMETHODIMP
    FindPortMappingProtocol(
        GUID *pGuid,
        IHNetPortMappingProtocol **ppProtocol
        );
    
};

class CHNetCfgMgrChild : public CHNetCfgMgr
{

protected:

    // Do our initialization work in Initialize() instead of
    // FinalConstruct
    HRESULT
    FinalConstruct()
    {
        // Do nothing
        return S_OK;
    }

public:

    HRESULT
    Initialize(
        IWbemServices       *piwsHomenet
        )
    {
        HRESULT             hr = S_OK;

        //
        // Allocate the commonly used BSTRs
        //

        m_bstrWQL = SysAllocString(c_wszWQL);

        if (NULL == m_bstrWQL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_piwsHomenet = piwsHomenet;
            m_piwsHomenet->AddRef();
        }

        return hr;
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncenum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C E N U M . H
//
//  Contents:   Generic WMI enumerator template
//
//  Notes:
//
//  Author:     jonburs 20 June 2000
//
//----------------------------------------------------------------------------

template<
    class EnumInterface,
    class ItemInterface,
    class WrapperClass
    >
class CHNCEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface
{
private:
    typedef CHNCEnum<EnumInterface, ItemInterface, WrapperClass> _ThisClass;

    //
    // The IEnumWbemClassObject we're wrapping
    //

    IEnumWbemClassObject *m_pwcoEnum;

    //
    // The IWbemServices for our namespace
    //

    IWbemServices *m_pwsNamespace;

public:

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Object Creation
    //

    CHNCEnum()
    {
        m_pwcoEnum = NULL;
        m_pwsNamespace = NULL;
    };

    HRESULT
    Initialize(
        IWbemServices *pwsNamespace,
        IEnumWbemClassObject *pwcoEnum
        )
    {
        _ASSERT(NULL == m_pwsNamespace);
        _ASSERT(NULL == m_pwcoEnum);
        _ASSERT(NULL != pwsNamespace);
        _ASSERT(NULL != pwcoEnum);

        m_pwcoEnum = pwcoEnum;
        m_pwcoEnum->AddRef();
        m_pwsNamespace = pwsNamespace;
        m_pwsNamespace->AddRef();

        return S_OK;
    };

    //
    // Object Destruction
    //

    HRESULT
    FinalRelease()
    {
        if (NULL != m_pwcoEnum)
        {
            m_pwcoEnum->Release();
        }

        if (NULL != m_pwsNamespace)
        {
            m_pwsNamespace->Release();
        }

        return S_OK;
    };

    //
    // EnumInterface methods
    //
    
    STDMETHODIMP
    Next(
        ULONG cElt,
        ItemInterface **rgElt,
        ULONG *pcEltFetched
        )
        
    {
        HRESULT hr = S_OK;
        ULONG cInstancesFetched = 0;
        IWbemClassObject **rgpwcoInstances = NULL;
        CComObject<WrapperClass> *pWrapper = NULL;
        LONG i;

        _ASSERT(NULL != m_pwcoEnum);

        if (NULL == rgElt)
        {
            hr = E_POINTER;
        }
        else if (0 == cElt)
        {
            hr = E_INVALIDARG;
        }
        else if (1 != cElt && NULL == pcEltFetched)
        {
            hr = E_POINTER;
        }

        if (S_OK == hr)
        {
            //
            // Zero the output array
            //

            ZeroMemory(rgElt, cElt * sizeof(ItemInterface*));
            
            //
            // Allocate enough memory to hold pointers to the instances we
            // were asked to fetch.
            //

            rgpwcoInstances = new IWbemClassObject*[cElt];
            if (NULL != rgpwcoInstances)
            {
                ZeroMemory(rgpwcoInstances, sizeof(IWbemClassObject*) * cElt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            //
            // Grab the requested number of instances from the contained
            // WMI enumeration.
            //

            hr = m_pwcoEnum->Next(
                    WBEM_INFINITE,
                    cElt,
                    rgpwcoInstances,
                    &cInstancesFetched
                    );
        }

        if (SUCCEEDED(hr))
        {
            //
            // For each instance we retrieved, create the wrapper
            // object.
            //

            for (i = 0;
                 static_cast<ULONG>(i) < cInstancesFetched;
                 i++)
            {
                hr = CComObject<WrapperClass>::CreateInstance(&pWrapper);

                if (SUCCEEDED(hr))
                {
                    pWrapper->AddRef();
                    hr = pWrapper->Initialize(
                            m_pwsNamespace,
                            rgpwcoInstances[i]
                            );
                
                    if (SUCCEEDED(hr))
                    {
                        //
                        // QI for the desired interface, and place into
                        // the output array
                        //

                        hr = pWrapper->QueryInterface(
                                IID_PPV_ARG(ItemInterface, &rgElt[i])
                                );

                        //
                        // This can only fail if we were given incorrect
                        // template arguments.
                        //
                        
                        _ASSERT(SUCCEEDED(hr));
                    }

                    pWrapper->Release();
                }

                if (FAILED(hr))
                {
                    break;
                }
            }

            if (FAILED(hr))
            {
                //
                // Something went wrong, and we destroy all of the objects
                // we just created and QI'd. (The position of the last object
                // created is one less than the current value of i.)
                //

                for (i-- ; i >= 0; i--)
                {
                    if (NULL != rgElt[i])
                    {
                        rgElt[i]->Release();
                    }
                }
            }

            //
            // Release all of the instances we retrieved
            //

            for (ULONG j = 0; j < cInstancesFetched; j++)
            {
                if (NULL != rgpwcoInstances[j])
                {
                    rgpwcoInstances[j]->Release();
                }
            }
        }

        //
        // If necessary, release the memory we used to hold the
        // instance pointers.
        //

        if (NULL != rgpwcoInstances)
        {
            delete [] rgpwcoInstances;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Set the number of items we retrieved
            //

            if (NULL != pcEltFetched)
            {
                *pcEltFetched = cInstancesFetched;
            }

            //
            // Normalize return value
            //

            if (cInstancesFetched == cElt)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }

        return hr;
    };

    STDMETHODIMP
    Clone(
        EnumInterface **ppEnum
        )

    {
        HRESULT hr = S_OK;
        IEnumWbemClassObject *pwcoClonedEnum;
        CComObject<_ThisClass> *pNewEnum;

        if (NULL == ppEnum)
        {
            hr = E_POINTER;
        }
        else
        {
            //
            // Attempt to clone the embedded enumeration.
            //

            pwcoClonedEnum = NULL;
            hr = m_pwcoEnum->Clone(&pwcoClonedEnum);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create an initialized a new instance of ourselves
            //

            hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);
            if (SUCCEEDED(hr))
            {
                pNewEnum->AddRef();
                hr = pNewEnum->Initialize(m_pwsNamespace, pwcoClonedEnum);

                if (SUCCEEDED(hr))
                {
                    hr = pNewEnum->QueryInterface(
                            IID_PPV_ARG(EnumInterface, ppEnum)
                            );

                    //
                    // This QI should never fail, unless we were given
                    // bogus template arguments.
                    //
                    
                    _ASSERT(SUCCEEDED(hr));
                }

                pNewEnum->Release();
            }

            //
            // Release the cloned enum. New enum object will have
            // AddReffed it...
            //

            pwcoClonedEnum->Release();
        }

        return hr;
    };

    //
    // Skip and Reset simply delegate to the contained enumeration.
    //

    STDMETHODIMP
    Reset()
    
    {
        _ASSERT(NULL != m_pwcoEnum);
        return m_pwcoEnum->Reset();
    };

    STDMETHODIMP
    Skip(
        ULONG cElt
        )
        
    {
        _ASSERT(NULL != m_pwcoEnum);
        return m_pwcoEnum->Skip(WBEM_INFINITE, cElt);
    };   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C U T I L . H
//
//  Contents:   Home Networking Configuration Utility Routines
//
//  Notes:
//
//  Author:     jonburs 13 June 2000
//
//----------------------------------------------------------------------------

#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

BOOLEAN
ApplicationProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usOutgoingPort,
    UCHAR ucOutgoingIPProtocol
    );

HRESULT
HrFromLastWin32Error();

HRESULT
BuildAndString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildAssociatorsQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszAssocClass
    );

HRESULT
BuildEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildEscapedQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildReferencesQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszTargetClass
    );

HRESULT
BuildSelectQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszProperties,
    LPCWSTR pwszFromClause,
    LPCWSTR pwszWhereClause
    );

BOOLEAN
ConnectionIsBoundToTcp(
    PIP_INTERFACE_INFO pIpInfoTable,
    GUID *pConnectionGuid
    );

HRESULT
ConvertResponseRangeArrayToInstanceSafearray(
    IWbemServices *piwsNamespace,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    SAFEARRAY **ppsa
    );

HRESULT
CopyResponseInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_RESPONSE_RANGE *pResponse
    );

HRESULT
CopyStructToResponseInstance(
    HNET_RESPONSE_RANGE *pResponse,
    IWbemClassObject *pwcoInstance
    );

HRESULT
DeleteWmiInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    );

LPWSTR
EscapeString(
    LPCWSTR wsz
    );

HRESULT
InitializeNetCfgForWrite(
    OUT INetCfg             **ppnetcfg,
    OUT INetCfgLock         **ppncfglock
    );

void
UninitializeNetCfgForWrite(
    IN INetCfg              *pnetcfg,
    IN INetCfgLock          *pncfglock
    );

HRESULT
FindAdapterByGUID(
    IN INetCfg              *pnetcfg,
    IN GUID                 *pguid,
    OUT INetCfgComponent    **ppncfgcomp
    );

HRESULT
BindOnlyToBridge(
    IN INetCfgComponent     *pnetcfgcomp
    );

HRESULT
FindINetConnectionByGuid(
    GUID *pGuid,
    INetConnection **ppNetCon
    );

HRESULT
GetBridgeConnection(
    IN IWbemServices        *piwsHomenet,
    OUT IHNetBridge        **pphnetBridge
    );

HRESULT
GetIHNetConnectionForNetCfgComponent(
    IN IWbemServices        *piwsHomenet,
    IN INetCfgComponent     *pnetcfgcomp,
    IN BOOLEAN               fLanConnection,
    IN REFIID                iid,
    OUT PVOID               *ppv
    );

HRESULT
GetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN *pfBoolean
    );

HRESULT
GetConnectionInstanceByGuid(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection
    );

HRESULT
GetConnAndPropInstancesByGuid(
    IWbemServices *piwsNamespace,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetConnAndPropInstancesForHNC(
    IWbemServices *piwsNamespace,
    IHNetConnection *pConn,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetPhonebookPathFromRasNetcon(
    INetConnection *pConn,
    LPWSTR *ppwstr
    );

HRESULT
GetPortMappingBindingInstance(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    BSTR bstrConnectionPath,
    BSTR bstrProtocolPath,
    USHORT usPublicPort,
    IWbemClassObject **ppInstance
    );

HRESULT
GetPropInstanceFromConnInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetWmiObjectFromPath(
    IWbemServices *piwsNamespace,
    BSTR bstrPath,
    IWbemClassObject **pwcoInstance
    );

HRESULT
GetWmiPathFromObject(
    IWbemClassObject *pwcoInstance,
    BSTR *pbstrPath
    );

HRESULT
MapGuidStringToAdapterIndex(
    LPCWSTR pwszGuid,
    ULONG *pulIndex
    );

HRESULT
HostAddrToIpPsz(
    DWORD   dwIPAddress,
    LPWSTR* ppszwNewStr
    );

DWORD
IpPszToHostAddr(
    LPCWSTR cp
    );

BOOLEAN
IsRoutingProtocolInstalled(
    ULONG ulProtocolId
    );

BOOLEAN
IsServiceRunning(
    LPCWSTR pwszServiceName
    );

HRESULT
OpenRegKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    );

BOOLEAN
PortMappingProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usPort,
    UCHAR ucIPProtocol
    );

HRESULT
QueryRegValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    );

HRESULT
ReadDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    );

HRESULT
RetrieveSingleInstance(
    IWbemServices *piwsNamespace,
    const OLECHAR *pwszClass,
    BOOLEAN fCreate,
    IWbemClassObject **ppwcoInstance
    );

HRESULT
SetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN fBoolean
    );

VOID
SetProxyBlanket(
    IUnknown *pUnk
    );

HRESULT
SpawnNewInstance(
    IWbemServices *piwsNamespace,
    LPCWSTR wszClass,
    IWbemClassObject **ppwcoInstance
    );

DWORD
StartOrUpdateService(
    VOID
    );

VOID
StopService(
    VOID
    );

HRESULT
UpdateOrStopService(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    DWORD dwControlCode
    );

VOID
UpdateService(
    DWORD dwControlCode
    );

VOID
ValidateFinishedWCOEnum(
    IWbemServices *piwsNamespace,
    IEnumWbemClassObject *pwcoEnum
    );

HRESULT
SendPortMappingListChangeNotification();

HRESULT
SignalModifiedConnection(
    GUID            *pGUID
    );

HRESULT
SignalNewConnection(
    GUID            *pGUID
    );

HRESULT
SignalDeletedConnection(
    GUID            *pGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnfwconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N F W C O N N . H
//
//  Contents:   CHNFWConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNFWConn :
    public CHNetConn,
    public IHNetFirewalledConnection
{       
public:

    BEGIN_COM_MAP(CHNFWConn)
        COM_INTERFACE_ENTRY(IHNetFirewalledConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetFirewalledConnection methods
    //

    STDMETHODIMP
    Unfirewall();
};

typedef CHNCEnum<
            IEnumHNetFirewalledConnections,
            IHNetFirewalledConnection,
            CHNFWConn
            >
        CEnumHNetFirewalledConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnetconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N E T C O N N. H
//
//  Contents:   CHNetConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetConn :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetConnection
{
protected:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to the WMI instance for the connection
    //

    BSTR m_bstrConnection;

    //
    // Path to the WMI instance for the connection properties
    //

    BSTR m_bstrProperties;  

    //
    // Pointer to our corresponding INetConnection. May
    // be null, depending on how we were created.
    //
    
    INetConnection *m_pNetConn;

    //
    // Cached connection type. Always valid and read-only
    // after construction
    //

    BOOLEAN m_fLanConnection;

    //
    // Cached GUID. Will be NULL until someone (possibly internal)
    // asks for our GUID.
    //

    GUID *m_pGuid;

    //
    // Cached connection name. Will be NULL until someone
    // asks for our name
    //

    LPWSTR m_wszName;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Policy check helper object
    //

    INetConnectionUiUtilities *m_pNetConnUiUtil;

    //
    // Netman update object
    //

    INetConnectionHNetUtil *m_pNetConnHNetUtil;

    //
    // Netman UI refresh object
    //

    INetConnectionRefresh *m_pNetConnRefresh;

    //
    // Retrieves the HNet_FwIcmpSettings associated with
    // this connection
    //
    
    HRESULT
    GetIcmpSettingsInstance(
        IWbemClassObject **ppwcoSettings
        );

    //
    // Copies from an IWbemClassObject representing an ICMP settings
    // instance to an HNET_FW_ICMP_SETTINGS structure
    //

    HRESULT
    CopyIcmpSettingsInstanceToStruct(
        IWbemClassObject *pwcoSettings,
        HNET_FW_ICMP_SETTINGS *pSettings
        );

    //
    // Copies from an HNET_FW_ICMP_SETTINGS structure to
    // an IWbemClassObject representing an ICMP settings
    // instance.
    //

    HRESULT
    CopyStructToIcmpSettingsInstance(
        HNET_FW_ICMP_SETTINGS *pSettings,
        IWbemClassObject *pwcoSettings
        );

    //
    // Ensures that all port mapping bindings have been created
    // for this connection. Called when EnumPortMappings is
    // called on the connection, and fEnabledOnly is false.
    //

    HRESULT
    CreatePortMappingBindings();

    //
    // Copies our property instance into an allocated structure
    //

    HRESULT
    InternalGetProperties(
        IWbemClassObject *pwcoProperties,
        HNET_CONN_PROPERTIES *pProperties
        );

    //
    // Configures the connection to be the private adapter
    //

    HRESULT
    SetupConnectionAsPrivateLan();

    //
    // Saves the current IP configuration into the store
    //

    HRESULT
    BackupIpConfiguration();

    //
    // Set's the IP configuration to what was saved in the store
    //

    HRESULT
    RestoreIpConfiguration();

    //
    // Open a registry key to our IP settings
    //

    HRESULT
    OpenIpConfigurationRegKey(
        ACCESS_MASK DesiredAccess,
        HANDLE *phKey
        );

    //
    // Retrieves our GUID. The caller must NOT free the pointer
    // that is returned.
    
    HRESULT
    GetGuidInternal(
        GUID **ppGuid
        );

    //
    // Retrieves the underlying connection object
    //

    HRESULT
    GetConnectionObject(
        IWbemClassObject **ppwcoConnection
        );

    //
    // Retrieves the underlying connection properties object
    //

    HRESULT
    GetConnectionPropertiesObject(
        IWbemClassObject **ppwcoProperties
        );

    //
    // Helper routine to perform policy checks. Returns
    // TRUE if this action is prohibited.
    //

    BOOLEAN
    ProhibitedByPolicy(
        DWORD dwPerm
        );

    //
    // Helper routine to update netman that some homenet
    // property changed
    //

    HRESULT
    UpdateNetman();

    //
    // Creates the association between the connection and the
    // ICMP settings block
    //

    HRESULT
    CreateIcmpSettingsAssociation(
        BSTR bstrIcmpSettingsPath
        );

    //
    // Obtains the name of a RAS connection from the
    // appropriate phonebook.
    //

    HRESULT
    GetRasConnectionName(
        OLECHAR **ppszwConnectionName
        );

    //
    // Helper routine to inform netman that a change requiring
    // a UI refresh has occured.
    //

    HRESULT
    RefreshNetConnectionsUI(
        VOID
        );


public:

    BEGIN_COM_MAP(CHNetConn)
        COM_INTERFACE_ENTRY(IHNetConnection)
    END_COM_MAP()

    //
    // Inline constructor
    //

    CHNetConn()
    {
        m_piwsHomenet = NULL;
        m_bstrConnection = NULL;
        m_bstrProperties = NULL;
        m_pNetConn = NULL;
        m_fLanConnection = FALSE;
        m_pGuid = NULL;
        m_wszName = NULL;
        m_bstrWQL = NULL;
        m_pNetConnUiUtil = NULL;
        m_pNetConnHNetUtil = NULL;
        m_pNetConnRefresh = NULL;
    };

    //
    // ATL Methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Ojbect initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoProperties
        );

    HRESULT
    InitializeFromConnection(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection
        );

    HRESULT
    InitializeFromInstances(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection,
        IWbemClassObject *pwcoProperties
        );

    HRESULT
    InitializeFull(
        IWbemServices *piwsNamespace,
        BSTR bstrConnection,
        BSTR bstrProperties,
        BOOLEAN fLanConnection
        );

    HRESULT
    SetINetConnection(
        INetConnection *pConn
        );

    //
    // IHNetConnection methods
    //

    STDMETHODIMP
    GetINetConnection(
        INetConnection **ppNetConnection
        );

    STDMETHODIMP
    GetGuid(
        GUID **ppGuid
        );

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    GetRasPhonebookPath(
        OLECHAR **ppszwPath
        );

    STDMETHODIMP
    GetProperties(
        HNET_CONN_PROPERTIES **ppProperties
        );

    STDMETHODIMP
    GetControlInterface(
        REFIID iid,
        void **ppv
        );

    STDMETHODIMP
    Firewall(
        IHNetFirewalledConnection **ppFirewalledConn
        );

    STDMETHODIMP
    SharePublic(
        IHNetIcsPublicConnection **ppIcsPublicConn
        );

    STDMETHODIMP
    SharePrivate(
        IHNetIcsPrivateConnection **ppIcsPrivateConn
        );

    STDMETHODIMP
    EnumPortMappings(
        BOOLEAN fEnabledOnly,
        IEnumHNetPortMappingBindings **ppEnum
        );

    STDMETHODIMP
    GetBindingForPortMappingProtocol(
        IHNetPortMappingProtocol *pProtocol,
        IHNetPortMappingBinding **ppBinding
        );